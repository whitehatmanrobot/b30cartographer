s designed to indicate to Lsa if the new*
 * password is acceptable.  We will simply return TRUE (indicating it*
 * is acceptable) and do nothing.                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN PasswordFilter
BOOLEAN __stdcall PasswordFilter(PUNICODE_STRING AccountName, PUNICODE_STRING FullName,
						PUNICODE_STRING Password, BOOLEAN SetOperation)
{
	return TRUE;
}
//END PasswordFilter


/***************************/
/* Internal DLL functions. */
/***************************/

static BOOL Initialize(void)
{
    return TRUE;
}

static BOOL Terminate(BOOL procterm)
{

	if (!procterm)
            return TRUE;

/* XXX Do stuff here */

	return TRUE;
}


BOOL WINAPI
DllMain(HINSTANCE hinst, DWORD reason, VOID *rsvd)
/*++

Routine description:

    Dynamic link library entry point.  Does nothing meaningful.


Arguments:

    hinst  = handle for the DLL
    reason = code indicating reason for call
    rsvd   = for process attach: non-NULL => process startup
     		for process detach: non-NULL => process termination

Return value:

    status = success/failure

Side effects:

    None

--*/
 
{
	switch (reason) {

	case DLL_PROCESS_ATTACH:
	{
		_CRT_INIT(hinst, reason, rsvd); 
		return Initialize();
		break;
	}

	case DLL_PROCESS_DETACH:
	{
		BOOL bStat = Terminate(rsvd != NULL);
		_CRT_INIT(hinst, reason, rsvd); 
        return bStat;
		break;
	}

	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		return TRUE;

	default:
		return FALSE;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Midl allocate memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_FAR * __RPC_USER
   midl_user_allocate(
      size_t                 len )
{
   return new char[len];
}

///////////////////////////////////////////////////////////////////////////////
// Midl free memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_USER
   midl_user_free(
      void __RPC_FAR       * ptr )
{
   delete [] ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\domaincontainer.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "DomainContainer.h"

#include "Error.h"
#include "AdsiHelpers.h"
#include "NameCracker.h"

#include <map>
#include <memory>
#include <string>
#include <LM.h>
#include <DsGetDC.h>
#include <DsRole.h>
#include <NtLdap.h>
#include <NtDsAPI.h>
#include <ActiveDS.h>
#include <Sddl.h>
#define NO_WBEM
#include "T_SafeVector.h"

#ifndef tstring
typedef std::basic_string<_TCHAR> tstring;
#endif

using namespace _com_util;


namespace _DomainContainer
{

tstring __stdcall CreateFilter(LPCTSTR pszFilter, const StringSet& setExcludeNames);

bool __stdcall IsClass(LPCTSTR pszClass, const _variant_t& vntClass);

#define MIN_NON_RESERVED_RID 1000

bool __stdcall IsUserRid(const _variant_t& vntSid);

IDispatchPtr GetADsObject(_bstr_t strPath);
void ReportADsError(HRESULT hr, const IID& iid = GUID_NULL);

} // namespace _DomainContainer

using namespace _DomainContainer;


//---------------------------------------------------------------------------
// Domain Class
//---------------------------------------------------------------------------


// Constructors and Destructor ----------------------------------------------


CDomain::CDomain() :
	m_bUpLevel(false),
	m_bNativeMode(false)
{
}


CDomain::~CDomain()
{
}


// Implementation -----------------------------------------------------------


// Initialize Method
//
// Initializes domain parameters such as DNS domain name, Flat (NETBIOS) domain name,
// forest name, domain controller name.

void CDomain::Initialize(_bstr_t strDomainName)
{
	if (!strDomainName)
	{
		AdmtThrowError(
			GUID_NULL, GUID_NULL,
			E_INVALIDARG,
			IDS_E_DOMAIN_NAME_NOT_SPECIFIED
		);
	}

	// retrieve name of a domain controller in the domain

	m_strDcName = GetDcName(strDomainName);

	// retrieve domain information

	PDSROLE_PRIMARY_DOMAIN_INFO_BASIC ppdib;

	DWORD dwError = DsRoleGetPrimaryDomainInformation(
		m_strDcName,
		DsRolePrimaryDomainInfoBasic,
		(BYTE**)&ppdib
	);

	if (dwError != NO_ERROR)
	{
		AdmtThrowError(
			GUID_NULL, GUID_NULL,
			HRESULT_FROM_WIN32(dwError),
			IDS_E_CANT_GET_DOMAIN_INFORMATION,
			(LPCTSTR)strDomainName
		);
	}

	// initialize data members from domain information

	m_bUpLevel = (ppdib->Flags & DSROLE_PRIMARY_DS_RUNNING) ? true : false;
	m_bNativeMode = (m_bUpLevel && !(ppdib->Flags & DSROLE_PRIMARY_DS_MIXED_MODE)) ? true : false;

	if (ppdib->DomainNameDns)
	{
		m_strDomainNameDns = ppdib->DomainNameDns;
	}
	else
	{
		m_strDomainNameDns = _bstr_t();
	}

	if (ppdib->DomainNameFlat)
	{
		m_strDomainNameFlat = ppdib->DomainNameFlat;
	}
	else
	{
		m_strDomainNameFlat = _bstr_t();
	}

	if (ppdib->DomainForestName)
	{
		m_strForestName = ppdib->DomainForestName;
	}
	else
	{
		m_strForestName = _bstr_t();
	}

	DsRoleFreeMemory(ppdib);

	// initialize ADsPath

	if (m_bUpLevel)
	{
		m_strADsPath = _T("LDAP://") + m_strDomainNameDns;

		// retrieve global catalog server name for uplevel domains

//		m_strGcName = GetGcName();
	}
	else
	{
		m_strADsPath = _T("WinNT://") + m_strDomainNameFlat;
	}

	// retrieve domain sid

	m_strDomainSid = GetSid();

	// initialize dispatch interface pointer to active directory object

	m_sp = GetADsObject(m_strADsPath);
}


// GetDcName Method
//
// Retrieves name of domain controller in the given domain.

_bstr_t CDomain::GetDcName(_bstr_t strDomainName)
{
	_bstr_t strName;

	PDOMAIN_CONTROLLER_INFO pdci;

	// attempt to retrieve DNS name of domain controller supporting active directory service

	DWORD dwError = DsGetDcName(NULL, strDomainName, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED|DS_RETURN_DNS_NAME, &pdci);

	// if domain controller not found, attempt to retrieve flat name of domain controller

	if (dwError == ERROR_NO_SUCH_DOMAIN)
	{
		dwError = DsGetDcName(NULL, strDomainName, NULL, NULL, DS_RETURN_FLAT_NAME, &pdci);
	}

	// if domain controller found then save name otherwise generate error

	if (dwError == NO_ERROR)
	{
		strName = pdci->DomainControllerName;

		NetApiBufferFree(pdci);
	}
	else
	{
		AdmtThrowError(
			GUID_NULL, GUID_NULL,
			HRESULT_FROM_WIN32(dwError),
			IDS_E_CANT_GET_DOMAIN_CONTROLLER,
			(LPCTSTR)strDomainName
		);
	}

	return strName;
}


// GetGcName Method
//
// Retrieves name of global catalog server.

_bstr_t CDomain::GetGcName()
{
	_bstr_t strName;

	PDOMAIN_CONTROLLER_INFO pdci;

	DWORD dwError = DsGetDcName(NULL, m_strForestName, NULL, NULL, DS_GC_SERVER_REQUIRED, &pdci);

	if (dwError == NO_ERROR)
	{
		strName = pdci->DomainControllerName;

		NetApiBufferFree(pdci);
	}
	else
	{
		AdmtThrowError(
			GUID_NULL, GUID_NULL,
			HRESULT_FROM_WIN32(dwError),
			IDS_E_CANT_GET_GLOBAL_CATALOG_SERVER,
			(LPCTSTR)m_strForestName
		);
	}

	return strName;
}


// GetSid Method

_bstr_t CDomain::GetSid()
{
	_bstr_t strSid;

	PUSER_MODALS_INFO_2 pumi2;

	if (NetUserModalsGet(m_strDcName, 2, (LPBYTE*)&pumi2) == NERR_Success)
	{
		if (IsValidSid(pumi2->usrmod2_domain_id))
		{
			LPTSTR pszSid;

			if (ConvertSidToStringSid(pumi2->usrmod2_domain_id, &pszSid))
			{
				strSid = pszSid;

				LocalFree(LocalHandle(pszSid));
			}
		}

		NetApiBufferFree(pumi2);
	}

	return strSid;
}


// GetContainer Method
//
// Retrieves a container given it's relative canonical path. Will
// optionally create container if create parameter is true and container
// does not already exist.

CContainer CDomain::GetContainer(_bstr_t strRelativeCanonicalPath, bool bCreate)
{
	CContainer aContainer;

	// return a non-empty container only if the domain is uplevel and a
	// relative canonical path is supplied

	if (m_bUpLevel && (strRelativeCanonicalPath.length() > 0))
	{
		if (bCreate)
		{
			tstring strPath = strRelativeCanonicalPath;

			// initialize parent container
			// if path separator is specified than initialize parent
			// container from ADsPath otherwise this container is the
			// parent container

			CContainer aParent;

			UINT pos = strPath.find_last_of(_T("/\\"));

			if (pos != tstring::npos)
			{
				aParent = GetLDAPPath(GetDistinguishedName(strPath.substr(0, pos).c_str()));
			}
			else
			{
				aParent = *this;
			}

			tstring strName = strPath.substr(pos + 1);

			CADsPathName aPathName(aParent.GetPath());

			tstring strRDN = _T("CN=") + strName;

			aPathName.AddLeafElement(strRDN.c_str());

			IDispatchPtr spDispatch;

			HRESULT hr = ADsGetObject(aPathName.Retrieve(ADS_FORMAT_X500), __uuidof(IDispatch), (void**)&spDispatch);

			if (SUCCEEDED(hr))
			{
				aContainer = CContainer(spDispatch);
			}
			else
			{
				strRDN = _T("OU=") + strName;

				aContainer = aParent.CreateContainer(strRDN.c_str());
			}
		}
		else
		{
			try
			{
				aContainer = GetLDAPPath(GetDistinguishedName(strRelativeCanonicalPath));
			}
			catch (_com_error& ce)
			{
				AdmtThrowError(GUID_NULL, GUID_NULL, ce, IDS_E_CANNOT_GET_CONTAINER, (LPCTSTR)strRelativeCanonicalPath);
			}
		}
	}

	return aContainer;
}


// GetLDAPPath

_bstr_t CDomain::GetLDAPPath(_bstr_t strDN)
{
	_bstr_t strPath = _T("LDAP://") + m_strDomainNameDns;

	if (strDN.length() > 0)
	{
		strPath += _T("/") + strDN;
	}

	return strPath;
}


// GetWinNTPath

_bstr_t CDomain::GetWinNTPath(_bstr_t strName)
{
	const _TCHAR c_chEscape = _T('\\');
	static _TCHAR s_chSpecial[] = _T("\",/<>");

	std::auto_ptr<_TCHAR> spEscapedName(new _TCHAR[strName.length() * 2 + 1]);

	if (spEscapedName.get() == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	_TCHAR* pchOld = strName;
	_TCHAR* pchNew = spEscapedName.get();

	while (*pchOld)
	{
		if (_tcschr(s_chSpecial, *pchOld))
		{
			*pchNew++ = c_chEscape;
		}

		*pchNew++ = *pchOld++;
	}

	*pchNew = _T('\0');

	tstring strPath;

	strPath += _T("WinNT://");
	strPath += m_strDomainNameFlat;
	strPath += _T("/");
	strPath += spEscapedName.get();

	return strPath.c_str();
}


// GetDistinguishedName Method

_bstr_t CDomain::GetDistinguishedName(_bstr_t strRelativeCanonicalPath)
{
	_bstr_t strDN;

	HRESULT hr = S_OK;

	HANDLE hDS;

	DWORD dwError = DsBind(m_strDcName, NULL, &hDS);

	if (dwError == NO_ERROR)
	{
		_bstr_t strCanonicalName = m_strDomainNameDns + _T("/") + strRelativeCanonicalPath;

		LPTSTR psz = strCanonicalName;

		PDS_NAME_RESULT pnr;

		dwError = DsCrackNames(hDS, DS_NAME_NO_FLAGS, DS_CANONICAL_NAME, DS_FQDN_1779_NAME, 1, &psz, &pnr);

		if (dwError == NO_ERROR)
		{
			if (pnr->rItems[0].status == DS_NAME_NO_ERROR)
			{
				strDN = pnr->rItems[0].pName;
			}
			else
			{
				hr = AdmtSetError(
					GUID_NULL, GUID_NULL,
					E_INVALIDARG,
					IDS_E_CANT_GET_DISTINGUISHED_NAME,
					(LPCTSTR)strCanonicalName
				);
			}

			DsFreeNameResult(pnr);
		}
		else
		{
			hr = AdmtSetError(
				GUID_NULL, GUID_NULL,
				HRESULT_FROM_WIN32(dwError),
				IDS_E_CANT_GET_DISTINGUISHED_NAME,
				(LPCTSTR)strCanonicalName
			);
		}

		DsUnBind(&hDS);
	}
	else
	{
		hr = AdmtSetError(
			GUID_NULL, GUID_NULL,
			HRESULT_FROM_WIN32(dwError),
			IDS_E_CANT_CONNECT_TO_DIRECTORY_SERVICE,
			(LPCTSTR)m_strDomainNameDns
		);
	}

	if (hr != S_OK)
	{
		_com_issue_error(hr);
	}

	return strDN;
}


// CreateContainer Method

CContainer CDomain::CreateContainer(_bstr_t strRDN)
{
	CContainer aContainer;

	if (m_bUpLevel)
	{
		aContainer = CContainer::CreateContainer(strRDN);
	}
	else
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_CANT_CREATE_CONTAINER_NT4);
	}

	return aContainer;
}

// QueryContainers Method

void CDomain::QueryContainers(ContainerVector& rContainers)
{
	if (m_bUpLevel)
	{
		CContainer::QueryContainers(rContainers);
	}
}


// QueryUsers Method

void CDomain::QueryUsers(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rUsers)
{
	if (m_bUpLevel)
	{
		CContainer::QueryUsers(bRecurse, setExcludeNames, rUsers);
	}
	else
	{
		QueryUsers4(setExcludeNames, rUsers);
	}
}


// QueryUsers Method

void CDomain::QueryUsers(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rUsers)
{
	if (m_bUpLevel)
	{
		QueryObjects(rContainer, setIncludeNames, setExcludeNames, _T("user"), rUsers);
	}
	else
	{
		QueryUsers4(setIncludeNames, setExcludeNames, rUsers);
	}
}


// QueryGroups Method

void CDomain::QueryGroups(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rGroups)
{
	if (m_bUpLevel)
	{
		CContainer::QueryGroups(bRecurse, setExcludeNames, rGroups);
	}
	else
	{
		QueryGroups4(setExcludeNames, rGroups);
	}
}


// QueryGroups Method

void CDomain::QueryGroups(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rGroups)
{
	if (m_bUpLevel)
	{
		QueryObjects(rContainer, setIncludeNames, setExcludeNames, _T("group"), rGroups);
	}
	else
	{
		QueryGroups4(setIncludeNames, setExcludeNames, rGroups);
	}
}


// QueryComputers Method

void CDomain::QueryComputers(bool bIncludeDCs, bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	if (m_bUpLevel)
	{
		CContainer::QueryComputers(bIncludeDCs, bRecurse, setExcludeNames, rComputers);
	}
	else
	{
		QueryComputers4(bIncludeDCs, setExcludeNames, rComputers);
	}
}


// QueryComputers Method

void CDomain::QueryComputers(CContainer& rContainer, bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	if (m_bUpLevel)
	{
		QueryObjects(rContainer, setIncludeNames, setExcludeNames, _T("computer"), rComputers);

		if (!bIncludeDCs)
		{
			for (CDomainAccounts::iterator it = rComputers.begin(); it != rComputers.end();)
			{
				long lUserAccountControl = it->GetUserAccountControl();

				if (lUserAccountControl & ADS_UF_SERVER_TRUST_ACCOUNT)
				{
					_Module.Log(ErrW, IDS_E_CANNOT_MIGRATE_DOMAIN_CONTROLLERS, (LPCTSTR)it->GetADsPath());

					it = rComputers.erase(it);
				}
				else
				{
					it++;
				}
			}
		}
	}
	else
	{
		QueryComputers4(bIncludeDCs, setIncludeNames, setExcludeNames, rComputers);
	}
}


// QueryComputersAcrossDomains Method

void CDomain::QueryComputersAcrossDomains(CContainer& rContainer, bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	CDomainToPathMap mapDomainToPath;

	mapDomainToPath.Initialize(m_strDomainNameDns, m_strDomainNameFlat, setIncludeNames);

	for (CDomainToPathMap::iterator it = mapDomainToPath.begin(); it != mapDomainToPath.end(); it++)
	{
		_bstr_t strDomainName = it->first;

		try
		{
			CDomain domain;
			domain.Initialize(strDomainName);
			domain.QueryComputers(rContainer, bIncludeDCs, it->second, setExcludeNames, rComputers);
		}
		catch (_com_error& ce)
		{
			_Module.Log(ErrE, IDS_E_CANNOT_PROCESS_ACCOUNTS_IN_DOMAIN, (LPCTSTR)strDomainName, ce.ErrorMessage(), ce.Error());
		}
		catch (...)
		{
			_Module.Log(ErrE, IDS_E_CANNOT_PROCESS_ACCOUNTS_IN_DOMAIN, (LPCTSTR)strDomainName, _com_error(E_FAIL).ErrorMessage(), E_FAIL);
		}
	}
}


// QueryObjects Method

void CDomain::QueryObjects(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, LPCTSTR pszClass, CDomainAccounts& rAccounts)
{
	// copy specified include names to vector

	StringVector vecNames;

	for (StringSet::const_iterator itInclude = setIncludeNames.begin(); itInclude != setIncludeNames.end(); itInclude++)
	{
		vecNames.push_back(tstring(*itInclude));
	}

	// crack names

	CNameCracker cracker;

	cracker.SetDomainNames(m_strDomainNameDns, m_strDomainNameFlat, m_strDcName);
	cracker.SetDefaultContainer(IADsContainerPtr(rContainer.GetInterface()));

	cracker.CrackNames(vecNames);

	// log un-resolved names

	const StringVector& vecUnResolved = cracker.GetUnResolvedNames();

	for (StringVector::const_iterator itUnResolved = vecUnResolved.begin(); itUnResolved != vecUnResolved.end(); itUnResolved++)
	{
		_Module.Log(ErrW, IDS_E_CANNOT_RESOLVE_NAME, itUnResolved->c_str());
	}

	// initialize compare exclude names

	CCompareStrings csExclude(setExcludeNames);

	// add resolved accounts

	const CStringSet& setResolved = cracker.GetResolvedNames();

	CADsPathName pathname;
	pathname.Set(_T("LDAP"), ADS_SETTYPE_PROVIDER);
	pathname.Set(m_strDomainNameDns, ADS_SETTYPE_SERVER);

	CDirectoryObject doObject;

	doObject.AddAttribute(ATTRIBUTE_OBJECT_CLASS);
	doObject.AddAttribute(ATTRIBUTE_OBJECT_SID);
	doObject.AddAttribute(ATTRIBUTE_NAME);
	doObject.AddAttribute(ATTRIBUTE_USER_PRINCIPAL_NAME);
	doObject.AddAttribute(ATTRIBUTE_SAM_ACCOUNT_NAME);
	doObject.AddAttribute(ATTRIBUTE_USER_ACCOUNT_CONTROL);

	for (CStringSet::const_iterator itResolved = setResolved.begin(); itResolved != setResolved.end(); itResolved++)
	{
		try
		{
			// get active directory service path
			// Note: the pathname component will, if necessary, escape any special characters
			pathname.Set(itResolved->c_str(), ADS_SETTYPE_DN);
			_bstr_t strADsPath = pathname.Retrieve(ADS_FORMAT_X500);

			// get object attributes
			doObject = (LPCTSTR)strADsPath;
			doObject.GetAttributes();

			// if the object is of the specified account class...

			_variant_t vntClass = doObject.GetAttributeValue(ATTRIBUTE_OBJECT_CLASS);

			if (IsClass(pszClass, vntClass))
			{
				// and it does not represent a built-in account...

				_variant_t vntSid = doObject.GetAttributeValue(ATTRIBUTE_OBJECT_SID);

				if (IsUserRid(vntSid))
				{
					// then if name is not in exclusion list...

					_bstr_t strName = doObject.GetAttributeValue(ATTRIBUTE_NAME);

					if (csExclude.IsMatch(strName) == false)
					{
						//
						// then add account to account list
						//

						CDomainAccount daAccount;

						// active directory service path
						daAccount.SetADsPath(strADsPath);

						// name attribute
						daAccount.SetName(strName);

						// user principal name attribute

						_variant_t vntUserPrincipalName = doObject.GetAttributeValue(ATTRIBUTE_USER_PRINCIPAL_NAME);

						if (V_VT(&vntUserPrincipalName) != VT_EMPTY)
						{
							daAccount.SetUserPrincipalName(_bstr_t(vntUserPrincipalName));
						}

						// sam account name attribute

						_variant_t vntSamAccountName = doObject.GetAttributeValue(ATTRIBUTE_SAM_ACCOUNT_NAME);

						if (V_VT(&vntSamAccountName) != VT_EMPTY)
						{
							daAccount.SetSamAccountName(_bstr_t(vntSamAccountName));
						}

						// user account control attribute

						_variant_t vntUserAccountControl = doObject.GetAttributeValue(ATTRIBUTE_USER_ACCOUNT_CONTROL);

						if (V_VT(&vntUserAccountControl) != VT_EMPTY)
						{
							daAccount.SetUserAccountControl(vntUserAccountControl);
						}

						rAccounts.insert(daAccount);
					}
					else
					{
						_Module.Log(ErrW, IDS_E_ACCOUNT_EXCLUDED, itResolved->c_str());
					}
				}
				else
				{
					_Module.Log(ErrW, IDS_E_CANT_DO_BUILTIN, itResolved->c_str());
				}
			}
			else
			{
				_Module.Log(ErrW, IDS_E_OBJECT_NOT_OF_CLASS, itResolved->c_str());
			}
		}
		catch (_com_error& ce)
		{
			ATLTRACE(_T("'%s' : %s : 0x%08lX\n"), itResolved->c_str(), ce.ErrorMessage(), ce.Error());
		}
		catch (...)
		{
			ATLTRACE(_T("'%s' : %s : 0x%08lX\n"), itResolved->c_str(), _com_error(E_FAIL).ErrorMessage(), E_FAIL);
		}
	}
}


// QueryUsers4 Method

void CDomain::QueryUsers4(StringSet& setExcludeNames, CDomainAccounts& rUsers)
{
	CCompareStrings aExclude(setExcludeNames);

	DWORD dwIndex = 0;
	NET_API_STATUS status;

	CDomainAccount aUser;

	do
	{
		DWORD dwCount = 0;
		PNET_DISPLAY_USER pdu = NULL;

		status = NetQueryDisplayInformation(m_strDcName, 1, dwIndex, 1000, 32768, &dwCount, (PVOID*)&pdu);

		if ((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA))
		{
			for (PNET_DISPLAY_USER p = pdu; dwCount > 0; dwCount--, p++)
			{
				if (p->usri1_user_id >= MIN_NON_RESERVED_RID)
				{
					_bstr_t strName(p->usri1_name);

					if (aExclude.IsMatch(strName) == false)
					{
						aUser.SetADsPath(GetWinNTPath(strName));
						aUser.SetName(strName);

						rUsers.insert(aUser);
					}
				}

				dwIndex = p->usri1_next_index;
			}
		}

		if (pdu)
		{
			NetApiBufferFree(pdu);
		}
	}
	while (status == ERROR_MORE_DATA);
}


// QueryUsers4 Method

void CDomain::QueryUsers4(StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rUsers)
{
	CCompareStrings aExclude(setExcludeNames);

	CDomainAccount aUser;

	for (StringSet::iterator it = setIncludeNames.begin(); it != setIncludeNames.end(); it++)
	{
		_bstr_t strName = *it;

		if (aExclude.IsMatch(strName) == false)
		{
			_bstr_t strADsPath = GetWinNTPath(strName) + _T(",user");

			IADsPtr spADs;
			HRESULT hr = ADsGetObject(strADsPath, IID_IADs, (VOID**)&spADs);

			if (SUCCEEDED(hr))
			{
				BSTR bstr;

// The WinNT: provider does not return all ADsPaths correctly escaped
// (ie. it does not escape the double quote (") character)
// The member method GetWinNTPath does escape all known special characters.
#if 0
				spADs->get_ADsPath(&bstr);
				aUser.SetADsPath(_bstr_t(bstr, false));
#else
				aUser.SetADsPath(GetWinNTPath(strName));
#endif
				spADs->get_Name(&bstr);
				aUser.SetName(_bstr_t(bstr, false));

				rUsers.insert(aUser);
			}
			else
			{
				_Module.Log(ErrE, IDS_E_CANT_ADD_USER, (LPCTSTR)strADsPath, _com_error(hr).ErrorMessage());
			}
		}
	}
}


// QueryGroups4 Method

void CDomain::QueryGroups4(StringSet& setExcludeNames, CDomainAccounts& rGroups)
{
	CCompareStrings aExclude(setExcludeNames);

	DWORD dwIndex = 0;
	NET_API_STATUS status;

	CDomainAccount aGroup;

	do
	{
		DWORD dwCount = 0;
		PNET_DISPLAY_GROUP pdg = NULL;

		status = NetQueryDisplayInformation(m_strDcName, 3, dwIndex, 1000, 32768, &dwCount, (PVOID*)&pdg);

		if ((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA))
		{
			for (PNET_DISPLAY_GROUP p = pdg; dwCount > 0; dwCount--, p++)
			{
				if (p->grpi3_group_id >= MIN_NON_RESERVED_RID)
				{
					_bstr_t strName(p->grpi3_name);

					if (aExclude.IsMatch(strName) == false)
					{
						aGroup.SetADsPath(GetWinNTPath(strName));
						aGroup.SetName(strName);

						rGroups.insert(aGroup);
					}
				}

				dwIndex = p->grpi3_next_index;
			}
		}

		if (pdg)
		{
			NetApiBufferFree(pdg);
		}
	}
	while (status == ERROR_MORE_DATA);
}


// QueryGroups4 Method

void CDomain::QueryGroups4(StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rGroups)
{
	CCompareStrings aExclude(setExcludeNames);

	CDomainAccount aGroup;

	for (StringSet::iterator it = setIncludeNames.begin(); it != setIncludeNames.end(); it++)
	{
		_bstr_t strName = *it;

		if (aExclude.IsMatch(strName) == false)
		{
			_bstr_t strADsPath = GetWinNTPath(strName) + _T(",group");

			IADsPtr spADs;
			HRESULT hr = ADsGetObject(strADsPath, IID_IADs, (VOID**)&spADs);

			if (SUCCEEDED(hr))
			{
				BSTR bstr;

				spADs->get_ADsPath(&bstr);
				aGroup.SetADsPath(_bstr_t(bstr, false));

				spADs->get_Name(&bstr);
				aGroup.SetName(_bstr_t(bstr, false));

				rGroups.insert(aGroup);
			}
			else
			{
				_Module.Log(ErrE, IDS_E_CANT_ADD_GROUP, (LPCTSTR)strADsPath, _com_error(hr).ErrorMessage());
			}
		}
	}
}


// QueryComputers4 Method

void CDomain::QueryComputers4(bool bIncludeDCs, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	CCompareStrings aExclude(setExcludeNames);

	DWORD dwIndex = 0;
	NET_API_STATUS status;

	CDomainAccount aComputer;

	DWORD dwflags = bIncludeDCs ? UF_WORKSTATION_TRUST_ACCOUNT|UF_SERVER_TRUST_ACCOUNT : UF_WORKSTATION_TRUST_ACCOUNT;

	do
	{
		DWORD dwCount = 0;
		PNET_DISPLAY_MACHINE pdm = NULL;

		status = NetQueryDisplayInformation(m_strDcName, 2, dwIndex, 1000, 32768, &dwCount, (PVOID*)&pdm);

		if ((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA))
		{
			for (PNET_DISPLAY_MACHINE p = pdm; dwCount > 0; dwCount--, p++)
			{
				if ((p->usri2_user_id >= MIN_NON_RESERVED_RID) && (p->usri2_flags & dwflags))
				{
					_bstr_t strName(p->usri2_name);

					if (aExclude.IsMatch(strName) == false)
					{
						aComputer.SetADsPath(GetWinNTPath(strName));
						aComputer.SetName(strName);
						aComputer.SetSamAccountName(strName);

						rComputers.insert(aComputer);
					}
				}

				dwIndex = p->usri2_next_index;
			}
		}

		if (pdm)
		{
			NetApiBufferFree(pdm);
		}
	}
	while (status == ERROR_MORE_DATA);
}


// QueryComputers4 Method

void CDomain::QueryComputers4(bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	typedef std::map<_bstr_t, DWORD, IgnoreCaseStringLess> CMachineMap;

	PNET_DISPLAY_MACHINE pndmMachine = NULL;

	try
	{
		CMachineMap map;

		DWORD dwIndex = 0;
		NET_API_STATUS nasStatus;

		do
		{
			DWORD dwCount = 0;

			nasStatus = NetQueryDisplayInformation(m_strDcName, 2, dwIndex, 256, 32768, &dwCount, (PVOID*)&pndmMachine);

			if ((nasStatus == ERROR_SUCCESS) || (nasStatus == ERROR_MORE_DATA))
			{
				for (PNET_DISPLAY_MACHINE p = pndmMachine; dwCount > 0; dwCount--, p++)
				{
					map.insert(CMachineMap::value_type(p->usri2_name, p->usri2_flags));

					dwIndex = p->usri2_next_index;
				}
			}

			if (pndmMachine)
			{
				NetApiBufferFree(pndmMachine);
				pndmMachine = NULL;
			}
		}
		while (nasStatus == ERROR_MORE_DATA);

		if (nasStatus != ERROR_SUCCESS)
		{
			AdmtThrowError(
				GUID_NULL,
				GUID_NULL,
				HRESULT_FROM_WIN32(nasStatus),
				IDS_E_CANT_ENUMERATE_COMPUTERS,
				(LPCTSTR)m_strDomainNameFlat
			);
		}

		CCompareStrings aExclude(setExcludeNames);

		for (StringSet::iterator it = setIncludeNames.begin(); it != setIncludeNames.end(); it++)
		{
			tstring str = *it;

			if ((str[0] == _T('\\')) || (str[0] == _T('/')))
			{
				str = str.substr(1);
			}

			_bstr_t strName = str.c_str();

			if (aExclude.IsMatch(strName) == false)
			{
				_bstr_t strPath = GetWinNTPath(strName);

				CMachineMap::iterator it = map.find(strName + _T("$"));

				if (it != map.end())
				{
					if (bIncludeDCs || !(it->second & UF_SERVER_TRUST_ACCOUNT))
					{
						CDomainAccount aComputer;

						aComputer.SetADsPath(strPath);
						aComputer.SetName(strName);
						aComputer.SetSamAccountName(strName + _T("$"));

						rComputers.insert(aComputer);
					}
					else
					{
						_Module.Log(ErrW, IDS_E_CANT_MIGRATE_DOMAIN_CONTROLLERS, (LPCTSTR)strPath);
					}
				}
				else
				{
					_Module.Log(ErrW, IDS_E_CANT_FIND_COMPUTER, (LPCTSTR)strPath);
				}
			}
		}
	}
	catch (...)
	{
		if (pndmMachine)
		{
			NetApiBufferFree(pndmMachine);
		}

		throw;
	}
}


//---------------------------------------------------------------------------
// Container Class
//---------------------------------------------------------------------------


// Constructors and Destructor ----------------------------------------------


CContainer::CContainer()
{
}


CContainer::CContainer(IDispatchPtr sp) :
	m_sp(sp)
{
}


CContainer::CContainer(_bstr_t strPath)
{
	HRESULT hr = ADsGetObject(strPath, __uuidof(IDispatch), (void**)&m_sp);

	if (FAILED(hr))
	{
		ReportADsError(hr);

		_com_issue_error(hr);
	}
}


CContainer::CContainer(const CContainer& r) :
	m_sp(r.m_sp)
{
}


CContainer::~CContainer()
{
	if (m_sp)
	{
		m_sp.Release();
	}
}


// Implementation -----------------------------------------------------------


// operator =

CContainer& CContainer::operator =(_bstr_t strPath)
{
	HRESULT hr = ADsGetObject(strPath, __uuidof(IDispatch), (void**)&m_sp);

	if (FAILED(hr))
	{
		ReportADsError(hr);

		_com_issue_error(hr);
	}

	return *this;
}


// operator =

CContainer& CContainer::operator =(const CContainer& r)
{
	m_sp = r.m_sp;

	return *this;
}


// GetPath Method

_bstr_t CContainer::GetPath()
{
	IDirectoryObjectPtr spObject(m_sp);

	PADS_OBJECT_INFO poi;

	CheckError(spObject->GetObjectInformation(&poi));

	// the ADS_OBJECT_INFO member pszObjectDN actually
	// specifies the ADsPath not the distinguished name

	_bstr_t strPath = poi->pszObjectDN;

	FreeADsMem(poi);

	return strPath;
}


// GetDomain Method

_bstr_t CContainer::GetDomain()
{
	CADsPathName aPathName(GetPath());

	return aPathName.Retrieve(ADS_FORMAT_SERVER);
}


// GetName Method

_bstr_t CContainer::GetName()
{
	CDirectoryObject aObject(m_sp);

	aObject.AddAttribute(ATTRIBUTE_NAME);
	aObject.GetAttributes();

	return aObject.GetAttributeValue(ATTRIBUTE_NAME);
}


// GetRDN Method

_bstr_t CContainer::GetRDN()
{
	IDirectoryObjectPtr spObject(m_sp);

	PADS_OBJECT_INFO poi;

	CheckError(spObject->GetObjectInformation(&poi));

	_bstr_t strRDN = poi->pszRDN;

	FreeADsMem(poi);

	return strRDN;
}


// CreateContainerHierarchy Method

void CContainer::CreateContainerHierarchy(CContainer& rSource)
{
	ContainerVector cvContainers;

	rSource.QueryContainers(cvContainers);

	for (ContainerVector::iterator it = cvContainers.begin(); it != cvContainers.end(); it++)
	{
		CContainer aTarget = CreateContainer(_T("OU=") + it->GetName());

		aTarget.CreateContainerHierarchy(*it);
	}
}


// GetContainer Method

CContainer CContainer::GetContainer(_bstr_t strName)
{
	IDispatchPtr spDispatch;

	CADsPathName aPathName(GetPath());

	// try organizational unit first

	aPathName.AddLeafElement(_T("OU=") + strName);

	HRESULT hr = ADsGetObject(aPathName.Retrieve(ADS_FORMAT_X500), __uuidof(IDispatch), (void**)&spDispatch);

	if (FAILED(hr))
	{
	//	if (hr == ?)
	//	{
			// then try container

			aPathName.RemoveLeafElement();
			aPathName.AddLeafElement(_T("CN=") + strName);

			CheckError(ADsGetObject(aPathName.Retrieve(ADS_FORMAT_X500), __uuidof(IDispatch), (void**)&spDispatch));
	//	}
	//	else
	//	{
	//		_com_issue_error(hr);
	//	}
	}

	return CContainer(spDispatch);
}


// CreateContainer Method

CContainer CContainer::CreateContainer(_bstr_t strRDN)
{
	IDispatchPtr spDispatch;

	CADsPathName aPathName(GetPath());

	aPathName.AddLeafElement(strRDN);

	_bstr_t strPath = aPathName.Retrieve(ADS_FORMAT_X500);

	HRESULT hr = ADsGetObject(strPath, __uuidof(IDispatch), (void**)&spDispatch);

	if (FAILED(hr))
	{
		ADSVALUE valueClass;
		valueClass.dwType = ADSTYPE_CASE_IGNORE_STRING;
		valueClass.CaseIgnoreString = L"organizationalUnit";

		ADS_ATTR_INFO aiAttrs[] =
		{
			{ L"objectClass", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING, &valueClass, 1 },
		};
		DWORD dwAttrCount = sizeof(aiAttrs) / sizeof(aiAttrs[0]);

		IDirectoryObjectPtr spObject(m_sp);

		HRESULT hr = spObject->CreateDSObject(strRDN, aiAttrs, dwAttrCount, &spDispatch);

		if (FAILED(hr))
		{
			ReportADsError(hr, IID_IDirectoryObject);

			_com_issue_error(hr);
		}
	}

	return CContainer(spDispatch);
}


// QueryContainers Method

void CContainer::QueryContainers(ContainerVector& rContainers)
{
	CDirectorySearch aSearch(m_sp);
	aSearch.SetFilter(_T("(|(objectCategory=OrganizationalUnit)(&(objectCategory=Container)(|(cn=Computers)(cn=Users))))"));
	aSearch.SetPreferences(ADS_SCOPE_ONELEVEL);
	aSearch.AddAttribute(ATTRIBUTE_ADS_PATH);
	aSearch.Search();

	for (bool bGet = aSearch.GetFirstRow(); bGet; bGet = aSearch.GetNextRow())
	{
		CContainer aContainer(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_ADS_PATH)));

		rContainers.push_back(aContainer);
	}
}


// QueryUsers Method

void CContainer::QueryUsers(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rUsers)
{
	tstring strFilter = CreateFilter(
		_T("(objectCategory=Person)(objectClass=user)")
		_T("(userAccountControl:") LDAP_MATCHING_RULE_BIT_OR_W _T(":=512)"),
		setExcludeNames
	);

	CDirectorySearch aSearch(m_sp);
	aSearch.SetFilter(strFilter.c_str());
	aSearch.SetPreferences(bRecurse ? ADS_SCOPE_SUBTREE : ADS_SCOPE_ONELEVEL);
	aSearch.AddAttribute(ATTRIBUTE_OBJECT_SID);
	aSearch.AddAttribute(ATTRIBUTE_ADS_PATH);
	aSearch.AddAttribute(ATTRIBUTE_NAME);
	aSearch.AddAttribute(ATTRIBUTE_USER_PRINCIPAL_NAME);
	aSearch.Search();

	CDomainAccount aUser;

	for (bool bGet = aSearch.GetFirstRow(); bGet; bGet = aSearch.GetNextRow())
	{
		// if not a built-in or well known account

		if (IsUserRid(aSearch.GetAttributeValue(ATTRIBUTE_OBJECT_SID)))
		{
			// add user

			aUser.SetADsPath(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_ADS_PATH)));
			aUser.SetName(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_NAME)));

			_variant_t vntUserPrincipalName = aSearch.GetAttributeValue(ATTRIBUTE_USER_PRINCIPAL_NAME);

			if (V_VT(&vntUserPrincipalName) != VT_EMPTY)
			{
				aUser.SetUserPrincipalName(_bstr_t(vntUserPrincipalName));
			}

			rUsers.insert(aUser);
		}
	}
}


// QueryGroups Method

void CContainer::QueryGroups(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rGroups)
{
	tstring strFilter = CreateFilter(_T("(objectCategory=Group)"), setExcludeNames);

	CDirectorySearch aSearch(m_sp);
	aSearch.SetFilter(strFilter.c_str());
	aSearch.SetPreferences(bRecurse ? ADS_SCOPE_SUBTREE : ADS_SCOPE_ONELEVEL);
	aSearch.AddAttribute(ATTRIBUTE_OBJECT_SID);
	aSearch.AddAttribute(ATTRIBUTE_ADS_PATH);
	aSearch.AddAttribute(ATTRIBUTE_NAME);
	aSearch.Search();

	CDomainAccount aGroup;

	for (bool bGet = aSearch.GetFirstRow(); bGet; bGet = aSearch.GetNextRow())
	{
		// if not a built-in or well known account

		if (IsUserRid(aSearch.GetAttributeValue(ATTRIBUTE_OBJECT_SID)))
		{
			// add group

			aGroup.SetADsPath(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_ADS_PATH)));
			aGroup.SetName(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_NAME)));

			rGroups.insert(aGroup);
		}
	}
}


// QueryComputers Method

void CContainer::QueryComputers(bool bIncludeDCs, bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rComputers)
{
	tstring strFilter;

	// ADS_UF_WORKSTATION_TRUST_ACCOUNT = 0x1000
	// ADS_UF_SERVER_TRUST_ACCOUNT      = 0x2000

	if (bIncludeDCs)
	{
		strFilter = CreateFilter(
			_T("(objectCategory=Computer)")
			_T("(userAccountControl:") LDAP_MATCHING_RULE_BIT_OR_W _T(":=4096)"),
			setExcludeNames
		);
	}
	else
	{
		strFilter = CreateFilter(
			_T("(objectCategory=Computer)")
			_T("(|(userAccountControl:") LDAP_MATCHING_RULE_BIT_OR_W _T(":=4096)")
			_T("(userAccountControl:") LDAP_MATCHING_RULE_BIT_OR_W _T(":=8192))"),
			setExcludeNames
		);
	}

	CDirectorySearch aSearch(m_sp);
	aSearch.SetFilter(strFilter.c_str());
	aSearch.SetPreferences(bRecurse ? ADS_SCOPE_SUBTREE : ADS_SCOPE_ONELEVEL);
	aSearch.AddAttribute(ATTRIBUTE_OBJECT_SID);
	aSearch.AddAttribute(ATTRIBUTE_ADS_PATH);
	aSearch.AddAttribute(ATTRIBUTE_NAME);
	aSearch.AddAttribute(ATTRIBUTE_SAM_ACCOUNT_NAME);
	aSearch.Search();

	CDomainAccount aComputer;

	for (bool bGet = aSearch.GetFirstRow(); bGet; bGet = aSearch.GetNextRow())
	{
		// if not a built-in or well known account

		if (IsUserRid(aSearch.GetAttributeValue(ATTRIBUTE_OBJECT_SID)))
		{
			// add computer

			aComputer.SetADsPath(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_ADS_PATH)));
			aComputer.SetName(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_NAME)));
			aComputer.SetSamAccountName(_bstr_t(aSearch.GetAttributeValue(ATTRIBUTE_SAM_ACCOUNT_NAME)));

			rComputers.insert(aComputer);
		}
	}
}


//---------------------------------------------------------------------------


namespace _DomainContainer
{


// CreateFilter Method

tstring __stdcall CreateFilter(LPCTSTR pszFilter, const StringSet& setExcludeNames)
{
	tstring strFilter;

	strFilter += _T("(&");

	strFilter += pszFilter;

	if (!setExcludeNames.empty())
	{
		strFilter += _T("(!(|");

		for (StringSet::const_iterator it = setExcludeNames.begin(); it != setExcludeNames.end(); it++)
		{
			strFilter += _T("(name=");
			strFilter += *it;
			strFilter += _T(")");
		}

		strFilter += _T("))");
	}

	strFilter += _T(")");

	return strFilter;
}


// IsClass

bool __stdcall IsClass(LPCTSTR pszClass, const _variant_t& vntClass)
{
	bool bIs = false;

	if (pszClass)
	{
		if (V_VT(&vntClass) == VT_BSTR)
		{
			if (V_BSTR(&vntClass))
			{
				if (_tcsicmp(pszClass, V_BSTR(&vntClass)) == 0)
				{
					bIs = true;
				}
			}
		}
		else
		{
			 if (V_VT(&vntClass) == (VT_ARRAY|VT_BSTR))
			 {
				SAFEARRAY* psa = V_ARRAY(&vntClass);

				if (psa->cDims == 1)
				{
					BSTR* pbstr = reinterpret_cast<BSTR*>(psa->pvData);
					DWORD cbstr = psa->rgsabound[0].cElements;

					if (pbstr)
					{
						BSTR bstrClass = pbstr[cbstr - 1];

						if (bstrClass)
						{
							if (_tcsicmp(pszClass, bstrClass) == 0)
							{
								bIs = true;
							}
						}
					}
				}
			 /*
				typedef std::vector<_bstr_t> ClassVector;

				ClassVector vec = T_SafeVector2<VT_BSTR, _bstr_t, ClassVector, T_Extract_bstr_t<ClassVector> >(const_cast<_variant_t&>(vntClass));

				if (vec.size() > 0)
				{
					_bstr_t strClass = vec[vec.size() - 1];

					if (strClass.length() > 0)
					{
						if (_tcsicmp(strClass, pszClass) == 0)
						{
							bIs = true;
						}
					}
				}
			*/
			}
		}
	}

	return bIs;
}


// IsUserRid

bool __stdcall IsUserRid(const _variant_t& vntSid)
{
	bool bUser = false;

	if (V_VT(&vntSid) == (VT_ARRAY|VT_UI1))
	{
		PSID pSid = (PSID)vntSid.parray->pvData;

		if (IsValidSid(pSid))
		{
			PUCHAR puch = GetSidSubAuthorityCount(pSid);
			DWORD dwCount = static_cast<DWORD>(*puch);
			DWORD dwIndex = dwCount - 1;
			PDWORD pdw = GetSidSubAuthority(pSid, dwIndex);
			DWORD dwRid = *pdw;

			if (dwRid >= MIN_NON_RESERVED_RID)
			{
				bUser = true;
			}
		}
	}

	return bUser;
}


// GetADsObject

IDispatchPtr GetADsObject(_bstr_t strPath)
{
	IDispatch* pdisp;

	HRESULT hr = ADsGetObject(strPath, __uuidof(IDispatch), (void**)&pdisp);

	if (FAILED(hr))
	{
		ReportADsError(hr);

		_com_issue_error(hr);
	}

	return IDispatchPtr(pdisp, false);
}


// ReportADsError

void ReportADsError(HRESULT hr, const IID& iid)
{
	DWORD dwError;
	WCHAR szName[256];
	WCHAR szError[256];

	ADsGetLastError(&dwError, szError, sizeof(szError) / sizeof(szError[0]), szName, sizeof(szName) / sizeof(szName[0]));

	AtlReportError(GUID_NULL, szError, iid, hr);
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\computermigration.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// ComputerMigration Class
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CComputerMigration :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IComputerMigration, &IID_IComputerMigration, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CComputerMigration();
	~CComputerMigration();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CComputerMigration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IComputerMigration)
	END_COM_MAP()

public:

	// IComputerMigration

	STDMETHOD(put_TranslationOption)(long lOption);
	STDMETHOD(get_TranslationOption)(long* plOption);
	STDMETHOD(put_TranslateFilesAndFolders)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateFilesAndFolders)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateLocalGroups)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateLocalGroups)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslatePrinters)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslatePrinters)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateRegistry)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateRegistry)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateShares)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateShares)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateUserProfiles)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateUserProfiles)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateUserRights)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateUserRights)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_RestartDelay)(long lTime);
	STDMETHOD(get_RestartDelay)(long* plTime);
	STDMETHOD(Migrate)(long lOptions, VARIANT vntInclude, VARIANT vntExclude);

protected:

	void ValidateMigrationParameters();

	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource, CContainer& rTarget);
	void DoComputers(CContainer& rSource, CContainer& rTarget);
	void DoComputers(CDomainAccounts& rComputers, CContainer& rTarget);

	void SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet);
	void SetAccountOptions(CVarSet& rVarSet);
	void SetSecurity(CVarSet& rVarSet);

protected:

	long m_lTranslationOption;
	bool m_bTranslateFilesAndFolders;
	bool m_bTranslateLocalGroups;
	bool m_bTranslatePrinters;
	bool m_bTranslateRegistry;
	bool m_bTranslateShares;
	bool m_bTranslateUserProfiles;
	bool m_bTranslateUserRights;
	long m_lRestartDelay;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\computermigration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "ComputerMigration.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetAccountOptions.h"
#include "VarSetSecurity.h"


//---------------------------------------------------------------------------
// Computer Migration Class
//---------------------------------------------------------------------------


CComputerMigration::CComputerMigration() :
	m_lTranslationOption(admtTranslateReplace),
	m_bTranslateFilesAndFolders(false),
	m_bTranslateLocalGroups(false),
	m_bTranslatePrinters(false),
	m_bTranslateRegistry(false),
	m_bTranslateShares(false),
	m_bTranslateUserProfiles(false),
	m_bTranslateUserRights(false),
	m_lRestartDelay(5)
{
}


CComputerMigration::~CComputerMigration()
{
}


// IComputerMigration Implementation ----------------------------------------


// TranslationOption Property

STDMETHODIMP CComputerMigration::put_TranslationOption(long lOption)
{
	HRESULT hr = S_OK;

	if (IsTranslationOptionValid(lOption))
	{
		m_lTranslationOption = lOption;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IComputerMigration, E_INVALIDARG, IDS_E_TRANSLATION_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CComputerMigration::get_TranslationOption(long* plOption)
{
	*plOption = m_lTranslationOption;

	return S_OK;
}


// TranslateFilesAndFolders Property

STDMETHODIMP CComputerMigration::put_TranslateFilesAndFolders(VARIANT_BOOL bTranslate)
{
	m_bTranslateFilesAndFolders = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateFilesAndFolders(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateFilesAndFolders ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateLocalGroups Property

STDMETHODIMP CComputerMigration::put_TranslateLocalGroups(VARIANT_BOOL bTranslate)
{
	m_bTranslateLocalGroups = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateLocalGroups(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateLocalGroups ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslatePrinters Property

STDMETHODIMP CComputerMigration::put_TranslatePrinters(VARIANT_BOOL bTranslate)
{
	m_bTranslatePrinters = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslatePrinters(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslatePrinters ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateRegistry Property

STDMETHODIMP CComputerMigration::put_TranslateRegistry(VARIANT_BOOL bTranslate)
{
	m_bTranslateRegistry = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateRegistry(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateRegistry ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateShares Property

STDMETHODIMP CComputerMigration::put_TranslateShares(VARIANT_BOOL bTranslate)
{
	m_bTranslateShares = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateShares(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateShares ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateUserProfiles Property

STDMETHODIMP CComputerMigration::put_TranslateUserProfiles(VARIANT_BOOL bTranslate)
{
	m_bTranslateUserProfiles = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateUserProfiles(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateUserProfiles ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateUserRights Property

STDMETHODIMP CComputerMigration::put_TranslateUserRights(VARIANT_BOOL bTranslate)
{
	m_bTranslateUserRights = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CComputerMigration::get_TranslateUserRights(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateUserRights ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// RestartDelay Property

STDMETHODIMP CComputerMigration::put_RestartDelay(long lTime)
{
	HRESULT hr = S_OK;

	if ((lTime >= 1) && (lTime <= 10))
	{
		m_lRestartDelay = lTime;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IComputerMigration, E_INVALIDARG, IDS_E_RESTART_DELAY_INVALID);
	}

	return hr;
}

STDMETHODIMP CComputerMigration::get_RestartDelay(long* plTime)
{
	*plTime = m_lRestartDelay;

	return S_OK;
}


// Migrate Method

STDMETHODIMP CComputerMigration::Migrate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
	HRESULT hr = S_OK;

	MutexWait();

	bool bLogOpen = _Module.OpenLog();

	try
	{
		_Module.Log(ErrI, IDS_STARTED_COMPUTER_MIGRATION);

		InitSourceDomainAndContainer();
		InitTargetDomainAndContainer();

		VerifyInterIntraForest();
		ValidateMigrationParameters();

		DoOption(lOptions, vntInclude, vntExclude);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IComputerMigration, ce, IDS_E_CANT_MIGRATE_COMPUTERS);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IComputerMigration, E_FAIL, IDS_E_CANT_MIGRATE_COMPUTERS);
	}

	if (bLogOpen)
	{
		_Module.CloseLog();
	}

	MutexRelease();

	return hr;
}


// Implementation -----------------------------------------------------------


// ValidateMigrationParameters Method

void CComputerMigration::ValidateMigrationParameters()
{
	bool bIntraForest = m_spInternal->IntraForest ? true : false;

	if (bIntraForest)
	{
		// validate conflict option

		long lConflictOptions = m_spInternal->ConflictOptions;
		long lConflictOption = lConflictOptions & 0x0F;

		if (lConflictOption == admtReplaceConflicting)
		{
			AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INTRA_FOREST_REPLACE);
		}
	}
}


// DoNames Method

void CComputerMigration::DoNames()
{
	CDomainAccounts aComputers;

	m_SourceDomain.QueryComputers(GetSourceContainer(), false, m_setIncludeNames, m_setExcludeNames, aComputers);

	DoComputers(aComputers, GetTargetContainer());
}


// DoDomain Method

void CComputerMigration::DoDomain()
{
	CContainer& rSource = GetSourceContainer();
	CContainer& rTarget = GetTargetContainer();

	if (m_nRecurseMaintain == 2)
	{
		rTarget.CreateContainerHierarchy(rSource);
	}

	DoContainers(rSource, rTarget);
}


// DoContainers Method

void CComputerMigration::DoContainers(CContainer& rSource, CContainer& rTarget)
{
	DoComputers(rSource, rTarget);

	if (m_nRecurseMaintain == 2)
	{
		ContainerVector aContainers;
		rSource.QueryContainers(aContainers);

		for (ContainerVector::iterator it = aContainers.begin(); it != aContainers.end(); it++)
		{
			DoContainers(*it, rTarget.GetContainer(it->GetName()));
		}
	}
}


// DoComputers Method

void CComputerMigration::DoComputers(CContainer& rSource, CContainer& rTarget)
{
	CDomainAccounts aComputers;
	rSource.QueryComputers(false, m_nRecurseMaintain == 1, m_setExcludeNames, aComputers);

	DoComputers(aComputers, rTarget);
}


// DoComputers Method

void CComputerMigration::DoComputers(CDomainAccounts& rComputers, CContainer& rTarget)
{
	if (rComputers.size() > 0)
	{
		CVarSet aVarSet;

		SetOptions(rTarget.GetPath(), aVarSet);
		SetAccountOptions(aVarSet);
		SetSecurity(aVarSet);

		VerifyRenameConflictPrefixSuffixValid();

		FillInVarSetForComputers(rComputers, false, true, true, m_lRestartDelay, aVarSet);

		rComputers.clear();

		if (m_bTranslateUserProfiles)
		{
			aVarSet.Put(_T("PlugIn.%ld"), 0, _T("{0EB9FBE9-397D-4D09-A65E-ABF1790CC470}"));
		}
		else
		{
			aVarSet.Put(_T("PlugIn.%ld"), 0, _T("None"));
		}

		#ifdef _DEBUG
		aVarSet.Dump();
		#endif

		PerformMigration(aVarSet);

		SaveSettings(aVarSet);
	}
}


// SetOptions Method

void CComputerMigration::SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet)
{
	CVarSetOptions aOptions(rVarSet);

	aOptions.SetTest(m_spInternal->TestMigration ? true : false);

	aOptions.SetUndo(false);
	aOptions.SetWizard(_T("computer"));

	aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
	aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns(), m_SourceDomain.Sid());
	aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
	aOptions.SetTargetOu(strTargetOu);

	aOptions.SetRenameOptions(m_spInternal->RenameOption, m_spInternal->RenamePrefixOrSuffix);
	aOptions.SetRestartDelay(m_lRestartDelay);
}


// SetAccountOptions Method

void CComputerMigration::SetAccountOptions(CVarSet& rVarSet)
{
	CVarSetAccountOptions aOptions(rVarSet);

	// naming conflict options
	// removing existing members of groups being replaced is not applicable

	aOptions.SetConflictOptions(
		m_spInternal->ConflictOptions & ~admtRemoveExistingMembers,
		m_spInternal->ConflictPrefixOrSuffix
	);

	aOptions.SetMigrateSids(false);
	aOptions.SetComputerMigrationOptions();

	aOptions.SetExcludedComputerProps(m_spInternal->ComputerPropertiesToExclude);
}


// SetSecurity Method

void CComputerMigration::SetSecurity(CVarSet& rVarSet)
{
	CVarSetSecurity aSecurity(rVarSet);

	aSecurity.SetTranslationOption(m_lTranslationOption);
	aSecurity.SetTranslateContainers(false);
	aSecurity.SetTranslateFiles(m_bTranslateFilesAndFolders);
	aSecurity.SetTranslateLocalGroups(m_bTranslateLocalGroups);
	aSecurity.SetTranslatePrinters(m_bTranslatePrinters);
	aSecurity.SetTranslateRegistry(m_bTranslateRegistry);
	aSecurity.SetTranslateShares(m_bTranslateShares);
	aSecurity.SetTranslateUserProfiles(m_bTranslateUserProfiles);
	aSecurity.SetTranslateUserRights(m_bTranslateUserRights);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\domainaccount.h ===
#pragma once

#include <set>


//---------------------------------------------------------------------------
// Domain Account Class
//---------------------------------------------------------------------------


class CDomainAccount
{
public:

	CDomainAccount() :
		m_lUserAccountControl(0)
	{
	}

	CDomainAccount(const CDomainAccount& r) :
		m_strADsPath(r.m_strADsPath),
		m_strName(r.m_strName),
		m_strUserPrincipalName(r.m_strUserPrincipalName),
		m_strSamAccountName(r.m_strSamAccountName),
		m_lUserAccountControl(r.m_lUserAccountControl)
	{
	}

	~CDomainAccount()
	{
	}

	//

	_bstr_t GetADsPath() const
	{
		return m_strADsPath;
	}

	void SetADsPath(_bstr_t strPath)
	{
		m_strADsPath = strPath;
	}

	_bstr_t GetName() const
	{
		return m_strName;
	}

	void SetName(_bstr_t strName)
	{
		m_strName = strName;
	}

	_bstr_t GetUserPrincipalName() const
	{
		return m_strUserPrincipalName;
	}

	void SetUserPrincipalName(_bstr_t strName)
	{
		m_strUserPrincipalName = strName;
	}

	_bstr_t GetSamAccountName() const
	{
		return m_strSamAccountName;
	}

	void SetSamAccountName(_bstr_t strName)
	{
		m_strSamAccountName = strName;
	}

	long GetUserAccountControl() const
	{
		return m_lUserAccountControl;
	}

	void SetUserAccountControl(long lUserAccountControl)
	{
		m_lUserAccountControl = lUserAccountControl;
	}

	//

	bool operator <(const CDomainAccount& r) const
	{
		return (m_strADsPath < r.m_strADsPath);
	}

protected:

	_bstr_t m_strADsPath;
	_bstr_t m_strName;
	_bstr_t m_strUserPrincipalName;
	_bstr_t m_strSamAccountName;
	long m_lUserAccountControl;
};


//---------------------------------------------------------------------------
// Domain Accounts Class
//---------------------------------------------------------------------------


class CDomainAccounts :
	public std::set<CDomainAccount>
{
public:

	CDomainAccounts() {}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\error.h ===
#pragma once

#include "Resource.h"


//---------------------------------------------------------------------------
// Error Methods
//---------------------------------------------------------------------------


HRESULT __cdecl AdmtSetError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...);
HRESULT __cdecl AdmtSetError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat = NULL, ...);

void __cdecl AdmtThrowError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...);
void __cdecl AdmtThrowError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat = NULL, ...);

//_bstr_t __cdecl FormatError(_com_error ce, UINT uId, ...);
//_bstr_t __cdecl FormatError(_com_error ce, LPCTSTR pszFormat = NULL, ...);

//_bstr_t __stdcall FormatResult(HRESULT hr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\domaincontainer.h ===
#pragma once

#include <set>
#include <vector>
#include "DomainAccount.h"
#include "VarSetBase.h"
#include <IsAdmin.hpp>

#ifndef StringSet
typedef std::set<_bstr_t> StringSet;
#endif


//---------------------------------------------------------------------------
// Container Class
//
// This class encapsulates the properties of a domain container and the
// operations that may be performed on a domain container.
//---------------------------------------------------------------------------


class CContainer
{
public:

	CContainer();
	CContainer(_bstr_t strPath);
	CContainer(IDispatchPtr sp);
	CContainer(const CContainer& r);
	virtual ~CContainer();

	// assignment operator

	CContainer& operator =(_bstr_t strPath);
	CContainer& operator =(const CContainer& r);

	// boolean operator
	// returns true if dispatch interface is not null

	operator bool()
	{
		return m_sp;
	}

	IDispatchPtr GetInterface() const
	{
		return m_sp;
	}

	_bstr_t GetPath();
	_bstr_t GetDomain();
	_bstr_t GetName();
	_bstr_t GetRDN();

	// duplicates container hierarchy given a source container
	void CreateContainerHierarchy(CContainer& rSource);

	// create a child container given a relative distinguished name
	virtual CContainer CreateContainer(_bstr_t strRDN);

	// retrieve a child container given a relative distinguished name
	virtual CContainer GetContainer(_bstr_t strRDN);

	virtual void QueryContainers(std::vector<CContainer>& rContainers);
	virtual void QueryUsers(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rUsers);
	virtual void QueryGroups(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rGroups);
	virtual void QueryComputers(bool bIncludeDCs, bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rComputers);

protected:

	IDispatchPtr m_sp;
};


typedef std::vector<CContainer> ContainerVector;


//---------------------------------------------------------------------------
// Domain Class
//---------------------------------------------------------------------------


class CDomain : public CContainer
{
public:

	CDomain();
	~CDomain();

	bool UpLevel() const
	{
		return m_bUpLevel;
	}

	bool NativeMode() const
	{
		return m_bNativeMode;
	}

	_bstr_t Name() const
	{
		_bstr_t strName = m_strDomainNameDns;

		if (!strName)
		{
			strName = m_strDomainNameFlat;
		}

		return strName;
	}

	_bstr_t NameDns() const
	{
		return m_strDomainNameDns;
	}

	_bstr_t NameFlat() const
	{
		return m_strDomainNameFlat;
	}

	_bstr_t ForestName() const
	{
		return m_strForestName;
	}

	_bstr_t Sid() const
	{
		return m_strDomainSid;
	}

	_bstr_t DomainControllerName() const
	{
		return m_strDcName;
	}

	void Initialize(_bstr_t strDomainName);

	DWORD IsAdministrator()
	{
		return IsAdminRemote(m_strDcName);
	}

	virtual CContainer CreateContainer(_bstr_t strRDN);
	CContainer GetContainer(_bstr_t strRelativeCanonicalPath, bool bCreate = false);
	virtual void QueryContainers(ContainerVector& rContainers);

	void QueryUsers(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rUsers);
	void QueryGroups(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rGroups);
	void QueryComputers(CContainer& rContainer, bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers);
	void QueryComputersAcrossDomains(CContainer& rContainer, bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers);

	virtual void QueryUsers(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rUsers);
	virtual void QueryGroups(bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rGroups);
	virtual void QueryComputers(bool bIncludeDCs, bool bRecurse, StringSet& setExcludeNames, CDomainAccounts& rComputers);

protected:

	CDomain(const CDomain& r) {}

	_bstr_t GetDcName(_bstr_t strDomainName);
	_bstr_t GetGcName();
	_bstr_t GetSid();

	_bstr_t GetLDAPPath(_bstr_t strDN);
	_bstr_t GetWinNTPath(_bstr_t strName);
	_bstr_t GetDistinguishedName(_bstr_t strRelativeCanonicalPath);

	void QueryObjects(CContainer& rContainer, StringSet& setIncludeNames, StringSet& setExcludeNames, LPCTSTR pszClass, CDomainAccounts& rAccounts);

	void QueryUsers4(StringSet& setExcludeNames, CDomainAccounts& rUsers);
	void QueryUsers4(StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rUsers);
	void QueryGroups4(StringSet& setExcludeNames, CDomainAccounts& rGroups);
	void QueryGroups4(StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rGroups);
	void QueryComputers4(bool bIncludeDCs, StringSet& setExcludeNames, CDomainAccounts& rComputers);
	void QueryComputers4(bool bIncludeDCs, StringSet& setIncludeNames, StringSet& setExcludeNames, CDomainAccounts& rComputers);

protected:

	bool m_bUpLevel;
	bool m_bNativeMode;

	_bstr_t m_strADsPath;

	_bstr_t m_strDcName;
	_bstr_t m_strGcName;
	_bstr_t m_strForestName;
	_bstr_t m_strDomainNameDns;
	_bstr_t m_strDomainNameFlat;
	_bstr_t m_strDomainSid;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\error.cpp ===
#include "StdAfx.h"
#include "Error.h"
#include <ComDef.h>
using namespace _com_util;

#define COUNT_OF(a) (sizeof(a) / sizeof(a[0]))

namespace Error_cpp
{


IErrorInfoPtr __stdcall AdmtCreateErrorInfo(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription);


// AdmtSetErrorImpl Method

inline HRESULT __stdcall AdmtSetErrorImpl(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
{
	SetErrorInfo(0, AdmtCreateErrorInfo(clsid, iid, ce, pszDescription));

	return ce.Error();
}


// AdmtThrowErrorImpl Method

inline void __stdcall AdmtThrowErrorImpl(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
{
	IErrorInfoPtr spErrorInfo = AdmtCreateErrorInfo(clsid, iid, ce, pszDescription);

	if (spErrorInfo)
	{
		_com_raise_error(ce.Error(), spErrorInfo.Detach());
	}
	else
	{
		_com_raise_error(ce.Error());
	}
}


}

using namespace Error_cpp;


//---------------------------------------------------------------------------
// Error Methods
//---------------------------------------------------------------------------


// AdmtSetError Methods -------------------------------------------------


HRESULT __cdecl AdmtSetError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...)
{
	_TCHAR szFormat[512];
	_TCHAR szDescription[1024];

	if (LoadString(_Module.GetResourceInstance(), uId, szFormat, 512))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	return AdmtSetErrorImpl(clsid, iid, ce, szDescription);
}


HRESULT __cdecl AdmtSetError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[1024];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	return AdmtSetErrorImpl(clsid, iid, ce, szDescription);
}


// AdmtThrowError Methods -----------------------------------------------


void __cdecl AdmtThrowError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...)
{
	_TCHAR szFormat[512];
	_TCHAR szDescription[1024];

	if (LoadString(_Module.GetResourceInstance(), uId, szFormat, 512))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	AdmtThrowErrorImpl(clsid, iid, ce, szDescription);
}


void __cdecl AdmtThrowError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[1024];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	AdmtThrowErrorImpl(clsid, iid, ce, szDescription);
}


// Implementation -----------------------------------------------------------


namespace Error_cpp
{


// AdmtCreateErrorInfo Method

IErrorInfoPtr __stdcall AdmtCreateErrorInfo(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
{
	ICreateErrorInfoPtr spCreateErrorInfo;

	CreateErrorInfo(&spCreateErrorInfo);

	if (spCreateErrorInfo)
	{
		IErrorInfoPtr spErrorInfo = ce.ErrorInfo();

		if (spErrorInfo == NULL)
		{
			GetErrorInfo(0, &spErrorInfo);
		}

		// source

		if (IsEqualCLSID(clsid, GUID_NULL) == FALSE)
		{
			LPOLESTR pszProgId;

			if (ProgIDFromCLSID(clsid, &pszProgId) == S_OK)
			{
				spCreateErrorInfo->SetSource(pszProgId);
				CoTaskMemFree(pszProgId);
			}
			else
			{
				spCreateErrorInfo->SetSource(L"");
			}
		}
		else if (spErrorInfo)
		{
			BSTR bstrSource;
			spErrorInfo->GetSource(&bstrSource);
			spCreateErrorInfo->SetSource(bstrSource);
			SysFreeString(bstrSource);
		}
		else
		{
			spCreateErrorInfo->SetSource(L"");
		}

		// GUID

		if (IsEqualIID(iid, GUID_NULL) == FALSE)
		{
			spCreateErrorInfo->SetGUID(iid);
		}
		else if (spErrorInfo)
		{
			GUID guid;
			spErrorInfo->GetGUID(&guid);
			spCreateErrorInfo->SetGUID(guid);
		}
		else
		{
			spCreateErrorInfo->SetGUID(GUID_NULL);
		}

		// description

		_bstr_t strDescription = pszDescription;

		if (spErrorInfo)
		{
			BSTR bstrSource;
			spErrorInfo->GetSource(&bstrSource);

			if (SysStringLen(bstrSource) > 0)
			{
				if (strDescription.length() > 0)
				{
					strDescription += _T(" : ");
				}

				strDescription += bstrSource;
			}

			SysFreeString(bstrSource);

			BSTR bstrDescription;
			spErrorInfo->GetDescription(&bstrDescription);

			if (SysStringLen(bstrDescription) > 0)
			{
				if (strDescription.length() > 0)
				{
					strDescription += _T(" ");
				}

				strDescription += bstrDescription;
			}
			else
			{
				LPCTSTR pszErrorMessage = ce.ErrorMessage();

				if (pszErrorMessage)
				{
					if (strDescription.length() > 0)
					{
						strDescription += _T(" : ");
					}

					strDescription += pszErrorMessage;
				}
			}

			SysFreeString(bstrDescription);
		}
		else
		{
			LPCTSTR pszErrorMessage = ce.ErrorMessage();

			if (pszErrorMessage)
			{
				if (strDescription.length() > 0)
				{
					strDescription += _T(" ");
				}

				strDescription += pszErrorMessage;
			}
		}

		spCreateErrorInfo->SetDescription(strDescription);

		// help file

		if (spErrorInfo)
		{
			BSTR bstrHelpFile;
			spErrorInfo->GetHelpFile(&bstrHelpFile);
			spCreateErrorInfo->SetHelpFile(bstrHelpFile);
			SysFreeString(bstrHelpFile);
		}
		else
		{
			spCreateErrorInfo->SetHelpFile(L"");
		}

		// help context

		DWORD dwHelpContext = 0;

		if (spErrorInfo)
		{
			spErrorInfo->GetHelpContext(&dwHelpContext);
		}

		spCreateErrorInfo->SetHelpContext(dwHelpContext);
	}

	return IErrorInfoPtr(spCreateErrorInfo);
}


}	// namespace Error_cpp

/*
_bstr_t __stdcall FormatResult(HRESULT hr);


_bstr_t __cdecl FormatError(_com_error ce, UINT uId, ...)
{
	_bstr_t bstrDescription;

	try
	{
		_TCHAR szFormat[1024];

		if (LoadString(_Module.GetResourceInstance(), uId, szFormat, 1024))
		{
			_TCHAR szDescription[1024];

			va_list args;
			va_start(args, uId);
			_vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
			va_end(args);

			bstrDescription = szDescription;
		}

		_bstr_t bstrSource = ce.Source();

		if (bstrSource.length() > 0)
		{
			if (bstrDescription.length() > 0)
			{
				bstrDescription += _T(" : ");
			}

			bstrDescription += bstrSource;
		}

		_bstr_t bstrOldDescription = ce.Description();

		if (bstrOldDescription.length() > 0)
		{
			if (bstrDescription.length() > 0)
			{
				bstrDescription += _T(" ");
			}

			bstrDescription += bstrOldDescription;
		}

		_bstr_t bstrResult = FormatResult(ce.Error());

		if (bstrResult.length() > 0)
		{
			if (bstrDescription.length() > 0)
			{
				bstrDescription += _T(" : ");
			}

			bstrDescription += bstrResult;
		}
	}
	catch (...)
	{
		;
	}

	return bstrDescription;
}


_bstr_t __cdecl FormatError(_com_error ce, LPCTSTR pszFormat, ...)
{
	_bstr_t bstrDescription;

	try
	{
		if (pszFormat)
		{
			_TCHAR szDescription[1024];

			va_list args;
			va_start(args, pszFormat);
			_vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
			va_end(args);

			bstrDescription = szDescription;
		}

		_bstr_t bstrSource = ce.Source();

		if (bstrSource.length() > 0)
		{
			if (bstrDescription.length() > 0)
			{
				bstrDescription += _T(" : ");
			}

			bstrDescription += bstrSource;
		}

		_bstr_t bstrOldDescription = ce.Description();

		if (bstrOldDescription.length() > 0)
		{
			if (bstrDescription.length() > 0)
			{
				bstrDescription += _T(" ");
			}

			bstrDescription += bstrOldDescription;
		}

		_bstr_t bstrResult = FormatResult(ce.Error());

		if (bstrResult.length() > 0)
		{
			if (bstrDescription.length() > 0)
			{
				bstrDescription += _T(" : ");
			}

			bstrDescription += bstrResult;
		}
	}
	catch (...)
	{
		;
	}

	return bstrDescription;
}


_bstr_t __stdcall FormatResult(HRESULT hr)
{
	_bstr_t bstrError;

	LPTSTR pszError = NULL;

	try
	{
		switch (HRESULT_FACILITY(hr))
		{
		//	case FACILITY_NULL:        //  0
		//	case FACILITY_RPC:         //  1
		//	case FACILITY_DISPATCH:    //  2
		//	case FACILITY_STORAGE:     //  3
		//	case FACILITY_ITF:         //  4
		//	{
		//		HMODULE hModule = LoadLibrary(_T("MSDAERR.dll"));

		//		if (hModule)
		//		{
		//			FormatMessage(
		//				FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
		//				hModule,
		//				hr,
		//				0,
		//				(LPTSTR)&pszError,
		//				0,
		//				NULL
		//			);

		//			FreeLibrary(hModule);
		//		}
		//		break;
		//	}
			case FACILITY_WIN32:       //  7
			{
				FormatMessage(
					FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					hr,
					0,
					(LPTSTR)&pszError,
					0,
					NULL
				);
				break;
			}
		//	case FACILITY_WINDOWS:     //  8
		//	case FACILITY_SSPI:        //  9
		//	case FACILITY_SECURITY:    //  9
		//	case FACILITY_CONTROL:     // 10
		//	{
		//		HMODULE hModule = LoadLibrary(_T("MSADER15.dll"));

		//		if (hModule)
		//		{
		//			FormatMessage(
		//				FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
		//				hModule,
		//				hr,
		//				0,
		//				(LPTSTR)&pszError,
		//				0,
		//				NULL
		//			);

		//			FreeLibrary(hModule);
		//		}
		//		break;
		//	}
		//	case FACILITY_CERT:        // 11
		//	case FACILITY_INTERNET:    // 12
		//	case FACILITY_MEDIASERVER: // 13
			case FACILITY_MSMQ:        // 14
			{
				HMODULE hModule = LoadLibrary(_T("MQUTIL.dll"));

				if (hModule)
				{
					FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
						hModule,
						hr,
						0,
						(LPTSTR)&pszError,
						0,
						NULL
					);

					FreeLibrary(hModule);
				}
				break;
			}
		//	case FACILITY_SETUPAPI:    // 15
		//	case FACILITY_SCARD:       // 16
		//	case FACILITY_COMPLUS:     // 17
		//	case FACILITY_AAF:         // 18
		//	case FACILITY_URT:         // 19
		//	case FACILITY_ACS:         // 20
			default:
			{
				FormatMessage(
					FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					hr,
					0,
					(LPTSTR)&pszError,
					0,
					NULL
				);
				break;
			}
		}

		if (pszError)
		{
			size_t cch = _tcslen(pszError);

			if ((cch > 1) && (pszError[cch - 1] == _T('\n')))
			{
				pszError[cch - 1] = 0;

				if (pszError[cch - 2] == _T('\r'))
				{
					pszError[cch - 2] = 0;
				}
			}

			bstrError = pszError;
		}
		else
		{
			_TCHAR szError[32];
			_stprintf(szError, _T("Unknown error 0x%08lX."), hr);

			bstrError = szError;
		}
	}
	catch (...)
	{
		;
	}

	if (pszError)
	{
		LocalFree((HLOCAL)pszError);
	}

    return bstrError;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\fixhierarchy.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "FixHierarchy.h"


//---------------------------------------------------------------------------
// Fix Objects in Hierarchy Class Implementation
//---------------------------------------------------------------------------


CFixObjectsInHierarchy::CFixObjectsInHierarchy() :
	m_bFixReplaced(false)
{
}


CFixObjectsInHierarchy::~CFixObjectsInHierarchy()
{
}


void CFixObjectsInHierarchy::FixObjects()
{
	m_Migrated.RetrieveMigratedObjects();

	int nCount = m_Migrated.GetCount();

	if (nCount > 0)
	{
		m_TargetPath.SetContainerPaths(m_strSourceContainerPath, m_strTargetContainerPath);

		for (int nIndex = 0; nIndex < nCount; nIndex++)
		{
			int nStatus = m_Migrated.GetObjectStatus(nIndex);

			if ((nStatus & CMigrated::STATUS_CREATED) || (m_bFixReplaced && (nStatus & CMigrated::STATUS_REPLACED)))
			{
				_bstr_t strType = m_Migrated.GetObjectType(nIndex);

				if ((strType.length() > 0) && (_tcsicmp(strType, m_strObjectType) == 0))
				{
					if (m_TargetPath.NeedsToMove(m_Migrated.GetObjectSourcePath(nIndex), m_Migrated.GetObjectTargetPath(nIndex)))
					{
						m_Containers.InsertObject(m_TargetPath.GetTargetContainerPath(), nIndex, m_TargetPath.GetTargetObjectCurrentPath());
					}
				}
			}
		}

		for (CContainers::iterator itContainer = m_Containers.begin(); itContainer != m_Containers.end(); itContainer++)
		{
			try
			{
				CADsContainer cContainer((LPCTSTR)itContainer->first);

				CObjects& ovObjects = itContainer->second;

				for (CObjects::iterator itObject = ovObjects.begin(); itObject != ovObjects.end(); itObject++)
				{
					try
					{
						SObject& oObject = *itObject;

						CADs account(IADsPtr(cContainer.MoveHere(oObject.m_strPath, _bstr_t())));

						m_Migrated.UpdateObjectTargetPath(oObject.m_nIndex, account.GetADsPath());
					}
					catch (_com_error& ce)
					{
						_Module.Log(ErrW, IDS_E_FIX_HIERARCHY_MOVE_OBJECT, (LPCTSTR)itObject->m_strPath, (LPCTSTR)itContainer->first, ce.ErrorMessage());
					}
					catch (...)
					{
						_Module.Log(ErrW, IDS_E_FIX_HIERARCHY_MOVE_OBJECT, (LPCTSTR)itObject->m_strPath, (LPCTSTR)itContainer->first, _com_error(E_FAIL).ErrorMessage());
					}
				}
			}
			catch (_com_error& ce)
			{
				_Module.Log(ErrW, IDS_E_FIX_HIERARCHY_BIND_TO_CONTAINER, (LPCTSTR)itContainer->first, ce.ErrorMessage());
			}
			catch (...)
			{
				_Module.Log(ErrW, IDS_E_FIX_HIERARCHY_BIND_TO_CONTAINER, (LPCTSTR)itContainer->first, _com_error(E_FAIL).ErrorMessage());
			}
		}
	}
}


//---------------------------------------------------------------------------
// Migrated Objects Class Implementation
//---------------------------------------------------------------------------


CFixObjectsInHierarchy::CMigrated::CMigrated() :
	m_lActionId(-1),
	m_spDB(__uuidof(IManageDB))
{
}


CFixObjectsInHierarchy::CMigrated::~CMigrated()
{
}


int CFixObjectsInHierarchy::CMigrated::GetCount()
{
	return long(m_vsObjects.Get(_T("MigratedObjects")));
}


_bstr_t CFixObjectsInHierarchy::CMigrated::GetObjectKey(int nIndex)
{
	_TCHAR szKey[64];
	_stprintf(szKey, _T("MigratedObjects.%d"), nIndex);
	return szKey;
}


_bstr_t CFixObjectsInHierarchy::CMigrated::GetObjectType(int nIndex)
{
	return m_vsObjects.Get(_T("MigratedObjects.%d.Type"), nIndex);
}


int CFixObjectsInHierarchy::CMigrated::GetObjectStatus(int nIndex)
{
	return long(m_vsObjects.Get(_T("MigratedObjects.%d.status"), nIndex));
}


_bstr_t CFixObjectsInHierarchy::CMigrated::GetObjectSourcePath(int nIndex)
{
	return m_vsObjects.Get(_T("MigratedObjects.%d.SourceAdsPath"), nIndex);
}


_bstr_t CFixObjectsInHierarchy::CMigrated::GetObjectTargetPath(int nIndex)
{
	return m_vsObjects.Get(_T("MigratedObjects.%d.TargetAdsPath"), nIndex);
}


void CFixObjectsInHierarchy::CMigrated::RetrieveMigratedObjects(int nActionId)
{
	if (nActionId > 0)
	{
		m_lActionId = nActionId;
	}
	else
	{
		m_spDB->GetCurrentActionID(&m_lActionId);
	}

	IUnknownPtr spUnknown(m_vsObjects.GetInterface());
	IUnknown* punk = spUnknown;

	m_spDB->GetMigratedObjects(m_lActionId, &punk);
}


void CFixObjectsInHierarchy::CMigrated::UpdateObjectTargetPath(int nIndex, _bstr_t strPath)
{
	IVarSetPtr spVarSet(__uuidof(VarSet));

	spVarSet->ImportSubTree(_bstr_t(), IVarSetPtr(m_vsObjects.GetInterface()->getReference(GetObjectKey(nIndex))));
	spVarSet->put(_T("TargetAdsPath"), strPath);

	m_spDB->SaveMigratedObject(m_lActionId, IUnknownPtr(spVarSet));
}


//---------------------------------------------------------------------------
// Target Path Class Implementation
//---------------------------------------------------------------------------


CFixObjectsInHierarchy::CTargetPath::CTargetPath()
{
}


CFixObjectsInHierarchy::CTargetPath::~CTargetPath()
{
}


void CFixObjectsInHierarchy::CTargetPath::SetContainerPaths(_bstr_t strSourceContainerPath, _bstr_t strTargetContainerPath)
{
	m_pnSourceContainerPath.Set(strSourceContainerPath, ADS_SETTYPE_FULL);
	m_pnTargetContainerPath.Set(strTargetContainerPath, ADS_SETTYPE_FULL);
}


bool CFixObjectsInHierarchy::CTargetPath::NeedsToMove(_bstr_t strSourceObjectPath, _bstr_t strTargetObjectPath)
{
	bool bNeedsToMove = false;

	// if the source object exists within the source root container hierarchy...

	CADsPathName pn(strSourceObjectPath);

	long lCount = pn.GetNumElements() - m_pnSourceContainerPath.GetNumElements();

	while (lCount-- > 0)
	{
		pn.RemoveLeafElement();
	}

	if (IsMatch(pn.Retrieve(ADS_FORMAT_X500_DN), m_pnSourceContainerPath.Retrieve(ADS_FORMAT_X500_DN)))
	{
		m_pnTargetObjectOldPath.Set(strTargetObjectPath, ADS_SETTYPE_FULL);

		// construct expected target object path

		m_pnTargetObjectNewPath.Set(m_pnTargetContainerPath.Retrieve(ADS_FORMAT_X500), ADS_SETTYPE_FULL);

		pn.Set(strSourceObjectPath, ADS_SETTYPE_FULL);

		long lIndex = pn.GetNumElements() - m_pnSourceContainerPath.GetNumElements();

		while (--lIndex >= 0)
		{
			m_pnTargetObjectNewPath.AddLeafElement(pn.GetElement(lIndex));
		}

		// compare expected target path with current target path

		if (!IsMatch(m_pnTargetObjectNewPath.Retrieve(ADS_FORMAT_X500_DN), m_pnTargetObjectOldPath.Retrieve(ADS_FORMAT_X500_DN)))
		{
			m_pnTargetObjectNewPath.Set(m_pnTargetObjectOldPath.Retrieve(ADS_FORMAT_SERVER), ADS_SETTYPE_SERVER);

			bNeedsToMove = true;
		}
	}

	return bNeedsToMove;
}


_bstr_t CFixObjectsInHierarchy::CTargetPath::GetTargetContainerPath()
{
	CADsPathName pn(m_pnTargetObjectNewPath.Retrieve(ADS_FORMAT_X500));

	pn.RemoveLeafElement();

	return pn.Retrieve(ADS_FORMAT_X500);
}


_bstr_t CFixObjectsInHierarchy::CTargetPath::GetTargetObjectCurrentPath()
{
	return m_pnTargetObjectOldPath.Retrieve(ADS_FORMAT_X500_NO_SERVER);
}


bool CFixObjectsInHierarchy::CTargetPath::IsMatch(LPCTSTR pszA, LPCTSTR pszB)
{
	bool bMatch = false;

	if (pszA && pszB)
	{
		bMatch = (_tcsicmp(pszA, pszB) == 0) ? true : false;
	}

	return bMatch;
}


//---------------------------------------------------------------------------
// Containers Class Implementation
//---------------------------------------------------------------------------


void CFixObjectsInHierarchy::CContainers::InsertObject(_bstr_t strContainerPath, int nObjectIndex, _bstr_t strObjectPathOld)
{
	iterator it = find(strContainerPath);

	if (it == end())
	{
		_Pairib pair = insert(value_type(strContainerPath, CObjects()));

		it = pair.first;
	}

	CObjects& ov = it->second;

	ov.push_back(SObject(nObjectIndex, strObjectPathOld));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\fixhierarchy.h ===
#pragma once

#include <map>
#include <vector>
#include <AdsiHelpers.h>
#include "VarSetBase.h"


class CFixObjectsInHierarchy
{
public:

	CFixObjectsInHierarchy();
	~CFixObjectsInHierarchy();

	_bstr_t GetObjectType() const
	{
		return m_strObjectType;
	}

	void SetObjectType(LPCTSTR pszType)
	{
		m_strObjectType = pszType;
	}

	bool GetFixReplaced() const
	{
		return m_bFixReplaced;
	}

	void SetFixReplaced(bool bFix)
	{
		m_bFixReplaced = bFix;
	}

	_bstr_t GetSourceContainerPath() const
	{
		return m_strSourceContainerPath;
	}

	void SetSourceContainerPath(_bstr_t strPath)
	{
		m_strSourceContainerPath = strPath;
	}

	_bstr_t GetTargetContainerPath() const
	{
		return m_strTargetContainerPath;
	}

	void SetTargetContainerPath(_bstr_t strPath)
	{
		m_strTargetContainerPath = strPath;
	}

	void FixObjects();

private:

	class CMigrated
	{
	public:

		CMigrated();
		~CMigrated();

		void RetrieveMigratedObjects(int nActionId = -1);

		int GetCount();
		_bstr_t GetObjectType(int nIndex);
		int GetObjectStatus(int nIndex);
		_bstr_t GetObjectSourcePath(int nIndex);
		_bstr_t GetObjectTargetPath(int nIndex);

		void UpdateObjectTargetPath(int nIndex, _bstr_t strPath);

	public:

		enum EStatus
		{
			STATUS_CREATED  = 0x00000001,
			STATUS_REPLACED = 0x00000002,
			STATUS_EXISTED  = 0x00000004,
		};

	private:

		_bstr_t GetObjectKey(int nIndex);

	private:

		long m_lActionId;
		IIManageDBPtr m_spDB;
		CVarSet m_vsObjects;
	};

	class CTargetPath
	{
	public:

		CTargetPath();
		~CTargetPath();

		void SetContainerPaths(_bstr_t strSourceContainerPath, _bstr_t strTargetContainerPath);

		bool NeedsToMove(_bstr_t strSourceObjectPath, _bstr_t strTargetObjectPath);

		_bstr_t GetTargetContainerPath();
		_bstr_t GetTargetObjectCurrentPath();

	private:

		bool IsMatch(LPCTSTR pszA, LPCTSTR pszB);

	private:

		CADsPathName m_pnSourceContainerPath;
		CADsPathName m_pnTargetContainerPath;
		CADsPathName m_pnTargetObjectOldPath;
		CADsPathName m_pnTargetObjectNewPath;
	};

	class CContainers;

	struct SObject
	{
		SObject(int nIndex, _bstr_t strPath) :
			m_nIndex(nIndex),
			m_strPath(strPath)
		{
		}

		SObject(const SObject& r) :
			m_nIndex(r.m_nIndex),
			m_strPath(r.m_strPath)
		{
		}

		SObject& operator =(const SObject& r)
		{
			m_nIndex = r.m_nIndex;
			m_strPath = r.m_strPath;
			return *this;
		}

		int m_nIndex;
		_bstr_t m_strPath;

		friend CContainers;
	};

	typedef std::vector<SObject> CObjects;

	class CContainers : public std::map<_bstr_t, CObjects>
	{
	public:

		CContainers() {}

		void InsertObject(_bstr_t strContainerPath, int nObjectIndex, _bstr_t strObjectPathOld);
	};

private:

	_bstr_t m_strObjectType;
	bool m_bFixReplaced;
	_bstr_t m_strSourceContainerPath;
	_bstr_t m_strTargetContainerPath;

	CMigrated m_Migrated;
	CTargetPath m_TargetPath;
	CContainers m_Containers;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\migration.h ===
#pragma once

#include "Resource.h"


//---------------------------------------------------------------------------
// CMigration
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CMigration : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMigration, &CLSID_Migration>,
	public ISupportErrorInfoImpl<&IID_IMigration>,
	public IDispatchImpl<IMigration, &IID_IMigration, &LIBID_ADMT>,
	public IMigrationInternal
{
public:

	CMigration();
	~CMigration();

	DECLARE_REGISTRY_RESOURCEID(IDR_MIGRATION)
	DECLARE_NOT_AGGREGATABLE(CMigration)

	BEGIN_COM_MAP(CMigration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IMigration)
		COM_INTERFACE_ENTRY(IMigrationInternal)
		COM_INTERFACE_ENTRY(ISupportErrorInfo)
	END_COM_MAP()

public:

	// IMigration

	STDMETHOD(put_TestMigration)(VARIANT_BOOL bTest);
	STDMETHOD(get_TestMigration)(VARIANT_BOOL* pbTest);
	STDMETHOD(put_IntraForest)(VARIANT_BOOL bIntraForest);
	STDMETHOD(get_IntraForest)(VARIANT_BOOL* pbIntraForest);
	STDMETHOD(put_SourceDomain)(BSTR bstrDomain);
	STDMETHOD(get_SourceDomain)(BSTR* pbstrDomain);
	STDMETHOD(put_SourceOu)(BSTR bstrOu);
	STDMETHOD(get_SourceOu)(BSTR* pbstrOu);
	STDMETHOD(put_TargetDomain)(BSTR bstrDomain);
	STDMETHOD(get_TargetDomain)(BSTR* pbstrDomain);
	STDMETHOD(put_TargetOu)(BSTR bstrOu);
	STDMETHOD(get_TargetOu)(BSTR* pbstrOu);
	STDMETHOD(put_RenameOption)(long lOption);
	STDMETHOD(get_RenameOption)(long* plOption);
	STDMETHOD(put_RenamePrefixOrSuffix)(BSTR bstrPrefixOrSuffix);
	STDMETHOD(get_RenamePrefixOrSuffix)(BSTR* pbstrPrefixOrSuffix);
	STDMETHOD(put_PasswordOption)(long lOption);
	STDMETHOD(get_PasswordOption)(long* plOption);
	STDMETHOD(put_PasswordServer)(BSTR bstrServer);
	STDMETHOD(get_PasswordServer)(BSTR* pbstrServer);
	STDMETHOD(put_PasswordFile)(BSTR bstrPath);
	STDMETHOD(get_PasswordFile)(BSTR* pbstrPath);
	STDMETHOD(put_ConflictOptions)(long lOptions);
	STDMETHOD(get_ConflictOptions)(long* plOptions);
	STDMETHOD(put_ConflictPrefixOrSuffix)(BSTR bstrPrefixOrSuffix);
	STDMETHOD(get_ConflictPrefixOrSuffix)(BSTR* pbstrPrefixOrSuffix);
	STDMETHOD(put_UserPropertiesToExclude)(BSTR bstrProperties);
	STDMETHOD(get_UserPropertiesToExclude)(BSTR* pbstrProperties);
	STDMETHOD(put_GroupPropertiesToExclude)(BSTR bstrProperties);
	STDMETHOD(get_GroupPropertiesToExclude)(BSTR* pbstrProperties);
	STDMETHOD(put_ComputerPropertiesToExclude)(BSTR bstrProperties);
	STDMETHOD(get_ComputerPropertiesToExclude)(BSTR* pbstrProperties);
	STDMETHOD(CreateUserMigration)(IUserMigration** pitfUserMigration);
	STDMETHOD(CreateGroupMigration)(IGroupMigration** pitfGroupMigration);
	STDMETHOD(CreateComputerMigration)(IComputerMigration** pitfComputerMigration);
	STDMETHOD(CreateSecurityTranslation)(ISecurityTranslation** pitfSecurityTranslation);
	STDMETHOD(CreateServiceAccountEnumeration)(IServiceAccountEnumeration** pitfServiceAccountEnumeration);
	STDMETHOD(CreateReportGeneration)(IReportGeneration** pitfReportGeneration);

	// IMigrationInternal
	// Note: properties implemented by IMigration interface implementation

//	STDMETHOD(get_TestMigration)(VARIANT_BOOL* pbTest);
//	STDMETHOD(get_IntraForest)(VARIANT_BOOL* pbIntraForest);
//	STDMETHOD(get_SourceOu)(BSTR* pbstrOu);
//	STDMETHOD(get_TargetOu)(BSTR* pbstrOu);
//	STDMETHOD(get_RenameOption)(long* plOption);
//	STDMETHOD(get_RenamePrefixOrSuffix)(BSTR* pbstrPrefixOrSuffix);
//	STDMETHOD(get_PasswordOption)(long* plOption);
//	STDMETHOD(get_PasswordFile)(BSTR* pbstrPath);
//	STDMETHOD(get_ConflictOptions)(long* plOptions);
//	STDMETHOD(get_ConflictPrefixOrSuffix)(BSTR* pbstrPrefixOrSuffix);
//	STDMETHOD(get_UserPropertiesToExclude)(BSTR* pbstrProperties);
//	STDMETHOD(get_GroupPropertiesToExclude)(BSTR* pbstrProperties);
//	STDMETHOD(get_ComputerPropertiesToExclude)(BSTR* pbstrProperties);

protected:

	static _bstr_t GetValidDcName(_bstr_t strDcName);

	static void UpdateDatabase();
	static _bstr_t GetParsedExcludeProperties(LPCTSTR pszOld);

protected:

	bool m_bTestMigration;
	bool m_bIntraForest;
	_bstr_t m_bstrSourceDomain;
	_bstr_t m_bstrSourceOu;
	_bstr_t m_bstrTargetDomain;
	_bstr_t m_bstrTargetOu;
	long m_lRenameOption;
	_bstr_t m_bstrRenamePrefixOrSuffix;
	long m_lPasswordOption;
	_bstr_t m_bstrPasswordServer;
	_bstr_t m_bstrPasswordFile;
	long m_lConflictOptions;
	_bstr_t m_bstrConflictPrefixOrSuffix;
	_bstr_t m_bstrUserPropertiesToExclude;
	_bstr_t m_bstrGroupPropertiesToExclude;
	_bstr_t m_bstrComputerPropertiesToExclude;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\migration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "Migration.h"

#include "Error.h"
#include "UserMigration.h"
#include "GroupMigration.h"
#include "ComputerMigration.h"
#include "SecurityTranslation.h"
#include "ServiceAccountEnumeration.h"
#include "ReportGeneration.h"

#include <LM.h>
#include <DsGetDC.h>

#import <DBMgr.tlb> no_namespace
#import <UpdateMOT.tlb> no_namespace

using namespace _com_util;

#ifndef tstring
#include <string>
typedef std::basic_string<_TCHAR> tstring;
#endif


//---------------------------------------------------------------------------
// CMigration
//---------------------------------------------------------------------------


// Construction -------------------------------------------------------------


// Constructor

CMigration::CMigration() :
	m_bTestMigration(false),
	m_bIntraForest(false),
	m_lRenameOption(admtDoNotRename),
	m_lPasswordOption(admtPasswordFromName),
	m_lConflictOptions(admtIgnoreConflicting)
{
}


// Destructor

CMigration::~CMigration()
{
}


// IMigration Implementation ------------------------------------------------


// TestMigration Property

STDMETHODIMP CMigration::put_TestMigration(VARIANT_BOOL bTest)
{
	m_bTestMigration = bTest ? true : false;

	return S_OK;
}

STDMETHODIMP CMigration::get_TestMigration(VARIANT_BOOL* pbTest)
{
	*pbTest = m_bTestMigration ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// IntraForest Property

STDMETHODIMP CMigration::put_IntraForest(VARIANT_BOOL bIntraForest)
{
	m_bIntraForest = bIntraForest ? true : false;

	return S_OK;
}

STDMETHODIMP CMigration::get_IntraForest(VARIANT_BOOL* pbIntraForest)
{
	*pbIntraForest = m_bIntraForest ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// SourceDomain Property

STDMETHODIMP CMigration::put_SourceDomain(BSTR bstrDomain)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrSourceDomain = bstrDomain;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_SourceDomain(BSTR* pbstrDomain)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrDomain = m_bstrSourceDomain.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// SourceOu Property

STDMETHODIMP CMigration::put_SourceOu(BSTR bstrOu)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrSourceOu = bstrOu;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_SourceOu(BSTR* pbstrOu)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrOu = m_bstrSourceOu.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// TargetDomain Property

STDMETHODIMP CMigration::put_TargetDomain(BSTR bstrDomain)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrTargetDomain = bstrDomain;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_TargetDomain(BSTR* pbstrDomain)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrDomain = m_bstrTargetDomain.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// TargetOu Property

STDMETHODIMP CMigration::put_TargetOu(BSTR bstrOu)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrTargetOu = bstrOu;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_TargetOu(BSTR* pbstrOu)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrOu = m_bstrTargetOu.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// RenameOption Property

STDMETHODIMP CMigration::put_RenameOption(long lOption)
{
	HRESULT hr = S_OK;

	if ((lOption >= admtDoNotRename) && (lOption <= admtRenameWithSuffix))
	{
		m_lRenameOption = lOption;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_INVALIDARG, IDS_E_RENAME_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CMigration::get_RenameOption(long* plOption)
{
	*plOption = m_lRenameOption;

	return S_OK;
}


// RenamePrefixOrSuffix Property

STDMETHODIMP CMigration::put_RenamePrefixOrSuffix(BSTR bstrPrefixOrSuffix)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrRenamePrefixOrSuffix = bstrPrefixOrSuffix;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_RenamePrefixOrSuffix(BSTR* pbstrPrefixOrSuffix)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrPrefixOrSuffix = m_bstrRenamePrefixOrSuffix.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// PasswordOption Property

STDMETHODIMP CMigration::put_PasswordOption(long lOption)
{
	HRESULT hr = S_OK;

	if ((lOption >= admtPasswordFromName) && (lOption <= admtCopyPassword))
	{
		m_lPasswordOption = lOption;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_INVALIDARG, IDS_E_PASSWORD_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CMigration::get_PasswordOption(long* plOption)
{
	*plOption = m_lPasswordOption;

	return S_OK;
}


// PasswordServer Property

STDMETHODIMP CMigration::put_PasswordServer(BSTR bstrServer)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrPasswordServer = bstrServer;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_PasswordServer(BSTR* pbstrServer)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrServer = m_bstrPasswordServer.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// GetValidDcName Method
//
// Retrieves name of domain controller in the given domain.

_bstr_t CMigration::GetValidDcName(_bstr_t strDcName)
{
	_bstr_t strName;

	PDOMAIN_CONTROLLER_INFO pdci;

	// attempt to retrieve DNS name of domain controller

	// Note: requires NT 4.0 SP6a

	DWORD dwError = DsGetDcName(strDcName, NULL, NULL, NULL, DS_RETURN_DNS_NAME, &pdci);

	// if domain controller not found, attempt to retrieve flat name of domain controller

	if (dwError == ERROR_NO_SUCH_DOMAIN)
	{
		dwError = DsGetDcName(strDcName, NULL, NULL, NULL, DS_RETURN_FLAT_NAME, &pdci);
	}

	// if domain controller found then save name otherwise generate error

	if (dwError == NO_ERROR)
	{
		// remove double backslash prefix to remain consistent with wizard

		strName = pdci->DomainControllerName + 2;

		NetApiBufferFree(pdci);
	}
	else
	{
		_com_issue_error(HRESULT_FROM_WIN32(dwError));
	}

	return strName;
}


// PasswordFile Property

STDMETHODIMP CMigration::put_PasswordFile(BSTR bstrPath)
{
	HRESULT hr = S_OK;

	try
	{
		_bstr_t strFile = bstrPath;

		if (strFile.length() > 0)
		{
			_TCHAR szPath[_MAX_PATH];
			LPTSTR pszFilePart;

			DWORD cchPath = GetFullPathName(strFile, _MAX_PATH, szPath, &pszFilePart);

			if ((cchPath == 0) || (cchPath >= _MAX_PATH))
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(GetLastError()), 
					IDS_E_PASSWORD_FILE,
					(LPCTSTR)strFile
				);
			}

			HANDLE hFile = CreateFile(
				szPath,
				GENERIC_WRITE,
				FILE_SHARE_READ|FILE_SHARE_WRITE,
				NULL,
				OPEN_ALWAYS,
				FILE_ATTRIBUTE_NORMAL,
				NULL
			);

			if (hFile == INVALID_HANDLE_VALUE)
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(GetLastError()), 
					IDS_E_PASSWORD_FILE,
					(LPCTSTR)strFile
				);
			}

			CloseHandle(hFile);

			m_bstrPasswordFile = szPath;
		}
		else
		{
			m_bstrPasswordFile = strFile;
		}
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_PasswordFile(BSTR* pbstrPath)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrPath = m_bstrPasswordFile.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// ConflictOptions Property

STDMETHODIMP CMigration::put_ConflictOptions(long lOptions)
{
	HRESULT hr = S_OK;

	long lOption = lOptions & 0x0F;
	long lFlags = lOptions & 0xF0;

	if ((lOption >= admtIgnoreConflicting) && (lOption <= admtRenameConflictingWithSuffix))
	{
		if ((lOption == admtReplaceConflicting) || (lFlags == 0))
		{
			m_lConflictOptions = lOptions;
		}
		else
		{
			hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_INVALIDARG, IDS_E_CONFLICT_FLAGS_NOT_ALLOWED);
		}
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_INVALIDARG, IDS_E_CONFLICT_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CMigration::get_ConflictOptions(long* plOptions)
{
	*plOptions = m_lConflictOptions;

	return S_OK;
}


// ConflictPrefixOrSuffix Property

STDMETHODIMP CMigration::put_ConflictPrefixOrSuffix(BSTR bstrPrefixOrSuffix)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrConflictPrefixOrSuffix = bstrPrefixOrSuffix;
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_ConflictPrefixOrSuffix(BSTR* pbstrPrefixOrSuffix)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrPrefixOrSuffix = m_bstrConflictPrefixOrSuffix.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// UserPropertiesToExclude Property

STDMETHODIMP CMigration::put_UserPropertiesToExclude(BSTR bstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrUserPropertiesToExclude = GetParsedExcludeProperties(bstrProperties);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_UserPropertiesToExclude(BSTR* pbstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrProperties = m_bstrUserPropertiesToExclude.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// GroupPropertiesToExclude Property

STDMETHODIMP CMigration::put_GroupPropertiesToExclude(BSTR bstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrGroupPropertiesToExclude = GetParsedExcludeProperties(bstrProperties);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_GroupPropertiesToExclude(BSTR* pbstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrProperties = m_bstrGroupPropertiesToExclude.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// ComputerPropertiesToExclude Property

STDMETHODIMP CMigration::put_ComputerPropertiesToExclude(BSTR bstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		m_bstrComputerPropertiesToExclude = GetParsedExcludeProperties(bstrProperties);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CMigration::get_ComputerPropertiesToExclude(BSTR* pbstrProperties)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrProperties = m_bstrComputerPropertiesToExclude.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL);
	}

	return hr;
}


// CreateUserMigration Method

STDMETHODIMP CMigration::CreateUserMigration(IUserMigration** pitfUserMigration)
{
	HRESULT hr = S_OK;

	try
	{
		UpdateDatabase();

		CComObject<CUserMigration>* pUserMigration;
		CheckError(CComObject<CUserMigration>::CreateInstance(&pUserMigration));
		CheckError(pUserMigration->QueryInterface(__uuidof(IUserMigration), (void**)pitfUserMigration));
		pUserMigration->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_USER_MIGRATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_USER_MIGRATION);
	}

	return hr;
}


// CreateGroupMigration Method

STDMETHODIMP CMigration::CreateGroupMigration(IGroupMigration** pitfGroupMigration)
{
	HRESULT hr = S_OK;

	try
	{
		UpdateDatabase();

		CComObject<CGroupMigration>* pGroupMigration;
		CheckError(CComObject<CGroupMigration>::CreateInstance(&pGroupMigration));
		CheckError(pGroupMigration->QueryInterface(__uuidof(IGroupMigration), (void**)pitfGroupMigration));
		pGroupMigration->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_GROUP_MIGRATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_GROUP_MIGRATION);
	}

	return hr;
}


// CreateComputerMigration Method

STDMETHODIMP CMigration::CreateComputerMigration(IComputerMigration** pitfComputerMigration)
{
	HRESULT hr = S_OK;

	try
	{
		UpdateDatabase();

		CComObject<CComputerMigration>* pComputerMigration;
		CheckError(CComObject<CComputerMigration>::CreateInstance(&pComputerMigration));
		CheckError(pComputerMigration->QueryInterface(__uuidof(IComputerMigration), (void**)pitfComputerMigration));
		pComputerMigration->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_COMPUTER_MIGRATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_COMPUTER_MIGRATION);
	}

	return hr;
}


// CreateSecurityTranslation Method

STDMETHODIMP CMigration::CreateSecurityTranslation(ISecurityTranslation** pitfSecurityTranslation)
{
	HRESULT hr = S_OK;

	try
	{
		UpdateDatabase();

		CComObject<CSecurityTranslation>* pSecurityTranslation;
		CheckError(CComObject<CSecurityTranslation>::CreateInstance(&pSecurityTranslation));
		CheckError(pSecurityTranslation->QueryInterface(__uuidof(ISecurityTranslation), (void**)pitfSecurityTranslation));
		pSecurityTranslation->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_SECURITY_TRANSLATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_SECURITY_TRANSLATION);
	}

	return hr;
}


// CreateServiceAccountEnumeration Method

STDMETHODIMP CMigration::CreateServiceAccountEnumeration(IServiceAccountEnumeration** pitfServiceAccountEnumeration)
{
	HRESULT hr = S_OK;

	try
	{
		UpdateDatabase();

		CComObject<CServiceAccountEnumeration>* pServiceAccountEnumeration;
		CheckError(CComObject<CServiceAccountEnumeration>::CreateInstance(&pServiceAccountEnumeration));
		CheckError(pServiceAccountEnumeration->QueryInterface(__uuidof(IServiceAccountEnumeration), (void**)pitfServiceAccountEnumeration));
		pServiceAccountEnumeration->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_SERVICE_ACCOUNT_ENUMERATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_SERVICE_ACCOUNT_ENUMERATION);
	}

	return hr;
}


// CreateReportGeneration Method

STDMETHODIMP CMigration::CreateReportGeneration(IReportGeneration** pitfReportGeneration)
{
	HRESULT hr = S_OK;

	try
	{
		UpdateDatabase();

		CComObject<CReportGeneration>* pReportGeneration;
		CheckError(CComObject<CReportGeneration>::CreateInstance(&pReportGeneration));
		CheckError(pReportGeneration->QueryInterface(__uuidof(IReportGeneration), (void**)pitfReportGeneration));
		pReportGeneration->SetInternalInterface(this);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, ce, IDS_E_CREATE_REPORT_GENERATION);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IMigration, E_FAIL, IDS_E_CREATE_REPORT_GENERATION);
	}

	return hr;
}


// UpdateDatabase

void CMigration::UpdateDatabase()
{
	try
	{
		// verify and create if necessary a source domain
		// sid column in the migrated objects table

		ISrcSidUpdatePtr spSrcSidUpdate(__uuidof(SrcSidUpdate));

		if (spSrcSidUpdate->QueryForSrcSidColumn() == VARIANT_FALSE)
		{
			spSrcSidUpdate->CreateSrcSidColumn(VARIANT_TRUE);
		}

		// verify and create if necessary an account
		// sid column in the account references table

		IIManageDBPtr spIManageDB(__uuidof(IManageDB));

		if (spIManageDB->SidColumnInARTable() == VARIANT_FALSE)
		{
			spIManageDB->CreateSidColumnInAR();
		}
	}
	catch (_com_error& ce)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, ce, IDS_E_UNABLE_TO_UPDATE_DATABASE);
	}
	catch (...)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_UNABLE_TO_UPDATE_DATABASE);
	}
}


//---------------------------------------------------------------------------
// GetParsedExcludeProperties Method
//
// Trims whitespace from comma delimited properties.
//
// 2001-02-06 Mark Oluper - initial
//---------------------------------------------------------------------------

_bstr_t CMigration::GetParsedExcludeProperties(LPCTSTR pszOld)
{
	tstring strNew;

	if (pszOld)
	{
		bool bInProperty = false;

		// for each character in input string

		for (LPCTSTR pch = pszOld; *pch; pch++)
		{
			// if not whitespace or comma

			if (!(_istspace(*pch) || (*pch == _T(','))))
			{
				// if not 'in property'

				if (!bInProperty)
				{
					// set 'in property'

					bInProperty = true;

					// if not first property add comma delimiter

					if (!strNew.empty())
					{
						strNew += _T(',');
					}
				}

				// add character to property

				strNew += *pch;
			}
			else
			{
				// if 'in property' reset

				if (bInProperty)
				{
					bInProperty = false;
				}
			}
		}
	}

	return strNew.c_str();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\groupmigration.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// GroupMigration Class
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CGroupMigration :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IGroupMigration, &IID_IGroupMigration, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CGroupMigration();
	~CGroupMigration();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CGroupMigration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IGroupMigration)
	END_COM_MAP()

public:

	// IGroupMigration

	STDMETHOD(put_MigrateSIDs)(VARIANT_BOOL bMigrate);
	STDMETHOD(get_MigrateSIDs)(VARIANT_BOOL* pbMigrate);
	STDMETHOD(put_UpdateGroupRights)(VARIANT_BOOL bUpdate);
	STDMETHOD(get_UpdateGroupRights)(VARIANT_BOOL* pbUpdate);
	STDMETHOD(put_UpdatePreviouslyMigratedObjects)(VARIANT_BOOL bUpdate);
	STDMETHOD(get_UpdatePreviouslyMigratedObjects)(VARIANT_BOOL* pbUpdate);
	STDMETHOD(put_FixGroupMembership)(VARIANT_BOOL bFix);
	STDMETHOD(get_FixGroupMembership)(VARIANT_BOOL* pbFix);
	STDMETHOD(put_MigrateMembers)(VARIANT_BOOL bMigrate);
	STDMETHOD(get_MigrateMembers)(VARIANT_BOOL* pbMigrate);
	STDMETHOD(put_DisableOption)(long lOption);
	STDMETHOD(get_DisableOption)(long* plOption);
	STDMETHOD(put_SourceExpiration)(long lExpiration);
	STDMETHOD(get_SourceExpiration)(long* plExpiration);
	STDMETHOD(put_TranslateRoamingProfile)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateRoamingProfile)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(Migrate)(long lOptions, VARIANT vntInclude, VARIANT vntExclude);

protected:

	void ValidateMigrationParameters();

	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource, CContainer& rTarget);
	void DoGroups(CContainer& rSource, CContainer& rTarget);
	void DoGroups(CDomainAccounts& rGroups, CContainer& rTarget);

	void SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet);
	void SetAccountOptions(CVarSet& rVarSet);

protected:

	bool m_bMigrateSids;
	bool m_bUpdateGroupRights;
	bool m_bUpdateMigrated;
	bool m_bFixGroupMembership;
	bool m_bMigrateMembers;
	long m_lDisableOption;
	long m_lSourceExpiration;
	bool m_bTranslateRoamingProfile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\groupmigration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "GroupMigration.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetAccountOptions.h"
#include "VarSetSecurity.h"


//---------------------------------------------------------------------------
// Group Migration Class
//---------------------------------------------------------------------------


CGroupMigration::CGroupMigration() :
	m_bMigrateSids(false),
	m_bUpdateGroupRights(false),
	m_bUpdateMigrated(false),
	m_bFixGroupMembership(true),
	m_bMigrateMembers(false),
	m_lDisableOption(admtEnableTarget),
	m_lSourceExpiration(admtNoExpiration),
	m_bTranslateRoamingProfile(false)
{
}


CGroupMigration::~CGroupMigration()
{
}


// IGroupMigration Implementation -------------------------------------------


// MigrateSIDs Property

STDMETHODIMP CGroupMigration::put_MigrateSIDs(VARIANT_BOOL bMigrate)
{
	m_bMigrateSids = bMigrate ? true : false;

	return S_OK;
}

STDMETHODIMP CGroupMigration::get_MigrateSIDs(VARIANT_BOOL* pbMigrate)
{
	*pbMigrate = m_bMigrateSids ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// UpdateGroupRights Property

STDMETHODIMP CGroupMigration::put_UpdateGroupRights(VARIANT_BOOL bUpdate)
{
	m_bUpdateGroupRights = bUpdate ? true : false;

	return S_OK;
}

STDMETHODIMP CGroupMigration::get_UpdateGroupRights(VARIANT_BOOL* pbUpdate)
{
	*pbUpdate = m_bUpdateGroupRights ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// UpdatePreviouslyMigratedObjects Property

STDMETHODIMP CGroupMigration::put_UpdatePreviouslyMigratedObjects(VARIANT_BOOL bUpdate)
{
	m_bUpdateMigrated = bUpdate ? true : false;

	return S_OK;
}

STDMETHODIMP CGroupMigration::get_UpdatePreviouslyMigratedObjects(VARIANT_BOOL* pbUpdate)
{
	*pbUpdate = m_bUpdateMigrated ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// FixGroupMembership Property

STDMETHODIMP CGroupMigration::put_FixGroupMembership(VARIANT_BOOL bFix)
{
	m_bFixGroupMembership = bFix ? true : false;

	return S_OK;
}

STDMETHODIMP CGroupMigration::get_FixGroupMembership(VARIANT_BOOL* pbFix)
{
	*pbFix = m_bFixGroupMembership ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// MigrateMembers Property

STDMETHODIMP CGroupMigration::put_MigrateMembers(VARIANT_BOOL bMigrate)
{
	m_bMigrateMembers = bMigrate ? true : false;

	return S_OK;
}

STDMETHODIMP CGroupMigration::get_MigrateMembers(VARIANT_BOOL* pbMigrate)
{
	*pbMigrate = m_bMigrateMembers ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// DisableOption Property

STDMETHODIMP CGroupMigration::put_DisableOption(long lOption)
{
	HRESULT hr = S_OK;

	if (IsDisableOptionValid(lOption))
	{
		m_lDisableOption = lOption;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IGroupMigration, E_INVALIDARG, IDS_E_DISABLE_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CGroupMigration::get_DisableOption(long* plOption)
{
	*plOption = m_lDisableOption;

	return S_OK;
}


// SourceExpiration Property

STDMETHODIMP CGroupMigration::put_SourceExpiration(long lExpiration)
{
	HRESULT hr = S_OK;

	if (IsSourceExpirationValid(lExpiration))
	{
		m_lSourceExpiration = lExpiration;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IGroupMigration, E_INVALIDARG, IDS_E_SOURCE_EXPIRATION_INVALID);
	}

	return hr;
}

STDMETHODIMP CGroupMigration::get_SourceExpiration(long* plExpiration)
{
	*plExpiration = m_lSourceExpiration;

	return S_OK;
}


// TranslateRoamingProfile Property

STDMETHODIMP CGroupMigration::put_TranslateRoamingProfile(VARIANT_BOOL bTranslate)
{
	m_bTranslateRoamingProfile = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CGroupMigration::get_TranslateRoamingProfile(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateRoamingProfile ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// Migrate Method

STDMETHODIMP CGroupMigration::Migrate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
	HRESULT hr = S_OK;

	MutexWait();

	bool bLogOpen = _Module.OpenLog();

	try
	{
		_Module.Log(ErrI, IDS_STARTED_GROUP_MIGRATION);

		InitSourceDomainAndContainer();
		InitTargetDomainAndContainer();

		VerifyInterIntraForest();
		ValidateMigrationParameters();

		if (m_bMigrateSids)
		{
			VerifyCanAddSidHistory();
		}

		VerifyPasswordOption();

		DoOption(lOptions, vntInclude, vntExclude);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IGroupMigration, ce, IDS_E_CANT_MIGRATE_GROUPS);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IGroupMigration, E_FAIL, IDS_E_CANT_MIGRATE_GROUPS);
	}

	if (bLogOpen)
	{
		_Module.CloseLog();
	}

	MutexRelease();

	return hr;
}


// Implementation -----------------------------------------------------------


// ValidateMigrationParameters Method

void CGroupMigration::ValidateMigrationParameters()
{
	bool bIntraForest = m_spInternal->IntraForest ? true : false;

	if (bIntraForest)
	{
		// validate conflict option

		long lConflictOptions = m_spInternal->ConflictOptions;
		long lConflictOption = lConflictOptions & 0x0F;

		if (lConflictOption == admtReplaceConflicting)
		{
			AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INTRA_FOREST_REPLACE);
		}
	}
}


// DoNames Method

void CGroupMigration::DoNames()
{
	CDomainAccounts aGroups;

	m_SourceDomain.QueryGroups(GetSourceContainer(), m_setIncludeNames, m_setExcludeNames, aGroups);

	DoGroups(aGroups, GetTargetContainer());
}


// DoDomain Method

void CGroupMigration::DoDomain()
{
	CContainer& rSource = GetSourceContainer();
	CContainer& rTarget = GetTargetContainer();

	if (m_nRecurseMaintain == 2)
	{
		rTarget.CreateContainerHierarchy(rSource);
	}

	DoContainers(rSource, rTarget);
}


// DoContainers Method

void CGroupMigration::DoContainers(CContainer& rSource, CContainer& rTarget)
{
	DoGroups(rSource, rTarget);

	if (m_nRecurseMaintain == 2)
	{
		ContainerVector aContainers;
		rSource.QueryContainers(aContainers);

		for (ContainerVector::iterator it = aContainers.begin(); it != aContainers.end(); it++)
		{
			DoContainers(*it, rTarget.GetContainer(it->GetName()));
		}
	}
}


// DoGroups Method

void CGroupMigration::DoGroups(CContainer& rSource, CContainer& rTarget)
{
	CDomainAccounts aGroups;
	rSource.QueryGroups(m_nRecurseMaintain == 1, m_setExcludeNames, aGroups);

	DoGroups(aGroups, rTarget);
}


// DoGroups Method

void CGroupMigration::DoGroups(CDomainAccounts& rGroups, CContainer& rTarget)
{
	if (rGroups.size() > 0)
	{
		CVarSet aVarSet;

		SetOptions(rTarget.GetPath(), aVarSet);
		SetAccountOptions(aVarSet);

		VerifyRenameConflictPrefixSuffixValid();

		FillInVarSetForGroups(rGroups, aVarSet);

		rGroups.clear();

		#ifdef _DEBUG
		aVarSet.Dump();
		#endif

		PerformMigration(aVarSet);

		SaveSettings(aVarSet);

		if ((m_nRecurseMaintain == 2) && m_bMigrateMembers)
		{
			FixObjectsInHierarchy(_T("user"));
		}
	}
}


// SetOptions Method

void CGroupMigration::SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet)
{
	CVarSetOptions aOptions(rVarSet);

	aOptions.SetTest(m_spInternal->TestMigration ? true : false);

	aOptions.SetUndo(false);
	aOptions.SetWizard(_T("group"));

	aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
	aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns(), m_SourceDomain.Sid());
	aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
	aOptions.SetTargetOu(strTargetOu);

	if (m_spInternal->PasswordOption == admtCopyPassword)
	{
		aOptions.SetTargetServer(m_TargetDomain.DomainControllerName());
	}

	aOptions.SetRenameOptions(m_spInternal->RenameOption, m_spInternal->RenamePrefixOrSuffix);
}


// SetAccountOptions Method

void CGroupMigration::SetAccountOptions(CVarSet& rVarSet)
{
	CVarSetAccountOptions aOptions(rVarSet);

	aOptions.SetPasswordOption(m_spInternal->PasswordOption, m_spInternal->PasswordServer);
	aOptions.SetPasswordFile(m_spInternal->PasswordFile);
	aOptions.SetConflictOptions(m_spInternal->ConflictOptions, m_spInternal->ConflictPrefixOrSuffix);

	aOptions.SetDisableOption(m_lDisableOption);
	aOptions.SetSourceExpiration(m_lSourceExpiration);
	aOptions.SetMigrateSids(m_bMigrateSids);
	aOptions.SetGroupMigrationOptions(m_bMigrateMembers, m_bUpdateMigrated);
//	aOptions.SetSidHistoryCredentials(NULL, NULL, NULL);
	aOptions.SetFixGroupMembership(m_bFixGroupMembership);
	aOptions.SetUpdateUserRights(m_bUpdateGroupRights);
	aOptions.SetTranslateRoamingProfile(m_bTranslateRoamingProfile);

	if (m_bMigrateMembers)
	{
		aOptions.SetExcludedUserProps(m_spInternal->UserPropertiesToExclude);
	}

	aOptions.SetExcludedGroupProps(m_spInternal->GroupPropertiesToExclude);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\migrationbase.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "MigrationBase.h"

#include <LM.h>

#include "Error.h"
#include "VarSetAccounts.h"
#include "VarSetServers.h"
#include "FixHierarchy.h"

using namespace _com_util;


namespace MigrationBase
{


void GetNamesFromData(VARIANT& vntData, StringSet& setNames);
void GetNamesFromVariant(VARIANT* pvnt, StringSet& setNames);
void GetNamesFromString(BSTR bstr, StringSet& setNames);
void GetNamesFromStringArray(SAFEARRAY* psa, StringSet& setNames);
void GetNamesFromVariantArray(SAFEARRAY* psa, StringSet& setNames);

void GetNamesFromFile(VARIANT& vntData, StringSet& setNames);
void GetNamesFromFile(LPCTSTR pszFileName, StringSet& setNames);
void GetNamesFromStringA(LPCSTR pchString, DWORD cchString, StringSet& setNames);
void GetNamesFromStringW(LPCWSTR pchString, DWORD cchString, StringSet& setNames);

_bstr_t RemoveTrailingDollarSign(LPCTSTR pszName);


}


using namespace MigrationBase;


//---------------------------------------------------------------------------
// MigrationBase Class
//---------------------------------------------------------------------------


// Constructor

CMigrationBase::CMigrationBase() :
	m_nRecurseMaintain(0),
	m_Mutex(ADMT_MUTEX)
{
}


// Destructor

CMigrationBase::~CMigrationBase()
{
}


// InitSourceDomainAndContainer Method

void CMigrationBase::InitSourceDomainAndContainer()
{
	m_SourceDomain.Initialize(m_spInternal->SourceDomain);
	m_SourceContainer = m_SourceDomain.GetContainer(m_spInternal->SourceOu);
}


// InitTargetDomainAndContainer Method

void CMigrationBase::InitTargetDomainAndContainer()
{
	m_TargetDomain.Initialize(m_spInternal->TargetDomain);
	m_TargetContainer = m_TargetDomain.GetContainer(m_spInternal->TargetOu);

	// verify target domain is in native mode

	if (m_TargetDomain.NativeMode() == false)
	{
		AdmtThrowError(
			GUID_NULL, GUID_NULL,
			E_INVALIDARG, IDS_E_TARGET_DOMAIN_NOT_NATIVE_MODE,
			(LPCTSTR)m_TargetDomain.Name()
		);
	}

	VerifyTargetContainerPathLength();
}


// VerifyInterIntraForest Method

void CMigrationBase::VerifyInterIntraForest()
{
	// if the source and target domains have the same forest name then they are intra-forest

	bool bIntraForest = m_spInternal->IntraForest ? true : false;

	if (m_SourceDomain.ForestName() == m_TargetDomain.ForestName())
	{
		// intra-forest must be set to true to match the domains

		if (!bIntraForest)
		{
			AdmtThrowError(
				GUID_NULL, GUID_NULL,
				E_INVALIDARG, IDS_E_NOT_INTER_FOREST,
				(LPCTSTR)m_SourceDomain.Name(), (LPCTSTR)m_TargetDomain.Name()
			);
		}
	}
	else
	{
		// intra-forest must be set to false to match the domains

		if (bIntraForest)
		{
			AdmtThrowError(
				GUID_NULL, GUID_NULL,
				E_INVALIDARG, IDS_E_NOT_INTRA_FOREST,
				(LPCTSTR)m_SourceDomain.Name(), (LPCTSTR)m_TargetDomain.Name()
			);
		}
	}
}


// DoOption Method

void CMigrationBase::DoOption(long lOptions, VARIANT& vntInclude, VARIANT& vntExclude)
{
	m_setIncludeNames.clear();
	m_setExcludeNames.clear();

	InitRecurseMaintainOption(lOptions);

	GetExcludeNames(vntExclude, m_setExcludeNames);

	switch (lOptions & 0xFF)
	{
		case admtNone:
		{
			DoNone();
			break;
		}
		case admtData:
		{
			GetNamesFromData(vntInclude, m_setIncludeNames);
			DoNames();
			break;
		}
		case admtFile:
		{
			GetNamesFromFile(vntInclude, m_setIncludeNames);
			DoNames();
			break;
		}
		case admtDomain:
		{
			m_setIncludeNames.clear();
			DoDomain();
			break;
		}
		default:
		{
			AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_OPTION);
			break;
		}
	}
}


// DoNone Method

void CMigrationBase::DoNone()
{
}


// DoNames Method

void CMigrationBase::DoNames()
{
}


// DoDomain Method

void CMigrationBase::DoDomain()
{
}


// InitRecurseMaintainOption Method

void CMigrationBase::InitRecurseMaintainOption(long lOptions)
{
	switch (lOptions & 0xFF)
	{
		case admtData:
		case admtFile:
		{
			if (lOptions & 0xFF00)
			{
				AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_DATA_OPTION_FLAGS_NOT_ALLOWED);
			}

			m_nRecurseMaintain = 0;
			break;
		}
		case admtDomain:
		{
			m_nRecurseMaintain = 0;

			if (lOptions & admtRecurse)
			{
				++m_nRecurseMaintain;

				if (lOptions & admtMaintainHierarchy)
				{
					++m_nRecurseMaintain;
				}
			}
			break;
		}
		default:
		{
			m_nRecurseMaintain = 0;
			break;
		}
	}
}


// GetExcludeNames Method

void CMigrationBase::GetExcludeNames(VARIANT& vntExclude, StringSet& setExcludeNames)
{
	try
	{
		switch (V_VT(&vntExclude))
		{
			case VT_EMPTY:
			case VT_ERROR:
			{
				setExcludeNames.clear();
				break;
			}
			case VT_BSTR:
			{
				GetNamesFromFile(V_BSTR(&vntExclude), setExcludeNames);
				break;
			}
			case VT_BSTR|VT_BYREF:
			{
				BSTR* pbstr = V_BSTRREF(&vntExclude);

				if (pbstr)
				{
					GetNamesFromFile(*pbstr, setExcludeNames);
				}
				break;
			}
			case VT_BSTR|VT_ARRAY:
			{
				GetNamesFromStringArray(V_ARRAY(&vntExclude), setExcludeNames);
				break;
			}
			case VT_BSTR|VT_ARRAY|VT_BYREF:
			{
				SAFEARRAY** ppsa = V_ARRAYREF(&vntExclude);

				if (ppsa)
				{
					GetNamesFromStringArray(*ppsa, setExcludeNames);
				}
				break;
			}
			case VT_VARIANT|VT_BYREF:
			{
				VARIANT* pvnt = V_VARIANTREF(&vntExclude);

				if (pvnt)
				{
					GetExcludeNames(*pvnt, setExcludeNames);
				}
				break;
			}
			case VT_VARIANT|VT_ARRAY:
			{
				GetNamesFromVariantArray(V_ARRAY(&vntExclude), setExcludeNames);
				break;
			}
			case VT_VARIANT|VT_ARRAY|VT_BYREF:
			{
				SAFEARRAY** ppsa = V_ARRAYREF(&vntExclude);

				if (ppsa)
				{
					GetNamesFromVariantArray(*ppsa, setExcludeNames);
				}
				break;
			}
			default:
			{
				_com_issue_error(E_INVALIDARG);
				break;
			}
		}
	}
	catch (_com_error& ce)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, ce.Error(), IDS_E_INVALID_EXCLUDE_DATA_TYPE);
	}
	catch (...)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_INVALID_EXCLUDE_DATA_TYPE);
	}
}


// FillInVarSetForUsers Method

void CMigrationBase::FillInVarSetForUsers(CDomainAccounts& rUsers, CVarSet& rVarSet)
{
	CVarSetAccounts aAccounts(rVarSet);

	for (CDomainAccounts::iterator it = rUsers.begin(); it != rUsers.end(); it++)
	{
		aAccounts.AddAccount(_T("User"), it->GetADsPath(), it->GetName(), it->GetUserPrincipalName());
	}
}


// FillInVarSetForGroups Method

void CMigrationBase::FillInVarSetForGroups(CDomainAccounts& rGroups, CVarSet& rVarSet)
{
	CVarSetAccounts aAccounts(rVarSet);

	for (CDomainAccounts::iterator it = rGroups.begin(); it != rGroups.end(); it++)
	{
		aAccounts.AddAccount(_T("Group"), it->GetADsPath(), it->GetName());
	}
}


// FillInVarSetForComputers Method

void CMigrationBase::FillInVarSetForComputers(CDomainAccounts& rComputers, bool bMigrateOnly, bool bMoveToTarget, bool bReboot, long lRebootDelay, CVarSet& rVarSet)
{
	CVarSetAccounts aAccounts(rVarSet);
	CVarSetServers aServers(rVarSet);

	for (CDomainAccounts::iterator it = rComputers.begin(); it != rComputers.end(); it++)
	{
		// remove trailing '$'
		// ADMT doesn't accept true SAM account name

		_bstr_t strName = RemoveTrailingDollarSign(it->GetSamAccountName());

		aAccounts.AddAccount(_T("Computer"), strName);
		aServers.AddServer(strName, bMigrateOnly, bMoveToTarget, bReboot, lRebootDelay);
	}
}


// VerifyRenameConflictPrefixSuffixValid Method

void CMigrationBase::VerifyRenameConflictPrefixSuffixValid()
{
	int nTotalPrefixSuffixLength = 0;

	long lRenameOption = m_spInternal->RenameOption;

	if ((lRenameOption == admtRenameWithPrefix) || (lRenameOption == admtRenameWithSuffix))
	{
		_bstr_t strPrefixSuffix = m_spInternal->RenamePrefixOrSuffix;

		nTotalPrefixSuffixLength += strPrefixSuffix.length();
	}

	long lConflictOption = m_spInternal->ConflictOptions & 0x0F;

	if ((lConflictOption == admtRenameConflictingWithSuffix) || (lConflictOption == admtRenameConflictingWithPrefix))
	{
		_bstr_t strPrefixSuffix = m_spInternal->ConflictPrefixOrSuffix;

		nTotalPrefixSuffixLength += strPrefixSuffix.length();
	}

	if (nTotalPrefixSuffixLength > MAXIMUM_PREFIX_SUFFIX_LENGTH)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_PREFIX_SUFFIX_TOO_LONG, MAXIMUM_PREFIX_SUFFIX_LENGTH);
	}
}


// VerifyCanAddSidHistory Method

void CMigrationBase::VerifyCanAddSidHistory()
{
	#define F_WORKS              0x00000000
	#define F_WRONGOS            0x00000001
	#define F_NO_REG_KEY         0x00000002
	#define F_NO_AUDITING_SOURCE 0x00000004
	#define F_NO_AUDITING_TARGET 0x00000008
	#define F_NO_LOCAL_GROUP     0x00000010

	try
	{
		long lErrorFlags = 0;

		IAccessCheckerPtr spAccessChecker(__uuidof(AccessChecker));

		spAccessChecker->CanUseAddSidHistory(m_SourceDomain.Name(), m_TargetDomain.Name(), &lErrorFlags);

		if (lErrorFlags != 0)
		{
			_bstr_t strError;

			CComBSTR str;

			if (lErrorFlags & F_NO_AUDITING_SOURCE)
			{
				str.LoadString(IDS_E_NO_AUDITING_SOURCE);
				strError += str.operator BSTR();
			}

			if (lErrorFlags & F_NO_AUDITING_TARGET)
			{
				str.LoadString(IDS_E_NO_AUDITING_TARGET);
				strError += str.operator BSTR();
			}

			if (lErrorFlags & F_NO_LOCAL_GROUP)
			{
				str.LoadString(IDS_E_NO_SID_HISTORY_LOCAL_GROUP);
				strError += str.operator BSTR();
			}

			if (lErrorFlags & F_NO_REG_KEY)
			{
				str.LoadString(IDS_E_NO_SID_HISTORY_REGISTRY_ENTRY);
				strError += str.operator BSTR();
			}

			AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_SID_HISTORY_CONFIGURATION, (LPCTSTR)strError);
		}
	}
	catch (_com_error& ce)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, ce, IDS_E_CAN_ADD_SID_HISTORY);
	}
	catch (...)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_CAN_ADD_SID_HISTORY);
	}
}


// VerifyTargetContainerPathLength Method

void CMigrationBase::VerifyTargetContainerPathLength()
{
	_bstr_t strPath = GetTargetContainer().GetPath();

	if (strPath.length() > 999)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_TARGET_CONTAINER_PATH_TOO_LONG);
	}
}


// VerifyPasswordServer Method

void CMigrationBase::VerifyPasswordOption()
{
	if (m_spInternal->PasswordOption == admtCopyPassword)
	{
		_bstr_t strServer = m_spInternal->PasswordServer;

		// a password server must be specified for copy password option

		if (strServer.length() == 0)
		{
			AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_PASSWORD_DC_NOT_SPECIFIED);
		}

		//
		// verify that password server exists and is a domain controller
		//

		_bstr_t strPrefixedServer;

		if (_tcsncmp(strServer, _T("\\\\"), 2) == 0)
		{
			strPrefixedServer = strServer;
		}
		else
		{
			strPrefixedServer = _T("\\\\") + strServer;
		}

		PSERVER_INFO_101 psiInfo;

		NET_API_STATUS nasStatus = NetServerGetInfo(strPrefixedServer, 101, (LPBYTE*)&psiInfo);

		if (nasStatus != NERR_Success)
		{
			AdmtThrowError(GUID_NULL, GUID_NULL, HRESULT_FROM_WIN32(nasStatus), IDS_E_PASSWORD_DC_NOT_FOUND, (LPCTSTR)strServer);
		}

		UINT uMsgId = 0;

		if (psiInfo->sv101_platform_id != PLATFORM_ID_NT)
		{
			uMsgId = IDS_E_PASSWORD_DC_NOT_NT;
		}
		else if (!(psiInfo->sv101_type & SV_TYPE_DOMAIN_CTRL) && !(psiInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL))
		{
			uMsgId = IDS_E_PASSWORD_DC_NOT_DC;
		}

		NetApiBufferFree(psiInfo);

		if (uMsgId)
		{
			AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, uMsgId, (LPCTSTR)strServer);
		}

		//
		// verify that password server is configured properly
		//

		IPasswordMigrationPtr spPasswordMigration(__uuidof(PasswordMigration));

		spPasswordMigration->EstablishSession(strServer, m_TargetDomain.DomainControllerName());
	}
}


// PerformMigration Method

void CMigrationBase::PerformMigration(CVarSet& rVarSet)
{
	IPerformMigrationTaskPtr spMigrator(__uuidof(Migrator));

	try
	{
		spMigrator->PerformMigrationTask(IUnknownPtr(rVarSet.GetInterface()), 0);
	}
	catch (_com_error& ce)
	{
		if (ce.Error() == MIGRATOR_E_PROCESSES_STILL_RUNNING)
		{
			AdmtThrowError(GUID_NULL, GUID_NULL, ce.Error(), IDS_E_ADMT_PROCESS_RUNNING);
		}
		else
		{
			throw;
		}
	}
}


// FixObjectsInHierarchy Method

void CMigrationBase::FixObjectsInHierarchy(LPCTSTR pszType)
{
	CFixObjectsInHierarchy fix;

	fix.SetObjectType(pszType);

	long lOptions = m_spInternal->ConflictOptions;
	long lOption = lOptions & 0x0F;
	long lFlags = lOptions & 0xF0;

	fix.SetFixReplaced((lOption == admtReplaceConflicting) && (lFlags & admtMoveReplacedAccounts));

	fix.SetSourceContainerPath(m_SourceContainer.GetPath());
	fix.SetTargetContainerPath(m_TargetContainer.GetPath());

	fix.FixObjects();
}


//---------------------------------------------------------------------------


namespace MigrationBase
{


// GetNamesFromData Method

void GetNamesFromData(VARIANT& vntData, StringSet& setNames)
{
	try
	{
		GetNamesFromVariant(&vntData, setNames);
	}
	catch (_com_error& ce)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, ce.Error(), IDS_E_INVALID_DATA_OPTION_DATA_TYPE);
	}
	catch (...)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_FAIL, IDS_E_INVALID_DATA_OPTION_DATA_TYPE);
	}
}


// GetNamesFromVariant Method

void GetNamesFromVariant(VARIANT* pvntData, StringSet& setNames)
{
	switch (V_VT(pvntData))
	{
		case VT_BSTR:
		{
			GetNamesFromString(V_BSTR(pvntData), setNames);
			break;
		}
		case VT_BSTR|VT_BYREF:
		{
			BSTR* pbstr = V_BSTRREF(pvntData);

			if (pbstr)
			{
				GetNamesFromString(*pbstr, setNames);
			}
			break;
		}
		case VT_BSTR|VT_ARRAY:
		{
			GetNamesFromStringArray(V_ARRAY(pvntData), setNames);
			break;
		}
		case VT_BSTR|VT_ARRAY|VT_BYREF:
		{
			SAFEARRAY** ppsa = V_ARRAYREF(pvntData);

			if (ppsa)
			{
				GetNamesFromStringArray(*ppsa, setNames);
			}
			break;
		}
		case VT_VARIANT|VT_BYREF:
		{
			VARIANT* pvnt = V_VARIANTREF(pvntData);

			if (pvnt)
			{
				GetNamesFromVariant(pvnt, setNames);
			}
			break;
		}
		case VT_VARIANT|VT_ARRAY:
		{
			GetNamesFromVariantArray(V_ARRAY(pvntData), setNames);
			break;
		}
		case VT_VARIANT|VT_ARRAY|VT_BYREF:
		{
			SAFEARRAY** ppsa = V_ARRAYREF(pvntData);

			if (ppsa)
			{
				GetNamesFromVariantArray(*ppsa, setNames);
			}
			break;
		}
		case VT_EMPTY:
		{
			// ignore empty variants
			break;
		}
		default:
		{
			_com_issue_error(E_INVALIDARG);
			break;
		}
	}
}


// GetNamesFromString Method

void GetNamesFromString(BSTR bstr, StringSet& setNames)
{
	if (bstr)
	{
		UINT cch = SysStringLen(bstr);

		if (cch > 0)
		{
			GetNamesFromStringW(bstr, cch, setNames);
		}
	}
}


// GetNamesFromStringArray Method

void GetNamesFromStringArray(SAFEARRAY* psa, StringSet& setNames)
{
	BSTR* pbstr;

	HRESULT hr = SafeArrayAccessData(psa, (void**)&pbstr);

	if (SUCCEEDED(hr))
	{
		try
		{
			UINT uDimensionCount = psa->cDims;

			for (UINT uDimension = 0; uDimension < uDimensionCount; uDimension++)
			{
				UINT uElementCount = psa->rgsabound[uDimension].cElements;

				for (UINT uElement = 0; uElement < uElementCount; uElement++)
				{
					setNames.insert(_bstr_t(*pbstr++));
				}
			}

			SafeArrayUnaccessData(psa);
		}
		catch (...)
		{
			SafeArrayUnaccessData(psa);
			throw;
		}
	}
}


// GetNamesFromVariantArray Method

void GetNamesFromVariantArray(SAFEARRAY* psa, StringSet& setNames)
{
	VARIANT* pvnt;

	HRESULT hr = SafeArrayAccessData(psa, (void**)&pvnt);

	if (SUCCEEDED(hr))
	{
		try
		{
			UINT uDimensionCount = psa->cDims;

			for (UINT uDimension = 0; uDimension < uDimensionCount; uDimension++)
			{
				UINT uElementCount = psa->rgsabound[uDimension].cElements;

				for (UINT uElement = 0; uElement < uElementCount; uElement++)
				{
					GetNamesFromVariant(pvnt++, setNames);
				}
			}

			SafeArrayUnaccessData(psa);
		}
		catch (...)
		{
			SafeArrayUnaccessData(psa);
			throw;
		}
	}
}


// GetNamesFromFile Method
//
// - the maximum file size this implementation can handle is 4,294,967,295 bytes

void GetNamesFromFile(VARIANT& vntData, StringSet& setNames)
{
	bool bInvalidArg = false;

	switch (V_VT(&vntData))
	{
		case VT_BSTR:
		{
			BSTR bstr = V_BSTR(&vntData);

			if (bstr)
			{
				GetNamesFromFile(bstr, setNames);
			}
			else
			{
				bInvalidArg = true;
			}
			break;
		}
		case VT_BSTR|VT_BYREF:
		{
			BSTR* pbstr = V_BSTRREF(&vntData);

			if (pbstr && *pbstr)
			{
				GetNamesFromFile(*pbstr, setNames);
			}
			else
			{
				bInvalidArg = true;
			}
			break;
		}
		case VT_VARIANT|VT_BYREF:
		{
			VARIANT* pvnt = V_VARIANTREF(&vntData);

			if (pvnt)
			{
				GetNamesFromFile(*pvnt, setNames);
			}
			else
			{
				bInvalidArg = true;
			}
			break;
		}
		default:
		{
			bInvalidArg = true;
			break;
		}
	}

	if (bInvalidArg)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILE_OPTION_DATA_TYPE);
	}
}


// GetNamesFromFile Method
//
// - the maximum file size this implementation can handle is 4,294,967,295 bytes

void GetNamesFromFile(LPCTSTR pszFileName, StringSet& setNames)
{
	HRESULT hr = S_OK;

	if (pszFileName)
	{
		HANDLE hFile = CreateFile(pszFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

		if (hFile != INVALID_HANDLE_VALUE)
		{
			DWORD dwFileSize = GetFileSize(hFile, NULL);

			if (dwFileSize > 0)
			{
				HANDLE hFileMappingObject = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

				if (hFileMappingObject != NULL)
				{
					LPVOID pvBase = MapViewOfFile(hFileMappingObject, FILE_MAP_READ, 0, 0, 0);

					if (pvBase != NULL)
					{
						// if Unicode signature assume Unicode file
						// otherwise it must be an ANSI file

						LPCWSTR pwcs = (LPCWSTR)pvBase;

						if ((dwFileSize >= 2) && (*pwcs == L'\xFEFF'))
						{
							GetNamesFromStringW(pwcs + 1, dwFileSize / sizeof(WCHAR) - 1, setNames);
						}
						else
						{
							GetNamesFromStringA((LPCSTR)pvBase, dwFileSize, setNames);
						}

						UnmapViewOfFile(pvBase);
					}
					else
					{
						hr = HRESULT_FROM_WIN32(GetLastError());
					}

					CloseHandle(hFileMappingObject);
				}
				else
				{
					hr = HRESULT_FROM_WIN32(GetLastError());
				}
			}

			CloseHandle(hFile);
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = E_INVALIDARG;
	}

	if (FAILED(hr))
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, hr, IDS_E_INCLUDE_NAMES_FILE, pszFileName);
	}
}


// GetNamesFromStringA Method

void GetNamesFromStringA(LPCSTR pchString, DWORD cchString, StringSet& setNames)
{
	static const CHAR chSeparators[] = "\t\n\r";

	LPCSTR pchStringEnd = &pchString[cchString];

	for (LPCSTR pch = pchString; pch < pchStringEnd; pch++)
	{
		// skip space characters

		while ((pch < pchStringEnd) && (*pch == ' '))
		{
			++pch;
		}

		// beginning of name

		LPCSTR pchBeg = pch;

		// scan for separator saving pointer to last non-whitespace character

		LPCSTR pchEnd = pch;

		while ((pch < pchStringEnd) && (strchr(chSeparators, *pch) == NULL))
		{
			if (*pch++ != ' ')
			{
				pchEnd = pch;
			}
		}

		// insert name which doesn't contain any leading or trailing whitespace characters

		if (pchEnd > pchBeg)
		{
			size_t cchName = pchEnd - pchBeg;
			LPSTR pszName = (LPSTR) _alloca((cchName + 1) * sizeof(CHAR));
			strncpy(pszName, pchBeg, cchName);
			pszName[cchName] = '\0';

			setNames.insert(_bstr_t(pszName));
		}
	}
}


// GetNamesFromStringW Method

void GetNamesFromStringW(LPCWSTR pchString, DWORD cchString, StringSet& setNames)
{
	static const WCHAR chSeparators[] = L"\t\n\r";

	LPCWSTR pchStringEnd = &pchString[cchString];

	for (LPCWSTR pch = pchString; pch < pchStringEnd; pch++)
	{
		// skip space characters

		while ((pch < pchStringEnd) && (*pch == L' '))
		{
			++pch;
		}

		// beginning of name

		LPCWSTR pchBeg = pch;

		// scan for separator saving pointer to last non-whitespace character

		LPCWSTR pchEnd = pch;

		while ((pch < pchStringEnd) && (wcschr(chSeparators, *pch) == NULL))
		{
			if (*pch++ != L' ')
			{
				pchEnd = pch;
			}
		}

		// insert name which doesn't contain any leading or trailing whitespace characters

		if (pchEnd > pchBeg)
		{
			_bstr_t strName(SysAllocStringLen(pchBeg, pchEnd - pchBeg), false);

			setNames.insert(strName);
		}
	}
}


// RemoveTrailingDollarSign Method

_bstr_t RemoveTrailingDollarSign(LPCTSTR pszName)
{
	LPTSTR psz = _T("");

	if (pszName)
	{
		size_t cch = _tcslen(pszName);

		if (cch > 0)
		{
			psz = reinterpret_cast<LPTSTR>(_alloca((cch + 1) * sizeof(_TCHAR)));

			_tcscpy(psz, pszName);

			LPTSTR p = &psz[cch - 1];

			if (*p == _T('$'))
			{
				*p = _T('\0');
			}
		}
	}

	return psz;
}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\migrationbase.h ===
#pragma once

#include <set>
#include "DomainAccount.h"
#include "DomainContainer.h"
#include "VarSetBase.h"
#include <MigrationMutex.h>

#ifndef StringSet
typedef std::set<_bstr_t> StringSet;
#endif

#define MAXIMUM_PREFIX_SUFFIX_LENGTH 8


//---------------------------------------------------------------------------
// MigrationBase Class
//---------------------------------------------------------------------------


class CMigrationBase
{
public:

	void SetInternalInterface(IMigrationInternal* pInternal)
	{
		m_spInternal = pInternal;
	}

protected:

	CMigrationBase();
	~CMigrationBase();

	void InitSourceDomainAndContainer();
	void InitTargetDomainAndContainer();

	void VerifyInterIntraForest();

	CContainer& GetSourceContainer()
	{
		if (m_SourceContainer)
		{
			return m_SourceContainer;
		}
		else
		{
			return m_SourceDomain;
		}
	}

	CContainer& GetTargetContainer()
	{
		if (m_TargetContainer)
		{
			return m_TargetContainer;
		}
		else
		{
			return m_TargetDomain;
		}
	}

	void DoOption(long lOptions, VARIANT& vntInclude, VARIANT& vntExclude);

	virtual void DoNone();
	virtual void DoNames();
	virtual void DoDomain();

	void FillInVarSetForUsers(CDomainAccounts& rUsers, CVarSet& rVarSet);
	void FillInVarSetForGroups(CDomainAccounts& rGroups, CVarSet& rVarSet);
	void FillInVarSetForComputers(CDomainAccounts& rComputers, bool bMigrateOnly, bool bMoveToTarget, bool bReboot, long lRebootDelay, CVarSet& rVarSet);

	void MutexWait()
	{
		m_Mutex.ObtainOwnership();
	}

	void MutexRelease()
	{
		m_Mutex.ReleaseOwnership();
	}

	void VerifyRenameConflictPrefixSuffixValid();
	void VerifyCanAddSidHistory();
	void VerifyTargetContainerPathLength();
	void VerifyPasswordOption();

	void PerformMigration(CVarSet& rVarSet);

	void SaveSettings(CVarSet& rVarSet)
	{
		IIManageDBPtr spDatabase(__uuidof(IManageDB));
		spDatabase->SaveSettings(IUnknownPtr(rVarSet.GetInterface()));
	}

	void FixObjectsInHierarchy(LPCTSTR pszType);

protected:

	void InitRecurseMaintainOption(long lOptions);
	void GetExcludeNames(VARIANT& vntExclude, StringSet& setExcludeNames);

protected:

	IMigrationInternalPtr m_spInternal;

	CDomain m_SourceDomain;
	CContainer m_SourceContainer;

	CDomain m_TargetDomain;
	CContainer m_TargetContainer;

	int m_nRecurseMaintain;

	StringSet m_setIncludeNames;
	StringSet m_setExcludeNames;

	CMigrationMutex m_Mutex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\reportgeneration.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// ReportGeneration Class
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CReportGeneration :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IReportGeneration, &IID_IReportGeneration, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CReportGeneration();
	~CReportGeneration();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CReportGeneration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IReportGeneration)
	END_COM_MAP()

public:

	// IReport

	STDMETHOD(put_Type)(long lType);
	STDMETHOD(get_Type)(long* plType);
	STDMETHOD(put_Folder)(BSTR bstrFolder);
	STDMETHOD(get_Folder)(BSTR* pbstrFolder);
	STDMETHOD(Generate)(long lOption, VARIANT vntInclude, VARIANT vntExclude);

protected:

	virtual void DoNone();
	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource);
	void DoComputers(CContainer& rSource);
	void DoComputers(CDomainAccounts& rComputers);

	void SetOptions(CVarSet& rVarSet);
	void SetReports(CVarSet& rVarSet);

protected:

	long m_lType;
	_bstr_t m_bstrFolder;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\namecracker.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "NameCracker.h"
#include <LM.h>
#include <NtDsApi.h>
#pragma comment(lib, "NtDsApi.lib")
#include <DsGetDC.h>
#include "Error.h"
#include "AdsiHelpers.h"


namespace
{

const _TCHAR CANONICAL_DELIMITER = _T('/');
const _TCHAR SAM_DELIMITER = _T('\\');
const _TCHAR SAM_INVALID_CHARACTERS[] = _T("\"*+,./:;<=>?[\\]|");

}


//---------------------------------------------------------------------------
// Name Cracker Class
//---------------------------------------------------------------------------


CNameCracker::CNameCracker()
{
}


CNameCracker::~CNameCracker()
{
}


void CNameCracker::CrackNames(const StringVector& vecNames)
{
	// separate the names into canonical names,
	// SAM account names and relative distinguished names

	StringVector vecCanonicalNames;
	StringVector vecSamAccountNames;
	StringVector vecRelativeDistinguishedNames;

	Separate(vecNames, vecCanonicalNames, vecSamAccountNames, vecRelativeDistinguishedNames);

	// then crack canonical names

	CrackCanonicalNames(vecCanonicalNames, vecRelativeDistinguishedNames);

	// then crack SAM account names

	CrackSamAccountNames(vecSamAccountNames, vecRelativeDistinguishedNames);

	// then crack relative distinguished names

	CrackRelativeDistinguishedNames(vecRelativeDistinguishedNames, m_vecUnResolvedNames);
}


void CNameCracker::Separate(
	const StringVector& vecNames,
	StringVector& vecCanonicalNames,
	StringVector& vecSamAccountNames,
	StringVector& vecRelativeDistinguishedNames
)
{
	// for each name in vector...

	for (StringVector::const_iterator it = vecNames.begin(); it != vecNames.end(); it++)
	{
		const tstring& strName = *it;

		// if non empty name...

		if (strName.empty() == false)
		{
			LPCTSTR pszName = strName.c_str();

			// then if name contains a solidus '/' character...

			if (_tcschr(pszName, CANONICAL_DELIMITER))
			{
				// then assume canonical name
				vecCanonicalNames.push_back(strName);
			}
			else
			{
				// otherwise if name contains a reverse solidus '\'
				// character and no invalid SAM account name characters...

				LPCTSTR pchDelimiter = _tcschr(pszName, SAM_DELIMITER);

				if (pchDelimiter && (_tcspbrk(pchDelimiter + 1, SAM_INVALID_CHARACTERS) == NULL))
				{
					// then assume SAM account name
					vecSamAccountNames.push_back(strName);
				}
				else
				{
					// otherwise assume relative distinguished name
					vecRelativeDistinguishedNames.push_back(strName);
				}
			}
		}
	}
}


void CNameCracker::CrackCanonicalNames(const StringVector& vecCanonicalNames, StringVector& vecUnResolvedNames)
{
	//
	// for each name generate a complete canonical name
	//

	CNameVector vecNames;
	tstring strCanonical;

	for (StringVector::const_iterator it = vecCanonicalNames.begin(); it != vecCanonicalNames.end(); it++)
	{
		const tstring& strName = *it;

		// if first character is the solidus '/' character...

		if (strName[0] == CANONICAL_DELIMITER)
		{
			// then generate complete canonical name
			strCanonical = m_strDnsName + strName;
		}
		else
		{
			// otherwise if already complete canonical name for this domain...

			if (_tcsnicmp(m_strDnsName.c_str(), strName.c_str(), m_strDnsName.length()) == 0)
			{
				// then add complete canonical name
				strCanonical = strName;
			}
			else
			{
				// otherwise prefix DNS domain name with solidus and add
				strCanonical = m_strDnsName + CANONICAL_DELIMITER + strName;
			}
		}

		vecNames.push_back(SName(strName.c_str(), strCanonical.c_str()));
	}

	//
	// crack canonical names
	//

	CrackNames(CANONICAL_NAME, vecNames);

	for (size_t i = 0; i < vecNames.size(); i++)
	{
		const SName& name = vecNames[i];

		if (name.strResolved.empty() == false)
		{
			m_setResolvedNames.insert(name.strResolved);
		}
		else
		{
			vecUnResolvedNames.push_back(name.strPartial);
		}
	}
}


void CNameCracker::CrackSamAccountNames(const StringVector& vecSamAccountNames, StringVector& vecUnResolvedNames)
{
	//
	// for each name generate a NT4 account name
	//

	CNameVector vecNames;
	tstring strNT4Account;

	for (StringVector::const_iterator it = vecSamAccountNames.begin(); it != vecSamAccountNames.end(); it++)
	{
		const tstring& strName = *it;

		// if first character is the reverse solidus '\' character...

		if (strName[0] == SAM_DELIMITER)
		{
			// then generate downlevel name
			strNT4Account = m_strFlatName + strName;
		}
		else
		{
			// otherwise if already downlevel name for this domain...

			if (_tcsnicmp(m_strFlatName.c_str(), strName.c_str(), m_strFlatName.length()) == 0)
			{
				// then add downlevel name
				strNT4Account = strName;
			}
			else
			{
				// otherwise prefix flat domain name with reverse solidus and add
				strNT4Account = m_strFlatName + SAM_DELIMITER + strName;
			}
		}

		vecNames.push_back(SName(strName.c_str(), strNT4Account.c_str()));
	}

	//
	// crack names
	//

	CrackNames(NT4_ACCOUNT_NAME, vecNames);

	for (size_t i = 0; i < vecNames.size(); i++)
	{
		const SName& name = vecNames[i];

		if (name.strResolved.empty() == false)
		{
			m_setResolvedNames.insert(name.strResolved);
		}
		else
		{
			vecUnResolvedNames.push_back(name.strPartial);
		}
	}
}


void CNameCracker::CrackRelativeDistinguishedNames(const StringVector& vecRelativeDistinguishedNames, StringVector& vecUnResolvedNames)
{
	CDirectorySearch dsSearch = IDispatchPtr(m_spDefaultContainer);

	dsSearch.AddAttribute(ATTRIBUTE_DISTINGUISHED_NAME);
	dsSearch.SetPreferences(ADS_SCOPE_ONELEVEL);

	for (StringVector::const_iterator it = vecRelativeDistinguishedNames.begin(); it != vecRelativeDistinguishedNames.end(); it++)
	{
		tstring strFilter = _T("(") + GetEscapedFilterName(it->c_str()) + _T(")");

		dsSearch.SetFilter(strFilter.c_str());
		dsSearch.Search();

		bool bFound = false;

		try
		{
			for (bool bGet = dsSearch.GetFirstRow(); bGet; bGet = dsSearch.GetNextRow())
			{
				m_setResolvedNames.insert(tstring(_bstr_t(dsSearch.GetAttributeValue(ATTRIBUTE_DISTINGUISHED_NAME))));

				bFound = true;
			}
		}
		catch (_com_error& ce)
		{
		#ifdef _DEBUG
			_TCHAR sz[2048];
			_stprintf(sz, _T("'%s' : %s : 0x%08lX\n"), it->c_str(), ce.ErrorMessage(), ce.Error());
			OutputDebugString(sz);
		#endif
			bFound = false;
		}
		catch (...)
		{
			bFound = false;
		}

		if (!bFound)
		{
			vecUnResolvedNames.push_back(*it);
		}
	}
}


void CNameCracker::CrackNames(NAME_FORMAT eFormat, CNameVector& vecNames)
{
	HANDLE hDs = NULL;
	LPTSTR apszNames = NULL;
	PDS_NAME_RESULT pdnrResult = NULL;

	try
	{
		if (vecNames.size() > 0)
		{
			DWORD dwError = DsBind(m_strDomainController.c_str(), NULL, &hDs);

			if (dwError == NO_ERROR)
			{
				DWORD dwCount = vecNames.size();
				LPCTSTR* apszNames = new LPCTSTR[dwCount];

				if (apszNames != NULL)
				{
					for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++)
					{
						apszNames[dwIndex] = vecNames[dwIndex].strComplete.c_str();
					}

					dwError = DsCrackNames(
						hDs,
						DS_NAME_NO_FLAGS,
						(eFormat == CANONICAL_NAME) ? DS_CANONICAL_NAME : (eFormat == NT4_ACCOUNT_NAME) ? DS_NT4_ACCOUNT_NAME : DS_UNKNOWN_NAME,
						DS_FQDN_1779_NAME,
						dwCount,
						const_cast<LPTSTR*>(apszNames),
						&pdnrResult
					);

					if (dwError == NO_ERROR)
					{
						DWORD c = pdnrResult->cItems;

						for (DWORD i = 0; i < c; i++)
						{
							DS_NAME_RESULT_ITEM& dnriItem = pdnrResult->rItems[i];

							if (dnriItem.status == DS_NAME_NO_ERROR)
							{
								vecNames[i].strResolved = dnriItem.pName;
							}
						}

						DsFreeNameResult(pdnrResult);
					}
					else
					{
						_com_issue_error(HRESULT_FROM_WIN32(dwError));
					}

					delete [] apszNames;
				}
				else
				{
					_com_issue_error(E_OUTOFMEMORY);
				}

				DsUnBind(&hDs);
			}
			else
			{
				_com_issue_error(HRESULT_FROM_WIN32(dwError));
			}
		}
	}
	catch (...)
	{
		if (pdnrResult)
		{
			DsFreeNameResult(pdnrResult);
		}

		delete [] apszNames;

		if (hDs)
		{
			DsUnBind(&hDs);
		}

		throw;
	}
}


tstring CNameCracker::GetEscapedFilterName(LPCTSTR pszName)
{
	tstring strNameEscaped;

	if (pszName)
	{
		// generate escaped name

		for (LPCTSTR pch = pszName; *pch; pch++)
		{
			switch (*pch)
			{
				case _T('('):
				{
					strNameEscaped += _T("\\28");
					break;
				}
				case _T(')'):
				{
					strNameEscaped += _T("\\29");
					break;
				}
				case _T('*'):
				{
					strNameEscaped += _T("\\2A");
					break;
				}
				case _T('\\'):
				{
					if (*(pch + 1) == _T('\\'))
					{
						strNameEscaped += _T("\\5C");
					}
					break;
				}
				default:
				{
					strNameEscaped += *pch;
					break;
				}
			}
		}
	}

	return strNameEscaped;
}


namespace
{

// SplitCanonicalName Method
//
// Given 'a.company.com/Sales/West/Name' this method splits the complete
// canonical name into its component parts Domain='a.company.com',
// Path='/Sales/West/', Name='Name'.
//
// Given 'Sales/West/Name' this method splits the partial canonical name
// into its component parts Domain='', Path='/Sales/West/', Name='Name'.
//
// Given 'Name' this method splits the partial canonical name into its
// component parts Domain='', Path='/', Name='Name'.

void SplitCanonicalName(LPCTSTR pszName, _bstr_t& strDomain, _bstr_t& strPath, _bstr_t& strName)
{
	strDomain = (LPCTSTR)NULL;
	strPath = (LPCTSTR)NULL;
	strName = (LPCTSTR)NULL;

	if (pszName)
	{
		tstring str = pszName;

		UINT posA = 0;
		UINT posB = tstring::npos;

		do
		{
			posA = str.find_first_of(_T('/'), posA ? posA + 1 : posA);
		}
		while ((posA != 0) && (posA != tstring::npos) && (str[posA - 1] == _T('\\')));

		do
		{
			posB = str.find_last_of(_T('/'), (posB != tstring::npos) ? posB - 1 : posB);
		}
		while ((posB != 0) && (posB != tstring::npos) && (str[posB - 1] == _T('\\')));

		strDomain = str.substr(0, posA).c_str();
		strPath = str.substr(posA, posB - posA).c_str();
		strName = str.substr(posB).c_str();
	}
}

void SplitPath(LPCTSTR pszPath, _bstr_t& strPath, _bstr_t& strName)
{
	strPath = (LPCTSTR)NULL;
	strName = (LPCTSTR)NULL;

	if (pszPath)
	{
		tstring str = pszPath;

		UINT pos = str.find_first_of(_T('\\'));

		if (pos != tstring::npos)
		{
			strName = pszPath;
		}
		else
		{
			UINT posA = str.find_first_of(_T('/'));

			if (posA == tstring::npos)
			{
				strName = (_T("/") + str).c_str();
			}
			else
			{
				UINT posB = str.find_last_of(_T('/'));

				strPath = str.substr(posA, posB - posA).c_str();
				strName = str.substr(posB).c_str();
			}
		}
	}
}

}


//---------------------------------------------------------------------------
// Ignore Case String Less
//---------------------------------------------------------------------------

struct SIgnoreCaseStringLess :
	public std::binary_function<tstring, tstring, bool>
{
	bool operator()(const tstring& x, const tstring& y) const
	{
		bool bLess;

		LPCTSTR pszX = x.c_str();
		LPCTSTR pszY = y.c_str();

		if (pszX == pszY)
		{
			bLess = false;
		}
		else if (pszX == NULL)
		{
			bLess = true;
		}
		else if (pszY == NULL)
		{
			bLess = false;
		}
		else
		{
			bLess = _tcsicmp(pszX, pszY) < 0;
		}

		return bLess;
	}
};


//---------------------------------------------------------------------------
// CDomainMap Implementation
//---------------------------------------------------------------------------


class CDomainMap :
	public std::map<_bstr_t, StringSet, IgnoreCaseStringLess>
{
public:

	CDomainMap()
	{
	}

	void Initialize(const StringSet& setNames)
	{
		_bstr_t strDefaultDns(_T("/"));
		_bstr_t strDefaultFlat(_T("\\"));

		for (StringSet::const_iterator it = setNames.begin(); it != setNames.end(); it++)
		{
			tstring strName = *it;

			// if not an empty name...

			if (strName.empty() == false)
			{
				// if name contains a canonical name delimiter...

				UINT posDelimiter = strName.find(CANONICAL_DELIMITER);

				if (posDelimiter != tstring::npos)
				{
					// then assume canonical name

					if (posDelimiter == 0)
					{
						// then generate complete canonical name
						Insert(strDefaultDns, *it);
					}
					else
					{
						// otherwise if path component before delimiter contains
						// a period

						UINT posDot = strName.find(_T('.'));

						if (posDot < posDelimiter)
						{
							// then assume a complete canonical name with DNS domain name prefix
							Insert(strName.substr(0, posDelimiter).c_str(), *it);
						}
						else
						{
							// otherwise assume domain name has not been specified
							Insert(strDefaultDns, *it);
						}
					}
				}
				else
				{
					// otherwise if name contains a NT account name delimiter
					// character and no invalid SAM account name characters...

					UINT posDelimiter = strName.find(SAM_DELIMITER);

					if (posDelimiter != tstring::npos)
					{
						if (strName.find_first_of(SAM_INVALID_CHARACTERS, posDelimiter + 1) == tstring::npos)
						{
							if (posDelimiter == 0)
							{
								Insert(strDefaultFlat, *it);
							}
							else
							{
								// then assume SAM account name
								Insert(strName.substr(0, posDelimiter).c_str(), *it);
							}
						}
						else
						{
							// otherwise assume relative distinguished name
							Insert(strDefaultDns, *it);
						}
					}
					else
					{
						Insert(strDefaultDns, *it);
					}
				}
			}
		}
	}

protected:

	void Insert(_bstr_t strDomain, _bstr_t strName)
	{
		iterator it = find(strDomain);

		if (it == end())
		{
			std::pair<iterator, bool> pair = insert(value_type(strDomain, StringSet()));
			it = pair.first;
		}

		it->second.insert(strName);
	}
};


//---------------------------------------------------------------------------
// CDomainToPathMap Implementation
//---------------------------------------------------------------------------


// Initialize Method

void CDomainToPathMap::Initialize(LPCTSTR pszDefaultDomainDns, LPCTSTR pszDefaultDomainFlat, const StringSet& setNames)
{
	CDomainMap map;

	map.Initialize(setNames);

	for (CDomainMap::const_iterator itDomain = map.begin(); itDomain != map.end(); itDomain++)
	{
		_bstr_t strDomainName = itDomain->first;

		LPCTSTR pszDomainName = strDomainName;

		if (pszDomainName && ((*pszDomainName == _T('/')) || (*pszDomainName == _T('\\'))))
		{
			strDomainName = (pszDefaultDomainDns && (_tcslen(pszDefaultDomainDns) > 0)) ? pszDefaultDomainDns : pszDefaultDomainFlat;
		}
		else
		{
			if (GetValidDomainName(strDomainName) == false)
			{
				strDomainName = (pszDefaultDomainDns && (_tcslen(pszDefaultDomainDns) > 0)) ? pszDefaultDomainDns : pszDefaultDomainFlat;
			}
		}

		iterator it = find(strDomainName);

		if (it == end())
		{
			std::pair<iterator, bool> pair = insert(value_type(strDomainName, StringSet()));
			it = pair.first;
		}

		StringSet& setNames = it->second;

		const StringSet& set = itDomain->second;

		for (StringSet::const_iterator itSet = set.begin(); itSet != set.end(); itSet++)
		{
			setNames.insert(*itSet);
		}
	}
}


// GetValidDomainName Method

bool CDomainToPathMap::GetValidDomainName(_bstr_t& strDomainName)
{
	bool bValid = false;

	PDOMAIN_CONTROLLER_INFO pdci;

	// attempt to retrieve DNS name of domain controller supporting active directory service

	DWORD dwError = DsGetDcName(NULL, strDomainName, NULL, NULL, DS_RETURN_DNS_NAME, &pdci);

	// if domain controller not found, attempt to retrieve flat name of domain controller

	if (dwError == ERROR_NO_SUCH_DOMAIN)
	{
		dwError = DsGetDcName(NULL, strDomainName, NULL, NULL, DS_RETURN_FLAT_NAME, &pdci);
	}

	// if domain controller found then save name otherwise generate error

	if (dwError == NO_ERROR)
	{
		strDomainName = pdci->DomainName;

		NetApiBufferFree(pdci);

		bValid = true;
	}

	return bValid;
}


//
// CNameToPathMap Implementation
//


CNameToPathMap::CNameToPathMap()
{
}

CNameToPathMap::CNameToPathMap(StringSet& setNames)
{
	Initialize(setNames);
}

void CNameToPathMap::Initialize(StringSet& setNames)
{
	_bstr_t strDomain;
	_bstr_t strPath;
	_bstr_t strName;

	for (StringSet::iterator it = setNames.begin(); it != setNames.end(); it++)
	{
	//	SplitPath(*it, strPath, strName);
		SplitCanonicalName(*it, strDomain, strPath, strName);

		Add(strName, strPath);
	}
}

void CNameToPathMap::Add(_bstr_t& strName, _bstr_t& strPath)
{
	iterator it = find(strName);

	if (it == end())
	{
		std::pair<iterator, bool> pair = insert(value_type(strName, StringSet()));

		it = pair.first;
	}

	it->second.insert(strPath);
}


//
// IgnoreCaseStringLess Implementation
//


bool IgnoreCaseStringLess::operator()(const _bstr_t& x, const _bstr_t& y) const
{
	bool bLess;

	LPCTSTR pszThis = x;
	LPCTSTR pszThat = y;

	if (pszThis == pszThat)
	{
		bLess = false;
	}
	else if (pszThis == NULL)
	{
		bLess = true;
	}
	else if (pszThat == NULL)
	{
		bLess = false;
	}
	else
	{
		bLess = _tcsicmp(pszThis, pszThat) < 0;
	}

	return bLess;
}


//
// CCompareStrings Implementation
//


CCompareStrings::CCompareStrings()
{
}

CCompareStrings::CCompareStrings(StringSet& setNames)
{
	Initialize(setNames);
}

void CCompareStrings::Initialize(StringSet& setNames)
{
	for (StringSet::iterator it = setNames.begin(); it != setNames.end(); it++)
	{
		m_vecCompareStrings.push_back(CCompareString(*it));
	}
}

bool CCompareStrings::IsMatch(LPCTSTR pszName)
{
	bool bIs = false;

	CompareStringVector::iterator itBeg = m_vecCompareStrings.begin();
	CompareStringVector::iterator itEnd = m_vecCompareStrings.end();

	for (CompareStringVector::iterator it = itBeg; it != itEnd; it++)
	{
		if (it->IsMatch(pszName))
		{
			bIs = true;

			break;
		}
	}

	return bIs;
}


//
// CCompareString Implementation
//


CCompareStrings::CCompareString::CCompareString(LPCTSTR pszCompare)
{
	if (pszCompare)
	{
		Initialize(pszCompare);
	}
}

CCompareStrings::CCompareString::CCompareString(const CCompareString& r) :
	m_nType(r.m_nType),
	m_strCompare(r.m_strCompare)
{
}

void CCompareStrings::CCompareString::Initialize(LPCTSTR pszCompare)
{
	if (pszCompare)
	{
		tstring str = pszCompare;

		UINT uLength = str.length();

		bool bBeg = (str[0] == _T('*'));
		bool bEnd = false;

		if ((uLength > 1) && (str[uLength - 1] == _T('*')) && (str[uLength - 2] != _T('\\')))
		{
			bEnd = true;
		}

		if (bBeg && bEnd)
		{
			// contains
			m_nType = 3;
			str = str.substr(1, uLength - 2);
		}
		else if (bBeg)
		{
			// ends with
			m_nType = 2;
			str = str.substr(1, uLength - 1);
		}
		else if (bEnd)
		{
			// begins with
			m_nType = 1;
			str = str.substr(0, uLength - 1);
		}
		else
		{
			// equals
			m_nType = 0;
		}

		if (str.length() > 0)
		{
			// replace escaped asterisks with asterisk

			for (UINT pos = str.find(_T('*')); pos != tstring::npos; pos = str.find(_T('*'), pos))
			{
				if ((pos > 0) && (str[pos - 1] == _T('\\')))
				{
					str = str.substr(0, pos - 1) + str.substr(pos);
				}
				else
				{
					AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszCompare);
				}
			}

			m_strCompare = str.c_str();
		}
		else
		{
			AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, pszCompare);
		}
	}
	else
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_FILTER_STRING, _T(""));
	}
}

bool CCompareStrings::CCompareString::IsMatch(LPCTSTR psz)
{
	bool bIs = false;

	if (psz)
	{
		switch (m_nType)
		{
			case 0: // equals
			{
				bIs = (_tcsicmp(psz, m_strCompare) == 0);
				break;
			}
			case 1: // begins with
			{
				bIs = (_tcsnicmp(psz, m_strCompare, m_strCompare.length()) == 0);
				break;
			}
			case 2: // ends with
			{
				UINT cchT = _tcslen(psz);
				UINT cchC = m_strCompare.length();

				if (cchT >= cchC)
				{
					bIs = (_tcsnicmp(psz + cchT - cchC, m_strCompare, cchC) == 0);
				}
				break;
			}
			case 3: // contains
			{
				LPTSTR pszT = (LPTSTR)_alloca((_tcslen(psz) + 1) * sizeof(_TCHAR));
				LPTSTR pszC = (LPTSTR)_alloca((m_strCompare.length() + 1) * sizeof(_TCHAR));

				_tcscpy(pszT, psz);
				_tcscpy(pszC, m_strCompare);

				_tcslwr(pszT);
				_tcslwr(pszC);

				bIs = (_tcsstr(pszT, pszC) != NULL);
				break;
			}
		}
	}

	return bIs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\securitytranslation.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// SecurityTranslation Class
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CSecurityTranslation :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ISecurityTranslation, &IID_ISecurityTranslation, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CSecurityTranslation();
	~CSecurityTranslation();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CSecurityTranslation)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(ISecurityTranslation)
	END_COM_MAP()

public:

	// ISecurityTranslation

	STDMETHOD(put_TranslationOption)(long lOption);
	STDMETHOD(get_TranslationOption)(long* plOption);
	STDMETHOD(put_TranslateFilesAndFolders)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateFilesAndFolders)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateLocalGroups)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateLocalGroups)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslatePrinters)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslatePrinters)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateRegistry)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateRegistry)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateShares)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateShares)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateUserProfiles)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateUserProfiles)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_TranslateUserRights)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateUserRights)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_SidMappingFile)(BSTR bstrFile);
	STDMETHOD(get_SidMappingFile)(BSTR* pbstrFile);
	STDMETHOD(Translate)(long lOption, VARIANT vntInclude, VARIANT vntExclude);

protected:

	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource);
	void DoComputers(CContainer& rSource);
	void DoComputers(CDomainAccounts& rComputers);

	void SetOptions(CVarSet& rVarSet);
	void SetAccountOptions(CVarSet& rVarSet);
	void SetSecurity(CVarSet& rVarSet);

protected:

	long m_lTranslationOption;
	bool m_bTranslateFilesAndFolders;
	bool m_bTranslateLocalGroups;
	bool m_bTranslatePrinters;
	bool m_bTranslateRegistry;
	bool m_bTranslateShares;
	bool m_bTranslateUserProfiles;
	bool m_bTranslateUserRights;
	_bstr_t m_bstrSidMappingFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\reportgeneration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "ReportGeneration.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetReports.h"


//---------------------------------------------------------------------------
// Report Class
//---------------------------------------------------------------------------


CReportGeneration::CReportGeneration() :
	m_lType(admtReportMigratedAccounts)
{
}


CReportGeneration::~CReportGeneration()
{
}


// IReport Implementation ----------------------------------------


// Type Property

STDMETHODIMP CReportGeneration::put_Type(long lType)
{
	HRESULT hr = S_OK;

	if (IsReportTypeValid(lType))
	{
		m_lType = lType;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, E_INVALIDARG, IDS_E_REPORT_TYPE_INVALID);
	}

	return hr;
}

STDMETHODIMP CReportGeneration::get_Type(long* plType)
{
	*plType = m_lType;

	return S_OK;
}


// Folder Property

STDMETHODIMP CReportGeneration::put_Folder(BSTR bstrFolder)
{
	HRESULT hr = S_OK;

	try
	{
		_bstr_t strFolder = bstrFolder;

		if (strFolder.length() > 0)
		{
			_TCHAR szPath[_MAX_PATH];
			LPTSTR pszFilePart;

			DWORD cchPath = GetFullPathName(strFolder, _MAX_PATH, szPath, &pszFilePart);

			if ((cchPath == 0) || (cchPath >= _MAX_PATH))
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(GetLastError()), 
					IDS_E_REPORT_FOLDER,
					(LPCTSTR)strFolder
				);
			}

			DWORD dwAttributes = GetFileAttributes(szPath);

			if (dwAttributes == DWORD(-1))
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(GetLastError()),
					IDS_E_REPORT_FOLDER,
					(LPCTSTR)strFolder
				);
			}

			if (!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(ERROR_DIRECTORY),
					IDS_E_REPORT_FOLDER,
					(LPCTSTR)strFolder
				);
			}

			m_bstrFolder = szPath;
		}
		else
		{
			m_bstrFolder = strFolder;
		}
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CReportGeneration::get_Folder(BSTR* pbstrFolder)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrFolder = m_bstrFolder.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, E_FAIL);
	}

	return hr;
}


// Generate Method

STDMETHODIMP CReportGeneration::Generate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
	HRESULT hr = S_OK;

	MutexWait();

	bool bLogOpen = _Module.OpenLog();

	try
	{
		_Module.Log(ErrI, IDS_STARTED_REPORT_GENERATION);

		InitSourceDomainAndContainer();
		InitTargetDomainAndContainer();

		DoOption(lOptions, vntInclude, vntExclude);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, ce, IDS_E_CANT_GENERATE_REPORT);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IReportGeneration, E_FAIL, IDS_E_CANT_GENERATE_REPORT);
	}

	if (bLogOpen)
	{
		_Module.CloseLog();
	}

	MutexRelease();

	return hr;
}


// Implementation -----------------------------------------------------------


// DoNone Method

void CReportGeneration::DoNone()
{
	CVarSet aVarSet;

	SetOptions(aVarSet);
	SetReports(aVarSet);

	aVarSet.Put(_T("PlugIn.%ld"), 0, _T("None"));

	PerformMigration(aVarSet);
}


// DoNames Method

void CReportGeneration::DoNames()
{
	CDomainAccounts aComputers;

	m_SourceDomain.QueryComputersAcrossDomains(GetSourceContainer(), true, m_setIncludeNames, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoDomain Method

void CReportGeneration::DoDomain()
{
	DoContainers(GetSourceContainer());
}


// DoContainers Method

void CReportGeneration::DoContainers(CContainer& rSource)
{
	DoComputers(rSource);
}


// DoComputers Method

void CReportGeneration::DoComputers(CContainer& rSource)
{
	CDomainAccounts aComputers;

	rSource.QueryComputers(true, m_nRecurseMaintain >= 1, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoComputers Method

void CReportGeneration::DoComputers(CDomainAccounts& rComputers)
{
	if (rComputers.size() > 0)
	{
		CVarSet aVarSet;

		SetOptions(aVarSet);
		SetReports(aVarSet);

		FillInVarSetForComputers(rComputers, false, false, false, 0, aVarSet);

		aVarSet.Put(_T("PlugIn.%ld"), 0, _T("None"));

		rComputers.clear();

		PerformMigration(aVarSet);

		aVarSet.Put(DCTVS_GatherInformation, false);

		SaveSettings(aVarSet);
	}
}


// SetOptions Method

void CReportGeneration::SetOptions(CVarSet& rVarSet)
{
	CVarSetOptions aOptions(rVarSet);

	aOptions.SetWizard(_T("reporting"));
	aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
	aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns());
	aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
}


// SetReports Method

void CReportGeneration::SetReports(CVarSet& rVarSet)
{
	CVarSetReports aReports(rVarSet);

	aReports.SetType(m_lType);
	aReports.SetReportsDirectory(m_bstrFolder);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\securitytranslation.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "SecurityTranslation.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetAccountOptions.h"
#include "VarSetSecurity.h"


//---------------------------------------------------------------------------
// Security Translation Class
//---------------------------------------------------------------------------


CSecurityTranslation::CSecurityTranslation() :
	m_lTranslationOption(admtTranslateReplace),
	m_bTranslateFilesAndFolders(false),
	m_bTranslateLocalGroups(false),
	m_bTranslatePrinters(false),
	m_bTranslateRegistry(false),
	m_bTranslateShares(false),
	m_bTranslateUserProfiles(false),
	m_bTranslateUserRights(false)
{
}


CSecurityTranslation::~CSecurityTranslation()
{
}


// ISecurityTranslation Implementation ----------------------------------------


// TranslationOption Property

STDMETHODIMP CSecurityTranslation::put_TranslationOption(long lOption)
{
	HRESULT hr = S_OK;

	if (IsTranslationOptionValid(lOption))
	{
		m_lTranslationOption = lOption;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, E_INVALIDARG, IDS_E_TRANSLATION_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CSecurityTranslation::get_TranslationOption(long* plOption)
{
	*plOption = m_lTranslationOption;

	return S_OK;
}


// TranslateFilesAndFolders Property

STDMETHODIMP CSecurityTranslation::put_TranslateFilesAndFolders(VARIANT_BOOL bTranslate)
{
	m_bTranslateFilesAndFolders = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateFilesAndFolders(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateFilesAndFolders ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateLocalGroups Property

STDMETHODIMP CSecurityTranslation::put_TranslateLocalGroups(VARIANT_BOOL bTranslate)
{
	m_bTranslateLocalGroups = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateLocalGroups(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateLocalGroups ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslatePrinters Property

STDMETHODIMP CSecurityTranslation::put_TranslatePrinters(VARIANT_BOOL bTranslate)
{
	m_bTranslatePrinters = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslatePrinters(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslatePrinters ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateRegistry Property

STDMETHODIMP CSecurityTranslation::put_TranslateRegistry(VARIANT_BOOL bTranslate)
{
	m_bTranslateRegistry = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateRegistry(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateRegistry ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateShares Property

STDMETHODIMP CSecurityTranslation::put_TranslateShares(VARIANT_BOOL bTranslate)
{
	m_bTranslateShares = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateShares(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateShares ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateUserProfiles Property

STDMETHODIMP CSecurityTranslation::put_TranslateUserProfiles(VARIANT_BOOL bTranslate)
{
	m_bTranslateUserProfiles = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateUserProfiles(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateUserProfiles ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateUserRights Property

STDMETHODIMP CSecurityTranslation::put_TranslateUserRights(VARIANT_BOOL bTranslate)
{
	m_bTranslateUserRights = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CSecurityTranslation::get_TranslateUserRights(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateUserRights ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// SidMappingFile Property

STDMETHODIMP CSecurityTranslation::put_SidMappingFile(BSTR bstrFile)
{
	HRESULT hr = S_OK;

	try
	{
		_bstr_t strFile = bstrFile;

		if (strFile.length() > 0)
		{
			_TCHAR szPath[_MAX_PATH];
			LPTSTR pszFilePart;

			DWORD cchPath = GetFullPathName(strFile, _MAX_PATH, szPath, &pszFilePart);

			if ((cchPath == 0) || (cchPath >= _MAX_PATH))
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(GetLastError()), 
					IDS_E_SID_MAPPING_FILE,
					(LPCTSTR)strFile
				);
			}

			HANDLE hFile = CreateFile(
				szPath,
				GENERIC_READ,
				FILE_SHARE_READ|FILE_SHARE_WRITE,
				NULL,
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL,
				NULL
			);

			if (hFile == INVALID_HANDLE_VALUE)
			{
				AdmtThrowError(
					GUID_NULL,
					GUID_NULL,
					HRESULT_FROM_WIN32(GetLastError()), 
					IDS_E_SID_MAPPING_FILE,
					(LPCTSTR)strFile
				);
			}

			CloseHandle(hFile);

			m_bstrSidMappingFile = szPath;
		}
		else
		{
			m_bstrSidMappingFile = strFile;
		}
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, E_FAIL);
	}

	return hr;
}

STDMETHODIMP CSecurityTranslation::get_SidMappingFile(BSTR* pbstrFile)
{
	HRESULT hr = S_OK;

	try
	{
		*pbstrFile = m_bstrSidMappingFile.copy();
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, ce);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, E_FAIL);
	}

	return hr;
}


// Translate Method

STDMETHODIMP CSecurityTranslation::Translate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
	HRESULT hr = S_OK;

	MutexWait();

	bool bLogOpen = _Module.OpenLog();

	try
	{
		_Module.Log(ErrI, IDS_STARTED_SECURITY_TRANSLATION);

		InitSourceDomainAndContainer();
		InitTargetDomainAndContainer();

		DoOption(lOptions, vntInclude, vntExclude);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, ce, IDS_E_CANT_TRANSLATE_SECURITY);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_ISecurityTranslation, E_FAIL, IDS_E_CANT_TRANSLATE_SECURITY);
	}

	if (bLogOpen)
	{
		_Module.CloseLog();
	}

	MutexRelease();

	return hr;
}


// Implementation -----------------------------------------------------------


// DoNames Method

void CSecurityTranslation::DoNames()
{
	CDomainAccounts aComputers;

	m_SourceDomain.QueryComputersAcrossDomains(GetSourceContainer(), true, m_setIncludeNames, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoDomain Method

void CSecurityTranslation::DoDomain()
{
	DoContainers(GetSourceContainer());
}


// DoContainers Method

void CSecurityTranslation::DoContainers(CContainer& rSource)
{
	DoComputers(rSource);
}


// DoComputers Method

void CSecurityTranslation::DoComputers(CContainer& rSource)
{
	CDomainAccounts aComputers;

	rSource.QueryComputers(true, m_nRecurseMaintain >= 1, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoComputers Method

void CSecurityTranslation::DoComputers(CDomainAccounts& rComputers)
{
	if (rComputers.size() > 0)
	{
		CVarSet aVarSet;

		SetOptions(aVarSet);
		SetAccountOptions(aVarSet);
		SetSecurity(aVarSet);

		FillInVarSetForComputers(rComputers, false, false, false, 0, aVarSet);

		rComputers.clear();

		if (m_bTranslateUserProfiles)
		{
			aVarSet.Put(_T("PlugIn.%ld"), 0, _T("{0EB9FBE9-397D-4D09-A65E-ABF1790CC470}"));
		}
		else
		{
			aVarSet.Put(_T("PlugIn.%ld"), 0, _T("None"));
		}

		PerformMigration(aVarSet);

		SaveSettings(aVarSet);
	}
}


// SetOptions Method

void CSecurityTranslation::SetOptions(CVarSet& rVarSet)
{
	CVarSetOptions aOptions(rVarSet);

	aOptions.SetTest(m_spInternal->TestMigration ? true : false);
	aOptions.SetUndo(false);
	aOptions.SetWizard(_T("security"));
	aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
	aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns());
	aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
}


// SetAccountOptions Method

void CSecurityTranslation::SetAccountOptions(CVarSet& rVarSet)
{
	CVarSetAccountOptions aOptions(rVarSet);

	aOptions.SetSecurityTranslationOptions();
	aOptions.SetSecurityMapFile(m_bstrSidMappingFile);
}


// SetSecurity Method

void CSecurityTranslation::SetSecurity(CVarSet& rVarSet)
{
	CVarSetSecurity aSecurity(rVarSet);

	aSecurity.SetTranslationOption(m_lTranslationOption);
	aSecurity.SetTranslateContainers(false);
	aSecurity.SetTranslateFiles(m_bTranslateFilesAndFolders);
	aSecurity.SetTranslateLocalGroups(m_bTranslateLocalGroups);
	aSecurity.SetTranslatePrinters(m_bTranslatePrinters);
	aSecurity.SetTranslateRegistry(m_bTranslateRegistry);
	aSecurity.SetTranslateShares(m_bTranslateShares);
	aSecurity.SetTranslateUserProfiles(m_bTranslateUserProfiles);
	aSecurity.SetTranslateUserRights(m_bTranslateUserRights);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ADMTScript.rc
//
#define IDS_PROJNAME                    100
#define IDR_MIGRATION                   101
#define IDS_STARTED_USER_MIGRATION      102
#define IDS_STARTED_GROUP_MIGRATION     103
#define IDS_STARTED_COMPUTER_MIGRATION  104
#define IDS_STARTED_SECURITY_TRANSLATION 105
#define IDS_STARTED_SERVICE_ACCOUNT_ENUMERATION 106
#define IDS_E_CREATE_USER_MIGRATION     107
#define IDS_E_CREATE_GROUP_MIGRATION    108
#define IDS_E_CREATE_COMPUTER_MIGRATION 109
#define IDS_E_CREATE_SECURITY_TRANSLATION 110
#define IDS_E_CREATE_SERVICE_ACCOUNT_ENUMERATION 111
#define IDS_E_CANT_MIGRATE_USERS        112
#define IDS_E_CANT_MIGRATE_GROUPS       113
#define IDS_E_CANT_MIGRATE_COMPUTERS    114
#define IDS_E_CANT_TRANSLATE_SECURITY   115
#define IDS_E_CANT_ENUMERATE_SERVICE_ACCOUNTS 116
#define IDS_E_CONFLICT_OPTION_INVALID   117
#define IDS_E_CONFLICT_FLAGS_NOT_ALLOWED 118
#define IDS_E_DISABLE_OPTION_INVALID    119
#define IDS_E_PASSWORD_OPTION_INVALID   120
#define IDS_E_RENAME_OPTION_INVALID     121
#define IDS_E_RESTART_DELAY_INVALID     122
#define IDS_E_SOURCE_EXPIRATION_INVALID 123
#define IDS_E_TRANSLATION_OPTION_INVALID 124
#define IDS_E_DOMAIN_SPECIFIED          125
#define IDS_E_NOT_SOURCE_DOMAIN         126
#define IDS_E_INVALID_FILTER_STRING     127
#define IDS_E_CANT_GET_DOMAIN_INFORMATION 128
#define IDS_E_CANT_GET_DOMAIN_CONTROLLER 129
#define IDS_E_CANT_GET_GLOBAL_CATALOG_SERVER 130
#define IDS_E_CANT_GET_DISTINGUISHED_NAME 131
#define IDS_E_CANT_CONNECT_TO_DIRECTORY_SERVICE 132
#define IDS_E_CANT_CREATE_CONTAINER_NT4 133
#define IDS_E_CANT_ADD_GROUP            134
#define IDS_E_CANT_ADD_USER             135
#define IDS_E_CANT_CONNECT_TO_DOMAIN    136
#define IDS_E_CANT_ADD_COMPUTER         137
#define IDS_E_CANT_EXECUTE_SEARCH       138
#define IDS_E_NOT_INTER_FOREST          139
#define IDS_E_NOT_INTRA_FOREST          140
#define IDS_E_INVALID_OPTION            141
#define IDS_E_INVALID_EXCLUDE_DATA_TYPE 142
#define IDS_E_INVALID_DATA_OPTION_DATA_TYPE 143
#define IDS_E_INVALID_FILE_OPTION_DATA_TYPE 144
#define IDS_E_DATA_OPTION_FLAGS_NOT_ALLOWED 145
#define IDS_E_PASSWORD_DC_INVALID       146
#define IDS_E_PASSWORD_DC_NOT_SPECIFIED 147
#define IDS_E_USER_NOT_FOUND            148
#define IDS_E_GROUP_NOT_FOUND           149
#define IDS_E_COMPUTER_NOT_FOUND        150
#define IDS_E_CANT_DO_BUILTIN           151
#define IDS_E_DOMAIN_NOT_VALID          152
#define IDS_STARTED_REPORT_GENERATION   153
#define IDS_E_REPORT_TYPE_INVALID       154
#define IDS_E_CANT_GENERATE_REPORT      155
#define IDS_E_CREATE_REPORT_GENERATION  156
#define IDS_E_PASSWORD_DC_NOT_NT        157
#define IDS_E_PASSWORD_DC_NOT_DC        158
#define IDS_E_PASSWORD_DC_DLL_NOT_RUNNING 159
#define IDS_E_PASSWORD_MIGRATION_DISABLED 160
#define IDS_E_PASSWORD_GENERATE_SESSION_KEY_FAILED 161
#define IDS_E_PASSWORD_CANT_GENERATE_PASSWORD 162
#define IDS_E_PASSWORD_ENCRYPTION_KEY_INVALID 163
#define IDS_E_INTRA_FOREST_REPLACE      164
#define IDS_E_PASSWORD_ENCRYPTION_PACK_INVALID 165
#define IDS_E_ADMT_PROCESS_RUNNING      166
#define IDS_E_PASSWORD_DC_NOT_FOUND     167
#define IDS_E_SID_MAPPING_FILE          168
#define IDS_E_NO_RENAME_PREFIX          169
#define IDS_E_RENAME_NO_SUFFIX          170
#define IDS_E_NO_CONFLICT_PREFIX        171
#define IDS_E_NO_CONFLICT_SUFFIX        172
#define IDS_E_PREFIX_SUFFIX_TOO_LONG    173
#define IDS_E_NOT_ADMINISTRATOR         174
#define IDS_E_INVALID_RENAME_PREFIX_SUFFIX 175
#define IDS_E_INVALID_CONFLICT_PREFIX_SUFFIX 176
#define IDS_E_UNABLE_TO_UPDATE_DATABASE 177
#define IDS_E_CANT_MIGRATE_DOMAIN_CONTROLLERS 178
#define IDS_E_CANT_FIND_COMPUTER        179
#define IDS_E_CANT_ENUMERATE_COMPUTERS  180
#define IDS_E_DOMAIN_NAME_NOT_SPECIFIED 181
#define IDS_E_CAN_ADD_SID_HISTORY       182
#define IDS_E_SID_HISTORY_CONFIGURATION 183
#define IDS_E_NO_AUDITING_SOURCE        184
#define IDS_E_NO_AUDITING_TARGET        185
#define IDS_E_NO_SID_HISTORY_LOCAL_GROUP 186
#define IDS_E_NO_SID_HISTORY_REGISTRY_ENTRY 187
#define IDS_E_REPORT_FOLDER             188
#define IDS_E_TARGET_CONTAINER_PATH_TOO_LONG 189
#define IDS_E_PASSWORD_FILE             190
#define IDS_E_INCLUDE_NAMES_FILE        191
#define IDS_E_REMOVING_SERVICE_ACCOUNTS 192
#define IDS_E_FIX_HIERARCHY_MOVE_OBJECT 193
#define IDS_E_FIX_HIERARCHY_BIND_TO_CONTAINER 194
#define IDS_E_CANNOT_GET_CONTAINER      195
#define IDS_E_CANNOT_MIGRATE_DOMAIN_CONTROLLERS 196
#define IDS_E_CANNOT_PROCESS_ACCOUNTS_IN_DOMAIN 197
#define IDS_E_CANNOT_RESOLVE_NAME       198
#define IDS_E_ACCOUNT_EXCLUDED          199
#define IDS_E_OBJECT_NOT_OF_CLASS       200
#define IDS_E_TARGET_DOMAIN_NOT_NATIVE_MODE 201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\namecracker.h ===
#pragma once

#include <map>

#ifndef tstring
#include <string>
typedef std::basic_string<_TCHAR> tstring;
#endif
#ifndef StringVector
#include <vector>
typedef std::vector<tstring> StringVector;
#endif
#ifndef CStringSet
#include <set>
typedef std::set<tstring> CStringSet;
#endif
#ifndef IADsContainerPtr
#include <ComDef.h>
#include <ActiveDS.h>
_COM_SMARTPTR_TYPEDEF(IADsContainer, IID_IADsContainer);
#endif
#ifndef StringSet
#include <set>
typedef std::set<_bstr_t> StringSet;
#endif


//---------------------------------------------------------------------------
// Name Cracker Class
//---------------------------------------------------------------------------

class CNameCracker
{
public:

	CNameCracker();
	~CNameCracker();

	void SetDomainNames(LPCTSTR pszDnsName, LPCTSTR pszFlatName, LPCTSTR pszDomainController)
	{
		m_strDnsName = pszDnsName;
		m_strFlatName = pszFlatName;
		m_strDomainController = pszDomainController;
	}

	void SetDefaultContainer(IADsContainerPtr& spContainer)
	{
		m_spDefaultContainer = spContainer;
	}

	void CrackNames(const StringVector& vecNames);

	const CStringSet& GetResolvedNames() const
	{
		return m_setResolvedNames;
	}

	const StringVector& GetUnResolvedNames() const
	{
		return m_vecUnResolvedNames;
	}

protected:

	void Separate(
		const StringVector& vecNames,
		StringVector& vecCanonicalNames,
		StringVector& vecSamAccountNames,
		StringVector& vecRelativeDistinguishedNames
	);
	void CrackCanonicalNames(const StringVector& vecCanonicalNames, StringVector& vecUnResolvedNames);
	void CrackSamAccountNames(const StringVector& vecSamAccountNames, StringVector& vecUnResolvedNames);
	void CrackRelativeDistinguishedNames(const StringVector& vecRelativeDistinguishedNames, StringVector& vecUnResolvedNames);

	typedef enum
	{
		CANONICAL_NAME,
		NT4_ACCOUNT_NAME,
	}
	NAME_FORMAT;

	struct SName
	{
		SName(LPCTSTR pszPartial, LPCTSTR pszComplete) :
			strPartial(pszPartial),
			strComplete(pszComplete)
		{
		}

		SName(const SName& r) :
			strPartial(r.strPartial),
			strComplete(r.strComplete),
			strResolved(r.strResolved)
		{
		}

		SName& operator =(const SName& r)
		{
			strPartial = r.strPartial;
			strComplete = r.strComplete;
			strResolved = r.strResolved;
			return *this;
		}

		tstring strPartial;
		tstring strComplete;
		tstring strResolved;
	};

	typedef std::vector<SName> CNameVector;

	void CrackNames(NAME_FORMAT eFormat, CNameVector& vecNames);

	static tstring GetEscapedFilterName(LPCTSTR pszName);

protected:

	tstring m_strDnsName;
	tstring m_strFlatName;
	tstring m_strDomainController;
	IADsContainerPtr m_spDefaultContainer;

	CStringSet m_setResolvedNames;
	StringVector m_vecUnResolvedNames;
};


//---------------------------------------------------------------------------
// Ignore Case String Less
//---------------------------------------------------------------------------

struct IgnoreCaseStringLess :
	public std::binary_function<_bstr_t, _bstr_t, bool>
{
	bool operator()(const _bstr_t& x, const _bstr_t& y) const;
};


//---------------------------------------------------------------------------
// Domain To Path Map Class
//---------------------------------------------------------------------------

class CDomainToPathMap :
	public std::map<_bstr_t, StringSet, IgnoreCaseStringLess>
{
public:

	CDomainToPathMap()
	{
	}

	void Initialize(LPCTSTR pszDefaultDomainDns, LPCTSTR pszDefaultDomainFlat, const StringSet& setNames);

protected:

	static bool GetValidDomainName(_bstr_t& strDomainName);
};


//---------------------------------------------------------------------------
// Name To Path Map Class
//---------------------------------------------------------------------------

class CNameToPathMap :
	public std::map<_bstr_t, StringSet, IgnoreCaseStringLess>
{
public:

	CNameToPathMap();
	CNameToPathMap(StringSet& setNames);

	void Initialize(StringSet& setNames);

	void Add(_bstr_t& strName, _bstr_t& strPath);
};


//---------------------------------------------------------------------------
// Compare Strings Class
//---------------------------------------------------------------------------

class CCompareStrings
{
public:

	CCompareStrings();
	CCompareStrings(StringSet& setNames);

	void Initialize(StringSet& setNames);
	bool IsMatch(LPCTSTR pszName);

protected:

	class CCompareString
	{
	public:

		CCompareString(LPCTSTR pszCompare = NULL);
		CCompareString(const CCompareString& r);

		void Initialize(LPCTSTR pszCompare);
		bool IsMatch(LPCTSTR psz);

	protected:

		int m_nType;
		_bstr_t m_strCompare;
	};

	typedef std::vector<CCompareString> CompareStringVector;

	CompareStringVector m_vecCompareStrings;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\serviceaccountenumeration.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// CServiceAccountEnumeration
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CServiceAccountEnumeration :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IServiceAccountEnumeration, &IID_IServiceAccountEnumeration, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CServiceAccountEnumeration();
	~CServiceAccountEnumeration();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CServiceAccountEnumeration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IServiceAccountEnumeration)
	END_COM_MAP()

public:

	// IServiceAccountEnumeration

	STDMETHOD(Enumerate)(long lOption, VARIANT vntInclude, VARIANT vntExclude);

protected:

	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource);
	void DoComputers(CContainer& rSource);
	void DoComputers(CDomainAccounts& rComputers);

	void SetOptions(CVarSet& rVarSet);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\usermigration.h ===
#pragma once

#include "MigrationBase.h"


//---------------------------------------------------------------------------
// CUserMigration
//---------------------------------------------------------------------------


class ATL_NO_VTABLE CUserMigration :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IUserMigration, &IID_IUserMigration, &LIBID_ADMT>,
	public CMigrationBase
{
public:

	CUserMigration();
	~CUserMigration();

	DECLARE_NO_REGISTRY()

	BEGIN_COM_MAP(CUserMigration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IUserMigration)
	END_COM_MAP()

public:

	// IUserMigration

	STDMETHOD(put_DisableOption)(long lOption);
	STDMETHOD(get_DisableOption)(long* plOption);
	STDMETHOD(put_SourceExpiration)(long lExpiration);
	STDMETHOD(get_SourceExpiration)(long* plExpiration);
	STDMETHOD(put_MigrateSIDs)(VARIANT_BOOL bMigrate);
	STDMETHOD(get_MigrateSIDs)(VARIANT_BOOL* pbMigrate);
	STDMETHOD(put_TranslateRoamingProfile)(VARIANT_BOOL bTranslate);
	STDMETHOD(get_TranslateRoamingProfile)(VARIANT_BOOL* pbTranslate);
	STDMETHOD(put_UpdateUserRights)(VARIANT_BOOL bUpdate);
	STDMETHOD(get_UpdateUserRights)(VARIANT_BOOL* pbUpdate);
	STDMETHOD(put_MigrateGroups)(VARIANT_BOOL bMigrate);
	STDMETHOD(get_MigrateGroups)(VARIANT_BOOL* pbMigrate);
	STDMETHOD(put_UpdatePreviouslyMigratedObjects)(VARIANT_BOOL bUpdate);
	STDMETHOD(get_UpdatePreviouslyMigratedObjects)(VARIANT_BOOL* pbUpdate);
	STDMETHOD(put_FixGroupMembership)(VARIANT_BOOL bFix);
	STDMETHOD(get_FixGroupMembership)(VARIANT_BOOL* pbFix);
	STDMETHOD(put_MigrateServiceAccounts)(VARIANT_BOOL bMigrate);
	STDMETHOD(get_MigrateServiceAccounts)(VARIANT_BOOL* pbMigrate);
	STDMETHOD(Migrate)(long lOptions, VARIANT vntInclude, VARIANT vntExclude);

protected:

	void ValidateMigrationParameters();

	virtual void DoNames();
	virtual void DoDomain();

	void DoContainers(CContainer& rSource, CContainer& rTarget);
	void DoUsers(CContainer& rSource, CContainer& rTarget);
	void DoUsers(CDomainAccounts& rUsers, CContainer& rTarget);

	void RemoveServiceAccounts(CDomainAccounts& rUsers);

	void SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet);
	void SetAccountOptions(CVarSet& rVarSet);

protected:

	long m_lDisableOption;
	long m_lSourceExpiration;
	bool m_bMigrateSids;
	bool m_bTranslateRoamingProfile;
	bool m_bUpdateUserRights;
	bool m_bMigrateGroups;
	bool m_bUpdatePreviouslyMigratedObjects;
	bool m_bFixGroupMembership;
	bool m_bMigrateServiceAccounts;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\serviceaccountenumeration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "ServiceAccountEnumeration.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetAccountOptions.h"
#include "VarSetSecurity.h"


//---------------------------------------------------------------------------
// Service Account Enumeration Class
//---------------------------------------------------------------------------


CServiceAccountEnumeration::CServiceAccountEnumeration()
{
}


CServiceAccountEnumeration::~CServiceAccountEnumeration()
{
}


// IServiceAccountEnumeration Implementation --------------------------------


// Enumerate Method

STDMETHODIMP CServiceAccountEnumeration::Enumerate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
	HRESULT hr = S_OK;

	MutexWait();

	bool bLogOpen = _Module.OpenLog();

	try
	{
		_Module.Log(ErrI, IDS_STARTED_SERVICE_ACCOUNT_ENUMERATION);

		InitSourceDomainAndContainer();

		DoOption(lOptions, vntInclude, vntExclude);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IServiceAccountEnumeration, ce, IDS_E_CANT_ENUMERATE_SERVICE_ACCOUNTS);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IServiceAccountEnumeration, E_FAIL, IDS_E_CANT_ENUMERATE_SERVICE_ACCOUNTS);
	}

	if (bLogOpen)
	{
		_Module.CloseLog();
	}

	MutexRelease();

	return hr;
}


// Implementation -----------------------------------------------------------


// DoNames Method

void CServiceAccountEnumeration::DoNames()
{
	CDomainAccounts aComputers;

	m_SourceDomain.QueryComputersAcrossDomains(GetSourceContainer(), true, m_setIncludeNames, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoDomain Method

void CServiceAccountEnumeration::DoDomain()
{
	DoContainers(GetSourceContainer());
}


// DoContainers Method

void CServiceAccountEnumeration::DoContainers(CContainer& rSource)
{
	DoComputers(rSource);
}


// DoComputers Method

void CServiceAccountEnumeration::DoComputers(CContainer& rSource)
{
	CDomainAccounts aComputers;

	rSource.QueryComputers(true, m_nRecurseMaintain >= 1, m_setExcludeNames, aComputers);

	DoComputers(aComputers);
}


// DoComputers Method

void CServiceAccountEnumeration::DoComputers(CDomainAccounts& rComputers)
{
	if (rComputers.size() > 0)
	{
		CVarSet aVarSet;

		SetOptions(aVarSet);

		FillInVarSetForComputers(rComputers, false, false, false, 0, aVarSet);

		rComputers.clear();

		aVarSet.Put(_T("PlugIn.%ld"), 0, _T("{9CC87460-461D-11D3-99F3-0010A4F77383}"));

		PerformMigration(aVarSet);

		SaveSettings(aVarSet);
	}
}


// SetOptions Method

void CServiceAccountEnumeration::SetOptions(CVarSet& rVarSet)
{
	CVarSetOptions aOptions(rVarSet);

	aOptions.SetTest(m_spInternal->TestMigration ? true : false);
	aOptions.SetUndo(false);
	aOptions.SetWizard(_T("service"));
	aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
	aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns());
	aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\varsetaccountoptions.h ===
#pragma once

#include "Error.h"
#include "Resource.h"
#include "VarSetBase.h"


//---------------------------------------------------------------------------
// VarSet AccountOptions Class
//---------------------------------------------------------------------------


class CVarSetAccountOptions : public CVarSet
{
public:

	CVarSetAccountOptions(const CVarSet& rVarSet) :
		CVarSet(rVarSet)
	{
		// must specify that security translation uses the migrated objects
		// table for all cases except when using a sid mapping file

		Put(DCTVS_AccountOptions_SecurityInputMOT, true);
	}

	//

	void SetPasswordOption(long lOption, LPCTSTR pszDc = NULL)
	{
		Put(DCTVS_AccountOptions_GenerateStrongPasswords, (lOption != admtPasswordFromName));
		Put(DCTVS_AccountOptions_CopyPasswords, (lOption == admtCopyPassword));

		if (lOption == admtCopyPassword)
		{
			if (pszDc)
			{
				Put(DCTVS_AccountOptions_PasswordDC, pszDc);
			}
			else
			{
				AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_PASSWORD_DC_NOT_SPECIFIED);
			}
		}
	}

	void SetPasswordFile(LPCTSTR pszFile)
	{
		if (pszFile && (_tcslen(pszFile) > 0))
		{
			Put(DCTVS_AccountOptions_PasswordFile, pszFile);
		}
		else
		{
			Put(DCTVS_AccountOptions_PasswordFile, GetLogFolder() + _T("Passwords.txt"));
		}
	}

	void SetConflictOptions(long lOptions, LPCTSTR pszPrefixOrSuffix);

	void SetDisableOption(long lOption)
	{
		long lTarget = lOption & (admtDisableTarget|admtTargetSameAsSource);
		Put(DCTVS_AccountOptions_DisableCopiedAccounts, lTarget == admtDisableTarget);
		Put(DCTVS_AccountOptions_TgtStateSameAsSrc, lTarget == admtTargetSameAsSource);
		Put(DCTVS_AccountOptions_DisableSourceAccounts, (lOption & admtDisableSource) != 0);
	}

	void SetSourceExpiration(long lExpiration);

	// SetUserMigrationOptions is for user migration only

	void SetUserMigrationOptions(bool bMigrateGroups, bool bUpdateMigrated)
	{
		Put(DCTVS_AccountOptions_CopyUsers, true);
		Put(DCTVS_AccountOptions_CopyLocalGroups, bMigrateGroups);
		Put(DCTVS_AccountOptions_CopyMemberOf, bMigrateGroups);
		Put(DCTVS_AccountOptions_CopyComputers, false);
		Put(DCTVS_AccountOptions_CopyContainerContents, false);
		Put(DCTVS_AccountOptions_IncludeMigratedAccts, bMigrateGroups ? bUpdateMigrated : false);
	}

	// SetGroupMigrationOptions is for group migration only

	void SetGroupMigrationOptions(bool bMigrateMembers, bool bUpdateMigrated)
	{
		Put(DCTVS_AccountOptions_CopyUsers, bMigrateMembers);
		Put(DCTVS_AccountOptions_CopyLocalGroups, true);
		Put(DCTVS_AccountOptions_CopyComputers, false);
		Put(DCTVS_AccountOptions_CopyContainerContents, bMigrateMembers);
		Put(DCTVS_AccountOptions_CopyMemberOf, false);
		Put(DCTVS_AccountOptions_IncludeMigratedAccts, bMigrateMembers ? bUpdateMigrated : false);
	}

	// SetComputerMigrationOptions is for computer migration only

	void SetComputerMigrationOptions()
	{
		Put(DCTVS_AccountOptions_CopyUsers, false);
		Put(DCTVS_AccountOptions_CopyLocalGroups, false);
		Put(DCTVS_AccountOptions_CopyComputers, true);
		Put(DCTVS_AccountOptions_CopyContainerContents, false);
		Put(DCTVS_AccountOptions_CopyMemberOf, false);
	}

	// SetSecurityTranslationOptions is for security translation only

	void SetSecurityTranslationOptions()
	{
		Put(DCTVS_AccountOptions_CopyUsers, false);
		Put(DCTVS_AccountOptions_CopyLocalGroups, false);
		Put(DCTVS_AccountOptions_CopyComputers, false);
		Put(DCTVS_AccountOptions_CopyContainerContents, false);
	//	Put(DCTVS_AccountOptions_CopyMemberOf, false);
	}

	void SetMigrateSids(bool bMigrate)
	{
		Put(DCTVS_AccountOptions_AddSidHistory, bMigrate);
	}

	void SetSidHistoryCredentials(LPCTSTR pszDomain, LPCTSTR pszUserName, LPCTSTR pszPassword)
	{
		Put(DCTVS_AccountOptions_SidHistoryCredentials_Domain, pszDomain);
		Put(DCTVS_AccountOptions_SidHistoryCredentials_UserName, pszUserName);
		Put(DCTVS_AccountOptions_SidHistoryCredentials_Password, pszPassword);
	}

	void SetFixGroupMembership(bool bFix)
	{
		Put(DCTVS_AccountOptions_FixMembership, bFix);
	}

	void SetUpdateUserRights(bool bUpdate)
	{
		Put(DCTVS_AccountOptions_UpdateUserRights, bUpdate);
	}

	void SetTranslateRoamingProfile(bool bTranslate)
	{
		Put(DCTVS_AccountOptions_TranslateRoamingProfiles, bTranslate);
	}

	void SetExcludedUserProps(LPCTSTR pszProperties)
	{
		if (pszProperties && (_tcslen(pszProperties) > 0))
		{
			Put(DCTVS_AccountOptions_ExcludeProps, true);
			Put(DCTVS_AccountOptions_ExcludedUserProps, pszProperties);
		}
	}

	void SetExcludedGroupProps(LPCTSTR pszProperties)
	{
		if (pszProperties && (_tcslen(pszProperties) > 0))
		{
			Put(DCTVS_AccountOptions_ExcludeProps, true);
			Put(DCTVS_AccountOptions_ExcludedGroupProps, pszProperties);
		}
	}

	void SetExcludedComputerProps(LPCTSTR pszProperties)
	{
		if (pszProperties && (_tcslen(pszProperties) > 0))
		{
			Put(DCTVS_AccountOptions_ExcludeProps, true);
			Put(DCTVS_AccountOptions_ExcludedComputerProps, pszProperties);
		}
	}

	void SetSecurityMapFile(LPCTSTR pszFile)
	{
		if (pszFile && (_tcslen(pszFile) > 0))
		{
			Put(DCTVS_AccountOptions_SecurityInputMOT, false);
			Put(DCTVS_AccountOptions_SecurityMapFile, pszFile);
		}
	}

protected:

	void SetReplaceExistingAccounts(bool bReplace)
	{
		Put(DCTVS_AccountOptions_ReplaceExistingAccounts, bReplace);
	}

	void SetRemoveExistingUserRights(bool bRemove)
	{
		Put(DCTVS_AccountOptions_RemoveExistingUserRights, bRemove);
	}

	void SetReplaceExistingGroupMembers(bool bReplace)
	{
		Put(DCTVS_AccountOptions_ReplaceExistingGroupMembers, bReplace);
	}

	void SetMoveReplacedAccounts(bool bMove)
	{
		Put(DCTVS_AccountOptions_MoveReplacedAccounts, bMove);
	}

	void SetPrefix(LPCTSTR pszPrefix)
	{
		Put(DCTVS_AccountOptions_Prefix, pszPrefix);
	}

	void SetSuffix(LPCTSTR pszSuffix)
	{
		Put(DCTVS_AccountOptions_Suffix, pszSuffix);
	}
};


//---------------------------------------------------------------------------
// Validation Functions
//---------------------------------------------------------------------------


inline bool IsDisableOptionValid(long lOption)
{
	bool bIs = false;

	// if only valid option bits are set...

	if (!(lOption & ~(admtEnableTarget|admtDisableSource|admtDisableTarget|admtTargetSameAsSource)))
	{
		// and not both disable target and target same as source options...

		if (!((lOption & admtDisableTarget) && (lOption & admtTargetSameAsSource)))
		{
			// then valid
			bIs = true;
		}
	}

	return bIs;
}


inline bool IsSourceExpirationValid(long lExpiration)
{
	return ((lExpiration == -1) || ((lExpiration >= 0) && (lExpiration <= 1095)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#define COUNT_OF(a) (sizeof(a) / sizeof(a[0]))


//---------------------------------------------------------------------------
// CAdmtModule Class
//---------------------------------------------------------------------------


CAdmtModule::CAdmtModule()
{
}


CAdmtModule::~CAdmtModule()
{
}


// OpenLog Method

bool CAdmtModule::OpenLog()
{
//	CloseLog(); // error class doesn't reset file pointer to NULL when closing file

	return m_Error.LogOpen(GetLogFolder() + _T("Migration.log"), 0, 0, true) ? true : false;
}


// CloseLog Method

void CAdmtModule::CloseLog()
{
	m_Error.LogClose();
}


// Log Method

void __cdecl CAdmtModule::Log(UINT uLevel, UINT uId, ...)
{
	_TCHAR szFormat[512];
	_TCHAR szMessage[1024];

	if (LoadString(GetResourceInstance(), uId, szFormat, 512))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szMessage, COUNT_OF(szMessage), szFormat, args);
		va_end(args);

		szMessage[1023] = _T('\0');
	}
	else
	{
		szMessage[0] = _T('\0');
	}

	m_Error.MsgProcess(uLevel | uId, szMessage);
}


// Log Method

void __cdecl CAdmtModule::Log(LPCTSTR pszFormat, ...)
{
	_TCHAR szMessage[1024];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szMessage, COUNT_OF(szMessage), pszFormat, args);
		va_end(args);

		szMessage[1023] = _T('\0');
	}
	else
	{
		szMessage[0] = _T('\0');
	}

	m_Error.MsgProcess(0, szMessage);
}

StringLoader gString;

//#import <ActiveDs.tlb> no_namespace implementation_only exclude("_LARGE_INTEGER","_SYSTEMTIME")

#import <DBMgr.tlb> no_namespace implementation_only
#import <MigDrvr.tlb> no_namespace implementation_only
#import <VarSet.tlb> no_namespace rename("property", "aproperty") implementation_only
#import <WorkObj.tlb> no_namespace implementation_only
#import <MsPwdMig.tlb> no_namespace implementation_only

#import "Internal.tlb" no_namespace implementation_only


// GetLogFolder Method

_bstr_t GetLogFolder()
{
	_bstr_t strFolder;

	HKEY hKey;

	DWORD dwError = RegOpenKey(HKEY_LOCAL_MACHINE, _T("Software\\Mission Critical Software\\DomainAdmin"), &hKey);

	if (dwError == ERROR_SUCCESS)
	{
		_TCHAR szPath[_MAX_PATH];
		DWORD cbPath = sizeof(szPath);

		dwError = RegQueryValueEx(hKey, _T("Directory"), NULL, NULL, (LPBYTE)szPath, &cbPath);

		if (dwError == ERROR_SUCCESS)
		{
			_TCHAR szDrive[_MAX_DRIVE];
			_TCHAR szDir[_MAX_DIR];

			_tsplitpath(szPath, szDrive, szDir, NULL, NULL);
			_tcscat(szDir, _T("Logs"));
			_tmakepath(szPath, szDrive, szDir, NULL, NULL);

			strFolder = szPath;
		}

		RegCloseKey(hKey);
	}

	return strFolder;
}


// GetReportsFolder Method

_bstr_t GetReportsFolder()
{
	_bstr_t strFolder;

	HKEY hKey;

	DWORD dwError = RegOpenKey(HKEY_LOCAL_MACHINE, _T("Software\\Mission Critical Software\\DomainAdmin"), &hKey);

	if (dwError == ERROR_SUCCESS)
	{
		_TCHAR szPath[_MAX_PATH];
		DWORD cbPath = sizeof(szPath);

		dwError = RegQueryValueEx(hKey, _T("Directory"), NULL, NULL, (LPBYTE)szPath, &cbPath);

		if (dwError == ERROR_SUCCESS)
		{
			_TCHAR szDrive[_MAX_DRIVE];
			_TCHAR szDir[_MAX_DIR];

			_tsplitpath(szPath, szDrive, szDir, NULL, NULL);
			_tcscat(szDir, _T("Reports"));
			_tmakepath(szPath, szDrive, szDir, NULL, NULL);

			CreateDirectory(szPath, NULL);

			strFolder = szPath;
		}

		RegCloseKey(hKey);
	}

	return strFolder;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\stdafx.h ===
#pragma once

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>

#include <ErrDct.hpp>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

//---------------------------------------------------------------------------
// CAdmtModule Class
//---------------------------------------------------------------------------

class CAdmtModule : public CComModule
{
public:

	CAdmtModule();
	~CAdmtModule();

	bool OpenLog();
	void CloseLog();

	void __cdecl Log(UINT uLevel, UINT uId, ...);
	void __cdecl Log(LPCTSTR pszFormat, ...);

protected:

	TErrorDct m_Error;
};

extern CAdmtModule _Module;

#include <atlcom.h>

#include <ComDef.h>
#include <ResStr.h>

//#pragma warning(disable: 4192) // automatically excluding

//#import <ActiveDs.tlb> no_namespace no_implementation exclude("_LARGE_INTEGER","_SYSTEMTIME")

#import <DBMgr.tlb> no_namespace no_implementation
#import <MigDrvr.tlb> no_namespace no_implementation
#import <VarSet.tlb> no_namespace rename("property", "aproperty") no_implementation
#import <WorkObj.tlb> no_namespace no_implementation
#import <MsPwdMig.tlb> no_namespace no_implementation

#import "Internal.tlb" no_namespace no_implementation

_bstr_t GetLogFolder();
_bstr_t GetReportsFolder();

//{{AFX_INSERT_LOCATION}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\varsetaccountoptions.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "VarSetAccountOptions.h"
#include <Validation.h>


//---------------------------------------------------------------------------
// VarSet Account Options Class
//---------------------------------------------------------------------------


// SetConflictOptions Method

void CVarSetAccountOptions::SetConflictOptions(long lOptions, LPCTSTR pszPrefixOrSuffix)
{
	long lOption = lOptions & 0x0F;
	long lFlags = lOptions & 0xF0;

	_bstr_t c_bstrEmpty;

	switch (lOption)
	{
		case admtRenameConflictingWithSuffix:
		{
			if (pszPrefixOrSuffix && (_tcslen(pszPrefixOrSuffix) > 0))
			{
				if (IsValidPrefixOrSuffix(pszPrefixOrSuffix))
				{
					SetReplaceExistingAccounts(false);
					SetPrefix(c_bstrEmpty);
					SetSuffix(pszPrefixOrSuffix);
				}
				else
				{
					AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_CONFLICT_PREFIX_SUFFIX);
				}
			}
			else
			{
				AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_NO_CONFLICT_PREFIX);
			}
			break;
		}
		case admtRenameConflictingWithPrefix:
		{
			if (pszPrefixOrSuffix && (_tcslen(pszPrefixOrSuffix) > 0))
			{
				if (IsValidPrefixOrSuffix(pszPrefixOrSuffix))
				{
					SetReplaceExistingAccounts(false);
					SetPrefix(pszPrefixOrSuffix);
					SetSuffix(c_bstrEmpty);
				}
				else
				{
					AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_CONFLICT_PREFIX_SUFFIX);
				}
			}
			else
			{
				AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_NO_CONFLICT_SUFFIX);
			}
			break;
		}
		case admtReplaceConflicting:
		{
			SetReplaceExistingAccounts(true);
			SetRemoveExistingUserRights((lFlags & admtRemoveExistingUserRights) ? true : false);
			SetReplaceExistingGroupMembers((lFlags & admtRemoveExistingMembers) ? true : false);
			SetMoveReplacedAccounts((lFlags & admtMoveReplacedAccounts) ? true : false);
			SetPrefix(c_bstrEmpty);
			SetSuffix(c_bstrEmpty);
			break;
		}
		default: // admtIgnoreConflicting
		{
			SetReplaceExistingAccounts(false);
			SetPrefix(c_bstrEmpty);
			SetSuffix(c_bstrEmpty);
			break;
		}
	}
}


// SetSourceExpiration Method

void CVarSetAccountOptions::SetSourceExpiration(long lExpiration)
{
	_variant_t vntExpiration;

	if (lExpiration >= 0)
	{
		vntExpiration = lExpiration;
	}

	Put(DCTVS_AccountOptions_ExpireSourceAccounts, vntExpiration);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\usermigration.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "UserMigration.h"

#include "Error.h"
#include "VarSetOptions.h"
#include "VarSetAccountOptions.h"
#include "VarSetSecurity.h"


//---------------------------------------------------------------------------
// CUserMigration
//---------------------------------------------------------------------------


CUserMigration::CUserMigration() :
	m_lDisableOption(admtEnableTarget),
	m_lSourceExpiration(-1),
	m_bMigrateSids(false),
	m_bTranslateRoamingProfile(false),
	m_bUpdateUserRights(false),
	m_bMigrateGroups(false),
	m_bUpdatePreviouslyMigratedObjects(false),
	m_bFixGroupMembership(true),
	m_bMigrateServiceAccounts(true)
{
}


CUserMigration::~CUserMigration()
{
}


// IUserMigration Implementation --------------------------------------------


// DisableOption Property

STDMETHODIMP CUserMigration::put_DisableOption(long lOption)
{
	HRESULT hr = S_OK;

	if (IsDisableOptionValid(lOption))
	{
		m_lDisableOption = lOption;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IUserMigration, E_INVALIDARG, IDS_E_DISABLE_OPTION_INVALID);
	}

	return hr;
}

STDMETHODIMP CUserMigration::get_DisableOption(long* plOption)
{
	*plOption = m_lDisableOption;

	return S_OK;
}


// SourceExpiration Property

STDMETHODIMP CUserMigration::put_SourceExpiration(long lExpiration)
{
	HRESULT hr = S_OK;

	if (IsSourceExpirationValid(lExpiration))
	{
		m_lSourceExpiration = lExpiration;
	}
	else
	{
		hr = AdmtSetError(CLSID_Migration, IID_IUserMigration, E_INVALIDARG, IDS_E_SOURCE_EXPIRATION_INVALID);
	}

	return hr;
}

STDMETHODIMP CUserMigration::get_SourceExpiration(long* plExpiration)
{
	*plExpiration = m_lSourceExpiration;

	return S_OK;
}


// MigrateSIDs Property

STDMETHODIMP CUserMigration::put_MigrateSIDs(VARIANT_BOOL bMigrate)
{
	m_bMigrateSids = bMigrate ? true : false;

	return S_OK;
}

STDMETHODIMP CUserMigration::get_MigrateSIDs(VARIANT_BOOL* pbMigrate)
{
	*pbMigrate = m_bMigrateSids ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// TranslateRoamingProfile Property

STDMETHODIMP CUserMigration::put_TranslateRoamingProfile(VARIANT_BOOL bTranslate)
{
	m_bTranslateRoamingProfile = bTranslate ? true : false;

	return S_OK;
}

STDMETHODIMP CUserMigration::get_TranslateRoamingProfile(VARIANT_BOOL* pbTranslate)
{
	*pbTranslate = m_bTranslateRoamingProfile ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// UpdateUserRights Property

STDMETHODIMP CUserMigration::put_UpdateUserRights(VARIANT_BOOL bUpdate)
{
	m_bUpdateUserRights = bUpdate ? true : false;

	return S_OK;
}

STDMETHODIMP CUserMigration::get_UpdateUserRights(VARIANT_BOOL* pbUpdate)
{
	*pbUpdate = m_bUpdateUserRights ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// MigrateGroups Property

STDMETHODIMP CUserMigration::put_MigrateGroups(VARIANT_BOOL bMigrate)
{
	m_bMigrateGroups = bMigrate ? true : false;

	return S_OK;
}

STDMETHODIMP CUserMigration::get_MigrateGroups(VARIANT_BOOL* pbMigrate)
{
	*pbMigrate = m_bMigrateGroups ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// UpdatePreviouslyMigratedObjects Property

STDMETHODIMP CUserMigration::put_UpdatePreviouslyMigratedObjects(VARIANT_BOOL bUpdate)
{
	m_bUpdatePreviouslyMigratedObjects = bUpdate ? true : false;

	return S_OK;
}

STDMETHODIMP CUserMigration::get_UpdatePreviouslyMigratedObjects(VARIANT_BOOL* pbUpdate)
{
	*pbUpdate = m_bUpdatePreviouslyMigratedObjects ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// FixGroupMembership Property

STDMETHODIMP CUserMigration::put_FixGroupMembership(VARIANT_BOOL bFix)
{
	m_bFixGroupMembership = bFix ? true : false;

	return S_OK;
}

STDMETHODIMP CUserMigration::get_FixGroupMembership(VARIANT_BOOL* pbFix)
{
	*pbFix = m_bFixGroupMembership ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// MigrateServiceAccounts Property

STDMETHODIMP CUserMigration::put_MigrateServiceAccounts(VARIANT_BOOL bMigrate)
{
	m_bMigrateServiceAccounts = bMigrate ? true : false;

	return S_OK;
}

STDMETHODIMP CUserMigration::get_MigrateServiceAccounts(VARIANT_BOOL* pbMigrate)
{
	*pbMigrate = m_bMigrateServiceAccounts ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}


// Migrate Method

STDMETHODIMP CUserMigration::Migrate(long lOptions, VARIANT vntInclude, VARIANT vntExclude)
{
	HRESULT hr = S_OK;

	MutexWait();

	bool bLogOpen = _Module.OpenLog();

	try
	{
		_Module.Log(ErrI, IDS_STARTED_USER_MIGRATION);

		InitSourceDomainAndContainer();
		InitTargetDomainAndContainer();

		VerifyInterIntraForest();
		ValidateMigrationParameters();

		if (m_bMigrateSids)
		{
			VerifyCanAddSidHistory();
		}

		VerifyPasswordOption();

		DoOption(lOptions, vntInclude, vntExclude);
	}
	catch (_com_error& ce)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IUserMigration, ce, IDS_E_CANT_MIGRATE_USERS);
	}
	catch (...)
	{
		hr = AdmtSetError(CLSID_Migration, IID_IUserMigration, E_FAIL, IDS_E_CANT_MIGRATE_USERS);
	}

	if (bLogOpen)
	{
		_Module.CloseLog();
	}

	MutexRelease();

	return hr;
}


// Implementation -----------------------------------------------------------


// ValidateMigrationParameters Method

void CUserMigration::ValidateMigrationParameters()
{
	bool bIntraForest = m_spInternal->IntraForest ? true : false;

	if (bIntraForest)
	{
		// validate conflict option

		long lConflictOptions = m_spInternal->ConflictOptions;
		long lConflictOption = lConflictOptions & 0x0F;

		if (lConflictOption == admtReplaceConflicting)
		{
			AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INTRA_FOREST_REPLACE);
		}
	}
}


// DoNames Method

void CUserMigration::DoNames()
{
	CDomainAccounts aUsers;

	m_SourceDomain.QueryUsers(GetSourceContainer(), m_setIncludeNames, m_setExcludeNames, aUsers);

	DoUsers(aUsers, GetTargetContainer());
}


// DoDomain Method

void CUserMigration::DoDomain()
{
	CContainer& rSource = GetSourceContainer();
	CContainer& rTarget = GetTargetContainer();

	if (m_nRecurseMaintain == 2)
	{
		rTarget.CreateContainerHierarchy(rSource);
	}

	DoContainers(rSource, rTarget);
}


// DoContainers Method

void CUserMigration::DoContainers(CContainer& rSource, CContainer& rTarget)
{
	DoUsers(rSource, rTarget);

	if (m_nRecurseMaintain == 2)
	{
		ContainerVector aContainers;
		rSource.QueryContainers(aContainers);

		for (ContainerVector::iterator it = aContainers.begin(); it != aContainers.end(); it++)
		{
			DoContainers(*it, rTarget.GetContainer(it->GetName()));
		}
	}
}


// DoUsers Method

void CUserMigration::DoUsers(CContainer& rSource, CContainer& rTarget)
{
	CDomainAccounts aUsers;
	rSource.QueryUsers(m_nRecurseMaintain == 1, m_setExcludeNames, aUsers);

	DoUsers(aUsers, rTarget);
}


// DoUsers Method

void CUserMigration::DoUsers(CDomainAccounts& rUsers, CContainer& rTarget)
{
	if (rUsers.size() > 0)
	{
		if (!m_bMigrateServiceAccounts)
		{
			RemoveServiceAccounts(rUsers);
		}

		if (rUsers.size() > 0)
		{
			CVarSet aVarSet;

			SetOptions(rTarget.GetPath(), aVarSet);
			SetAccountOptions(aVarSet);

			VerifyRenameConflictPrefixSuffixValid();

			FillInVarSetForUsers(rUsers, aVarSet);

			rUsers.clear();

			#ifdef _DEBUG
			aVarSet.Dump();
			#endif

			PerformMigration(aVarSet);

			SaveSettings(aVarSet);

			if ((m_nRecurseMaintain == 2) && m_bMigrateGroups)
			{
				FixObjectsInHierarchy(_T("group"));
			}
		}
	}
}


// RemoveServiceAccounts Method

void CUserMigration::RemoveServiceAccounts(CDomainAccounts& rUsers)
{
	try
	{
		CVarSet varset;

		IIManageDBPtr spDatabase(__uuidof(IManageDB));
		IUnknownPtr spunkVarSet(varset.GetInterface());
		IUnknown* punkVarset = spunkVarSet;
		spDatabase->GetServiceAccount(_bstr_t(_T("")), &punkVarset);

		long lCount = varset.Get(_T("ServiceAccountEntries"));

		if (lCount > 0)
		{
			StringSet setNames;

			for (long lIndex = 0; lIndex < lCount; lIndex++)
			{
				setNames.insert(_bstr_t(varset.Get(_T("ServiceAccount.%ld"), lIndex)));
			}

			_bstr_t strDomain = m_SourceDomain.NameFlat();

			for (CDomainAccounts::iterator itUser = rUsers.begin(); itUser != rUsers.end(); )
			{
				bool bFound = false;

				for (StringSet::iterator itName = setNames.begin(); itName != setNames.end(); itName++)
				{
					if (*itName == itUser->GetUserPrincipalName())
					{
						bFound = true;
						break;
					}

					if (*itName == (strDomain + _T("\\") + itUser->GetSamAccountName()))
					{
						bFound = true;
						break;
					}
				}

				if (bFound)
				{
					itUser = rUsers.erase(itUser);
				}
				else
				{
					++itUser;
				}
			}
		}
	}
	catch (_com_error& ce)
	{
		AdmtThrowError(GUID_NULL, GUID_NULL, ce, IDS_E_REMOVING_SERVICE_ACCOUNTS);
	}
}


// SetOptions Method

void CUserMigration::SetOptions(_bstr_t strTargetOu, CVarSet& rVarSet)
{
	CVarSetOptions aOptions(rVarSet);

	aOptions.SetTest(m_spInternal->TestMigration ? true : false);

	aOptions.SetUndo(false);
	aOptions.SetWizard(_T("user"));

	aOptions.SetIntraForest(m_spInternal->IntraForest ? true : false);
	aOptions.SetSourceDomain(m_SourceDomain.NameFlat(), m_SourceDomain.NameDns(), m_SourceDomain.Sid());
	aOptions.SetTargetDomain(m_TargetDomain.NameFlat(), m_TargetDomain.NameDns());
	aOptions.SetTargetOu(strTargetOu);

	if (m_spInternal->PasswordOption == admtCopyPassword)
	{
		aOptions.SetTargetServer(m_TargetDomain.DomainControllerName());
	}

	aOptions.SetRenameOptions(m_spInternal->RenameOption, m_spInternal->RenamePrefixOrSuffix);
}


// SetAccountOptions Method

void CUserMigration::SetAccountOptions(CVarSet& rVarSet)
{
	CVarSetAccountOptions aOptions(rVarSet);

	aOptions.SetPasswordOption(m_spInternal->PasswordOption, m_spInternal->PasswordServer);
	aOptions.SetPasswordFile(m_spInternal->PasswordFile);
	aOptions.SetConflictOptions(m_spInternal->ConflictOptions, m_spInternal->ConflictPrefixOrSuffix);

	aOptions.SetDisableOption(m_lDisableOption);
	aOptions.SetSourceExpiration(m_lSourceExpiration);
	aOptions.SetMigrateSids(m_bMigrateSids);
	aOptions.SetUserMigrationOptions(m_bMigrateGroups, m_bUpdatePreviouslyMigratedObjects);
//	aOptions.SetSidHistoryCredentials(NULL, NULL, NULL);
	aOptions.SetFixGroupMembership(m_bFixGroupMembership);
	aOptions.SetUpdateUserRights(m_bUpdateUserRights);
	aOptions.SetTranslateRoamingProfile(m_bTranslateRoamingProfile);

	aOptions.SetExcludedUserProps(m_spInternal->UserPropertiesToExclude);

	if (m_bMigrateGroups)
	{
		aOptions.SetExcludedGroupProps(m_spInternal->GroupPropertiesToExclude);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\common.cpp ===
//#pragma title( "Common.cpp - Common class implementations" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common class implementations.
Updates     -  1997-09-09 RED ErrorCodeToText moved to Err.cpp
            -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "Common.hpp"

///////////////////////////////////////////////////////////////////////////////
// TTime class member functions
///////////////////////////////////////////////////////////////////////////////

   TTime                     gTTime;       // global instance of TTime

time_t                                     // ret-current time
   TTime::Now(
      time_t               * pTime         // out-optional current time
   )  const
{
   time_t                    tTime;        // work copy of current time

   union
   {
      __int64                intTime;
      FILETIME               fileTime;
   }                         wTime;
   GetSystemTimeAsFileTime( &wTime.fileTime );
   tTime = ConvertFiletimeToTimet( wTime.intTime );

   if ( pTime ) *pTime = tTime;
   return tTime;
}

__int64                                    // ret-current time
   TTime::NowAsFiletime(
      __int64              * pTime         // out-optional current time
   )  const
{
   union
   {
      __int64                intTime;
      FILETIME               fileTime;
   }                         wTime;
   GetSystemTimeAsFileTime( &wTime.fileTime );
   if ( pTime ) *pTime = wTime.intTime;
   return wTime.intTime;
}

time_t                                     // ret-time_t representation
   TTime::ConvertFiletimeToTimet(
      __int64                fileTime      // in -filetime representation
   )  const
{
   __int64                   wTime;        // intermediate work area
   time_t                    retTime;      // returned time

   // If the source date/time is less than the minimum date/time supported
   // by time_t, then zero is returned.
   // If the source date/time is more that the maximum date/time supported
   // by time_t, then ULONG_MAX is returned.

   wTime = fileTime / 10000000;

   if ( wTime < 11644473600 )
   {
      retTime = 0;
   }
   else
   {
      wTime -= 11644473600;
      if ( wTime > ULONG_MAX )
      {
         retTime = ULONG_MAX;
      }
      else
      {
         retTime = (time_t) wTime;
      }
   }

   return retTime;
}


WCHAR *                                     // ret-YYYY-MM-DD HH:MM:SS string
   TTime::FormatIsoUtc(
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const
{
   struct tm               * tmTime;

   tmTime = gmtime( &tTime );
   tmTime->tm_year += tmTime->tm_year >= 70 ? 1900 : 2000;
   swprintf(
         sTime,
         L"%04d-%02d-%02d %02d:%02d:%02d",
         tmTime->tm_year,
         tmTime->tm_mon+1,
         tmTime->tm_mday,
         tmTime->tm_hour,
         tmTime->tm_min,
         tmTime->tm_sec );

   return sTime;
}

WCHAR *                                    // ret-YYYY-MM-DD HH:MM:SS string
   TTime::FormatIsoLcl(
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const
{
   struct tm               * tmTime;

   TIME_ZONE_INFORMATION     infoTime;     // WIN32 time zone info
   time_t                    wTime;        // workarea
   switch ( GetTimeZoneInformation( &infoTime ) )
   {
      case TIME_ZONE_ID_STANDARD:
         wTime = infoTime.StandardBias;
         break;
      case TIME_ZONE_ID_DAYLIGHT:
         wTime = infoTime.DaylightBias;
         break;
      default:
         wTime = 0;
         break;
   }
   wTime = (infoTime.Bias + wTime) * 60;
   wTime = tTime - wTime;
   if ( wTime < 0 )
   {
      wTime = 0;
   }
   tmTime = gmtime( &wTime );
   tmTime->tm_year += tmTime->tm_year >= 70 ? 1900 : 2000;
   swprintf(
         sTime,
         L"%04d-%02d-%02d %02d:%02d:%02d",
         tmTime->tm_year,
         tmTime->tm_mon+1,
         tmTime->tm_mday,
         tmTime->tm_hour,
         tmTime->tm_min,
         tmTime->tm_sec );

   return sTime;
}

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) plus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   )
{
   memset( pTimeZoneInfo, 0, sizeof *pTimeZoneInfo );
   BOOL                      retval=TRUE;  // returned value
   DWORD                     OsRc;         // OS return code
   TIME_ZONE_INFORMATION     TimeZoneInfo; // WIN32 time zone info

   OsRc = GetTimeZoneInformation( &TimeZoneInfo );
   switch ( OsRc )
   {
      case TIME_ZONE_ID_STANDARD:
         pTimeZoneInfo->dst = TimeZoneInfo.StandardBias;
         break;
      case TIME_ZONE_ID_DAYLIGHT:
         pTimeZoneInfo->dst = TimeZoneInfo.DaylightBias;
         break;
      case TIME_ZONE_ID_UNKNOWN:
         retval = TimeZoneInfo.Bias;
         break;
      default:
         retval = FALSE;
         break;
   }
   if ( retval )
   {
      pTimeZoneInfo->bias = TimeZoneInfo.Bias * 60;
      pTimeZoneInfo->dst *= 60;
      pTimeZoneInfo->biasdst = pTimeZoneInfo->bias + pTimeZoneInfo->dst;
   }
   return retval;
}

// Common.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\varsetoptions.cpp ===
#include "StdAfx.h"
#include "ADMTScript.h"
#include "Options.h"

#include "ADMTCommon.h"


//---------------------------------------------------------------------------
// Options Class
//---------------------------------------------------------------------------


// Constructor

COptions::COptions(const CVarSet& rVarSet) :
	CVarSet(rVarSet)
{
	Put(DCTVS_Options_MaxThreads, 20L);

	// TODO: these credentials are used during security translation?
	Put(DCTVS_Options_Credentials_Domain, (LPCTSTR)NULL);
	Put(DCTVS_Options_Credentials_UserName, (LPCTSTR)NULL);
	Put(DCTVS_Options_Credentials_Password, (LPCTSTR)NULL);

	_bstr_t strLogFolder = GetLogFolder();

	Put(DCTVS_Options_AppendToLogs, true);
	Put(DCTVS_Options_DispatchLog, strLogFolder + _T("Dispatch.log"));
	Put(DCTVS_Options_Logfile, strLogFolder + _T("Migration.log"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\varsetbase.h ===
#pragma once

#include "Error.h"


//---------------------------------------------------------------------------
// VarSet Class
//---------------------------------------------------------------------------


class CVarSet
{
public:

	CVarSet() :
		m_sp(__uuidof(VarSet)),
		m_vntYes(GET_STRING(IDS_YES)),
		m_vntNo(GET_STRING(IDS_No))
	{
	}

	CVarSet(const CVarSet& r) :
		m_sp(r.m_sp),
		m_vntYes(r.m_vntYes),
		m_vntNo(r.m_vntNo)
	{
	}

	//

	IVarSetPtr GetInterface()
	{
		return m_sp;
	}

	//

	void Put(UINT uId, bool bValue)
	{
		m_sp->put(GET_BSTR(uId), bValue ? m_vntYes : m_vntNo);
	}

	void Put(UINT uId, long lValue)
	{
		m_sp->put(GET_BSTR(uId), _variant_t(lValue));
	}

	void Put(UINT uId, LPCTSTR pszValue)
	{
		m_sp->put(GET_BSTR(uId), _variant_t(pszValue));
	}

	void Put(UINT uId, _bstr_t strValue)
	{
		m_sp->put(GET_BSTR(uId), _variant_t(strValue));
	}

	void Put(UINT uId, const _variant_t& vntValue)
	{
		m_sp->put(GET_BSTR(uId), vntValue);
	}

	//

	void Put(LPCTSTR pszName, bool bValue)
	{
		m_sp->put(_bstr_t(pszName), bValue ? m_vntYes : m_vntNo);
	}

	void Put(LPCTSTR pszName, long lValue)
	{
		m_sp->put(_bstr_t(pszName), _variant_t(lValue));
	}

	void Put(LPCTSTR pszName, LPCTSTR pszValue)
	{
		m_sp->put(_bstr_t(pszName), _variant_t(pszValue));
	}

	void Put(LPCTSTR pszName, _bstr_t strValue)
	{
		m_sp->put(_bstr_t(pszName), _variant_t(strValue));
	}

	void Put(LPCTSTR pszName, const _variant_t& vntValue)
	{
		m_sp->put(_bstr_t(pszName), vntValue);
	}

	//

	void Put(LPCTSTR pszFormat, long lIndex, bool bValue)
	{
		_TCHAR szName[256];
		_stprintf(szName, pszFormat, lIndex);
		m_sp->put(_bstr_t(szName), bValue ? m_vntYes : m_vntNo);
	}

	void Put(LPCTSTR pszFormat, long lIndex, long lValue)
	{
		_TCHAR szName[256];
		_stprintf(szName, pszFormat, lIndex);
		m_sp->put(_bstr_t(szName), _variant_t(lValue));
	}

	void Put(LPCTSTR pszFormat, long lIndex, LPCTSTR pszValue)
	{
		_TCHAR szName[256];
		_stprintf(szName, pszFormat, lIndex);
		m_sp->put(_bstr_t(szName), _variant_t(pszValue));
	}

	//

	_variant_t Get(UINT uId)
	{
		return m_sp->get(GET_BSTR(uId));
	}

	//

	_variant_t Get(LPCTSTR pszName)
	{
		return m_sp->get(_bstr_t(pszName));
	}

	bool GetBool(LPCTSTR pszName)
	{
		bool bValue = false;

		_variant_t vnt = m_sp->get(_bstr_t(pszName));

		if (vnt == m_vntYes)
		{
			bValue = true;
		}

		return bValue;
	}

	//

	_variant_t Get(LPCTSTR pszFormat, long lIndex)
	{
		_TCHAR szName[256];
		_stprintf(szName, pszFormat, lIndex);
		return m_sp->get(_bstr_t(szName));
	}

	bool GetBool(LPCTSTR pszFormat, long lIndex)
	{
		_TCHAR szName[256];
		_stprintf(szName, pszFormat, lIndex);
		return GetBool(szName);
	}

	//

	void Dump(LPCTSTR pszFile = _T("\\VarSetDump.txt"))
	{
		m_sp->DumpToFile(pszFile);
	}

protected:

	IVarSetPtr m_sp;

	_variant_t m_vntYes;
	_variant_t m_vntNo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\common.hpp ===
//#pragma title( "Common.hpp - Common classes of general utility" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common classes of general utility.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Common_hpp
#define  MCSINC_Common_hpp

// Start of header file dependencies

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef  _INC_STDIO
#include <stdio.h>
#endif

#ifndef _INC_TIME
#include <time.h>
#endif

#ifndef MCSINC_Mcs_h
#include "Mcs.h"
#endif

// End of header file dependencies

#define SECS(n) (n * 1000)
#define DIM(array) (sizeof (array) / sizeof (array[0]))
#ifdef  UNICODE
   typedef  unsigned short  UTCHAR;
   #define  UTEXT(quote)  ((unsigned short *) (L##quote))
#else
   typedef  unsigned char  UTCHAR;
   #define  UTEXT(quote)  ((unsigned char *) (quote))
#endif  // UNICODE

#define  UnNull(ptr)  ( (ptr) ? (ptr) : (UCHAR *) "" )

#define  DAYSECS  (24*60*60)

class TTime
{
private:
protected:
public:
   time_t Now(                             // ret-current time
      time_t               * pTime         // out-optional current time
   )  const;
#ifndef  WIN16_VERSION
   __int64 NowAsFiletime(                  // ret-current time
      __int64              * pTime         // out-optional current time
   )  const;
   time_t ConvertFiletimeToTimet(          // ret-time_t representation
      __int64                fileTime      // in -filetime representation
   )  const;
#endif  // WIN16_VERSION
   WCHAR * FormatIsoUtc(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
   WCHAR * FormatIsoLcl(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
};

extern
   TTime                     gTTime;       // global instance of TTime

#ifndef  WIN16_VERSION
__int64                                    // ret-numeric value of string
   TextToInt64(
      TCHAR          const * str          ,// in-string value to parse
      __int64                minVal       ,// in -min allowed value for result
      __int64                maxVal       ,// in -max allowed value for result
      char          const ** errMsg        // out-error message pointer or NULL
   );
#endif  // WIN16_VERSION

typedef  struct  EaTimeZoneInfo
{  // all values are in seconds
   long                      bias;         // time zone bias
   long                      dst;          // daylight savings time bias
   long                      biasdst;      // time zone bias including possible DST
}  EaTimeZoneInfo;

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) minus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   );

#endif  // MCSINC_Common_hpp

// Common.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\varsetaccounts.h ===
#pragma once

#include "VarSetBase.h"


//---------------------------------------------------------------------------
// VarSet Accounts Class
//---------------------------------------------------------------------------


class CVarSetAccounts : public CVarSet
{
public:

	CVarSetAccounts(const CVarSet& rVarSet) :
		CVarSet(rVarSet),
		m_lIndex(0)
	{
	}

	long GetCount()
	{
		return m_lIndex;
	}

	void AddAccount(LPCTSTR pszType, LPCTSTR pszPath, LPCTSTR pszName = NULL, LPCTSTR pszUPName = NULL)
	{
		_TCHAR szValueBase[64];
		_TCHAR szValueName[128];

		_stprintf(szValueBase, _T("Accounts.%ld"), m_lIndex);

		// ADsPath

		Put(szValueBase, pszPath);

		// type

		_tcscpy(szValueName, szValueBase);
		_tcscat(szValueName, _T(".Type"));

		Put(szValueName, pszType);

		// name

		if (pszName)
		{
			_tcscpy(szValueName, szValueBase);
			_tcscat(szValueName, _T(".Name"));

			Put(szValueName, pszName);
		}

		// user principal name

		if (pszUPName)
		{
			_tcscpy(szValueName, szValueBase);
			_tcscat(szValueName, _T(".UPNName"));

			Put(szValueName, pszUPName);
		}

		// target name

	//	_tcscpy(szValueName, szValueBase);
	//	_tcscat(szValueName, _T(".TargetName"));

	//	Put(szValueName, (LPCTSTR)NULL);

		Put(DCTVS_Accounts_NumItems, ++m_lIndex);
	}

protected:

	long m_lIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\varsetoptions.h ===
#pragma once

#include <Validation.h>
#include "VarSetBase.h"


//---------------------------------------------------------------------------
// VarSet Options Class
//---------------------------------------------------------------------------


class CVarSetOptions : public CVarSet
{
public:

	CVarSetOptions(const CVarSet& rVarSet) :
		CVarSet(rVarSet)
	{
	//	Put(DCTVS_Options_MaxThreads, 20L);

		// TODO: these credentials are used during security translation?
	//	Put(DCTVS_Options_Credentials_Domain, (LPCTSTR)NULL);
	//	Put(DCTVS_Options_Credentials_UserName, (LPCTSTR)NULL);
	//	Put(DCTVS_Options_Credentials_Password, (LPCTSTR)NULL);

		_bstr_t strLogFolder = GetLogFolder();

		Put(DCTVS_Options_DontBeginNewLog, true);
		Put(DCTVS_Options_AppendToLogs, true);
		Put(DCTVS_Options_Logfile, strLogFolder + _T("Migration.log"));
		Put(DCTVS_Options_DispatchLog, strLogFolder + _T("Dispatch.log"));
		Put(DCTVS_Options_AutoCloseHideDialogs, 2L);
	}

	//

	void SetTest(bool bTest)
	{
		Put(DCTVS_Options_NoChange, bTest);
	}

	void SetUndo(bool bUndo)
	{
		Put(DCTVS_Options_Undo, bUndo);
	}

	void SetWizard(LPCTSTR pszWizard)
	{
		Put(DCTVS_Options_Wizard, pszWizard);
	}

	void SetIntraForest(bool bIntraForest)
	{
		Put(DCTVS_Options_IsIntraforest, bIntraForest);
	}

	void SetSourceDomain(LPCTSTR pszNameFlat, LPCTSTR pszNameDns, LPCTSTR pszSid = NULL)
	{
		Put(DCTVS_Options_SourceDomain, pszNameFlat);
		Put(DCTVS_Options_SourceDomainDns, (pszNameDns && pszNameDns[0]) ? pszNameDns : pszNameFlat);

		if (pszSid)
		{
			Put(DCTVS_Options_SourceDomainSid, pszSid);
		}
	}

	void SetTargetDomain(LPCTSTR pszNameFlat, LPCTSTR pszNameDns)
	{
		Put(DCTVS_Options_TargetDomain, pszNameFlat);
		Put(DCTVS_Options_TargetDomainDns, pszNameDns);
	}

	void SetTargetOu(LPCTSTR pszOu)
	{
		Put(DCTVS_Options_OuPath, pszOu);
	}

	// only set if copying passwords

	void SetTargetServer(LPCTSTR pszServer)
	{
		Put(DCTVS_Options_TargetServerOverride, pszServer);
	}

	void SetRenameOptions(long lOption, LPCTSTR pszPrefixOrSuffix)
	{
		switch (lOption)
		{
			case admtRenameWithPrefix:
			{
				if (pszPrefixOrSuffix && (_tcslen(pszPrefixOrSuffix) > 0))
				{
					if (IsValidPrefixOrSuffix(pszPrefixOrSuffix))
					{
						Put(DCTVS_Options_Prefix, pszPrefixOrSuffix);
						Put(DCTVS_Options_Suffix, (LPCTSTR)NULL);
					}
					else
					{
						AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_RENAME_PREFIX_SUFFIX);
					}
				}
				else
				{
					AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_NO_RENAME_PREFIX);
				}
				break;
			}
			case admtRenameWithSuffix:
			{
				if (pszPrefixOrSuffix && (_tcslen(pszPrefixOrSuffix) > 0))
				{
					if (IsValidPrefixOrSuffix(pszPrefixOrSuffix))
					{
						Put(DCTVS_Options_Prefix, (LPCTSTR)NULL);
						Put(DCTVS_Options_Suffix, pszPrefixOrSuffix);
					}
					else
					{
						AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_INVALID_RENAME_PREFIX_SUFFIX);
					}
				}
				else
				{
					AdmtThrowError(GUID_NULL, GUID_NULL, E_INVALIDARG, IDS_E_RENAME_NO_SUFFIX);
				}
				break;
			}
		}
	}

	void SetRestartDelay(long lTime)
	{
		Put(DCTVS_Options_GuiOnlyRebootSaver, lTime);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\varsetreports.h ===
#pragma once

#include "VarSetBase.h"

#include <time.h>


//---------------------------------------------------------------------------
// VarSet Reports Class
//---------------------------------------------------------------------------


class CVarSetReports : public CVarSet
{
public:

	CVarSetReports(const CVarSet& rVarSet) :
		CVarSet(rVarSet)
	{
		Put(DCTVS_GatherInformation, true);
		Put(DCTVS_Reports_Generate, true);
	}

	//

	void SetType(int nType)
	{
		UINT uIdType;
		UINT uIdTime;

		switch (nType)
		{
			case admtReportMigratedAccounts:
				uIdType = DCTVS_Reports_MigratedAccounts;
				uIdTime = DCTVS_Reports_MigratedAccounts_TimeGenerated;
				break;
			case admtReportMigratedComputers:
				uIdType = DCTVS_Reports_MigratedComputers;
				uIdTime = DCTVS_Reports_MigratedComputers_TimeGenerated;
				break;
			case admtReportExpiredComputers:
				uIdType = DCTVS_Reports_ExpiredComputers;
				uIdTime = DCTVS_Reports_ExpiredComputers_TimeGenerated;
				break;
			case admtReportAccountReferences:
				uIdType = DCTVS_Reports_AccountReferences;
				uIdTime = DCTVS_Reports_AccountReferences_TimeGenerated;
				break;
			case admtReportNameConflicts:
				uIdType = DCTVS_Reports_NameConflicts;
				uIdTime = DCTVS_Reports_NameConflicts_TimeGenerated;
				break;
			default:
				_ASSERT(FALSE);
				break;
		}

		Put(uIdType, true);
		Put(uIdTime, _bstr_t(_variant_t(time(NULL))));
	}

	void SetReportsDirectory(LPCTSTR pszDirectory)
	{
		_bstr_t strDirectory;

		if (pszDirectory && pszDirectory[0])
		{
			strDirectory = pszDirectory;
		}
		else
		{
			strDirectory = GetReportsFolder();
		}

		Put(DCTVS_Reports_Directory, strDirectory);
	}
};


//---------------------------------------------------------------------------
// Validation Functions
//---------------------------------------------------------------------------


inline bool IsReportTypeValid(long lType)
{
	return ((lType >= admtReportMigratedAccounts) && (lType <= admtReportNameConflicts));
}


/*

Migrated Users & Groups

2000-11-20 12:05:27 VarSet
2000-11-20 12:05:27 Case Sensitive: Yes, Indexed: Yes
2000-11-20 12:05:27 User Data ( 25 ) items
2000-11-20 12:05:27  [] <Empty>
2000-11-20 12:05:27  [GatherInformation] Yes
2000-11-20 12:05:27  [Options] <Empty>
2000-11-20 12:05:27  [Options.AppendToLogs] Yes
2000-11-20 12:05:27  [Options.DispatchLog] E:\Program Files\Active Directory Migration Tool\Logs\dispatch.log
2000-11-20 12:05:27  [Options.IsIntraforest] No
2000-11-20 12:05:27  [Options.Logfile] E:\Program Files\Active Directory Migration Tool\Logs\Migration.log
2000-11-20 12:05:27  [Options.MaxThreads] 20
2000-11-20 12:05:27  [Options.SourceDomain] HAY-BUV
2000-11-20 12:05:27  [Options.SourceDomainDns] hay-buv.nttest.microsoft.com
2000-11-20 12:05:27  [Options.TargetDomain] HAY-BUV-MPO
2000-11-20 12:05:27  [Options.TargetDomainDns] hay-buv-mpo.nttest.microsoft.com
2000-11-20 12:05:27  [Options.Wizard] reporting
2000-11-20 12:05:27  [PlugIn] <Empty>
2000-11-20 12:05:27  [PlugIn.0] None
2000-11-20 12:05:27  [Reports] <Empty>
2000-11-20 12:05:27  [Reports.AccountReferences] No
2000-11-20 12:05:27  [Reports.Directory] E:\Program Files\Active Directory Migration Tool\Reports
2000-11-20 12:05:27  [Reports.ExpiredComputers] No
2000-11-20 12:05:27  [Reports.Generate] Yes
2000-11-20 12:05:27  [Reports.MigratedAccounts] Yes
2000-11-20 12:05:27  [Reports.MigratedAccounts.TimeGenerated] 974750727
2000-11-20 12:05:27  [Reports.MigratedComputers] No
2000-11-20 12:05:27  [Reports.NameConflicts] No
2000-11-20 12:05:27  [Security] <Empty>
2000-11-20 12:05:27  [Security.TranslateContainers] 

Migrated Computers

2000-11-20 12:21:13 VarSet
2000-11-20 12:21:13 Case Sensitive: Yes, Indexed: Yes
2000-11-20 12:21:13 User Data ( 25 ) items
2000-11-20 12:21:13  [] <Empty>
2000-11-20 12:21:13  [GatherInformation] Yes
2000-11-20 12:21:13  [Options] <Empty>
2000-11-20 12:21:13  [Options.AppendToLogs] Yes
2000-11-20 12:21:13  [Options.DispatchLog] E:\Program Files\Active Directory Migration Tool\Logs\dispatch.log
2000-11-20 12:21:13  [Options.IsIntraforest] No
2000-11-20 12:21:13  [Options.Logfile] E:\Program Files\Active Directory Migration Tool\Logs\Migration.log
2000-11-20 12:21:13  [Options.MaxThreads] 20
2000-11-20 12:21:13  [Options.SourceDomain] HAY-BUV
2000-11-20 12:21:13  [Options.SourceDomainDns] hay-buv.nttest.microsoft.com
2000-11-20 12:21:13  [Options.TargetDomain] HAY-BUV-MPO
2000-11-20 12:21:13  [Options.TargetDomainDns] hay-buv-mpo.nttest.microsoft.com
2000-11-20 12:21:13  [Options.Wizard] reporting
2000-11-20 12:21:13  [PlugIn] <Empty>
2000-11-20 12:21:13  [PlugIn.0] None
2000-11-20 12:21:13  [Reports] <Empty>
2000-11-20 12:21:13  [Reports.AccountReferences] No
2000-11-20 12:21:13  [Reports.Directory] E:\Program Files\Active Directory Migration Tool\Reports
2000-11-20 12:21:13  [Reports.ExpiredComputers] No
2000-11-20 12:21:13  [Reports.Generate] Yes
2000-11-20 12:21:13  [Reports.MigratedAccounts] No
2000-11-20 12:21:13  [Reports.MigratedComputers] Yes
2000-11-20 12:21:13  [Reports.MigratedComputers.TimeGenerated] 974751673
2000-11-20 12:21:13  [Reports.NameConflicts] No
2000-11-20 12:21:13  [Security] <Empty>
2000-11-20 12:21:13  [Security.TranslateContainers] 

Expired Computer Accounts

2000-11-20 12:22:49 VarSet
2000-11-20 12:22:49 Case Sensitive: Yes, Indexed: Yes
2000-11-20 12:22:49 User Data ( 25 ) items
2000-11-20 12:22:49  [] <Empty>
2000-11-20 12:22:49  [GatherInformation] Yes
2000-11-20 12:22:49  [Options] <Empty>
2000-11-20 12:22:49  [Options.AppendToLogs] Yes
2000-11-20 12:22:49  [Options.DispatchLog] E:\Program Files\Active Directory Migration Tool\Logs\dispatch.log
2000-11-20 12:22:49  [Options.IsIntraforest] No
2000-11-20 12:22:49  [Options.Logfile] E:\Program Files\Active Directory Migration Tool\Logs\Migration.log
2000-11-20 12:22:49  [Options.MaxThreads] 20
2000-11-20 12:22:49  [Options.SourceDomain] HAY-BUV
2000-11-20 12:22:49  [Options.SourceDomainDns] hay-buv.nttest.microsoft.com
2000-11-20 12:22:49  [Options.TargetDomain] HAY-BUV-MPO
2000-11-20 12:22:49  [Options.TargetDomainDns] hay-buv-mpo.nttest.microsoft.com
2000-11-20 12:22:49  [Options.Wizard] reporting
2000-11-20 12:22:49  [PlugIn] <Empty>
2000-11-20 12:22:49  [PlugIn.0] None
2000-11-20 12:22:49  [Reports] <Empty>
2000-11-20 12:22:49  [Reports.AccountReferences] No
2000-11-20 12:22:49  [Reports.Directory] E:\Program Files\Active Directory Migration Tool\Reports
2000-11-20 12:22:49  [Reports.ExpiredComputers] Yes
2000-11-20 12:22:49  [Reports.ExpiredComputers.TimeGenerated] 974751769
2000-11-20 12:22:49  [Reports.Generate] Yes
2000-11-20 12:22:49  [Reports.MigratedAccounts] No
2000-11-20 12:22:49  [Reports.MigratedComputers] No
2000-11-20 12:22:49  [Reports.NameConflicts] No
2000-11-20 12:22:49  [Security] <Empty>
2000-11-20 12:22:49  [Security.TranslateContainers] 

Account Reference

2000-11-20 12:25:16 VarSet
2000-11-20 12:25:16 Case Sensitive: Yes, Indexed: Yes
2000-11-20 12:25:16 User Data ( 43 ) items
2000-11-20 12:25:16  [] <Empty>
2000-11-20 12:25:16  [Accounts] <Empty>
2000-11-20 12:25:16  [Accounts.0] HAY-BUV3-DC1
2000-11-20 12:25:16  [Accounts.0.TargetName] 
2000-11-20 12:25:16  [Accounts.0.Type] computer
2000-11-20 12:25:16  [Accounts.1] HB-RES-MEM
2000-11-20 12:25:16  [Accounts.1.TargetName] 
2000-11-20 12:25:16  [Accounts.1.Type] computer
2000-11-20 12:25:16  [Accounts.NumItems] 2
2000-11-20 12:25:16  [GatherInformation] Yes
2000-11-20 12:25:16  [Options] <Empty>
2000-11-20 12:25:16  [Options.AppendToLogs] Yes
2000-11-20 12:25:16  [Options.Credentials] <Empty>
2000-11-20 12:25:16  [Options.Credentials.Domain] HAY-BUV
2000-11-20 12:25:16  [Options.Credentials.Password] xyz
2000-11-20 12:25:16  [Options.Credentials.UserName] Administrator
2000-11-20 12:25:16  [Options.DispatchLog] E:\Program Files\Active Directory Migration Tool\Logs\dispatch.log
2000-11-20 12:25:16  [Options.IsIntraforest] No
2000-11-20 12:25:16  [Options.Logfile] E:\Program Files\Active Directory Migration Tool\Logs\Migration.log
2000-11-20 12:25:16  [Options.MaxThreads] 20
2000-11-20 12:25:16  [Options.SourceDomain] HAY-BUV
2000-11-20 12:25:16  [Options.SourceDomainDns] hay-buv.nttest.microsoft.com
2000-11-20 12:25:16  [Options.TargetDomain] HAY-BUV-MPO
2000-11-20 12:25:16  [Options.TargetDomainDns] hay-buv-mpo.nttest.microsoft.com
2000-11-20 12:25:16  [Options.Wizard] reporting
2000-11-20 12:25:16  [PlugIn] <Empty>
2000-11-20 12:25:16  [PlugIn.0] None
2000-11-20 12:25:16  [Reports] <Empty>
2000-11-20 12:25:16  [Reports.AccountReferences] Yes
2000-11-20 12:25:16  [Reports.AccountReferences.TimeGenerated] 974751916
2000-11-20 12:25:16  [Reports.Directory] E:\Program Files\Active Directory Migration Tool\Reports
2000-11-20 12:25:16  [Reports.ExpiredComputers] No
2000-11-20 12:25:16  [Reports.Generate] Yes
2000-11-20 12:25:16  [Reports.MigratedAccounts] No
2000-11-20 12:25:16  [Reports.MigratedComputers] No
2000-11-20 12:25:16  [Reports.NameConflicts] No
2000-11-20 12:25:16  [Security] <Empty>
2000-11-20 12:25:16  [Security.TranslateContainers] 
2000-11-20 12:25:16  [Servers] <Empty>
2000-11-20 12:25:16  [Servers.0] \\HAY-BUV3-DC1
2000-11-20 12:25:16  [Servers.0.MigrateOnly] No
2000-11-20 12:25:16  [Servers.1] \\HB-RES-MEM
2000-11-20 12:25:16  [Servers.1.MigrateOnly] No
2000-11-20 12:25:16  [Servers.NumItems] 2

Account Name Conflict

2000-11-20 12:40:05 VarSet
2000-11-20 12:40:05 Case Sensitive: Yes, Indexed: Yes
2000-11-20 12:40:05 User Data ( 25 ) items
2000-11-20 12:40:05  [] <Empty>
2000-11-20 12:40:05  [GatherInformation] Yes
2000-11-20 12:40:05  [Options] <Empty>
2000-11-20 12:40:05  [Options.AppendToLogs] Yes
2000-11-20 12:40:05  [Options.DispatchLog] E:\Program Files\Active Directory Migration Tool\Logs\dispatch.log
2000-11-20 12:40:05  [Options.IsIntraforest] No
2000-11-20 12:40:05  [Options.Logfile] E:\Program Files\Active Directory Migration Tool\Logs\Migration.log
2000-11-20 12:40:05  [Options.MaxThreads] 20
2000-11-20 12:40:05  [Options.SourceDomain] HAY-BUV
2000-11-20 12:40:05  [Options.SourceDomainDns] hay-buv.nttest.microsoft.com
2000-11-20 12:40:05  [Options.TargetDomain] HAY-BUV-MPO
2000-11-20 12:40:05  [Options.TargetDomainDns] hay-buv-mpo.nttest.microsoft.com
2000-11-20 12:40:05  [Options.Wizard] reporting
2000-11-20 12:40:05  [PlugIn] <Empty>
2000-11-20 12:40:05  [PlugIn.0] None
2000-11-20 12:40:05  [Reports] <Empty>
2000-11-20 12:40:05  [Reports.AccountReferences] No
2000-11-20 12:40:05  [Reports.Directory] E:\Program Files\Active Directory Migration Tool\Reports
2000-11-20 12:40:05  [Reports.ExpiredComputers] No
2000-11-20 12:40:05  [Reports.Generate] Yes
2000-11-20 12:40:05  [Reports.MigratedAccounts] No
2000-11-20 12:40:05  [Reports.MigratedComputers] No
2000-11-20 12:40:05  [Reports.NameConflicts] Yes
2000-11-20 12:40:05  [Reports.NameConflicts.TimeGenerated] 974752805
2000-11-20 12:40:05  [Security] <Empty>
2000-11-20 12:40:05  [Security.TranslateContainers] 

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\varsetservers.h ===
#pragma once

#include "VarSetBase.h"


//---------------------------------------------------------------------------
// VarSet Servers Class
//---------------------------------------------------------------------------


class CVarSetServers : public CVarSet
{
public:

	CVarSetServers(const CVarSet& rVarSet) :
		CVarSet(rVarSet),
		m_lIndex(0)
	{
	}

	long GetCount()
	{
		return m_lIndex;
	}

	void AddServer(_bstr_t strServer, bool bMigrateOnly, bool bMoveToTarget, bool bReboot, long lRebootDelay)
	{
		_TCHAR szValueBase[64];
		_TCHAR szValueName[128];

		_stprintf(szValueBase, _T("Servers.%ld"), m_lIndex);

		// ADsPath
		// ADMT expects computer name to be prefixed with '\\'

		Put(szValueBase, _T("\\\\") + strServer);

		// migrate only

		_tcscpy(szValueName, szValueBase);
		_tcscat(szValueName, _T(".MigrateOnly"));

		Put(szValueName, bMigrateOnly);

		// move to target

		_tcscpy(szValueName, szValueBase);
		_tcscat(szValueName, _T(".MoveToTarget"));

		Put(szValueName, bMoveToTarget);

		// reboot

		_tcscpy(szValueName, szValueBase);
		_tcscat(szValueName, _T(".Reboot"));

		Put(szValueName, bReboot);

		// reboot delay

		_tcscpy(szValueName, szValueBase);
		_tcscat(szValueName, _T(".RebootDelay"));

		Put(szValueName, lRebootDelay * 60L);

		//

		Put(DCTVS_Servers_NumItems, ++m_lIndex);
	}

protected:

	long m_lIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\varsetsecurity.h ===
#pragma once

#include "VarSetBase.h"


//---------------------------------------------------------------------------
// VarSet Security Class
//---------------------------------------------------------------------------


class CVarSetSecurity : public CVarSet
{
public:

	CVarSetSecurity(CVarSet& rVarSet) :
		CVarSet(rVarSet),
		m_strReplace(GET_STRING(IDS_Replace)),
		m_strAdd(GET_STRING(IDS_Add)),
		m_strRemove(GET_STRING(IDS_Remove))
	{
	}

	//

	void SetGatherInformation(bool bGather)
	{
		Put(DCTVS_Security_GatherInformation, bGather);
	}

	void SetTranslateContainers(bool bTranslate)
	{
		if (bTranslate)
		{
			Put(DCTVS_Security_TranslateContainers, true);
		}
		else
		{
			Put(DCTVS_Security_TranslateContainers, (LPCTSTR)NULL);
		}
	}

	void SetTranslateFiles(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateFiles, bTranslate);
	}

	void SetTranslateLocalGroups(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateLocalGroups, bTranslate);
	}

	void SetTranslatePrinters(bool bTranslate)
	{
		Put(DCTVS_Security_TranslatePrinters, bTranslate);
	}

	void SetTranslateRegistry(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateRegistry, bTranslate);
	}

	void SetTranslateShares(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateShares, bTranslate);
	}

	void SetTranslateUserProfiles(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateUserProfiles, bTranslate);
	}

	void SetTranslateUserRights(bool bTranslate)
	{
		Put(DCTVS_Security_TranslateUserRights, bTranslate);
	}

	void SetTranslationOption(long lOption)
	{
		LPCTSTR pszOption;

		switch (lOption)
		{
			case admtTranslateReplace:
				pszOption = m_strReplace;
				break;
			case admtTranslateAdd:
				pszOption = m_strAdd;
				break;
			case admtTranslateRemove:
				pszOption = m_strRemove;
				break;
			default:
				pszOption = NULL;
				break;
		}

		Put(DCTVS_Security_TranslationMode, pszOption);
	}

protected:

	_bstr_t m_strReplace;
	_bstr_t m_strAdd;
	_bstr_t m_strRemove;
};


//---------------------------------------------------------------------------
// Validation Functions
//---------------------------------------------------------------------------


inline bool IsTranslationOptionValid(long lOption)
{
	return ((lOption >= admtTranslateReplace) && (lOption <= admtTranslateRemove));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\err.hpp ===
//#pragma title( "Err.hpp - Basic error handling/message/logging" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Err.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Implements the TError class that handles basic exception
               handling, message generation, and logging functions.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Err_hpp
#define  MCSINC_Err_hpp

// Start of header file dependencies

#ifndef  MCSINC_Common_hpp
#include "Common.hpp"
#endif

// End of header file dependencies

// ErrMsg error level constants
#define ErrT            (      - __LINE__) // Testing
#define ErrI            (00000 + __LINE__) // Information
#define ErrW            (10000 + __LINE__) // Warning
#define ErrE            (20000 + __LINE__) // Error
#define ErrS            (30000 + __LINE__) // Severe error
#define ErrV            (40000 + __LINE__) // Very sever error
#define ErrU            (50000 + __LINE__) // Unrecoverable error
#define ErrX            (60000 + __LINE__) // extremely unrecoverable <g>

#define ErrNone         (0)

class TError
{
protected:
   int                       level;
   int                       lastError;
   int                       maxError;
   int                       logLevel;     // minimum level to log
   int                       dispLevel;    // minimum level to display
   FILE                    * logFile;
   int                       beepLevel;
public:
                        TError(
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      WCHAR          const * filename = L"",// in -file name of log (NULL if none)
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
                                             //     Some people dont like the beeps so we turned it off by default.

                        );
                        ~TError();

   void __cdecl         MsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
   );
#ifndef WIN16_VERSION

   void __cdecl         SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   );
   void __cdecl         SysMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   );
#endif

   void __stdcall       MsgProcess(
      int                    num          ,// in -error number/level code
      WCHAR          const * str           // in -error string to display
   );

   virtual void __stdcall StrWrite(int level, WCHAR const * str) const { wprintf(L"%ls\n", str); };

   virtual BOOL         LogOpen(
      WCHAR          const * fileName     ,// in -name of file including any path
      int                    mode = 0     ,// in -0=overwrite, 1=append
      int                    level = 0     // in -minimum level to log
   );
   virtual void         LogClose() { if ( logFile ) fclose(logFile); };
   virtual void         LogWrite(WCHAR const * msg);
   void                 LevelSet(int displevel=0, int loglevel=-1, int beeplevel=2)
                           { dispLevel = displevel; logLevel = loglevel; beepLevel = beeplevel; };
   void                 LevelDispSet(int  displevel=0)
                           { dispLevel = displevel; };
   void                 LevelLogSet(int  loglevel=-1)
                           { logLevel = loglevel; };
   void                 LevelBeepSet(int  beeplevel=-1)
                           { beepLevel = beeplevel; };
   DWORD                MaxError()  const { return maxError; };
   DWORD                LastError() const { return lastError; };

   int                  GetMaxSeverityLevel () { return maxError / 10000; }

   virtual WCHAR * ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   );
};

extern TError              & errCommon;

#endif  // MCSINC_Err_hpp

// Err.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\errdct.hpp ===
#ifndef __ERRDCT_HPP__
#define __ERRDCT_HPP__
/*---------------------------------------------------------------------------
  File: ErrDct.hpp

  Comments: TError derived class that specifies a numeric code for each message 
  format.  The goal is to make it easy to convert this to a real message file 
  later.

  This class also improves on the behavior of the TError class by returning text
  for HRESULT error codes.
  

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/26/99 13:04:51

 ---------------------------------------------------------------------------
*/
#include "Err.hpp"
#include "Common.hpp"
#include "UString.hpp"    
#include "McsDmMsg.h"

// These codes are passed as the messageNumber argument to MsgWrite and SysMsgWrite.


// Recursively walk through a path, trying to create the directories at each level

DWORD          // ret - 0 if successful (directories created\already existed), OS return code otherwise
   DirectoryCreateR(
      WCHAR          const * dirToCreate       // in-directory to create (full path or UNC)
   );

class TErrorDct : public TError
{
public:
   TErrorDct(
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
      ) : TError(displevel,loglevel,NULL,logmode,beeplevel)
   {}
   virtual WCHAR * ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   );   

   WCHAR const * LookupMessage(UINT msgNumber);

   virtual void __cdecl
   SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      UINT                   msgNumber    ,// in -constant for message
            ...                            // in -printf args to msg pattern
   );

   virtual void __cdecl
   MsgWrite(
      int                    num          ,// in -error number/level code
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   );

   void __cdecl
      DbgMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
      );

   virtual BOOL         LogOpen(
      WCHAR          const * fileName     ,// in -name of file including any path
      int                    mode = 0     ,// in -0=overwrite, 1=append
      int                    level = 0     // in -minimum level to log
   )
   {
      WCHAR                  directory[MAX_PATH];

      safecopy(directory,fileName);

      WCHAR                * x = wcsrchr(directory,'\\');
      
      if ( x )
      {
         (*x) = 0;
         DirectoryCreateR(directory);
      }
      
      return TError::LogOpen(fileName,mode,level);
   }

};

#endif //__ERRDCT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\mcs.h ===
//---------------------------------------------------------------------------
// MCS.h 
//
// Main header file for all MCS applications.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_Mcs_h
#define MCSINC_Mcs_h
#ifdef __cplusplus

// Mandatory Pragma Definitions.
// #pragma warning( 3 : 4706 ) // assignment within if, while, etc.

// Header Files Common To All MCS Modules.
#include "McsDebug.h"   // contains debug macros, it depends on
                        // the following files: McsDebug.cpp,
                        // McsDebugUtil.h and McsDebugUtil.cpp.

#endif /* __cplusplus */
#endif /* MCSINC_Mcs_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\mcsdbgu.cpp ===
//---------------------------------------------------------------------------
// McsDebugUtil.cpp
//
// The classes declared in MCSDebugUtil.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++  */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "McsDbgU.h"

// -----------
// McsDebugLog
// ----------- 
void McsDebugUtil::McsDebugLog::write 
			(const char *messageIn) {
   if (m_outStream) {
      *(m_outStream) << messageIn;
      m_outStream->flush(); 
   }
}

#endif 	/* Not WIN16_VERSION */
#endif	/* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\mcsdbgu.h ===
//---------------------------------------------------------------------------
// McsDebugUtil.h
//
// The MCS Debug utility classes are declared in this file.
// The utility classes are:
//
// McsDebugException:
// This class is the exception class that is thrown by
// MCSEXCEPTION(SZ) macros and MCSASSERT(SZ) macros in
// test mode.
//
// McsDebugCritSec:
// Critical section class to support multi-threaded calls
// to the logger classes.
//
// McsDebugLog:
// Writes to ostream object.
// 
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebugUtil_h
#define MCSINC_McsDebugUtil_h

#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#include <iostream.h>
#include <fstream.h>

namespace McsDebugUtil {
   // ---------------
   // McsDebugCritSec
   // ---------------
   class McsDebugCritSec {
      public:
         McsDebugCritSec (void);
         ~McsDebugCritSec (void);
         void enter (void);
         void leave (void);

      private:
         McsDebugCritSec (const McsDebugCritSec&);
         McsDebugCritSec& operator= (const McsDebugCritSec&);

      private:
         CRITICAL_SECTION m_section;
   };

   // -----------
   // McsDebugLog
   // -----------
   class McsDebugLog {
      public:
         McsDebugLog (void);
         ~McsDebugLog (void);
         bool isLogSet (void) const;
         void changeLog (ostream *outStreamIn);
         void write (const char *messageIn);

      private:
         // Do not allow copy ctor & operator=.
         McsDebugLog (const McsDebugLog&);
         McsDebugLog& operator= (const McsDebugLog&);

      private: 
         ostream *m_outStream;
   };

   // --- INLINES ---
   // ---------------------
   // McsDebugCritSec
   // ---------------------
   inline McsDebugCritSec::McsDebugCritSec (void){
      ::InitializeCriticalSection (&m_section);
   }

   inline McsDebugCritSec::~McsDebugCritSec (void) {
      ::DeleteCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::enter (void) {
      ::EnterCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::leave (void) {
      ::LeaveCriticalSection (&m_section);
   }

   // -----------
   // McsDebugLog
   // ----------- 
   inline McsDebugLog::McsDebugLog (void)
   : m_outStream (NULL)
   { /* EMPTY */ }

   // outStream object is set and owned by the
   // user of this class do not delete.
   inline McsDebugLog::~McsDebugLog (void) { /* EMPTY */ }

   inline bool McsDebugLog::isLogSet (void) const
   { return m_outStream != NULL; }

   inline void McsDebugLog::changeLog 
                  (ostream *outStreamIn) {
      m_outStream = outStreamIn;
   }
}

#endif	/* Not WIN16_VERSION */
#endif	/* C++ */
#endif	/* MCSINC_Mcs_Debug_Util_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\mcsdebug.cpp ===
//---------------------------------------------------------------------------
// MCSDebug.cpp
//
// The classes declared in MCSDebug.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include <time.h>
#include <strstrea.h>
#include "UString.hpp"
#include "McsDebug.h"

// -----------------
// McsDebugException
// -----------------
McsDebugException::McsDebugException 
      (const McsDebugException &t) 
: m_message (0), m_fileName (0), m_lineNum (t.m_lineNum) {
	if (t.m_message) { 
		m_message = new char [UStrLen(t.m_message)+1];
      if (m_message) { UStrCpy (m_message, t.m_message); }
    }
    if (t.m_fileName) {
		m_fileName = new char [UStrLen(t.m_fileName)+1];
      if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
    }
}

McsDebugException::McsDebugException 
                           (const char *messageIn,
						          const char *fileNameIn,
							       int        lineNumIn) 
: m_lineNum (lineNumIn) {
   if (messageIn) { 
      m_message = new char [UStrLen (messageIn)+1];
      if (m_message) { UStrCpy (m_message, messageIn); }
   }
   if (fileNameIn) {
      m_fileName = new char [UStrLen(fileNameIn)+1];
      UStrCpy (m_fileName, fileNameIn);
   }
}

McsDebugException& McsDebugException::operator= 
         (const McsDebugException &t) {
   if (this != &t) {
      if (t.m_message) { 
         m_message = new char [UStrLen(t.m_message)+1];
         if (m_message) { UStrCpy (m_message, t.m_message); }
      }
      if (t.m_fileName) {
         m_fileName = new char [UStrLen(t.m_fileName)+1];
         if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
      }
      m_lineNum = t.m_lineNum;
   }
   return *this;
}

// ------------
// McsVerifyLog
// ------------
static McsVerifyLog *pVerifyLog;
static LONG         verifyInitFlag;

McsVerifyLog* McsVerifyLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pVerifyLog) {
      while (::InterlockedExchange 
               (&verifyInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pVerifyLog) {
         static McsVerifyLog verifyLog;
         pVerifyLog = &verifyLog;
      }
      ::InterlockedExchange (&verifyInitFlag, 0);
   }
   return pVerifyLog;
}

void McsVerifyLog::changeLog (ostream *outStreamIn) {
   m_logSec.enter();
   m_log.changeLog (outStreamIn);
   delete m_outLog;
   m_outLog = 0;
   m_logSec.leave();
}

void McsVerifyLog::log (const char *messageIn,
                        const char *fileNameIn,
                        int        lineNumIn) {
   m_logSec.enter();
   // If the log file has not been set, set it
   // to the module name log file.
   if (!m_log.isLogSet()) {
      m_outLog = new fstream (getLogFileName(), 
         ios::app);
      m_log.changeLog (m_outLog);
   }
   // Format and write the message.
   formatMsg (messageIn, fileNameIn, lineNumIn);
   m_log.write (m_msgBuf);
   m_logSec.leave();
}

const char* McsVerifyLog::getLogFileName (void) {
   const char  *MCS_LOG_ENV  = "MCS_LOG";
   const char  *DIR_SEP      = "\\";
   const char  *EXT          = ".err";
   const char  *DEFAULT_NAME = "MCSDEBUG";
   static char logFileName[MAX_PATH];

   // Get MCS_LOG_ENV, or temp directory path, 
   // NULL means current directory.
   logFileName[0] = 0;
   char *mcs_log_path = getenv (MCS_LOG_ENV);
   bool isLogPath = false;
   if (mcs_log_path) {
      DWORD attrib = ::GetFileAttributesA (mcs_log_path);
      if ((attrib != 0xFFFFFFFF)
          && (attrib & FILE_ATTRIBUTE_DIRECTORY)) {
         UStrCpy (logFileName, mcs_log_path);
         isLogPath = true;
      }
   }
   if (!isLogPath) { 
      ::GetTempPathA (MAX_PATH, logFileName);
   }

   // Get file name from the module name.  If error
   // generate fixed filename. 
   char fullFilePath [MAX_PATH];
   char fileName[MAX_PATH];
   if (::GetModuleFileNameA (NULL, fullFilePath, 
                  MAX_PATH)) {
      // Get file name out of the path
      _splitpath (fullFilePath, NULL, NULL, fileName, 
                        NULL);

      // Generate full path name with extension.
      int len = UStrLen (logFileName);
      if (len) {
         UStrCpy (logFileName + len, DIR_SEP);
         UStrCpy (logFileName + UStrLen (logFileName), 
                     fileName);
      } else {
         UStrCpy (logFileName, fileName);
      }
   } else {
      UStrCpy (logFileName, DEFAULT_NAME);
   }
   strcat (logFileName + UStrLen (logFileName), EXT);

   return logFileName;
}

void McsVerifyLog::formatMsg (const char *messageIn,
                              const char *fileNameIn,
                              int         lineNumIn) {
   const char  *TIME        = "TIME : ";
   const char  *MSG         = "MSG  : ";
   const char  *FILE        = "FILE : ";
   const char  *LINE        = "LINE : ";
   const char  *SPACER      = ", ";

   // Create stream buf object.
   strstream msgBufStream (m_msgBuf, MSG_BUF_LEN, ios::out);

   // Write time stamp.
   time_t cur;
   time (&cur);
   struct tm *curTm = localtime (&cur);
   if (curTm) {
      char *tstr = asctime (curTm);
      if (tstr) {
         msgBufStream << TIME << tstr << SPACER;
      }
   }

   // Write message.
   if (messageIn) {
      msgBufStream << MSG << messageIn << SPACER;
   }

   // Write file name.
   if (fileNameIn) {
      msgBufStream << FILE << fileNameIn << SPACER;
   }

   // Write line number.
   msgBufStream << LINE << lineNumIn << endl;
}

// ----------
// McsTestLog
// ----------
static McsTestLog *pTestLog;
static LONG       testInitFlag;

McsTestLog* McsTestLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pTestLog) {
      while (::InterlockedExchange 
               (&testInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pTestLog) {
         static McsTestLog testLog;
         pTestLog = &testLog;
      }
      ::InterlockedExchange (&testInitFlag, 0);
   }
   return pTestLog;
}

bool McsTestLog::isTestMode (void) {
   const char *TEST_ENV = "MCS_TEST";
   const char *PRE_FIX  = "MCS";

   // Check if tested.
   if (!m_isTested) {
      // If not tested lock, test again, and
      // initialize test mode flag.
      m_testSec.enter();
      if (!m_isTested) {
         m_isTested    = true;
         m_isTestMode_ = getenv (TEST_ENV) != NULL;
      }
      m_testSec.leave();
   }

   return m_isTestMode_;
}

#endif 	/* Not WIN16_VERSION */
#endif  /* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\detector.h ===
// SetDetector.h: Definition of the CSetDetector class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SETDETECTOR_H__48E3EC72_2B25_11D3_8AE5_00A0C9AFE114__INCLUDED_)
#define AFX_SETDETECTOR_H__48E3EC72_2B25_11D3_8AE5_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSetDetector

class CSetDetector : 
	public ISetDetector,
	public CComObjectRoot,
	public CComCoClass<CSetDetector,&CLSID_SetDetector>
{
public:
	CSetDetector() {}
BEGIN_COM_MAP(CSetDetector)
	COM_INTERFACE_ENTRY(ISetDetector)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSetDetector) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_SetDetector)

// ISetDetector
public:
   STDMETHOD(IsClosedSet)(/*[in]*/BSTR domain,/*[in]*/LONG nItems,/*[in,size_is(nItems)]*/ BSTR pNames[],/*[out]*/ BOOL * bIsClosed, /*[out]*/ BSTR * pReason);
};

#endif // !defined(AFX_SETDETECTOR_H__48E3EC72_2B25_11D3_8AE5_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__2DEA8C29_2B25_11D3_8AE5_00A0C9AFE114__INCLUDED_)
#define AFX_DLLDATAX_H__2DEA8C29_2B25_11D3_8AE5_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__2DEA8C29_2B25_11D3_8AE5_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "McsClosedSet_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\err.cpp ===
//#pragma title( "Err.cpp - Basic error handling/message/logging" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Err.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Implements the TError class that handles basic exception
               handling, message generation, and logging functions.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#ifndef WIN16_VERSION
   #include <lm.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include <stdarg.h>
#include <share.h>
#include <time.h>
#include <rpc.h>
#include <rpcdce.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"

#define  TERR_MAX_MSG_LEN  (2000)
#define  BYTE_ORDER_MARK   (0xFEFF)


TError::TError(
      int                    displevel    ,// in -mimimum severity level to display
      int                    loglevel     ,// in -mimimum severity level to log
      WCHAR          const * filename     ,// in -file name of log (NULL if none)
      int                    logmode      ,// in -0=replace, 1=append
      int                    beeplevel     // in -min error level for beeping
   )
{
   lastError = 0;
   maxError = 0;
   logLevel = loglevel;
   dispLevel = displevel;
   logFile = NULL;
   beepLevel = beeplevel;
   LogOpen(filename, logmode, loglevel);
}


TError::~TError()
{
   LogClose();
}

// Closes any existing open logFile and opens a new log file if the fileName is
// not null.  If it is a null string, then a default fileName of "Temp.log" is
// used.
BOOL
   TError::LogOpen(
      WCHAR           const * fileName    ,// in -name of file including any path
      int                     mode        ,// in -0=overwrite, 1=append
      int                     level        // in -minimum level to log
   )
{
   BOOL                       retval=TRUE;

   if ( logFile )
   {
      fclose(logFile);
      logFile = NULL;
   }

   if ( fileName && fileName[0] )
   {
      // Check to see if the file already exists
      WIN32_FIND_DATA      fDat;
      HANDLE               hFind;
      BOOL                 bExisted = FALSE;

      hFind = FindFirstFile(fileName,&fDat);
      if ( hFind != INVALID_HANDLE_VALUE )
      {
         FindClose(hFind);
         bExisted = TRUE;   
      }

      logFile = _wfsopen( fileName, mode == 0 ? L"wb" : L"ab", _SH_DENYNO );
      if ( !logFile )
      {
         MsgWrite( 4101, L"Log Open(%s) failed", fileName );
         retval = FALSE;
      }
      else
      {
         if (! bExisted )
         {
            // this is a new file we've just created
            // we need to write the byte order mark to the beginning of the file
            WCHAR x = BYTE_ORDER_MARK;
            fwprintf(logFile,L"%lc",x);
         }
      }
   }

   logLevel = level;

   return retval;
}


//-----------------------------------------------------------------------------
// Writes formatted message to log file and flushes buffers
//-----------------------------------------------------------------------------
void TError::LogWrite(WCHAR const * msg)
{
   WCHAR                     sTime[32];
   WCHAR                     sTemp[TERR_MAX_MSG_LEN];   
   
   // Get rid of the <CR> from the end of the message because it causes things
   // to run together in the logs
   wcscpy(sTemp, msg);
   DWORD dwLen = wcslen(sTemp);
   if ( sTemp[dwLen-1] == 0x0d )
      sTemp[dwLen-1] = 0x00;

   if ( logFile )
   {
      fwprintf(
            logFile,
            L"%s-%s\r\n",
            gTTime.FormatIsoLcl( gTTime.Now( NULL ), sTime ),
            sTemp );
      fflush( logFile );
   }
}

//-----------------------------------------------------------------------------
// Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::MsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;

   va_start(argPtr, msg);
   _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}

#ifndef WIN16_VERSION
//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;
   int                       len;

   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   va_start(argPtr, msg);
   len = _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);

   // append the system message for the lastRc at the end.
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len);
   }
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::SysMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;
   int                       len;
   DWORD                     lastRc = GetLastError();

   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   va_start( argPtr, msg );
   len = _vsnwprintf( suffix, DIM(suffix) - 1, msg, argPtr );

   // append the system message for the lastRc at the end.
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len);
   }
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}
#endif

//-----------------------------------------------------------------------------
// Error message format, display and exception processing function
//-----------------------------------------------------------------------------
void __stdcall
   TError::MsgProcess(
      int                    num          ,// in -error number/level code
      WCHAR          const * str           // in -error string to display
   )
{
   static WCHAR      const   prefLetter[] = L"TIWESVUXXXXX"; // These form the status code that appears at the start of each error message
   WCHAR                     fullmsg[TERR_MAX_MSG_LEN];
   struct
   {
      USHORT                 frequency;    // audio frequency
      USHORT                 duration;     // duration in mSec
   }                         audio[] = {{ 300,  20},{ 500,  50},{ 700, 100},
                                        { 800, 200},{1000, 300},{1500, 400},
                                        {2500, 750},{2500,1000},{2500,1000}};

   if ( num >= 0 )
      level = num / 10000;                 // 10000's position of error number
   else
      level = -1;
   if ( num == 0 )
   {
      wcsncpy(fullmsg, str, DIM(fullmsg));
      fullmsg[DIM(fullmsg) - 1] = L'\0';  // ensure null termination
   }
   else
   {
      if ( num > maxError )
         maxError = num;
      _snwprintf(fullmsg, DIM(fullmsg), L"%c%05d: %-s", prefLetter[level+1], num, str);
      fullmsg[DIM(fullmsg) - 1] = L'\0';  // ensure null termination
   }

   lastError = num;
   StrWrite(level, fullmsg);

   if ( level >= beepLevel )
      Beep(audio[level].frequency, audio[level].duration);

   if ( level >= logLevel )
      LogWrite(fullmsg);

   if ( level > 4 )
   {
      exit(level);
   }
}

//-----------------------------------------------------------------------------
// Return text for error code
//-----------------------------------------------------------------------------

WCHAR *        
   TError::ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   )
{
   static HMODULE            hNetMsg = NULL;
   DWORD                     rc;
   WCHAR                   * pMsg;

   msg[0] = '\0'; // force to null

   if ( code >= NERR_BASE && code < MAX_NERR )
   {
      if ( !hNetMsg )
         hNetMsg = LoadLibrary(L"netmsg.dll");
      rc = 1;
   }
   else
   {
      rc = DceErrorInqText( code, msg );
      // Change any imbedded CR or LF to blank.
      for ( pMsg = msg;
            *pMsg;
            pMsg++ )
      {
         if ( (*pMsg == L'\x0D') || (*pMsg == L'\x0A') )
            *pMsg = L' ';
      }
      // Remove trailing blanks
      for ( pMsg--;
            pMsg >= msg;
            pMsg-- )
      {
         if ( *pMsg == L' ' )
            *pMsg = L'\0';
         else
            break;
      }
   }
   if ( rc )
   {
      if ( code >= NERR_BASE && code < MAX_NERR && hNetMsg )
      {
         FormatMessage(FORMAT_MESSAGE_FROM_HMODULE
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | 80,
                        hNetMsg,
                        code,
                        0,
                        msg,
                        lenMsg,
                        NULL );
      }
      else
      {
         FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | 80,
                        NULL,
                        code,
                        0,
                        msg,
                        lenMsg,
                        NULL );
      }
   }
   return msg;
}

// Err.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\resstr.h ===
#ifndef RES_STRING_H
#define RES_STRING_H
#ifdef USE_STDAFX 
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include "TSync.hpp"

#define MAX_STRING_SIZE          (5000)
#include "Mcs.h"
#include "McsRes.h"
#include "UString.hpp"

class StringLoader
{
   HINSTANCE                 m_hInstance; // handle to resources to load from
   TCriticalSection          m_cs;
   WCHAR                     m_buffer[MAX_STRING_SIZE];
   DWORD                     rc;
public:
   StringLoader() 
   { 
      WCHAR                  fullpath[400];
      DWORD                  lenValue = sizeof(fullpath);
      DWORD                  type;
         // first, try to load from our install directory
      HKEY           hKey;
#ifdef OFA         
      rc = RegOpenKey(HKEY_LOCAL_MACHINE,L"Software\\Mission Critical Software\\OnePointFileAdmin",&hKey);
#else
      rc = RegOpenKey(HKEY_LOCAL_MACHINE,L"Software\\Mission Critical Software\\DomainAdmin",&hKey);
#endif
      if ( ! rc )
      {
         
         rc = RegQueryValueEx(hKey,L"Directory",0,&type,(LPBYTE)fullpath,&lenValue);
         if (! rc )
         {
            UStrCpy(fullpath+UStrLen(fullpath),L"McsDmRes.DLL");
         }
         RegCloseKey(hKey);
      }
      m_hInstance = LoadLibrary(fullpath);

      // If that fails, see if there's one anywhere in the path
      if ( ! m_hInstance )
      {
         m_hInstance = LoadLibrary(L"McsDmRes.DLL");
      }
      if (! m_hInstance ) 
      {
         MCSASSERTSZ(FALSE,"Failed to load McsDmRes.DLL");
         rc = GetLastError(); 
      }
   }

   WCHAR                   * GetString(UINT nID)
   {
      int                    len;
      WCHAR                * result = NULL;

      m_cs.Enter();
      m_buffer[0] = 0;
      len = LoadString(m_hInstance,nID,m_buffer,MAX_STRING_SIZE);
      if (! len )
      {
         DWORD               rc = GetLastError();
      }
      result = new WCHAR[len+1];
      wcscpy(result,m_buffer);
      m_cs.Leave();

      return result;
   }
};
          
extern StringLoader gString;
  
class TempString
{
   WCHAR                   * m_data;
public:
   TempString(WCHAR * data) { m_data = data; }
   ~TempString() { if ( m_data ) delete [] m_data; }
   operator WCHAR * () { return m_data; }
   operator WCHAR const * () { return (WCHAR const*)m_data; }
};

//#define GET_BSTR(nID) _bstr_t(SysAllocString(GET_STRING(nID)),false)
#define GET_BSTR(nID)   _bstr_t((WCHAR*)TempString(gString.GetString(nID)))

#define GET_STRING(nID) GET_STRING2(gString,nID)

#define GET_STRING2(strObj,nID) TempString(strObj.GetString(nID))

#define GET_WSTR(nID) ((WCHAR*)TempString(gString.GetString(nID)))
#endif RES_STRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\errdct.cpp ===
/*---------------------------------------------------------------------------
  File: ErrDct.cpp

  Comments: TError derived class for OnePoint Domain Administrator messages

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX 
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include "ErrDct.hpp"
#include "AdsErr.h"

#define  TERR_MAX_MSG_LEN  (2000)

// Recursively walk through a path, trying to create the directories at each level

DWORD          // ret - 0 if successful (directories created\already existed), OS return code otherwise
   DirectoryCreateR(
      WCHAR          const * dirToCreate       // in-directory to create (full path or UNC)
   )
{
   WCHAR                   * c;
   WCHAR                   * end;
   BOOL                      error = FALSE;
   DWORD                     rcOs;
   WCHAR                     dirName[MAX_PATH+1];
   BOOL                      isUNC = FALSE;
   BOOL                      skipShareName = FALSE;

   if ( !dirName )
      return ERROR_INVALID_PARAMETER;

   safecopy(dirName,dirToCreate);

   // Note: if the string is empty, that's ok - we will catch it when we don't see C:\ or C$\ below
   // walk through the string, and try to create at each step along the way

   do { // once
      c = dirName;
      end = dirName + UStrLen(dirName);
          // skip computer-name if UNC
      if ( *c == L'\\' && *(c + 1) == L'\\' )
      {
         isUNC = TRUE;
         for ( c=c+2 ; *c && *c != L'\\' ; c++ )
         ;
         if ( ! *c )
         {
            error = TRUE;
            rcOs = ERROR_INVALID_PARAMETER;
            break;
         }
         c++;
      }
      // skip C:\ or C$\.
      if ( *(c) &&  ( *(c+1)==L'$' || *(c+1)==L':' ) && *(c+2)==L'\\' )
      {
         c = c + 3;
         if ( c == end ) // They put in the root directory for some volume
            break;

      }
      else
      {
         if ( isUNC )
         {
            skipShareName = TRUE;
         }
         else
         {
            rcOs = ERROR_INVALID_PARAMETER;
            error = TRUE;
            break;
         }
      }
      // scan through the string looking for '\'
      for ( ; c <= end ; c++ )
      {
         if ( !*c || *c == L'\\' )
         {
            if ( skipShareName )
            {
               skipShareName = FALSE;
               continue;
            }
            // try to create at this level
            *c = L'\0';
            if ( ! CreateDirectory(dirName,NULL) )
            {
               rcOs = GetLastError();
               switch ( rcOs )
               {
               case 0:
               case ERROR_ALREADY_EXISTS:
                  break;
               default:
                  error = TRUE;
               }
            }
            if (c != end )
               *c = L'\\';
            if ( error )
                  break;
         }
      }
   } while ( FALSE );
   if ( !error )
      rcOs = 0;

   return rcOs;
}


WCHAR const *                               // ret- text for DCT message
   TErrorDct::LookupMessage(
      UINT                   msgNumber     // in - message number DCT_MSG_???
   )
{
   WCHAR             const * msg = NULL;

   return msg;
}

WCHAR *                                     // ret-text for system or EA error
   TErrorDct::ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   )
{
   if ( SUCCEEDED(code) )
   {
      return TError::ErrorCodeToText(code,lenMsg,msg);
   }
   else
   {
      if ( HRESULT_FACILITY(code) == FACILITY_WIN32 )
      {
         return TError::ErrorCodeToText(HRESULT_CODE(code),lenMsg,msg);
      }
      else
      {
         //Translate ADSI errors to DCT errors so message can be written.
         DWORD msgId = 0;
         switch ( code )
         {
            case (E_ADS_BAD_PATHNAME)              :   msgId = DCT_MSG_E_MSG_ADS_BAD_PATHNAME;
                                                      break;
            case (E_ADS_INVALID_DOMAIN_OBJECT)     :   msgId = DCT_MSG_E_ADS_INVALID_DOMAIN_OBJECT;
                                                      break;
            case (E_ADS_INVALID_USER_OBJECT)       :   msgId = DCT_MSG_E_ADS_INVALID_USER_OBJECT;
                                                      break;
            case (E_ADS_INVALID_COMPUTER_OBJECT)   :   msgId = DCT_MSG_E_ADS_INVALID_COMPUTER_OBJECT;
                                                      break;
            case (E_ADS_UNKNOWN_OBJECT)            :   msgId = DCT_MSG_E_ADS_UNKNOWN_OBJECT;
                                                      break;
            case (E_ADS_PROPERTY_NOT_SET)          :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_SET;
                                                      break;
            case (E_ADS_PROPERTY_NOT_SUPPORTED)    :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_SUPPORTED;
                                                      break;
            case (E_ADS_PROPERTY_INVALID)          :   msgId = DCT_MSG_E_ADS_PROPERTY_INVALID;
                                                      break;
            case (E_ADS_BAD_PARAMETER)             :   msgId = DCT_MSG_E_ADS_BAD_PARAMETER;
                                                      break;
            case (E_ADS_OBJECT_UNBOUND)            :   msgId = DCT_MSG_E_ADS_OBJECT_UNBOUND;
                                                      break;
            case (E_ADS_PROPERTY_NOT_MODIFIED)     :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_MODIFIED;
                                                      break;
            case (E_ADS_PROPERTY_MODIFIED)         :   msgId = DCT_MSG_E_ADS_PROPERTY_MODIFIED;
                                                      break;
            case (E_ADS_CANT_CONVERT_DATATYPE)     :   msgId = DCT_MSG_E_ADS_CANT_CONVERT_DATATYPE;
                                                      break;
            case (E_ADS_PROPERTY_NOT_FOUND)        :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_FOUND;
                                                      break;
            case (E_ADS_OBJECT_EXISTS)             :   msgId = DCT_MSG_E_ADS_OBJECT_EXISTS;
                                                      break;
            case (E_ADS_SCHEMA_VIOLATION)          :   msgId = DCT_MSG_E_ADS_SCHEMA_VIOLATION;
                                                      break;
            case (E_ADS_COLUMN_NOT_SET)            :   msgId = DCT_MSG_E_ADS_COLUMN_NOT_SET;
                                                      break;
            case (E_ADS_INVALID_FILTER)            :   msgId = DCT_MSG_E_ADS_INVALID_FILTER;
                                                      break;
            default                                :   msgId = 0;
         }

         if ( !msgId )
         {
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                         | FORMAT_MESSAGE_MAX_WIDTH_MASK
                         | FORMAT_MESSAGE_IGNORE_INSERTS
                         | 80,
                           NULL,
                           code,
                           0,
                           msg,
                           lenMsg,
                           NULL );
         }
         else
         {
            static HMODULE            hDctMsg = NULL;
            DWORD                     rc = 0;   
            if ( ! hDctMsg )
            {
               hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
               if ( ! hDctMsg )
               {
                  rc = GetLastError();
               }
            }

            if ( ! rc )
            {
               FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                          hDctMsg,
                          msgId,
                          0,
                          msg,
                          lenMsg,
                          NULL);
            }
            else
            {
               swprintf(msg,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgId);
            }
            
         }
      }
   }
   return msg;
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TErrorDct::SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      UINT                   msgNumber    ,// in -constant for message
            ...                            // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN] = L"";
   WCHAR                   * pMsg = NULL;
   va_list                   argPtr;
   int                       len;
   
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   static HMODULE            hDctMsg = NULL;
   DWORD                     rc = 0;

   if ( ! hDctMsg )
   {
      hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
      if ( ! hDctMsg )
      {
         rc = GetLastError();
      }
   }
   
   va_start(argPtr,msgNumber);
   
   if ( ! rc )
   {
      len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                 hDctMsg,
                 msgNumber,
                 0,
                 suffix,
                 DIM(suffix),
                 &argPtr);
   }
   else
   {
      swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
   }
   va_end(argPtr);
   
   // Change any imbedded CR or LF to blank.
   for ( pMsg = suffix;
         *pMsg;
         pMsg++ )
   {
      if ( (*pMsg == L'\x0D') || (*pMsg == L'\x0A') )
         *pMsg = L' ';
   }
   // append the system message for the lastRc at the end.
   len = UStrLen(suffix);
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len );
   }
   suffix[DIM(suffix) - 1] = '\0';
   
   va_end(argPtr);
   
   MsgProcess(num, suffix);
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TErrorDct::MsgWrite(
      int                    num          ,// in -error number/level code
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   )
{
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;
   static HMODULE            hDctMsg = NULL;
   DWORD                     rc = 0;

   if ( ! hDctMsg )
   {
     hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
	  if ( ! hDctMsg )
	  {
		  DWORD rc = GetLastError();
	  }

   }
   
   WCHAR                     suffix[TERR_MAX_MSG_LEN] = L"";
   va_list                   argPtr;

   va_start(argPtr,msgNumber);
   
   if ( rc == 0 )
   {
      FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                 hDctMsg,
                 msgNumber,
                 0,
                 suffix,
                 DIM(suffix),
                 &argPtr);
   }
   else
   {
      swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
   }
   if ( suffix[UStrLen(suffix)-1] == L'\n' )
   {
		suffix[UStrLen(suffix)-1] = L'\0';
   }
   
   va_end(argPtr);
   
   MsgProcess(num, suffix);

}

void __cdecl
   TErrorDct::DbgMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
      )
{
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;

   va_start(argPtr,msg);
   _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);

   MsgProcess(num, suffix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\detector.cpp ===
/*---------------------------------------------------------------------------
  File: SetDetector.cpp

  Comments: implementation of COM object to detect whether a set of users and 
  groups forms a closed set.

  This is used by the GUI, and the engine to determine whether ReACLing must be
  done for intra-forest, mixed-mode source domain, incremental migrations.
 
 (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 07/01/99 

 ---------------------------------------------------------------------------
*/// SetDetector.cpp : Implementation of CMcsClosedSetApp and DLL registration.

#include "stdafx.h"
#include "ClSet.h"
#include "Detector.h"
#include "Common.hpp"
#include "UString.hpp"
#include "TNode.hpp"
#include "ResStr.h"


#include <comdef.h>
#include <iads.h>
#include <adshlp.h>

#import "\bin\NetEnum.tlb" no_namespace, named_guids

class TItemNode : public TNode
{
   _bstr_t                   m_name;
   long                      m_iter;
   long                      m_status;
   long                      m_nLinks;
   TItemNode              ** m_Links;
public:
   TItemNode(WCHAR const * name) { m_name = name; m_Links = NULL; m_status = 0; m_iter = 0; m_nLinks = 0; }
   void SetIter(long val) { m_iter = val; }
   void SetStatus(long val) { m_status = val; }
   long GetStatus() { return m_status; }
   long GetIter() { return m_iter; }

   WCHAR const * GetName() { return (WCHAR const *)m_name; }
};

class TLinkTree : public TNodeListSortable
{
   static int CompNode(const TNode * n1, const TNode * n2)
   {
      TItemNode            * t1 = (TItemNode *)n1;
      TItemNode            * t2 = (TItemNode *)n2;

      return UStrICmp(t1->GetName(),t2->GetName());
   }
   static int CompValue(const TNode * n, const void * v)
   {
      TItemNode            * p = (TItemNode *)n;
      WCHAR          const * name = (WCHAR const *) v;

      return UStrICmp(p->GetName(),name);
   }
public:
   TLinkTree() { TypeSetTree(); CompareSet(&TLinkTree::CompNode); }
   ~TLinkTree() { ToSorted(); DeleteAllListItems(TItemNode); }
   TItemNode * Lookup(WCHAR const * name) { return (TItemNode *)Find(&TLinkTree::CompValue,name); }

};


/////////////////////////////////////////////////////////////////////////////
//

HRESULT 
   AddToList(
      TLinkTree            * pUsers,
      TLinkTree            * pGroups,
      WCHAR          const * domain,
      WCHAR          const * pName
   )
{
   HRESULT                   hr = S_OK;
   IADs                    * pADs = NULL;
   WCHAR                     path[MAX_PATH];
   BSTR                      bstrClass = NULL;
   TItemNode               * pNode = NULL;

   swprintf(path,L"LDAP://%s/%s",domain,pName);

   hr = ADsGetObject(path,IID_IADs,(void**)&pADs);
   if ( SUCCEEDED(hr) )
   {
      // get the object class
      hr = pADs->get_Class(&bstrClass);
      if ( SUCCEEDED(hr) )
      {
         if (!UStrICmp((WCHAR*)bstrClass,L"user") )
         {
            // add it to the users list
            pNode = new TItemNode(path);
            pUsers->Insert(pNode);
         }
         else if ( !UStrICmp((WCHAR*)bstrClass,L"group") )
         {  
            // add it to the groups list
            pNode = new TItemNode(path);
            pGroups->Insert(pNode);
         }
         else
         {
            // we only support users and groups!
            MCSASSERT(FALSE);
            hr = E_NOTIMPL;
         }

         SysFreeString(bstrClass);
      }
      pADs->Release();
   }
   return hr;
}

STDMETHODIMP 
   CSetDetector::IsClosedSet(
      BSTR                   domain,      /*[in]*/
      LONG                   nItems,      /*[in]*/
      BSTR                   pNames[],    /*[in,size_is(nItems)]*/ 
      BOOL                 * bIsClosed,   /*[out]*/ 
      BSTR                 * pReason      /*[out]*/ 
   )
{
   HRESULT                   hr = S_OK;
   long                      i;
   TLinkTree                 users;
   TLinkTree                 groups;
   BOOL                      bClosed = TRUE;
   WCHAR                     path[MAX_PATH];

   // initialize output variables
   (*bIsClosed) = FALSE;
   (*pReason) = NULL;

   // sort through the list of items  and add them to the trees
   for ( i = 0 ; i < nItems ; i++ )
   {
      // for each item, get an IADs pointer to it and add it to the tree
      hr = AddToList(&users,&users,domain,pNames[i]);

   }
   // now iterate through the user's tree checking the group memberships of each user
   TNodeTreeEnum             e;
   TItemNode               * pUser;
   IADsUser                * pADs = NULL;
   IADsContainer           * pCont = NULL;
   INetObjEnumeratorPtr      pEnum;
   VARIANT                   member;
   VARIANT                   memberOf;
   IEnumVARIANT            * pEnumerator = NULL;
   WCHAR                     reason[1000] = L"";

   VariantInit(&member);
   VariantInit(&memberOf);

   hr = pEnum.CreateInstance(CLSID_NetObjEnumerator);
   if ( SUCCEEDED(hr) )
   {

      for ( i = 0 , pUser = (TItemNode*)e.OpenFirst(&users) ; pUser && bClosed ; pUser = (TItemNode*)e.Next() , i++)
      {
         // get the group memberships for the user
         swprintf(path,L"LDAP://%s/%s",domain,pNames[i]);
         SAFEARRAYBOUND      bound[1] = { { 3, 0 } };
         SAFEARRAY         * pArray = SafeArrayCreate(VT_BSTR,1,bound);
         
         hr = pEnum->SetQuery(path,domain,L"(objectClass=*)",ADS_SCOPE_BASE,TRUE);
         if ( SUCCEEDED(hr) )
         {
            long ndx[1];
            ndx[0] = 0;
            SafeArrayPutElement(pArray,ndx,SysAllocString(L"member"));
            ndx[0] = 1;
            SafeArrayPutElement(pArray,ndx,SysAllocString(L"memberOf"));
            ndx[0] = 2;
            SafeArrayPutElement(pArray,ndx,SysAllocString(L"distinguishedName"));

            hr = pEnum->SetColumns((long)pArray);
         }
         if ( SUCCEEDED(hr) )
         {
            hr = pEnum->Execute(&pEnumerator);
         }
         if ( SUCCEEDED(hr) )
         {
            unsigned long             count = 0;

            while (  bClosed &&  hr != S_FALSE )
            {
               hr = pEnumerator->Next(1,&member,&count);
               
               // break if there was an error, or Next returned S_FALSE
               if ( hr != S_OK )
                  break;
               // see if this is an array
               if ( member.vt == ( VT_ARRAY | VT_VARIANT ) )
               {
                  pArray = member.parray;
                  VARIANT              * pData;
                  WCHAR                  path2[MAX_PATH];

                  SafeArrayAccessData(pArray,(void**)&pData);
                  // pData[0] has the members list
                  if ( pData[0].vt == ( VT_ARRAY | VT_VARIANT) )
                  {
                     // enumerate the members, checking to see if each one is in the list
                     SAFEARRAY         * pMembers = pData[0].parray;
                     VARIANT           * pMemVar = NULL;
                     long                count;
                     
                     SafeArrayGetUBound(pMembers,1,&count);
                     SafeArrayAccessData(pMembers,(void**)&pMemVar);
                     for ( long i = 0 ; i <= count ; i++ )
                     {
                        swprintf(path2,L"LDAP://%ls/%ls",domain,pMemVar[i].bstrVal);
                        // check each member to see if it is in the tree
                        if ( ! users.Lookup(path2) )
                        {
                           WCHAR   * args[2];
                           args[0] = path;
                           args[1] = pMemVar[i].bstrVal;

                           FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                          GET_STRING(IDS_CLSET_MEMBER_NOT_INCLUDED),0,0,reason,DIM(reason),(char **)args);  
                           bClosed = FALSE;
                           break;
                        }
                     }
                     SafeArrayUnaccessData(pMembers);
                  }
                  else
                  {
                     // there may be just a single member
                     if ( pData[0].vt == VT_BSTR && UStrLen(pData[0].bstrVal))
                     {
                        swprintf(path2,L"LDAP://%ls/%ls",domain,pData[0].bstrVal);
                        // check each member to see if it is in the tree
                        if ( ! users.Lookup(path2) )
                        {
                           WCHAR   * args[2];
                           args[0] = path;
                           args[1] = pData[0].bstrVal;

                           FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                          GET_STRING(IDS_CLSET_MEMBER_NOT_INCLUDED),0,0,reason,DIM(reason),(char **)args);  
                           bClosed = FALSE;
                           break;
                        }
                     }
                  }


                  // pData[1] has the memberOf list
                  if ( pData[1].vt == ( VT_ARRAY | VT_VARIANT) )
                  {
                     // enumerate the member-ofs, checking to see if each one is in the list
                     // enumerate the members, checking to see if each one is in the list
                     SAFEARRAY         * pMembers = pData[1].parray;
                     VARIANT           * pMemVar = NULL;
                     long                count;
                     
                     hr = SafeArrayGetUBound(pMembers,1,&count);
                     hr = SafeArrayAccessData(pMembers,(void**)&pMemVar);
                     for ( long i = 0 ; i <= count ; i++ )
                     {
                        swprintf(path2,L"LDAP://%ls/%ls",domain,pMemVar[i].bstrVal);
                        // check each member to see if it is in the tree
                        if ( ! users.Lookup(path2) )
                        {
                           WCHAR   * args[2];
                           args[0] = path;
                           args[1] = pMemVar[i].bstrVal;

                           FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                          GET_STRING(IDS_CLSET_GROUP_NOT_INCLUDED),0,0,reason,DIM(reason),(char **)args);  
                           
                           bClosed = FALSE;
                           break;
                        }
                     }
                     SafeArrayUnaccessData(pMembers);
                  }
                  else
                  {
                     // there may be just a single entry
                     if ( pData[1].vt == VT_BSTR && UStrLen(pData[1].bstrVal))
                     {
                        swprintf(path2,L"LDAP://%ls/%ls",domain,pData[1].bstrVal);
                        // check each member to see if it is in the tree
                        if ( ! users.Lookup(path2) )
                        {
                           WCHAR   * args[2];
                           args[0] = path;
                           args[1] = pData[1].bstrVal;

                           FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                          GET_STRING(IDS_CLSET_GROUP_NOT_INCLUDED),0,0,reason,DIM(reason),(char **)args);  
                           
                           bClosed = FALSE;
                           break;
                        }
                     }
                  }

                  SafeArrayUnaccessData(pArray);
               
               }
            }
            pEnumerator->Release();
            VariantInit(&member);
         }
      }
      e.Close();
   }
   (*bIsClosed) = bClosed;
   if ( ! bClosed )
   {
      (*pReason) = SysAllocString(reason);
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\tsync.cpp ===
//#pragma title( "TSync.cpp - Common synchronization classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TSync.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-08
Description -  Common synchronization classes
               TCriticalSection
               TSemaphoreNamed
Updates     -
===============================================================================
*/

#include <stdio.h>
#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <time.h>

#include "Common.hpp"
#include "Err.hpp"
#include "TSync.hpp"

///////////////////////////////////////////////////////////////////////////////
// TSemaphoreNamed member functions
///////////////////////////////////////////////////////////////////////////////

// Create named semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Create(
      TCHAR          const * sNameT       ,// in -semaphore name
      DWORD                  nInitial     ,// in -initial count
      DWORD                  nMaximum     ,// in -maximum count
      BOOL                 * pbExisted     // out-TRUE=previously existed
   )
{
   DWORD                     rcOs=0;       // OS return code
   handle = CreateSemaphore( NULL, nInitial, nMaximum, sNameT );
   if ( handle == NULL )
   {
      rcOs = GetLastError();
   }
   else if ( pbExisted )
   {
      rcOs = GetLastError();
      switch ( rcOs )
      {
         case 0:
            *pbExisted = FALSE;
            break;
         case ERROR_ALREADY_EXISTS:
            *pbExisted = TRUE;
            rcOs = 0;
            break;
         default:
            break;
      }
   }
   return rcOs;
}

// Open named semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Open(
      TCHAR          const * sNameT        // in -semaphore name
   )
{
   DWORD                     rcOs=0;       // OS return code
   handle = OpenSemaphore( SEMAPHORE_ALL_ACCESS, FALSE, sNameT );
   if ( handle == NULL ) rcOs = GetLastError();
   return rcOs;
}

// Release semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Release(
      long                   nRelease      // in -number to release
   )
{
   DWORD                     rcOs;         // OS return code
   long                      nPrevious=0;  // previous count
   rcOs = ReleaseSemaphore( Handle(), nRelease, &nPrevious )
         ? 0 : GetLastError();
   return rcOs;
}


// TSync.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\mcsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McDomRes.rc
//
#define DCTVS_Options_SourceDomain      1
#define DCTVS_Options_TargetDomain      2
#define DCTVS_Options_NoChange          3
#define DCTVS_Options_LogLevel          4
#define DCTVS_Options_LogToTemp         5
#define DCTVS_Options_Logfile           6
#define DCTVS_Options_Credentials_Domain 7
#define DCTVS_Options_Credentials_UserName 8
#define DCTVS_Options_Credentials_Password 9
#define DCTVS_Options_Credentials_Server 10
#define DCTVS_Options_Credentials_Share 11
#define DCTVS_Options_ResultFile        12
#define DCTVS_Options_DeleteFileAfterLoad 13
#define DCTVS_Options_RemoveAgentOnCompletion 14
#define DCTVS_Options_SourceDomainSid   15
#define DCTVS_Options_TargetDomainSid   16
#define DCTVS_Options_LocalProcessingOnly 17
#define DCTVS_ConfigurationFile         18
#define DCTVS_InstallToServer           19
#define DCTVS_Dispatcher_ResultPath     20
#define DCTVS_StatusObject              21
#define DCTVS_Options_UniqueNumberForResultsFile 22
#define DCTVS_Options_MaxThreads        23
#define DCTVS_Options_DispatchLog       24
#define DCTVS_GatherInformation_UserRights 25
#define DCTVS_GatherInformation_ComputerPasswordAge 26
#define DCTVS_Security_ReportAccountReferences 27
#define DCTVS_Security_GatherInformation 28
#define DCTVS_Security_TranslationMode  29
#define DCTVS_Security_BuildCacheFile   30
#define DCTVS_Security_TranslateFiles   31
#define DCTVS_Security_TranslateShares  32
#define DCTVS_Security_TranslateUserRights 33
#define DCTVS_Security_TranslateMailboxes 34
#define DCTVS_Security_TranslateContainers 35
#define DCTVS_Security_TranslateLocalGroups 36
#define DCTVS_Security_TranslatePrinters 37
#define DCTVS_Security_TranslateUserProfiles 38
#define DCTVS_Security_MapiProfile      39
#define DCTVS_Accounts_InputFile        40
#define DCTVS_Accounts_WildcardSpec     41
#define DCTVS_Accounts_WildcardSpec_Computer 42
#define DCTVS_Accounts_NumItems         43
#define DCTVS_AccountOptions_CopyUsers  44
#define DCTVS_AccountOptions_CopyLocalGroups 45
#define DCTVS_AccountOptions_CopyGlobalGroups 46
#define DCTVS_AccountOptions_CopyComputers 47
#define DCTVS_AccountOptions_Prefix     48
#define DCTVS_AccountOptions_AddToGroup 49
#define DCTVS_AccountOptions_AddToGroupOnSourceDomain 50
#define DCTVS_AccountOptions_DisableCopiedAccounts 51
#define DCTVS_AccountOptions_DisableSourceAccounts 52
#define DCTVS_AccountOptions_CopyPasswords 53
#define DCTVS_AccountOptions_GenerateStrongPasswords 54
#define DCTVS_AccountOptions_PasswordFile 55
#define DCTVS_AccountOptions_UpdateUserRights 56
#define DCTVS_AccountOptions_ReplaceExistingAccounts 57
#define DCTVS_AccountOptions_ReplaceExistingGroupMembers 58
#define DCTVS_AccountOptions_RemoveExistingUserRights 59
#define DCTVS_AccountOptions_CSVResultFile 60
#define DCTVS_AccountOptions_RenameOnly 61
#define DCTVS_AccountOptions_AddSidHistory 62
#define DCTVS_AccountOptions_TranslateRoamingProfiles 63
#define DCTVS_LocalServer_RenameTo      64
#define DCTVS_LocalServer_ChangeDomain  65
#define DCTVS_LocalServer_Reboot        66
#define DCTVS_LocalServer_RebootDelay   67
#define DCTVS_LocalServer_MigrateOnly   68
#define DCTVS_Servers_NumItems          69
#define DCTVS_JobStatus                 70
#define DCTVS_CurrentPath               71
#define DCTVS_Server_Index              72
#define DCTVS_CurrentOperation          141
#define DCTVS_Results_ErrorLevel        142
#define DCTVS_Stats_Paths               144
#define DCTVS_Stats_Servers             145
#define DCTVS_Stats_Files_Examined      146
#define DCTVS_Stats_Files_Changed       147
#define DCTVS_Stats_Files_Skipped       148
#define DCTVS_Stats_Files_CacheHits     149
#define DCTVS_Stats_Directories_Examined 150
#define DCTVS_Stats_Directories_Changed 151
#define DCTVS_Stats_Directories_Skipped 152
#define DCTVS_Stats_Directories_CacheHits 153
#define DCTVS_Stats_Shares_Examined     154
#define DCTVS_Stats_Shares_Changed      155
#define DCTVS_Stats_Shares_Skipped      156
#define DCTVS_Stats_Shares_CacheHits    157
#define DCTVS_Stats_Members_Examined    158
#define DCTVS_Stats_Members_Changed     159
#define DCTVS_Stats_Members_Skipped     160
#define DCTVS_Stats_Members_CacheHits   161
#define DCTVS_Stats_UserRights_Examined 162
#define DCTVS_Stats_UserRights_Changed  163
#define DCTVS_Stats_UserRights_Skipped  164
#define DCTVS_Stats_UserRights_CacheHits 165
#define DCTVS_Stats_Mailboxes_Examined  166
#define DCTVS_Stats_Mailboxes_Changed   167
#define DCTVS_Stats_Mailboxes_Skipped   168
#define DCTVS_Stats_Mailboxes_CacheHits 169
#define DCTVS_Stats_Containers_Examined 170
#define DCTVS_Stats_Containers_Changed  171
#define DCTVS_Stats_Containers_Skipped  172
#define DCTVS_Stats_Containers_CacheHits 173
#define DCTVS_Stats_Owners_Examined     174
#define DCTVS_Stats_Groups_Examined     175
#define DCTVS_Stats_DACL_Examined       176
#define DCTVS_Stats_SACL_Examined       177
#define DCTVS_Stats_DACE_Examined       178
#define DCTVS_Stats_SACE_Examined       179
#define DCTVS_Stats_Owners_Changed      180
#define DCTVS_Stats_Groups_Changed      181
#define DCTVS_Stats_DACL_Changed        182
#define DCTVS_Stats_SACL_Changed        183
#define DCTVS_Stats_DACE_Changed        184
#define DCTVS_Stats_SACE_Changed        185
#define DCTVS_Stats_Owners_NoTarget     186
#define DCTVS_Stats_Groups_NoTarget     187
#define DCTVS_Stats_DACE_NoTarget       188
#define DCTVS_Stats_SACE_NoTarget       189
#define DCTVS_Stats_Owners_NotSelected  190
#define DCTVS_Stats_Groups_NotSelected  191
#define DCTVS_Stats_DACE_NotSelected    192
#define DCTVS_Stats_SACE_NotSelected    193
#define DCTVS_Stats_Owners_Unknown      194
#define DCTVS_Stats_Groups_Unknown      195
#define DCTVS_Stats_DACE_Unknown        196
#define DCTVS_Stats_SACE_Unknown        197
#define DCTVS_Stats_Accounts_NumUsers   198
#define DCTVS_Stats_Accounts_NumGlobalGroups 199
#define DCTVS_Stats_Accounts_NumLocalGroups 200
#define DCTVS_Stats_Accounts_NumOther   201
#define DCTVS_Stats_Users_Examined      202
#define DCTVS_Stats_Users_Created       203
#define DCTVS_Stats_Users_Replaced      204
#define DCTVS_Stats_Users_Warnings      205
#define DCTVS_Stats_Users_Errors        206
#define DCTVS_Stats_GlobalGroups_Examined 207
#define DCTVS_Stats_GlobalGroups_Created 208
#define DCTVS_Stats_GlobalGroups_Replaced 209
#define DCTVS_Stats_GlobalGroups_Warnings 210
#define DCTVS_Stats_GlobalGroups_Errors 211
#define DCTVS_Stats_LocalGroups_Examined 212
#define DCTVS_Stats_LocalGroups_Created 213
#define DCTVS_Stats_LocalGroups_Replaced 214
#define DCTVS_Stats_LocalGroups_Warnings 215
#define DCTVS_Stats_LocalGroups_Errors  216
#define DCTVS_Stats_Computers_Examined  217
#define DCTVS_Stats_Computers_Created   218
#define DCTVS_Stats_Computers_Replaced  219
#define DCTVS_Stats_Computers_Warnings  220
#define DCTVS_Stats_Computers_Errors    221
#define DCTVS_AgentService_DebugMode    222
#define IDS_DISPLAY_NAME                223
#define IDS_SERVICE_NAME                224
#define IDS_LOCALSERVICE_PATH           225
#define IDS_SERVICE_PATH                226
#define IDS_AGENT_EXE                   227
#define IDS_SERVICE_EXE                 228
#define IDS_WORKER_DLL                  229
#define IDS_VARSET_DLL                  230
#define IDS_DATA_FILE                   231
#define IDS_EVENTSOURCE                 232
#define IDS_APPNAME                     233
#define IDS_LOG_FILENAME                234
#define DCTVS_AccountOptions_PasswordPolicy_MaxConsecutiveAlpha 235
#define DCTVS_AccountOptions_PasswordPolicy_MinUpper 236
#define DCTVS_AccountOptions_PasswordPolicy_MinLower 237
#define DCTVS_AccountOptions_PasswordPolicy_MinSpecial 238
#define DCTVS_AccountOptions_PasswordPolicy_MinDigit 239
#define IDS_DOMAIN_ADMIN_REGKEY         240
#define IDS_AgentResultFileFmt          241
#define IDS_ACCT_REPL_OPERATION_TEXT    242
#define IDS_FST_OPERATION_TEXT          243
#define IDS_EST_OPERATION_TEXT          244
#define IDS_DCT_Status_Completed        245
#define DCTVSFmt_Accounts_D             246
#define DCTVSFmt_Accounts_TargetName_D  247
#define DCTVSFmt_Accounts_Type_D        248
#define IDS_LGST_OPERATION_TEXT         249
#define IDS_URST_OPERATION_TEXT         250
#define DCTVSFmt_Servers_D              251
#define IDS_RESULT_SHARE_NAME           252
#define IDS_RESULT_SHARE_REMARK         253
#define IDS_CACHE_FILE_NAME             254
#define IDS_DCTVSFmt_MigrateServers_D   255
#define IDS_DCTVSFmt_MigrateServers_RenameTo_D 256
#define IDS_DCTVSFmt_MigrateServers_ChangeDomain_D 257
#define IDS_DCTVSFmt_MigrateServers_Reboot_D 258
#define IDS_DCTVSFmt_MigrateServers_RebootDelay_D 259
#define IDS_DCTVSFmt_Servers_RenameTo_D 260
#define IDS_DCTVSFmt_Servers_ChangeDomain_D 261
#define IDS_DCTVSFmt_Servers_Reboot_D   262
#define IDS_DCTVSFmt_Servers_RebootDelay_D 263
#define IDS_DCTVSFmt_Servers_MigrateOnly_D 264
#define DCTVS_Options_CreateTempCredentials 265
#define DCTVS_Options_OuPath            266
#define IDS_DCTVSFmt_PlugIn_RegisterFiles_D 267
#define IDS_YES                         268
#define IDS_DEBUG_SWITCH                269
#define IDS_HKLM_DomainAdmin_Key        270
#define IDS_AGENT_DIRECTORY             271
#define IDS_DCTVS_Fmt_PlugIn_D          272
#define DCTVS_Options                   273
#define DCTVS_Accounts                  274
#define IDS_Replace                     275
#define IDS_MSG_ComputerAccountNotWorkstation 276
#define IDS_DCT_Status_NotStarted       277
#define IDS_DCT_Status_InProgress       278
#define IDS_DCT_Status_Aborting         279
#define IDS_DCT_Status_Aborted          280
#define IDS_DCT_Status_Unknown          281
#define DCTVS_Stats                     282
#define IDS_DCT_NoStatsAvailable        283
#define IDS_DCTVSFmt_Job_D              284
#define IDS_DCTVSFmt_JobStatus_D        285
#define IDS_DCTVSFmt_Job_StartTime_D    286
#define IDS_DCTVSFmt_Job_EndTime_D      287
#define IDS_DCTVSFmt_PlugIn_D           288
#define IDS_DCTVSFmt_PlugIn_Interface_D 289
#define DCTVS_PlugIn_Interface_Count    290
#define DCTVS_CopiedAccount_SourceName  291
#define DCTVS_CopiedAccount_SourcePath  292
#define DCTVS_CopiedAccount_SourceRID   293
#define DCTVS_CopiedAccount_SourceSam   294
#define DCTVS_CopiedAccount_SourceProfile 295
#define DCTVS_CopiedAccount_Status      296
#define DCTVS_CopiedAccount_TargetName  297
#define DCTVS_CopiedAccount_TargetPath  298
#define DCTVS_CopiedAccount_TargetProfile 299
#define DCTVS_CopiedAccount_TargetRID   300
#define DCTVS_CopiedAccount_TargetSam   301
#define DCTVS_CopiedAccount_Type        302
#define IDS_Special                     303
#define IDS_All                         304
#define IDS_AccountMigration            305
#define IDS_WriteChanges_No             306
#define IDS_CopyUsers_Yes               307
#define IDS_CopyUsers_No                308
#define IDS_CopyGlobalGroups_Yes        309
#define IDS_CopyGlobalGroups_No         310
#define IDS_CopyLocalGroups_Yes         311
#define IDS_CopyLocalGroups_No          312
#define IDS_CopyComputers_Yes           313
#define IDS_CopyComputers_No            314
#define IDS_ReplaceExisting_Yes         315
#define IDS_DisableAll_Yes              316
#define IDS_DisableSpecial_Yes          317
#define IDS_DisableSourceAccounts_Yes   318
#define IDS_StrongPwd_All               319
#define IDS_StrongPwd_Special           320
#define IDS_PasswordFile                321
#define IDS_AddToGroup                  322
#define IDS_AddToGroupOnTargetDescription_S 323
#define IDS_AddToGroupOnSourceDescription_S 324
#define IDS_NotAllowedOnDomainController 325
#define IDS_CannotTrustSelf             326
#define IDS_CannotGetDCName             327
#define IDS_No                          328
#define IDS_ScanningExchangeDirectory   329
#define IDS_Examining                   331
#define IDS_Add                         332
#define IDS_Remove                      333
#define DCTVS_Options_DispatchCSV       334
#define DCTVS_SUB_ERROR                 335
#define IDS_UNKNOWN_TYPE                336
#define DCTVS_Options_SourceServer      337
#define DCTVS_Options_TargetServer      338
#define DCTVS_AccountOptions_Suffix     339
#define DCTVS_AccountOptions_CopyCompters 340
#define DCTVS_AccountOptions_CopyOUs    341
#define DCTVS_AccountOptions_CopyContainerContents 342
#define DB_ActionID                     343
#define DB_Time                         344
#define DB_SourceDomain                 345
#define DB_TargetDomain                 346
#define DB_SourceAdsPath                347
#define DB_TargetAdsPath                348
#define DB_SourceSamName                349
#define DB_TargetSamName                350
#define DB_Type                         351
#define DB_GUID                         352
#define DB_status                       353
#define DCTVS_CopiedAccount_GUID        354
#define IDS_CLSET_MEMBER_NOT_INCLUDED   355
#define IDS_CLSET_GROUP_NOT_INCLUDED    356
#define DCTVS_Options_AppendToLogs      357
#define DCTVS_Options_Undo              358
#define DCTVS_Options_GlobalOperationMask 359
#define DCTVS_Accounts_D_OperationMask  360
#define DCTVS_ActionID_D                361
#define DCTVS_ActionID_Servers_SD       362
#define DCTVS_ActionID_Servers_Status_SD 363
#define DCTVS_AREXT_NUMITEM             364
#define DCTVS_AREXTENSIONS_D            365
#define DCTVS_Security_TranslateMigratedObjects 366
#define DCTVS_AccountOptions_ExpireSourceAccounts 367
#define DCTVS_AccountOptions_SidHistoryCredentials_Domain 368
#define DCTVS_AccountOptions_SidHistoryCredentials_UserName 369
#define DCTVS_AccountOptions_SidHistoryCredentials_Password 370
#define DCTVS_AccountOptions_CopyMemberOf 371
#define DCTVS_DBManager                 372
#define DCTVS_Servers                   373
#define DCTVS_Reports_Generate          374
#define DCTVS_Reports_Directory         375
#define DCTVS_Reports_MigratedAccounts  376
#define DCTVS_Reports_MigratedComputers 377
#define DCTVS_Reports_ExpiredComputers  378
#define DCTVS_Reports_AccountReferences 379
#define DCTVS_Reports_NameConflicts     380
#define IDS_REGKEY_REPORTS              381
#define IDS_REGST_OPERATION_TEXT        382
#define DCTVS_Security_TranslateRegistry 383
#define DCTVS_AccountOptions_IncludeMigratedAccts 384
#define DCTVS_GatherInformation         385
#define DCTVS_Options_Prefix            386
#define DCTVS_Options_Suffix            387
#define DCTVS_AccountOptions_PasswordPolicy_MinLength 388
#define DCTVS_Options_SourceDomainDns   389
#define DCTVS_Options_TargetDomainDns   390
#define IDS_REPORT_MigratedAccounts     391
#define IDS_REPORT_MigratedComputers    392
#define IDS_REPORT_ExpiredComputers     393
#define IDS_REPORT_AccountReferences    394
#define IDS_REPORT_NameConflicts        395
#define IDS_TABLE_FIELD_SourceDomain    396
#define IDS_TABLE_FIELD_TargetDomain    397
#define IDS_TABLE_FIELD_Type            398
#define IDS_TABLE_FIELD_SourceAdsPath   399
#define IDS_TABLE_FIELD_TargetAdsPath   400
#define IDS_TABLE_FIELD_Status          401
#define IDS_TABLE_FIELD_Time            402
#define IDS_TABLE_FIELD_DomainName      403
#define IDS_TABLE_FIELD_CompName        404
#define IDS_TABLE_FIELD_Description     405
#define IDS_TABLE_FIELD_PwdAge          406
#define IDS_TABLE_FIELD_Account         407
#define IDS_TABLE_FIELD_Server          408
#define IDS_TABLE_FIELD_RefCount        409
#define IDS_TABLE_FIELD_RefType         410
#define IDS_TABLE_FIELD_SourceType      411
#define IDS_TABLE_FIELD_TargetType      412
#define IDS_TABLE_FIELD_SourceDesc      413
#define IDS_TABLE_FIELD_TargetDesc      414
#define IDS_TABLE_FIELD_SrcFullName     415
#define IDS_TABLE_FIELD_TgtFullName     416
#define IDS_NAMECONFLICTS               417
#define IDS_DISPATCHING                 418
#define DCTVS_Options_Wizard            419
#define DCTVS_Reports_MigratedAccounts_TimeGenerated 421
#define DCTVS_Reports_MigratedComputers_TimeGenerated 422
#define DCTVS_Reports_ExpiredComputers_TimeGenerated 423
#define DCTVS_Reports_AccountReferences_TimeGenerated 424
#define DCTVS_Reports_NameConflicts_TimeGenerated 425
#define DCTVS_Options_GuiOnlyRebootSaver 426
#define DCTVS_CopiedAccount_DoNotUpdatePassword 427
#define IDS_TEMP_FILE_1                 428
#define IDS_TEMP_FILE_2                 429
#define IDS_HKLM_WINDOWS_NT             430
#define IDS_CurrentVersion              431
#define IDS_CSDVersion                  432
#define IDS_HKLM_MICROSOFT              433
#define IDS_START_FAILED                434
#define IDS_UNSOUPPORTED_OS             435
#define IDS_AGENT_RUNNING               436
#define DCTVS_Options_DeleteJobFile     437
#define IDS_BUILDING_ACCOUNT_LIST       438
#define IDS_EXPANDING_MEMBERSHIP        439
#define IDS_EXPANDING_CONTAINERS        440
#define IDS_MERGING_EXPANDED_LISTS      441
#define IDS_CREATING_S                  442
#define IDS_MAPPING_PROPS_S             443
#define IDS_UPDATING_PROPS_S            444
#define IDS_EVENT_SOURCE                445
#define IDS_RUNNING_EXTS_S              446
#define IDS_TRANSLATE_ROAMING_PROFILE_S 447
#define IDS_ADDING_SIDHISTORY_S         448
#define IDS_UPDATING_GROUP_MEMBERSHIPS_S 449
#define IDS_EXPANDING_ADDING_SS         450
#define IDS_EXPANDING_IGNORING_SS       451
#define IDS_EXPANDING_GROUP_ADDING_SS   452
#define IDS_DELETING_S                  453
#define DCTVS_Options_IsIntraforest     454
#define IDS_EXTRACTING_COMP_PWD_AGE     455
#define IDS_Gathering_SvcAcct           456
#define DCTVS_Results_LogFile           457
#define IDS_REGKEY_PROFILE_EXTENSIONS   458
#define IDS_COM_DisTarget               459
#define IDS_COM_DisPid                  460
#define IDS_COM_DisPidVer               461
#define IDS_COM_AcctReplName            462
#define IDS_COM_AcctReplPid             463
#define IDS_COM_AcctReplPidVer          464
#define IDS_COM_ChgDomName              465
#define IDS_COM_ChgDomPidVer            466
#define IDS_COM_ChgDomPid               467
#define IDS_COM_ChkName                 468
#define IDS_COM_ChkPid                  469
#define IDS_COM_ChkPidVer               470
#define IDS_COM_PIInfoName              471
#define IDS_COM_PIInfoPid               472
#define IDS_COM_PIInfoPidVer            473
#define IDS_COM_CompAgeName             474
#define IDS_COM_CompAgePid              475
#define IDS_COM_CompAgePidVer           476
#define IDS_COM_RebootName              477
#define IDS_COM_RebootPid               478
#define IDS_COM_RebootPidVer            479
#define IDS_COM_RenameName              480
#define IDS_COM_RenamePid               481
#define IDS_COM_RenamePidVer            482
#define IDS_COM_SecTransName            483
#define IDS_COM_SecTransPid             484
#define IDS_COM_SecTransPidVer          485
#define IDS_COM_StatusObjName           486
#define IDS_COM_StatusObjPid            487
#define IDS_COM_StatusObjPidVer         488
#define IDS_COM_URName                  489
#define IDS_COM_URPid                   490
#define IDS_COM_URPidVer                491
#define DB_SourceRid                    492
#define DB_TargetRid                    493
#define IDS_DOM_LOC_GRP_COMMENT         494
#define DCTVS_CopiedAccount_Operations  495
#define IDS_Reporting                   496
#define IDS_ReportsMMCNode              497
#define IDS_ActiveDirectoryMigrationTool 503
#define DCTVS_Stats_Generic_Errors      504
#define DCTVS_Stats_Generic_Warnings    505
#define DCTVS_Stats_Generic_Examined    506
#define DCTVS_Stats_Generic_Created     507
#define DCTVS_Stats_Generic_Replaced    508
#define IDS_Unspecified_Failure         509
#define IDS_RegKeyRebootMessage         510
#define IDS_UNRESOLVED                  511
#define IDS_AGENT_INTEL_DIR             512
#define IDS_AGENT_ALPHA_DIR             513
#define IDS_STReference_File            514
#define IDS_STReference_Dir             515
#define IDS_STReference_Share           516
#define IDS_STReference_Mailbox         517
#define IDS_STReference_Container       518
#define IDS_STReference_Member          519
#define IDS_STReference_UserRight       520
#define IDS_STReference_RegKey          521
#define IDS_STReference_Printer         522
#define DCTVS_Options_SourceServerOverride 523
#define DCTVS_Options_TargetServerOverride 524
#define DCTVS_Options_AllowDuplicateUPNs 525
#define DCT_MSG_CHANGE_GROUP_TYPE_S     526
#define DCT_MSG_RECORD_REMOVE_MEMBER_S  527
#define DCT_MSG_RECORD_REMOVE_MEMBEROF_S 528
#define DCT_MSG_UPDATE_MEMBER_LIST_S    529
#define DCT_MSG_RESET_GROUP_MEMBERS_S   530
#define DCT_MSG_RESET_MEMBERSHIP_S      531
#define DCT_MSG_MOVING_S                532
#define DCT_MSG_RECORD_REMOVE_MEMBEROF_SS 533
#define DCT_MSG_RESET_OBJECT_MEMBERSHIP_SS 534
#define DCT_MSG_RECORD_REMOVE_MEMBER_SS 535
#define DCT_MSG_RESET_GROUP_MEMBERS_SS  536
#define IDS_HiddenShare                 537
#define IDS_AgentDirectoryName          538
#define IDS_HiddenShareRemark           539
#define DCTVS_Security_AlternateCacheFile 540
#define IDS_RenamedRecyclerSuffix       541
#define DCTVS_Security                  542
#define DCTVS_CopiedAccount_ExpDate     543
#define DCTVS_CopiedAccount_UserFlags   544
#define DB_ExpDate                      545
#define DB_UserFlags                    546
#define IDS_TRUST_DIRECTION_DISABLED    547
#define IDS_TRUST_DIRECTION_INBOUND     548
#define IDS_TRUST_DIRECTION_OUTBOUND    549
#define IDS_TRUST_DIRECTION_BIDIRECTIONAL 550
#define IDS_TRUST_TYPE_DOWNLEVEL        551
#define IDS_TRUST_TYPE_CHILD            552
#define IDS_EVENTVW_MSG_MONJOBSTAT      553
#define IDS_EVENTVW_MSG_MONERROR        554
#define IDS_EVENTVW_MSG_MONEXIT         555
#define IDS_EVENTVW_MSG_STARTPLUGREG    556
#define IDS_EVENTVW_MSG_FILEREG         557
#define IDS_EVENTVW_MSG_PLUGREGDONE     558
#define IDS_EVENTVW_MSG_JOBDEL          559
#define IDS_EVENTVW_MSG_SETFLAG         560
#define IDS_EVENTVW_MSG_NOSETFLAG       561
#define IDS_EVENTVW_MSG_REMOVEAGENT     562
#define IDS_EVENTVW_MSG_UNREGFILES      563
#define IDS_EVENTVW_MSG_FILEDEL         564
#define IDS_EVENTVW_MSG_REMOVESVC       565
#define IDS_EVENTVW_MSG_NOREMOVEAGENT   566
#define IDS_EVENTVW_MSG_STOPLISTEN      567
#define IDS_EVENTVW_MSG_AGENTSVCINSTALLED 568
#define IDS_EVENTVW_MSG_AGENTSVCNOTINSTALLED 569
#define IDS_EVENTVW_MSG_OSVERSION       570
#define IDS_EVENTVW_MSG_REGISTERED      571
#define IDS_EVENTVW_MSG_UNREGISTERED    572
#define IDS_EVENTVW_MSG_INITOLE         573
#define IDS_EVENTVW_MSG_REGCOMPNT       574
#define IDS_EVENTVW_MSG_CREATEAGT       575
#define IDS_EVENTVW_MSG_INITRPC         576
#define IDS_EVENTVW_MSG_LISTENQ         577
#define IDS_EVENTVW_MSG_EXITENTRYP      578
#define IDS_EVENTVW_MSG_AGTEXITQ        579
#define IDS_EVENTVW_MSG_AGTEXITS        580
#define IDS_STOptions_Start             581
#define IDS_STOptions_WriteChng         582
#define IDS_STOptions_Files             583
#define IDS_STOptions_Shares            584
#define IDS_STOptions_LocalGroup        585
#define IDS_STOptions_URights           586
#define IDS_STOptions_Profiles          587
#define IDS_STOptions_RBin              588
#define IDS_STOptions_LogName           589
#define IDS_STOptions_AddMode           590
#define IDS_STOptions_RemoveMode        591
#define IDS_STOptions_ReplaceMode       592

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\tsync.hpp ===
//#pragma title( "TSync.hpp - Common synchronization classes header file" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TSync.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-08
Description -  Common synchronization classes header file
               This includes TCriticalSection, and TNamedSemaphore
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TSync_hpp
#define  MCSINC_TSync_hpp

#ifndef _INC_TIME
#include <time.h>
#endif

class TCriticalSection
{
   CRITICAL_SECTION          cs;
public:
                        TCriticalSection() { InitializeCriticalSection(&cs); }
                        ~TCriticalSection() { DeleteCriticalSection(&cs); }
   void                 Enter() { EnterCriticalSection(&cs); }
   void                 Leave() { LeaveCriticalSection(&cs); }
};

class TSynchObject
{
public:
   HANDLE                    handle;
   TSynchObject()
   { handle = NULL; }
   ~TSynchObject()
   { Close(); }
   void Close()
   { if ( handle != NULL ) { CloseHandle( handle ); handle = NULL; } }

   DWORD                WaitSingle(DWORD msec) const { return WaitForSingleObject(handle, msec); }
   DWORD                WaitSingle()           const { return WaitForSingleObject(handle, INFINITE); }
   HANDLE               Handle() { return handle; }
};

///////////////////////////////////////////////////////////////////////////////
// Named semaphores
///////////////////////////////////////////////////////////////////////////////

class TSemaphoreNamed : public TSynchObject
{
public:
   TSemaphoreNamed() {};
   ~TSemaphoreNamed() {};
   DWORD Create(                           // ret-OS return code
      TCHAR          const * sNameT       ,// in -semaphore name
      DWORD                  nInitial     ,// in -initial count
      DWORD                  nMaximum     ,// in -maximum count
      BOOL                 * pbExisted=NULL // out-TRUE=previously existed
   );
   DWORD Open(                             // ret-OS return code
      TCHAR          const * sNameT        // in -semaphore name
   );
   DWORD Release(                          // ret-OS return code
      long                   nRelease=1    // in -number to release
   );
};


#endif  // MCSINC_TSync_hpp

// TSync.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SetDtct.rc
//
#define IDS_PROJNAME                    100
#define IDS_SETDETECTOR_DESC            101
#define IDR_SetDetector                 102
#define IDS_MEMBER_NOT_INCLUDED         102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2DEA8C21_2B25_11D3_8AE5_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__2DEA8C21_2B25_11D3_8AE5_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2DEA8C21_2B25_11D3_8AE5_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\mcsdebug.h ===
//---------------------------------------------------------------------------
// MCSDebug.h 
//
// The debug macros and support classes are declared in 
// this file, they are:
//
// MCSASSERT & MCSASSERTSZ:
// These macros are only valid for a debug build. The 
// usage of these macros is outlined in the MCS Coding 
// Standards document. To support automated testing these
// macros look to the environment variable MCS_TEST, if
// this variable is defined a McsDebugException is generated.
//
// MCSEXCEPTION & MCSEXCEPTIONSZ
// These macros are valid for debug and release builds.  
// In the debug mode these macros are the same as 
// MCSASSERT(SZ).  In the release mode they throw an 
// exception McsException The usage of these macros is 
// outlined in the MCS Coding Standards document.
//
// MCSVERIFY & MCSVERIFYSZ
// These macros are valid for debug and release builds.  
// In the debug mode these macros are the same as 
// MCSASSERT(SZ).  In the release mode they log the 
// message using McsVerifyLog class.  The usage of these 
// macros is outlined in the MCS Coding Standards document.  
//
// MCSASSERTVALID
// This macro is based on MCSASSERT(SZ) macros, and is
// available only in debug mode.  The usage of this macro
// is outlined in the MCS Coding Standards document.  
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSEXCEPTIONVALID
// This macro is based on MCSEXCEPTION(SZ) macros, and is
// available in debug and release modes.  The usage of this 
// macro is outlined in the MCS Coding Standards document.  
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSVERIFYVALID
// This macro is based on MCSVERIFY(SZ) macros, and is
// available debug and release modes.  The usage of this 
// macro is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// McsVerifyLog:
// The McsVerifyLog class is used by MCSVERIFY(SZ) macros
// to log verify messages.  This class uses the McsDebugLog
// class to log messages.  The user can change the ostream
// object to log messages else where.  
// The output log file is created in the directory 
// defined by MCS_LOG environment variable, or in the 
// TEMP directory, or in the current directory.  The name 
// of the output log file is <module name>.err.  
//
// McsTestLog:
// The McsTestLog class is used by MCSASSERT(SZ) macros
// to log messages in test mode. This class currently
// generates an exception.  This may have to be modified
// to support any new functionality required for unit
// testing.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebug_h
#define MCSINC_McsDebug_h

#ifdef __cplusplus		/* C++ */
#ifdef WIN16_VERSION	/* WIN16_VERSION */

#include <assert.h>

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#define MCSASSERT(expr) assert(expr)

#define MCSASSERTSZ(expr,msg) assert(expr)

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#define MCSEXCEPTION(expr) MCSASSERT(expr)

#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#define MCSVERIFY(expr) MCSASSERT(expr)

#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

#else /* WIN16_VERSION */

#include <crtdbg.h>
#include "McsDbgU.h"

// ------------
// McsException
// ------------
class McsDebugException {
   public:
      McsDebugException ();
      McsDebugException (const McsDebugException &sourceIn);
      McsDebugException (const char *messageIn,
                         const char *fileNameIn,
                         int        lineNumIn);
      ~McsDebugException();
      McsDebugException& operator= (const McsDebugException &rhsIn);

      const char *getMessage (void) const;
      const char *getFileName (void) const;
      getLineNum (void) const;

   private:
      char *m_message;
      char *m_fileName;
      int  m_lineNum;
};

// ------------
// McsVerifyLog
// ------------
class McsVerifyLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsVerifyLog* getLog (void);
      ~McsVerifyLog (void);
      void changeLog (ostream *outStreamIn);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsVerifyLog (void);
      const char* getLogFileName (void);
      void formatMsg (const char *messageIn,
                      const char *fileNameIn,
                      int        lineNumIn);

      // Do not allow dflt ctor, copy ctor & operator=.
      McsVerifyLog (const McsVerifyLog&);
      McsVerifyLog& operator= (const McsVerifyLog&);

   private:
      enum { MSG_BUF_LEN = 2048 };
      char							      m_msgBuf[MSG_BUF_LEN];
	   McsDebugUtil::McsDebugCritSec m_logSec;
	   McsDebugUtil::McsDebugLog     m_log;
      fstream						      *m_outLog;
};

// ----------
// McsTestLog
// ----------
class McsTestLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsTestLog* getLog (void);
      ~McsTestLog (void);
      bool isTestMode (void);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsTestLog (void);

      // Do not allow copy ctor & operator=.
      McsTestLog (const McsTestLog&);
      McsTestLog& operator= (const McsTestLog&);

   private:
      bool							m_isTested;
      bool							m_isTestMode_;
	  McsDebugUtil::McsDebugCritSec m_testSec;
};

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#ifdef  _DEBUG
#define MCSASSERT(expr) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (#expr, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else  // _DEBUG 
#define MCSASSERT(expr) ((void)0)
#endif // _DEBUG

#ifdef  _DEBUG
#define MCSASSERTSZ(expr,msg) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (msg, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, \
                  __LINE__, NULL, msg)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else // _DEBUG 
#define MCSASSERTSZ(expr,msg) ((void)0)
#endif // _DEBUG

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#ifdef _DEBUG
#define MCSEXCEPTION(expr) MCSASSERT(expr)
#else
#define MCSEXCEPTION(expr) \
   do { \
      if (!(expr)) { \
         throw new McsDebugException (#expr, __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSEXCEPTIONSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         throw new McsDebugException ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#ifdef _DEBUG
#define MCSVERIFY(expr) MCSASSERT(expr)
#else
#define MCSVERIFY(expr) \
   do { \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log (#expr, __FILE__, __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSVERIFYSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0) 

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// ---------------
// --- INLINES ---
// ---------------

// -----------------
// McsDebugException 
// -----------------
inline McsDebugException::McsDebugException () 
: m_message (0), m_fileName (0), m_lineNum (0) 
{ /* EMPTY */ }
   
inline McsDebugException::~McsDebugException() { 
   delete [] m_message; 
   delete [] m_fileName; 
}

inline const char *McsDebugException::getMessage 
               (void) const {
   return m_message;
}

inline const char *McsDebugException::getFileName 
               (void) const {
   return m_fileName;
}

inline int McsDebugException::getLineNum 
               (void) const {
   return m_lineNum;
}

// ------------
// McsVerifyLog
// ------------
inline McsVerifyLog::McsVerifyLog (void) 
{ /* EMPTY */ }

inline McsVerifyLog::~McsVerifyLog (void) {
   delete m_outLog;
}

// ----------
// McsTestLog
// ----------
inline McsTestLog::McsTestLog (void) 
: m_isTested (FALSE), m_isTestMode_ (FALSE) 
{ /* EMPTY */ }

inline McsTestLog::~McsTestLog (void) { /* EMPTY */ }


inline void McsTestLog::log (const char *messageIn,
                             const char *fileNameIn,
                             int        lineNumIn) {
   throw new McsDebugException (messageIn, fileNameIn,
               lineNumIn);
}

#endif /* WIN16_VERSION */
#endif /* C++ */
#endif /* MCSINC_McsDebug_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\setdtct.cpp ===
/*---------------------------------------------------------------------------
  File: McsClosedSet.cpp

  Comments: DLL exports for closed set detector COM object. This file is mostly 
  generated by the ATL wizard.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 07/01/99 

 ---------------------------------------------------------------------------
*/// McsClosedSet.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for McsClosedSet.idl by adding the following 
//      files to the Outputs.
//          McsClosedSet_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsClosedSetps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ClSet.h"
#include "dlldatax.h"

#include "ClSet_i.c"
#include "Detector.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif


#include "ErrDct.hpp"
#include "ResStr.h"

TErrorDct               err;
TError                & errCommon = err;
StringLoader            gString;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SetDetector, CSetDetector)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSCLOSEDSETLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\tnode.hpp ===
//#pragma title( "TNode.hpp - List/Tree base classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TNode.hpp
System      -  Common
Author      -  Tom Bernhardt
Created     -  1989-11-19
Description -  List/Tree base classes.
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TNode_hpp
#define  MCSINC_TNode_hpp

#include "common.hpp"

#define MCS_ListError_InvalidHead       0x00000001
#define MCS_ListError_InvalidTail       0x00000002
#define MCS_ListError_InvalidCount      0x00000004
#define MCS_ListError_InvalidPtr        0x00000008
#define MCS_ListError_Exception         0x00000010

#define TNodeCompare(name)                                                     \
   int                                    /* ret-0(v1==v2) >0(v1>v2) <0(v1<v2)*/\
      name(                                                                    \
         TNode       const * v1          ,/* in -value1 to compare           */\
         TNode       const * v2           /* in -value2 to compare           */\
      )

#define TNodeCompareValue(name)                                               \
   int                                    /* ret-0(v1==v2) >0(v1>v2) <0(v1<v2)*/\
      name(                                                                   \
         TNode       const * tnode       ,/* in -value1 to compare           */\
         void        const * value        /* in -value2 to compare           */\
      )

#define DeleteAllListItems(datatype)                                          \
   TNodeListEnum             tenum;        /* enumerate values             */ \
   datatype                * tnode;        /* this node                    */ \
   datatype                * tnext;        /* next node                    */ \
   for ( tnode = (datatype *) tenum.OpenFirst( this );                        \
         tnode;                                                               \
         tnode = tnext )                                                      \
   {                                                                          \
      tnext = (datatype *) tenum.Next();                                      \
      Remove( tnode );                                                        \
      delete tnode;                                                           \
   }                                                                          \
   tenum.Close()

// TNode is a a base class for any derived object to be put into one of the
// TNodeList classes.
class TNode
{
   friend class TNodeList;
   friend class TNodeListSortable;
   friend class TNodeListEnum;
   friend class TNodeListOrdEnum;
   friend class TNodeTreeEnum;
   TNode                   * left;
   TNode                   * right;
public:
   TNode                * Next() const { MCSASSERT(this); return right; }
// virtual ~TNode() {}
};


class TNodeList
{
   friend class TNodeListEnum;
   friend class TNodeListOrdEnum;
   friend class TNodeTreeEnum;
protected:
   TNode                   * head,
                           * tail;
   DWORD                     count;
public:
                        TNodeList() { head = tail = NULL; count = 0; };
                        ~TNodeList();
   void                 InsertTop( TNode * eIns );
   void                 InsertBottom( TNode * eIns );
   void                 InsertAfter( TNode * eIns, TNode * eAft );
   void                 InsertBefore( TNode * eIns, TNode * eBef );
   void                 Remove(TNode const * t);
// void                 Delete(TNode * t) { Remove(t); delete t; };
   void                 Reverse();
   TNode *              Find(TNodeCompareValue((* Compare)), void const * findval) const;
   long                 Pos(TNode const * t) const
                        {
                           long n;
                           TNode * c;
                           MCSASSERT(this);
                           for (c=head, n=0; c!=t; c=c->right,n++);
                           return c ? n : -1;
                        }
   TNode              * Head() const { MCSASSERT(this); return head; }
   DWORD                Count() const { MCSASSERT (this); return count; }

protected:
   DWORD                Validate( TNode  ** pErrorNode );
};

/*
   A dynamically sortable collection of TNode entries.  The TNodes are arranged
   in either of two forms: a sorted linked linear list or a binary tree.  The
   current data data structure (form) is stored in the listType member.

   The form of the list may be easily changed from binary tree to sorted list or
   vice versa.  The following member functions support these transformations:
      ToSorted       Converts the tree form into a sorted linear list form without
                     need for comparisons; the order is preserved.
      SortedToTree   Converts the sorted linear list form into a perfectly
                     balanced binary tree without comparisons; the order is preserved.
      UnsortedToTree Converts the sorted linear list form into a binary tree
                     that is not necesarily balanced.  It uses the PCompare function
                     to form the order of the tree.  Thus if the list order closely
                     matches the PCompare directed order, the resulting tree will be
                     grossly unbalanced.  This has a bearing on the performance and
                     memory requirements of the ToSorted function which is recursive.
                     So be careful, especially with large lists.
      Sort           This resorts either a tree or list form according to the argument
                     pCompare function pointer provided.  Note the above admonition.

   In either form, exposed are also Insert and Remove member functions.  The functions
   are wrappers for TreeInsert and SortedInsert function depending upon the current
   list type.
*/
enum TNodeListType { TNodeTypeError, TNodeTypeUnsorted, TNodeTypeLinear, TNodeTypeTree };

class TNodeListSortable : public TNodeList
{
private:
   TNode                   * lastInsert;
   static TNode *                          // ret-head of sorted list
                        TreeToSortedList(
         TNode                * top       ,// i/o-top of [sub]tree to squash
         TNode               ** newhead   ,// out-leftmost branch from tree
         TNode               ** newtail    // out-rightmost branch from tree
      );
   static TNode *                          // ret-middle of list (head of Btree)
                        ListSortedToTree(
         TNode                * top        // i/o-top of [sub]list to tree-ify
      );

   BOOL                 CountTree( TNode * pCurrentTop, DWORD * pCount);

protected:
   TNodeListType        listType;
                        TNodeCompare((* PCompare));
public:
                        TNodeListSortable(TNodeCompare((* pCompare)) = NULL, TNodeListType t = TNodeTypeLinear)
                           { lastInsert = NULL; listType = t; PCompare = pCompare; };
                                                      ~TNodeListSortable() { if ( IsTree() ) ToSorted(); }

   void                 CompareSet(TNodeCompare((* pCompare))) { PCompare = pCompare; }
   void                 TypeSetTree()   { listType = TNodeTypeTree; }
   void                 TypeSetSorted() { listType = TNodeTypeLinear; }

   void                 TreeInsert(TNode * item, short * depth);
   TNode **             TreeFindInsert(TNode const * item, short * depth);
   BOOL                 TreeInsertIfNew(TNode * item, short * depth)
   {
      TNode ** r=TreeFindInsert(item,depth);
      if (*r) return FALSE;
      *r=item;
      item->left = item->right = NULL;
      count++;
      return TRUE;
   }
   void                 TreeInsert(TNode * item) { short discard; TreeInsert(item, &discard); };
   void                 TreeRemove(TNode * item);
   TNode *              TreeFind(TNodeCompareValue((* pCompare)), void const * findval) const;

   void                 SortedInsert(TNode * t);
   BOOL                 SortedInsertIfNew(TNode * t);
   TNode *              SortedFindInsertBefore(TNode * item, BOOL * exists);

   void                 Insert(TNode * t) { if (IsTree()) TreeInsert(t); else SortedInsert(t); }
   BOOL                 InsertIfNew(TNode * t) { short depth; if (IsTree()) return TreeInsertIfNew(t,&depth);
                                                              else return SortedInsertIfNew(t); }
   virtual void         Remove(TNode * t) { if (t==lastInsert) lastInsert = NULL;
                                            if (IsTree()) TreeRemove(t);
                                            else TNodeList::Remove(t); };
// void                 Delete(TNode * t) { Remove(t); delete t; };
   TNode *              Find(TNodeCompareValue((* pCompare)), void const * findval) const
                           { if (IsTree()) return TreeFind(pCompare,findval); return TNodeList::Find(pCompare,findval); }

   void                 SortedToTree()
   {
      MCSASSERTSZ( !IsTree(), "TNodeListSortable::SortedToTree - list is already a tree" );
      if ( !IsTree() )
      {
         head = ListSortedToTree( head );
         tail = NULL;
         listType = TNodeTypeTree;
      }
   }
   TNode *              UnsortedToTree();
   void                 ToSorted()
   {
      MCSASSERTSZ( IsTree(), "TNodeListSortable::ToSorted - list is not a tree" );
      if ( IsTree() )
      {
         MCSASSERT( ValidateTree() );
         if ( head )
            TreeToSortedList( head, &head, &tail );
         listType = TNodeTypeLinear;
      }
   }
   void                 Balance()
   {
      MCSASSERTSZ( IsTree(), "TNodeListSortable::Balance - list is not a tree" );
      if ( IsTree() )
      {
         ToSorted();
         SortedToTree();
      }
   }
   void                 Sort(TNodeCompare((* pCompare))) { TNodeListType lt = listType;
                                          if (lt == TNodeTypeTree) ToSorted();
                                          CompareSet(pCompare);
                                          UnsortedToTree();
                                          if (lt != TNodeTypeTree) ToSorted(); }
   void                 SortedToScrambledTree();
   BOOL                 IsTree() const { return listType == TNodeTypeTree; };

   BOOL                 ValidateTree( );
   DWORD                ValidateList( TNode  ** pErrorNode = NULL)
                        {
                           MCSASSERT(listType != TNodeTypeTree);
                           return Validate(pErrorNode);
                        }
};


/*
   TNodeListEnum is a 'friend' of TNode used to enumerate/iterate through
   TNodeList in linear list form.  It is an error to give it a TNodeList in
   tree form.
*/
class TNodeListEnum
{
protected:
   TNodeList         const * list;   // list for which enums are carried out
   TNode                   * curr;   // last node processed by enum functions
public:
                        TNodeListEnum() { list = NULL; curr = NULL; };
                        TNodeListEnum(TNodeList const * tlist) { Open(tlist); }
                        ~TNodeListEnum() { };

   void                 Open(TNodeList const * tlist) { list = tlist; Top(); };
   TNode              * OpenFirst(TNodeList const * tlist) { list = tlist; return First(); }
   TNode              * First() { return curr = list->head; };
   TNode              * Next() { return curr = (curr ? curr->right : list->head); }
   TNode              * Prev() { return curr = (curr ? curr->left  : list->tail); }
   TNode              * Last() { return curr = list->tail; };
   TNode *              Get() { return curr; }
   TNode *              Get(long n) { TNode * c; Top(); while ( n-->=0 && (c=Next()) ); return c; }
   void                 Close() { curr = NULL; }
   void                 Top() { curr = NULL; };
};

// provides optimized direct accessibility by ordinal to TNodeList at some
// expense to sequential traversal performance
class TNodeListOrdEnum : public TNodeListEnum
{
private:
   long                 nCurr;
public:
                        TNodeListOrdEnum() : TNodeListEnum() { nCurr = -1; };
                        TNodeListOrdEnum(TNodeList const * tlist) { Open(tlist); };

   void                 Open(TNodeList const * tlist) { TNodeListEnum::Open(tlist); nCurr = -1; };
   TNode              * OpenFirst(TNodeList const * tlist) { Open(tlist); return First(); }
   TNode              * First() { nCurr = list->head ? 0 : -1; return TNodeListEnum::First(); };
   TNode              * Next() { TNode * t = TNodeListEnum::Next(); if (curr) nCurr++; else nCurr=-1; return t; }
   TNode              * Prev() { TNode * t = TNodeListEnum::Prev(); if (curr) if (nCurr>0) nCurr--; else nCurr=list->Count()-1; else nCurr=-1; return t; }
   void                 Close() { nCurr=-1; TNodeListEnum::Close(); }
   void                 Top() { nCurr=-1; TNodeListEnum::Top(); };

   long                 Pos() const { return nCurr; };
   long                 Pos(TNode const * t) { long n; TNode * c;
                                               for (c=list->head, n=0; c!=t; c=c->right,n++);
                                               if (c) nCurr=n; else nCurr=-1; curr=c; return nCurr; }
   TNode *              Get(long n);
};


/*
   TNodeTreeEnum enumerates a TNodeListSortable that is in tree form.  It is an error
   to give it a TNodeListSortable that is in linear list form.
*/
enum TNodeTreeStackEntryState {Snone, Sleft, Sused, Sright, SComplete};
struct TNodeTreeStackEntry
{
   TNode                * save;
   TNodeTreeStackEntryState state;
};

const TREE_STACKSIZE = 200;            // default maximum recursion depth
class TNodeTreeEnum
{
private:
   TNodeTreeStackEntry     * stackBase,
                           * stackPos;
   int                       stackSize;
   void                 Push(TNode * item) { (++stackPos)->save = item; stackPos->state = Snone; };
   BOOL                 Pop() { return --stackPos >= stackBase; };
   void                 StackAlloc(int stacksize)
                           { stackSize = stacksize;
                             stackBase = new TNodeTreeStackEntry[stacksize]; };
protected:
   TNode                   * top;    // tree top for which enums are carried out
   TNode                   * curr;   // next node processed by enum functions
public:
                        TNodeTreeEnum(int stacksize = TREE_STACKSIZE) { top = NULL; StackAlloc(stacksize); };
                        TNodeTreeEnum(TNodeListSortable const * tlist, int stacksize = TREE_STACKSIZE) { StackAlloc(stacksize); Open(tlist); };
                        ~TNodeTreeEnum() { Close(); delete [] stackBase; };

   void                 Open(TNodeListSortable const * tlist)
                           {
                              top = tlist->head;
                              stackPos = stackBase;
                              stackPos->save = NULL;
                              stackPos->state = SComplete;
                              if ( top )
                                 Push(top);
                           }

   TNode              * First();
   TNode              * FirstAfter(TNodeCompareValue((* Compare) ), void const * findVal);
   TNode              * OpenFirst(TNodeListSortable const * tlist) {  Open(tlist);  return Next(); }

   TNode              * Next();
   TNode              * StackTop() { return stackPos->save; }
   void                 Close() { stackPos = stackBase; }
};

#endif  // MCSINC_TNode_hpp

// TNode.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\tnode.cpp ===
//#pragma title( "TNode.cpp - List/Tree base classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      - TNode.cpp
System      - Common
Author      - Tom Bernhardt
Created     - 1989-11-19
Description - List/Tree base classes.
              TNode is a base class to define a collection element.  It
              contains a left and right pointer to another TNode item and
              these may be organized as a double-linked linear list or
              binary tree in the collection classes that use TNode items.

              Central to its utility are member functions to convert between
              binary tree, sorted 2-way linear linked lists, and unsorted 2-way
              linked linear lists.

 Collection and enum classes
   TNodeList         A simple collection of TNode elements.
   TNodeListSortable A TNodeList that is sortable by one or more compare functions.


 Conversion member functions for TNodeListSortable:
   The form of the list may be easily changed from binary tree to sorted list or
   vice versa.  The following member functions support these transformations:
      ToSorted       Converts the tree form into a sorted linear list form without
                     need for comparisons; the order is preserved.
      SortedToTree   Converts the sorted linear list form into a perfectly
                     balanced binary tree without comparisons; the order is preserved.
      UnsortedToTree Converts the sorted linear list form into a binary tree
                     that is not necesarily balanced.  It uses the PCompare function
                     to form the order of the tree.  Thus if the list order closely
                     matches the PCompare directed order, the resulting tree will be
                     grossly unbalanced.  This has a bearing on the performance and
                     memory requirements of the ToSorted function which is recursive.
                     So be careful, especially with large lists.
      Sort           This resorts either a tree or list form according to the argument
                     pCompare function pointer provided.  Note the above admonition.

   In either form, exposed are also Insert and Remove member functions.  The functions
   are wrappers for TreeInsert and SortedInsert function depending upon the current
   list type.
Updates     -
1995-05-01 TPB Converted to C++ classes.
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include "TNode.hpp"
#include "common.hpp"


#pragma page()
//------------------------------------------------------------------------------
// Warning: Must not pass top == NULL
//------------------------------------------------------------------------------
TNode *                                    // ret-head of sorted list
   TNodeListSortable::TreeToSortedList(
      TNode                * top          ,// i/o-top of [sub]tree to squash
      TNode               ** newhead      ,// out-leftmost branch from tree
      TNode               ** newtail       // out-rightmost branch from tree
   )
{
   TNode                   * temp;         // temporary pointer placeholder

   if ( top->left == NULL )
      *newhead = top;                      // this is leftmost of parent node
   else
   {
      TreeToSortedList(top->left, newhead, &temp);
      top->left = temp;                    // left = tail of sub-list
      top->left->right = top;
   }
   if ( top->right == NULL )
      *newtail = top;                      // tree is rightmost of parent node
   else
   {
      TreeToSortedList(top->right, &temp, newtail);
      top->right = temp;                   // right = head of sub-list
      top->right->left = top;
   }
   return *newhead;
}


//------------------------------------------------------------------------------
// converts sorted 2-linked list into balanced binary tree
//------------------------------------------------------------------------------
TNode *                                    // ret-middle of list (head of Btree)
   TNodeListSortable::ListSortedToTree(
      TNode                * top           // i/o-top of [sub]list to tree-ify
   )
{
   TNode                   * mid = top    ,// middle of list
                           * curr;
   int                       odd = 1;

   if ( top == NULL )
      return NULL;
   for ( curr = top;  curr;  curr = curr->right ) // find list middle
   {
      if ( odd ^= 1 )
         mid = mid->right;
   }
   if ( mid->left )                        // split list around mid point
   {
      mid->left->right = NULL;             // right terminate new sublist
      mid->left = ListSortedToTree(top);   // recursive call to set left side
   }
   if ( mid->right )
   {
      mid->right->left = NULL;             // left terminate new sublist
      mid->right = ListSortedToTree(mid->right);// recursive call to set right side
   }
   return mid;
}


#pragma page()
TNode *                                    // ret-new head of tree
   TNodeListSortable::UnsortedToTree()
{
   TNode                   * treehead = NULL,
                           * tree,
                           * curr,
                           * next;

   MCSASSERTSZ( !IsTree(), "TNodeListSortable::UnsortedToTree - list is already a tree" );

   if ( !IsTree() )
   {
      for ( curr = head;  curr;  curr = next )// insert each node into BinTree
      {
         next = curr->right;                  // save right pointer
         curr->right = curr->left = NULL;     // break chains for insertion node
         if ( treehead == NULL )
            treehead = curr;                  // first node become BinTree head
         else
         {
            for ( tree = treehead;  ; )       // iterative BinTree insert algorithm
            {
               if ( PCompare(curr, tree) <=0 )// if belongs left of current node
                  if ( tree->left == NULL )   //    if left tree empty
                  {
                     tree->left = curr;       //       insert here
                     break;                   //       and process right node
                  }
                  else                        //    else
                     tree = tree->left;       //       go down left side 1 level
               else                           // must be right side
               {
                  if ( tree->right == NULL )
                  {
                     tree->right = curr;
                     break;
                  }
                  else
                     tree = tree->right;
               }
            }
         }
      }
      TypeSetTree();
   }
   return treehead;
}

#pragma page()

//------------------------------------------------------------------------------
// comparison function used for scrambling a sorted linked list
//------------------------------------------------------------------------------
TNodeCompare(ScrambledCompare)
{
   return (rand() - RAND_MAX/2);
}

//------------------------------------------------------------------------------
// converts sorted 2-linked list into a scrambled random binary tree
//------------------------------------------------------------------------------
void
   TNodeListSortable::SortedToScrambledTree()
{
   MCSASSERTSZ( !IsTree(), "TNodeListSortable::SortedToScrambledTree - list is already a tree" );

   if ( !IsTree() )
   {
      TNodeCompare((*pOldCompare));
      pOldCompare = PCompare;
      CompareSet(ScrambledCompare);
      UnsortedToTree();
      CompareSet(pOldCompare);
   }
}

#pragma page()
TNodeList::~TNodeList()
{

// _ASSERTE( (count == 0) && (head == NULL) );

   if ( (count == 0) && (head == NULL) )
      ;
   else
   {
      //printf( "\aTNodeList destructor failure - list is not empty!\a\n" );
   }
}

void
   TNodeList::InsertTop(
      TNode                * eIns          // i/o-element to be inserted
   )
{
   MCSVERIFY(this);
   MCSVERIFY(eIns);

   eIns->right = head;
   eIns->left  = NULL;
   if ( head )
      head->left = eIns;
   else
      tail = eIns;
   head = eIns;
   count++;
   return;
}

void
   TNodeList::InsertBottom(
      TNode                * eIns          // i/o-element to be inserted
   )
{
   MCSVERIFY(this);
   MCSVERIFY(eIns);

   eIns->right = NULL;
   eIns->left  = tail;
   if ( tail )
      tail->right = eIns;
   else
      head = eIns;
   tail = eIns;
   count++;
   return;
}

void
   TNodeList::InsertAfter(
      TNode                * eIns         ,// i/o-element to be inserted
      TNode                * eAft          // i/o-element insert point
   )
{
   TNode                   * eFwd;         // element after inserted element

   MCSVERIFY(this);
   MCSVERIFY(eIns);

   if ( !eAft )
      InsertTop( eIns );
   else
   {
      eFwd = eAft->right;
      eIns->right = eFwd;
      eIns->left  = eAft;
      if ( eFwd )
         eFwd->left  = eIns;
      else
         tail = eIns;
      eAft->right = eIns;
      count++;
   }
}

void
   TNodeList::InsertBefore(
      TNode                * eIns         ,// i/o-element to be inserted
      TNode                * eBef          // i/o-element insert point
   )
{
   TNode                   * eBwd;         // element before inserted element

   MCSVERIFY(this);
   MCSVERIFY(eIns);

   if ( !eBef )
      InsertBottom( eIns );
   else
   {
      eBwd = eBef->left;
      eIns->right = eBef;
      eIns->left  = eBwd;
      if ( eBwd )
         eBwd->right = eIns;
      else
         head = eIns;
      eBef->left = eIns;
      count++;
   }
   return;
}

void
   TNodeList::Remove(
      TNode          const * t             // i/o-new node to remove from list but not delete
   )
{
   MCSVERIFY(this);
   MCSVERIFY(t);

   if ( t->left )
      t->left->right = t->right;
   else
      head = t->right;

   if ( t->right )
      t->right->left = t->left;
   else
      tail = t->left;
   count--;

   //Remove links to the list from t. We cant do this because
   // t is a const *
   //t->left = t->right = NULL;
}


void
   TNodeList::Reverse()
{
   TNode                   * node;
   TNode                   * swap;

   MCSVERIFY(this);

   for ( node = head;  node;  node = node->left )
   {
       swap        = node->left;
       node->left  = node->right;
       node->right = swap;
   }
   swap = head;
   head = tail;
   tail = swap;
}


TNode *
   TNodeList::Find(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void const           * findval
   ) const
{
   TNode                   * curr;

   MCSASSERT(this);

   for ( curr = head;  curr;  curr = curr->right )
   {
      if ( !Compare( curr, findval ) )
         break;
   }
   return curr;
}

BOOL                                       // ret-TRUE if valid
   TNodeListSortable::CountTree(
      TNode                * pCurrentTop  ,// i/o-top of [sub]tree to count nodes
      DWORD                * pCount        // i/o-Number of nodes encountered in the tree
   )
{
   if ( !pCurrentTop )
      return TRUE;

   (*pCount)++;

   if( (*pCount) > count )
      return FALSE;

   if(!CountTree(pCurrentTop->left,pCount))
      return FALSE;

   if(!CountTree(pCurrentTop->right,pCount))
      return FALSE;

   return TRUE;
}


BOOL                                       // TRUE if Valid and FALSE if not
   TNodeListSortable::ValidateTree()
{
   DWORD                     dwTempCount=0;
   DWORD                     bValid;

   MCSVERIFY(listType == TNodeTypeTree);

   bValid = CountTree(head,&dwTempCount);

   return bValid;
}

// Routine to validate the state of the list
DWORD
   TNodeList::Validate(
      TNode               ** pErrorNode
   )
{
   DWORD                     dwError=0;
   DWORD                     nNodesVisited=0;
   TNode                   * pCurrentNode;
   DWORD                     dwNodeCount = Count();

   if(pErrorNode)
      *pErrorNode = NULL;

#ifndef WIN16_VERSION
   try
   {
#endif
      pCurrentNode = head;

      if ( pCurrentNode)  // If the list is not empty
      {
         if ( pCurrentNode->left)
         {
            dwError = MCS_ListError_InvalidHead;
         }
         else
         {
            while ( pCurrentNode->right )
            {
               if(pCurrentNode->right->left != pCurrentNode)
               {
                  dwError = MCS_ListError_InvalidPtr;
                  if(pErrorNode)
                     *pErrorNode = pCurrentNode->right;
                  break;
               }

               nNodesVisited++;

               if ( nNodesVisited > dwNodeCount )
               {
                  dwError = MCS_ListError_InvalidCount;
                  break;
               }
               pCurrentNode = pCurrentNode->right;
            }

            if ( (!dwError) && (!pCurrentNode->right) )
            {
               if ( pCurrentNode != tail)
               {
                  dwError = MCS_ListError_InvalidTail;
                  if(pErrorNode)
                     *pErrorNode = pCurrentNode->right;
               }
            }
         }
      }
      else  // if the list is empty
      {
         if(dwNodeCount)
         {
            dwError = MCS_ListError_InvalidCount;
         }
      }
#ifndef WIN16_VERSION
   }
   catch(...)
   {
      dwError = MCS_ListError_Exception;
   }
#endif

   return dwError;
}

void
   TNodeListSortable::TreeRemove(
      TNode                * item          // i/o-node to remove from binary tree
   )
{
   TNode                  ** prevNext = &head,
                           * rep,
                           * repLeft,
                           * temp;
   int                       cmp;

   MCSVERIFY(listType == TNodeTypeTree);

   while ( *prevNext )
   {
      cmp = PCompare( item, *prevNext );
      if ( cmp < 0 )
         prevNext = &(*prevNext)->left;
      else if ( cmp > 0 )
         prevNext = &(*prevNext)->right;
      else
      {
         // we've found a matching 'name' (they compare equal)
         if ( *prevNext == item )
         {
            // we've found the address we're looking for
            if ( (*prevNext)->right )
            {
               rep = repLeft = (*prevNext)->right;
               for ( temp = rep->left;  temp;  temp = temp->left )
                  repLeft = temp;
               repLeft->left = (*prevNext)->left;
               temp = *prevNext;
               *prevNext = rep;
            }
            else
            {
               temp = *prevNext;
               *prevNext = (*prevNext)->left; // simple case
            }

            // break removed nodes links to existing tree
            temp->left = temp->right = NULL;
            count--;
            break;
         }
      }
   }
   return;
}

// returns the insert point in a sorted list for a prospective node
TNode *                                    // ret-insert before point or NULL
   TNodeListSortable::SortedFindInsertBefore(
      TNode                * item         ,// i/o-node to insert into TNode
      BOOL                 * exists        // out-TRUE if already exists
   )
{
   int                       c;
   TNode                   * curr;

   *exists = FALSE;
   if ( !lastInsert )
   {
      if ( !head )           // if null head, empty list, return NULL
         return NULL;
      lastInsert = head;
   }

   c = PCompare(item, lastInsert);
   if ( c < 0 )
      lastInsert = head;

   for ( curr = lastInsert;  curr;  curr = curr->right )
   {
      c = PCompare(item, curr);
      if ( c <= 0 )
         if ( c == 0 )
            *exists = TRUE;
         else
            break;
   }

   return curr;
}

// inserts node into sorted linear list
void
   TNodeListSortable::SortedInsert(
      TNode                * item          // i/o-node to insert into TNode
   )
{
   BOOL                      exists;

   MCSVERIFY(listType != TNodeTypeTree);

   TNode                   * insertPoint = SortedFindInsertBefore(item, &exists);

   InsertBefore(item, insertPoint);
   lastInsert = item;
}


BOOL
   TNodeListSortable::SortedInsertIfNew(
      TNode                * item          // i/o-node to insert into TNode
   )
{
   BOOL                      exists;
   TNode                   * insertPoint = SortedFindInsertBefore(item, &exists);

   if ( !exists )
   {
      InsertBefore(item, insertPoint);
      lastInsert = item;
   }
   return !exists;
}


void
   TNodeListSortable::TreeInsert(
      TNode                * item         ,// i/o-node to insert into binary tree
      short                * depth         // out-tree/recursion depth of new item
   )
{
   TNode                  ** prevNext = &head;
   int                       cmp;

   MCSVERIFY(listType == TNodeTypeTree);

   for ( *depth = 0;  *prevNext;  (*depth)++ )
   {
      cmp = PCompare( item, *prevNext );
      if ( cmp <= 0 )
         prevNext = &(*prevNext)->left;
      else
         prevNext = &(*prevNext)->right;
   }
   *prevNext = item;
   item->left = item->right = NULL;
   count++;
   return;
}


TNode *
   TNodeListSortable::TreeFind(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void const           * findval
   ) const
{
   TNode                   * curr = head;
   int                       cmp;

   while ( curr )
   {
      cmp = Compare( curr, findval );
      if ( cmp > 0 )
         curr = curr->left;
      else if ( cmp < 0 )
         curr = curr->right;
      else   // cmp == 0
         break;
   }
   return curr;
}


TNode *                                    // ret-TNode at pos n or NULL
   TNodeListOrdEnum::Get(
      long                   n             // in -new position
   )
{
   long                 disCurr = n - nCurr, // distance to curr
                        disTop  = n < (long)list->Count()/2 ? n : n - list->Count();

#ifdef WIN16_VERSION
   long absDisTop  = (disTop<0)  ? -disTop  : disTop;
   long absDisCurr = (disCurr<0) ? -disCurr : disCurr;
   if ( absDisTop < absDisCurr )
#else
   if ( abs(disTop) < abs(disCurr) )
#endif
   {
      Top();
      disCurr = disTop;
   }
   if ( disCurr < 0 )
      for ( Prev();  n < nCurr  &&  Prev(); );
   else
      for (       ;  n > nCurr  &&  Next(); );

   return curr;
}

// returns the first node of the tree
TNode *
   TNodeTreeEnum::First()
{
   stackPos = stackBase;
   if ( top )
      Push(top);
   return Next();
}

// Returns the tree node logically following the value per the sort organization
// specified by Compare, and sets up the enumeration to continue from that point.
TNode *
   TNodeTreeEnum::FirstAfter(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void  const          * findVal       // in -findVal to position after
   )
{
   TNode                   * tn;
   int                       cmp;

   stackPos = stackBase;
   for ( tn = top;  tn;  )
   {
      Push(tn);
      cmp = Compare( tn, findVal );
      if ( cmp < 0 )
      {
         stackPos->state = Sright;
         if ( tn->right )
            tn = tn->right;
         else
            return Next();
      }
      else if ( cmp > 0 )
      {
         stackPos->state = Sleft;
         if ( tn->left )
            tn = tn->left;
         else
         {
            stackPos->state = Sused;
            return tn;
         }
      }
      else
      {
         stackPos->state = Sused;
         return Next();
      }
   }

   return NULL;
}


// returns the Next logical node of the tree ending with NULL when complete
TNode *
   TNodeTreeEnum::Next()
{
   for ( ;; )
   {
      switch ( stackPos->state )
      {
         case Snone:                       // we've done nothing here
            stackPos->state = Sleft;
            if ( stackPos->save->left )
               Push(stackPos->save->left);
            break;
         case Sleft:                       // we've gone left and are back
            stackPos->state = Sused;
            return stackPos->save;
         case Sused:                       // we've used the node
            stackPos->state = Sright;
            if ( stackPos->save->right )
               Push(stackPos->save->right);// process right side of branch
            break;
         case Sright:                      // we've gone right and are back
            if ( !Pop() )
               return NULL;
            break;
         case SComplete:
            return NULL;
            break;                         // Do we need this?
         default:                          // bad error
            MCSASSERT(FALSE);
            return NULL;
      }
   }

   return NULL;   // can't get here
}

// Returns the address of the forward (left/right) pointer where the find node
// already exists or would be inserted.  If the singly deferenced result is not
// null, the node's key value already exists in the tree.
// If, after obtaining the insertion point, you want to insert the node, just
// assign its address to the singly deferenced return value.  The following inserts
// the node "f" if it is not alread in the tree:
//    TNode **r = tree.TreeFindInsert(f);
//    if ( !*r )
//       *r = f;
TNode **                                   // ret-pointer forward pointer to find
   TNodeListSortable::TreeFindInsert(
      TNode const          * find         ,// in -node to find
      short                * depth         // out-tree depth of insertion point
   )
{
   TNode                  ** prevNext = &head;
   int                       cmp;

   for ( *depth = 0;  *prevNext;  (*depth)++ )
   {
      cmp = PCompare( find, *prevNext );
      if ( cmp < 0 )
         prevNext = &(*prevNext)->left;
      else if ( cmp > 0 )
         prevNext = &(*prevNext)->right;
      else
         break;
   }

   return prevNext;
}

// TNode.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setup\admtmsi\admtmsi.h ===
// ADMTMsi.h : main header file for the ADMTMSI DLL
//

#if !defined(AFX_ADMTMSI_H__BFA3C95E_AF45_4B19_B62D_0D2927CB826C__INCLUDED_)
#define AFX_ADMTMSI_H__BFA3C95E_AF45_4B19_B62D_0D2927CB826C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CADMTMsiApp
// See ADMTMsi.cpp for the implementation of this class
//

class CADMTMsiApp : public CWinApp
{
public:
	CADMTMsiApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CADMTMsiApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CADMTMsiApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADMTMSI_H__BFA3C95E_AF45_4B19_B62D_0D2927CB826C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setdtct\ustring.hpp ===
//#pragma title( "UString.hpp - Common string and character functions" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  UString.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1995-08-25
Description -  Common string and character functions.
      Many string and character functions defined in "string.h" are redefined
         here as overloaded inline functions with several extensions:
      o  Both ANSI and UNICODE strings are supported.
      o  Both ANSI and UNICODE characters are supported.
      o  For ANSI, characters can be "char signed" or "char unsigned".
      o  Functions that allow a length field, such as "lstrcpy" vs "lstrcpyn",
         are implemented as overloaded functions with optional arguments.
      o  Some functions, UStrCpy in particular, can perform conversion between
         ANSI and UNICODE strings.
      The function names defined here consist of "U" concatenated to the base
         name from "string.h".  The first letter of words or word abbreviations
         are capitalized, e.g. "strcpy" becomes "UStrCpy".
Updates     -
===============================================================================
*/

#ifndef  MCSINC_UString_hpp
#define  MCSINC_UString_hpp

#define safecopy(trg,src) (UStrCpy(trg,src,DIM(trg)))

#ifdef  WIN16_VERSION
   #ifndef  UCHAR
      #define  UCHAR  unsigned char
   #endif

   #include <string.h>
   #include <ctype.h>
#endif  // WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      char           const * s1            // in -ANSI string
   )
{
   return strlen( s1 );
}


int _inline                                // ret-length in chars
   UStrLen(
      UCHAR          const * s1            // in -ANSI string
   )
{
   return strlen( (char const *) s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   strcpy( aTarget, aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      strncpy( aTarget, aSource, copylen );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( aTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource, len );
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( (char const *) s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( (char const *) s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( (char const *) s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( (char const *) s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( (char const *) s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( (char const *) s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( (char const *) s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( (char const *) s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

char _inline *
   UStrLwr(
      char                 * s             // i/o-ANSI string
   )
{
   return strlwr( s );
}

UCHAR _inline *
   UStrLwr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strlwr( (char *) s );
}

char _inline *
   UStrUpr(
      char                 * s             // i/o-ANSI string
   )
{
   return strupr( s );
}

UCHAR _inline *
   UStrUpr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strupr( (char *) s );
}

char _inline
   UToLower(
      char                   c             // in -ANSI char
   )
{
   return tolower( c );
}

UCHAR _inline
   UToLower(
      UCHAR                  c             // in -ANSI char
   )
{
   return tolower( (char) c );
}

char _inline
   UToUpper(
      char                   c             // in -ANSI char
   )
{
   return toupper( c );
}

UCHAR _inline
   UToUpper(
      UCHAR                  c             // in -ANSI char
   )
{
   return toupper( (char) c );
}

// Left-trim string in place
_inline UCHAR *
   LTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strorg = s;

   while ( *strorg == ' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

_inline char *
   LTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) LTrim( (UCHAR *) s );
}

// Right-trim string in place
_inline UCHAR *
   RTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == ' ') )
      strend--;
   *strend = '\0';
   return s;
}

_inline char *
   RTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) RTrim( (UCHAR *) s );
}

// Trim string in place
_inline UCHAR *
   Trim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

_inline char *
   Trim(
      char                 * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

#ifndef  WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      WCHAR          const * s1            // in -UNICODE string
   )
{
   return lstrlenW( s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   UStrCpy( (char *) aTarget, wSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource       // in -ANSI source string
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( wTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   lstrcpyW( wTarget, wSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, wSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( wTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      lstrcpynW( wTarget, wSource, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         s2,
         -1 ) - 2;
// return wcscmp( s1, s2 );
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         s2,
         len ) - 2;
// return wcsncmp( s1, s2, len );
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         s2,
         -1 ) - 2;
// return wcsicmp( s1, s2 );
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         s2,
         len ) - 2;
// return wcsnicmp( s1, s2, len );
}

WCHAR _inline *
   UStrLwr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return wcslwr( s );
}

WCHAR _inline *
   UStrUpr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return wcsupr( s );
}

WCHAR _inline
   UToLower(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towlower( c );
}

WCHAR _inline
   UToUpper(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towupper( c );
}

// Left-trim string in place
_inline WCHAR *
   LTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strorg = s;

   while ( *strorg == L' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

// Right-trim string in place
_inline WCHAR *
   RTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == L' ') )
      strend--;
   *strend = L'\0';
   return s;
}

// Trim string in place
_inline WCHAR *
   Trim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return LTrim( RTrim( s ) );
}

char * _cdecl                             // ret-target string
   UStrJoin(
      char                 * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      char const           * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

WCHAR * _cdecl                            // ret-target string
   UStrJoin(
      WCHAR                * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      WCHAR const          * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

#endif  // WIN16_VERSION

#endif  // MCSINC_UString_hpp

// UString.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setup\admtmsi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ADMTMSI.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE	1000
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		1000
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setup\admtmsi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ADMTMsi.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setup\admtmsi\admtmsi.cpp ===
// ADMTMsi.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <stdio.h>
#include <windows.h> 
#include <winuser.h>
#include <lm.h>
#include <msi.h>
#include <msiquery.h>
#include "ADMTMsi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CADMTMsiApp

BEGIN_MESSAGE_MAP(CADMTMsiApp, CWinApp)
	//{{AFX_MSG_MAP(CADMTMsiApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CADMTMsiApp construction

CADMTMsiApp::CADMTMsiApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CADMTMsiApp object

CADMTMsiApp theApp;
HWND installWnd = 0;

/********************
 * Helper Functions *
 ********************/


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 JAN 2001                                                 *
 *                                                                   *
 *     This function is a callback function used by GetWndFromInstall*
 * to compare titles and store the found HWND globally.              *
 *                                                                   *
 *********************************************************************/

//BEGIN CheckTitle
BOOL CALLBACK CheckTitle(HWND hwnd, LPARAM lParam)
{
/* local variables */
   WCHAR		sText[MAX_PATH];
   WCHAR	  * pTitle;
   BOOL			bSuccess;
   int			len;

/* function body */
   pTitle = (WCHAR*)lParam; //get the title to compare

      //get the title of this window
   len = GetWindowText(hwnd, sText, MAX_PATH);

   if ((len) && (pTitle))
   {
	  if (wcsstr(sText, pTitle))
	  {
		 installWnd = hwnd;
	     return FALSE;
	  }
   }
   return TRUE;
}
//END CheckTitle


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for getting the HWND of the      *
 * current installation to be used to display a MessageBox tied to   *
 * the install GUI.                                                  *
 *                                                                   *
 *********************************************************************/

//BEGIN GetWndFromInstall
void GetWndFromInstall(MSIHANDLE hInstall)
{
/* local variables */
   WCHAR				szPropName[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sTitle[MAX_PATH];
   DWORD				nCount = MAX_PATH;

/* function body */
      //get the installation's title
   wcscpy(szPropName, L"ProductName");
   lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
   if (lret != ERROR_SUCCESS)
      wcscpy(sTitle, L"ADMT Password Migration DLL");

      //get the window handle for the install GUI
   EnumChildWindows(NULL, CheckTitle, (LPARAM)sTitle);
   if (!installWnd)
	  installWnd = GetForegroundWindow();
}
//END GetWndFromInstall


/**********************
 * exported functions *
 **********************/


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 DEC 2000                                                 *
 *                                                                   *
 *     This function is responsible for saving current ADMT files in *
 * the %TEMP% folder prior to installing the new version.  The       *
 * installation will later call the restore function to restore the  *
 * saved file.  Currently this mechanism is used for saving the      *
 * current protar.mdb database.                                      *
 *                                                                   *
 *********************************************************************/

//BEGIN SaveCurrentFiles
UINT __stdcall SaveCurrentFiles(MSIHANDLE hInstall)
{
/* local constants */
   const int GETENVVAR_ERROR = 0;    //this indicates an error from the "GetEnvironmentVariable" function
   const WCHAR	sDCValue[2] = L"1";

/* local variables */
   WCHAR				tempdir[MAX_PATH];
   WCHAR				filename[MAX_PATH];
   WCHAR				newfilename[MAX_PATH];
   int					length;
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sPropName[MAX_PATH];
   WCHAR				sDir[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   HANDLE               hFile;
   WIN32_FIND_DATA      fDat;
   BOOL					bSuccess;

/* function body */
      //initialize these strings
   wcscpy(sPropName, L"INSTALLDIR");

      //if INSTALLDIR was not retrieved, set to default
   if (MsiGetProperty(hInstall, sPropName, sDir, &nCount) != ERROR_SUCCESS)
   {
      length = GetEnvironmentVariable( L"ProgramFiles", sDir, MAX_PATH);
      if (length != GETENVVAR_ERROR)
	     wcscat(sDir, L"\\Active Directory Migration Tool\\");
	  else
         wcscpy(sDir, L"C:\\Program Files\\Active Directory Migration Tool\\");
   }

      //find the temp dir
   length = GetEnvironmentVariable( L"temp", tempdir, MAX_PATH);
   if (length == GETENVVAR_ERROR)
	  wcscpy(tempdir, L"C:\\Temp");

      //copy files to temp
   wcscpy(filename, sDir);
   wcscat(filename, L"Protar.mdb");
   wcscpy(newfilename, tempdir);
   wcscat(newfilename, L"\\Protar.mdb");
   hFile = FindFirstFile(filename, &fDat);
      //if found, copy it
   if (hFile != INVALID_HANDLE_VALUE)
   {
      FindClose(hFile);
      bSuccess = CopyFile(filename, newfilename, FALSE);

      if (bSuccess)
	  {
	     lret = ERROR_SUCCESS;
         wcscpy(sPropName, L"bMDBSaved");
         lret = MsiSetProperty(hInstall, sPropName, sDCValue);
	  }
      else
	     lret = ERROR_INSTALL_FAILURE;
   }
   else
   {
      wcscpy(sPropName, L"bMDBNotPresent");
      lret = MsiSetProperty(hInstall, sPropName, sDCValue);
   }


   return lret;
}
//END SaveCurrentFiles


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 DEC 2000                                                 *
 *                                                                   *
 *     This function is responsible for restoring ADMT files         *
 * previously stored by a call to "SaveCurrentFiles".  Currently this*
 * mechanism is used for saving the current protar.mdb database.     *
 *                                                                   *
 *********************************************************************/

//BEGIN RestoreFiles
UINT __stdcall RestoreFiles(MSIHANDLE hInstall)
{
/* local constants */
   const int GETENVVAR_ERROR = 0;    //this indicates an error from the "GetEnvironmentVariable" function
   const WCHAR	sDCValue[2] = L"1";

/* local variables */
   WCHAR				sDir[MAX_PATH];
   WCHAR				tempdir[MAX_PATH];
   WCHAR				filename[MAX_PATH];
   WCHAR				newfilename[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   BOOL					bSuccess;
   WCHAR				sPropName[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   int					length;

/* function body */
      //get the dir where we saved the files previously
   wcscpy(sPropName, L"INSTALLDIR");

      //if not retrieved, set to default
   if (MsiGetProperty(hInstall, sPropName, sDir, &nCount) != ERROR_SUCCESS)
   {
      length = GetEnvironmentVariable( L"ProgramFiles", sDir, MAX_PATH);
      if (length != GETENVVAR_ERROR)
	     wcscat(sDir, L"\\Active Directory Migration Tool\\");
	  else
         wcscpy(sDir, L"C:\\Program Files\\Active Directory Migration Tool\\");
   }

         //get the dir where we saved the files previously
   length = GetEnvironmentVariable( L"temp", tempdir, MAX_PATH);
   if (length == GETENVVAR_ERROR)
      wcscpy(tempdir, L"C:\\Temp");

      //copy files back
   wcscpy(filename, tempdir);
   wcscat(filename, L"\\Protar.mdb");
   wcscpy(newfilename, sDir);
   wcscat(newfilename, L"Protar.mdb");
   bSuccess = CopyFile(filename, newfilename, FALSE);

   if (bSuccess)
   {
      wcscpy(sPropName, L"bMDBRestored");
      lret = MsiSetProperty(hInstall, sPropName, sDCValue);
   }
   else
   {
   	  lret = ERROR_INSTALL_FAILURE;
   }
 
   return lret;
}
//END RestoreFiles

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for displaying a message box.    *
 *                                                                   *
 *********************************************************************/

//BEGIN DisplayExiting
UINT __stdcall DisplayExiting(MSIHANDLE hInstall)
{
/* local variables */
   WCHAR				sPropName[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sTitle[MAX_PATH] = L"";
   WCHAR				sMsg[MAX_PATH] = L"";
   DWORD				nCount = MAX_PATH;

/* function body */
      //initialize these strings
   wcscpy(sPropName, L"bMDBSaved");

      //if this is not a DC, get its messages
   if (MsiGetProperty(hInstall, sPropName, sMsg, &nCount) == ERROR_SUCCESS)
   {
      if (!wcscmp(sMsg, L"0"))
	  {
            //get the leave messagebox msg string and title for not being able to save protar.mdb
         wcscpy(sPropName, L"MDBLeaveMsg");
         lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sMsg, L"ADMT's internal database, protar.mdb, could not be saved. The installation cannot continue.");
        
         wcscpy(sPropName, L"MDBLeaveTitle");
         lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Protar.mdb Not Saved!");
	  }
	  else
	  {
            //get the leave messagebox msg string and title for not being able to restore protar.mdb
         wcscpy(sPropName, L"MDB2LeaveMsg");
         lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
         if (lret != ERROR_SUCCESS)
		 {
            wcscpy(sMsg, L"ADMT's internal database, protar.mdb, could not be restored. Manually restore");
		    wcscat(sMsg, L" it from the, environment variable, TEMP directory.");
		 }
        
         wcscpy(sPropName, L"MDB2LeaveTitle");
         lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Protar.mdb Not Restored!");
	  }
   }

   GetWndFromInstall(hInstall);
   MessageBox(installWnd, sMsg, sTitle, MB_ICONSTOP | MB_OK);
   return lret;
}
//END DisplayExiting


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 14 JAN 2000                                                 *
 *                                                                   *
 *     This function is responsible for displaying a message box.    *
 *                                                                   *
 *********************************************************************/

//BEGIN IsUpgrade
UINT __stdcall IsUpgrade(MSIHANDLE hInstall)
{
/* local constants */
   const int GETENVVAR_ERROR = 0;    //this indicates an error from the "GetEnvironmentVariable" function
   const WCHAR	sExit[2] = L"1";

/* local variables */
   WCHAR				sPropName[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sTitle[MAX_PATH] = L"";
   WCHAR				sMsg[MAX_PATH] = L"";
   WCHAR				sDir[MAX_PATH] = L"";
   WCHAR				sKey[MAX_PATH] = L"";
   DWORD				nCount = MAX_PATH;
   long					lrtn = ERROR_SUCCESS;
   HKEY					hADMTKey;
   int					length;

/* function body */
   /* see if ADMT V1.0 is installed by looking at the registry and find
      out where it is installed at */
      //open the ADMT Registry key, if it exists
   wcscpy(sKey, L"SOFTWARE\\Mission Critical Software\\DomainAdmin");
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, sKey, 0, KEY_READ, &hADMTKey) != ERROR_SUCCESS)
      return lret;

      //get the current install path
   wcscpy(sPropName, L"Directory");
   nCount = MAX_PATH;
   if (RegQueryValueEx(hADMTKey, sPropName, NULL, NULL, 
	                   (LPBYTE)sDir, &nCount) != ERROR_SUCCESS)
   {
      length = GetEnvironmentVariable( L"ProgramFiles", sDir, MAX_PATH);
      if (length != GETENVVAR_ERROR)
	     wcscat(sDir, L"\\Active Directory Migration Tool\\");
	  else
         wcscpy(sDir, L"C:\\Program Files\\Active Directory Migration Tool\\");
   }
   RegCloseKey(hADMTKey);

      //now see if V1.0 is really installed (key exists)
   wcscpy(sKey, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{76789332-34CD-11D3-9E6A-00A0C9AFE10F}");
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, sKey, 0, KEY_READ, &hADMTKey) != ERROR_SUCCESS)
      return lret;
   RegCloseKey(hADMTKey);

      //get the upgrade messagebox msg string and title
   wcscpy(sPropName, L"UpgradeMsg");
   lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
   if (lret != ERROR_SUCCESS)
   {
      wcscpy(sMsg, L"ADMT Version 1.00 is currently istalled.  Would");
	  wcscat(sMsg, L" you like to upgrade to Version 2.00 Beta 2?");
   }
        
   nCount = MAX_PATH;
   wcscpy(sPropName, L"UpgradeTitle");
   lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
   if (lret != ERROR_SUCCESS)
      wcscpy(sTitle, L"Upgrade ADMT?");

      //if they want to upgrade, save the install path
   GetWndFromInstall(hInstall);
   if (MessageBox(installWnd, sMsg, sTitle, MB_ICONQUESTION | MB_YESNO) == IDYES)
   {
      wcscpy(sPropName, L"INSTALLDIR");
      lret = MsiSetProperty(hInstall, sPropName, sDir);
   }
   else //else, set the flag to exit the install
   {
      wcscpy(sPropName, L"bUpgradeExit");
      lret = MsiSetProperty(hInstall, sPropName, sExit);
   }
   return lret;
}
//END IsUpgrade
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setup\admtmsi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__45FD9CD9_F9CE_4A4D_9BED_ACC54B3C5F56__INCLUDED_)
#define AFX_STDAFX_H__45FD9CD9_F9CE_4A4D_9BED_ACC54B3C5F56__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC Automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__45FD9CD9_F9CE_4A4D_9BED_ACC54B3C5F56__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setup\pwdmsi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PwdMsi.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setup\pwdmsi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	PwdMsi.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setup\pwdmsi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__55E9DEC0_A79C_4159_8A49_117749D82CF4__INCLUDED_)
#define AFX_STDAFX_H__55E9DEC0_A79C_4159_8A49_117749D82CF4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__55E9DEC0_A79C_4159_8A49_117749D82CF4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setup\pwdmsi\pwdmsi.cpp ===
// PwdMsi.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include <winuser.h>
#include <stdio.h>
#include <lm.h>
#include <msi.h>
#include <msiquery.h>
#include <comdef.h>
#include <commdlg.h>
#include <Dsgetdc.h>
#include <eh.h>
#include "pwdfuncs.h"
#include "ADMTCrypt.h"
#include "PwdMsi.h"

bool b3DESNotInstalled = false;
bool bPESFileFound = false;
bool bPasswordNeeded = false;
HWND installWnd = 0;


BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


// This is the constructor of a class that has been exported.
// see PwdMsi.h for the class definition
CPwdMsi::CPwdMsi()
{ 
	return; 
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 JAN 2001                                                 *
 *                                                                   *
 *     This function is a callback function used by GetWndFromInstall*
 * to compare titles and store the found HWND globally.              *
 *                                                                   *
 *********************************************************************/

//BEGIN CheckTitle
BOOL CALLBACK CheckTitle(HWND hwnd, LPARAM lParam)
{
/* local variables */
   WCHAR		sText[MAX_PATH];
   WCHAR	  * pTitle;
   BOOL			bSuccess;
   int			len;

/* function body */
   pTitle = (WCHAR*)lParam; //get the title to compare

      //get the title of this window
   len = GetWindowText(hwnd, sText, MAX_PATH);

   if ((len) && (pTitle))
   {
	  if (wcsstr(sText, pTitle))
	  {
		 installWnd = hwnd;
	     return FALSE;
	  }
   }
   return TRUE;
}
//END CheckTitle


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for getting the HWND of the      *
 * current installation to be used to display a MessageBox tied to   *
 * the install GUI.                                                  *
 *                                                                   *
 *********************************************************************/

//BEGIN GetWndFromInstall
void GetWndFromInstall(MSIHANDLE hInstall)
{
/* local variables */
   WCHAR				szPropName[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sTitle[MAX_PATH];
   DWORD				nCount = MAX_PATH;

/* function body */
      //get the installation's title
   wcscpy(szPropName, L"ProductName");
   lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
   if (lret != ERROR_SUCCESS)
      wcscpy(sTitle, L"ADMT Password Migration DLL");

      //get the window handle for the install GUI
   EnumChildWindows(NULL, CheckTitle, (LPARAM)sTitle);
   if (!installWnd)
	  installWnd = GetForegroundWindow();
}
//END GetWndFromInstall

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 DEC 2000                                                 *
 *                                                                   *
 *     This function is responsible for retrieving a password        *
 * encryption key from the given path.                               *
 *                                                                   *
 *********************************************************************/

//BEGIN RetrieveAndStorePwdKey
bool RetrieveAndStorePwdKey(WCHAR * sPwd, _bstr_t sPath)
{
/* local variables */
   bool					bRetrieved = false;
   WCHAR			  * pDrive;
   HANDLE               hFile;
   WIN32_FIND_DATA      fDat;
   _variant_t           varData;

/* function body */
   hFile = FindFirstFile((WCHAR*)sPath, &fDat);
      //if found, retrieve and store the key
   if (hFile != INVALID_HANDLE_VALUE)
   {
      FindClose(hFile);
	  try
	  {
         bPESFileFound = true;
		    //get the data
         varData = GetDataFromFloppy((WCHAR*)sPath);
		 if (varData.vt == (VT_UI1 | VT_ARRAY))
		 {
		    long uUBound;
			LPBYTE pByte = NULL;
            SafeArrayAccessData(varData.parray,(void**)&pByte);
			BYTE byteKey = pByte[0];
            SafeArrayUnaccessData(varData.parray);

			   //the first byte tells us if this key is password encrypted
			   //if password needed, return and have install display the UI
			if (byteKey != 0)
			{
			   if (sPwd)
			   {
				     //try saving the key with this password
				  try
				  {
			         CSourceCrypt aCryptObj;  //create a crypt object

                        //try to store the key. If fails, it throws a com error caught below
                     aCryptObj.ImportEncryptionKey(varData, sPwd);
					 bRetrieved = true;
				  }
                  catch (_com_error& ce)
				  {
                        //if HES not installed, set flag
	                 if (ce.Error() == NTE_KEYSET_NOT_DEF)
	                    b3DESNotInstalled = true;
				  }
			   }
			   else
                  bPasswordNeeded = true;
			}
			else
			{
               bPasswordNeeded = false;
			   try
			   { 
			      CSourceCrypt aCryptObj;  //create a crypt object

			          //try to store the key. If fails, it throws a com error caught below
				  aCryptObj.ImportEncryptionKey(varData, NULL);
				  bRetrieved = true;
			   }
               catch (_com_error& ce)
			   {
                     //if HES not installed, set flag
	              if (ce.Error() == NTE_KEYSET_NOT_DEF)
	                 b3DESNotInstalled = true;
			   }
			}
		 }
	  }
	  catch (...)
	  {
	  }
   }

   return bRetrieved;
}
//END RetrieveAndStorePwdKey


/**********************
 * exported functions *
 **********************/

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for adding the PWMIG dll name to *
 * the Multi-string value "Notification Packages" under the Lsa key. *
 *                                                                   *
 *********************************************************************/

//BEGIN IsDC
PWDMSI_API UINT __stdcall IsDC(MSIHANDLE hInstall)
{
/* local constants */
   const WCHAR	sDCValue[2] = L"1";

/* local variables */
   bool					bDC = false;
   DWORD				dwLevel = 101;
   LPSERVER_INFO_101	pBuf = NULL;
   NET_API_STATUS		nStatus;
   WCHAR				szPropName[MAX_PATH] = L"DC";
   UINT					lret = ERROR_SUCCESS;

/* function body */

   nStatus = NetServerGetInfo(NULL,
                              dwLevel,
                              (LPBYTE *)&pBuf);
   if (nStatus == NERR_Success)
   {
      //
      // Check for the type of server.
      //
      if ((pBuf->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
         (pBuf->sv101_type & SV_TYPE_DOMAIN_BAKCTRL))
         bDC = true;

      NetApiBufferFree(pBuf);
   }

   if (bDC)
      lret = MsiSetProperty(hInstall, szPropName, sDCValue);

   return lret;
}
//END IsDC

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for displaying a message box.    *
 *                                                                   *
 *********************************************************************/

//BEGIN DisplayExiting
PWDMSI_API UINT __stdcall DisplayExiting(MSIHANDLE hInstall)
{
/* local variables */
   WCHAR				sPropName[MAX_PATH];
   UINT					lret = ERROR_SUCCESS;
   WCHAR				sTitle[MAX_PATH];
   WCHAR				sMsg[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   bool					bMsgGot = false;

/* function body */
      //get the DC property
   wcscpy(sPropName, L"DC");
      //if this is not a DC, get its messages
   if (MsiGetProperty(hInstall, sPropName, sMsg, &nCount) == ERROR_SUCCESS)
   {
      if (!wcscmp(sMsg, L"0"))
	  {
            //get the leave messagebox msg string and title for not being a DC
         wcscpy(sPropName, L"DCLeaveMsg");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sMsg, L"ADMT's Password Migration Filter DLL can only be installed on a DC, PDC, or BDC!");
        
         wcscpy(sPropName, L"DCLeaveTitle");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Invalid Machine!");

	     bMsgGot = true;
	  }
   }
   
      //if this is a DC then see if the High Encryption pack was not installed
   if (!bMsgGot)
   {
         //get the HES flag property
      wcscpy(sPropName, L"b3DESNotInstalled");
      nCount = MAX_PATH;
         //if HEP is not installed, get its messages
      if (MsiGetProperty(hInstall, sPropName, sMsg, &nCount) == ERROR_SUCCESS)
	  {
         if (!wcscmp(sMsg, L"1"))
		 {
		       //get the leave messagebox msg string and title for not getting a key
            wcscpy(sPropName, L"HEPLeaveMsg");
            nCount = MAX_PATH;
            lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
            if (lret != ERROR_SUCCESS)
			{
               wcscpy(sMsg, L"The high encryption pack has not been installed on this machine.  ADMT's ");
			   wcscat(sMsg, L"Password Migration Filter DLL will not install without the high encryption pack.");
			}
        
            wcscpy(sPropName, L"HEPLeaveTitle");
            nCount = MAX_PATH;
            lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
            if (lret != ERROR_SUCCESS)
               wcscpy(sTitle, L"High Encryption Pack Required!");

			bMsgGot = true;
		 }
	  }
   }
   
/*      //see if an encryption key file was not found on a local drive
   if (!bMsgGot)
   {
         //get the File flag property
      wcscpy(sPropName, L"bPESFileNotFound");
      nCount = MAX_PATH;
         //if file not found, get its messages
      if (MsiGetProperty(hInstall, sPropName, sMsg, &nCount) == ERROR_SUCCESS)
	  {
         if (!wcscmp(sMsg, L"1"))
		 {
		       //get the leave messagebox msg string and title for not getting a key
            wcscpy(sPropName, L"PESLeaveMsg");
            nCount = MAX_PATH;
            lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
            if (lret != ERROR_SUCCESS)
			{
               wcscpy(sMsg, L"An encryption key file (.pes) could not be found on any of the floppy drives.");
			}
        
            wcscpy(sPropName, L"PESLeaveTitle");
            nCount = MAX_PATH;
            lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
            if (lret != ERROR_SUCCESS)
               wcscpy(sTitle, L"File Not Found!");

			bMsgGot = true;
		 }
	  }
   }
*/
      //else password was bad
   if (!bMsgGot)
   {
         //get the leave messagebox msg string and title for not getting a key
      wcscpy(sPropName, L"PwdLeaveMsg");
      nCount = MAX_PATH;
      lret = MsiGetProperty(hInstall, sPropName, sMsg, &nCount);
      if (lret != ERROR_SUCCESS)
	  {
         wcscpy(sMsg, L"The supplied password does not match this encryption key's password.  ADMT's ");
		 wcscat(sMsg, L"Password Migration Filter DLL will not install without a valid encryption key.");
	  }
        
      wcscpy(sPropName, L"PwdLeaveTitle");
      nCount = MAX_PATH;
      lret = MsiGetProperty(hInstall, sPropName, sTitle, &nCount);
      if (lret != ERROR_SUCCESS)
         wcscpy(sTitle, L"Invalid Password!");
   }

   GetWndFromInstall(hInstall);
   MessageBox(installWnd, sMsg, sTitle, MB_ICONSTOP | MB_OK);
   return lret;
}
//END DisplayExiting


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 20 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for trying to delete any files,  *
 * that will be installed, that may have been left around by previous*
 * installations.                                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN DeleteOldFiles
PWDMSI_API UINT __stdcall DeleteOldFiles(MSIHANDLE hInstall)
{
/* local constants */
   const int GETENVVAR_ERROR = 0;    //this indicates an error from the "GetEnvironmentVariable" function

/* local variables */
   WCHAR				systemdir[MAX_PATH];
   WCHAR				filename[MAX_PATH];
   int					length;
   UINT					lret = ERROR_SUCCESS;

/* function body */
      //try deleting previously installed files
   length = GetEnvironmentVariable( L"windir", systemdir, MAX_PATH);
   if (length != GETENVVAR_ERROR)
   {
      wcscat(systemdir, L"\\system32\\");  //go from windir to winsysdir
	  wcscpy(filename, systemdir);
	  wcscat(filename, L"PwMig.dll");
	  DeleteFile(filename);

	  wcscpy(filename, systemdir);
	  wcscat(filename, L"mschapp.dll");
	  DeleteFile(filename);
   }

   return lret;
}
//END DeleteOldFiles

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 DEC 2000                                                  *
 *                                                                   *
 *     This function is responsible for displaying the necessary     *
 * dialogs to prompt for and retrieve a password encryption key off  *
 * of a floppy disk.  This key is placed on a floppy disk via a      *
 * command line option on the ADMT machine.                          *
 *                                                                   *
 *********************************************************************/

//BEGIN GetInstallEncryptionKey
PWDMSI_API UINT __stdcall GetInstallEncryptionKey(MSIHANDLE hInstall)
{
/* local constants */
   const int			ADRIVE_SIZE = 3;  //length of a drive in the string (i.e "a:\")

/* local variables */
   UINT					lret = ERROR_SUCCESS;
   WCHAR				szPropName[MAX_PATH];
   WCHAR				sTitle[MAX_PATH];
   WCHAR				sMsg[MAX_PATH];
   WCHAR				sTemp[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   int					nRet;
   bool					bRetrieved = false;
   WCHAR				sRetrieved[2] = L"0";
   WCHAR				sFlagSet[2] = L"1";
   WCHAR				sFlagClear[2] = L"0";
   _bstr_t				sDrives;
   _bstr_t				sPath;
   WCHAR				sADrive[ADRIVE_SIZE+1];

/* function body */
      //if no path to file, return
   wcscpy(szPropName, L"SENCRYPTIONFILEPATH");
   lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
   if (lret != ERROR_SUCCESS)
      return lret;

   sPath = sMsg;  //save the given path

   //get the drive of the given path
   wcsncpy(sADrive, sMsg, ADRIVE_SIZE);
   sADrive[ADRIVE_SIZE] = L'\0';

      //enumerate all local drives
   sDrives = EnumLocalDrives();

      //if the given file is not on a local drive, set a flag and return
   WCHAR* pFound = wcsstr(sDrives, sADrive);
   if ((!pFound) || (wcslen(sADrive) == 0) || (wcsstr(sMsg, L".pes") == NULL))
   {
	      //set the bad path flag
      wcscpy(szPropName, L"bBadKeyPath");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);

	     //if starts with "\\" then tell them it must be a local drive
      if ((!pFound) && (wcsstr(sMsg, L"\\\\") == sMsg))
	  {
	        //get the bad path messagebox msg string and title
         wcscpy(szPropName, L"BadDriveMsg");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
         if (lret != ERROR_SUCCESS)
		 {
            wcscpy(sMsg, L"The given path is not on a local drive and is therefore invalid.");
		    wcscat(sMsg, L"  Please supply the path to a valid encryption key file on a local drive.");
		 }
      
		 wcscpy(szPropName, L"BadPathTitle");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Invalid Local Drive!");
	  }
	     //else if the given file does end with ".pes", tell them it must
      else if ((pFound) && (wcsstr(sMsg, L".pes") == NULL))
	  {
	        //get the bad file extension messagebox msg string
         wcscpy(szPropName, L"BadFileExtMsg");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
         if (lret != ERROR_SUCCESS)
		 {
            wcscpy(sMsg, L"The given file must be a valid encryption key file ending with the \".pes\" extension.");
		 }
      
		 wcscpy(szPropName, L"BadFileExtTitle");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Invalid File Extension!");
	  }
	     //else, tell them it is not a local drive
      else
	  {
	        //get the bad path messagebox msg string and title
         wcscpy(szPropName, L"BadPathMsg");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sTemp, &nCount);
         if (lret != ERROR_SUCCESS)
		 {
            wcscpy(sTemp, L"The given drive, %s, is not a local drive and is therefore invalid.");
		    wcscat(sTemp, L"  Please supply the path to a valid encryption key file on a local drive.");
		 }
	     swprintf(sMsg, sTemp, sADrive);
      
		 wcscpy(szPropName, L"BadPathTitle");
         nCount = MAX_PATH;
         lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
         if (lret != ERROR_SUCCESS)
            wcscpy(sTitle, L"Invalid Local Drive!");
	  }
        
      GetWndFromInstall(hInstall);
      MessageBox(installWnd, sMsg, sTitle, MB_ICONSTOP | MB_OK);

      return lret;
   }
   else
   {
	      //else clear the bad path flag
      wcscpy(szPropName, L"bBadKeyPath");
      lret = MsiSetProperty(hInstall, szPropName, sFlagClear);
   }

      //try to retrieve the encryption key
   if (RetrieveAndStorePwdKey(NULL, sPath))
      wcscpy(sRetrieved, L"1");
   else if (bPasswordNeeded)
   {
      wcscpy(szPropName, L"bPwdNeeded");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);
   }

      //set the key retrieved flag
   wcscpy(szPropName, L"bKeyRetrieved");
   lret = MsiSetProperty(hInstall, szPropName, sRetrieved);

      //if file not found at the given path, prompt the user for a new one
   if (!bPESFileFound)
   {
	      //set the bad path flag
      wcscpy(szPropName, L"bBadKeyPath");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);

         //get the bad path messagebox msg string and title
      wcscpy(szPropName, L"PESLeaveMsg");
      nCount = MAX_PATH;
      lret = MsiGetProperty(hInstall, szPropName, sTemp, &nCount);
      if (lret != ERROR_SUCCESS)
	  {
         wcscpy(sTemp, L"The given encryption key file, %s, could not be found.");
		 wcscat(sTemp, L"  Please enter the path to a valid encryption key file.");
	  }
	  swprintf(sMsg, sTemp, (WCHAR*)sPath);
        
      wcscpy(szPropName, L"PESLeaveTitle");
      nCount = MAX_PATH;
      lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
      if (lret != ERROR_SUCCESS)
         wcscpy(sTitle, L"File Not Found!");

      GetWndFromInstall(hInstall);
      MessageBox(installWnd, sMsg, sTitle, MB_ICONSTOP | MB_OK);

      return lret;
   }

      //if HES is not installed, set that flag
   if (b3DESNotInstalled)
   {
      wcscpy(szPropName, L"b3DESNotInstalled");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);
   }

   return lret;
}
//END GetInstallEncryptionKey


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 SEPT 2000                                                *
 *                                                                   *
 *     This function is used by the installation routine and is      *
 * responsible for adding the PWMIG dll name to the Multi-string     *
 * value "Notification Packages" under the Lsa key.                  *
 *                                                                   *
 *********************************************************************/

//BEGIN AddToLsaNotificationPkgValue
PWDMSI_API UINT __stdcall AddToLsaNotificationPkgValue(MSIHANDLE hInstall)
{
/* local constants */
   const WCHAR sLsaKey[40] = L"SYSTEM\\CurrentControlSet\\Control\\Lsa";
   const WCHAR sLsaValue[25] = L"Notification Packages";
   const WCHAR sNewAddition[10] = L"PWMIG";

/* local variables */
   bool				bSuccess = false;
   bool				bFound = false;
   bool				bAlreadyThere = false;
   DWORD			rc;
   DWORD			type;
   DWORD			len = MAX_PATH * sizeof(WCHAR*);
   HKEY				hKey;
   WCHAR			sString[MAX_PATH];
   WCHAR			sTemp[MAX_PATH];
   int				currentPos = 0;
   UINT				lret = ERROR_SUCCESS;

/* function body */
      //open the Lsa registry key
   rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     sLsaKey,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey);
   if (rc == ERROR_SUCCESS)
   {
	     //get the current value string
      rc = RegQueryValueEx(hKey, sLsaValue, NULL, &type, (LPBYTE)sString, &len);
      if ((rc == ERROR_SUCCESS) && (type == REG_MULTI_SZ))
	  {
		    //copy each string in the multi-string until the end is reached
         while (!bFound)
		 {
			if (!wcscmp(sString+currentPos, sNewAddition))
			   bAlreadyThere = true;
		    wcscpy(sTemp+currentPos, sString+currentPos);
		    currentPos += wcslen(sTemp+currentPos) + 1;
		    if (sString[currentPos] == L'\0')
			   bFound = true;
		 }
		 if (!bAlreadyThere)
		 {
	           //now add our new text and terminate the string
			wcscpy(sTemp+currentPos, sNewAddition);
		    currentPos += wcslen(sNewAddition) + 1;
			sTemp[currentPos] = L'\0';

			   //save the new value in the registry
			len = (currentPos + 1) * sizeof(WCHAR);
            rc = RegSetValueEx(hKey, sLsaValue, 0, type, (LPBYTE)sTemp, len);
			if (rc == ERROR_SUCCESS)
			   bSuccess = true;
		 }
	  }
      RegCloseKey(hKey);
   }
   
      //tell installer we want to reboot
   MsiSetMode(hInstall, MSIRUNMODE_REBOOTATEND, TRUE);

   return lret;
}
//END AddToLsaNotificationPkgValue

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 SEPT 2000                                                *
 *                                                                   *
 *     This function is used by the installation routine and is      *
 * responsible for deleting the PWMIG dll name from the Multi-string *
 * value "Notification Packages" under the Lsa key.                  *
 *                                                                   *
 *********************************************************************/

//BEGIN DeleteFromLsaNotificationPkgValue
PWDMSI_API UINT __stdcall DeleteFromLsaNotificationPkgValue(MSIHANDLE hInstall)
{
/* local constants */
   const WCHAR sLsaKey[40] = L"SYSTEM\\CurrentControlSet\\Control\\Lsa";
   const WCHAR sLsaValue[25] = L"Notification Packages";
   const WCHAR sNewAddition[10] = L"PWMIG";

/* local variables */
   bool				bSuccess = false;
   DWORD			rc;
   DWORD			type;
   DWORD			len = MAX_PATH * sizeof(WCHAR*);
   HKEY				hKey;
   WCHAR			sString[MAX_PATH];
   WCHAR			sTemp[MAX_PATH];
   int				currentPos = 0;
   int				tempPos = 0;
   UINT				lret = ERROR_SUCCESS;

/* function body */
      //open the Lsa registry key
   rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     sLsaKey,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey);
   if (rc == ERROR_SUCCESS)
   {
	     //get the current value string
      rc = RegQueryValueEx(hKey, sLsaValue, NULL, &type, (LPBYTE)sString, &len);
      if ((rc == ERROR_SUCCESS) && (type == REG_MULTI_SZ))
	  {
		    //copy each string in the multi-string until the desired string
         while (sString[currentPos] != L'\0')
		 {
			  //if not string wanted, copy to destination string
		    if (wcscmp(sString+currentPos, sNewAddition))
			{
		       wcscpy(sTemp+tempPos, sString+currentPos);
			   tempPos += wcslen(sString+currentPos) + 1;
		       currentPos += wcslen(sString+currentPos) + 1;
			}
			else //else this is our string, skip it
			{
				currentPos += wcslen(sString+currentPos) + 1;
			}
		 }
		    //add the ending NULL
		 sTemp[tempPos] = L'\0';

		    //save the new value in the registry
		 len = (tempPos + 1) * sizeof(WCHAR);
         rc = RegSetValueEx(hKey, sLsaValue, 0, type, (LPBYTE)sTemp, len);
		 if (rc == ERROR_SUCCESS)
		    bSuccess = true;
	  }
      RegCloseKey(hKey);
   }

      //tell installer we want to reboot
   MsiSetMode(hInstall, MSIRUNMODE_REBOOTATEND, TRUE);

   return lret;
}
//END DeleteFromLsaNotificationPkgValue


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 23 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for displaying the necessary     *
 * dialogs to prompt for and retrieve a password encryption key off  *
 * of a floppy disk.  This key is placed on a floppy disk via a      *
 * command line option on the ADMT machine.                          *
 *                                                                   *
 *********************************************************************/

//BEGIN FinishWithPassword
PWDMSI_API UINT __stdcall FinishWithPassword(MSIHANDLE hInstall)
{
/* local variables */
   UINT					lret = ERROR_SUCCESS;
   WCHAR				szPropName[MAX_PATH];
   WCHAR				sPwd[MAX_PATH];
   WCHAR				sMsg[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   _bstr_t				sPath;
   WCHAR				sFlagSet[2] = L"1";

/* function body */
      //get the password to try
   wcscpy(szPropName, L"sKeyPassword");
   lret = MsiGetProperty(hInstall, szPropName, sPwd, &nCount);
   if (lret != ERROR_SUCCESS)
      return lret;

      //if no path to file, return
   nCount = MAX_PATH;
   wcscpy(szPropName, L"SENCRYPTIONFILEPATH");
   lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
   if (lret != ERROR_SUCCESS)
      return lret;

   sPath = sMsg;  //save the given path

      //try saving the key with this password
   if (RetrieveAndStorePwdKey(sPwd, sPath))
   {
      wcscpy(szPropName, L"bKeyRetrieved");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);
   }

      //if HES is not installed, set that flag
   if (b3DESNotInstalled)
   {
      wcscpy(szPropName, L"b3DESNotInstalled");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);
   }

/*      //if file not found on the floppy, set that flag
   if (!bPESFileFound)
   {
      wcscpy(szPropName, L"bPESFileNotFound");
      lret = MsiSetProperty(hInstall, szPropName, sFlagSet);
   }
*/
   return lret;
}
//END FinishWithPassword

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 24 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for displaying a MesasgeBox      *
 * the user that the passwords did not match.                        *
 *                                                                   *
 *********************************************************************/

//BEGIN PwdsDontMatch
PWDMSI_API UINT __stdcall PwdsDontMatch(MSIHANDLE hInstall)
{
/* local variables */
   UINT					lret = ERROR_SUCCESS;
   WCHAR				szPropName[MAX_PATH];
   WCHAR				sMsg[MAX_PATH];
   WCHAR				sTitle[MAX_PATH];
   DWORD				nCount = MAX_PATH;
   WCHAR				sEmpty[2] = L"";

/* function body */
      //get the message to display
   wcscpy(szPropName, L"PwdMatchMsg");
   lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
   if (lret != ERROR_SUCCESS)
      wcscpy(sMsg, L"The passwords entered do not match each other.  Please try again!");
        
      //get the title string
   nCount = MAX_PATH;
   wcscpy(szPropName, L"PwdMatchTitle");
   lret = MsiGetProperty(hInstall, szPropName, sTitle, &nCount);
   if (lret != ERROR_SUCCESS)
      wcscpy(sTitle, L"Password Mismatch");

   GetWndFromInstall(hInstall);
   MessageBox(installWnd, sMsg, sTitle, MB_ICONSTOP | MB_OKCANCEL);
   return lret;
}
//END PwdsDontMatch

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 28 MAR 2001                                                 *
 *                                                                   *
 *     This function is responsible for displaying a browse dialog to*
 * aid the install user in finding a password encryption key file,   *
 * which has a .PES extension.                                       *
 *                                                                   *
 *********************************************************************/

//BEGIN BrowseForEncryptionKey
PWDMSI_API UINT __stdcall BrowseForEncryptionKey(MSIHANDLE hInstall)
{
/* local variables */
   UINT					lret = ERROR_SUCCESS;
   WCHAR				szPropName[MAX_PATH];
   WCHAR				sMsg[2*MAX_PATH];
   WCHAR				sFile[2*MAX_PATH];
   DWORD				nCount = 2*MAX_PATH;
   _bstr_t				sPath = L"";
   int					nRet;
   OPENFILENAME         ofn;
   HANDLE               hFile;
   WCHAR				sFilter[MAX_PATH];
   bool					bFile, bFolder = false;

/* function body */
      //get the starting location
   wcscpy(szPropName, L"SENCRYPTIONFILEPATH");
   lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
   if (lret != ERROR_SUCCESS)
   {
      wcscpy(sMsg, L"");
	  bFile = false;
   }
   else
   {
	  WCHAR* pFound = wcsstr(sMsg, L".pes");
	  if (pFound)
	     bFile = true;
	  else
	  {
	     WCHAR* pFound = wcsrchr(sMsg, L'\\');
		 if (pFound)
		 {
//		    *pFound = L'\0';
			bFolder = true;
		 }
	     bFile = false;
	  }
   }
    
      //get a handle to the install
   GetWndFromInstall(hInstall);

      // Initialize OPENFILENAME
   ZeroMemory(&ofn, sizeof(OPENFILENAME));
   ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
   ofn.hwndOwner = installWnd;
   if (bFile)
      ofn.lpstrFile = sMsg;
   else
   {
      wcscpy(sFile, L"");
      ofn.lpstrFile = sFile;
   }
   if (bFolder)
      ofn.lpstrInitialDir = sMsg;
   ofn.nMaxFile = 2*MAX_PATH;
   ofn.lpstrFilter = L"Password Encryption Files (*.pes)\0*.pes\0";
   ofn.nFilterIndex = 0;
   ofn.lpstrFileTitle = NULL;
   ofn.nMaxFileTitle = 0;
   ofn.lpstrInitialDir = NULL;
   ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_LONGNAMES | 
	           OFN_NONETWORKBUTTON;

      // Display the Open dialog box. 
   if (GetOpenFileName(&ofn))
   {
	     //get the given file path
	  sPath = ofn.lpstrFile;
         //set the filepath property
      wcscpy(szPropName, L"sFilePath");
      lret = MsiSetProperty(hInstall, szPropName, sPath);
   }

   return lret;
}
//END BrowseForEncryptionKey

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 28 MAR 2001                                                 *
 *                                                                   *
 *     This function is responsible for setting the                  *
 * "sEncryptionFilePath" property to a default location.  If the     *
 * property is not "None" then we will not set the property.         *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDefaultPathToEncryptionKey
PWDMSI_API UINT __stdcall GetDefaultPathToEncryptionKey(MSIHANDLE hInstall)
{
/* local constants */
   const WCHAR TOKENS[3] = L",\0";

/* local variables */
   _bstr_t				sFloppies;
   WCHAR			  * pDrive;
   HANDLE               hFile;
   WIN32_FIND_DATA      fDat;
   _bstr_t				sPath;
   _bstr_t				sPathSaved = L"";
   _bstr_t				sDrive = L"";
   int					ndx = 0;
   int					ndx2 = 0;
   UINT					lret = ERROR_SUCCESS;
   WCHAR				szPropName[MAX_PATH];
   WCHAR				sMsg[2*MAX_PATH];
   DWORD				nCount = 2*MAX_PATH;

/* function body */
      //if already set don't get again
   wcscpy(szPropName, L"SENCRYPTIONFILEPATH");
   lret = MsiGetProperty(hInstall, szPropName, sMsg, &nCount);
   if ((lret == ERROR_SUCCESS) && (wcscmp(sMsg, L"None")))
      return lret;

      //enumerate all local drives
   sDrive = EnumLocalDrives();
      //check each drive for the file
   pDrive = wcstok((WCHAR*)sDrive, TOKENS);
   while (pDrive != NULL)
   {
      if (ndx == 0)
         sPathSaved = pDrive;
      ndx++;

	     //see if a .pes file is on this drive
	  sPath = pDrive;
	  sPath += L"*.pes";
	  hFile = FindFirstFile((WCHAR*)sPath, &fDat);
         //if found, store the file path
	  if (hFile != INVALID_HANDLE_VALUE)
	  {
         FindClose(hFile);
			//get the data
	     sPath = pDrive;
	     sPath += fDat.cFileName;
		 if (ndx2 == 0)
		    sPathSaved = sPath;
		 ndx2++;
	  }
         //get the next drive
      pDrive = wcstok(NULL, TOKENS);
   }

      //set the filepath property
   wcscpy(szPropName, L"SENCRYPTIONFILEPATH");
   lret = MsiSetProperty(hInstall, szPropName, sPathSaved);

   return lret;
}
//END GetDefaultPathToEncryptionKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\setup\pwdmsi\pwdmsi.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the PWDMSI_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// PWDMSI_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef PWDMSI_EXPORTS
#define PWDMSI_API __declspec(dllexport)
#else
#define PWDMSI_API __declspec(dllimport)
#endif

// This class is exported from the PwdMsi.dll
class PWDMSI_API CPwdMsi {
public:
	CPwdMsi(void);
	// TODO: add your methods here.
};

PWDMSI_API UINT __stdcall IsDC(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall DisplayExiting(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall DeleteOldFiles(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall GetInstallEncryptionKey(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall AddToLsaNotificationPkgValue(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall DeleteFromLsaNotificationPkgValue(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall FinishWithPassword(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall PwdsDontMatch(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall BrowseForEncryptionKey(MSIHANDLE hInstall);
PWDMSI_API UINT __stdcall GetDefaultPathToEncryptionKey(MSIHANDLE hInstall);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( UpdateMOT )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( UpdateMOT ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\introdlg.cpp ===
// IntroDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "IntroDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIntroDlg dialog


CIntroDlg::CIntroDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CIntroDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CIntroDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CIntroDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIntroDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	DDX_Control(pDX, IDOK, m_NextBtn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIntroDlg, CDialog)
	//{{AFX_MSG_MAP(CIntroDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIntroDlg message handlers

void CIntroDlg::OnCancel() 
{
	// TODO: Add extra cleanup here
	CString msg, title;
	title.LoadString(IDS_EXIT_TITLE);
	msg.LoadString(IDS_EXIT_MSG);
	if (MessageBox(msg, title, MB_YESNO | MB_ICONQUESTION) == IDYES)
	   CDialog::OnCancel();
}

void CIntroDlg::OnOK() 
{
	// TODO: Add extra validation here
	CDialog::OnOK();
}

BOOL CIntroDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\domainlistdlg.h ===
#if !defined(AFX_DOMAINLISTDLG_H__7BEF53AE_FF9A_4626_9DF5_669D2190E700__INCLUDED_)
#define AFX_DOMAINLISTDLG_H__7BEF53AE_FF9A_4626_9DF5_669D2190E700__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DomainListDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDomainListDlg dialog

class CDomainListDlg : public CDialog
{
// Construction
public:
	CDomainListDlg(CWnd* pParent = NULL);   // standard constructor

	void SetDomainListPtr(CStringList * pList) {pDomainList = pList;}
	void SetExcludeListPtr(CStringList * pList) {pExcludeList = pList;}

// Dialog Data
	//{{AFX_DATA(CDomainListDlg)
	enum { IDD = IDD_DOMAINLIST_DLG };
	CTreeCtrl	m_domainTree;
	CButton	m_NextBtn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainListDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringList * pDomainList; //pointer to a list of domains in the table 
	CStringList * pExcludeList; //pointer to a list of domains excluded 
	BOOL	bExcludeOne; 

	// Generated message map functions
	//{{AFX_MSG(CDomainListDlg)
	virtual BOOL OnInitDialog();
	virtual void OnCancel();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void FillTreeControl();
    void ModifyDomainList(); 
	HTREEITEM AddOneItem(HTREEITEM hParent, LPTSTR szText);
	void AddExclutedBackToList();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DOMAINLISTDLG_H__7BEF53AE_FF9A_4626_9DF5_669D2190E700__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\introdlg.h ===
#if !defined(AFX_INTRODLG_H__1F3FDB56_7F34_4051_8A50_F8910DC93498__INCLUDED_)
#define AFX_INTRODLG_H__1F3FDB56_7F34_4051_8A50_F8910DC93498__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// IntroDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIntroDlg dialog

class CIntroDlg : public CDialog
{
// Construction
public:
	CIntroDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CIntroDlg)
	enum { IDD = IDD_UPDATEMOT_INTRO };
	CButton	m_NextBtn;
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIntroDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CIntroDlg)
	virtual void OnCancel();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INTRODLG_H__1F3FDB56_7F34_4051_8A50_F8910DC93498__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\domainlistdlg.cpp ===
// DomainListDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "DomainListDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDomainListDlg dialog


CDomainListDlg::CDomainListDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDomainListDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDomainListDlg)
	//}}AFX_DATA_INIT
	bExcludeOne = FALSE;
}


void CDomainListDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDomainListDlg)
	DDX_Control(pDX, IDC_DOMAINTREE, m_domainTree);
	DDX_Control(pDX, IDOK, m_NextBtn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDomainListDlg, CDialog)
	//{{AFX_MSG_MAP(CDomainListDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDomainListDlg message handlers

BOOL CDomainListDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
		//fill the tree control
	FillTreeControl();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDomainListDlg::OnCancel() 
{
	// TODO: Add extra cleanup here
	CString msg, title;
	title.LoadString(IDS_EXIT_TITLE);
	msg.LoadString(IDS_EXIT_MSG);
	if (MessageBox(msg, title, MB_YESNO | MB_ICONQUESTION) == IDYES)
	   CDialog::OnCancel();
}

void CDomainListDlg::OnOK() 
{
	CString msg, title;
	// TODO: Add extra validation here
	   //remove deselected items from the domain list
    ModifyDomainList();
	   //if at least one domain was deselected, post a warning message
	if (bExcludeOne)
	{
	   title.LoadString(IDS_EXCLUDE_TITLE);
	   msg.LoadString(IDS_EXCLUDE_MSG);
	   if (MessageBox(msg, title, MB_YESNO | MB_ICONQUESTION) == IDYES)
	      CDialog::OnOK();
	   else
		   AddExclutedBackToList();
	}
	else
	   CDialog::OnOK();
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 17 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CDomainListDlg class is *
 * responsible for displaying all domains in the Protar database's   *
 * MigratedObjects table.                                            *
 *                                                                   *
 *********************************************************************/

//BEGIN FillTreeControl
void CDomainListDlg::FillTreeControl() 
{
/* local variables */
	POSITION currentPos;    //current position in the list
	CString domainName;     //name of domain from the list
	WCHAR sName[MAX_PATH];  //name in string format to pass to tree control

/* function body */
	CWaitCursor wait; //Put up a wait cursor

	    //make sure the checkbox sytle is set for this tree control
	long lStyles = GetWindowLong(m_domainTree.m_hWnd, GWL_STYLE);
	   //if checkbox style is not set, set it
	if (!(lStyles & TVS_CHECKBOXES))
	{
	   lStyles = lStyles | TVS_CHECKBOXES;
	   SetWindowLong(m_domainTree.m_hWnd, GWL_STYLE, lStyles);
	}

		//get the position and string of the first name in the list
	currentPos = pDomainList->GetHeadPosition();

		//while there is another entry to retrieve from the list, then 
		//get a name from the list and add it to the tree control
	while (currentPos != NULL)
	{
			//get the next string in the list, starts with the first
		domainName = pDomainList->GetNext(currentPos);
		wcscpy(sName, (LPCTSTR)domainName);
  	    AddOneItem((HTREEITEM)TVI_ROOT, sName);
	}

	wait.~CWaitCursor();  //remove the wait cursor
}
//END FillTreeControl


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 17 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CDomainListDlg class is *
 * responsible for adding one item to the tree control in the        *
 * specified place.                                                  *
 *                                                                   *
 *********************************************************************/

//BEGIN AddOneItem
HTREEITEM CDomainListDlg::AddOneItem(HTREEITEM hParent, LPTSTR szText)
{
/* local variables */
	HTREEITEM hItem;
	TV_INSERTSTRUCT tvstruct;

/* function body */
	// fill the tree control
	tvstruct.hParent				= hParent;
	tvstruct.hInsertAfter			= TVI_SORT;
	tvstruct.item.pszText			= szText;
	tvstruct.item.cchTextMax		= MAX_PATH;
	tvstruct.item.mask				= TVIF_TEXT | TVIF_STATE;
	tvstruct.item.state				= INDEXTOSTATEIMAGEMASK(2);
	tvstruct.item.stateMask			= TVIS_STATEIMAGEMASK;
	hItem = m_domainTree.InsertItem(&tvstruct);

		//make sure item is checked
	m_domainTree.SetCheck(hItem, TRUE);

	return (hItem);
}
//END AddOneItem


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 17 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CDomainListDlg class is *
 * responsible for removing list entries if they where deselected in *
 * the tree control.                                                 *
 *                                                                   *
 *********************************************************************/

//BEGIN ModifyDomainList
void CDomainListDlg::ModifyDomainList() 
{
/* local variables */
    HTREEITEM hItem;        //current tree control item
	POSITION currentPos;    //current position in the list
	CString domainName;     //name of domain from the list
	UINT ndx;               //for loop counter

/* function body */
	CWaitCursor wait; //Put up a wait cursor

		//get the number of entries in the tree control
	for (ndx=0; ndx < m_domainTree.GetCount(); ndx++)
	{
	   if (ndx == 0)
          hItem = m_domainTree.GetNextItem(NULL, TVGN_CHILD);
	   else
          hItem = m_domainTree.GetNextItem(hItem, TVGN_NEXT);

	   domainName = m_domainTree.GetItemText(hItem);
	      //if deselected, remove from the list and add to the excluded list
	   if (m_domainTree.GetCheck(hItem) == 0)
	   {
	         //if we find the string in the list, remove it
		  currentPos = pDomainList->Find(domainName);
		  if (currentPos != NULL)
		  {
			  pDomainList->RemoveAt(currentPos);
			  pExcludeList->AddTail(domainName);
		  }
          bExcludeOne = TRUE; //set class flag to tell one is excluded
	   }
	}

	wait.~CWaitCursor();  //remove the wait cursor
}
//END ModifyDomainList


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CDomainListDlg class is *
 * responsible for taking the domain names out of the excluded list  *
 * and placing it back into the domain list.                         *
 *                                                                   *
 *********************************************************************/

//BEGIN AddExclutedBackToList
void CDomainListDlg::AddExclutedBackToList() 
{
/* local variables */
	POSITION currentPos;    //current position in the list
	CString domainName;     //name of domain from the list
/* function body */
    currentPos = pExcludeList->GetHeadPosition();
	while (currentPos != NULL)
	{
	   domainName = pExcludeList->GetNext(currentPos);
	   pDomainList->AddTail(domainName);
	}
	pExcludeList->RemoveAll();
}
//END AddExclutedBackToList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\progressdlg.cpp ===
// ProgressDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "ProgressDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog


CProgressDlg::CProgressDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CProgressDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CProgressDlg)
	m_domainName = _T("");
	//}}AFX_DATA_INIT

	m_pParent = pParent;
	m_nID = CProgressDlg::IDD;
}


void CProgressDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProgressDlg)
	DDX_Control(pDX, IDC_PROGRESS1, m_progressCtrl);
	DDX_Control(pDX, IDC_DOMAIN_NAME, m_DomainCtrl);
	DDX_Text(pDX, IDC_DOMAIN_NAME, m_domainName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProgressDlg, CDialog)
	//{{AFX_MSG_MAP(CProgressDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg message handlers

BOOL CProgressDlg::OnInitDialog() 
{
	const int START = 0;

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
    lowerLimit = 0;
	upperLimit = 100;
    bCanceled = FALSE;	//clear the "has the user canceled" flag
    m_progressCtrl.SetPos(START); //start the progress control at the beginning
	m_domainName = L"";
    UpdateData(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CProgressDlg::OnCancel() 
{
	// TODO: Add extra cleanup here
    bCanceled = TRUE;  //set the "has the user canceled" flag	
//	CDialog::OnCancel();
}

BOOL CProgressDlg::Create()
{
	return CDialog::Create(m_nID, m_pParent);
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This public member function of the CProgressDlg class is      *
 * responsible for trying to grab this dialog's messages from the    *
 * message queue and dispatch them.  We are having to do this in     *
 * order to receive a hit on the Cancel button.                      *
 *                                                                   *
 *********************************************************************/

//BEGIN CheckForCancel
void CProgressDlg::CheckForCancel(void)
{
/* local constants */

/* local variables */
   MSG aMsg;

/* function body */
   while (PeekMessage(&aMsg, m_hWnd, 0, 0, PM_REMOVE))
   {
	   if (!PreTranslateMessage(&aMsg))
	   {
		   TranslateMessage(&aMsg);
		   DispatchMessage(&aMsg);
	   }
   }
}//END CheckForCancel

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This public member function of the CProgressDlg class is      *
 * responsible for setting the amount the progress control will      *
 * advance per single step based on the number of domains to process.*
 *                                                                   *
 *********************************************************************/

//BEGIN SetIncrement
void CProgressDlg::SetIncrement(int numDomains)
{
/* local constants */
	const short MIN_STEPS = 10;

/* local variables */

/* function body */
   lowerLimit = 0;
   upperLimit = (short)numDomains * MIN_STEPS;
   m_progressCtrl.SetRange(lowerLimit, upperLimit);
   m_progressCtrl.SetStep(MIN_STEPS);

   UpdateWindow(); //force a paint of the dialog
}//END SetIncrement
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\progressdlg.h ===
#if !defined(AFX_PROGRESSDLG_H__226A22DA_6109_406B_9532_8BAB28EE559F__INCLUDED_)
#define AFX_PROGRESSDLG_H__226A22DA_6109_406B_9532_8BAB28EE559F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ProgressDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

class CProgressDlg : public CDialog
{
// Construction
public:
	CProgressDlg(CWnd* pParent = NULL);   // standard constructor
	BOOL Create();
	void SetIncrement(int numDomains);
	void Increment() {m_progressCtrl.StepIt();UpdateData(FALSE);Sleep(2000);};
	void Done() {m_progressCtrl.SetPos(upperLimit);UpdateData(FALSE);Sleep(2000);};
	void SetDomain(CString domainName) {m_domainName = domainName;UpdateData(FALSE);};
	BOOL Canceled() {return bCanceled;};
	void CheckForCancel(void);

// Dialog Data
	//{{AFX_DATA(CProgressDlg)
	enum { IDD = IDD_PROGRESSDLG };
	CProgressCtrl	m_progressCtrl;
	CStatic	m_DomainCtrl;
	CString	m_domainName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgressDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	CWnd* m_pParent;
	int m_nID;
	short upperLimit, lowerLimit;

	// Generated message map functions
	//{{AFX_MSG(CProgressDlg)
	virtual BOOL OnInitDialog();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	BOOL bCanceled;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGRESSDLG_H__226A22DA_6109_406B_9532_8BAB28EE559F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\srcsidupdate.cpp ===
// SrcSidUpdate.cpp : Implementation of CSrcSidUpdate
#include "stdafx.h"
#include "UpdateMOT.h"
#include "SrcSidUpdate.h"
#include "IntroDlg.h"
#include "DomainListDlg.h"
#include "ProgressDlg.h"
#include "SummaryDlg.h"

#import "DBMgr.tlb" no_namespace,named_guids
#import "VarSet.tlb" no_namespace , named_guids rename("property", "aproperty")

/////////////////////////////////////////////////////////////////////////////
// CSrcSidUpdate


STDMETHODIMP CSrcSidUpdate::QueryForSrcSidColumn(VARIANT_BOOL *pbFound)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   HRESULT                   hr = S_OK;
   
   try 
   {
      IIManageDBPtr   pDB(CLSID_IManageDB);
	    //see if column is already in the database
      *pbFound = pDB->SrcSidColumnInMigratedObjectsTable();
   }
   catch(_com_error& e)
   {
      hr = e.Error();
   }
   catch(...)
   {
      hr = E_FAIL;
   }

   return hr;
}

STDMETHODIMP CSrcSidUpdate::CreateSrcSidColumn(VARIANT_BOOL bHide, VARIANT_BOOL *pbCreated)
{
	HRESULT hr = S_OK;
	BOOL bAgain = TRUE; //flag used to redo upon cancel

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	   //retrieve a list of domains from the MigratedObjects table
	hr = FillDomainListFromMOT();
    if ( FAILED(hr) )
	{
	   *pbCreated = VARIANT_FALSE;
	   return E_FAIL;
	}

	   //if the MOT is empty, just add the new column without the GUI
	if (domainList.IsEmpty())
	{
       try 
	   {
          IIManageDBPtr   pDB(CLSID_IManageDB);
	         //create the new column in the MigratedObjects table
          hr = pDB->raw_CreateSrcSidColumnInMOT(pbCreated);
          if ( FAILED(hr) )
	         *pbCreated = VARIANT_FALSE; //column not created
		  else
             *pbCreated = VARIANT_TRUE; //column is created

	   }//end try
       catch(_com_error& e)
	   {
          hr = e.Error();
       }
       catch(...)
	   {
          hr = E_FAIL;
	   }

	   return hr;
	}

	   //if hide the GUI, try populating for all domains in the MOT
	if (bHide)
	{
       try 
	   {
          IIManageDBPtr   pDB(CLSID_IManageDB);
	         //create the new column in the MigratedObjects table
          hr = pDB->raw_CreateSrcSidColumnInMOT(pbCreated);
          if ( FAILED(hr) )
		  {
	         *pbCreated = VARIANT_FALSE;
	         return hr;
		  }

          *pbCreated = VARIANT_TRUE; //column is created

	      CString domainName;

	      POSITION pos = domainList.GetHeadPosition();
	        //while we have domains to process, populate that domain
	      while (pos != NULL)
		  {
		        //get the next domain name
             domainName = domainList.GetNext(pos);

		        //populate the new column for this domain
             pDB->PopulateSrcSidColumnByDomain(domainName.AllocSysString(), L"");
		  }
	   }//end try
       catch(_com_error& e)
	   {
          hr = e.Error();
       }
       catch(...)
	   {
          hr = E_FAIL;
	   }

	   return hr;
	}//end if hide

	   //display the intro dialog
    CIntroDlg  introDlg;
    if (introDlg.DoModal() == IDCANCEL)
	{
	   *pbCreated = VARIANT_FALSE;
	   return S_OK;
	}

	   //do atleast once and again if cancel on the progress dialog
	while (bAgain)
	{
	   bAgain = FALSE; //clear flag so we don't do this again
	   
          //pass the list to the dialog for display
       CDomainListDlg  domainListDlg;
       domainListDlg.SetDomainListPtr(&domainList);
       domainListDlg.SetExcludeListPtr(&excludeList);

	      //now display the domain selection dialog
       if (domainListDlg.DoModal() == IDCANCEL)
	   {
	      *pbCreated = VARIANT_FALSE;
	      return S_OK;
	   }

       try 
	   {
          IIManageDBPtr   pDB(CLSID_IManageDB);
	         //create the new column in the MigratedObjects table
          hr = pDB->raw_CreateSrcSidColumnInMOT(pbCreated);
          if ( FAILED(hr) )
		  {
	         *pbCreated = VARIANT_FALSE;
	         return hr;
		  }

          *pbCreated = VARIANT_TRUE; //column is created

		     //display the progress dialog
	      CProgressDlg progressDlg;
          progressDlg.Create();
		  progressDlg.ShowWindow(SW_SHOW);
	      progressDlg.SetIncrement((int)(domainList.GetCount())); //init the progress dialog

	      CString domainName;
	      VARIANT_BOOL bPopulated;

	      POSITION pos = domainList.GetHeadPosition();
			 //process dialog's messages (looking specifically for Cancel message)
		  progressDlg.CheckForCancel();
	        //while we have domains to process and user has not canceled,
	        //process each domain and control the progress dialog
	      while ((pos != NULL) && (!progressDlg.Canceled()))
		  {
		        //get the next domain name
             domainName = domainList.GetNext(pos);
		        //set the domain name on the progress dialog
		     progressDlg.SetDomain(domainName);

			 CWaitCursor wait; //Put up a wait cursor
		        //populate the new column for this domain
             bPopulated = pDB->PopulateSrcSidColumnByDomain(domainName.AllocSysString(), L"");
	         wait.~CWaitCursor();//remove the wait cursor

		        //if populate of the column was successful, add the domain
			    //name to the populate list
		     if (bPopulated)
		        populatedList.AddTail(domainName);

			    //process dialog's messages (looking specifically for Cancel message)
		     progressDlg.CheckForCancel();

			    //increment the progress dialog regardless of success
		     if (pos == NULL)
			 {
		        progressDlg.Done();
			    progressDlg.DestroyWindow();
			 }
		     else
                progressDlg.Increment();
		  }
		     //if canceled, delete the new column, clear the lists, and
		     //start over
	      if (progressDlg.Canceled())
		  {
		        //remove the column and return to the domain list dialog
			 VARIANT_BOOL bDeleted = pDB->DeleteSrcSidColumnInMOT();
			 
			    //reinitalize the lists
		     ReInitializeLists();

	         bAgain = TRUE; //set flag to try again
		  }
	   }//end try
       catch(_com_error& e)
	   {
          hr = e.Error();
       }
       catch(...)
	   {
          hr = E_FAIL;
	   }
	}//end while cancel

	   //display the summary dialog
    CSummaryDlg summaryDlg;
    summaryDlg.SetDomainListPtr(&domainList);
    summaryDlg.SetExcludeListPtr(&excludeList);
    summaryDlg.SetPopulatedListPtr(&populatedList);
    summaryDlg.DoModal();

	return hr;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 18 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CSrcSidUpdate class is  *
 * responsible for adding domains from the Protar database's         *
 * MigratedObjects table into the domain list.                       *
 *                                                                   *
 *********************************************************************/

//BEGIN FillDomainListFromMOT
HRESULT CSrcSidUpdate::FillDomainListFromMOT()
{
/* local variables */
   HRESULT                   hr = S_OK;
   IUnknown                * pUnk = NULL;
   long						 ndx, numObjects;
   _bstr_t                   srcDom;
   CString					 domainName;
   POSITION					 currentPos; 
   WCHAR                     strKey[MAX_PATH];

/* function body */
   try 
   {
      IVarSetPtr      pVarSet(CLSID_VarSet);
      IIManageDBPtr   pDB(CLSID_IManageDB);

      hr = pVarSet->QueryInterface(IID_IUnknown,(void**)&pUnk);
      if ( SUCCEEDED(hr) )
      {
		    //get all migrated objects into a varset
         hr = pDB->raw_GetMigratedObjectsFromOldMOT(-1,&pUnk);
      }
      if ( SUCCEEDED(hr) )
      {
         pVarSet = pUnk;
         pUnk->Release();

		 numObjects = pVarSet->get(L"MigratedObjects");

			//for each migrated object, save its source domain in the list
         for ( ndx = 0; ndx < numObjects; ndx++ )
         {
			   //get the source domain name
            swprintf(strKey,L"MigratedObjects.%ld.%s",ndx,L"SourceDomain");
            srcDom = pVarSet->get(strKey);
			   //add the name to the list, if not already in it
			domainName = (WCHAR*)srcDom;
		    currentPos = domainList.Find(domainName);
		    if (currentPos == NULL)
			   domainList.AddTail(domainName);
         }
	  }//end if got objects
   }
   catch(_com_error& e)
   {
      hr = e.Error();
   }
   catch(...)
   {
      hr = E_FAIL;
   }

   return hr;

}//END FillDomainListFromMOT


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CDomainListDlg class is *
 * responsible for taking the domain names out of the excluded list  *
 * and placing it back into the domain list.                         *
 *                                                                   *
 *********************************************************************/

//BEGIN ReInitializeLists
void CSrcSidUpdate::ReInitializeLists() 
{
/* local variables */
	POSITION currentPos;    //current position in the list
	CString domainName;     //name of domain from the list
/* function body */
    currentPos = excludeList.GetHeadPosition();
	while (currentPos != NULL)
	{
	   domainName = excludeList.GetNext(currentPos);
	   domainList.AddTail(domainName);
	}
	excludeList.RemoveAll();
	populatedList.RemoveAll();
}
//END ReInitializeLists
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UpdateMOT.rc
//
#define IDS_PROJNAME                    100
#define IDS_EXIT_MSG                    101
#define IDR_SRCSIDUPDATE                102
#define IDS_EXIT_TITLE                  102
#define IDS_EXCLUDE_TITLE               103
#define IDS_EXCLUDE_MSG                 104
#define IDS_POP_YES                     105
#define IDS_POP_NO                      106
#define IDS_DOMAIN_COLUMN_TITLE         107
#define IDS_POPULATED_COLUMN_TITLE      108
#define IDS_EXCLUDED_COLUMN_TITLE       109
#define IDD_UPDATEMOT_INTRO             201
#define IDD_DOMAINLIST_DLG              202
#define IDC_DOMAINTREE                  202
#define IDC_PROGRESS1                   203
#define IDD_PROGRESSDLG                 203
#define IDC_DOMAIN_NAME                 204
#define IDD_SUMMARYDLG                  204
#define IDC_BACK                        205
#define IDC_STATIC1                     207
#define IDC_BUTTON2                     209
#define IDC_LIST1                       210
#define IDC_DOMAINLIST                  210
#define IDC_PROGRESS2                   211

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         212
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\srcsidupdate.h ===
// SrcSidUpdate.h : Declaration of the CSrcSidUpdate

#ifndef __SRCSIDUPDATE_H_
#define __SRCSIDUPDATE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSrcSidUpdate
class ATL_NO_VTABLE CSrcSidUpdate : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSrcSidUpdate, &CLSID_SrcSidUpdate>,
	public IDispatchImpl<ISrcSidUpdate, &IID_ISrcSidUpdate, &LIBID_UPDATEMOTLib>
{
public:
	CSrcSidUpdate()
	{
		domainList.RemoveAll();
		excludeList.RemoveAll();
		populatedList.RemoveAll();
	}

    ~CSrcSidUpdate()
	{
		domainList.RemoveAll();
		excludeList.RemoveAll();
		populatedList.RemoveAll();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SRCSIDUPDATE)
DECLARE_NOT_AGGREGATABLE(CSrcSidUpdate)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSrcSidUpdate)
	COM_INTERFACE_ENTRY(ISrcSidUpdate)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISrcSidUpdate
public:
	STDMETHOD(CreateSrcSidColumn)(/*[in]*/ VARIANT_BOOL bHide, /*[out, retval]*/ VARIANT_BOOL * pbCreated);
	STDMETHOD(QueryForSrcSidColumn)(/*[out, retval]*/ VARIANT_BOOL * pbFound);
private:
	CStringList domainList;
	CStringList excludeList;
	CStringList populatedList;
	HRESULT FillDomainListFromMOT();
	void ReInitializeLists();
};

#endif //__SRCSIDUPDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A2BDC2E3_2144_478D_947D_D1671A5BA298__INCLUDED_)
#define AFX_STDAFX_H__A2BDC2E3_2144_478D_947D_D1671A5BA298__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A2BDC2E3_2144_478D_947D_D1671A5BA298__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\summarydlg.cpp ===
// SummaryDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "SummaryDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSummaryDlg dialog


CSummaryDlg::CSummaryDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSummaryDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSummaryDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CSummaryDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSummaryDlg)
	DDX_Control(pDX, IDC_DOMAINLIST, m_listCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSummaryDlg, CDialog)
	//{{AFX_MSG_MAP(CSummaryDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSummaryDlg message handlers

BOOL CSummaryDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	   //Add columns and information to the list control
    CreateListCtrlColumns();
	AddDomainsToList();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CSummaryDlg class is    *
 * responsible for adding the domains in the 3 lists into the list   *
 * control.  Those domains in the populated list are also in the     *
 * domain list, therefore they are ignored in the domain list        *
 * processing.                                                       *
 *                                                                   *
 *********************************************************************/

//BEGIN AddDomainsToList
void CSummaryDlg::AddDomainsToList() 
{
/* local constants */
    const int POPULATE_COLUMN = 1;
    const int EXCLUDE_COLUMN = 2;

/* local variables */
	POSITION currentPos;    //current position in the list
	POSITION pos;           //position in the domain list
	CString domainName;     //name of domain from the list
	CString Text;           //CString holder
	int nlistNum = 0;       //current list item being added
	int ndx = 0;            //while loop counter
	LVITEM aItem;           //list control item to insert
	WCHAR sText[MAX_PATH];  //holds string to add

/* function body */
	  //add the domains that were successfully populated (and remove
	  //from the domain list)
    currentPos = pPopulatedList->GetHeadPosition();
	while (ndx < pPopulatedList->GetCount())
	{
		  //get domain name
	   domainName = pPopulatedList->GetNext(currentPos);
	      //insert in list control
	   aItem.iItem = ndx;
	   aItem.iSubItem = 0;
	   aItem.mask = LVIF_TEXT;
	   wcscpy(sText, (LPCTSTR)domainName);
	   aItem.pszText = sText;
       m_listCtrl.InsertItem(&aItem);
		  //add populated status
	   Text.LoadString(IDS_POP_YES);
	   wcscpy(sText, (LPCTSTR)Text);
	   m_listCtrl.SetItemText(ndx, POPULATE_COLUMN, sText);
		  //add excluded status
	   Text.LoadString(IDS_POP_NO);
	   wcscpy(sText, (LPCTSTR)Text);
	   m_listCtrl.SetItemText(ndx, EXCLUDE_COLUMN, sText);
		  //remove from the domain list
	   if ((pos = pDomainList->Find(domainName)) != NULL)
		  pDomainList->RemoveAt(pos);
	   ndx++;
	}

	  //add the domains that were not successfully populated and remain
	  //in the domain list
	nlistNum = ndx;
	ndx = 0;
    currentPos = pDomainList->GetHeadPosition();
	while (ndx < pDomainList->GetCount())
	{
		  //get domain name
	   domainName = pDomainList->GetNext(currentPos);
	      //insert in list control
	   aItem.iItem = nlistNum + ndx;
	   aItem.iSubItem = 0;
	   aItem.mask = LVIF_TEXT;
	   wcscpy(sText, (LPCTSTR)domainName);
	   aItem.pszText = sText;
       m_listCtrl.InsertItem(&aItem);
		  //add populated status
	   Text.LoadString(IDS_POP_NO);
	   wcscpy(sText, (LPCTSTR)Text);
	   m_listCtrl.SetItemText(nlistNum+ndx, POPULATE_COLUMN, sText);
		  //add excluded status
	   m_listCtrl.SetItemText(nlistNum+ndx, EXCLUDE_COLUMN, sText);
	   ndx++;
	}

	  //add the domains that were excluded
	nlistNum += ndx;
	ndx = 0;
    currentPos = pExcludeList->GetHeadPosition();
	while (ndx < pExcludeList->GetCount())
	{
		  //get domain name
	   domainName = pExcludeList->GetNext(currentPos);
	      //insert in list control
	   aItem.iItem = nlistNum + ndx;
	   aItem.iSubItem = 0;
	   aItem.mask = LVIF_TEXT;
	   wcscpy(sText, (LPCTSTR)domainName);
	   aItem.pszText = sText;
       m_listCtrl.InsertItem(&aItem);
		  //add populated status
	   Text.LoadString(IDS_POP_NO);
	   wcscpy(sText, (LPCTSTR)Text);
	   m_listCtrl.SetItemText(nlistNum+ndx, POPULATE_COLUMN, sText);
		  //add excluded status
	   Text.LoadString(IDS_POP_YES);
	   wcscpy(sText, (LPCTSTR)Text);
	   m_listCtrl.SetItemText(nlistNum+ndx, EXCLUDE_COLUMN, sText);
	   ndx++;
	}
}
//END AddDomainsToList


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CSummaryDlg class is    *
 * responsible for adding the columns to the summary's list control. *
 *                                                                   *
 *********************************************************************/

//BEGIN CreateListCtrlColumns
void CSummaryDlg::CreateListCtrlColumns() 
{
/* local constants */

/* local variables */
   CString Text;
   CRect rect;
   int columnWidth;

/* function body */
      //get the width in pixels of the CListCtrl
   m_listCtrl.GetWindowRect(&rect);
   
	  //create the domain name column
   Text.LoadString(IDS_DOMAIN_COLUMN_TITLE);
   columnWidth = (int)(rect.Width() * 0.6);
   m_listCtrl.InsertColumn(0, Text, LVCFMT_LEFT, columnWidth);

      //create the populated Yes/No column
   Text.LoadString(IDS_POPULATED_COLUMN_TITLE);
   columnWidth = (int)((rect.Width() - columnWidth) / 2);
   columnWidth -= 1; //make it fit in the control without a scrollbar
   m_listCtrl.InsertColumn(1, Text, LVCFMT_CENTER, columnWidth);

      //create the populated Yes/No column
   Text.LoadString(IDS_EXCLUDED_COLUMN_TITLE);
   columnWidth -= 1; //make it fit in the control without a scrollbar
   m_listCtrl.InsertColumn(2, Text, LVCFMT_CENTER, columnWidth);

   UpdateData(FALSE);
}
//END CreateListCtrlColumns
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\summarydlg.h ===
#if !defined(AFX_SUMMARYDLG_H__0AFEFC3C_9E2B_4988_8FF8_618EFA4F99C3__INCLUDED_)
#define AFX_SUMMARYDLG_H__0AFEFC3C_9E2B_4988_8FF8_618EFA4F99C3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SummaryDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSummaryDlg dialog

class CSummaryDlg : public CDialog
{
// Construction
public:
	CSummaryDlg(CWnd* pParent = NULL);   // standard constructor

	void SetDomainListPtr(CStringList * pList) {pDomainList = pList;}
	void SetExcludeListPtr(CStringList * pList) {pExcludeList = pList;}
	void SetPopulatedListPtr(CStringList * pList) {pPopulatedList = pList;}

// Dialog Data
	//{{AFX_DATA(CSummaryDlg)
	enum { IDD = IDD_SUMMARYDLG };
	CListCtrl	m_listCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSummaryDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringList * pDomainList; //pointer to a list of domains in the table 
	CStringList * pExcludeList; //pointer to a list of domains excluded 
	CStringList * pPopulatedList; //pointer to a list of domains successfully populated 

	// Generated message map functions
	//{{AFX_MSG(CSummaryDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void AddDomainsToList(void);
    void CreateListCtrlColumns(void);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SUMMARYDLG_H__0AFEFC3C_9E2B_4988_8FF8_618EFA4F99C3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\updatemot\updatemot.cpp ===
// UpdateMOT.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f UpdateMOTps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "UpdateMOT.h"

#include "UpdateMOT_i.c"
#include "SrcSidUpdate.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SrcSidUpdate, CSrcSidUpdate)
END_OBJECT_MAP()

class CUpdateMOTApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUpdateMOTApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CUpdateMOTApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CUpdateMOTApp, CWinApp)
	//{{AFX_MSG_MAP(CUpdateMOTApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CUpdateMOTApp theApp;

BOOL CUpdateMOTApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance, &LIBID_UPDATEMOTLib);
    return CWinApp::InitInstance();
}

int CUpdateMOTApp::ExitInstance()
{
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
//#include "McsVarSetMin_p.c"
#include "VarSet_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__8B94B5D4_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED_)
#define AFX_DLLDATAX_H__8B94B5D4_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__8B94B5D4_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VSMin.rc
//
#define IDS_PROJNAME                    100
#define IDR_VSET                        101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\nomcs.h ===
#ifndef __NOMCSCOMMON_H__
#define __NOMCSCOMMON_H__
/*---------------------------------------------------------------------------
  File: NoMcsCommon.h

  Comments: A minimal set of definitions for code which cannot depend on McsCommon.
  This is a temporary hack, to allow the McsVarSet COM object to be installed without requiring 
  a reboot.  McsCommon requires MSVCP60.DLL, which requires an updated version of MSVCRT.DLL, 
  which is in use by NETAPI32.DLL, and thus requires a reboot to update.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 04/28/99 16:18:12

 ---------------------------------------------------------------------------
*/


#define MC_LOGGING(level) false
#define MC_LogBlockPtrIf(level, str)
#define MC_LOGBLOCKIF(level, str) 
#define MC_LOGBLOCK(str) 
#define MC_LogBlockPtr(str)
#define MC_LOGIF(level, info) do {}while(0)
#define MC_LOGALWAYS(info) do {}while(0)
#define MC_LOG(info) do {}while(0)
#define MC_LOGTEMPCONTEXT(new_context) 

#include <assert.h>

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#define MCSASSERT(expr) assert(expr)

#define MCSASSERTSZ(expr,msg) assert(expr)

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#define MCSEXCEPTION(expr) MCSASSERT(expr)

#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#define MCSVERIFY(expr) MCSASSERT(expr)

#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)

#define MCSINC_Mcs_h

#endif //__NOMCSCOMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include <ResStr.h>

StringLoader gString;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\dotstr.cpp ===
/*---------------------------------------------------------------------------
  File: DottedString.cpp

  Comments: Utility class used to parse dot-delimited strings

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 17:23:47

 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "DotStr.hpp"

/////////////////////////////////////////////////////
// Utility class used to parse dot-delimited strings
/////////////////////////////////////////////////////


void 
   CDottedString::Init()
{
   // count the number of segments
   m_nSegments = 1;
   for ( int i = 0 ; i < m_name.GetLength() ; i++ )
   {
      if ( m_name[i] == _T('.') )
      {
         m_nSegments++;
      }
   }
   // special case for empty string
   if ( m_name.IsEmpty() )
   {
      m_nSegments = 0;
   }
}

void 
   CDottedString::GetSegment(
      int                    ndx,          // in - which segment to get (first=0)
      CString              & str           // out- segment, or empty string if ndx is not valid
   )
{
   int                       n = ndx;
   int                       x;
   
   str = _T("");

   if ( ndx >= 0 && ndx < m_nSegments )
   {
      str = m_name;

      while ( n )
      {
//         x = str.Find(_T("."),0);
         x = str.Find(_T("."));
         str = str.Right(str.GetLength() - x - 1);
         n--;
      }
//      x = str.Find(_T("."),0);
      x = str.Find(_T("."));
      if ( x >= 0 )
      {
         str = str.Left(x);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\dotstr.hpp ===
/*---------------------------------------------------------------------------
  File: DottedString.hpp

  Comments: Utility class used by VarSet to parse dot-delimited strings.
  Uses CString.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 17:24:11

 ---------------------------------------------------------------------------
*/

#ifndef __CDOTTEDSTRING_HPP__
#define __CDOTTEDSTRING_HPP__

/////////////////////////////////////////////////////
// Utility class used to parse dot-delimited strings
/////////////////////////////////////////////////////
class CDottedString
{
   CString                    m_name;
   int                       m_nSegments;

public:
            CDottedString(BSTR str)    { m_name = str; Init(); }
            CDottedString(TCHAR const * str) { m_name = str; Init();}

   int      NumSegments() { return m_nSegments; }
   void     GetSegment(int ndx,CString & str);

protected:
   void     Init();  // counts the number of segments
};

#endif //__CPROPSTRING_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "StdAfx.h"
#ifdef _WIN64
#include "McsDebug.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8B94B5CC_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__8B94B5CC_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0351
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
//#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define VARSET_LOGLEVEL_CLIENT      3
#define VARSET_LOGLEVEL_INTERNAL    4


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8B94B5CC_FE44_11D2_A1E8_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\vardata.cpp ===
/*---------------------------------------------------------------------------
  File: VarData.cpp

  Comments: CVarData represents one level in the VarSet.  It has a variant
  value, and a map containing one or more subvalues.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 17:24:56

 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "VarData.h"
#include "VarMap.h"
#include "DotStr.hpp"

#ifdef STRIPPED_VARSET
   #include "Varset.h"
   #include "NoMcs.h"  
#else
   #include <VarSet.h>
   #include "McString.h"
   #include "McLog.h"
   using namespace McString;
#endif
#include "VSet.h"
#include <comdef.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


int    
   CVarData::SetData(
      CString                key,          // in - key value
      VARIANT              * var,          // in - data value
      BOOL                   bCoerce,      // in - flag, whether to coerce to a persistable value
      HRESULT              * pResult       // out- optional return code
   )
{
   int                       nCreated = 0;
   _variant_t                newVal(var);
   HRESULT                   hr = S_OK;

   if ( key.IsEmpty() )
   {
      m_cs.Lock();
      // set my data value
      if ( ! bCoerce )
      {
         m_var.Copy(&newVal);   
      }
      else
      {
         // need to coerce the value to an appropriate type
      
         if ( var->vt == VT_DISPATCH  || var->vt == VT_UNKNOWN )
         {
            // if it's an IUnknown, see if it supports IDispatch
            IDispatchPtr               pDisp;

            pDisp = newVal;

            if ( pDisp != NULL )
            {
               // the object supports IDispatch
               // try to get the default property
               _variant_t              defPropVar;
               DISPPARAMS              dispParamsNoArgs = {NULL, NULL, 0, 0};

               hr = pDisp->Invoke(0,
                                  IID_NULL,
                                  LOCALE_USER_DEFAULT,
                                  DISPATCH_PROPERTYGET,
                                  &dispParamsNoArgs,
                                  &defPropVar,
                                  NULL,
                                  NULL);
               if ( SUCCEEDED(hr) )
               {
                  // we got the default property
                  newVal = defPropVar;
               }
               else
               {
                  MC_LOG("VarSet::put - unable to retrieve default property for IDispatch object.  Put operation failed, hr=" << hr << "returning E_INVALIDARG");
                  hr = E_INVALIDARG;
               }
            }
         }
         if ( SUCCEEDED(hr) )
         {
            if ( newVal.vt & VT_BYREF )
            {
               if ( newVal.vt == (VT_VARIANT | VT_BYREF) )
               {
                  m_var.Copy(newVal.pvarVal);   
               }
               else
               {
                  hr = ::VariantChangeType(&newVal,&newVal,0,newVal.vt & ~VT_BYREF);
                  if ( SUCCEEDED(hr) )
                  {
                     m_var.Copy(&newVal);   
                  }
                  else
                  {
                     MC_LOG("VarSet::put - failed to dereference variant of type " << newVal.vt << ".  Put operation failed, hr=" <<hr);
                     hr = E_INVALIDARG;
                  }
               }
            }
            else 
            {
               m_var.Copy(&newVal);
            }
         }
      }
      m_cs.Unlock();
   }
   else
   {
      // set the value for a child

      CDottedString          s(key);
      CString                seg;
      CVarData             * pObj;
      CVarData             * pChild;

      s.GetSegment(0,seg);
   
      m_cs.Lock();
      if ( ! m_children )
      {
         // create the child map if it does not exist
         m_children = new CMapStringToVar(IsCaseSensitive(),IsIndexed(), AllowRehashing() );
         if (!m_children)
		 {
            m_cs.Unlock();
            return nCreated;
		 }
      }
      // look for the first segment of the entry in the child map
      if ( ! m_children->Lookup(seg,pObj) )
      {
         // add it if it doesn't exist
         pChild = new CVarData;
         if (!pChild)
		 {
            m_cs.Unlock();
            return nCreated;
		 }
         pChild->SetCaseSensitive(IsCaseSensitive());
         pChild->SetAllowRehashing(AllowRehashing());
         pChild->SetIndexed(IsIndexed());
         m_children->SetAt(seg,pChild);
         nCreated++; // we added a new node
      }
      else
      {
         pChild = (CVarData*)pObj;
      }
      // strip off the first segment from the property name, and call SetData
      // recursively on the child item
      nCreated += pChild->SetData(key.Right(key.GetLength() - seg.GetLength()-1),var,bCoerce,&hr);
      m_cs.Unlock();
   }
   if ( pResult )
   {
      (*pResult) = hr;
   }
   return nCreated;
}

void 
   CVarData::RemoveAll()
{
   // remove all children from the map
   m_cs.Lock();
   if ( m_children && ! m_children->IsEmpty() )
   {
      // Enumerate the MAP and delete each object
      POSITION               pos;
      CString                key;
      CVarData             * pObj;

      pos = m_children->GetStartPosition();

      while ( pos )
      {
         m_children->GetNextAssoc(pos,key,pObj);
         if ( pObj )
         {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
            delete pObj;
         }
      }
      m_children->RemoveAll();
   }
   if ( m_children )
   {
      delete m_children;
      m_children = NULL;
   }
   m_cs.Unlock();
}

BOOL                                         // ret- TRUE if key exists in the map
   CVarData::Lookup(
      LPCTSTR                key,            // in - key to search for
      CVarData            *& rValue          // out- value
   ) 
{ 
   if ( m_children ) 
   { 
      return m_children->Lookup(key,rValue); 
   } 
   else 
   {
      return FALSE; 
   }
}

BOOL                                        // ret- TRUE if there are sub-items for this node
   CVarData::HasChildren() 
{ 
   return m_children && !m_children->IsEmpty(); 
}

void 
   CVarData::SetAt(
      LPCTSTR                key,            // in - key 
      CVarData             * newValue        // in - new value
   ) 
{ 
   if ( ! m_children ) 
   { 
      // create map to hold children if it doesn't already exist
      m_children = new CMapStringToVar(IsCaseSensitive(),IsIndexed(),AllowRehashing()); 
      if (!m_children)
         return;
   }
   m_children->SetAt(key,newValue); 
}

void 
   CVarData::SetIndexed(
      BOOL                   nVal
   )
{
   if ( m_children )
   {
      m_children->SetIndexed(nVal);
   }
   if ( nVal )
   {
      m_options |= CVARDATA_INDEXED;
   }
   else
   {
      m_options &= ~CVARDATA_INDEXED;
   }
}
                           
void 
   CVarData::SetCaseSensitive(
      BOOL                   nVal           // in - whether to make lookups case-sensitive
  )
{ 
   if ( m_children ) 
   {
      m_children->SetCaseSensitive(nVal); 
   }
   if ( nVal )
   {
      m_options |= CVARDATA_CASE_SENSITIVE;
   }
   else
   {
      m_options &= ~CVARDATA_CASE_SENSITIVE;
   }
}

void 
   CVarData::SetAllowRehashing(
      BOOL                   nVal           // in - whether to allow the table to be rehashed for better performance
  )
{ 
   if ( m_children ) 
   {
      m_children->SetAllowRehash(nVal); 
   }
   if ( nVal )
   {
      m_options |= CVARDATA_ALLOWREHASH;
   }
   else
   {
      m_options &= ~CVARDATA_ALLOWREHASH;
   }
}




HRESULT 
   CVarData::WriteToStream(
      LPSTREAM               pS            // in - stream to write data to
   )
{
   HRESULT                   hr = S_OK;
   BOOL                      hasChildren = (m_children != NULL);
   
   // save the variant
   hr = m_var.WriteToStream(pS);
   
   if (SUCCEEDED(hr) )
   {
      // save children, if any
      ULONG                result;
      hr = pS->Write(&hasChildren,(sizeof hasChildren),&result);
      if ( SUCCEEDED(hr) )
      {
         if ( m_children )
         {
            hr = m_children->WriteToStream(pS);
         }
      }
   }
   
   return 0;
}

HRESULT 
   CVarData::ReadFromStream(
      LPSTREAM               pS            // in - stream to read data from
   )
{
   HRESULT                   hr = S_OK;
   BOOL                      hasChildren;
   ULONG                     result;

   // read the variant
   hr = m_var.ReadFromStream(pS);
   if ( SUCCEEDED(hr) )
   {
      hr = pS->Read(&hasChildren,(sizeof hasChildren),&result);
      if ( SUCCEEDED(hr) )
      {
         if ( hasChildren )
         {
            // create the child array
            m_children = new CMapStringToVar(IsCaseSensitive(),IsIndexed(),AllowRehashing());
            if (!m_children)
               return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            hr = m_children->ReadFromStream(pS);
         }
      }

   }
   return hr;
}

DWORD                                      // ret- Length, in bytes to write the data to a stream
   CVarData::CalculateStreamedLength()
{
   HRESULT                   hr =S_OK;
   DWORD                     len = sizeof (VARTYPE);
   
   // Calculate size needed for root data value

   int cbWrite = 0;
	switch (m_var.vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
	   {
         CComQIPtr<IPersistStream> spStream = m_var.punkVal;
         if( spStream )                
         {
            len += sizeof(CLSID);
            ULARGE_INTEGER  uiSize = { 0 };
            hr = spStream->GetSizeMax(&uiSize);
            if (FAILED(hr))                        
               return hr;
            len += uiSize.LowPart;                
         }            
      }
      break;
   case VT_UI1:
	case VT_I1:
		cbWrite = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbWrite = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbWrite = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbWrite = sizeof(double);
		break;
	default:
		break;
	}
	
   CComBSTR bstrWrite;
	CComVariant varBSTR;
	
   if (m_var.vt != VT_BSTR)
	{
		hr = VariantChangeType(&varBSTR, &m_var, VARIANT_NOVALUEPROP, VT_BSTR);
		if (FAILED(hr))
			return hr;
		bstrWrite = varBSTR.bstrVal;
	}
	else
   {
      bstrWrite = m_var.bstrVal;
   }
   len += 4 + (static_cast<BSTR>(bstrWrite) ? SysStringByteLen(bstrWrite) : 0) + 2;
   if ( SUCCEEDED(hr) )
   {
      len += cbWrite;
   }
   
   // Add sizes of children
   len += (sizeof BOOL); // has children?
   if ( m_children )
   {
      len += m_children->CalculateStreamedLength();
   }

   return len;
}

long                                       // ret- number of data items
   CVarData::CountItems()
{
   long                      count = 1;

   if ( m_children )
   {
      count += m_children->CountItems();
   }

   return count;
}

void 
   CVarData::McLogInternalDiagnostics(
      CString                keyname       // in - Key name for this subtree, so the complete name can be displayed
   )
{
   CString value;

   switch ( m_var.vt )
   {
      case VT_EMPTY:      
         value = _T("<Empty>");
         break;
      case VT_NULL:
         value = _T("<Null>");
         break;
      case VT_I2:
      case VT_I4:
         value.Format(_T("%ld"),m_var.iVal);
         break;
      case VT_BSTR:
         value = m_var.bstrVal;
         break;
      default:
         value.Format(_T("variant type=0x%lx"),m_var.vt);
         break;
   }
   MC_LOG(String(keyname) << "-->"<< String(value) << (m_children ? " (Has Children)" : " (No Children)") << " Options = " << makeStr(m_options) << " CaseSensitive=" << ( IsCaseSensitive()?"TRUE":"FALSE") << " Indexed=" << (IsIndexed()?"TRUE":"FALSE") );

   if ( m_children )
   {
      m_children->McLogInternalDiagnostics(keyname);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\vardata.h ===
/*---------------------------------------------------------------------------
  File: VarData.h

  Comments: This class makes up one level of data in the VarSet.  
            A CVarData consists of a variant value, and a (possibly empty) set of children.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 17:29:30

 ---------------------------------------------------------------------------
*/

#ifndef __CBBVAROBJ_HPP__
#define __CBBVAROBJ_HPP__

#define CVARDATA_CASE_SENSITIVE (0x01)
#define CVARDATA_INDEXED        (0x02)
#define CVARDATA_ALLOWREHASH    (0x04)

#include <atlbase.h>

class CMapStringToVar;

class CVarData //: public CObject
{
   CComAutoCriticalSection   m_cs;
   CComVariant               m_var;
   CMapStringToVar         * m_children; 
   BYTE                      m_options;
public:
//   CVarData() : m_children(NULL) {m_options = CVARDATA_CASE_SENSITIVE | CVARDATA_INDEXED | CVARDATA_ALLOWREHASH; };
// Gene Allen 99.04.22  Changed default from Case sensitive to case insensitive
  CVarData() : m_children(NULL) {m_options = CVARDATA_INDEXED | CVARDATA_ALLOWREHASH; };
   ~CVarData() { RemoveAll(); } 
   
   // Variant data functions
   CComVariant * GetData() { return &m_var; }         
   int           SetData(CString name,VARIANT * var,BOOL bCoerce, HRESULT * pReturnCode);  // returns the number of new items (& subitems) added to the VarSet
   
   // Property settings
   BOOL          IsCaseSensitive() { return m_options & CVARDATA_CASE_SENSITIVE; }
   BOOL          IsIndexed() { return m_options & CVARDATA_INDEXED; }
   BOOL          AllowRehashing() { return m_options & CVARDATA_ALLOWREHASH; }

   void          SetIndexed(BOOL v);
   void          SetCaseSensitive(BOOL nVal);  // only applies to child items
   void          SetAllowRehashing(BOOL v);    // only applies to child items
   // sub-element map functions
   BOOL                    HasChildren();
   BOOL                    HasData() { return m_var.vt != VT_EMPTY; }
   CMapStringToVar       * GetChildren() { return m_children; }
   void                    RemoveAll();   // deletes all children
   
   BOOL                    Lookup(LPCTSTR key,CVarData *& rValue);
   void                    SetAt(LPCTSTR key, CVarData * newValue);
   
   long                    CountItems();
   
   // Stream i/o functions
   HRESULT                 ReadFromStream(LPSTREAM pStr);
   HRESULT                 WriteToStream(LPSTREAM pStr);

   DWORD                   CalculateStreamedLength();

   void                    McLogInternalDiagnostics(CString keyName);
   
   //DECLARE_SERIAL(CVarData)
};

#endif //__CBBVAROBJ_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\varmap.cpp ===
/*---------------------------------------------------------------------------
  File: VarMap.cpp

  Comments: This class implements a hash table which contains the keys stored in the varset,
      along with their values.

      CaseSensitive property - The case of each key is preserved as it was when
      the key was first added to the map.  The hash function is not case sensitive,
      so the CaseSensitive property can be toggled on and off without rehashing the data.
      
      Optional indexing to allow for fast enumeration in alphabetical order by key.
      This will add overhead to insert operations.  Without indexing, the contents of 
      the map can be enumerated, but they will be in arbitrary order.

      Stream I/O functions for persistance.



  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 18:31:57

 ---------------------------------------------------------------------------
*/


#include "stdafx.h"
#include <afx.h>
#include <afxplex_.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "VarMap.h"

#ifdef STRIPPED_VARSET
   #include "NoMcs.h"
#else
   #pragma warning (push,3)
   #include "McString.h" 
   #include "McLog.h"
   #pragma warning (pop)
   using namespace McString;
#endif

static inline void FreeString(CString* pOldData)
{
	pOldData->~CString();
}


const UINT HashSizes[] = { 17, 251, 1049, 10753, 100417, 1299673 , 0 };


CMapStringToVar::CMapStringToVar(BOOL isCaseSensitive, BOOL isIndexed, BOOL allowRehash,int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = HashSizes[0];  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
   m_CaseSensitive = isCaseSensitive;
   m_Indexed = isIndexed;
   m_AllowRehash = allowRehash;
}

inline UINT CMapStringToVar::HashKey(LPCTSTR key) const
{
	UINT nHash = 0;
	while (*key)
   {
      nHash = (nHash<<5) + nHash + toupper(*key++);
   }
	return nHash;
}

void CMapStringToVar::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CHashItem* [nHashSize];
		if (!m_pHashTable)
		   return;
		memset(m_pHashTable, 0, sizeof(CHashItem*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

void CMapStringToVar::ResizeTable()
{
   // get the new size
   UINT                      nHashSize = 0;
   
   // find the current hash size in the array
   for ( int i = 0 ; HashSizes[i] <= m_nHashTableSize ; i++ )
   {
      if ( HashSizes[i] == m_nHashTableSize )
      {
         nHashSize = HashSizes[i+1];
         break;
      }
   }
   if ( nHashSize )
   {
      MC_LOGIF(VARSET_LOGLEVEL_INTERNAL,"Increasing hash size to "<< makeStr(nHashSize) );
      CHashItem ** oldHashTable = m_pHashTable;
      m_pHashTable = new CHashItem* [nHashSize];
	  if (!m_pHashTable)
	     return;
      memset(m_pHashTable,0, sizeof(CHashItem*) * nHashSize );
      // Rehash the existing items into the new table
      for ( UINT bucket = 0 ; bucket < m_nHashTableSize ; bucket++ )
      {
         CHashItem* pAssoc;
         CHashItem* pNext;

			for (pAssoc = oldHashTable[bucket]; pAssoc != NULL; pAssoc = pNext)
			{
			   pNext = pAssoc->pNext;
            // Re-hash, and insert into new table
            pAssoc->nHashValue = HashKey(pAssoc->key) % nHashSize;
            pAssoc->pNext = m_pHashTable[pAssoc->nHashValue];
            m_pHashTable[pAssoc->nHashValue] = pAssoc;
         }
			
      }
      // cleanup the old table 
      delete [] oldHashTable;
      m_nHashTableSize = nHashSize;
   }
   else
   {
      MC_LOG("Table size is "<< makeStr(m_nHashTableSize) << ".  Larger hash size not found, disabling rehashing.");
      m_AllowRehash = FALSE;
   }

}

void CMapStringToVar::RemoveAll()
{

	if ( m_Indexed )
   {
      m_Index.RemoveAll();
   }
	if (m_pHashTable != NULL)
	{
		// remove and destroy each element
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CHashItem* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				FreeString(&pAssoc->key);  

			}
		}

		// free hash table
		delete [] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapStringToVar::~CMapStringToVar()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers

CHashItem*
CMapStringToVar::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
							sizeof(CHashItem));
		// chain them into free list
		CHashItem* pAssoc = (CHashItem*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CHashItem* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
	memcpy(&pAssoc->key, &afxEmptyString, sizeof(CString));

	pAssoc->value = 0;

	return pAssoc;
}

void CMapStringToVar::FreeAssoc(CHashItem* pAssoc)
{
	FreeString(&pAssoc->key);  // free up string data

	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	MCSASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

CHashItem*
CMapStringToVar::GetAssocAt(LPCTSTR key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CHashItem* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
	   if ( m_CaseSensitive )
      {
         if (pAssoc->key == key)
			   return pAssoc;
      }
      else
      {
         if ( ! pAssoc->key.CompareNoCase(key) )
            return pAssoc;
      }
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////

BOOL CMapStringToVar::Lookup(LPCTSTR key, CVarData*& rValue) const
{
	ASSERT_VALID(this);

	UINT nHash;
   CHashItem* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

BOOL CMapStringToVar::LookupKey(LPCTSTR key, LPCTSTR& rKey) const
{
	ASSERT_VALID(this);

	UINT nHash;
	CHashItem* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rKey = pAssoc->key;
	return TRUE;
}

CVarData*& CMapStringToVar::operator[](LPCTSTR key)
{
	ASSERT_VALID(this);

	UINT nHash;
	CHashItem* pAssoc;
   // Grow the hash table, if necessary	
   if ( m_AllowRehash && ( m_nCount > 2 * m_nHashTableSize )  )
   {
      ResizeTable();
   }
   if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
      if ( m_Indexed )
      {
         pAssoc->pIndex = m_Index.Insert(pAssoc);
      }
      else
      {
         pAssoc->pIndex = NULL;
      }
	}
	
   return pAssoc->value;  // return new reference
}

void CMapStringToVar::SetIndexed(BOOL val)
{
   POSITION                  pos = GetStartPosition();
   CString                   key;
   CVarData                * value;
   
   
   if ( ! m_Indexed && val ) 
   {
       BuildIndex(); 
   }
   m_Indexed = val;  
   
   // recursively update children
   while ( pos )
   {
      GetNextAssoc(pos,key,value);
      if ( value )
      {
         value->SetIndexed(val);
      }   
   }
}


void CMapStringToVar::BuildIndex()
{
   // delete any old entries
   m_Index.RemoveAll();
   
   CHashItem               * pAssoc;
   POSITION                  pos = GetStartPosition();
   CString                   key;
   CVarData                * value;
   UINT                      hash;
   
   while ( pos )
   {
      GetNextAssoc(pos,key,value);
      pAssoc = GetAssocAt(key,hash);
      if ( pAssoc )
      {
         pAssoc->pIndex = m_Index.Insert(pAssoc);
         if ( value->HasChildren() )
         {
            value->GetChildren()->SetIndexed(TRUE);
         }
      }   
   }

}

BOOL CMapStringToVar::RemoveKey(LPCTSTR key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CHashItem** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

	CHashItem* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
      if ( (m_CaseSensitive && (pAssoc->key == key) || !m_CaseSensitive && pAssoc->key.CompareNoCase(key) ) )
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

/////////////////////////////////////////////////////////////////////////////
// Iterating

void CMapStringToVar::GetNextAssoc(POSITION& rNextPosition,
	CString& rKey, CVarData*& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CHashItem* pAssocRet = (CHashItem*)rNextPosition;
	ASSERT(pAssocRet != NULL);

	if (pAssocRet == (CHashItem*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		ASSERT(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CHashItem)));
	CHashItem* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// Serialization

void CMapStringToVar::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		if (m_nCount == 0)
			return;  // nothing more to do

		ASSERT(m_pHashTable != NULL);
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CHashItem* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
//				ar << pAssoc->key;
			//	ar << pAssoc->value;
			}
		}
	}
	else
	{
//		DWORD nNewCount = ar.ReadCount();
//		CString newKey;
//		CVarData* newValue;
//		while (nNewCount--)
//		{
	//		ar >> newKey;
		//	ar >> newValue;
		//	SetAt(newKey, newValue);
//		}
	}
}

void CMapStringToVar::McLogInternalDiagnostics(CString keyName)
{
   MC_LOGBLOCK("HashTable");
   MC_LOG("   " << String(keyName) << "Count="<<makeStr(m_nCount) << " Case Sensitive="<< (m_CaseSensitive?"TRUE":"FALSE") << " Indexed="<<(m_Indexed?"TRUE":"FALSE") );
   
   MC_LOG("TableSize="<<makeStr(m_nHashTableSize));
   for ( UINT i = 0 ; i < m_nHashTableSize ; i++ )
   {
      CHashItem            * pAssoc;
      MC_LOG("Bucket " << makeStr(i));
      for ( pAssoc = m_pHashTable[i] ; pAssoc != NULL ; pAssoc=pAssoc->pNext)
      {
         if ( pAssoc->value )
         {
            CString subKey;
            subKey = keyName;
            if ( ! subKey.IsEmpty() )
            {
               subKey += _T(".");
            }
            subKey += pAssoc->key;
            pAssoc->value->McLogInternalDiagnostics(subKey);
         }

         if ( keyName.IsEmpty() )
         {
            MC_LOG("   Address="<< makeStr(pAssoc,L"0x%lx") << " Key="<< String(pAssoc->key));
         }
         else
         {
            MC_LOG("   Address="<< makeStr(pAssoc,L"0x%lx") << " Key="<< String(keyName) << "."<< String(pAssoc->key));
         }


         MC_LOG("   ValueAddress=" << makeStr(pAssoc->value,L"0x%lx") << " IndexAddress="<<makeStr(pAssoc->pIndex,L"0x%lx"));
         
      }
   }
   if ( m_Indexed )
   {
      m_Index.McLogInternalDiagnostics(keyName);
   }
}
HRESULT CMapStringToVar::WriteToStream(LPSTREAM pS)
{
   HRESULT                   hr;
   ULONG                     result;
   CComBSTR                  str;

   do {
      hr = pS->Write(&m_nCount,(sizeof m_nCount),&result);
      if ( FAILED(hr) ) 
         break;
      if ( m_nCount )
      {
         for ( UINT nHash = 0 ; nHash < m_nHashTableSize ; nHash++ )
         {
            CHashItem         * pAssoc;
            
            for ( pAssoc = m_pHashTable[nHash]; pAssoc != NULL ; pAssoc=pAssoc->pNext)
            {
               // write the key
               str = pAssoc->key;
               hr = str.WriteToStream(pS);
               if ( FAILED(hr) )
                  break;
               // then the value
               hr = pAssoc->value->WriteToStream(pS);
               if ( FAILED(hr) )
                  break;
            }
            if ( FAILED(hr) )
               break;
         }
      }
   }while ( FALSE );

   return hr;
}


HRESULT CMapStringToVar::ReadFromStream(LPSTREAM pS)
{
   HRESULT                   hr;
   ULONG                     result;
   CComBSTR                  str;
   int                       count;
   do {
      hr = pS->Read(&count,(sizeof count),&result);
      if ( FAILED(hr) ) 
         break;
      
      if ( count )
      {
         // Find the closest hash table size to our count
         UINT                nHashSize = HashSizes[0];
   
      
         for ( int size = 0 ; HashSizes[size] != 0 && nHashSize < (UINT)count ; size++ )
         {
            nHashSize = HashSizes[size];
         }
   
         InitHashTable(nHashSize);
         for ( int i = 0 ; i < count ; i++ )
         {
            CString             key;
            CVarData          * pObj = new CVarData;
			if (!pObj)
	           return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

            pObj->SetCaseSensitive(m_CaseSensitive);
            pObj->SetIndexed(m_Indexed);
            hr = str.ReadFromStream(pS);
            if ( FAILED(hr) )
               break;
            key = str;      
            str.Empty();
            hr = pObj->ReadFromStream(pS);
            if ( FAILED(hr) )
               break;
            SetAt(key,pObj);
         }
      }
   }while ( FALSE );
   return hr;
}

DWORD 
   CMapStringToVar::CalculateStreamedLength()
{
   DWORD                     len = (sizeof m_nCount);

   if ( m_nCount )
   {
      for ( UINT nHash = 0 ; nHash < m_nHashTableSize ; nHash++ )
      {
         CHashItem         * pAssoc;
         
         for ( pAssoc = m_pHashTable[nHash]; pAssoc != NULL ; pAssoc=pAssoc->pNext)
         {
            // add the length of the string
            len += (sizeof TCHAR)*(pAssoc->key.GetLength() + 2);
            
            // and the value
            if ( pAssoc->value)
            {
               len += pAssoc->value->CalculateStreamedLength();
            }
         }
      }
   }

   return len;
}

long 
   CMapStringToVar::CountItems()
{
   long                      count = 0;

   if ( m_nCount )
   {
      for ( UINT nHash = 0 ; nHash < m_nHashTableSize ; nHash++ )
      {
         CHashItem         * pAssoc;
         
         for ( pAssoc = m_pHashTable[nHash]; pAssoc != NULL ; pAssoc=pAssoc->pNext)
         {
            // add the length of the string
            count += pAssoc->value->CountItems();
         }
      }
   }
   return count;   
}
/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CMapStringToVar::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nCount << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		CString   key;
		CVarData* val;

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			dc << "\n\t[" << key << "] = " << val;
		}
	}

	dc << "\n";
}

void CMapStringToVar::AssertValid() const
{
	CObject::AssertValid();

	if ( m_Indexed )
   {
      //m_Index.AssertValid(m_nCount);
   }
   ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif


IMPLEMENT_SERIAL(CMapStringToVar, CObject, 0)

// BEGIN - STUFF FROM PLEX.CPP
/////////////////////////////////////////////////////////////////////////////
// CPlex

CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
	if (!p)
	   return NULL;
			// may throw exception
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
	CPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}

// END - STUFF FROM PLEX.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\varndx.h ===
#ifndef __VARMAPINDEX_H__
#define __VARMAPINDEX_H__
/*---------------------------------------------------------------------------
  File: VarMapIndex.h

  Comments: Helper class for CMapStringToVar.

  CIndexTree implements a sorted, balanced binary tree.  This is used by CMapStringToVar
  to provide enumeration in sorted order by key.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 18:01:34

 ---------------------------------------------------------------------------
*/

#include "VarData.h"

class CHashItem;
class CIndexTree;

class CIndexItem
{
friend class CIndexTree;
   CHashItem               * pData;
   CIndexItem              * pLeft;
   CIndexItem              * pRight;
   CIndexItem              * pParent;
   BOOL                      red;
public:
   CVarData*      GetValue(); 
   CString        GetKey();   

protected:
   CIndexItem(CHashItem*pd) { pData = pd; pLeft = NULL; pRight = NULL; pParent = NULL; red = FALSE;}
   CHashItem*    Data() { return pData; }   
   CIndexItem*   Left() { return pLeft; }
   CIndexItem*   Right() { return pRight; }
   CIndexItem*   Parent() { return pParent; } 
   BOOL     IsRed() { return red; }
   void     Left(CIndexItem* l) { pLeft = l; }
   void     Right(CIndexItem* r) { pRight = r; }
   void     Parent(CIndexItem* par) { pParent = par; }
   void     Data(CHashItem* p) { pData=p; }
   void     Red(BOOL rd = TRUE) { red = rd; }
   void     Black(BOOL blk = TRUE) { red = !blk; }
   void     McLogInternalDiagnostics(CString keyName,int depth);
};


typedef int CompareFunction(CIndexItem* i1,CIndexItem* i2);

typedef int CompareKeyFunction(CString s, CIndexItem* i);

extern CompareFunction CompareItems;
extern CompareKeyFunction CompareStringToItem;

extern CompareFunction CompareItemsNoCase;
extern CompareKeyFunction CompareStringToItemNoCase;

class CIndexTree
{
   friend class CMapStringToVar;

   CIndexItem*          m_root;
   CompareFunction*     m_Compare;
   CompareKeyFunction*  m_CompareKey;
   BOOL                 m_CaseSensitive;


protected:
   CIndexTree(CompareFunction * comp = &CompareItems, CompareKeyFunction * kc = &CompareStringToItem) 
   { 
      m_root = NULL; 
      m_Compare = comp; 
      m_CompareKey = kc; 
      m_CaseSensitive = TRUE;
   }
   ~CIndexTree() { RemoveAll(); }
   
public:
   
   CIndexItem* GetFirstItem() const { CIndexItem * curr = m_root; while ( curr && curr->Left() ) curr = curr->Left(); return curr; }
   CIndexItem* GetPrevItem(CIndexItem*curr) const;
   CIndexItem* GetNextItem(CIndexItem*curr) const;
   CIndexItem* GetFirstAfter(CString value) const;

   void McLogInternalDiagnostics(CString keyName);
#ifdef _DEBUG
   BOOL AssertValid(int nItems) const;
#endif


protected:
   // functions called by CMapStringToVar to add/remove items from the tree
   void RemoveAll();
   CIndexItem * Insert(CHashItem* data);
   void SetCompareFunctions(CompareFunction * f, CompareKeyFunction * kc) { m_Compare = f; m_CompareKey = kc; }
   
   // Helper functions to maintain tree structure
   void LeftRotate(CIndexItem* item);
   void RightRotate(CIndexItem* item);
   void RemoveHelper(CIndexItem* item);
};



#endif //__VARMAPINDEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\vset.h ===
/*---------------------------------------------------------------------------
  File: VSet.h

  Comments: Class definition for CVSet, which implements the IVarSet interface.

  (c) Copyright 1995-1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 19:44:31

 ---------------------------------------------------------------------------
*/

	
// VSet.h : Declaration of the CVSet

#ifndef __VSET_H_
#define __VSET_H_

#include "resource.h"       // main symbols

#ifdef STRIPPED_VARSET 
   #include "NoMcs.h"
#else
   #include "Mcs.h"
#endif
#include "VarData.h"

#define VARSET_RESTRICT_NOCHANGEDATA      (0x00000001)
#define VARSET_RESTRICT_NOCHANGEPROPS     (0x00000002)
#define VARSET_RESTRICT_ALL               (0x00000003)

/////////////////////////////////////////////////////////////////////////////
// CVSet
class ATL_NO_VTABLE CVSet : 
	public CComObjectRootEx<CComMultiThreadModel>,
   public CComCoClass<CVSet, &CLSID_VarSet>,
	public ISupportErrorInfoImpl<&IID_IVarSet>,
#ifdef STRIPPED_VARSET
	public IDispatchImpl<IVarSet, &IID_IVarSet, &LIBID_MCSVARSETMINLib>,
#else
	public IDispatchImpl<IVarSet, &IID_IVarSet, &LIBID_MCSVARSETLib>,
#endif 
   public IPersistStorageImpl<CVSet>,
   public IPersistStreamInit,
   public IPersistStream,
   public IMarshal
{
public:
	CVSet()
	{
		m_data = new CVarData;
      m_pUnkMarshaler = NULL;
      m_nItems = 0;
      m_bLoaded = FALSE;
      m_parent = NULL;
      m_Restrictions = 0;
      m_ImmutableRestrictions = 0;
      InitProperties();
   }
   
   ~CVSet()
   {
      if ( m_parent )
      {
         m_parent->Release();
      }
      else
      {
         Clear();
         delete m_data;
      }
   }
DECLARE_REGISTRY_RESOURCEID(IDR_VSET)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVSet)
	COM_INTERFACE_ENTRY(IVarSet)
   COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
  	COM_INTERFACE_ENTRY(IPersistStreamInit)
   COM_INTERFACE_ENTRY(IPersistStream)
   COM_INTERFACE_ENTRY(IMarshal)
   COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
  	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
   {
		return CoCreateFreeThreadedMarshaler(
		GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
   
// IVSet
public:
   
   STDMETHOD(get)(/* [in] */BSTR property,/* [retval][out] */VARIANT * value);
   STDMETHOD(put)(/* [in] */BSTR property,/* [in] */VARIANT value);
   STDMETHOD(putObject)(/* [in] */BSTR property,/* [in] */VARIANT value);

   STDMETHOD(Clear)();
   
   // Enum methods
   STDMETHOD(get__NewEnum)(/* [retval][out] */IUnknown** retval);
 	STDMETHOD(getItems)(/* [in] */BSTR basepoint,
                       /* [in] */BSTR startAfter, 
                       /* [in] */BOOL bRecursive,
                       /* [in] */ULONG bSize, 
                       /* [out] */SAFEARRAY ** keys, 
                       /* [out] */SAFEARRAY ** values, 
                       /* [out][in] */LONG * nReturned);

   STDMETHOD(getItems2)(/* [in] */VARIANT basepoint,
                       /* [in] */VARIANT startAfter, 
                       /* [in] */VARIANT bRecursive,
                       /* [in] */VARIANT bSize, 
                       /* [out] */VARIANT * keys, 
                       /* [out] */VARIANT * values, 
                       /* [out][in] */VARIANT * nReturned);

   
   // properties
   STDMETHOD(get_NumChildren)(/* [in] */BSTR parentKey,/* [out,retval] */long*count);
   STDMETHOD(get_Count)(/* [retval][out] */long* retval);
   
   STDMETHOD(get_CaseSensitive)(/* [retval][out] */BOOL * isCaseSensitive);
   STDMETHOD(put_CaseSensitive)( /* [in] */BOOL newVal);
   STDMETHOD(get_Indexed)(/* [out, retval]*/ BOOL *pVal);
	STDMETHOD(put_Indexed)(/* [in] */ BOOL newVal);
   STDMETHOD(get_AllowRehashing)(/* [out, retval]*/ BOOL *pVal);
	STDMETHOD(put_AllowRehashing)(/* [in] */ BOOL newVal);
   STDMETHOD(DumpToFile)( /* [in] */ BSTR filename);
   STDMETHOD(ImportSubTree)(/*[in] */ BSTR key, /* [in] */ IVarSet * pVarSet);
   STDMETHOD(getReference)( /* [in] */ BSTR key, /* [out,retval] */IVarSet** cookie);
   STDMETHOD(get_Restrictions)(/* [out,retval] */ DWORD * restrictions);
   STDMETHOD(put_Restrictions)(/* [in] */ DWORD newRestrictions);

protected:
   CComAutoCriticalSection       m_cs;
   LONG                          m_nItems;
   
   // Properties
   BOOL                          m_CaseSensitive;
   BOOL                          m_Indexed;
   BOOL                          m_AllowRehashing;
   BOOL                          m_bNeedToSave;
   BOOL                          m_bLoaded;
   
   IVarSet                     * m_parent;
   CVarData                    * m_data;
   CComBSTR                      m_prefix;
   DWORD                         m_Restrictions;
   DWORD                         m_ImmutableRestrictions;
   // Helper functions
   void BuildVariantKeyArray(CString prefix,CMapStringToVar * map,CComVariant * pVars,int * offset);
   void BuildVariantKeyValueArray(CString prefix,CString startAfter,CMapStringToVar * map,
                     SAFEARRAY * keys,SAFEARRAY * pVars,int * offset,int maxOffset, BOOL bRecurse);
   CVarData * GetItem(CString str,BOOL addToMap = FALSE, CVarData * starting = NULL);
   void InitProperties()
   {
      m_CaseSensitive = TRUE;
      m_Indexed = TRUE;
      m_AllowRehashing = TRUE;
      m_bNeedToSave = TRUE;
   }

   void SetData(IVarSet * parent,CVarData * data,DWORD restrictions)
   {
      if ( m_parent )
      {
         m_parent->Release();
         m_parent = NULL;
      }
      if (m_data)
      {
         delete m_data;
      }
      m_data = data;
      m_parent = parent;
      m_bNeedToSave = TRUE;
      m_Indexed = m_data->IsIndexed();
      m_CaseSensitive = m_data->IsCaseSensitive();
      m_nItems = m_data->CountItems();
      m_Restrictions = restrictions;
      m_ImmutableRestrictions = restrictions;
      if ( ! m_data->HasData() )
      {
         // Don't count the root key "" if it does not have a value.
         m_nItems--;
      }
   }
    // IPersistStorage
public:
	
   STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID);

   STDMETHOD(IsDirty)();
        
   STDMETHOD(Load)(LPSTREAM pStm);
        
   STDMETHOD(Save)(LPSTREAM pStm,BOOL fClearDirty);
        
   STDMETHOD(GetSizeMax)(ULARGE_INTEGER __RPC_FAR *pCbSize);
        
   STDMETHOD(InitNew)();

  
   // IMarshal
public:
   STDMETHODIMP GetUnmarshalClass(REFIID riid, void *pv, DWORD dwDestContext, void *pvDestContext, DWORD mshlflags, CLSID *pCid);
   STDMETHODIMP GetMarshalSizeMax(REFIID riid, void *pv, DWORD dwDestContext, void *pvDestContext, DWORD mshlflags, DWORD *pSize);
   STDMETHODIMP MarshalInterface(IStream *pStm, REFIID riid, void *pv, DWORD dwDestContext, void *pvDestCtx, DWORD mshlflags);
   STDMETHODIMP UnmarshalInterface(IStream *pStm, REFIID riid, void **ppv);
   STDMETHODIMP ReleaseMarshalData(IStream *pStm);
   STDMETHODIMP DisconnectObject(DWORD dwReserved);
    
    
     
    
    

};

#endif //__VSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\vset.cpp ===
/*---------------------------------------------------------------------------
  File: VSet.cpp

  Comments: Implementation of IVarSet interface.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 19:44:06

 ---------------------------------------------------------------------------
*/

// VSet.cpp : Implementation of CVSet
#include "stdafx.h"

#ifdef STRIPPED_VARSET
   #include "NoMcs.h"
   #include <comdef.h>
   #include "Err.hpp"
   #include "Varset.h"
#else
#endif 

#include "VarSetI.h"
#include "VSet.h"
#include "VarMap.h"
#include "DotStr.hpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVSet

  
/////////////////////////////////////////////////////////////////////
// IVarSet
/////////////////////////////////////////////////////////////////////
// Gets the number of items in the map and all sub-maps
STDMETHODIMP CVSet::get_Count(/* [retval][out] */long* retval)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_Count");
   
   if (retval == NULL)
   {
      MCSVERIFYSZ(FALSE,"get_Count:  output pointer was null, returning E_POINTER");
      return E_POINTER;
   }

	m_cs.Lock();
   *retval = m_nItems;
   MCSASSERTSZ(! m_nItems || m_nItems == m_data->CountItems() - (m_data->HasData()?0:1),"get_Count:Item count consistency check failed.");
   m_cs.Unlock();
	
   return S_OK;
}

STDMETHODIMP CVSet::get_NumChildren(/* [in] */BSTR parentKey,/* [out,retval] */long*count)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_NumChildren");

   HRESULT                   hr = S_OK;
   CVarData                * pVar;
   CString                   parent;

   parent = parentKey;
   if ( count == NULL )
   {
      MCSVERIFYSZ(FALSE,"get_NumChildren:  output pointer was null, returning E_POINTER");
      hr = E_POINTER;
   }
   else
   {
      m_cs.Lock();
      pVar = GetItem(parent,FALSE);
      if ( pVar )
      {
         if ( pVar->HasChildren() )
         {
            (*count) = pVar->GetChildren()->GetCount();
         }
         else
         {
            (*count) = 0;
         }
      }
      else
      {
         // The parent key does not exist
         (*count) = 0;
      }
      m_cs.Unlock();
   }
   return hr;
}

  
// Adds or changes a value in the map
STDMETHODIMP CVSet::putObject(/* [in] */BSTR property,/* [in] */VARIANT value)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::putObject");
   
   CVarData                * pVar = NULL;
   HRESULT                   hr = S_OK;

   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEDATA )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {
      m_cs.Lock();
      m_bNeedToSave = TRUE;
      pVar = GetItem(property,TRUE);
      if ( pVar )
      {
         MC_LOG("set value for " << McString::String(property));
         m_nItems+=pVar->SetData("",&value,FALSE,&hr);
      }
      else
      {
         MCSASSERTSZ(FALSE,"VarSet internal error creating or retrieving node");   
         // GetItem failed - cannot add item to property
         hr = E_FAIL;
      }
      m_cs.Unlock();
   }
   return hr;
}

  
// Adds or changes a value in the map
STDMETHODIMP CVSet::put(/* [in] */BSTR property,/* [in] */VARIANT value)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::put");
   
   CVarData                * pVar = NULL;
   HRESULT                   hr = S_OK;

   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEDATA )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {
      m_cs.Lock();
      m_bNeedToSave = TRUE;
      pVar = GetItem(property,TRUE);
      if ( pVar )
      {
         MC_LOG("set value for " << McString::String(property));
         m_nItems+=pVar->SetData("",&value,TRUE,&hr);
      }
      else
      {
         MCSASSERTSZ(FALSE,"VarSet internal error creating or retrieving node");   
         // GetItem failed - cannot add item to property
         hr = E_FAIL;
      }
      m_cs.Unlock();
   }
   return hr;
}

CVarData *                                 // ret- pointer to item in varset
   CVSet::GetItem(
      CString                str,          // in - key to look for
      BOOL                   addToMap,     // in - if TRUE, adds the key to the map if it does not exist 
      CVarData             * base          // in - starting point
   )
{
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_INTERNAL,"CVSet::GetItem");
   
   CVarData                * curr = base;
   CVarData                * result = NULL;
   CDottedString             s(str);
   CString                   seg;
   CString                   next;

   if ( ! curr )
   {
      curr = m_data;
      MC_LOG("No basepoint provided, using root element");
   }

   if ( str.IsEmpty() )
   {
      result = curr;
      MC_LOG("Returning current node");
   }
   else
   {
      for ( int i = 0 ; curr && i < s.NumSegments(); i++ )
      {
         s.GetSegment(i,seg);
         MC_LOG("Looking for key segment "<< McString::String(seg) );
         curr->SetCaseSensitive(m_CaseSensitive);
         if  ( ! curr->Lookup(seg,result) )
         {
            if ( addToMap )
            {
               MC_LOG(McString::String(seg) << " not found, creating new node");
               result = new CVarData;
			   if (!result)
				  break;
               result->SetCaseSensitive(m_CaseSensitive);
               result->SetIndexed(m_Indexed);
               curr->SetAt(seg,result);
               m_nItems++;
            }
            else
            {
               MC_LOG(McString::String(seg) << " not found, aborting");
               result = NULL;
               break;
            }
         }
         curr = result;
      }
   }
   return result;      
}

// Retrieves a value from the map
STDMETHODIMP CVSet::get(/* [in] */BSTR property,/* [retval][out] */VARIANT * value)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get");

   CVarData                * pVar;
   HRESULT                   hr = S_OK;
   CComVariant               var;
   CString                   s;
                       
   if (property == NULL )
   {
      MCSVERIFYSZ(FALSE,"CVSet::get - output pointer is NULL, returning E_POINTER");
      hr = E_POINTER; 
   }
   else
   {
      m_cs.Lock();
      s = property;
      pVar = GetItem(s);
      var.Attach(value);
      if ( pVar )
      {
         MC_LOG("got value for " << McString::String(property));
         var.Copy(pVar->GetData());
      }
      else
      {
         MC_LOG("CVSet::get " << McString::String(property) << " was not found, returning empty variant");
      }
      // if the item was not found, set the variant to VT_EMPTY
      var.Detach(value);
      m_cs.Unlock();
   }
   return hr;
}

STDMETHODIMP CVSet::put_CaseSensitive(/* [in] */BOOL newVal)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::put_CaseSensitive");
   
   HRESULT                   hr = S_OK;

   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEPROPS )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {
      m_cs.Lock();
      m_bNeedToSave = TRUE;
      m_CaseSensitive = newVal;
      m_cs.Unlock();
   }
   return hr;
}

STDMETHODIMP CVSet::get_CaseSensitive(/* [retval][out] */BOOL * isCaseSensitive)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_CaseSensitive");
   
   if ( ! isCaseSensitive )
   {
      MCSVERIFYSZ(FALSE,"CVSet::get_CaseSensitive - output pointer is NULL, returning E_POINTER");
      return E_POINTER;
   }
   else
   {
      m_cs.Lock();
      (*isCaseSensitive) = m_CaseSensitive;
      m_cs.Unlock();
   }
   return S_OK;
}


// This function is used to sort the keys being returned from an enum.
 int __cdecl SortComVariantStrings(const void * v1, const void * v2)
{
   CComVariant             * var1 = (CComVariant*)v1;
   CComVariant             * var2 = (CComVariant*)v2;

   if ( var1->vt == VT_BSTR && var2->vt == VT_BSTR )
   {
      return wcscmp(var1->bstrVal,var2->bstrVal);
   }
   return 0;
}


// This returns an IEnumVARIANT interface.  It is used by the VB For Each command.
// This enumerates only the keys, not the values.  It is not very efficient, especially for large sets.
STDMETHODIMP CVSet::get__NewEnum(/* [retval][out] */IUnknown** retval)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_NewEnum");
   
   if (retval == NULL)
   {
      MCSVERIFYSZ(FALSE,"CVSet::get_NewEnum - output pointer is NULL, returning E_POINTER");
      return E_POINTER;
   }

	// initialize output parameter
   (*retval) = NULL;

	typedef CComObject<CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT,
		_Copy<VARIANT> > > enumvar;

	HRESULT                   hRes = S_OK;

   enumvar * p = new enumvar;
   
	if (p == NULL)
   {
      MCSVERIFYSZ(FALSE,"CVSet::get_NewEnum - Could not create IEnumVARIANT object");
      hRes = E_OUTOFMEMORY;
   }
	else
	{
		hRes = p->FinalConstruct();
		if (hRes == S_OK)
		{
			m_cs.Lock();
         
         CVarData                 * map = m_data;
         CString                    start;
         CString                    seg;
       
                  // Build an array of variants to hold the keys
         CComVariant       * pVars = new CComVariant[m_data->CountItems()+1];
         CString             key;
         int                 offset = 0;

         key = _T("");
         if ( map->GetData() && map->GetData()->vt != VT_EMPTY )
         {
            pVars[offset] = key;
            offset++;
         }
         if ( map->HasChildren() )
         {
            BuildVariantKeyArray(key,map->GetChildren(),pVars,&offset);
         }
      
         if ( ! m_Indexed )
         {
            // Sort the results
            qsort(pVars,offset,(sizeof CComVariant),&SortComVariantStrings);
         }

         hRes = p->Init(pVars, &pVars[offset], NULL,AtlFlagCopy);
			if (hRes == S_OK)
				hRes = p->QueryInterface(IID_IUnknown, (void**)retval);
         
         delete [] pVars;
         m_cs.Unlock();
   	}
	}
	if (hRes != S_OK)
		delete p;
   
   return hRes;
}

// Helper function for get__NewEnum
// copies all the keys in the map, and all sub-maps, into a CComVariant array.
// the values are then sorted if necessary.
void 
   CVSet::BuildVariantKeyArray(
      CString                prefix,       // in - string to tack on to the beginning of each key (used when enumerating subkeys)
      CMapStringToVar      * map,          // in - map containing data
      CComVariant          * pVars,        // i/o- array that will contain all the keys
      int                  * offset        // i/o- number of keys copied to pVars (index to use for next insertion)
   )
{
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_INTERNAL,"CVSet::BuildVariantKeyArray");
  
   int                       i;
   int                       nItems;
   CVarData                * pObj;
   CString                   key;
   CComVariant               var;
   CString                   val;

   if ( ! map )
      return;  // no data =>no work to do

   nItems = map->GetCount();
   
   if ( ! m_Indexed )
   {
      POSITION                  pos;
      
      pos = map->GetStartPosition();
      for ( i = 0 ; pos &&  i < nItems ; i++ )
      {
         map->GetNextAssoc(pos,key,pObj);
         if ( ! prefix.IsEmpty() )
         {
            var = prefix + L"." + key;
         }
         else
         {
            var = key;
         }
         // add each key to the array
         var.Detach(&pVars[(*offset)]);
         (*offset)++;
         if ( pObj->HasChildren() )
         {
            // Recursively do the sub-map
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyArray(prefix+L"."+key,pObj->GetChildren(),pVars,offset);
            }
            else
            {
               BuildVariantKeyArray(key,pObj->GetChildren(),pVars,offset);
            }
         }
      }
   }
   else
   {
      CIndexItem           * item;
      CIndexTree           * index = map->GetIndex();

      ASSERT(index);
      
      if ( ! index )
         return;
      
      item = index->GetFirstItem();

      for ( i = 0 ; item &&  i < nItems ; i++ )
      {
         key = item->GetKey();
         pObj = item->GetValue();

         if ( ! prefix.IsEmpty() )
         {
            var = prefix + L"." + key;
         }
         else
         {
            var = key;
         }
         // add each key to the array
         var.Detach(&pVars[(*offset)]);
         (*offset)++;
         if ( pObj->HasChildren() )
         {
            // Recursively do the sub-map
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyArray(prefix+L"."+key,pObj->GetChildren(),pVars,offset);
            }
            else
            {
               BuildVariantKeyArray(key,pObj->GetChildren(),pVars,offset);
            }
         }
         item = index->GetNextItem(item);
      }
   }
   
}

STDMETHODIMP 
   CVSet::getItems2(
      /* [in] */VARIANT      basepoint,     // in - if specified, only children of this node will be enumerated
      /* [in] */VARIANT      startAfter,    // in - the enumeration will begin with the next item in the map following this key.
      /* [in] */VARIANT      bRecursive,    // in - TRUE includes all sub-items, FALSE enumerates one level only.
      /* [in] */VARIANT      bSize,         // in - max number of elements to return (the size of the arrays)
      /* [out] */VARIANT   * keyVar,        // out- array of keys
      /* [out] */VARIANT   * valVar,        // out- array of values
      /* [in,out] */VARIANT* nReturned      // out- number of items copied
   )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::getItems2");
  
   HRESULT                   hr = S_OK;
   LONG                      n = 0;
   LONG                      size = bSize.pvarVal->iVal;
   
   // TODO:  Verify that all the arguments are the correct type!

   // Allocate SAFEARRAYs for the keys and values
   SAFEARRAY               * keys = NULL; 
   SAFEARRAY               * values= NULL;
   _variant_t                key;
   _variant_t                val;
   _variant_t                num;

   if ( ! keys || !values )
   {
      hr = E_OUTOFMEMORY;      
   }
   else
   {
      hr = getItems(basepoint.bstrVal,startAfter.bstrVal,bRecursive.boolVal,size,&keys,&values,&n);
      key.vt = VT_ARRAY | VT_VARIANT;
      key.parray = keys;
      val.vt = VT_ARRAY | VT_VARIANT;
      val.parray = values;
      num.vt = VT_I4;
      num.lVal = n;
      (*keyVar) = key.Detach();
      (*valVar) = val.Detach();
      (*nReturned) = num.Detach();
   }
   return hr;

}

STDMETHODIMP 
   CVSet::getItems(
      /* [in] */BSTR          basepoint,     // in - if specified, only children of this node will be enumerated
      /* [in] */BSTR          startAfter,    // in - the enumeration will begin with the next item in the map following this key.
      /* [in] */BOOL          bRecursive,    // in - TRUE includes all sub-items, FALSE enumerates one level only.
      /* [in] */ULONG         bSize,         // in - max number of elements to return (the size of the arrays)
      /* [out] */SAFEARRAY ** keys,          // out- array of keys
      /* [out] */SAFEARRAY ** values,        // out- array of values
      /* [out] */LONG       * nReturned      // out- number of items copied
   )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::getItems");
  
   HRESULT                   hr = S_OK;

   (*nReturned) = 0;
   (*keys) = 0;
   (*values) = 0;

   m_cs.Lock();
   
   CVarData                * map = m_data;
   CString                   base;
   CString                   start;
   CString                   seg;
 

   // Find the map to enumerate
   base = basepoint;
   if ( base.GetLength() > 0 )
   {
      map = GetItem(base);
   }
   
   if ( ! map )
   {
         // not found
      (*nReturned) = 0;
   }
   else
   {
      // Build an array of variants to hold the keys
      int                 offset = 0;

      SAFEARRAYBOUND            bound[1];
      LONG                      n = 0;
      LONG                      size = bSize;
   
      bound[0].lLbound = 0;
      bound[0].cElements = size;

      
      // Allocate SAFEARRAYs for the keys and values
      (*keys) = SafeArrayCreate(VT_VARIANT, 1, bound);
      (*values) = SafeArrayCreate(VT_VARIANT, 1, bound);
  
      start = startAfter;
      
      if ( base.GetLength() && start.GetLength() )
      {
         // ASSERT( that LEFT(start,LEN(base)) = base
         //start = start.Right(start.GetLength() - base.GetLength() - 1);
      }
      
      if ( base.IsEmpty() && start.IsEmpty() )
      {
         if ( map->GetData() && map->GetData()->vt != VT_EMPTY )
         {
            long             index[1];

            index[0] = 0;
            // add the root element to the results
            if ( (*keys)->fFeatures & FADF_BSTR  )
            {
               SafeArrayPutElement((*keys),index,_T(""));
            }
            else
            {
               // VBScript can only use VARIANT arrays (see getItems2)
               _variant_t tempKey;
               tempKey = _T("");
               SafeArrayPutElement((*keys),index,&tempKey);
            }
         
            SafeArrayPutElement((*values),index,map->GetData());
            offset++;
         }
         
      }
      if ( map->HasChildren() )
      {
         BuildVariantKeyValueArray(base,start,map->GetChildren(),(*keys),
            (*values),&offset,bSize,bRecursive);
      }
      (*nReturned) = offset;
   }
   m_cs.Unlock();
	

	return hr;
}

// helper function for getItems.  Fills SAFEARRAYs of keys and values
// if the varset is indexed, the items will be returned in sorted order, o.w. they will be in arbitrary (but consistent) order.
void 
   CVSet::BuildVariantKeyValueArray(
      CString                prefix,         // in - string to tack on to the beginning of each key (used when enumerating subkeys)
      CString                startAfter,     // in - optional, enumerates only those items that alphabetically follow this one.
      CMapStringToVar      * map,            // in - map containing the data
      SAFEARRAY            * keys,           // i/o- array that will contain the key values for the requested items
      SAFEARRAY            * pVars,          // i/o- array that will contain the data values for the requested items
      int                  * offset,         // i/o- number of items copied to the arrays (index to use for next insertion)
      int                    maxOffset,      // in - allocated size of the arrays
      BOOL                   bRecurse        // in - whether to recursively process children
   )
{
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_INTERNAL,"CVSet::BuildVariantKeyValueArray");
  
   int                 i;
   int                 nItems;
   CVarData          * pObj;
   CString             key;   // last segment of key name 
   POSITION            pos;
   
   CComBSTR            val;   // fully qualified key name to add to array (val = prefix.key)
   CComVariant         var;   // value to add to array
   BOOL                includeSomeChildrenOnly;

   CDottedString       dBase(prefix);
   CDottedString       dStartItem(startAfter);
   
   int                 depth = dBase.NumSegments();
    
   if ( ! map )   
      return; // no data => nothing to do

   if ( (*offset) >= maxOffset )
      return; // the arrays are full
   
   includeSomeChildrenOnly = dStartItem.NumSegments() > depth;

   nItems = map->GetCount();
   // If we're not using an index, the items will be returned in arbitrary order
   if ( ! m_Indexed )
   {
      if ( includeSomeChildrenOnly && bRecurse )
      {
         // the startAfter item is in a subtree.  Find the appropriate element at this level and recursively continue the search   
         dStartItem.GetSegment(depth,key);
         if ( map->Lookup(key,pObj) )
         {
            // found the object
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyValueArray(prefix+_T(".")+key,startAfter,pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            else
            {
               BuildVariantKeyValueArray(key,startAfter,pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
         }
         // we've included the children of this item that come after 'startAfter',
         // now process the rest of the items at this level
         // make sure there's still room
         if ( (*offset) >= maxOffset )
            return; // the arrays are full
      }
      
      // this is the usual case.  process the items at this level, starting with the element following StartAfter.
      
      // Get a pointer to that first element
      if ( startAfter.GetLength() > prefix.GetLength())
      {
         CString startItem;
         dStartItem.GetSegment(depth,startItem);
         // this returns the position before startItem
         pos = (POSITION)map->GetPositionAt(startItem);
		 if (!pos)
	        return;
         map->GetNextAssoc(pos,key,pObj);
      }
      else 
      {
         pos = map->GetStartPosition();
      }

      for ( i = 0 ; pos &&  i < nItems ; i++ )
      {
         map->GetNextAssoc(pos,key,pObj);
         if ( ! prefix.IsEmpty() )
         {
            val = prefix + L"." + key;
         }
         else
         {
            val = key;
         }
         // copy each item into the arrays
         ASSERT((*offset) < maxOffset);
         var.Copy(pObj->GetData());
         LONG                index[1];
         index[0] = (*offset);
         SafeArrayPutElement(pVars,index,&var);
         if ( keys->fFeatures & FADF_BSTR  )
         {
            SafeArrayPutElement(keys,index,val);
         }
         else
         {
            // VBScript can only use VARIANT arrays (see getItems2)
            _variant_t tempKey;
            tempKey = val;
            SafeArrayPutElement(keys,index,&tempKey);
         }

         var.Clear();
         (*offset)++;
         if ( *offset >= maxOffset )
            break; // arrays are full - stop
      
         if ( bRecurse && pObj->HasChildren() )
         {
            // Recursively do the sub-map
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyValueArray(prefix+L"."+key,"",pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            else
            {
               BuildVariantKeyValueArray(key,"",pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            if ( *offset >= maxOffset )
               break; // arrays are full - stop
         }
      }
   }
   else
   {
      // Use the index to enumerate the items in alphabetical order
      
      CIndexItem           * curr;
      CIndexTree           * ndx = map->GetIndex();
      
      ASSERT (ndx != NULL);

      if ( includeSomeChildrenOnly && bRecurse )
      {
         // the startAfter item is in a subtree.  Find the appropriate element at this level and recursively continue the search   
         dStartItem.GetSegment(depth,key);
         if ( map->Lookup(key,pObj) )
         {
            // found the object
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyValueArray(prefix+_T(".")+key,startAfter,pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            else
            {
               BuildVariantKeyValueArray(key,startAfter,pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
         }
         // we've included the children of this item that come after 'startAfter',
         // now process the rest of the items at this level
         // make sure there's still room
         if ( (*offset) >= maxOffset )
            return; // the arrays are full
      }
      
      // Get a pointer to the first item at this level AFTER startAfter
      if ( startAfter.GetLength() > prefix.GetLength() )
      {
         CString startItem;
         dStartItem.GetSegment(depth,startItem);
         // if a starting item is specified, try using the hash function to find it in the table
         curr = map->GetIndexAt(startItem);
         if ( curr )
         {
            curr = ndx->GetNextItem(curr);
         }
         else
         {
            // The startAfter item is not in the table.  Search the tree to find 
            // the first item that would follow it if it were there
            curr = ndx->GetFirstAfter(startItem);
         }
      }
      else
      {
         curr = ndx->GetFirstItem();  
      }
      // Process all the items
      while ( curr )
      {
         pObj = curr->GetValue();
         key = curr->GetKey();

         curr = ndx->GetNextItem(curr);
         if ( ! prefix.IsEmpty() )
         {
            val = prefix + L"." + key;
         }
         else
         {
            val = key;
         }
         // add each item to the arrays
         ASSERT((*offset) < maxOffset);
         
         var.Copy(pObj->GetData());
         
         LONG                index[1];
         
         index[0] = (*offset);
         SafeArrayPutElement(pVars,index,&var);
         if ( keys->fFeatures & FADF_BSTR  )
         {
            SafeArrayPutElement(keys,index,val);
         }
         else
         {
            // VBScript can only use VARIANT arrays (see getItems2)
            _variant_t tempKey;
            tempKey = val;
            SafeArrayPutElement(keys,index,&tempKey);
         }

         var.Clear();         
         (*offset)++;
         
         if ( *offset >= maxOffset )
            break; // arrays are full - stop
         
         if ( bRecurse && pObj->HasChildren() )
         {
            // Recursively do the sub-map
            if ( ! prefix.IsEmpty() )
            {
               BuildVariantKeyValueArray(prefix+L"."+key,"",pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            else
            {
               BuildVariantKeyValueArray(key,"",pObj->GetChildren(),keys,pVars,offset,maxOffset,bRecurse);
            }
            if ( *offset >= maxOffset )
               break; // arrays are full - stop
         }
      }
   }
}

        
STDMETHODIMP CVSet::Clear()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::Clear");
  
   HRESULT                   hr = S_OK;
   
   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEDATA )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {
      m_cs.Lock();
      m_bNeedToSave = TRUE;
      m_data->RemoveAll();
      m_data->GetData()->Clear();
      m_data->GetData()->ChangeType(VT_EMPTY);
      m_nItems = 0;
      m_cs.Unlock();
   }
   
   return hr;
}

//////////////IPersistStreamInit//////////////////////////////////////////////////////

STDMETHODIMP CVSet::GetClassID(CLSID __RPC_FAR *pClassID)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   (*pClassID) = CLSID_VarSet;
   
   return S_OK;
}

STDMETHODIMP CVSet::IsDirty()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   if ( m_bNeedToSave )
   {
      return S_OK;
   }
   else
   {
      return S_FALSE;
   }
}
     
STDMETHODIMP CVSet::Load(LPSTREAM pStm)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   ULONG                result = 0;
   HRESULT              hr;

   m_cs.Lock();

   do {  // once

      hr = pStm->Read(&m_nItems,(sizeof m_nItems),&result);
      if ( FAILED(hr) )
         break;
      hr = pStm->Read(&m_CaseSensitive,(sizeof m_CaseSensitive),&result);
      if ( FAILED(hr) )
         break;
      hr = pStm->Read(&m_Indexed,(sizeof m_Indexed),&result);
      if ( FAILED(hr) )
         break;
      hr = m_data->ReadFromStream(pStm);
      m_bNeedToSave = FALSE;
      m_bLoaded = TRUE;
   }
   while (FALSE);

   m_cs.Unlock();

   return hr;
}
     
STDMETHODIMP CVSet::Save(LPSTREAM pStm,BOOL fClearDirty)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   ULONG             result = 0;
   HRESULT           hr;

   m_cs.Lock();

   do {   // once
      hr = pStm->Write(&m_nItems,(sizeof m_nItems),&result);
      if ( FAILED(hr) )
         break;
      hr = pStm->Write(&m_CaseSensitive,(sizeof m_CaseSensitive),&result);
      if ( FAILED(hr) )
         break;
      hr = pStm->Write(&m_Indexed,(sizeof m_Indexed),&result);
      if ( FAILED(hr) )
         break;
      hr = m_data->WriteToStream(pStm);
      if ( fClearDirty )
      {
         m_bNeedToSave = FALSE;
      }
   }while (FALSE);

   m_cs.Unlock();
   return hr;
}

STDMETHODIMP CVSet::GetSizeMax(ULARGE_INTEGER __RPC_FAR *pCbSize)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_INTERNAL,"VarSet GetSizeMax");

   HRESULT                   hr = S_OK;

   if ( pCbSize == NULL )
   {
      return E_POINTER;
   }
   else
   {
      LPSTREAM               pStr = NULL;
      DWORD                  rc;
      STATSTG                stats;
      DWORD                  requiredLength = 0; 


      rc = CreateStreamOnHGlobal(NULL,TRUE,&pStr);
      if ( ! rc )
      {
         hr = Save(pStr,FALSE);
         if (SUCCEEDED(hr) )
         {
            hr = pStr->Stat(&stats,STATFLAG_NONAME);
            if (SUCCEEDED(hr) )
            {
               requiredLength = stats.cbSize.LowPart;
            }
         }
         pStr->Release();
      }

      pCbSize->LowPart = requiredLength;
      MC_LOG("Size is " << McString::makeStr(requiredLength) );
      pCbSize->HighPart = 0;
   }
   
   return hr;
}
    
STDMETHODIMP CVSet::InitNew()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   if ( m_bLoaded )
   {
      return E_UNEXPECTED;
   }
   else
   {
      m_cs.Lock();
      InitProperties();
      m_cs.Unlock();
      return S_OK;
   }
}

STDMETHODIMP CVSet::ImportSubTree(/*[in] */ BSTR key, /* [in] */ IVarSet * pVarSet)
{

   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::ImportSubTree");

   HRESULT                   hr = S_OK;
   VARIANT                   value;
   ULONG                     nGot;
   _bstr_t                   keyB;
   _bstr_t                   newkey;
   // make sure the varset is valid
                   
   // enumerate the varset, inserting each item into the tree as key.item
   IEnumVARIANT            * varEnum = NULL;
   IUnknown                * pUnk = NULL;

   // TODO:  need to speed this up by using getItems
   hr = pVarSet->get__NewEnum(&pUnk);
   if ( SUCCEEDED(hr) )
   {
      hr = pUnk->QueryInterface(IID_IEnumVARIANT,(void**)&varEnum);
      pUnk->Release();
   }
   if ( SUCCEEDED(hr))
   {
      value.vt = VT_EMPTY;
      while ( SUCCEEDED(hr = varEnum->Next(1,&value,&nGot)) )
      {
         if ( nGot==1 )
         {
            keyB = value.bstrVal;
            newkey = key;
            if ( newkey.length() )
            {
               newkey += _T(".");
            }
            newkey += keyB;
            hr = pVarSet->get(keyB,&value);
            if ( SUCCEEDED(hr )  )
            {
               hr = put(newkey,value);
            }
         }
         else
         {
            break;
         }
         if ( FAILED(hr) )
            break;
      }
      if ( varEnum )
         varEnum->Release();
   }
   varEnum = NULL;
  // clean up
   return hr;
}

STDMETHODIMP CVSet::getReference( /* [in] */ BSTR key, /* [out,retval] */IVarSet ** ppVarSet)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::getReference");

   HRESULT                   hr = S_OK;
   CVarData                * item = GetItem(key);
   
   typedef CComObject<CVSet> myvset;

   myvset                  * pVarSet;

   if ( ! ppVarSet )
   {
      hr = E_POINTER;
   }
   else
   {
      if ( item )
      {
         pVarSet = new myvset; 
         AddRef();
         ((CVSet*)pVarSet)->SetData(this,item,m_Restrictions);
         hr = pVarSet->QueryInterface(IID_IVarSet,(void**)ppVarSet);
      }
      else
      {
         hr = TYPE_E_ELEMENTNOTFOUND;
      }
   }
   return hr;
}

STDMETHODIMP CVSet::DumpToFile(BSTR filename)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())

   HRESULT                   hr = S_OK;

#ifdef STRIPPED_VARSET
   
   USES_CONVERSION;
   
   TError                    errLog;
   
   errLog.LogOpen((WCHAR*)filename,1,0);

   errLog.MsgWrite(0,L"VarSet");
   errLog.MsgWrite(0,L"Case Sensitive: %s, Indexed: %s",(m_CaseSensitive ? L"Yes" : L"No"),(m_Indexed ? L"Yes" : L"No") );
   errLog.MsgWrite(0,L"User Data ( %ld ) items",m_nItems);
#else
  
#endif     
   m_cs.Lock();
         
   CVarData                * map = m_data;
   CString                   start;
   CString                   seg;
 
                  // Build an array of variants to hold the keys
   CComVariant             * pVars = new CComVariant[m_data->CountItems()+1];
   CString                   key;
   int                       offset = 1;
   
   key = _T("");
   
   if (!pVars)
   {
      m_cs.Unlock();
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   }

   // include the root item in the list
   
   pVars[0] = key;
   if ( map->HasChildren() )
   {
      BuildVariantKeyArray(key,map->GetChildren(),pVars,&offset);
   }
   
   m_cs.Unlock();

   if ( ! m_Indexed )
   {
       // Sort the results
      qsort(pVars,offset,(sizeof CComVariant),&SortComVariantStrings);
   }

   
   for ( int i = 0 ; i < offset ; i++ )
   {
      CVarData             * data;
      CString                value;
      CString                key;

      key = pVars[i].bstrVal;

      data = GetItem(key);

      if ( data )
      {
         switch ( data->GetData()->vt )
         {
         case VT_EMPTY:      
            value = _T("<Empty>");
            break;
         case VT_NULL:
            value = _T("<Null>");
            break;
         case VT_I2:
            value.Format(_T("%ld"),data->GetData()->iVal);
            break;
         case VT_I4:
            value.Format(_T("%ld"),data->GetData()->lVal);
            break;
         case VT_BSTR:
            value = data->GetData()->bstrVal;
            break;
         default:
            value.Format(_T("variant type=0x%lx"),data->GetData()->vt);
            break;
         }
#ifdef STRIPPED_VARSET
         errLog.MsgWrite(0,L" [%ls] %ls",key.GetBuffer(0),value.GetBuffer(0));
#else
 
#endif
      }
      else
      {
#ifdef STRIPPED_VARSET
         errLog.MsgWrite(0,L" [%ls] <No Value>",key.GetBuffer(0));
#else
#endif 
      }
   }
   delete [] pVars;
   return hr;
}

STDMETHODIMP CVSet::get_Indexed(BOOL *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_Indexed");
   if ( pVal == NULL )
      return E_POINTER;
   
   m_cs.Lock();
   (*pVal) = m_Indexed;
   m_cs.Unlock();

   return S_OK;
}

STDMETHODIMP CVSet::put_Indexed(BOOL newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::put_Indexed");
   
   HRESULT                   hr = S_OK;
   
   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEPROPS )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {
      m_cs.Lock();
      m_bNeedToSave = TRUE;
      m_Indexed = newVal;  
      m_data->SetIndexed(m_Indexed);
      m_cs.Unlock();
   }
   return hr;
}


STDMETHODIMP CVSet::get_AllowRehashing(BOOL *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::get_AllowRehashing");
   if ( pVal == NULL )
      return E_POINTER;
   
   m_cs.Lock();
   (*pVal) = m_AllowRehashing;
   m_cs.Unlock();

   return S_OK;
}

STDMETHODIMP CVSet::put_AllowRehashing(BOOL newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   MC_LOGBLOCKIF(VARSET_LOGLEVEL_CLIENT,"CVSet::put_AllowRehashing");
   
   HRESULT                   hr = S_OK;
   
   if ( m_Restrictions & VARSET_RESTRICT_NOCHANGEPROPS )
   {
      hr = E_ACCESSDENIED;
   }
   else
   {

      m_cs.Lock();
   
      m_bNeedToSave = TRUE;
   
      m_AllowRehashing = newVal;
      m_data->SetAllowRehashing(newVal);

      m_cs.Unlock();
   }   
   return hr;
}         

STDMETHODIMP CVSet::get_Restrictions(DWORD * restrictions)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   HRESULT                   hr = S_OK;

   if ( restrictions == NULL )
   {
      hr = E_POINTER;
   }
   else
   {
      (*restrictions) = m_Restrictions;
   }
   return hr;
}

STDMETHODIMP CVSet::put_Restrictions(DWORD newRestrictions)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   HRESULT                   hr = S_OK;
   DWORD                     rAdding = newRestrictions & ~m_Restrictions;
   DWORD                     rRemoving = ~newRestrictions & m_Restrictions;


   // Can't remove any restrictions passed down from parent.
   if ( ( rRemoving & m_ImmutableRestrictions) )
   {
      hr = E_ACCESSDENIED;
   }
   else if ( rAdding & ! VARSET_RESTRICT_ALL )
   {
      hr = E_NOTIMPL;
   }
   else
   {
      // the change is OK.
      m_Restrictions = newRestrictions;
   }
   return hr;
}

// IMarshal implemention
// This marshals the varset to a stream that is then sent across the wire
STDMETHODIMP CVSet::GetUnmarshalClass(REFIID riid, void *pv, DWORD dwDestContext, void *pvDestContext, DWORD mshlflags, CLSID *pCid)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   *pCid = GetObjectCLSID();
   
   return S_OK;
}
 
STDMETHODIMP CVSet::GetMarshalSizeMax(REFIID riid, void *pv, DWORD dwDestContext, void *pvDestContext, DWORD mshlflags, DWORD *pSize)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   HRESULT                   hr = S_OK; 
   ULARGE_INTEGER            uli;
   
   hr = GetSizeMax(&uli);

   if (SUCCEEDED(hr))
   {
      *pSize = uli.LowPart;
   }
   
   return hr;
}
 
STDMETHODIMP CVSet::MarshalInterface(IStream *pStm, REFIID riid, void *pv, DWORD dwDestContext, void *pvDestCtx, DWORD mshlflags)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   HRESULT                   hr = S_OK;
   
   // Save the varset's data to a stream
   hr = Save(pStm, FALSE);
     
   return hr;
}
 
STDMETHODIMP CVSet::UnmarshalInterface(IStream *pStm, REFIID riid, void **ppv)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   HRESULT                 hr = S_OK;
     
   // Load up the data from the stream using our IPersistStream implementation
   hr = Load(pStm);

   if ( SUCCEEDED(hr) )
   {
      hr = QueryInterface(riid,ppv);
   }
     
   return hr;
}
 
STDMETHODIMP CVSet::ReleaseMarshalData(IStream * /*pStmNotNeeded*/)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   // we don't keep any state data, so there's nothing to release
   // since we just read the object from the stream, the stream's pointer should already be at the end,
   // so there's nothing left for us to do here
   return S_OK;
}
 
STDMETHODIMP CVSet::DisconnectObject(DWORD /*dwReservedNotUsed*/)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
   
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\varmap.h ===
/*---------------------------------------------------------------------------
  File: VarMap.h

  Comments: A map string=>Variant, used by VarSet.  It is implemented as a hash 
  table, win and optional red-black tree index.

  Added features include:  
      CaseSensitive property - The case of each key is preserved as it was when
      the key was first added to the map.  The hash function is not case sensitive,
      so the CaseSensitive property can be toggled on and off without rehashing the data.
      
      Optional indexing to allow for fast enumeration in alphabetical order by key.
      This will add overhead to insert operations.  Without indexing, the contents of 
      the map can be enumerated, but they will be in arbitrary order.

      Stream I/O functions for persistance.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 18:03:19

 ---------------------------------------------------------------------------
*/



#ifndef __VARSETMAP_H
#define __VARSETMAP_H

#include "VarData.h"
#include "VarNdx.h"

class CHashItem // used internally by hash table
{
   friend class CMapStringToVar;
   friend class CIndexItem;

   CHashItem() { pNext = NULL; value = NULL; pIndex = NULL; }
   
   CHashItem*      pNext;       // used in hash table
	UINT            nHashValue;  // needed for efficient iteration
	CString         key;
   CVarData*       value;
   CIndexItem*     pIndex;      // pointer to index, or NULL
};

class CMapStringToVar : public CObject
{
   DECLARE_SERIAL(CMapStringToVar)
public:
   
// Construction
	CMapStringToVar(BOOL isCaseSensitive,BOOL isIndexed, BOOL allowRehash, int nBlockSize = 10);
protected:
   CMapStringToVar() {};
public:
// Attributes
	// number of elements
	int GetCount() const 	{ return m_nCount; }
	BOOL IsEmpty() const    { return m_nCount == 0; }

	// Lookup
	BOOL Lookup(LPCTSTR key, CVarData*& rValue) const;
	BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
	// Lookup and add if not there
	CVarData*& operator[](LPCTSTR key);

	// add a new (key, value) pair
	void SetAt(LPCTSTR key, CVarData* newValue)	{ (*this)[key] = newValue; }


	BOOL RemoveKey(LPCTSTR key);
	void RemoveAll();

	POSITION GetStartPosition() const { return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CVarData*& rValue) const;
   POSITION GetPositionAt(LPCTSTR key) { UINT hash; return (POSITION)GetAssocAt(key,hash); }
   CIndexItem * GetIndexAt(LPCTSTR key) { UINT hash; CHashItem * h = GetAssocAt(key,hash); if ( h ) return h->pIndex; else return NULL; }

   UINT GetHashTableSize() const 	{ return m_nHashTableSize; }
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

	UINT HashKey(LPCTSTR key) const;

   void SetCaseSensitive(BOOL val) { m_CaseSensitive = val; 
                                     m_Index.SetCompareFunctions(val? &CompareItems : &CompareItemsNoCase,
                                                                 val? CompareStringToItem : CompareStringToItemNoCase); }
   
   void SetIndexed(BOOL val);

   void SetAllowRehash(BOOL val) { m_AllowRehash = val; }

   HRESULT ReadFromStream(LPSTREAM pStm);
   HRESULT WriteToStream(LPSTREAM pStm);
   DWORD   CalculateStreamedLength();
   long    CountItems();

   CIndexTree * GetIndex() { if ( m_Indexed ) return &m_Index; else return NULL; }
   
   void McLogInternalDiagnostics(CString keyName);

   
   // Implementation
protected:
	// Hash table stuff
   CHashItem**       m_pHashTable;
	UINT              m_nHashTableSize;
	UINT              m_nCount;
	CHashItem*        m_pFreeList;
	struct CPlex*     m_pBlocks;
	int               m_nBlockSize;

	CHashItem* NewAssoc();
	void FreeAssoc(CHashItem*);
   CHashItem* GetAssocAt(LPCTSTR, UINT&) const;
   void BuildIndex();
   void ResizeTable();
   
   BOOL              m_CaseSensitive;
   BOOL              m_Indexed;
   BOOL              m_AllowRehash;
   CIndexTree        m_Index;

public:
	~CMapStringToVar();

   void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};




////////////////////////////////////////////////////////////////
#endif // __VARSETMAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\containerselectiondlg.h ===
#if !defined(AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_)
#define AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ContainerSelectionDlg.h : header file
//
#import "\bin\NetEnum.tlb" no_namespace

/////////////////////////////////////////////////////////////////////////////
// CContainerSelectionDlg dialog

class CContainerSelectionDlg : public CDialog
{
// Construction
public:
	HRESULT FindContainer();
	CImageList ilist;
	BOOL LoadImageList();
	HRESULT ExpandCompletely(HTREEITEM tvItem, BSTR parentCont);
	HRESULT PopulateContainer(HTREEITEM tvItemParent,BSTR sContName, INetObjEnumeratorPtr pQuery);
	CString m_strDomain;
	CContainerSelectionDlg(CWnd* pParent = NULL);   // standard constructor
   COLORREF GetFirstBitmapPixel(CWnd * window,UINT idbBitmap);
   HTREEITEM OpenContainer(CString strCont, HTREEITEM root);

// Dialog Data
	//{{AFX_DATA(CContainerSelectionDlg)
	enum { IDD = IDD_CONT_SELECTION };
	CButton	m_btnOK;
	CTreeCtrl	m_trOUTree;
	CString	m_strCont;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContainerSelectionDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CContainerSelectionDlg)
	afx_msg void OnOk();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkTree1(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\varndx.cpp ===
/*---------------------------------------------------------------------------
  File: VarMapIndex.cpp

  Comments: Helper class for CMapStringToVar.

  CIndexTree implements a sorted, balanced binary tree.  This is used by CMapStringToVar
  to provide enumeration in sorted order by key.

  CIndexTree is currently implemented as a Red-Black tree.


  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 11/19/98 18:17:47

 ---------------------------------------------------------------------------
*/




#include "stdafx.h"
#include "VarMap.h"
#include "VarNdx.h"


#ifdef STRIPPED_VARSET
   #include "NoMcs.h"
#else
   #pragma warning (push,3)
   #include "McString.h" 
   #include "McLog.h"
   #pragma warning (pop)

   using namespace McString;
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Comparison functions used for sorting and searching
int CompareItems(CIndexItem* i1, CIndexItem* i2)
{
   ASSERT(i1 && i2);
   int result;

   result = i1->GetKey().Compare(i2->GetKey());
   
   return result;
}

int CompareStringToItem(CString s, CIndexItem *i)
{
   ASSERT(i);
   int result;

   result = s.Compare(i->GetKey());

   return result;
}

int CompareItemsNoCase(CIndexItem* i1, CIndexItem* i2)
{
   ASSERT(i1 && i2);
   int result;

   result = i1->GetKey().CompareNoCase(i2->GetKey());
   
   return result;
}

int CompareStringToItemNoCase(CString s, CIndexItem *i)
{
   ASSERT(i);
   int result;

   // this assumes i->Data is not null

   result = s.CompareNoCase(i->GetKey());

   return result;
}

CVarData *
   CIndexItem::GetValue()
{ 
   if ( pData ) 
   {
      return pData->value; 
   }
   else 
   {
      return NULL; 
   }
}

CString 
   CIndexItem::GetKey()
{ 
   if ( pData ) 
   {
      return pData->key; 
   }
   else
   {
      return _T(""); 
   }
}
/////////////////////////////////////////////////////////////////////////////


/// Implementation of Red-Black Tree

CIndexItem *                               // ret- pointer to node in index
   CIndexTree::Insert(
      CHashItem            * data          // in - item from hash table
   )
{
   CIndexItem              * item = new CIndexItem(data);
   CIndexItem              * curr;
   CIndexItem              * parent;
   int                       compResult=0;
   
   if ( ! m_root )
   {
      m_root = item;
   }
   else
   {
      curr = m_root;
      parent = NULL;
      while ( curr )
      {
         parent = curr;
         compResult = (*m_Compare)(item,curr);
         if  ( compResult < 0 )
         {
            curr = curr->Left();
         }
         else if ( compResult > 0 )
         {
            curr = curr->Right();
         }
         else
         {
            // The same key should not appear multiple times in the hash table
            // this is a bug
            ASSERT(FALSE);
            delete item;
            curr->Data(data);
         }
      }
      if ( ! curr )
      {
         // The item was not in the tree
         ASSERT(compResult!=0);
         
         item->Parent(parent);
         // Add the item in the appropriate place
         if ( compResult < 0 )
         {
            parent->Left(item);
         }
         else
         {
            parent->Right(item);
         }
         // now rebalance the tree  
         CIndexItem        * uncle;
         BOOL                uncleIsRight;

         item->Black();
         while ( item != m_root && parent->IsRed() )
         {
            // we don't have to worry about grandparent being null, since parent is red, and 
            // the root is always black.

            // is the parent a left or right child? (algorithm is symmetric)
            if ( parent == parent->Parent()->Left() )
            {
               uncle = parent->Parent()->Right();
               uncleIsRight = TRUE;
            }
            else
            {
               uncle = parent->Parent()->Left();
               uncleIsRight = FALSE;
            }
            
            if ( uncleIsRight )
            {
               if ( uncle && uncle->IsRed() )
               {
                  parent->Black();
                  uncle->Black();
                  item = parent->Parent();
                  item->Red();
               }
               else if ( item == parent->Right() )
               {
                  item = parent;
                  LeftRotate(item);
               }
               parent->Black();
               parent->Parent()->Red();
               RightRotate(parent->Parent());
            }
            else // same as above, except swap left and right
            {
               if ( uncle && uncle->IsRed() )
               {
                  parent->Black();
                  uncle->Black();
                  item = parent->Parent();
                  item->Red();
               }
               else if ( item == parent->Left() )
               {
                  item = parent;
                  RightRotate(item);
               }
               parent->Black();
               parent->Parent()->Red();
               LeftRotate(parent->Parent());
            }
         }
      }
   }
   m_root->Black(); // see, the root is always black

   return item;
}
      
   
void 
   CIndexTree::RightRotate(
      CIndexItem           * item          // in - item to rotate from
   )
{
   CIndexItem              * y = item->Right();

   if ( y )
   {
      // turn y's left subtree into x's right subtree
      item->Right(y->Left());
      if ( y->Left() )
      {
         y->Left()->Parent(item);
      }
      y->Parent(item->Parent()); // link item's parent to y
      if (! item->Parent() )
      {
         m_root = y;
      }
      else if ( item == item->Parent()->Left() )
      {
         item->Parent()->Left(y);
      }
      else
      {
         item->Parent()->Right(y);
      }
      // put item on y's left
      y->Left(item);
      item->Parent(y);
   }
}

void 
   CIndexTree::LeftRotate(
      CIndexItem           * item          // in - item to rotate from
   )
{
   CIndexItem              * y = item->Left();

   if ( y )
   {
      // turn y's right subtree into x's left subtree
      item->Left(y->Right());
      if ( y->Right() )
      {
         y->Right()->Parent(item);
      }
      // link item's parent to y
      y->Parent(item->Parent());
      if ( ! item->Parent() )
      {
         m_root = y;
      }
      else if ( item == item->Parent()->Right() )
      {
         item->Parent()->Right(y);
      }
      else
      {
         item->Parent()->Left(y);
      }
      // put item on y's right
      y->Right(item);
      item->Parent(y);
   }
}

CIndexItem *                               // ret- the node immediately preceding the given node
   CIndexTree::GetPrevItem(      
      CIndexItem           * item          // in - a node in the index tree
   ) const
{
   CIndexItem              * curr;

   if ( item->Left() )
   {
      curr = item->Left();
      while ( curr->Right() )
      {
         curr = curr->Right();
      }
   }
   else
   {
      curr = item;
      while ( curr->Parent() && curr->Parent()->Left() == curr )
      {
         curr = curr->Parent();
      }
      curr = curr->Parent();
   }
   return curr;
}

CIndexItem *                               // ret- the node immediately following the given node
   CIndexTree::GetNextItem(
      CIndexItem           * item          // in - a node in the index tree 
   ) const
{                                               
   CIndexItem              * curr;

   if ( item->Right() )
   {
      curr = item->Right();
      while ( curr->Left() )
      {
         curr = curr->Left();
      }
   }
   else
   {
      curr = item;
      while ( curr->Parent() && curr->Parent()->Right() == curr )
      {
         curr = curr->Parent();
      }
      curr = curr->Parent();
   }
   return curr;
}

void 
   CIndexTree::RemoveAll()
{
   // do a post-order traversal, removing each node
   if ( m_root )
   {
      RemoveHelper(m_root);
      m_root = NULL;
   }
}

// helper function for removing all items in the tree
void 
   CIndexTree::RemoveHelper(
      CIndexItem           * curr          // in - current node
   )
{
   // our tree currently does not support removing a single item, so we'll use a brute force method
   // recursively delete children, then delete the current node
   if ( curr->Left() )
   {
      RemoveHelper(curr->Left());
   }
   if ( curr->Right() )
   {
      RemoveHelper(curr->Right());
   }
   delete curr;
}

void 
   CIndexItem::McLogInternalDiagnostics(CString keyName, int depth)
{
   CString key;
   CString strLeft;
   CString strRight;
   CString strParent;

   if ( ! keyName.IsEmpty() )
   {
      key = keyName + ".";
   }
   if ( pData )
   {
      key = key + pData->key;
   }
   else
   {
      MC_LOG("data is NULL");
   }
   MC_LOG("address="<<makeStr(this,L"0x%lx") << " pData="<< makeStr(pData,L"0x%lx") << " pLeft="<<makeStr(pLeft,L"0x%lx")<<" pRight="<<makeStr(pRight,L"0x%lx")<< " pParent="<<makeStr(pParent,L"0x%lx") << " red="<<makeStr(red,L"0x%lx") << " depth="<<makeStr(depth));
   if ( pLeft )
      strLeft = pLeft->GetKey();
   if ( pRight )
      strRight = pRight->GetKey();
   if ( pParent )
      strParent = pParent->GetKey();
   MC_LOG("       Key=" << String(key) << " Left=" << String(strLeft) << " Right=" << String(strRight) << " Parent="<< String(strParent) );
   if ( pLeft )
      pLeft->McLogInternalDiagnostics(keyName,depth+1);
   if ( pRight )
      pRight->McLogInternalDiagnostics(keyName,depth+1);
}

CIndexItem *                               // ret- smallest node in the index that is >= value
   CIndexTree::GetFirstAfter(
      CString                value         // in - string to compare keys to
   ) const
{
   CIndexItem              * item = m_root;
   CIndexItem              * result = NULL;
   int                       cRes;

   while ( item )
   {
      cRes = m_CompareKey(value,item);
      if ( ! cRes )
      {
         break;
      }
      if ( cRes > 0 )
      {
         item = item->Left();
      }
      else
      {
         result = item;
         item = item->Right();
      }
   }
   return result;
}


void CIndexTree::McLogInternalDiagnostics(CString keyName)
{
   CString blockname;
   blockname = "Index of "+ keyName;
   CString compareFn;
   CString compareKey;

   if ( m_Compare == &CompareItems )
   {
      compareFn = "CompareItems";
   }
   else if ( m_Compare == &CompareItemsNoCase )
   {
      compareFn = "CompareItemsNoCase";
   }
   else 
   {
      compareFn.Format(_T("Unknown function, address=%lx"),m_Compare);
   }

   if ( m_CompareKey == &CompareStringToItem )
   {
      compareKey = "CompareStringToItem";
   }
   else if ( m_CompareKey == &CompareStringToItemNoCase )
   {
      compareKey = "CompareStringToItemNoCase";
   }
   else
   {
      compareKey.Format(_T("Unknown function, address=%lx"),m_CompareKey);
   }

   MC_LOG(String(blockname) << "  CaseSensitive=" << makeStr(m_CaseSensitive) << " Compare Function="<<String(compareFn)<< "Compare Key Function=" << String(compareKey) );

   if ( m_root )
   {
      MC_LOG("Beginning preorder dump of index");
      m_root->McLogInternalDiagnostics(keyName,0);
   }
   else
   {
      MC_LOG("Root of index is NULL");
   }
}

#ifdef _DEBUG
BOOL CIndexTree::AssertValid(int nItems) const
{
   BOOL                      bValid = TRUE;
   int                       i;
   CIndexItem              * curr = GetFirstItem();
   CIndexItem              * prev = NULL;

   for ( i = 0 ; i < nItems ; i++ )
   {
      ASSERT(curr);
      if ( prev && curr )
      {
         ASSERT(m_Compare(prev,curr) <= 0 );
      }
      prev = curr;
      curr = GetNextItem(curr);
   }
   ASSERT(curr == NULL);  // we should have reached the end

   for ( i = 0 ; i < nItems -1 ; i++ )
   {
      prev = GetPrevItem(prev);
      ASSERT(prev);
   }
   ASSERT(prev == GetFirstItem());

   return bValid;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\vsmin.cpp ===
// McsVarSetMin.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for McsVarSetMin.idl by adding the following 
//      files to the Outputs.
//          McsVarSetMin_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsVarSetMinps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "Varset.h"
#include "dlldatax.h"

#include "VarSet_i.c"
#include "VarSetI_i.c"
#include "VSet.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_VarSet, CVSet)
END_OBJECT_MAP()

class CVarSetApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVarSetApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CVarSetApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CVarSetApp, CWinApp)
	//{{AFX_MSG_MAP(CVarSetApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CVarSetApp theApp;

BOOL CVarSetApp::InitInstance()
{
	ATLTRACE(_T("{McsVarSetMin.dll}CVarSetApp::InitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Init(ObjectMap, m_hInstance, &LIBID_MCSVARSETMINLib);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    return bInit;
}

int CVarSetApp::ExitInstance()
{
	ATLTRACE(_T("{McsVarSetMin.dll}CVarSetApp::ExitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\varset\varset\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "OUPicker.h"

#include "MainFrm.h"

#include "ContainerSelectionDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers


void CMainFrame::OnFileNew() 
{
 	CContainerSelectionDlg  dlg;
   dlg.m_strDomain = CString("devraptorw2k");
   dlg.m_strCont = CString("OU=THANKS,OU=MAWLA,OU=TRIAL,OU=HELLO");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__0691ACEE_9532_4F8F_9730_EA1A9D459725__INCLUDED_)
#define AFX_MAINFRM_H__0691ACEE_9532_4F8F_9730_EA1A9D459725__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnFileNew();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__0691ACEE_9532_4F8F_9730_EA1A9D459725__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\callback.h ===
#pragma once
#include "GuiUtils.h"

INT_PTR CALLBACK
IntOptionsGroupMappingProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);	
INT_PTR CALLBACK
IntDomainSelectionProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);	
INT_PTR CALLBACK
IntTargetGroupProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);	

INT_PTR CALLBACK
IntTrustProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntCommitProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntHTMLLocationProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
NoncollisionRenamingProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntOptionsReportingProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntSelectionSecurityProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);

INT_PTR CALLBACK
IntRetryProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntDisableProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntUndoProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntPasswordProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntOptionsProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntExchangeSelectionProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntRebootProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntTranslationProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntTranslationModeProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntGroupOptionsProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntCredentialsProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntServiceRefreshProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntServiceInfoButtonProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntServiceInfoProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntCredentials2Proc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntRenameProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntOuSelectionProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK 
IntroDlgProc(
    IN HWND     hwndDlg,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
INT_PTR CALLBACK 
IntOptionsFromUserProc(
    IN HWND     hwndDlg,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
INT_PTR CALLBACK 
IntSelectionProc(
    IN HWND     hwndDlg,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
INT_PTR CALLBACK 
EndDlgProc(
    IN HWND     hwndDlg,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
INT_PTR CALLBACK
IntTranslationInputProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
INT_PTR CALLBACK
IntPropExclusionProc(
	IN HWND hwndDlg,
	IN UINT uMsg,
	IN WPARAM wParam,
	IN LPARAM lParam
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\migrvar.h ===
// EnumVar.h: interface for the CEnumVar class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENUMVAR_H__EFC2C760_1A9F_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_ENUMVAR_H__EFC2C760_1A9F_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define UNLEN        255

// The follwing flags make up a bitmask used to define what values the Enumerator fills up
// for a given object.

// TODO :: We can add more attributes in order to get the appropriate information from the Object
//         when we enumerate it. To add items simply add a flag and then add an item to the struct.
#define  F_Name              0x00000001
#define  F_Class             0x00000002
#define  F_SamName           0x00000004
#define  F_GroupType         0x00000008

// Structure used to fill out information about the object
typedef struct _Obj {
   WCHAR                     sName[UNLEN];    // Common Name of the object
   WCHAR                     sClass[UNLEN];   // The type of the object
   WCHAR                     sSamName[UNLEN]; // SamAccountName of the object
   long                      groupType;       // The type of a group object (UNIVERSAL etc)
} SAttrInfo;

class CEnumVar  
{
public:
	BOOL Next( long flag, SAttrInfo * pAttr );
	IEnumVARIANT  * m_pEnum;
	CEnumVar(IEnumVARIANT  * pEnum);
	virtual ~CEnumVar();
};

#endif // !defined(AFX_ENUMVAR_H__EFC2C760_1A9F_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\containerselectiondlg.cpp ===
// ContainerSelectionDlg.cpp : implementation file
//

#include "stdafx.h"
#include "OUPicker.h"
#include "ContainerSelectionDlg.h"
#include "iads.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CContainerSelectionDlg dialog

const BSTR sQuery = L"(|(objectClass=organizationalUnit) (objectClass=container))";
HTREEITEM root;

CContainerSelectionDlg::CContainerSelectionDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CContainerSelectionDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CContainerSelectionDlg)
	m_strCont = _T("");
	//}}AFX_DATA_INIT
}


void CContainerSelectionDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CContainerSelectionDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_TREE1, m_trOUTree);
	DDX_Text(pDX, IDC_EDIT1, m_strCont);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CContainerSelectionDlg, CDialog)
	//{{AFX_MSG_MAP(CContainerSelectionDlg)
	ON_BN_CLICKED(IDOK, OnOk)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREE1, OnSelchangedTree1)
	ON_NOTIFY(NM_DBLCLK, IDC_TREE1, OnDblclkTree1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CContainerSelectionDlg message handlers

void CContainerSelectionDlg::OnOk() 
{
   CDialog::OnOK();	
}

BOOL CContainerSelectionDlg::OnInitDialog() 
{
   CWaitCursor wait;
	CDialog::OnInitDialog();
   if ( m_strDomain.IsEmpty() )
      return TRUE;

   LoadImageList();

   root = m_trOUTree.InsertItem(m_strDomain, 0, 1);
   ExpandCompletely(root, L"");
   FindContainer();
   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE

}

HRESULT CContainerSelectionDlg::PopulateContainer(
                                                  HTREEITEM tvItemParent,        //in- Item to expand
                                                  BSTR      sContName,           //in- Name of the container.
                                                  INetObjEnumeratorPtr pQuery    //in- Query Object
                                                 )
{
   HRESULT                   hr = E_FAIL;
   IEnumVARIANT            * pEnum = NULL;
   SAFEARRAY               * psaCols = NULL;
   SAFEARRAYBOUND            bd = { 2, 0 };
   LPWSTR                    pCols[] = { L"name", L"objectClass" };
   BSTR  HUGEP             * pData;
   _variant_t                var;
   DWORD                     dwFetch = 0;
   BSTR                      domain = m_strDomain.AllocSysString();
   SAFEARRAY               * psaVals;
   _bstr_t                   sValName;
   _bstr_t                   sType;
   _variant_t              * pDataVar;
   _variant_t                varVal;
   WCHAR                     sTempName[255];
   int                       img = 0;

   psaCols = SafeArrayCreate(VT_BSTR, 1, &bd);
   if ( psaCols )
   {
      hr = SafeArrayAccessData(psaCols, (void HUGEP **)&pData);
      if ( SUCCEEDED(hr) )
      {
         pData[0] = SysAllocString(pCols[0]);
         pData[1] = SysAllocString(pCols[1]);
      }
      SafeArrayUnaccessData(psaCols);
   }


   if ( SUCCEEDED(hr))
      hr = pQuery->raw_SetQuery(sContName, domain, sQuery, ADS_SCOPE_ONELEVEL, FALSE);

   if ( SUCCEEDED(hr) )
      hr = pQuery->raw_SetColumns(psaCols);

   if ( SUCCEEDED(hr))
      hr = pQuery->raw_Execute(&pEnum);

   if ( pEnum )
   {
      while ( pEnum->Next(1, &var, &dwFetch) == S_OK )
      {
         psaVals = V_ARRAY(&var);
         hr = SafeArrayAccessData(psaVals, (void**)&pDataVar);
         if ( SUCCEEDED(hr) )
         {
            varVal = pDataVar[0];
            if ( varVal.vt == VT_BSTR ) sValName = V_BSTR(&varVal);
            varVal = pDataVar[1];
            if ( varVal.vt == VT_BSTR ) sType = V_BSTR(&varVal);
            SafeArrayUnaccessData(psaVals);
         }


         if ( SUCCEEDED(hr) )
         {
            // 
            if ( wcsicmp(sType, L"organizationalUnit") == 0 )
            {
               wsprintf(sTempName, L"OU=%s", (WCHAR*)sValName);
               img = 4;
            }
            else
            {
               wsprintf(sTempName, L"CN=%s", (WCHAR*)sValName);
               img = 2;
            }
            if ( wcsicmp(sTempName, L"CN=System") != 0 )
               m_trOUTree.InsertItem(sTempName, img, img+1, tvItemParent);
         }
      }
   }
   
   // Clean up
   ::SysFreeString(domain);
   if ( pEnum ) pEnum->Release();
   VariantInit(&var);
   return hr;
}


HRESULT CContainerSelectionDlg::ExpandCompletely(HTREEITEM tvItem, BSTR parentCont)
{
   HTREEITEM                 tvChild;
   WCHAR                     currCont[255];
   CString                   sContName;
   HRESULT                   hr = S_OK;
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));

   // First populate this container
   hr = PopulateContainer( tvItem, parentCont, pQuery);

   // Check if it has children. If it does then for each child call this function recursively
   if ( m_trOUTree.ItemHasChildren(tvItem) )
   {
      tvChild = m_trOUTree.GetChildItem(tvItem);
      while ( tvChild )
      {
         // Get the name of the 
         sContName = m_trOUTree.GetItemText(tvChild);
         if ( wcslen(parentCont) > 0 )
            wsprintf(currCont, L"%s,%s", sContName, (WCHAR*)parentCont);
         else
            wcscpy(currCont, sContName);
         ExpandCompletely(tvChild, currCont);
         tvChild = m_trOUTree.GetNextSiblingItem(tvChild);
      }
   }
   return hr;
}

BOOL CContainerSelectionDlg::LoadImageList()
{
	// set up icon list for list box
   // use bitmaps 
   CBitmap           cont;
   CBitmap           ou;
   CBitmap           openCont;
   CBitmap           openOU;
   CBitmap           dir;
   CBitmap           dirOpen;
   
   COLORREF          cr = 0x000000;
   if (
      dir.LoadBitmap(IDB_DIR)
      && dirOpen.LoadBitmap(IDB_OPEN_DIR)
      && cont.LoadBitmap(IDB_CONT)
      && ou.LoadBitmap(IDB_OU)
      && openCont.LoadBitmap(IDB_OPEN_CONT)
      && openOU.LoadBitmap(IDB_OPEN_OU)
   )
   {
      cr = GetFirstBitmapPixel(this,IDB_CONT);
      ilist.Create(IDB_DIR, 16, 16, cr);
      ilist.Add(&dirOpen, cr);
      ilist.Add(&cont,cr);
      ilist.Add(&openCont,cr);
      ilist.Add(&ou,cr);
      ilist.Add(&openOU,cr);
      m_trOUTree.SetImageList(&ilist,TVSIL_NORMAL);
   }
   return TRUE;
}

COLORREF CContainerSelectionDlg::GetFirstBitmapPixel(CWnd * window,UINT idbBitmap)
{
   CBitmap     bmp;
   COLORREF    color = 0x00ffffff;
   
   if ( bmp.LoadBitmap(idbBitmap) )
   {
      // Get Device context       
      CDC                  * windowDC = window->GetDC();
      HDC                    hdcImage = ::CreateCompatibleDC(windowDC->m_hDC);
      CBitmap              * tempBmp = (CBitmap *)::SelectObject(hdcImage,(HBITMAP)bmp);
      // now get the pixel
      if ( windowDC && hdcImage && tempBmp )
      {
         color = GetPixel(hdcImage,0, 0);
      }
      if ( tempBmp )
         ::SelectObject(hdcImage,tempBmp);
      if ( hdcImage )
         ::DeleteObject(hdcImage);
   }
   return color;
}

void CContainerSelectionDlg::OnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult) 
{
   m_strCont = L"";
	HTREEITEM                 tvSelected, tvParent;
   NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
   tvSelected = m_trOUTree.GetSelectedItem();
   if ( tvSelected )
   {
      // We dont want to process the domain name in the Container name so go upto
      // the point where we have a parent. i.e. Child of the domain node.
      while( tvParent = m_trOUTree.GetParentItem(tvSelected) )
      {
         // Build the container list by walking up the tree.
         if ( m_strCont.IsEmpty() )
            m_strCont = m_trOUTree.GetItemText(tvSelected);
         else
            m_strCont = m_strCont + CString(L",") + m_trOUTree.GetItemText(tvSelected);
         tvSelected = tvParent;
      }
   }
   m_btnOK.EnableWindow(!m_strCont.IsEmpty());
   UpdateData(FALSE);
	*pResult = 0;
}

void CContainerSelectionDlg::OnDblclkTree1(NMHDR* pNMHDR, LRESULT* pResult) 
{
   UpdateData();
   if ( !m_strCont.IsEmpty() )
      OnOk();	
	*pResult = 0;
}

HRESULT CContainerSelectionDlg::FindContainer()
{
   CString                   strName;
   int                       ndx = 0, oldNdx = -1;
   // We can find the container iff there is one specified.
   if (!m_strCont.IsEmpty())
   {
      OpenContainer(m_strCont, root);
   }
   return S_OK;
}

HTREEITEM CContainerSelectionDlg::OpenContainer(CString strCont, HTREEITEM rootSub)
{
   int                       ndx = -1;
   CString                   strLeft, strRight;
   HTREEITEM                 tvItem = NULL;

   if ( !strCont.IsEmpty() && rootSub ) 
   {
      ndx = strCont.Find(L",", 0);
      if ( ndx > -1 )
      {
         // Get the right side of the comma string and Call this again to open the parent container.
         strLeft = strCont.Left(ndx);
         strRight = strCont.Mid(ndx + 1);
         tvItem = OpenContainer(strRight, rootSub);
         tvItem = OpenContainer(strLeft, tvItem);
      }
      else
      {
         // We have a container name so lets find it below rootSub node.
         tvItem = m_trOUTree.GetChildItem(rootSub);
         while (tvItem)
         {
            if ( m_trOUTree.GetItemText(tvItem) == strCont )
            {
               //m_trOUTree.Expand(tvItem, 0);
               m_trOUTree.Select(tvItem, TVGN_CARET);
               break;
            }
            tvItem = m_trOUTree.GetNextSiblingItem(tvItem);
         }
      }
   }
   return tvItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\guiutils.cpp ===
#include "stdafx.h"
#include "GuiUtils.h"
#include "TxtSid.h"
#include "LSAUtils.h"
#include "ErrDct.hpp"
#include <ntdsapi.h>
#include <ntldap.h>   // LDAP_MATCHING_RULE_BIT_AND_W
#include <lm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef UINT (CALLBACK* DSBINDFUNC)(TCHAR*, TCHAR*, HANDLE*);
typedef UINT (CALLBACK* DSUNBINDFUNC)(HANDLE*);

typedef NTDSAPI
DWORD
WINAPI
 DSCRACKNAMES(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult);         // out


typedef NTDSAPI
void
WINAPI
 DSFREENAMERESULT(
  DS_NAME_RESULTW *pResult
);

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif
#ifndef IADsUserPtr
_COM_SMARTPTR_TYPEDEF(IADsUser, IID_IADsUser);
#endif
#ifndef IADsContainerPtr
_COM_SMARTPTR_TYPEDEF(IADsContainer, IID_IADsContainer);
#endif


BOOL
   CanSkipVerification()
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;
   DWORD                     val = 0;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);

   if (! rc )
   {
      rc = key.ValueGetDWORD(L"SkipGUIValidation",&val);
      if ( ! rc && ( val != 0 ) )
      {
         bFound = TRUE;
      }
   }
   return !bFound;
}


BOOL                                       // ret - TRUE if directory found
   GetDirectory(
      WCHAR                * filename      // out - string buffer to store directory name
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;


   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);


   if ( ! rc )
   {

	   rc = key.ValueGetStr(L"Directory",filename,MAX_PATH);

	   if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }


   return bFound;
}


void OnTOGGLE()
{
	int nItem;
	CString c,computer,account,service;
//	POSITION pos = m_serviceBox.GetFirstSelectedItemPosition();
	CString skip,include;
	skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); 
//	while (pos)
//	{
//		nItem = m_serviceBox.GetNextSelectedItem(pos);
	nItem = m_serviceBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		computer = m_serviceBox.GetItemText(nItem,0);
		service = m_serviceBox.GetItemText(nItem,1);
		account = m_serviceBox.GetItemText(nItem,2);
		c = m_serviceBox.GetItemText(nItem,3);

		if (c==skip)
		{
			c = include;
//			db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account),SvcAcctStatus_NotMigratedYet);
		}
		else if (c== include)
		{	
			c = skip;
//			db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account), SvcAcctStatus_DoNotUpdate);
		}
		SetItemText(m_serviceBox,nItem,3,c);
		nItem = m_serviceBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}
}
void OnRetryToggle()
{
	int nItem;
	CString c;
//	POSITION pos = m_cancelBox.GetFirstSelectedItemPosition();
	CString skip,include;
	skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); 
//	while (pos)
//	{

//		nItem = m_cancelBox.GetNextSelectedItem(pos);
	nItem = m_cancelBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		c = m_cancelBox.GetItemText(nItem,5);
		if (c== skip)
		{
			c = include;
		}
		else if (c== include)
		{
			c = skip;
		}
		SetItemText(m_cancelBox,nItem,5,c);
		nItem = m_cancelBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}
}

void OnUPDATE(HWND hwndDlg)
{

	ISvcMgrPtr svcMgr;
	HRESULT hr = svcMgr.CreateInstance(CLSID_ServMigr);
	int nItem;

	CString updated,updatefailed;
	updated.LoadString(IDS_UPDATED);updatefailed.LoadString(IDS_UPDATEFAILED); 

	CString computer,service,account,status;
//	POSITION pos = m_serviceBox.GetFirstSelectedItemPosition();
//	while (pos)
//	{
//		nItem = m_serviceBox.GetNextSelectedItem(pos);
	nItem = m_serviceBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		status = m_serviceBox.GetItemText(nItem,3);
		if (status == updatefailed)
		{
			computer = m_serviceBox.GetItemText(nItem,0);
			account= m_serviceBox.GetItemText(nItem,2);
			service = m_serviceBox.GetItemText(nItem,1);
			hr = svcMgr->raw_TryUpdateSam(_bstr_t(computer),_bstr_t(service),_bstr_t(account));
			if (! SUCCEEDED(hr))
			{
				db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account), SvcAcctStatus_UpdateFailed);
				SetItemText(m_serviceBox,nItem,3,updatefailed);
				ErrorWrapper(hwndDlg,hr);
			}
			else
			{
				db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account), SvcAcctStatus_Updated);
				SetItemText(m_serviceBox,nItem,3,updated);
			}
		}
		nItem = m_serviceBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}
}

DWORD  VerifyPassword(WCHAR  * sUserName, WCHAR * sPassword, WCHAR * sDomain)
{
   CWaitCursor			wait;
   DWORD				retVal = 0;
   CString				strDomainUserName;
   CString				localIPC;
   WCHAR				localMachine[MAX_PATH];
   WCHAR			  * computer = NULL;
   DWORD				len = DIM(localMachine);
   NETRESOURCE			nr;
   CString				error=L"no error";
   USER_INFO_3        * pInfo = NULL;
   NET_API_STATUS		rc;

   memset(&nr,0,(sizeof nr));

   if ( ! gbNeedToVerify )
      return 0;

   /* see if this domain exists and get a DC name */
      //get the domain controller name
   if (!GetDomainDCName(sDomain,&computer))
      return ERROR_LOGON_FAILURE;

   /* see if this user is a member of the given domain */
   rc = NetUserGetInfo(computer, sUserName, 3, (LPBYTE *)&pInfo);
   NetApiBufferFree(computer);
   if (rc != NERR_Success)
      return ERROR_LOGON_FAILURE;

   NetApiBufferFree(pInfo);

   /* see if the password allows us to connect to a local resource */
   strDomainUserName.Format(L"%s\\%s",sDomain,sUserName);
   // get the name of the local machine
   if (  GetComputerName(localMachine,&len) )
   {

	   localIPC.Format(L"\\\\%s",localMachine);
      nr.dwType = RESOURCETYPE_ANY;
      nr.lpRemoteName = localIPC.GetBuffer(0);
      retVal = WNetAddConnection2(&nr,sPassword,strDomainUserName,0);
error.Format(L"WNetAddConnection returned%u",retVal);	
	  if ( ! retVal )
      {
		error.Format(L"WNetAddConnection2 succeeded");

         retVal = WNetCancelConnection2(localIPC.GetBuffer(0),0,TRUE);
         if ( retVal )
            retVal = 0;
      }
      else if ( retVal == ERROR_SESSION_CREDENTIAL_CONFLICT )
      {

         // skip the password check in this case
         retVal = 0;
      }
	}
   else
   {
	   retVal = GetLastError();
	
   }
   return retVal;
}

void activateTrustButton(HWND hwndDlg)
{
//	int i = m_trustBox.GetSelectionMark();
	int i = m_trustBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	CString c;
	if (i==-1)
	{
		disable(hwndDlg,IDC_MIGRATE) ;
		return;
	}
	else if ((c = m_trustBox.GetItemText(i,3)) == (WCHAR const *) yes)
	{
		disable(hwndDlg,IDC_MIGRATE) ;
		return;
	}
	enable(hwndDlg,IDC_MIGRATE);
}


void activateServiceButtons(HWND hwndDlg)
{
	int nItem;
	CString checker;
	bool enableUpdate=false;
	bool enableToggle=false;
	CString skip,include,updated,updatefailed;
	skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); updated.LoadString(IDS_UPDATED);updatefailed.LoadString(IDS_UPDATEFAILED); 

//	POSITION pos = m_serviceBox.GetFirstSelectedItemPosition();

//	while (pos)
//	{
//		nItem = m_serviceBox.GetNextSelectedItem(pos);
	nItem = m_serviceBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		checker = m_serviceBox.GetItemText(nItem,3);
		enableToggle = enableToggle || (checker==skip|| checker==include);
		enableUpdate = enableUpdate || (checker==updatefailed);
		nItem = m_serviceBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}
	enableToggle ? enable(hwndDlg,IDC_TOGGLE) : disable(hwndDlg,IDC_TOGGLE);
	enableUpdate ? enable(hwndDlg,IDC_UPDATE) : disable(hwndDlg,IDC_UPDATE);
}	
void activateServiceButtons2(HWND hwndDlg)
{
	int nItem;
	CString checker;
	bool enableToggle=false;
	CString skip,include;
	skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); 
//	POSITION pos = m_serviceBox.GetFirstSelectedItemPosition();

//	while (pos)
//	{
//		nItem = m_serviceBox.GetNextSelectedItem(pos);
	nItem = m_serviceBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		checker = m_serviceBox.GetItemText(nItem,3);
		enableToggle = enableToggle || (checker==skip || checker==include);
		nItem = m_serviceBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}
	enableToggle ? enable(hwndDlg,IDC_TOGGLE) : disable(hwndDlg,IDC_TOGGLE);
}	

void removeService(CString name)
{
	name = name.Right((name.GetLength()-name.ReverseFind(L'\\')) -1);
	name.TrimLeft();name.TrimRight();
	_bstr_t text=get(DCTVS_Accounts_NumItems);
	CString base,base2,tocompare;
	int count = _ttoi((WCHAR * const) text);
	for (int i=0;i<count;i++)
	{
		base.Format(L"Accounts.%d.Name",i);
		text =pVarSet->get(_bstr_t(base));
		tocompare = (WCHAR * const) text;
		tocompare.TrimLeft();tocompare.TrimRight();
		if (!name.CompareNoCase(tocompare))
		{
			count--;
			base.Format(L"Accounts.%d",count);
			base2.Format(L"Accounts.%d",i);

			pVarSet->put(_bstr_t(base2),pVarSet->get(_bstr_t(base)));
			pVarSet->put(_bstr_t(base2+L".Name"),pVarSet->get(_bstr_t(base+L".Name")));
			pVarSet->put(_bstr_t(base2+L".Type"),pVarSet->get(_bstr_t(base+L".Type")));
			pVarSet->put(_bstr_t(base2+L".TargetName"),pVarSet->get(_bstr_t(base+L".TargetName")));

			pVarSet->put(_bstr_t(base),L"");
			pVarSet->put(_bstr_t(base+L".Name"),L"");
			pVarSet->put(_bstr_t(base+L".Type"),L"");
			pVarSet->put(_bstr_t(base+L".TargetName"),L"");


			put(DCTVS_Accounts_NumItems,(long) count);
			return;
		}
	}
}
void setDBStatusSkip()
{
	CString computer,account,service;
	for (int i=0;i<m_serviceBox.GetItemCount();i++)
	{
		computer = m_serviceBox.GetItemText(i,0);
		service = m_serviceBox.GetItemText(i,1);
		account = m_serviceBox.GetItemText(i,2);
		db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account),SvcAcctStatus_DoNotUpdate);
		removeService(account);
	}
}
bool setDBStatusInclude(HWND hwndDlg)
{
	CString c,computer,account,service;
	CString skip,include;
	skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); 
	bool messageDisplayed=false;
	for (int i=0;i<m_serviceBox.GetItemCount();i++)
	{
		computer = m_serviceBox.GetItemText(i,0);
		service = m_serviceBox.GetItemText(i,1);
		account = m_serviceBox.GetItemText(i,2);
		c = m_serviceBox.GetItemText(i,3);
		if (c== skip)
		{
			db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account),SvcAcctStatus_DoNotUpdate);
		}
		else if (c==include)
		{
			messageDisplayed=true;
			db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account), SvcAcctStatus_NotMigratedYet);
		}
	}
	return messageDisplayed;
}

void getService()
{
	IUnknown * pUnk;
	CString skip,include,updated,updatefailed,cannotMigrate;
	skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); updated.LoadString(IDS_UPDATED); updatefailed.LoadString(IDS_UPDATEFAILED);
	cannotMigrate.LoadString(IDS_CANNOT);

	m_serviceBox.DeleteAllItems();
	if (migration!=w_account)
	{
		pVarSetService->QueryInterface(IID_IUnknown, (void**) &pUnk);
		db->GetServiceAccount(L"",&pUnk);
		pUnk->Release();
	}				
	//	pVarSetService is now containing all service acct information.
	_bstr_t text;
	text = pVarSetService->get(L"ServiceAccountEntries");
	int numItems=_ttoi((WCHAR const *)text);
	CString toLoad,temp;
	toLoad = (WCHAR const *)text;

	for (int i = 0; i< numItems;i++)
	{
		
		toLoad.Format(L"Computer.%d",i);
		text = 	pVarSetService->get(_bstr_t(toLoad));		
		m_serviceBox.InsertItem(0,(WCHAR const *)text);
		toLoad.Format(L"Service.%d",i);
		text = 	pVarSetService->get(_bstr_t(toLoad));
		SetItemText(m_serviceBox,0,1,(WCHAR const *)text);
		toLoad.Format(L"ServiceAccount.%d",i);
		text = 	pVarSetService->get(_bstr_t(toLoad));
		SetItemText(m_serviceBox,0,2,(WCHAR const *)text);
		toLoad.Format(L"ServiceAccountStatus.%d",i);
		text = 	pVarSetService->get(_bstr_t(toLoad));
		
		if (!UStrCmp(text,L"0"))  temp = include;
		else if (!UStrCmp(text,L"1")) temp = skip;
		else if (!UStrCmp(text,L"4")) temp = updatefailed;
		else if (!UStrCmp(text,L"2")) temp = updated;
		else if (!UStrCmp(text,L"8")) temp = cannotMigrate;
		else temp =L"~";
		SetItemText(m_serviceBox,0,3,temp);	
		
		//new
		toLoad.Format(L"ServiceDisplayName.%d",i);
		text = 	pVarSetService->get(_bstr_t(toLoad));
		SetItemText(m_serviceBox,0,4,(WCHAR const *)text);
	}
}

void refreshDB(HWND hwndDlg)
{
	_variant_t varX = L"{9CC87460-461D-11D3-99F3-0010A4F77383}";
	pVarSet->put(L"PlugIn.0",varX);
	
	IPerformMigrationTaskPtr      w;  
	IUnknown                    * pUnk = NULL;
	HRESULT hr = w.CreateInstance(CLSID_Migrator);
	pVarSet->QueryInterface(IID_IUnknown,(void**)&pUnk);			
	try
	{
		w->PerformMigrationTask(pUnk,(LONG_PTR)hwndDlg);	
	}	
	catch (const _com_error &e)
	{
		if (e.Error() == MIGRATOR_E_PROCESSES_STILL_RUNNING)
		{
			CString str;
			str.LoadString(IDS_ADMT_PROCESSES_STILL_RUNNING);
			::AfxMessageBox(str);
		}
		else
		{
			::AfxMessageBox(e.ErrorMessage());
		}
	}
	pUnk->Release();
	varX = L"";
	pVarSet->put(L"PlugIn.0",varX);
}

void initnoncollisionrename(HWND hwndDlg)
{
	_bstr_t     pre;
	_bstr_t     suf;
	
	pre = get(DCTVS_Options_Prefix);
	suf = get(DCTVS_Options_Suffix);
	
	if (UStrICmp(pre,L""))
	{
		CheckRadioButton(hwndDlg,IDC_RADIO_NONE,IDC_RADIO_PRE,IDC_RADIO_PRE);
		enable(hwndDlg,IDC_PRE);
		disable(hwndDlg,IDC_SUF);
	}
	else if (UStrICmp(suf,L""))
	{
		CheckRadioButton(hwndDlg,IDC_RADIO_NONE,IDC_RADIO_SUF,IDC_RADIO_SUF);
		enable(hwndDlg,IDC_SUF);
		disable(hwndDlg,IDC_PRE);
	}
	else
	{
		CheckRadioButton(hwndDlg,IDC_RADIO_NONE,IDC_RADIO_SUF,IDC_RADIO_NONE);
		disable(hwndDlg,IDC_SUF);
		disable(hwndDlg,IDC_PRE);
	}

	initeditbox(hwndDlg,IDC_PRE,DCTVS_Options_Prefix);
	initeditbox(hwndDlg,IDC_SUF,DCTVS_Options_Suffix);
}
bool noncollisionrename(HWND hwndDlg)
{	
	CString P;
	CString S;
	if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_SUF))
	{
		if (!validString(hwndDlg,IDC_SUF)) return false;
		if (IsDlgItemEmpty(hwndDlg,IDC_SUF)) return false;
		GetDlgItemText(hwndDlg,IDC_SUF,S.GetBuffer(1000),1000);
		S.ReleaseBuffer();
		P=L"";		
	}
	else if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_PRE))
	{
		if (!validString(hwndDlg,IDC_PRE)) return false;
		if (IsDlgItemEmpty(hwndDlg,IDC_PRE)) return false;
		GetDlgItemText(hwndDlg,IDC_PRE,P.GetBuffer(1000),1000);
		P.ReleaseBuffer();
		S=L"";
	}
	else
	{
		P=L"";
		S=L"";
	}
if (P.GetLength() > 8 || S.GetLength() >8) return false;
	put(DCTVS_Options_Prefix,_bstr_t(P));
	put(DCTVS_Options_Suffix,_bstr_t(S));
	return true;
}

bool tooManyChars(HWND hwndDlg,int id)
{
    _bstr_t     text;
	CString temp;
	_variant_t varX;
	int i;

	GetDlgItemText( hwndDlg, id, temp.GetBuffer(1000),1000);	
	temp.ReleaseBuffer();
	i=temp.GetLength();
	
	text = get(DCTVS_Options_Prefix);
	temp=(WCHAR const *) text;
	i+= temp.GetLength();
	text = get(DCTVS_Options_Suffix);
	temp=(WCHAR const *) text;
	i+= temp.GetLength();

	return (i>8);
}

bool someServiceAccounts(int accounts,HWND hwndDlg)
{
	CWaitCursor c;
	if (migration==w_group) return false;
	
	IVarSetPtr  pVarSetMerge(__uuidof(VarSet));
	
	IUnknown * pUnk;
	int count=0;
	
	pVarSetMerge->QueryInterface(IID_IUnknown, (void**) &pUnk);
	_bstr_t nameToCheck,text;
	CString parameterToCheck;
	bool some= false;
	pVarSetService->Clear();
	for (int i = 0;i<accounts;i++)
	{
		pVarSetMerge->Clear();
		parameterToCheck.Format(L"Accounts.%d",i);
		nameToCheck = pVarSet->get(_bstr_t(parameterToCheck));
		// Get the DOMAIN\Account form of the name
		WCHAR       domAcct[500];
		WCHAR       domAcctUPN[5000];
		
		domAcct[0] = 0;
		if ( ! wcsncmp(nameToCheck,L"WinNT://",UStrLen(L"WinNT://")) )
		{
			// the name is in the format: WinNT://DOMAIN/Account
			safecopy(domAcct,((WCHAR*)nameToCheck)+UStrLen(L"WinNT://"));
			
			// convert the / to a \ .
			WCHAR     * slash = wcschr(domAcct,L'/');
			if ( slash )
			{
				(*slash) = L'\\';
			}
		}
		else
		{
			// this is the LDAP form of the name.
			IADsUserPtr pUser;
			
			HRESULT hr = ADsGetObject(nameToCheck,IID_IADsUser,(void**)&pUser);
			if ( SUCCEEDED(hr) )
			{
				VARIANT        v;
				
				VariantInit(&v);
				
				hr = pUser->Get(_bstr_t(L"sAMAccountName"),&v);
				if ( SUCCEEDED(hr) )
				{
					if ( v.vt == VT_BSTR  )
					{
						// we got the account name!
						swprintf(domAcct,L"%ls\\%ls",sourceNetbios,(WCHAR*)v.bstrVal);
					}
					VariantClear(&v);
				}
			}
			else
			{
				CString toload,title;toload.LoadString(IDS_MSG_SA_FAILED);
				title.LoadString(IDS_MSG_ERROR);
				MessageBox(hwndDlg,toload,title,MB_OK|MB_ICONSTOP);
				return false;
			}
		}
		
		if ( *domAcct ) // if we weren't able to get the account name, just skip the DB check
		{
			
			HRESULT hr=db->raw_GetServiceAccount(domAcct,&pUnk);
			if (FAILED(hr)) {
				CString toload,title;toload.LoadString(IDS_MSG_SA_FAILED);
				title.LoadString(IDS_MSG_ERROR);
				MessageBox(hwndDlg,toload,title,MB_OK|MB_ICONSTOP);
				return false;
			}
			text = pVarSetMerge->get(L"ServiceAccountEntries");

				//adding code to handle service accounts in the database that
				//may be listed by their UPN name
			if ((!UStrCmp(text,L"0")) || (!UStrCmp(text,L"")))
			{
               PDS_NAME_RESULT         pNamesOut = NULL;
               WCHAR                 * pNamesIn[1];
			   HINSTANCE               hLibrary = NULL;
			   DSCRACKNAMES          * DsCrackNames = NULL;
			   DSFREENAMERESULT      * DsFreeNameResult = NULL;
			   DSBINDFUNC              DsBind = NULL;
			   DSUNBINDFUNC            DsUnBind = NULL;
			   HANDLE                  hDs = NULL;

               pNamesIn[0] = (WCHAR*)domAcct;

               hLibrary = LoadLibrary(L"NTDSAPI.DLL"); 

               if ( hLibrary )
               {
                  DsBind = (DSBINDFUNC)GetProcAddress(hLibrary,"DsBindW");
                  DsUnBind = (DSUNBINDFUNC)GetProcAddress(hLibrary,"DsUnBindW");
                  DsCrackNames = (DSCRACKNAMES *)GetProcAddress(hLibrary,"DsCrackNamesW");
                  DsFreeNameResult = (DSFREENAMERESULT *)GetProcAddress(hLibrary,"DsFreeNameResultW");
               }
            
               if ( DsBind && DsUnBind && DsCrackNames && DsFreeNameResult)
               {
					//bind to that source domain
				  hr = (*DsBind)(NULL,sourceDNS.GetBuffer(1000),&hDs);
				  sourceDNS.ReleaseBuffer();
				  if ( !hr )
				  {
				      //get UPN name of this account from DSCrackNames
			         hr = (*DsCrackNames)(hDs,DS_NAME_NO_FLAGS,DS_NT4_ACCOUNT_NAME,DS_USER_PRINCIPAL_NAME,1,pNamesIn,&pNamesOut);
				     if ( !hr )
					 {     //if got the UPN name, retry DB query for that account in the
					    	//service account database
					    if ( pNamesOut->rItems[0].status == DS_NAME_NO_ERROR )
						{
						    wcscpy(domAcctUPN, pNamesOut->rItems[0].pName);
						 
							   //see if account in database by its UPN name
						    hr=db->raw_GetServiceAccount(domAcctUPN,&pUnk);
						    if (!SUCCEEDED (hr)) 
							{
					  		   CString toload,title;toload.LoadString(IDS_MSG_SA_FAILED);
							   title.LoadString(IDS_MSG_ERROR);
							   MessageBox(hwndDlg,toload,title,MB_OK|MB_ICONSTOP);
							   return false;
							}
						    text = pVarSetMerge->get(L"ServiceAccountEntries");
						}
	                    (*DsFreeNameResult)(pNamesOut);
					 }
					 (*DsUnBind)(&hDs);
				  }
			   }
		       
			   if ( hLibrary )
			   {
		          FreeLibrary(hLibrary);
			   }
			}

			if (UStrCmp(text,L"0") && UStrCmp(text,L""))
			{	
				int number=_ttoi((WCHAR * const) text);
				CString base,loader;
				_bstr_t text;
				for (int i=0;i<number;i++)
				{
					some=true;
					
					base.Format(L"Computer.%d",i);			
					text= pVarSetMerge->get(_bstr_t(base));				 
					loader.Format(L"Computer.%d",count);
					pVarSetService->put(_bstr_t(loader),text);
					
					base.Format(L"Service.%d",i);			
					text= pVarSetMerge->get(_bstr_t(base));				 
					loader.Format(L"Service.%d",count);
					pVarSetService->put(_bstr_t(loader),text);
					
					base.Format(L"ServiceAccount.%d",i);			
					text= pVarSetMerge->get(_bstr_t(base));
						//store the sAMAccountName in the varset and database rather
						//than the UPN name
					wcscpy((WCHAR*)text, domAcct);
					loader.Format(L"ServiceAccount.%d",count);
					pVarSetService->put(_bstr_t(loader),text);
					
					base.Format(L"ServiceAccountStatus.%d",i);			
					text= pVarSetMerge->get(_bstr_t(base));				 
					loader.Format(L"ServiceAccountStatus.%d",count);
					pVarSetService->put(_bstr_t(loader),text);
					

					base.Format(L"ServiceDisplayName.%d",i);			
					text= pVarSetMerge->get(_bstr_t(base));				 
					loader.Format(L"ServiceDisplayName.%d",count);
					pVarSetService->put(_bstr_t(loader),text);

					count++;
					pVarSetService->put(L"ServiceAccountEntries",(long) count);
				}
			}
		}
		}
	pUnk->Release();
	return some;
}
CString timeToCString(int varsetKey)
{
	_bstr_t     text;
	time_t t;	
	CString s;
	CString t2;
	text = pVarSet->get(GET_BSTR(varsetKey));
	t2 = (WCHAR * ) text;
	t2.TrimLeft();t2.TrimRight();
	if ((t2.IsEmpty() != FALSE) || (!t2.CompareNoCase(L"0")))
	{
		s.LoadString(IDS_NOT_CREATED);
	}
	else
	{
//*		t = _ttoi((WCHAR const *)text);
//*		CTime T(t);
		
//*		s = T.Format( "%c" );
		t = _ttoi((WCHAR const *)text);

   		SYSTEMTIME        stime;
   		CTime             ctime;
   		ctime = t;

		stime.wYear = (WORD) ctime.GetYear();
		stime.wMonth = (WORD) ctime.GetMonth();
		stime.wDayOfWeek = (WORD) ctime.GetDayOfWeek();
		stime.wDay = (WORD) ctime.GetDay();
		stime.wHour = (WORD) ctime.GetHour();
		stime.wMinute = (WORD) ctime.GetMinute();
		stime.wSecond = (WORD) ctime.GetSecond();
		stime.wMilliseconds = 0;
//*	   	if ( ctime.GetAsSystemTime(stime) )
//*   		{
			   CString     t1;
            CString     t2;

            GetTimeFormat(LOCALE_USER_DEFAULT,0,&stime,NULL,t1.GetBuffer(500),500);
            GetDateFormat(LOCALE_USER_DEFAULT,0,&stime,NULL,t2.GetBuffer(500),500);
			
            t1.ReleaseBuffer();
            t2.ReleaseBuffer();

            s = t2 + " " + t1;
//*   		}

	}
	return s;
}
_variant_t get(int i)
{
	return pVarSet->get(GET_BSTR(i));
}
void put(int i,_variant_t v)
{
	pVarSet->put(GET_BSTR(i),v);
}
void getReporting()
{
	_bstr_t temp;
	CString c;
	c.LoadString(IDS_COLUMN_NAMECONFLICTS);
	m_reportingBox.InsertItem(0,c);
	SetItemText(m_reportingBox,0, 1, timeToCString(DCTVS_Reports_NameConflicts_TimeGenerated));

	c.LoadString(IDS_COLUMN_ACCOUNTREFERENCES);
	m_reportingBox.InsertItem(0,c);
	SetItemText(m_reportingBox,0, 1, timeToCString(DCTVS_Reports_AccountReferences_TimeGenerated));
	
	c.LoadString(IDS_COLUMN_EXPIREDCOMPUTERS);
	m_reportingBox.InsertItem(0,c);
	SetItemText(m_reportingBox,0, 1, timeToCString(DCTVS_Reports_ExpiredComputers_TimeGenerated));
	
	c.LoadString(IDS_COLUMN_MIGRATEDCOMPUTERS);
	m_reportingBox.InsertItem(0,c);
	SetItemText(m_reportingBox,0, 1, timeToCString(DCTVS_Reports_MigratedComputers_TimeGenerated));
	
	c.LoadString(IDS_COLUMN_MIGRATEDACCOUNTS);
	m_reportingBox.InsertItem(0,c);
	SetItemText(m_reportingBox,0, 1, timeToCString(DCTVS_Reports_MigratedAccounts_TimeGenerated));

}
void putReporting()
{
	_variant_t varX;
	int nItem;
	bool atleast1 =false;
//	POSITION pos = m_reportingBox.GetFirstSelectedItemPosition();
//	while (pos)
//	{
//		atleast1 = true;
//		nItem = m_reportingBox.GetNextSelectedItem(pos);
	nItem = m_reportingBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		atleast1 = true;
		SetCheck(m_reportingBox,nItem,false);
		nItem = m_reportingBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}

	varX = (!GetCheck(m_reportingBox,0)) ? yes : no;
	put(DCTVS_Reports_MigratedAccounts,varX);
	varX = (!GetCheck(m_reportingBox,1)) ?  yes : no;
	put(DCTVS_Reports_MigratedComputers,varX);
	varX = (!GetCheck(m_reportingBox,2)) ?  yes : no;
	put(DCTVS_Reports_ExpiredComputers,varX);
	varX = (!GetCheck(m_reportingBox,3)) ?  yes : no;
	put(DCTVS_Reports_AccountReferences,varX);
	varX = (!GetCheck(m_reportingBox,4)) ?  yes : no;
	put(DCTVS_Reports_NameConflicts,varX);
	

	varX = atleast1 ?  yes : no;
	put(DCTVS_Reports_Generate,varX);

	for (int i = 0; i< m_reportingBox.GetItemCount();i++)
		SetCheck(m_reportingBox,i,true);
}
void populateReportingTime()
{
	_variant_t varX;
	_bstr_t text;
	CString temp;
	time_t ltime;	
	time(&ltime);
	temp.Format(L"%d",ltime);	
	varX = temp;

	if (!UStrICmp((text = get(DCTVS_Reports_MigratedAccounts)),(WCHAR const *) yes))
		put(DCTVS_Reports_MigratedAccounts_TimeGenerated,varX);
	if (!UStrICmp((text = get(DCTVS_Reports_MigratedComputers)),(WCHAR const *) yes))
		put(DCTVS_Reports_MigratedComputers_TimeGenerated,varX);
	if (!UStrICmp((text = get(DCTVS_Reports_ExpiredComputers)),(WCHAR const *) yes))
		put(DCTVS_Reports_ExpiredComputers_TimeGenerated,varX);
	if (!UStrICmp((text = get(DCTVS_Reports_AccountReferences)),(WCHAR const *) yes))
		put(DCTVS_Reports_AccountReferences_TimeGenerated,varX);
	if (!UStrICmp((text = get(DCTVS_Reports_NameConflicts)),(WCHAR const *) yes))
		put(DCTVS_Reports_NameConflicts_TimeGenerated,varX);
}



void getFailed(HWND hwndDlg)
{
	IVarSetPtr  pVarSetFailed(__uuidof(VarSet));
	IUnknown * pUnk;
	pVarSetFailed->QueryInterface(IID_IUnknown, (void**) &pUnk);
	HRESULT hr = db->GetFailedDistributedActions(-1, &pUnk);
	pUnk->Release();
	if (FAILED(hr))
		MessageBoxWrapper(hwndDlg,IDS_MSG_FAILED,IDS_MSG_ERROR);
	else
	{
		CString toLoad;
		CString holder;
		_bstr_t text;

		CString skip;
		skip.LoadString(IDS_SKIP);
		int i=0;
		_bstr_t numItemsText = pVarSetFailed->get(L"DA");
		CString jobHelper;
		if (UStrCmp(numItemsText,L"0") && UStrCmp(numItemsText,L""))
		{
			int numItems = _ttoi( (WCHAR const *) numItemsText);
			while (i<numItems)
			{
				holder.Format(L"DA.%d" ,i);

				toLoad = holder + L".Server";
				text = pVarSetFailed->get(_bstr_t(toLoad));
				m_cancelBox.InsertItem(0,(WCHAR const *)text);			
				
				toLoad = holder + L".JobFile";
				text = pVarSetFailed->get(_bstr_t(toLoad));
				SetItemText(m_cancelBox,0,1,(WCHAR const *)text);			
			
				JobFileGetActionText((WCHAR * const) text,jobHelper);
				SetItemText(m_cancelBox,0,3,jobHelper);

				toLoad = holder + L".StatusText";
				text = pVarSetFailed->get(_bstr_t(toLoad));
				SetItemText(m_cancelBox,0,2,(WCHAR const *)text);			

				toLoad = holder + L".ActionID";
				text = pVarSetFailed->get(_bstr_t(toLoad));
				SetItemText(m_cancelBox,0,4,(WCHAR const *)text);			

				SetItemText(m_cancelBox,0,5,skip);			

				i++;
			}
		}
	}
}

void handleCancel(HWND hwndDlg)
{
	int nItem;
	HRESULT hr=S_OK;
	long lActionID;
	CString computer;
	CString actionID;
//	POSITION pos = m_cancelBox.GetFirstSelectedItemPosition();
//	while (pos)
//	{
//		nItem = m_cancelBox.GetNextSelectedItem(pos);
	nItem = m_cancelBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		SetCheck(m_cancelBox,nItem,false);
		nItem = m_cancelBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}
	

	for (int i=(m_cancelBox.GetItemCount()-1);i>=0;i--)
	{
		if (!GetCheck(m_cancelBox,i))
		{
			computer = m_cancelBox.GetItemText(i,0);
			actionID = m_cancelBox.GetItemText(i,4);
			
			lActionID = _ttol(actionID.GetBuffer(500));
			actionID.ReleaseBuffer();

			hr  = db->CancelDistributedAction(lActionID, _bstr_t(computer));
			if (FAILED(hr))
				MessageBoxWrapper(hwndDlg,IDC_MSG_CANCEL,IDS_MSG_ERROR);
			else
				m_cancelBox.DeleteItem(i);
		}
	}
}
	
void OnRETRY()
{
	int count =0;
	CString holder,c;
	_variant_t varX;
	CString include;
	include.LoadString(IDS_INCLUDE); 
	for (int i=0;i<m_cancelBox.GetItemCount();i++)
	{		
		c = m_cancelBox.GetItemText(i,5);
		if (c== include)
		{
			CString name;
			CString sName;
			name = m_cancelBox.GetItemText(i,0);
			sName = L"\\\\";
			sName += name;
			holder.Format(L"Servers.%d",count);
			pVarSet->put(_bstr_t(holder),_bstr_t(sName));
			
			varX = m_cancelBox.GetItemText(i,1);
			holder = holder + L".JobFile";
			pVarSet->put(_bstr_t(holder),varX);
			count++;
		}
	}
	holder = L"Servers.NumItems";
	pVarSet->put(_bstr_t(holder),(long)count);
}

void JobFileGetActionText(WCHAR const * filename // in - job file name
				,CString & text      // in/out - text describing the action
)
{
   // load the varset into a file
    // Read the varset data from the file
   IVarSetPtr             pVarSet;
   IStorage             * store = NULL;
   HRESULT                hr;

   // Try to create the COM objects
   hr = pVarSet.CreateInstance(CLSID_VarSet);
   if ( SUCCEEDED(hr) )
   {
      // Read the VarSet from the data file
      hr = StgOpenStorage(filename,NULL,STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,NULL,0,&store);
      if ( SUCCEEDED(hr) )
      {                  
         // Load the data into a new varset
         hr = OleLoad(store,IID_IUnknown,NULL,(void **)&pVarSet);
         if ( SUCCEEDED(hr) )
         {
            _bstr_t     wizard = pVarSet->get(GET_BSTR(DCTVS_Options_Wizard));

//*            if ( !UStrICmp(wizard,(WCHAR const *) GET_BSTR1(IDS_WIZARD_COMPUTER) ))
            if ( !UStrICmp(wizard, L"computer"))
            {
               text = GET_CSTRING(IDS_MIGRATE_COMPUTER);
            }
//*            else if ( !UStrICmp(wizard,(WCHAR const *)GET_BSTR1(IDS_WIZARD_SERVICE) ))
            else if ( !UStrICmp(wizard, L"service"))
            {
               text = GET_CSTRING(IDS_GATHER_SERVICEACCOUNT);
            }
//*            else if ( ! UStrICmp(wizard,(WCHAR const *)GET_BSTR1(IDS_WIZARD_SECURITY) ))
            else if ( ! UStrICmp(wizard, L"security"))
            {
               text = GET_CSTRING(IDS_TRANSLATE_SECURITY);
            }
//*            else if (! UStrICmp(wizard,(WCHAR const *) GET_BSTR1(IDS_WIZARD_REPORTING)) )
            else if (! UStrICmp(wizard, L"reporting") )
            {
               text = GET_CSTRING(IDS_GATHER_INFORMATION);
            }
            else
            {
               text = (WCHAR*)wizard;
            }
         }
         store->Release();
      }
   }
}
_bstr_t GET_BSTR1(int id)
{
	CString yo;
	yo.LoadString(id);
	return (LPCTSTR)yo;
}

void activateCancelIfNecessary(HWND hwndDlg)
{
//	POSITION pos = m_cancelBox.GetFirstSelectedItemPosition();
//	if (pos)
	int nItem = m_cancelBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	if (nItem != -1)//PRT
	{
		enable(hwndDlg,IDC_CANCEL);
		enable(hwndDlg,IDC_TOGGLE);
	}
	else
	{
		disable(hwndDlg,IDC_CANCEL);
		disable(hwndDlg,IDC_TOGGLE);
	}
}

bool SomethingToRetry()
{
	if (m_cancelBox.GetItemCount()==0) return false;
	int count =0;
	CString include;
	include.LoadString(IDS_INCLUDE);

	CString c;
	for (int i=0;i<m_cancelBox.GetItemCount();i++)
	{		
		c = m_cancelBox.GetItemText(i,5);
		if (c== include)
		{
			return true;
		}
	}
	return false;
}

void OnFileBrowse(HWND hwndDlg,int id)
{
	CWnd yo;
	yo.Attach(hwndDlg);
	CString sDir = L"", sFile = L"", sPath = L"";
	
    CFileDialog f(FALSE,
		L"",
		GET_CSTRING(IDS_PASSWORDS),
		OFN_LONGNAMES | OFN_NOREADONLYRETURN,
		GET_CSTRING(IDS_MASKS),
		&yo);

	GetDlgItemText(hwndDlg, id, sPath.GetBuffer(1000), 1000);
	sPath.ReleaseBuffer();

	if (sPath.GetLength())
       GetValidPathPart(sPath, sDir, sFile);
       
	f.m_ofn.lpstrInitialDir = sDir.GetBuffer(1000);
    f.m_ofn.lpstrFile = sFile.GetBuffer(1000);
	
	if ( f.DoModal() == IDOK )
	{
		SetDlgItemText(hwndDlg,id,f.GetPathName());
	}
	yo.Detach();

	sFile.ReleaseBuffer();
	sDir.ReleaseBuffer();
}

void ShowWarning(HWND hwndDlg)
{
	CString warning,base,title;
	IAccessCheckerPtr          pAC;
	HRESULT hr = pAC.CreateInstance(CLSID_AccessChecker);
	long              length;
	hr = pAC->raw_GetPasswordPolicy(_bstr_t(targetDNS),&length);
	if ( !SUCCEEDED(hr) )
	{
		ErrorWrapper2(hwndDlg,hr);
	}
	else 
	{
		if (length>0)
		{
		base.Format(L"%lu",length);
		warning.LoadString(IDS_MSG_WARNING_LENGTH);
		base+=warning;
		title.LoadString(IDS_MSG_WARNING);
		MessageBox(hwndDlg,base,title,MB_OK|MB_ICONINFORMATION);
	}
	}	
}

bool obtainTrustCredentials(HWND hwndDlg,int spot, CString & domain, CString & account, CString & password)
{
	bool toreturn;
	CWnd yo;
	yo.Attach(hwndDlg);
	CTrusterDlg truster(&yo);
	truster.m_strDomain= m_trustBox.GetItemText(spot,0);

	truster.len = MAX_PATH;

	truster.m_strDomain= m_trustBox.GetItemText(spot,0);

	truster.DoModal();
	toreturn = truster.toreturn;
	
	if ( toreturn )
	{
		domain = truster.m_strDomain;
		account = truster.m_strUser;
		password = truster.m_strPassword;
	}
	yo.Detach();
	return toreturn;
}
CString GET_CSTRING(int id)
{
	CString c;
	c.LoadString(id);
	return c;
}

HRESULT MigrateTrusts(HWND hwndDlg,bool& atleast1succeeded)
{
	ITrustPtr      pTrusts;		
	IUnknown          * pUnk = NULL;
//	int i=m_trustBox.GetSelectionMark();
	int i=m_trustBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	CString trusted,trusting,direction;
	HRESULT hr = pTrusts.CreateInstance(CLSID_Trust);
	CString       strDomain,strAccount,strPassword;
	atleast1succeeded=false;
	
	if ( SUCCEEDED(hr) )
	{
		
		CWaitCursor s;
		direction = m_trustBox.GetItemText(i,1);
		direction.TrimLeft();
		direction.TrimRight();
		if (direction == GET_CSTRING(IDS_OUTBOUND))
		{
			trusting = targetNetbios;
			trusted = m_trustBox.GetItemText(i,0);
			hr = pTrusts->raw_CreateTrust(_bstr_t(trusting),_bstr_t(trusted),FALSE);
			
			if (HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)
				
				if (obtainTrustCredentials(hwndDlg,i,strDomain, strAccount, strPassword))
					
					hr = pTrusts->raw_CreateTrustWithCreds(_bstr_t(trusting),_bstr_t(trusted),
					NULL,NULL,NULL,_bstr_t(strDomain),_bstr_t(strAccount),
					_bstr_t(strPassword),FALSE);
				
				
		}
		
		else if (direction == GET_CSTRING(IDS_INBOUND))
		{
			trusting = m_trustBox.GetItemText(i,0);
			trusted = targetNetbios;
			
			hr = pTrusts->raw_CreateTrust(_bstr_t(trusting),_bstr_t(trusted),FALSE);
			if (HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)
				
				if (obtainTrustCredentials(hwndDlg,i,strDomain, strAccount, strPassword))
					
					hr = pTrusts->raw_CreateTrustWithCreds(_bstr_t(trusting),_bstr_t(trusted),
					_bstr_t(strDomain),_bstr_t(strAccount),
					_bstr_t(strPassword),NULL,NULL,NULL,FALSE);
		}
		else if (direction == GET_CSTRING(IDS_BIDIRECTIONAL))
		{
			trusting = m_trustBox.GetItemText(i,0);
			trusted = targetNetbios;
			hr = pTrusts->raw_CreateTrust(_bstr_t(trusting),_bstr_t(trusted),TRUE);
			if (HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)
				
				if (obtainTrustCredentials(hwndDlg,i,strDomain, strAccount, strPassword))
					
					
					hr = pTrusts->raw_CreateTrustWithCreds(_bstr_t(trusting),_bstr_t(trusted),
					_bstr_t(strDomain),_bstr_t(strAccount),
					_bstr_t(strPassword),NULL,NULL,NULL,TRUE);
				
		}
		
		if (direction == GET_CSTRING(IDS_DISABLED))
		{
			MessageBoxWrapper(hwndDlg,IDS_MSG_DISABLED_TRUST,IDS_MSG_ERROR);	
		}
		else if (direction.IsEmpty() != FALSE)
		{
			MessageBoxWrapper(hwndDlg,IDS_MSG_DIRECTION_TRUST,IDS_MSG_ERROR);	
		}
		
		else
		{
			if ( SUCCEEDED(hr) )
			{
				// update the UI to reflect that the trust now exists
				m_trustBox.SetItemText(i,3,GET_BSTR(IDS_YES));
				atleast1succeeded=true;   
			}
			
		}
	}
	return hr;
}
void getTrust()
{
				// get the trust relationship data
	ITrustPtr      pTrusts;
//	CWaitCursor wait;
	
	HRESULT hr = pTrusts.CreateInstance(CLSID_Trust);
	if ( SUCCEEDED(hr) )
	{
		IUnknown          * pUnk = NULL;
		CString dirname;
		GetDirectory(dirname.GetBuffer(1000));
		dirname.ReleaseBuffer();
		dirname+= L"Logs\\trust.log";
		hr = pTrusts->raw_QueryTrusts(_bstr_t(sourceNetbios),_bstr_t(targetNetbios),_bstr_t(dirname),&pUnk);
		if ( SUCCEEDED(hr) )
		{
			IVarSetPtr        pVsTrusts;
			pVsTrusts = pUnk;
			pUnk->Release();
			long              nTrusts = pVsTrusts->get(L"Trusts");
			for ( long i = 0 ; i < nTrusts ; i++ )
			{
				CString     base;
				CString     sub;
				
				base.Format(L"Trusts.%ld",i);
				_bstr_t     value = pVsTrusts->get(_bstr_t(base));
				m_trustBox.InsertItem(0,value);
				
				sub = base + L".Direction";
				value = pVsTrusts->get(_bstr_t(sub));
				SetItemText(m_trustBox,0,1,value);
				
				sub = base + L".Type";
				value = pVsTrusts->get(_bstr_t(sub));
				SetItemText(m_trustBox,0,2,value);
				
				sub = base + L".ExistsForTarget";
				value = pVsTrusts->get(_bstr_t(sub));
				SetItemText(m_trustBox,0,3,value);
				
			}
		}
	}
}
bool number(CString num)
{
	if (num.GetLength()==0) return false;
	CString checker;
	checker.LoadString(IDS_VALID_DIGITS);
	for (int i=0;i<num.GetLength();i++)
	{
		if (checker.Find(num.GetAt(i)) == -1)
			return false;
	}
	return true;
}
bool timeInABox(HWND hwndDlg,time_t& t)
{
	CString s;
	GetDlgItemText(hwndDlg,IDC_yo,s.GetBuffer(1000),1000);
	s.ReleaseBuffer();
	s.TrimLeft();s.TrimRight();
	if (!number(s)) return false;
	int num=_ttoi((LPTSTR const) s.GetBuffer(1000));
	s.ReleaseBuffer();
	if (num > THREE_YEARS || num < 1) return false;
	DWORD             nDays = num;
	
	DWORD             oneDay = 24 * 60 * 60; // number of seconds in 1 day
	time_t            currentTime = time(NULL);
	time_t            expireTime;
	expireTime = currentTime + nDays * oneDay;
//expireTime-=currentTime%86400;
	t= expireTime;
	return true;
}

HRESULT GetHelpFileFullPath( BSTR *bstrHelp )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CString  strPath, strName;
   HRESULT  hr = S_OK;

   TCHAR szModule[2*_MAX_PATH];
   DWORD dwReturn = 0;

   GetDirectory(szModule);
   
   strPath = szModule;
   strPath += _T("\\");
   strName.LoadString(IDS_HELPFILE);
   strPath += strName;

   *bstrHelp = SysAllocString(LPCTSTR(strPath));
   return hr;
}

void helpWrapper(HWND hwndDlg, int t)
{
   
   CComBSTR    bstrTopic;
	HRESULT     hr = GetHelpFileFullPath( &bstrTopic);
   if ( SUCCEEDED(hr) )
   {
	    HWND h = HtmlHelp(hwndDlg,  bstrTopic,  HH_HELP_CONTEXT, t );	
   }
   else
   {
		CString r,e;
		r.LoadString(IDS_MSG_HELP);
		e.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,r,e,MB_OK|MB_ICONSTOP);
   }
}

bool IsDlgItemEmpty(HWND hwndDlg, int id)
{
	CString temp;
	GetDlgItemText( hwndDlg, id, temp.GetBuffer(1000),1000);
	temp.ReleaseBuffer();
	temp.TrimLeft();
	temp.TrimRight();
	return  (temp.IsEmpty()!= FALSE);
}

void calculateDate(HWND hwndDlg,CString s)
{
	s.TrimLeft();s.TrimRight();
	if (!number(s)) return;
	long nDays=_ttol((LPTSTR const) s.GetBuffer(1000));
	s.ReleaseBuffer();
	
	long              oneDay = 24 * 60 * 60; // number of seconds in 1 day
	time_t            currentTime = time(NULL);
	time_t            expireTime;
	CTime             ctime;
   	SYSTEMTIME        stime;
	CString strDate;
	expireTime = currentTime + nDays * oneDay;
	
	ctime = expireTime;

	stime.wYear = (WORD) ctime.GetYear();
	stime.wMonth = (WORD) ctime.GetMonth();
	stime.wDayOfWeek = (WORD) ctime.GetDayOfWeek();
	stime.wDay = (WORD) ctime.GetDay();
	stime.wHour = (WORD) ctime.GetHour();
	stime.wMinute = (WORD) ctime.GetMinute();
	stime.wSecond = (WORD) ctime.GetSecond();
	stime.wMilliseconds = 0;

	GetDateFormat(LOCALE_USER_DEFAULT,0,&stime,NULL,strDate.GetBuffer(500),500);
	strDate.ReleaseBuffer();
	
	SetDlgItemText(hwndDlg,IDC_DATE,strDate);
}

void ErrorWrapper(HWND hwndDlg,HRESULT returncode)
{
	CString y,e,text,title;
	if (HRESULT_FACILITY(returncode)==FACILITY_WIN32)
	{
		returncode=HRESULT_CODE(returncode);
		err.ErrorCodeToText(returncode,1000,y.GetBuffer(1000));
		y.ReleaseBuffer();	
		text.LoadString(IDS_MSG_ERRORBUF);
		e.Format(text,y,returncode);
		title.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,e,title,MB_OK|MB_ICONSTOP);
	}
	else
	{
		err.ErrorCodeToText(returncode,1000,y.GetBuffer(1000));
		y.ReleaseBuffer();	
		text.LoadString(IDS_MSG_ERRORBUF);
//		text.Replace(L"%u",L"%x");
		int index = text.Find(L"%u"); //PRT
		text.SetAt(index+1, L'x');    //PRT
		e.Format(text,y,returncode);
		title.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,e,title,MB_OK|MB_ICONSTOP);
	}
}
void ErrorWrapper2(HWND hwndDlg,HRESULT returncode)
{
	CString y,e,text,title,message;
	if (HRESULT_FACILITY(returncode)==FACILITY_WIN32)
	{
		returncode=HRESULT_CODE(returncode);
		err.ErrorCodeToText(returncode,1000,y.GetBuffer(1000));
		y.ReleaseBuffer();
		message.LoadString(IDS_MSG_PASSWORD_POLICY);
		
		text.LoadString(IDS_MSG_ERRORBUF20);
		e.Format(text,message,y,returncode);
		
		title.LoadString(IDS_MSG_WARNING);	
		MessageBox(hwndDlg,e,title,MB_OK|MB_ICONSTOP);
	}
	else
	{
		err.ErrorCodeToText(returncode,1000,y.GetBuffer(1000));
		y.ReleaseBuffer();
		message.LoadString(IDS_MSG_PASSWORD_POLICY);
		
		text.LoadString(IDS_MSG_ERRORBUF20);
//		text.Replace(L"%u",L"%x");
		int index = text.Find(L"%u"); //PRT
		text.SetAt(index+1, L'x');    //PRT
		e.Format(text,message,y,returncode);
		
		title.LoadString(IDS_MSG_WARNING);	
		MessageBox(hwndDlg,e,title,MB_OK|MB_ICONSTOP);
	}
}



void ErrorWrapper3(HWND hwndDlg,HRESULT returncode,CString domainName)
{
	CString y,e,text,title,formatter;
	if (HRESULT_FACILITY(returncode)==FACILITY_WIN32)
	{
		returncode=HRESULT_CODE(returncode);
		err.ErrorCodeToText(returncode,1000,e.GetBuffer(1000));
		e.ReleaseBuffer();
		formatter.LoadString(IDS_MSG_ERRORBUF3);
		text.Format(formatter,e,returncode,domainName);
		title.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,text,title,MB_OK|MB_ICONSTOP);
	}
	else
	{
		err.ErrorCodeToText(returncode,1000,e.GetBuffer(1000));
		e.ReleaseBuffer();
		formatter.LoadString(IDS_MSG_ERRORBUF3);
//		formatter.Replace(L"%u",L"%x");
		int index = formatter.Find(L"%u"); //PRT
		formatter.SetAt(index+1, L'x');    //PRT
		text.Format(formatter,e,returncode,domainName);
		title.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,text,title,MB_OK|MB_ICONSTOP);
	}
	
}
void ErrorWrapper4(HWND hwndDlg,HRESULT returncode,CString domainName)
{
	CString y,e,text,title,formatter;
	if (HRESULT_FACILITY(returncode)==FACILITY_WIN32)
	{
		returncode=HRESULT_CODE(returncode);
		
		err.ErrorCodeToText(returncode,1000,e.GetBuffer(1000));
		e.ReleaseBuffer();
		formatter.LoadString(IDS_MSG_ERRORBUF2);
		text.Format(formatter,e,returncode,domainName);
		title.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,text,title,MB_OK|MB_ICONSTOP);
	}
	else
	{	err.ErrorCodeToText(returncode,1000,e.GetBuffer(1000));
	e.ReleaseBuffer();
	formatter.LoadString(IDS_MSG_ERRORBUF2);
//	formatter.Replace(L"%u",L"%x");
	int index = formatter.Find(L"%u"); //PRT
	formatter.SetAt(index+1, L'x');    //PRT
	text.Format(formatter,e,returncode,domainName);
	title.LoadString(IDS_MSG_ERROR);
	MessageBox(hwndDlg,text,title,MB_OK|MB_ICONSTOP);
	}
}

bool validDir(CString str)
{
	CFileFind finder;

	// build a string with wildcards
   str += _T("\\*.*");

   // start working for files
   BOOL bWorking = finder.FindFile(str);
   if (bWorking==0) 
   {
	   finder.Close();
	   return false;
   }
   bWorking = finder.FindNextFile();
   
   bool toreturn = (finder.IsDirectory()? true:false);

	//some root drives do not have the directory flag set, so convert to
	//the root path and use it
   if (!toreturn)
   {
	  str = finder.GetRoot();
	  if (str.GetLength())
		toreturn = true;
   }

   finder.Close();
   return toreturn;
}

bool validDirectoryString(HWND hwndDlg,int id)
{
	CString str;
	GetDlgItemText(hwndDlg,id,str.GetBuffer(1000),1000);
	str.ReleaseBuffer();

	CString sResult = CreatePath(str);
	if (sResult.GetLength())
	{
	   SetDlgItemText(hwndDlg, id, (LPCTSTR)sResult);
	   return true;
	}
	else
	   return false;
}

bool validString(HWND hwndDlg,int id)
{
		//characters with ASCII values 1-31 are not allowed in addition to
		//the characters in IDS_INVALID_STRING.  ASCII characters, whose
		//value is 1-31, are hardcoded here since Visual C++ improperly 
		//converts some of these
//	WCHAR InvalidDownLevelChars[] = //TEXT("\"/\\[]:|<>+=;,?,*")
//                                TEXT("\001\002\003\004\005\006\007")
//                                TEXT("\010\011\012\013\014\015\016\017")
//                                TEXT("\020\021\022\023\024\025\026\027")
//								TEXT("\030\031\032\033\034\035\036\037");

	bool bValid;
	CHAR ANSIStr[1000];
	int numConverted;
	CString c;	
	GetDlgItemText(hwndDlg,id,c.GetBuffer(1000),1000);
	c.ReleaseBuffer();

	   //we now use the validation function in the common library that we share 
	   //with the scripting code
	bValid = IsValidPrefixOrSuffix(c);

/*	CString check;
	CHAR ANSIStr[1000];
//*	check.LoadString(IDS_VALID_STRING);
	check.LoadString(IDS_INVALID_STRING); //load viewable invalid characters
	if (c.GetLength() > 8) return false;
	for (int i=0;i<c.GetLength();i++)
	{
//*		if (check.Find(c.GetAt(i)) == -1)
			//if any characters enetered by the user ar in the viewable
			//invalid list, return false to display a messagebox
		if (check.Find(c.GetAt(i)) != -1)
			return false;
			//if any chars have a value between 1-31, return false
		for (UINT j=0; j<wcslen(InvalidDownLevelChars); j++)
		{
			if ((c.GetAt(i)) == (InvalidDownLevelChars[j]))
				return false;
		}
	}
*/
		//convert the same user input so we can guard against <ALT>1 
		//- <ALT>31, which cause problems in ADMT
	if (bValid)
	{
       numConverted = WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, (LPCTSTR)c, 
							-1, ANSIStr, 1000, NULL, NULL);
	   if (numConverted)
	   {
		  WCHAR sUnicodeStr[1000];
		  UStrCpy(sUnicodeStr, ANSIStr);
	      bValid = IsValidPrefixOrSuffix(sUnicodeStr);
	   }
	}

	return bValid;
}
bool validReboot(HWND hwndDlg,int id)
{
	const int REBOOT_MAX = 15;  //MAX minutes before computer reboot on migration

	CString c;
	GetDlgItemText(hwndDlg,id,c.GetBuffer(1000),1000);
	c.ReleaseBuffer();
	CString check;
	check.LoadString(IDS_VALID_REBOOT);
	for (int i=0;i<c.GetLength();i++)
	{
		if (check.Find(c.GetAt(i)) == -1)
			return false;
	}

	   //check to make sure it doesn't exceed the MAX (15 minutes) (will not integer
	   //overflow since combobox is small and not scrollable
	int num;
	int nRead = swscanf((LPCTSTR)c, L"%d", &num);
	if ((nRead == EOF) || (nRead == 0))
	    return false;
	if ((num >= 0) && (num > REBOOT_MAX))
	   return false;

	return true;
}

bool findInVarSet(HWND hwndDlg,int id, BSTR bstr)
{
    _bstr_t     text;
	CString temp;
	_variant_t varX;

	GetDlgItemText( hwndDlg, id, temp.GetBuffer(1000),1000);	
	temp.ReleaseBuffer();
	text = pVarSet->get(bstr);
	
	return (!UStrICmp(temp.GetBuffer(1000),(WCHAR * const) text) ? true : false);
}


void enableRemoveIfNecessary(HWND hwndDlg)
{
//	POSITION pos = m_listBox.GetFirstSelectedItemPosition();
//	pos ? enable(hwndDlg,IDC_REMOVE_BUTTON) : disable(hwndDlg,IDC_REMOVE_BUTTON) ;
	int nItem = m_listBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	(nItem != -1) ? enable(hwndDlg,IDC_REMOVE_BUTTON) : disable(hwndDlg,IDC_REMOVE_BUTTON) ;//PRT
}
bool enableNextIfNecessary(HWND hwndDlg,int id)
{
	if (IsDlgItemEmpty(hwndDlg,id))
	{
		PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
	return false;
	}
	else
	{
		PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
		return true;
	}
}
void enableNextIfObjectsSelected(HWND hwndDlg)
{
	if (m_listBox.GetItemCount()==0)
	{
		PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
	}
	else
	{
		PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
	}
}


void setupColumns(bool sourceIsNT4)
{
	CString column;
	column.LoadString(IDS_COLUMN_NAME); m_listBox.InsertColumn( 1, column,LVCFMT_LEFT,125,1);
	column.LoadString(IDS_COLUMN_OBJECTPATH); m_listBox.InsertColumn( 2, column,LVCFMT_LEFT,0,1);
	
	if (sourceIsNT4)
	{
		if (migration==w_computer || (migration==w_security ||
			(migration==w_service || migration==w_reporting))) 
		{
			m_listBox.SetColumnWidth(0,455);
		}
		else if (migration==w_account)
		{
			column.LoadString(IDS_COLUMN_FULLNAME); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,125,1);
			column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 4, column,LVCFMT_LEFT,125,1);
		}
		else if (migration==w_group || migration==w_groupmapping)
		{
			column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,320,1);
		}
	}
	else
	{
		if (migration==w_computer || (migration==w_security ||
			(migration==w_service || migration==w_reporting))) 
		{
			column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,125,1);
		}
		else if (migration==w_account)
		{
			column.LoadString(IDS_COLUMN_SAMNAME); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,125,1);
			column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 4, column,LVCFMT_LEFT,125,1);
			column.LoadString(IDS_COLUMN_UPN); m_listBox.InsertColumn( 5, column,LVCFMT_LEFT,0,1);
		}
		else if (migration==w_group || migration==w_groupmapping)
		{
			column.LoadString(IDS_COLUMN_SAMNAME); m_listBox.InsertColumn( 3, column,LVCFMT_LEFT,125,1);
			column.LoadString(IDS_COLUMN_DESCRIPTION); m_listBox.InsertColumn( 4, column,LVCFMT_LEFT,205,1);
		}
	}		
}

void sort(CListCtrl & listbox,int col,bool order)
{
	CWaitCursor w;
	LV_ITEM lvItem;
	ZeroMemory(&lvItem, sizeof(lvItem));
	LV_ITEM lvItem2;
	ZeroMemory(&lvItem2, sizeof(lvItem2));
	bool ahead;
	CString temp1,temp2,temp3,temp4,temp5;
	int numItems = listbox.GetItemCount();
	for (int i = 0;i<numItems;i++)
	{
		for (int j=i;j<numItems;j++)
		{
			ahead = ((listbox.GetItemText(i,col)).CompareNoCase(listbox.GetItemText(j,col))> 0);
			if ((order && ahead) ||	(!order && !ahead))
			{
				temp1 = listbox.GetItemText(i,0);
				temp2 = listbox.GetItemText(i,1);
				temp3 = listbox.GetItemText(i,2);
				temp4 = listbox.GetItemText(i,3);
				temp5 = listbox.GetItemText(i,4);
				SetItemText(listbox,i,0,listbox.GetItemText(j,0));
				SetItemText(listbox,i,1,listbox.GetItemText(j,1));
				SetItemText(listbox,i,2,listbox.GetItemText(j,2));
				SetItemText(listbox,i,3,listbox.GetItemText(j,3));
				SetItemText(listbox,i,4,listbox.GetItemText(j,4));
				SetItemText(listbox,j,0,temp1);
				SetItemText(listbox,j,1,temp2);
				SetItemText(listbox,j,2,temp3);
				SetItemText(listbox,j,3,temp4);
				SetItemText(listbox,j,4,temp5);
			}
		}
	}
}
/*
void changePlaces(CListCtrl&listBox,int i,int j)
{
	CString temp1,temp2,temp3,temp4,temp5;
	temp1 = listbox.GetItemText(i,0);
	temp2 = listbox.GetItemText(i,1);
	temp3 = listbox.GetItemText(i,2);	
	temp4 = listbox.GetItemText(i,3);
	temp5 = listbox.GetItemText(i,4);
	SetItemText(listbox,i,0,listbox.GetItemText(j,0));
	SetItemText(listbox,i,1,listbox.GetItemText(j,1));
	SetItemText(listbox,i,2,listbox.GetItemText(j,2));
	SetItemText(listbox,i,3,listbox.GetItemText(j,3));
	SetItemText(listbox,i,4,listbox.GetItemText(j,4));
	SetItemText(listbox,j,0,temp1);
	SetItemText(listbox,j,1,temp2);
	SetItemText(listbox,j,2,temp3);
	SetItemText(listbox,j,3,temp4);
	SetItemText(listbox,j,4,temp5);
}
int Partition(CListCtrl & listbox,int col,bool order,int p,int r)
{
	CString x=listbox.GetItemText(p,col)
		int i=p-1;
	int j=r+1;
	while (true)
	{
		do
		{
			j--;
		}while(x.CompareNoCase(listBox.GetItemText(j,col) ) >= 0);
		do
		{
			i++;
		}while(x.CompareNoCase(listBox.GetItemText(i,col) ) <=0);
		if (i<j)
			changePlaces(listBox,i,j);
		else
			return j;
	}
	

}
void sort(CListCtrl & listbox,int col,bool order)
{
	CWaitCursor w;
	LV_ITEM lvItem;
	ZeroMemory(&lvItem, sizeof(lvItem));
	LV_ITEM lvItem2;
	ZeroMemory(&lvItem2, sizeof(lvItem2));
	bool ahead;
	CString temp1,temp2,temp3,temp4,temp5;
	int numItems = listbox.GetItemCount();
	
	for (int i = 0;i<numItems;i++)
	{
		for (int j=i;j<numItems;j++)
		{
			ahead = ((listbox.GetItemText(i,col)).CompareNoCase(listbox.GetItemText(j,col))> 0);
			if ((order && ahead) ||	(!order && !ahead))
			{
				temp1 = listbox.GetItemText(i,0);
				temp2 = listbox.GetItemText(i,1);
				temp3 = listbox.GetItemText(i,2);
				temp4 = listbox.GetItemText(i,3);
				temp5 = listbox.GetItemText(i,4);
				SetItemText(listbox,i,0,listbox.GetItemText(j,0));
				SetItemText(listbox,i,1,listbox.GetItemText(j,1));
				SetItemText(listbox,i,2,listbox.GetItemText(j,2));
				SetItemText(listbox,i,3,listbox.GetItemText(j,3));
				SetItemText(listbox,i,4,listbox.GetItemText(j,4));
				SetItemText(listbox,j,0,temp1);
				SetItemText(listbox,j,1,temp2);
				SetItemText(listbox,j,2,temp3);
				SetItemText(listbox,j,3,temp4);
				SetItemText(listbox,j,4,temp5);
			}
		}
	}
}

void QuickSort(CListCtrl & listbox,int col,bool order,int p,int r)
{
	int q;
	if (p<r)
	{
		q=	Partition(listBox,col,order,p,q);
		QuickSort(listBox,col,order,p,q);
		QuickSort(listBox,col,order,q+1,r);
	}
}
void sort(CListCtrl & listbox,int col,bool order)
{
	CWaitCursor w;
	QuickSort(listBox,col,order,1,listBox.GetItemCount());
}*/
void OnBROWSE(HWND hwndDlg,int id)
{
	TCHAR path[MAX_PATH]; 
	CString path2, sTitle; 
	BROWSEINFO b;

	sTitle.LoadString(IDS_BROWSE_REPORT_TITLE);
	b.hwndOwner=hwndDlg; 
    b.pidlRoot=NULL; 
    b.pszDisplayName=path; 
    b.lpszTitle=(LPCTSTR)sTitle; 
    b.lpfn=NULL; 
    b.lParam=NULL; 
    b.iImage=NULL; 
/**/b.ulFlags=0; //PRT - 4/3 
	LPITEMIDLIST l = SHBrowseForFolder(&b);
	SHGetPathFromIDList(l,path2.GetBuffer(1000));
	path2.ReleaseBuffer();
	SetDlgItemText(hwndDlg,id,path2.GetBuffer(1000));
	path2.ReleaseBuffer();
}


bool administrator(CString m_Computer,HRESULT& hr)
{
	IAccessCheckerPtr          pAC;
	long              bIs;
	hr = pAC.CreateInstance(CLSID_AccessChecker);
	
	hr = pAC->raw_IsAdmin(NULL,_bstr_t(m_Computer),&bIs);
	if ( SUCCEEDED(hr) )
	{
		if ( bIs == 0 )
			return false;
	}
	else return false;
	return true;
}
HRESULT validDomain(CString m_Computer,bool& isNt4)
{
	IAccessCheckerPtr            pAccess;
	HRESULT                      hr;
	unsigned long     maj,min,sp;
	hr = pAccess.CreateInstance(CLSID_AccessChecker);
	hr = pAccess->raw_GetOsVersion(_bstr_t(m_Computer),&maj,&min,&sp);
	maj<5 ? isNt4=true :isNt4=false;
	return hr;
}

bool targetNativeMode(_bstr_t b,HRESULT& hr)
{
	IAccessCheckerPtr            pAccess;
	hr = pAccess.CreateInstance(CLSID_AccessChecker);
	BOOL bTgtNative=FALSE; 
	hr=pAccess->raw_IsNativeMode(b, (long*)&bTgtNative);
	return ( bTgtNative != FALSE);
}
bool CheckSameForest(CString& domain1,CString& domain2,HRESULT& hr)
{
	IAccessCheckerPtr            pAccess;
	hr = pAccess.CreateInstance(CLSID_AccessChecker);
	BOOL pbIsSame=FALSE;
	hr = pAccess->raw_IsInSameForest(_bstr_t(domain1), _bstr_t(domain2), (long *) &pbIsSame);
	return (pbIsSame!=FALSE);
}


HRESULT doSidHistory(HWND hwndDlg) 
{
   CWaitCursor c;
   IAccessCheckerPtr          pAC;
   HRESULT           hr;
   CString           info=L"";
   long              bIs=0;
   PDOMAIN_CONTROLLER_INFOW pdomc;	
  
   hr = pAC.CreateInstance(CLSID_AccessChecker);

   if (FAILED(hr))
   {
      return hr;
   }

   hr = pAC->raw_CanUseAddSidHistory(_bstr_t((LPCTSTR)sourceNetbios), _bstr_t((LPCTSTR)targetNetbios), &bIs);

   if ( SUCCEEDED(hr) )
   {
	   if ( bIs == 0 )
	   {
		   return S_OK;
	   }
	   else
	   {
		   // get primary domain controller in source domain

		   hr = DsGetDcNameW(NULL, (LPCTSTR)sourceNetbios, NULL, NULL, DS_PDC_REQUIRED, &pdomc);

		   if (FAILED(hr))
		   {
		      return hr;
		   }

		   _bstr_t sourceDomainController = pdomc->DomainControllerName;
		   NetApiBufferFree(pdomc);

		   if ( bIs & F_NO_AUDITING_SOURCE )
		   {
			   info.LoadString(IDS_MSG_ENABLE_SOURCE);
			   if (MessageBox(hwndDlg,info,0,MB_YESNOCANCEL|MB_ICONQUESTION) ==IDYES)
			   {
				   hr = pAC->raw_EnableAuditing(sourceDomainController);
				   if(FAILED(hr)) return hr;
			   }			   
			   else return E_ABORT;
		   }
		   if ( bIs & F_NO_AUDITING_TARGET )
		   {
			   info.LoadString(IDS_MSG_ENABLE_TARGET);
			   if (MessageBox(hwndDlg,info,0,MB_YESNOCANCEL|MB_ICONQUESTION) ==IDYES)
			   {
				   hr = DsGetDcNameW(NULL,(LPCTSTR)targetNetbios, NULL, NULL, 0, &pdomc);
				   if (FAILED(hr))
				   {
				      return hr;
				   }
				   _bstr_t targetDomainController = pdomc->DomainControllerName;
				   NetApiBufferFree(pdomc);
				   hr = pAC->raw_EnableAuditing(targetDomainController);
				   if(FAILED(hr)) return hr;
			   }			   
			   else return E_ABORT;
		   }
		   if ( bIs & F_NO_LOCAL_GROUP )
		   {
			   CString info2;
			   info2.LoadString(IDS_MSG_LOCAL_GROUP);
				info.Format(info2,sourceNetbios,sourceNetbios);
			   if (MessageBox(hwndDlg,info,0,MB_YESNOCANCEL|MB_ICONQUESTION) ==IDYES)
			   {
				   hr = pAC->raw_AddLocalGroup(_bstr_t((LPCTSTR)sourceNetbios), sourceDomainController);
				   if(FAILED(hr)) return hr;
			   }			   
			   else return E_ABORT;
		   }

		   if ( bIs & F_NO_REG_KEY )
		   {
			   info.LoadString(IDS_MSG_REGKEY);
			   int bReboot=0;
			   if (MessageBox(hwndDlg,info,0,MB_YESNOCANCEL|MB_ICONQUESTION) ==IDYES)
			   {
				  info.LoadString(IDS_MSG_REBOOT_SID);
				  int answer = MessageBox(hwndDlg,info,0,MB_YESNOCANCEL|MB_ICONQUESTION) ;
				  if (answer==IDYES) 
					  bReboot=1;
				  else if (answer==IDNO)
					  bReboot=0;
				  else 
					return E_ABORT;

				   hr = pAC->raw_AddRegKey(sourceDomainController,bReboot);
				   if(FAILED(hr)) return hr;
			   }			   
			   else return E_ABORT;
		   }

		   return S_OK;
	   }
   }
   else
   {
	   info.LoadString(IDS_MSG_SID_HISTORY);
	   MessageBox(hwndDlg,info,0,MB_ICONSTOP);
	   return hr;
   }

}

void GetDnsAndNetbiosFromName(WCHAR const * name,WCHAR * netBios, WCHAR * dns)
{
   IADsPtr     pDomain;
   WCHAR       strText[1000];
   _bstr_t     distinguishedName;
   _bstr_t	   sNBName = name;
   DOMAIN_CONTROLLER_INFO  * pDomCtrlInfo = NULL;
   bool		   bDNS = false;

      //try to get the dns name for this given domain name
   if (DsGetDcName(NULL, name, NULL, NULL, DS_RETURN_DNS_NAME, &pDomCtrlInfo) == NO_ERROR)
   {
	     //if we got the domain anme back in DNS format, use it
	  if (pDomCtrlInfo->Flags & DS_DNS_DOMAIN_FLAG)
	  {
         swprintf(strText,L"LDAP://%ls",pDomCtrlInfo->DomainName);
		 bDNS = true;
	  }
	  else
	  {
		 sNBName = pDomCtrlInfo->DomainName;
         swprintf(strText,L"LDAP://%ls",pDomCtrlInfo->DomainName);
	  }
      NetApiBufferFree(pDomCtrlInfo);
   } 
      //else try to get the real NetBios name of this domain
   else if (DsGetDcName(NULL, name, NULL, NULL, 0, &pDomCtrlInfo) == NO_ERROR)
   {
      sNBName = pDomCtrlInfo->DomainName;
//      swprintf(strText,L"LDAP://%ls",pDomCtrlInfo->DomainName);
      NetApiBufferFree(pDomCtrlInfo);
   }
//   else   //else use the given name
//      swprintf(strText,L"LDAP://%ls",name);
   
   netBios[0] = 0;
   dns[0] = 0;

      // if we couldn't get the DNS name for the domain, use the specified 
      // name as both DNS and NETBIOS.  This will work for NT 4 domains
   if (!bDNS)
   {
      UStrCpy(netBios,(WCHAR*)sNBName);
      UStrCpy(dns,(WCHAR*)sNBName);
	  return;
   }

   HRESULT hr = ADsGetObject(strText,IID_IADs,(void**)&pDomain);
   if ( SUCCEEDED(hr) )
   {
      _variant_t        var;

      // get the DNS name from the LDAP provider
      hr = pDomain->Get(L"distinguishedName",&var);
      if ( SUCCEEDED(hr) )
      {
         WCHAR * dn = (WCHAR*)var.bstrVal;
         WCHAR * curr = dns;
         distinguishedName = dn;

         if ( !UStrICmp(dn,L"DC=",3) )
         {
            
            // for each ",DC=" in the name, replace it with a .
            for ( curr = dns, dn = dn+3 ;    // skip the leading "DC="
                  *dn       ;    // until the end of the string is reached
                  curr++         // 
                )
            {
               if ( (L',' == *dn)  && (L'D' == *(dn+1)) && (L'C' == *(dn+2)) && (L'=' == *(dn+3)) )
               {
                  (*curr) = L'.';
                  dn+=4;
               }
               else
               {
                  // just copy the character
                  (*curr) = (*dn);
                  dn++;
               }
            }
            *(curr) = 0;
         }
      
         // get the NETBIOS name from the LDAP provider
         hr = pDomain->Get(L"nETBIOSName",&var);
         if ( SUCCEEDED(hr) )
         {
            UStrCpy(netBios,(WCHAR*)var.bstrVal);
         }
         else
         {
            // currently, the netbiosName property is not filled in
            // so we will use a different method to get the flat-name for the domain
            // Here is our strategy to get the netbios name:
            // Enumerate the partitions container under the configuration container
            // look for a CrossRef object whose nCName property matches the distinguished name
            // we have for the domain.  This object's CN property is the flat-name for the domain

            // get the name of the configuration container
            IADsPtr       pDSE;
            _bstr_t       domainName = strText;
//            swprintf(strText,L"LDAP://%ls/RootDSE",name);
            swprintf(strText,L"%ls/RootDSE",(WCHAR*)domainName);
            hr = ADsGetObject(strText,IID_IADs,(void**)&pDSE);
            if ( SUCCEEDED(hr) )
            {
               hr = pDSE->Get(L"configurationNamingContext",&var);
               if ( SUCCEEDED(hr) )
               {
                  IADsContainerPtr    pPart;
//                  swprintf(strText,L"LDAP://%ls/CN=Partitions,%ls",name,var.bstrVal);
                  swprintf(strText,L"%ls/CN=Partitions,%ls",(WCHAR*)domainName,var.bstrVal);
                  hr = ADsGetObject(strText,IID_IADsContainer,(void**)&pPart);
                  if ( SUCCEEDED(hr) )
                  {
                     IUnknownPtr      pUnk;
                     IEnumVARIANTPtr  pEnum;
                     IADsPtr          pItem;
                     ULONG            lFetch = 0;
                     // enumerate the contents of the Partitions container
                     hr = pPart->get__NewEnum(&pUnk);
                     if ( SUCCEEDED(hr) )
                     {
                        pEnum = pUnk;
                     }
                     if ( SUCCEEDED(hr) )
                     {
                        var.Clear();
                        hr = pEnum->Next(1,&var,&lFetch);
                     }
                     while ( hr == S_OK )
                     {
                        if (lFetch == 1 )
                        {
                           IDispatchPtr pDisp = var;

                           if ( pDisp )
                           {
                              pItem = pDisp;

                              if ( pItem )
                              {
                                 BSTR bstr = NULL;
                                 hr = pItem->get_Class(&bstr);

                                 if (SUCCEEDED(hr))
                                 {
                                    _bstr_t strClass(bstr, false);

                                    if ( !UStrICmp(strClass,L"crossRef") )
                                    {
                                       // see if this is the one we are looking for
                                       var.Clear();
                                       hr = pItem->Get(L"nCName",&var);
                                       if ( SUCCEEDED(hr) )
                                       {
                                          if ( !UStrICmp(var.bstrVal,(WCHAR*)distinguishedName) )
                                          {
                                             // this is the one we want!
                                             var.Clear();
                                             hr = pItem->Get(L"cn",&var);
                                             if ( SUCCEEDED(hr) )
                                             {
                                                UStrCpy(netBios,var.bstrVal);
                                                break;
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                         }
                         var.Clear();
                         hr = pEnum->Next(1, &var, &lFetch);
                     }
                  }
               }
            }
         }
      }
   }
   else
   {
      // default to using the specified name as both DNS and NETBIOS
      // this will work for NT 4 domains
      UStrCpy(netBios,(WCHAR*)sNBName);
      UStrCpy(dns,(WCHAR*)sNBName);
   }
   if ( ! (*netBios) )
   {
      UStrCpy(netBios,(WCHAR*)sNBName);
      WCHAR          * temp = wcschr(netBios,L'.');
      if ( temp )
         *temp = 0;
   }
   if (! (*dns) )
   {
      UStrCpy(dns,(WCHAR*)sNBName);
   }
}

void GetDomainInfoFromActionHistory(WCHAR const * name,
									WCHAR * netBios, 
									WCHAR * dns, 
									CString targetDomainDns, 
									bool * bSetForest, 
									bool * bSetSrcOS, 
									LPSHAREDWIZDATA& pdata)
{
   IVarSetPtr                pVsAH(__uuidof(VarSet));
   IUnknown                * pUnk = NULL;
   HRESULT                   hr;
   _bstr_t                   srcNB, srcDNS;
   WCHAR					 key[MAX_PATH];
   long						 lActionID, ldx = 1;
   bool						 bID = false;
   bool						 bFound = false;

   *bSetForest = false;
   *bSetSrcOS = false;

     //get current Action ID so we know how many action history entries are in the table
   hr = db->raw_GetCurrentActionID(&lActionID);
   if ( SUCCEEDED(hr) )
      bID = true;

   	//get the varset for all action ids until we find what we are looking for
   while ( (!bFound) && ( ((bID) && (ldx <= lActionID)) || (!bID) ) )
   {
      hr = pVsAH->QueryInterface(IID_IUnknown, (void**)&pUnk);

	     //fill a varset with the next action from the Action History table
      if ( SUCCEEDED(hr) )
         hr = db->raw_GetActionHistory(ldx, &pUnk);

	  pUnk->Release();
      if ( SUCCEEDED(hr) )
	  {
	     srcNB = pVsAH->get(GET_BSTR(DCTVS_Options_SourceDomain));
	     srcDNS = pVsAH->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
			//if we have a match of with the source domain netbios or dns, continue, 
			//else, move to the next action history entry
		 if ((!UStrICmp(srcNB,name)) || (!UStrICmp(srcDNS,name)))
		 {
				//save the netbios and dns names
			 wcscpy(netBios, (WCHAR*)srcNB);
			 wcscpy(dns, (WCHAR*)srcDNS);

				//if we haven't been able to set the forest, do so
			 if (!(*bSetForest))
			 {
				   //if the target domain also matches then set whether they are intra-forest
	            _bstr_t tgtDNS = pVsAH->get(GET_BSTR(DCTVS_Options_TargetDomainDns));
			    if (!UStrICmp(tgtDNS, (LPCTSTR)targetDomainDns))
				{
				   *bSetForest = true; //set flag indicating intraforest flag set in pdata
				      //if this is intra-forest, then set all the fields and leave
				   _bstr_t sIntraforest = pVsAH->get(GET_BSTR(DCTVS_Options_IsIntraforest));
				   if (!UStrICmp(sIntraforest,GET_STRING(IDS_YES)))
				   {
					  pdata->sameForest = true;
					  pdata->sourceIsNT4 = false;
				      *bSetSrcOS = true; //set flag indicating Src OS set in pdata
					  bFound = true;  //set flag to leave this function
				   }
				   else //else we still need to figure out if the source domain is NT4 or W2K
				   {
					   pdata->sameForest = false;

						  //we can figure this out if this operation was not a computer migration
				       _bstr_t sWizard = pVsAH->get(GET_BSTR(DCTVS_Options_Wizard));
					   if (UStrICmp((WCHAR *)text, L"computer"))
					   {
						   //get the name of an object migrated and see if it starts with
						   //"WinNT://", which indicates an NT 4.0 source
                          swprintf(key,GET_STRING(DCTVSFmt_Accounts_D),0);
				          _bstr_t sName = pVsAH->get(key);
                          if (!wcsncmp(L"WinNT://", (WCHAR*)sName, 8))
					         pdata->sourceIsNT4 = true;
					      else
					         pdata->sourceIsNT4 = false;
				          *bSetSrcOS = true; //set flag indicating Src OS set in pdata
					      bFound = true;  //set flag to leave this function
					   }//end if not computer migration
				   }//end else inter-forest migration
				}//end if target domain match
			    else if (!(*bSetSrcOS)) //else if need to, try to find out if the source
				{   //domain is NT4.0 or W2K
				      //we can figure this out if this operation was not a computer migration
			       _bstr_t sWizard = pVsAH->get(GET_BSTR(DCTVS_Options_Wizard));
				   if (UStrICmp((WCHAR *)text, L"computer"))
				   {
				        //get the name of an object migrated and see if it starts with
				        //"WinNT://", which indicates an NT 4.0 source
                      swprintf(key,GET_STRING(DCTVSFmt_Accounts_D),0);
				      _bstr_t sName = pVsAH->get(key);
                      if (!wcsncmp(L"WinNT://", (WCHAR*)sName, 8))
				         pdata->sourceIsNT4 = true;
				      else
					     pdata->sourceIsNT4 = false;
				      *bSetSrcOS = true; //set flag indicating Src OS set in pdata
				   }//end if not computer migration
				}//end if not set OS flag yet
			 }//end if forest not set
			 else if (!(*bSetSrcOS)) //else if need to, try to find out if the source
			 {   //domain is NT4.0 or W2K
				   //we can figure this out if this operation was not a computer migration
			    _bstr_t sWizard = pVsAH->get(GET_BSTR(DCTVS_Options_Wizard));
				if (UStrICmp((WCHAR *)text, L"computer"))
				{
				     //get the name of an object migrated and see if it starts with
				     //"WinNT://", which indicates an NT 4.0 source
                   swprintf(key,GET_STRING(DCTVSFmt_Accounts_D),0);
				   _bstr_t sName = pVsAH->get(key);
                   if (!wcsncmp(L"WinNT://", (WCHAR*)sName, 8))
				      pdata->sourceIsNT4 = true;
				   else
					  pdata->sourceIsNT4 = false;
				   *bSetSrcOS = true; //set flag indicating Src OS set in pdata
				   bFound = true;  //set flag to leave this function
				}//end if not computer migration
			 }//end if not set OS flag yet
		 }//end if source domain match 
	  }//end if got next varset
	  else //else if could not retrieve the varset, leave
		  bFound = true;

	  ldx++;
   }//end while not done
}

bool GetDomainSidFromMigratedObjects(WCHAR const * sDomainNetBios, WCHAR * sSrcSid)
{
   IVarSetPtr                pVsMO(__uuidof(VarSet));
   IUnknown                * pUnk = NULL;
   HRESULT                   hr;
   WCHAR					 text[MAX_PATH];
   _bstr_t                   srcDom;
   _bstr_t                   txtSid;
   long						 numObjects, ndx = 0;
   bool						 bFound = false;

   hr = pVsMO->QueryInterface(IID_IUnknown, (void**)&pUnk);
   if ( SUCCEEDED(hr) )
   {
         //fill a varset with migrated objects from the Migrated Objects table
      hr = db->raw_GetMigratedObjectsWithSSid(-1,&pUnk);
      if ( SUCCEEDED(hr) )
      {
         pUnk->Release();
            //get the num of objects in the varset
         numObjects = pVsMO->get(L"MigratedObjects");

			//while not found and more objects, search for source domain match
			//and see if its Sid was stored
		 while ((!bFound) && (ndx < numObjects))
		 {
			   //get this object's source domain 
            swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceDomain));
            srcDom = pVsMO->get(text);
			   //if source domain matches, see if the sid was stored
			if (!UStrICmp((WCHAR*)srcDom, sDomainNetBios))
			{
				  //get the source domain Sid
               swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceDomainSid));
               txtSid = pVsMO->get(text);
				  //if source sid retrieved, convert to PSID and set found flag
			   if (UStrICmp((WCHAR*)txtSid, L""))
			   {
				  UStrCpy(sSrcSid, (WCHAR*)txtSid);
				  bFound = true;
			   }
			}//end if source domain match
		    ndx++;
		 }//end while not done
	  }//end if got migrated objects
   }//end if got IUnknown
   return bFound;
}

void cleanNames()
{
	sourceDNS=L"";
	sourceNetbios=L"";
	targetNetbios=L"";
	targetDNS=L"";
}

bool verifyprivs(HWND hwndDlg,CString& sourceDomainController,CString& targetDomainController,LPSHAREDWIZDATA& pdata)
{
	CWaitCursor wait;
	CString temp,temp2;
	HRESULT hr;
	bool result;
	GetDlgItemText( hwndDlg, IDC_EDIT_DOMAIN, temp.GetBuffer(1000),1000);
	GetDlgItemText( hwndDlg, IDC_EDIT_DOMAIN2, temp2.GetBuffer(1000),1000);
	temp.ReleaseBuffer();
	temp2.ReleaseBuffer();
	
	temp.TrimLeft();temp.TrimRight();
	temp2.TrimLeft();temp2.TrimRight();
	// if the source domain has changed...
	if ( temp.CompareNoCase(sourceDNS) && temp.CompareNoCase(sourceNetbios) )
	{
		pdata->newSource = true;
		// Get the DNS and Netbios names for the domain name the user has entered
	}
	else
	{
		pdata->newSource = false;
	}
	GetDnsAndNetbiosFromName(&*temp,sourceNetbios.GetBuffer(1000),sourceDNS.GetBuffer(1000));
	sourceNetbios.ReleaseBuffer();
	sourceDNS.ReleaseBuffer();
	
	sourceNetbios.TrimLeft();sourceDNS.TrimRight();
	
	GetDnsAndNetbiosFromName(&*temp2,targetNetbios.GetBuffer(1000),targetDNS.GetBuffer(1000));
	targetNetbios.ReleaseBuffer();
	targetDNS.ReleaseBuffer();
	
	targetNetbios.TrimLeft();targetDNS.TrimRight();
	
	if (!sourceNetbios.CompareNoCase(targetNetbios) || !sourceDNS.CompareNoCase(targetDNS))
	{
		MessageBoxWrapper3(hwndDlg,IDS_MSG_UNIQUE,IDS_MSG_ERROR,temp);
		cleanNames();
		return false;
	}
	
	
	_bstr_t text =get(DCTVS_Options_TargetDomain);
	CString tocheck = (WCHAR * const) text;
	tocheck.TrimLeft();tocheck.TrimRight();
	pdata->resetOUPATH = !tocheck.CompareNoCase(targetNetbios)  ?  false: true;
	
	PDOMAIN_CONTROLLER_INFOW pdomc;	
	HRESULT res = DsGetDcNameW(NULL,(LPCTSTR const)sourceNetbios,NULL,NULL,	DS_DIRECTORY_SERVICE_PREFERRED,&pdomc); 
	if (res!=NO_ERROR)
	{
		ErrorWrapper3(hwndDlg,res,temp);
		if ( gbNeedToVerify )
		{
			cleanNames();
			return false;
		}
	}
	else
	{
		sourceDomainController = pdomc->DomainControllerName;
		NetApiBufferFree(pdomc);
	}
	res = DsGetDcNameW(NULL,(LPCTSTR const) targetNetbios,NULL,NULL,	DS_DIRECTORY_SERVICE_PREFERRED,&pdomc); 
	if (res!=NO_ERROR)
	{
		ErrorWrapper3(hwndDlg,res,temp2);
		if ( gbNeedToVerify )
		{
			cleanNames();
			return false;
		}
	}
	else
	{
		targetDomainController = pdomc->DomainControllerName;
		NetApiBufferFree(pdomc);
	}

	///////////////////////////////////////////////////////////////////////////////////////////
    bool nothing;
	hr =validDomain(sourceDomainController,pdata->sourceIsNT4);
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp);
		if ( gbNeedToVerify )
		{
			cleanNames();
			return false;
		}
	}
	
	hr =validDomain(targetDomainController,nothing);
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp2);
		if ( gbNeedToVerify )
		{
			cleanNames();
			
			return false;
		}
	}
	
	
	result = administrator(sourceDomainController,hr);
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp);
		if ( gbNeedToVerify )
		{		 		
			cleanNames();
			
			return false;
		}
	}
	else if (!result)
	{	
		MessageBoxWrapper3(hwndDlg,IDS_MSG_SOURCE_ADMIN,IDS_MSG_ERROR,temp);
		if ( gbNeedToVerify )
		{
			cleanNames();
			
			return false;
		}
	}
	
	result=administrator(targetDomainController,hr);
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp2);
		if ( gbNeedToVerify )
		{	
			cleanNames();
		
		return false;
		}
	}
	else if (!result)
	{	
		MessageBoxWrapper3(hwndDlg,IDS_MSG_TARGET_ADMIN,IDS_MSG_ERROR,temp2);
		if ( gbNeedToVerify )
		{	
			cleanNames();
		
		return false;
	}	}
	TCHAR szBuf[800];
	swprintf(szBuf,L"%s",targetDNS);

	result=targetNativeMode(szBuf,hr);
	
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp2);
		if ( gbNeedToVerify )
		{	
			cleanNames();
		
		return false;
		}
	}
	else if (!result)
	{
		MessageBoxWrapper3(hwndDlg,IDS_MSG_TARGET_NATIVE,IDS_MSG_ERROR,temp2);
		if ( gbNeedToVerify )
		{
			cleanNames();
			return false;
		}
	}
	
	if (pdata->sourceIsNT4) 
	{
		pdata->sameForest=false;
	}
	else
	{
		pdata->sameForest=CheckSameForest(sourceDNS,targetDNS,hr);
		if (!SUCCEEDED(hr))
		{
			ErrorWrapper3(hwndDlg,hr,temp);
			if ( gbNeedToVerify )
			{
				cleanNames();
				
				return false;
			}
		}
	}

    pdata->sameForest ?	put(DCTVS_Options_IsIntraforest,yes) : put(DCTVS_Options_IsIntraforest,no);
    return true;
}

bool verifyprivs2(HWND hwndDlg,CString& additionalDomainController,CString domainName)
{
    CWaitCursor w;
	CString domainNetbios,domainDNS;
	GetDnsAndNetbiosFromName(&*domainName,domainNetbios.GetBuffer(1000),domainDNS.GetBuffer(1000));
	domainNetbios.ReleaseBuffer();
	domainDNS.ReleaseBuffer();
	PDOMAIN_CONTROLLER_INFOW pdomc;	
	HRESULT res = DsGetDcNameW(NULL,(LPCTSTR const)domainNetbios,NULL,NULL,	DS_DIRECTORY_SERVICE_PREFERRED,&pdomc); 
	if (res!=NO_ERROR)
	{
		ErrorWrapper3(hwndDlg,res,domainNetbios);
		if ( gbNeedToVerify )
			return false;
	}
	else
	{
		additionalDomainController = pdomc->DomainControllerName;
		NetApiBufferFree(pdomc);
	}
	

	bool nothing;
	HRESULT	hr =validDomain(additionalDomainController,nothing);
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,domainNetbios);
		if ( gbNeedToVerify )
			return false;
	}
	
	HRESULT	result = administrator(additionalDomainController,hr);
	if (!SUCCEEDED(hr))
	{
	ErrorWrapper3(hwndDlg,hr,domainNetbios);
		if ( gbNeedToVerify )
			return false;
	}
	else if (!result)
	{	
		MessageBoxWrapper3(hwndDlg,IDS_MSG_SOURCE_ADMIN,IDS_MSG_ERROR,domainNetbios);
		if ( gbNeedToVerify )
			return false;
	}
	
	return true;
}

bool verifyprivsSTW(HWND hwndDlg,CString& sourceDomainController,CString& targetDomainController,LPSHAREDWIZDATA& pdata)
{
	CWaitCursor wait;
	CString temp,temp2;
	HRESULT hr;
	bool result, bSetSrcOS, bSetForest;
	GetDlgItemText( hwndDlg, IDC_EDIT_DOMAIN, temp.GetBuffer(1000),1000);
	GetDlgItemText( hwndDlg, IDC_EDIT_DOMAIN2, temp2.GetBuffer(1000),1000);
	temp.ReleaseBuffer();
	temp2.ReleaseBuffer();
	
	temp.TrimLeft();temp.TrimRight();
	temp2.TrimLeft();temp2.TrimRight();
	// if the source domain has changed...
	if ( temp.CompareNoCase(sourceDNS) && temp.CompareNoCase(sourceNetbios) )
	{
		pdata->newSource = true;
		// Get the DNS and Netbios names for the domain name the user has entered
	}
	else
	{
		pdata->newSource = false;
	}

	GetDnsAndNetbiosFromName(&*temp2,targetNetbios.GetBuffer(1000),targetDNS.GetBuffer(1000));
	targetNetbios.ReleaseBuffer();
	targetDNS.ReleaseBuffer();
	
	targetNetbios.TrimLeft();targetDNS.TrimRight();
	
		//for Security Translation Wizard, get source domain info from the Action History table and
		//also use the table to fill in the info about whether the source domain is NT 4.0 and in
		//the same forest as the target domain.
	GetDomainInfoFromActionHistory(&*temp,sourceNetbios.GetBuffer(1000),sourceDNS.GetBuffer(1000), 
								   targetDNS, &bSetForest, &bSetSrcOS, pdata);
	sourceNetbios.ReleaseBuffer();
	sourceDNS.ReleaseBuffer();
	
	sourceNetbios.TrimLeft();sourceDNS.TrimRight();
	
	if ((sourceNetbios.IsEmpty()) || (sourceDNS.IsEmpty()))
	{
		MessageBoxWrapper3(hwndDlg,IDS_MSG_NOOBJECTS,IDS_MSG_ERROR,temp);
		cleanNames();
		return false;
	}

	if (!sourceNetbios.CompareNoCase(targetNetbios) || !sourceDNS.CompareNoCase(targetDNS))
	{
		MessageBoxWrapper3(hwndDlg,IDS_MSG_UNIQUE,IDS_MSG_ERROR,temp);
		cleanNames();
		return false;
	}

	   //get the source domain's sid from a previous migration, display
	   //message if no sid
    WCHAR txtSid[MAX_PATH] = L"";
	if (GetDomainSidFromMigratedObjects((LPCTSTR)sourceNetbios, txtSid))
         pVarSet->put(GET_BSTR(DCTVS_Options_SourceDomainSid),txtSid);
	else
	{
       PSID                      pSid = NULL;
       WCHAR                   * domctrl = NULL;
       DWORD                     lenTxt = DIM(txtSid);
	   BOOL						 bFailed = TRUE;

		  //try to get it from the source domain directly
       if (!NetGetDCName(NULL,(LPCTSTR)sourceNetbios,(LPBYTE*)&domctrl))
	   {
	      if(GetDomainSid(domctrl,&pSid))
		  {
             if (GetTextualSid(pSid,txtSid,&lenTxt))
			 {
				    //add the sid to the varset
                 pVarSet->put(GET_BSTR(DCTVS_Options_SourceDomainSid),txtSid);
				    //populate the MigratedObjects table with this sid
				 db->PopulateSrcSidColumnByDomain((LPCTSTR)sourceNetbios, _bstr_t(txtSid));
				 bFailed = FALSE;
			 }
			 if (pSid)
			    FreeSid(pSid);
		  }
          NetApiBufferFree(domctrl);
	   }
	   if (bFailed)
	   {
	      MessageBoxWrapper3(hwndDlg,IDS_MSG_NOSOURCESID,IDS_MSG_ERROR,temp);
	      cleanNames();
	      return false;
	   }
	}
	
	_bstr_t text =get(DCTVS_Options_TargetDomain);
	CString tocheck = (WCHAR * const) text;
	tocheck.TrimLeft();tocheck.TrimRight();
	pdata->resetOUPATH = !tocheck.CompareNoCase(targetNetbios)  ?  false: true;
	
	PDOMAIN_CONTROLLER_INFOW pdomc;	
	HRESULT res = DsGetDcNameW(NULL,(LPCTSTR const)sourceNetbios,NULL,NULL,	DS_DIRECTORY_SERVICE_PREFERRED,&pdomc); 
	if (res==NO_ERROR)
	{
		sourceDomainController = pdomc->DomainControllerName;
		NetApiBufferFree(pdomc);
	}

	res = DsGetDcNameW(NULL,(LPCTSTR const) targetNetbios,NULL,NULL,DS_DIRECTORY_SERVICE_PREFERRED,&pdomc); 
	if (res!=NO_ERROR)
	{
		ErrorWrapper3(hwndDlg,res,temp2);
		if ( gbNeedToVerify )
		{
			cleanNames();
			return false;
		}
	}
	else
	{
		targetDomainController = pdomc->DomainControllerName;
		NetApiBufferFree(pdomc);
	}
	///////////////////////////////////////////////////////////////////////////////////////////
    bool nothing;

		//if we were not able to determine the source domain's OS from the
		//Action History table and we did get the source DC name, try to do 
		//it here.  This will work if the source domain still exists.  If 
		//the source domain no longer exists, set default.
	if ((!bSetSrcOS) && (!sourceDomainController.IsEmpty()))
	{
	   hr =validDomain(sourceDomainController,pdata->sourceIsNT4);
	   if (!SUCCEEDED(hr))
		   pdata->sourceIsNT4 = true;
	}

	hr =validDomain(targetDomainController,nothing);
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp2);
		if ( gbNeedToVerify )
		{
			cleanNames();
			
			return false;
		}
	}
	
	result=administrator(targetDomainController,hr);
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp2);
		if ( gbNeedToVerify )
		{	
			cleanNames();
		
		return false;
		}
	}
	else if (!result)
	{	
		MessageBoxWrapper3(hwndDlg,IDS_MSG_TARGET_ADMIN,IDS_MSG_ERROR,temp2);
		if ( gbNeedToVerify )
		{	
			cleanNames();
		    return false;
		}	
	}

	TCHAR szBuf[800];
	swprintf(szBuf,L"%s",targetDNS);

	result=targetNativeMode(szBuf,hr);
	
	if (!SUCCEEDED(hr))
	{
		ErrorWrapper3(hwndDlg,hr,temp2);
		if ( gbNeedToVerify )
		{	
			cleanNames();
		
		return false;
		}
	}
	else if (!result)
	{
		MessageBoxWrapper3(hwndDlg,IDS_MSG_TARGET_NATIVE,IDS_MSG_ERROR,temp2);
		if ( gbNeedToVerify )
		{
			cleanNames();
			return false;
		}
	}
	
		//if we were not able to set the intraforest boolean variable by looking at 
		//the Action History table, then try to find out here.  This will not work 
		//if the source domain no longer exists, in which case we set it to a default 
		//value.
	if (!bSetForest)
	{
	   if (pdata->sourceIsNT4) 
	   {
		  pdata->sameForest=false;
	   }
	   else
	   {
		  pdata->sameForest=CheckSameForest(sourceDNS,targetDNS,hr);
		  if (!SUCCEEDED(hr))
		  { 
			  //if we cannot figure it out, assume it is intra-forest so we
			  //will prompt for target domain credentials
		     pdata->sameForest=true;
		  }
	   }
	}

    pdata->sameForest ?	put(DCTVS_Options_IsIntraforest,yes) : put(DCTVS_Options_IsIntraforest,no);
    return true;
}


void OnADD(HWND hwndDlg,bool sourceIsNT4)
{

	HRESULT hr = pDsObjectPicker->InvokeDialog(hwndDlg, &pdo);
	if (FAILED(hr)) return;	 
	if (hr == S_OK) {
		ProcessSelectedObjects(pdo,hwndDlg,sourceIsNT4);
		pdo->Release();
	}
}

bool GetCheck(CListCtrl & yo,int nItem)
{

	UINT nState = yo.GetItemState(nItem,LVIS_CUT);
	return (nState ? false: true);	
}
void SetCheck(CListCtrl & yo,int nItem,bool checkit)
{
	!checkit	? yo.SetItemState(nItem,LVIS_CUT,LVIS_CUT) : yo.SetItemState(nItem,0,LVIS_CUT); 
}

void SetItemText(CListCtrl& yo, int nItem, int subItem,CString& text)
{
CString f;
	LV_ITEM lvItem;
	ZeroMemory(&lvItem, sizeof(lvItem));
	lvItem.mask = LVIF_TEXT;
	
	lvItem.iItem = nItem;
	lvItem.iSubItem= subItem;
	
	f= text;
	lvItem.pszText = f.GetBuffer(1000);
	f.ReleaseBuffer();
	yo.SetItem(&lvItem); 
}

void SetItemText(CListCtrl& yo, int nItem, int subItem,TCHAR * text)
{
	CString temp = text;
	SetItemText(yo,nItem,subItem,temp);
}
void SetItemText(CListCtrl& yo, int nItem, int subItem,TCHAR const * text)
{
	CString temp = text;
	SetItemText(yo,nItem,subItem,temp);
}

void SetItemText(CListCtrl& yo, int nItem, int subItem,_bstr_t text)
{
	CString temp = (WCHAR * const) text;
	SetItemText(yo,nItem,subItem,temp);
}

void OnREMOVE(HWND hwndDlg) 
{
	int nItem;
//	POSITION pos = m_listBox.GetFirstSelectedItemPosition();
//	while (pos)
//	{
//		nItem = m_listBox.GetNextSelectedItem(pos);
	nItem = m_listBox.GetNextItem(-1, LVNI_SELECTED);//PRT
	while (nItem != -1)//PRT
	{
		SetCheck(m_listBox,nItem,false);
		nItem = m_listBox.GetNextItem(nItem, LVNI_SELECTED);//PRT
	}
	
	for (int i=(m_listBox.GetItemCount()-1);i>=0;i--)
		if (!GetCheck(m_listBox,i))
			m_listBox.DeleteItem(i);
}	

void OnMIGRATE(HWND hwndDlg,int& accounts,int&servers)
{
	CString name,spruced_name,varset_1,upnName;
	accounts=0,servers=0;
	int intCount=m_listBox.GetItemCount();
	CString n;
	for (int i=0;i<intCount;i++) 
	{
		if (migration==w_computer || (migration ==w_security || 
			(migration == w_reporting || migration == w_service)))
		{
			name= m_listBox.GetItemText(i,0);
			spruced_name = "\\\\" + name;
			varset_1.Format(L"Servers.%d",servers);
			pVarSet->put(_bstr_t(varset_1),_bstr_t(spruced_name));
			
			pVarSet->put(_bstr_t(varset_1 + ".MigrateOnly"),no);
			if (migration==w_computer)
				pVarSet->put(_bstr_t(varset_1 + ".MoveToTarget"),yes);
			else if (migration==w_security)
			{
				pVarSet->put(_bstr_t(varset_1 + ".Reboot"),no);
				pVarSet->put(_bstr_t(varset_1 + ".MoveToTarget"),no);
			}
			servers++;
		}
		else
		{
			name= m_listBox.GetItemText(i,1);
			upnName = m_listBox.GetItemText(i,4);
		}
		
		
		if (name.IsEmpty())
		{
			MessageBoxWrapper(hwndDlg,IDS_MSG_PATH,IDS_MSG_ERROR);
		}
		
		varset_1.Format(L"Accounts.%d",accounts);	
		pVarSet->put(_bstr_t(varset_1),_bstr_t(name));
		pVarSet->put(_bstr_t(varset_1+".TargetName"),L"");
		switch(migration)
		{
		case w_account:
			pVarSet->put(_bstr_t(varset_1+".Type"),L"user");
			pVarSet->put(_bstr_t(varset_1+".UPNName"),_bstr_t(upnName));
			break;
		case w_group:pVarSet->put(_bstr_t(varset_1+".Type"),L"group");break;
		case w_groupmapping:
			{
				pVarSet->put(_bstr_t(varset_1+".Type"),L"group");
				_bstr_t temp = GET_BSTR(DCTVS_Accounts_D_OperationMask);
				CString holder = (WCHAR * const) temp;
				CString toenter;
				toenter.Format(holder,i);
				pVarSet->put(_bstr_t(toenter),(LONG)0x1d);				
				break;
			}
		case w_computer:pVarSet->put(_bstr_t(varset_1+".Type"),L"computer");break;
		case w_security:pVarSet->put(_bstr_t(varset_1+".Type"),L"computer");break;
		case w_reporting:pVarSet->put(_bstr_t(varset_1+".Type"),L"computer");break;
		case w_service:pVarSet->put(_bstr_t(varset_1+".Type"),L"computer");break;
		default: break;
		}
		
		n=m_listBox.GetItemText(i,0);
		if (migration==w_account) 
			pVarSet->put(_bstr_t(varset_1+L".Name"), _bstr_t(n));
		accounts++;
	}
	put(DCTVS_Accounts_NumItems,(LONG)accounts);
	put(DCTVS_Servers_NumItems,(LONG)servers);
}

HRESULT InitObjectPicker2(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString targetComputer,bool sourceIsNT4) {
	static const int     SCOPE_INIT_COUNT = 2;
	
	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];
	DSOP_INIT_INFO  InitInfo;
	ZeroMemory(aScopeInit, 
		sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);
	ZeroMemory(&InitInfo, sizeof(InitInfo));
	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	InitInfo.cbSize = sizeof(InitInfo);
	
	aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT |DSOP_SCOPE_FLAG_STARTING_SCOPE;
	aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
	
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;	
	aScopeInit[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN 
		| DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
		| DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
		| DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE
		| DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE;
	InitInfo.pwzTargetComputer =  targetComputer.GetBuffer(1000);// Target is the local computer.
	targetComputer.ReleaseBuffer();
	InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	InitInfo.aDsScopeInfos = aScopeInit;
	
	if (sourceIsNT4)
	{
	}
	else
	{
		InitInfo.cAttributesToFetch = 1;
		InitInfo.apwzAttributeNames = new PCWSTR[1];
		
		InitInfo.apwzAttributeNames[0] =L"Description";
		
	}		
	if (multiselect)
		InitInfo.flOptions = DSOP_FLAG_MULTISELECT;	
	HRESULT hr= pDsObjectPicker->Initialize(&InitInfo);
	delete [] InitInfo.apwzAttributeNames;
	return hr;
}
HRESULT ReInitializeObjectPicker(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString additionalDomainController,bool sourceIsNT4) 


{CWaitCursor c;
 // static const int     SCOPE_INIT_COUNT = 3;
static const int     SCOPE_INIT_COUNT = 2;
	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];
	DSOP_INIT_INFO  InitInfo;
	ZeroMemory(aScopeInit, 
		sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);
	ZeroMemory(&InitInfo, sizeof(InitInfo));
	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
//	aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	InitInfo.cbSize = sizeof(InitInfo);
	
	aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;
//	aScopeInit[2].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
//	aScopeInit[2].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT |DSOP_SCOPE_FLAG_STARTING_SCOPE;
	aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
//	aScopeInit[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
	
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;	
	aScopeInit[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN 
		| DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
		| DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
		| DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE
		| DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE;
//	aScopeInit[2].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;	
	InitInfo.pwzTargetComputer =  additionalDomainController.GetBuffer(1000);// Target is the local computer.
	additionalDomainController.ReleaseBuffer();
	InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	InitInfo.aDsScopeInfos = aScopeInit;
	
	if (sourceIsNT4)
	{
	}
	else
	{
		InitInfo.cAttributesToFetch = 1;
		InitInfo.apwzAttributeNames = new PCWSTR[1];
		
		InitInfo.apwzAttributeNames[0] =L"Description";
		
	}		
	if (multiselect)
		InitInfo.flOptions = DSOP_FLAG_MULTISELECT;	
	HRESULT hr= pDsObjectPicker->Initialize(&InitInfo);
	return hr;
}


HRESULT InitObjectPicker(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString targetComputer,bool sourceIsNT4) {
	static const int     SCOPE_INIT_COUNT = 1;

	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];
	DSOP_INIT_INFO  InitInfo;
	ZeroMemory(aScopeInit, 
		sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);
	ZeroMemory(&InitInfo, sizeof(InitInfo));
	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	InitInfo.cbSize = sizeof(InitInfo);
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP |DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
	
	if (migration==w_computer || (migration==w_security ||
		 (migration==w_service || migration==w_reporting))) 
	{
		aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
		aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;
	}
	else if (migration==w_account) 
	{
		aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
		aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
	}
	else if (migration==w_group || migration==w_groupmapping) 
	{
		aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_BUILTIN_GROUPS 
			| DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_UNIVERSAL_GROUPS_DL 
			| DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_DL
			| DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL;
		aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
		
	}
	if  (migration==w_security || (migration==w_reporting || migration==w_service))
	{
		aScopeInit[0].flType |= DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN 
			| DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
			| DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
			| DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE
			| DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE /*| DSOP_SCOPE_TYPE_GLOBAL_CATALOG*/;
	}

	InitInfo.pwzTargetComputer =  targetComputer.GetBuffer(1000);// Target is the local computer.
	targetComputer.ReleaseBuffer();
	InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	InitInfo.aDsScopeInfos = aScopeInit;

	if (sourceIsNT4)
	{
		if (migration==w_computer || (migration==w_security ||
			(migration==w_service || migration==w_reporting))) 
		{
		}
		else if (migration==w_account)
		{
			InitInfo.cAttributesToFetch = 2;
			InitInfo.apwzAttributeNames = new PCWSTR[3];
			
			InitInfo.apwzAttributeNames[0] =L"FullName";
			InitInfo.apwzAttributeNames[1] =L"Description";
		}
		else if (migration==w_group || migration==w_groupmapping)
		{
			InitInfo.cAttributesToFetch = 1;
			InitInfo.apwzAttributeNames = new PCWSTR[1];
			
			InitInfo.apwzAttributeNames[0] =L"Description";
		}
	}
	else
	{
		if (migration==w_computer || (migration==w_security ||
			(migration==w_service || migration==w_reporting))) 
		{
			InitInfo.cAttributesToFetch = 1;
			InitInfo.apwzAttributeNames = new PCWSTR[1];
			
			InitInfo.apwzAttributeNames[0] =L"Description";
		}
		else if (migration==w_account)
		{
			InitInfo.cAttributesToFetch = 2;
			InitInfo.apwzAttributeNames = new PCWSTR[2];
			
			InitInfo.apwzAttributeNames[0] =L"sAMAccountName";
			InitInfo.apwzAttributeNames[1] =L"Description";
		}
		else if (migration==w_group || migration==w_groupmapping)
		{
			InitInfo.cAttributesToFetch = 2;
			InitInfo.apwzAttributeNames = new PCWSTR[2];
			
			InitInfo.apwzAttributeNames[0] =L"sAMAccountName";
			InitInfo.apwzAttributeNames[1] =L"Description";
		}
	}		

	if (multiselect)
		InitInfo.flOptions = DSOP_FLAG_MULTISELECT;

	HRESULT hr= pDsObjectPicker->Initialize(&InitInfo);

	delete [] InitInfo.apwzAttributeNames;

	return hr;
}
bool DC(WCHAR* computerName,CString sourceDomainController)
{
	USER_INFO_1   * uinf1 = NULL;
	bool toreturn =false;
	NET_API_STATUS  rc = NetUserGetInfo(sourceDomainController.GetBuffer(1000),computerName,1,(LPBYTE*)&uinf1);
	sourceDomainController.ReleaseBuffer();
	if ( ! rc )
	{
		if ( uinf1->usri1_flags & UF_SERVER_TRUST_ACCOUNT ) 
		{ 
			toreturn = true;
		}
		NetApiBufferFree(&uinf1);
	}
	return toreturn;
}
bool inList(CString m_name)
{CString temp;
	m_name.TrimLeft();m_name.TrimRight();
	int length=m_listBox.GetItemCount();
	for (int i=0;i<length;i++)
	{
		temp=m_listBox.GetItemText(i,1);
		temp.TrimLeft();temp.TrimRight();
		if (!temp.CompareNoCase(m_name))return true;
	}
	return false;

}
void ProcessSelectedObjects(IDataObject *pdo,HWND hwndDlg,bool sourceIsNT4)
{
	HRESULT hr = S_OK;	BOOL fGotStgMedium = FALSE;	PDS_SELECTION_LIST pDsSelList = NULL;	ULONG i;
	STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL, NULL};
	FORMATETC formatetc = {(CLIPFORMAT) g_cfDsObjectPicker,NULL,DVASPECT_CONTENT,-1,TYMED_HGLOBAL};
	hr = pdo->GetData(&formatetc, &stgmedium);
	if (FAILED(hr)) return;
	fGotStgMedium = TRUE;		
	pDsSelList = (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
	if (!pDsSelList) return;
	CString toinsert;
	WCHAR temp[10000];
	CString samName;
	CString upnName;
	bool atleast1dc=false;
	bool continue1;
	PDOMAIN_CONTROLLER_INFOW pdomc;
	CString sourceDomainController;
	if (migration==w_computer)
	{
		HRESULT res = DsGetDcNameW(NULL,(LPCTSTR const)sourceNetbios,NULL,NULL,	DS_DIRECTORY_SERVICE_PREFERRED,&pdomc); 
		sourceDomainController=pdomc->DomainControllerName;
	}
	_bstr_t yo;
	int a, ndx;
	for (i = 0; i < pDsSelList->cItems; i++)
	{
		continue1=true;
		toinsert = pDsSelList->aDsSelection[i].pwzName;
		samName = pDsSelList->aDsSelection[i].pwzADsPath;
		upnName = pDsSelList->aDsSelection[i].pwzUPN;
		swprintf(temp,L"%s",(toinsert+L"$"));

		if (migration ==w_computer) 
		{
			if (DC(temp,sourceDomainController))
			{
				atleast1dc = true;
				continue1=false;
			}
		}

		
		if (!inList(samName)&&continue1)
		{
			a = m_listBox.GetItemCount();
			ndx = m_listBox.InsertItem(a,toinsert);
			if (ndx == -1)
		       continue;
			SetItemText(m_listBox,ndx,1,samName);
			_variant_t v;
			if (sourceIsNT4)
			{
				if (migration==w_computer || (migration==w_security ||
					(migration==w_service || migration==w_reporting))) 
				{
				}
				else if (migration==w_account)
				{				
					
					v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[0];
					yo = (_bstr_t) v;
					SetItemText(m_listBox,ndx,2,yo);					
					v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[1];
					yo = (_bstr_t) v;
					SetItemText(m_listBox,ndx,3,yo);
				}
				else if (migration==w_group || migration==w_groupmapping)
				{					
					v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[0];
					yo = (_bstr_t) v;
					SetItemText(m_listBox,ndx,2,yo);
				}
			}
			else
			{
				if (migration==w_computer || (migration==w_security ||
					(migration==w_service || migration==w_reporting))) 
				{					
					v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[0];
					yo = (_bstr_t) v;
					SetItemText(m_listBox,ndx,2,yo);
				}
				else if (migration==w_account)
				{	
					v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[0];
					yo = (_bstr_t) v;
					SetItemText(m_listBox,ndx,2,yo);	
					v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[1];
					yo = (_bstr_t) v;
					SetItemText(m_listBox,ndx,3,yo);
					SetItemText(m_listBox,ndx,4,upnName);
				}
				else if (migration==w_group || migration==w_groupmapping)
				{
					
					v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[0];
					yo = (_bstr_t) v;
					SetItemText(m_listBox,ndx,2,yo);					
					v = pDsSelList->aDsSelection[i].pvarFetchedAttributes[1];
					yo = (_bstr_t) v;
					SetItemText(m_listBox,ndx,3,yo);
				}
			}
		}
	}

	GlobalUnlock(stgmedium.hGlobal);
	if (fGotStgMedium) 	ReleaseStgMedium(&stgmedium);	
	if (atleast1dc)
		MessageBoxWrapper(hwndDlg,IDS_MSG_DC,IDS_MSG_ERROR);
}

bool checkFile(HWND hwndDlg)
{
	CString h;GetDlgItemText(hwndDlg,IDC_PASSWORD_FILE,h.GetBuffer(1000),1000);h.ReleaseBuffer();
	CFileFind finder;

	bool exists = (finder.FindFile((LPCTSTR) h )!=0);
	if (exists)
	{
		finder.FindNextFile();
	    CString fullpath = finder.GetFilePath();
	    if (fullpath.GetLength() != 0)
		   SetDlgItemText(hwndDlg, IDC_PASSWORD_FILE, (LPCTSTR)fullpath);
		return !(finder.IsReadOnly()!=FALSE);
	}
	else
	{
		   //remove the file off the path
		int tosubtract = h.ReverseFind(L'\\');
		int tosubtract2 = h.ReverseFind(L'/');
		int final = (tosubtract > tosubtract2) ? tosubtract : tosubtract2;
		if ((final==-1) || ((final+1)==h.GetLength()))return false;

		CString dir = h.Left(final);
		CString filename = h.Right(h.GetLength()-final); //save the filename
		if ((dir.Right(1) == L':') && (validDir(dir)))
			return true;

		   //call the helper function to make sure the path exists
		CString sResult = CreatePath(dir);
		if (sResult.GetLength())
		{
			  //readd the filename to the resulting full path
		   sResult += filename;
		   SetDlgItemText(hwndDlg, IDC_PASSWORD_FILE, (LPCTSTR)sResult);
		   return true;
		}
		else
		   return false;
	}
}

void ProcessSelectedObjects2(IDataObject *pdo,HWND hwndDlg)
{
	HRESULT hr = S_OK;	BOOL fGotStgMedium = FALSE;	PDS_SELECTION_LIST pDsSelList = NULL;
	STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL, NULL};
	FORMATETC formatetc = {(CLIPFORMAT) g_cfDsObjectPicker,NULL,DVASPECT_CONTENT,-1,TYMED_HGLOBAL};
	hr = pdo->GetData(&formatetc, &stgmedium);
	if (FAILED(hr)) return;
	fGotStgMedium = TRUE;		
	pDsSelList = (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
	if (!pDsSelList) return;

	SetDlgItemText(hwndDlg,IDC_TARGET_GROUP,pDsSelList->aDsSelection[0].pwzName);
		
	GlobalUnlock(stgmedium.hGlobal);
	if (fGotStgMedium) 	ReleaseStgMedium(&stgmedium);
}



void initpasswordbox(HWND hwndDlg,int id1,int id2,int id3, BSTR bstr1, BSTR bstr2)
{
	_bstr_t     text;
	
	text = pVarSet->get(bstr2);

	if (!UStrICmp(text,(WCHAR const *) yes))
	{
		CheckRadioButton(hwndDlg,id1,id3,id3);
	}
	else
	{
	   text = pVarSet->get(bstr1);
	
	   if (!UStrICmp(text,(WCHAR const *) yes))
	   {
		  CheckRadioButton(hwndDlg,id1,id3,id1);
	   }
	   else 
	   {
		  CheckRadioButton(hwndDlg,id1,id3,id2);
	   }
	}
}

void initdisablesrcbox(HWND hwndDlg)
{
	_bstr_t 	text;
	CString		toformat;
	
	   //init disable src checkbox
    initcheckbox(hwndDlg,IDC_SRC_DISABLE_ACCOUNTS,DCTVS_AccountOptions_DisableSourceAccounts);

	   //set whether to expire accounts
	text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExpireSourceAccounts));
       //if invalid expire time, don't check it, set to 30 days, and disable the 
	   //other sub controls
	if ((!UStrICmp(text, L"")) || ((_wtol(text) == 0) && (UStrICmp(text,L"0"))) || (_wtol(text) > THREE_YEARS))
	{
		CheckDlgButton(hwndDlg, IDC_SRC_EXPIRE_ACCOUNTS, BST_UNCHECKED);
	    toformat.LoadString(IDS_30);
	    SetDlgItemText(hwndDlg,IDC_yo,toformat);
	    calculateDate(hwndDlg,toformat);
	    disable(hwndDlg,IDC_yo);
		disable(hwndDlg,IDC_DATE);
		disable(hwndDlg,IDC_TEXT);
	}
	else //else, check it, set to valid days, and enable sub controls 
	{
		CheckDlgButton(hwndDlg, IDC_SRC_EXPIRE_ACCOUNTS, BST_CHECKED);
	    toformat = (WCHAR*)text;
	    SetDlgItemText(hwndDlg,IDC_yo,toformat);
	    calculateDate(hwndDlg,toformat);
	    enable(hwndDlg,IDC_yo);
		enable(hwndDlg,IDC_DATE);
		enable(hwndDlg,IDC_TEXT);
	}
}

void inittgtstatebox(HWND hwndDlg)
{
	_bstr_t 	text;
	
       //if "Same as source" was set, check it
	text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_TgtStateSameAsSrc));
	if (!UStrICmp(text,(WCHAR const *) yes))
		CheckRadioButton(hwndDlg,IDC_TGT_ENABLE_ACCOUNTS,IDC_TGT_SAME_AS_SOURCE,IDC_TGT_SAME_AS_SOURCE);
	else   //else set enable tgt or disable tgt
	{
		text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
		if (!UStrICmp(text,(WCHAR const *) yes))
			CheckRadioButton(hwndDlg,IDC_TGT_ENABLE_ACCOUNTS,IDC_TGT_SAME_AS_SOURCE,IDC_TGT_DISABLE_ACCOUNTS);
		else
			CheckRadioButton(hwndDlg,IDC_TGT_ENABLE_ACCOUNTS,IDC_TGT_SAME_AS_SOURCE,IDC_TGT_ENABLE_ACCOUNTS);
	}
}

void addrebootValues(HWND hwndDlg)
{
	HWND hLC3= GetDlgItem(hwndDlg,IDC_COMBO2);
	m_rebootBox.Attach(hLC3);
	m_rebootBox.AddString(GET_CSTRING(IDS_ONE));
	m_rebootBox.AddString(GET_CSTRING(IDS_FIVE));
	m_rebootBox.AddString(GET_CSTRING(IDS_TEN));
}

void inittranslationbox(HWND hwndDlg,int id1,int id2,int id3,int i,bool sameForest)
{
	_bstr_t     text;
	text = pVarSet->get(GET_BSTR(i));
	_bstr_t b=pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
HRESULT hr;
	if (sameForest && targetNativeMode(b,hr))
	{
		CheckRadioButton(hwndDlg,id1,id3,id1);
		disable(hwndDlg,id2);
		disable(hwndDlg,id3);
	}
	else
	{
	
//*	if (!UStrICmp(text,L"Replace"))
	if (!UStrICmp(text,GET_STRING(IDS_Replace)))
		CheckRadioButton(hwndDlg,id1,id3,id1);
//*	else if (!UStrICmp(text,L"Add"))
	else if (!UStrICmp(text,GET_STRING(IDS_Add)))
		CheckRadioButton(hwndDlg,id1,id3,id2);
//*	else if (!UStrICmp(text,L"Remove"))
	else if (!UStrICmp(text,GET_STRING(IDS_Remove)))
		CheckRadioButton(hwndDlg,id1,id3,id3);
	else
		CheckRadioButton(hwndDlg,id1,id3,id1);
}
}
void handleDB()
{
	put(DCTVS_Options_Credentials_Password,L"");
	put(DCTVS_AccountOptions_SidHistoryCredentials_Password,L""); 
	put(DCTVS_GatherInformation, L"");
	db->SaveSettings(IUnknownPtr(pVarSet));
}
void populateTime(long rebootDelay,int servers )
{
	
	_variant_t varX;
	CString temp;
	CString typeExtension;
	time_t ltime;
	
	
	if (migration==w_computer)
	{
		time(&ltime);
		
		rebootDelay = rebootDelay;
		
		temp.Format(L"%d",rebootDelay);	
		varX = temp;
		for (int i =0;i<servers;i++)
		{
			typeExtension.Format(L"Servers.%d.RebootDelay",i);	
			pVarSet->put(_bstr_t(typeExtension), varX);
			typeExtension.Format(L"Servers.%d.Reboot",i);
			pVarSet->put(_bstr_t(typeExtension),yes);
		}
	}
}


void initcheckbox(HWND hwndDlg,int id,int varsetKey)
{
	_bstr_t     text;
	
	text = pVarSet->get(GET_BSTR(varsetKey));
	CheckDlgButton( hwndDlg,id, !UStrICmp(text,(WCHAR const * ) yes));
}

void initeditbox(HWND hwndDlg,int id,int varsetKey)
{
	_bstr_t     text;
	
	text = pVarSet->get(GET_BSTR(varsetKey));
	SetDlgItemText( hwndDlg,id, (WCHAR const *) text);
}


void checkbox(HWND hwndDlg,int id,int varsetKey)
{
	_variant_t varX;
	varX = IsDlgButtonChecked( hwndDlg,id) ?  yes : no;
	pVarSet->put(GET_BSTR(varsetKey), varX);
}
void editbox(HWND hwndDlg,int id,int varsetKey)
{
	_variant_t varX;
	CString temp;
	GetDlgItemText( hwndDlg, id, temp.GetBuffer(1000),1000);
	temp.ReleaseBuffer();
	varX = temp;
	pVarSet->put(GET_BSTR(varsetKey), varX); 
}


void translationbox(HWND hwndDlg,int id1,int id2,int id3,int varsetKey)
{
	_variant_t varX;
	if (IsDlgButtonChecked( hwndDlg, id1))
//*		varX = L"Replace";
		varX = GET_STRING(IDS_Replace);
	else if(IsDlgButtonChecked( hwndDlg, id2))
//*		varX = L"Add";
		varX = GET_STRING(IDS_Add);
	else if (IsDlgButtonChecked( hwndDlg, id3))
//*		varX = L"Remove"; 
		varX = GET_STRING(IDS_Remove); 
	pVarSet->put(GET_BSTR(varsetKey), varX);
}

long rebootbox(HWND hwndDlg,int id)
{
	_variant_t varX;
	int rebootDelay;
	if (IsDlgItemEmpty(hwndDlg,id))
		rebootDelay=0;
	else
	{
		CString rebooter;
		GetDlgItemText( hwndDlg, id, rebooter.GetBuffer(1000), 1000);		
		rebooter.ReleaseBuffer();
		rebootDelay = _ttoi(rebooter.GetBuffer(1000));
		rebooter.ReleaseBuffer();
	}
	rebootDelay =rebootDelay*60;
	return rebootDelay;
}


void populateList(CComboBox& s)
{
	DWORD                     fndNet=0;     // number of nets found
	DWORD                     rcNet;        // net enum return code
	HANDLE                    eNet;         // enumerate net domains
	EaWNetDomainInfo          iNet;         // net domain info
	
	rcNet = EaWNetDomainEnumOpen( &eNet );
	if (!rcNet )
	{
		for ( rcNet = EaWNetDomainEnumFirst( eNet, &iNet );
		!rcNet;
		rcNet = EaWNetDomainEnumNext( eNet, &iNet ) )
		{
			fndNet++;
			s.AddString(iNet.name);
		}
		EaWNetDomainEnumClose( eNet );
	}
}


void enable(HWND hwndDlg,int id)
{
	HWND temp=GetDlgItem(hwndDlg,id);
	EnableWindow(temp,true);
}
void disable(HWND hwndDlg,int id)
{
	HWND temp=GetDlgItem(hwndDlg,id);
	EnableWindow(temp,false);
}

void handleInitRename(HWND hwndDlg,bool sameForest,bool bCopyGroups)
{
	_bstr_t text1,text2,text3;
	
	text1 = get(DCTVS_AccountOptions_ReplaceExistingAccounts);
	text2 = get(DCTVS_AccountOptions_Prefix);
	text3 = get(DCTVS_AccountOptions_Suffix);
	
	initeditbox(hwndDlg,IDC_PREFIX,DCTVS_AccountOptions_Prefix );
	initeditbox(hwndDlg,IDC_SUFFIX,DCTVS_AccountOptions_Suffix );
	initcheckbox(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS,DCTVS_AccountOptions_RemoveExistingUserRights);
	initcheckbox(hwndDlg,IDC_REMOVE_EXISTING_LOCATION,DCTVS_AccountOptions_MoveReplacedAccounts);
	if ((migration==w_computer) || (!bCopyGroups))
	{
		disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
		CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
	}
	else
	{
		enable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
		initcheckbox(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,DCTVS_AccountOptions_ReplaceExistingGroupMembers);
	}
	
	if (!UStrICmp(text1,(WCHAR const *) yes))
		CheckRadioButton(hwndDlg,IDC_SKIP_CONFLICTING_ACCOUNTS,IDC_RENAME_CONFLICTING_ACCOUNTS,IDC_REPLACE_CONFLICTING_ACCOUNTS);
	else if (UStrICmp(text2,L"") || UStrICmp(text3,L""))	
		CheckRadioButton(hwndDlg,IDC_SKIP_CONFLICTING_ACCOUNTS,IDC_RENAME_CONFLICTING_ACCOUNTS,IDC_RENAME_CONFLICTING_ACCOUNTS);
	else
		CheckRadioButton(hwndDlg,IDC_SKIP_CONFLICTING_ACCOUNTS,IDC_RENAME_CONFLICTING_ACCOUNTS,IDC_SKIP_CONFLICTING_ACCOUNTS);
	
	if (IsDlgButtonChecked(hwndDlg,IDC_REPLACE_CONFLICTING_ACCOUNTS) && 
		((sameForest) && migration !=w_computer))
	{
		CheckRadioButton(hwndDlg,IDC_SKIP_CONFLICTING_ACCOUNTS,IDC_RENAME_CONFLICTING_ACCOUNTS,IDC_SKIP_CONFLICTING_ACCOUNTS);
		disable(hwndDlg,IDC_REPLACE_CONFLICTING_ACCOUNTS);
	}

	else if (sameForest && migration !=w_computer)
		disable(hwndDlg,IDC_REPLACE_CONFLICTING_ACCOUNTS);
}


void MessageBoxWrapper(HWND hwndDlg,int m,int t)
{
	CString message;
	CString title;
	message.LoadString(m);
	title.LoadString(t);
	MessageBox(hwndDlg,message,title,MB_OK | MB_ICONSTOP);
}
void MessageBoxWrapper3(HWND hwndDlg,int m,int t,CString domainName)
{
	CString message;
	CString title;
	message.LoadString(m);
	title.LoadString(t);

	CString messageFormatter;
	messageFormatter.LoadString(IDS_FORMAT_MESSAGE);
	CString text;
	text.Format(messageFormatter,message,domainName);
	MessageBox(hwndDlg,text,title,MB_OK|MB_ICONSTOP);
}
void MessageBoxWrapperFormat1(HWND hwndDlg,int f,int m, int t)
{
	CString formatter;
	CString insert;
	CString message;
	CString title;
	formatter.LoadString(f);
	insert.LoadString(m);
	message.Format(formatter,insert);
	title.LoadString(t);
	MessageBox(hwndDlg,message,title,MB_OK | MB_ICONSTOP);
}

HRESULT BrowseForContainer(HWND hWnd,//Handle to window that should own the browse dialog.
                    LPOLESTR szRootPath, //Root of the browse tree. NULL for entire forest.
                    LPOLESTR *ppContainerADsPath, //Return the ADsPath of the selected container.
                    LPOLESTR *ppContainerClass //Return the ldapDisplayName of the container's class.
                    )
{
   HRESULT hr = E_FAIL;
   DSBROWSEINFO dsbi;
   OLECHAR szPath[5000];
   OLECHAR szClass[MAX_PATH];
   DWORD result;
 
   if (!ppContainerADsPath)
     return E_POINTER;
 
   ::ZeroMemory( &dsbi, sizeof(dsbi) );
   dsbi.hwndOwner = hWnd;
   dsbi.cbStruct = sizeof (DSBROWSEINFO);
   CString temp1,temp2;
   temp1.LoadString(IDS_BROWSER);
   temp2.LoadString(IDS_SELECTOR);
   dsbi.pszCaption = temp1.GetBuffer(1000);
   temp1.ReleaseBuffer();
   dsbi.pszTitle = temp2.GetBuffer(1000);
   temp2.ReleaseBuffer();
  // L"Browse for Container"; // The caption (titlebar text)
	// dsbi.pszTitle = L"Select a target container."; //Text for the dialog.
   dsbi.pszRoot = szRootPath; //ADsPath for the root of the tree to display in the browser.
                   //Specify NULL with DSBI_ENTIREDIRECTORY flag for entire forest.
                   //NULL without DSBI_ENTIREDIRECTORY flag displays current domain rooted at LDAP.
   dsbi.pszPath = szPath; //Pointer to a unicode string buffer.
   dsbi.cchPath = sizeof(szPath)/sizeof(OLECHAR);//count of characters for buffer.
   dsbi.dwFlags = DSBI_RETURN_FORMAT | //Return the path to object in format specified in dwReturnFormat
               DSBI_RETURNOBJECTCLASS; //Return the object class
   dsbi.pfnCallback = NULL;
   dsbi.lParam = 0;
   dsbi.dwReturnFormat = ADS_FORMAT_X500; //Specify the format.
                       //This one returns an ADsPath. See ADS_FORMAT enum in IADS.H
   dsbi.pszObjectClass = szClass; //Pointer to a unicode string buffer.
   dsbi.cchObjectClass = sizeof(szClass)/sizeof(OLECHAR);//count of characters for buffer.
 
   //if root path is NULL, make the forest the root.
   if (!szRootPath)
     dsbi.dwFlags |= DSBI_ENTIREDIRECTORY;
 
 
 
   //Display browse dialog box.
   result = DsBrowseForContainerX( &dsbi ); // returns -1, 0, IDOK or IDCANCEL
   if (result == IDOK)
   {
       //Allocate memory for string
       *ppContainerADsPath = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(wcslen(szPath)+1));
       if (*ppContainerADsPath)
       {
           hr = S_OK;
           wcscpy(*ppContainerADsPath, szPath);
           //Caller must free using CoTaskMemFree

		      //if the domain was selected, add the DC= stuff
		   CString sNewPath = szPath;
		   if (sNewPath.Find(L"DC=") == -1)
		   {
			     //try retrieving the ADsPath of the containier, which does include
			     //the full LDAP path with DC=
			  IADsPtr			        pCont;
			  BSTR						sAdsPath;
			  hr = ADsGetObject(sNewPath,IID_IADs,(void**)&pCont);
			  if (SUCCEEDED(hr)) 
			  {
                 hr = pCont->get_ADsPath(&sAdsPath);
			     if (SUCCEEDED(hr))
				 {
					sNewPath = (WCHAR*)sAdsPath;
					SysFreeString(sAdsPath);
			        CoTaskMemFree(*ppContainerADsPath);
                    *ppContainerADsPath = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(sNewPath.GetLength()+1));
                    if (*ppContainerADsPath)
                       wcscpy(*ppContainerADsPath, (LPCTSTR)sNewPath);
                    else
                       hr=E_FAIL;
				 }
			  }
		   }
       }
       else
           hr=E_FAIL;
       if (ppContainerClass)
       {
           //Allocate memory for string
           *ppContainerClass = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(wcslen(szClass)+1));
       if (*ppContainerClass)
       {
           wcscpy(*ppContainerClass, szClass);
           //Call must free using CoTaskMemFree
           hr = S_OK;
       }
       else
           hr=E_FAIL;
       }
   }
   else
       hr = E_FAIL;
 
   return hr;
 
}
/*
typedef HRESULT (CALLBACK * DSGETDCNAME)(LPWSTR, LPWSTR, GUID*, LPWSTR, DWORD, PDOMAIN_CONTROLLER_INFO*);

// The following function is used to get the actual account name from the source domain
// instead of account that contains the SID in its SID history.
DWORD GetName(PSID pObjectSID, WCHAR * sNameAccount, WCHAR * sDomain)
{
	DWORD		cb = 255;
	DWORD    cbDomain = 255;
   DWORD    tempVal;
   PDWORD   psubAuth;
   PUCHAR   pVal;
   SID_NAME_USE	sid_Use;
   WCHAR    sDC[255];
   DWORD    rc = 0;

   // Copy the Sid to a temp SID
   DWORD    sidLen = GetLengthSid(pObjectSID);
   PSID     pObjectSID1 = new BYTE[sidLen];
   CopySid(sidLen, pObjectSID1, pObjectSID);

   // Get the RID out of the SID and get the domain SID
   pVal = GetSidSubAuthorityCount(pObjectSID1);
   (*pVal)--;
   psubAuth = GetSidSubAuthority(pObjectSID1, *pVal);
   tempVal = *psubAuth;
   *psubAuth = -1;

   //Lookup the domain from the SID 
   if (!LookupAccountSid(NULL, pObjectSID1, sNameAccount, &cb, sDomain, &cbDomain, &sid_Use))
   {
      rc = GetLastError();
//      err.SysMsgWrite(ErrE, rc,DCT_MSG_DOMAIN_LOOKUP_FAILED_D,rc);
      return rc;
   }
   
   // Get a DC for the domain
   DSGETDCNAME DsGetDcName = NULL;
   DOMAIN_CONTROLLER_INFO  * pSrcDomCtrlInfo = NULL;
   
   HMODULE hPro = LoadLibrary(L"NetApi32.dll");
   if ( hPro )
      DsGetDcName = (DSGETDCNAME)GetProcAddress(hPro, "DsGetDcNameW");
   else
   {
      long rc = GetLastError();
//      err.SysMsgWrite(ErrE, rc, DCT_MSG_LOAD_LIBRARY_FAILED_SD, L"NetApi32.dll");
   }

   if (DsGetDcName)   
   {
      if ( DsGetDcName(
                        NULL                                  ,// LPCTSTR ComputerName ?
                        sDomain                               ,// LPCTSTR DomainName
                        NULL                                  ,// GUID *DomainGuid ?
                        NULL                                  ,// LPCTSTR SiteName ?
                        0                                     ,// ULONG Flags ?
                        &pSrcDomCtrlInfo                       // PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
                     ))
      {
//         err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_GET_DCNAME_FAILED_SD,sDomain,GetLastError());
         return GetLastError();
      }
      else
      {
         wcscpy(sDC, pSrcDomCtrlInfo->DomainControllerName);
         NetApiBufferFree(pSrcDomCtrlInfo);
      }

      // Reset the sizes
      cb = 255;
      cbDomain = 255;

      // Lookup the account on the PDC that we found above.
      if ( LookupAccountSid(sDC, pObjectSID, sNameAccount, &cb, sDomain, &cbDomain, &sid_Use) == 0)
      {
         return GetLastError();
      }
   }
   FreeLibrary(hPro);
   return 0;
}
*/
BOOL GetDomainAndUserFromUPN(WCHAR const * UPNname,CString& domainNetbios, CString& user)
{
   HRESULT                   hr;
   HINSTANCE                 hLibrary = NULL;
   DSCRACKNAMES            * DsCrackNames = NULL;
   DSFREENAMERESULT        * DsFreeNameResult = NULL;
   DSBINDFUNC                DsBind = NULL;
   DSUNBINDFUNC              DsUnBind = NULL;
   HANDLE                    hDs = NULL;
   BOOL						 bConverted = FALSE;
   CString					 resultStr;
   CString					 sDomainDNS;

         // make sure the account name is in UPN format
   if ( NULL != wcschr(UPNname,L'\\') )
	   return FALSE;
      
   hLibrary = LoadLibrary(L"NTDSAPI.DLL"); 
   if ( hLibrary )
   {
       DsBind = (DSBINDFUNC)GetProcAddress(hLibrary,"DsBindW");
       DsUnBind = (DSUNBINDFUNC)GetProcAddress(hLibrary,"DsUnBindW");
       DsCrackNames = (DSCRACKNAMES *)GetProcAddress(hLibrary,"DsCrackNamesW");
       DsFreeNameResult = (DSFREENAMERESULT *)GetProcAddress(hLibrary,"DsFreeNameResultW");
   }
            
   if ( DsBind && DsUnBind && DsCrackNames && DsFreeNameResult)
   {
	  sDomainDNS = targetDNS;
      hr = (*DsBind)(NULL,sDomainDNS.GetBuffer(1000),&hDs);
	  sDomainDNS.ReleaseBuffer();
      if ( !hr )
      {
         PDS_NAME_RESULT         pNamesOut = NULL;
         WCHAR                 * pNamesIn[1];

         pNamesIn[0] = const_cast<WCHAR *>(UPNname);

         hr = (*DsCrackNames)(hDs,DS_NAME_NO_FLAGS,DS_USER_PRINCIPAL_NAME,DS_NT4_ACCOUNT_NAME,1,pNamesIn,&pNamesOut);
	     (*DsUnBind)(&hDs);
         if ( !hr )
         {
            if (pNamesOut->rItems[0].status == DS_NAME_NO_ERROR)
            {
                resultStr = pNamesOut->rItems[0].pName;
				int index = resultStr.Find(L'\\');
				if (index != -1)
				domainNetbios = resultStr.Left(index); //parse off the domain netbios name
				if (!domainNetbios.IsEmpty())
				{	
					   //get the user's sAMAccountName
					user = resultStr.Right(resultStr.GetLength() - index - 1);
					if (!user.IsEmpty())
					   bConverted = TRUE;
				}
            }
			else if (pNamesOut->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY)
			{
	           sDomainDNS = pNamesOut->rItems[0].pDomain;
               hr = (*DsBind)(NULL,sDomainDNS.GetBuffer(1000),&hDs);
			   sDomainDNS.ReleaseBuffer();
               if ( !hr )
			   {
                  (*DsFreeNameResult)(pNamesOut);
                  pNamesOut = NULL;
                  hr = (*DsCrackNames)(hDs,DS_NAME_NO_FLAGS,DS_USER_PRINCIPAL_NAME,DS_NT4_ACCOUNT_NAME,1,pNamesIn,&pNamesOut);
                  if ( !hr )
				  {
                     if ( pNamesOut->rItems[0].status == DS_NAME_NO_ERROR )
					 {
                        resultStr = pNamesOut->rItems[0].pName;
				        int index = resultStr.Find(L'\\');
				        if (index != -1)
				        domainNetbios = resultStr.Left(index); //parse off the domain netbios name
				        if (!domainNetbios.IsEmpty())
						{	
					          //get the user's sAMAccountName
					       user = resultStr.Right(resultStr.GetLength() - index - 1);
					       if (!user.IsEmpty())
					          bConverted = TRUE;
						}
					 }//end if no error
				  }//end if name cracked
  	              (*DsUnBind)(&hDs);
			   }//end if bound to other domain
			}
			if (pNamesOut)
               (*DsFreeNameResult)(pNamesOut);
         }//end if name cracked
      }//end if bound to target domain
   }//end got functions

   if ( hLibrary )
   {
      FreeLibrary(hLibrary);
   }

   return bConverted;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 31 AUG 2000                                                 *
 *                                                                   *
 *     This function is responsible for switching between showing the*
 * password file editbox and the password dc combobox.               *
 *                                                                   *
 *********************************************************************/

//BEGIN switchboxes
void switchboxes(HWND hwndDlg,int oldid, int newid)
{
/* local variables */
	CWnd oldWnd;
	CWnd newWnd;

/* function body */
	oldWnd.Attach(GetDlgItem(hwndDlg, oldid));
	newWnd.Attach(GetDlgItem(hwndDlg, newid));
	oldWnd.ShowWindow(SW_HIDE);
	newWnd.ShowWindow(SW_SHOW);
	oldWnd.Detach();
	newWnd.Detach();
}
//END switchboxes

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 31 AUG 2000                                                 *
 *                                                                   *
 *     This function is responsible for enumerating all DCs in the   *
 * given source domain and add them into the source domain combobox. *
 *                                                                   *
 *********************************************************************/

//BEGIN populatePasswordDCs
bool populatePasswordDCs(HWND hwndDlg, int id, bool bNT4)
{
/* local variables */
	CComboBox				pwdCombo;
	CString					aDCName;
	CString					aDnName;
    IEnumVARIANT          * pEnumerator = NULL;
    VARIANT                 var;
	POSITION				currentPos;
	HRESULT					hr = S_OK;

/* function body */
    VariantInit(&var);

    pwdCombo.Attach(GetDlgItem(hwndDlg, id));

	  //if we already have a list of DCs for this domain then add them
	if (!DCList.IsEmpty())
	{
		  //get the position and string of the first name in the list
	   currentPos = DCList.GetHeadPosition();

		  //while there is another entry to retrieve from the list, then 
		  //get a name from the list and add it to the combobox
	   while (currentPos != NULL)
	   {
			//get the next string in the list, starts with the first
		  aDCName = DCList.GetNext(currentPos);
		  if (pwdCombo.FindString(-1, aDCName) == CB_ERR)
	         pwdCombo.AddString(aDCName);//add the DC to the combobox
	   }
	}
	else //else enumerate DCs in the domain and add them
	{
	   pwdCombo.ResetContent();//reset the combobox contents

	      //enumerate all domain controllers in the given domain
       if (bNT4)
	      hr = QueryNT4DomainControllers(sourceDNS, pEnumerator);
       else
	      hr = QueryW2KDomainControllers(sourceDNS, pEnumerator);
	   if (SUCCEEDED(hr))
	   {
          unsigned long count = 0;
	         //for each computer see if a DC.  If so, add to combobox
          while ( pEnumerator->Next(1,&var,&count) == S_OK )
		  {
		        //get the sam account name for this computer
             if ( var.vt == ( VT_ARRAY | VT_VARIANT ) )
			 {
                VARIANT              * pData;
			    _variant_t			   vnt;
				_bstr_t				   abstr;

                SafeArrayAccessData(var.parray,(void**)&pData);
                  // pData[0] has the sam account name list
			    vnt.Attach(pData[0]);
				abstr = _bstr_t(vnt);
			    aDCName = (WCHAR *)abstr;
			    vnt.Detach();

			    SafeArrayUnaccessData(var.parray);

				   //computer sAMAccountNames end in $, lets get rid of that
				int length = aDCName.GetLength();
				if (aDCName[length-1] == L'$')
					aDCName = aDCName.Left(length-1);

				   //add the DC to the combobox and the memory list, if not in already
				if (pwdCombo.FindString(-1, aDCName) == CB_ERR)
				   pwdCombo.AddString(aDCName);
				if (DCList.Find(aDCName) == NULL)
		           DCList.AddTail(aDCName);
			 }
		  }//end while more computers
          pEnumerator->Release();
	   }
    }//end if must get DCs
	pwdCombo.Detach();

	if (hr == S_OK)
	   return true;
	else
	   return false;
}
//END populatePasswordDCs

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 1 SEPT 2000                                                 *
 *                                                                   *
 *     This worker function is responsible for enumerating all domain*
 * controllers in the given Windows 2000 domain.  The variant array  *
 * passed back is filled with the sAMAccountName for each domain     *
 * controller.                                                       *
 *                                                                   *
 *********************************************************************/

//BEGIN QueryW2KDomainControllers
HRESULT QueryW2KDomainControllers(CString domainDNS, IEnumVARIANT*& pEnum)
{
   CString                   sQuery;
   WCHAR                     sCont[MAX_PATH];
   SAFEARRAY               * colNames;
   SAFEARRAYBOUND            bd = { 1, 0 };
   HRESULT                   hr = S_OK;

   try
   {
      INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
	     //query for all domain controllers in the domain
      sQuery = L"(&(objectCategory=Computer)";
      sQuery += L"(userAccountControl:";
      sQuery += LDAP_MATCHING_RULE_BIT_AND_W;
      sQuery += L":=8192))";

	  wsprintf(sCont, L"LDAP://%s", domainDNS);

		 //set columns to retrieve sAMAccountName
      colNames = SafeArrayCreate(VT_BSTR, 1, &bd);
      long ndx[1];
      ndx[0] = 0;
      SafeArrayPutElement(colNames,ndx,SysAllocString(L"sAMAccountName"));

	     //prepare and execute the query
      pQuery->SetQuery(sCont, _bstr_t(domainDNS), _bstr_t(sQuery), ADS_SCOPE_SUBTREE, FALSE);
      pQuery->SetColumns(colNames);
      pQuery->Execute(&pEnum);
   }
   catch(_com_error& e)
   {
      hr = e.Error();
   }
   catch(...)
   {
      hr = E_FAIL;
   }

   return hr;
}
//END QueryW2KDomainControllers

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 1 SEPT 2000                                                 *
 *                                                                   *
 *     This worker function is responsible for enumerating all domain*
 * controllers in the given Windows NT4 domain.  The variant array   *
 * passed back is filled with the sAMAccountName for each domain     *
 * controller.                                                       *
 *                                                                   *
 *********************************************************************/

//BEGIN QueryNT4DomainControllers
HRESULT QueryNT4DomainControllers(CString domainDNS, IEnumVARIANT*& pEnum)
{
   CString                   sCont;
   SAFEARRAY               * colNames;
   SAFEARRAYBOUND            bd = { 1, 0 };
   HRESULT                   hr = S_OK;

   try
   {
      INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));

	  sCont = L"CN=DOMAIN CONTROLLERS";

		 //set columns to retrieve sAMAccountName
      colNames = SafeArrayCreate(VT_BSTR, 1, &bd);
      long ndx[1];
      ndx[0] = 0;
      SafeArrayPutElement(colNames,ndx,SysAllocString(L"sAMAccountName"));

	     //prepare and execute the query
      pQuery->SetQuery(_bstr_t(sCont), _bstr_t(domainDNS), L"", ADS_SCOPE_SUBTREE, FALSE);
      pQuery->SetColumns(colNames);
      pQuery->Execute(&pEnum);
   }
   catch(_com_error& e)
   {
      hr = e.Error();
   }
   catch(...)
   {
      hr = E_FAIL;
   }

   return hr;
}
//END QueryNT4DomainControllers

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 1 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for adding a given string to a   *
 * given combobox, if that string is not already in the combobox.    *
 *                                                                   *
 *********************************************************************/

//BEGIN addStringToComboBox
void addStringToComboBox(HWND hwndDlg, int id, CString s)
{
/* local variables */
	CComboBox				pwdCombo;

/* function body */
       //if the DC starts with "\\", then remove them
    if (!UStrICmp(s,L"\\\\",UStrLen(L"\\\\")))
	   s = s.Right(s.GetLength() - UStrLen(L"\\\\"));

    pwdCombo.Attach(GetDlgItem(hwndDlg, id));
	if (pwdCombo.FindString(-1, s) == CB_ERR)
	   pwdCombo.AddString(s);//add the string to the combobox
	pwdCombo.Detach();
}
//END addStringToComboBox

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 1 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for selecting a string in a given*
 * combobox.  If we previously had a DC selected for this domain in  *
 * the varset, we select it.  If not, then we set it to the DC found *
 * in the Domain Selection dialog.                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN initDCcombobox
void initDCcombobox(HWND hwndDlg, int id, int varsetKey)
{
/* local variables */
	CComboBox				pwdCombo;
	CString					prevDC;
	CString					sTemp;
	_bstr_t					text;

/* function body */
	   //strip the "\\" off the sourceDC default in case we need it
    if (!UStrICmp(sourceDC,L"\\\\",UStrLen(L"\\\\")))
	   sTemp = sourceDC.Right(sourceDC.GetLength() - UStrLen(L"\\\\"));

    pwdCombo.Attach(GetDlgItem(hwndDlg, id));

       //get a previous DC
	text = pVarSet->get(GET_BSTR(varsetKey));
	prevDC = (WCHAR *)text;
	prevDC.TrimLeft();prevDC.TrimRight();
	   //if not previous DC, use the one found during the Domain Selection
	if (prevDC.IsEmpty())
		prevDC = sTemp;

	   //select string in combobox
	if (pwdCombo.SelectString(-1, prevDC) == CB_ERR)
	   pwdCombo.SelectString(-1, sTemp);

	pwdCombo.Detach();
}
//END initDCcombobox


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 3 OCT 2000                                                  *
 *                                                                   *
 *     This function is responsible for initializing the Security    *
 * Translation Input dialog's radio buttons based on any previous    *
 * settings.                                                         *
 *                                                                   *
 *********************************************************************/

//BEGIN initsecinputbox
void initsecinputbox(HWND hwndDlg,int id1,int id2,int varsetKey)
{
	_bstr_t     text;
	
	text = pVarSet->get(GET_BSTR(varsetKey));

	if (!UStrICmp(text,(WCHAR const *) yes))
		CheckRadioButton(hwndDlg,id1,id2,id1);
	else
	    CheckRadioButton(hwndDlg,id1,id2,id2);
}
//END initsecinputbox


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 3 OCT 2000                                                  *
 *                                                                   *
 *     This function is responsible for displaying and handling the  *
 * map file browse dialog.                                           *
 *                                                                   *
 *********************************************************************/

//BEGIN OnMapFileBrowse
void OnMapFileBrowse(HWND hwndDlg,int id)
{
	CWnd yo ;
	yo.Attach(hwndDlg);
	
    CFileDialog f(TRUE,
		NULL,
		NULL,
		OFN_LONGNAMES | OFN_NOREADONLYRETURN,
	    (L"Text Files (*.csv;*.txt)|*.csv;*.txt|All Files (*.*)|*.*||"),
		&yo);


	
	if ( f.DoModal() == IDOK )
	{
		SetDlgItemText(hwndDlg,id,f.GetPathName());
	}
	yo.Detach();
}
//END OnMapFileBrowse


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 3 OCT 2000                                                  *
 *                                                                   *
 *     This function is responsible for checking to see if the file  *
 * specified in the edit box on the given dialog is a valid file.  We*
 * will set the full path of the file if a relative path was given.  *
 *                                                                   *
 *********************************************************************/

//BEGIN checkMapFile
bool checkMapFile(HWND hwndDlg)
{
	CString h;GetDlgItemText(hwndDlg,IDC_MAPPING_FILE,h.GetBuffer(1000),1000);h.ReleaseBuffer();
	CFileFind finder;

	bool exists = (finder.FindFile((LPCTSTR) h )!=0);
	if (exists)
	{
	   BOOL bmore = finder.FindNextFile();//must call to fill in path info
	   CString fullpath = finder.GetFilePath();
	   if (fullpath.GetLength() != 0)
	      SetDlgItemText(hwndDlg,IDC_MAPPING_FILE,fullpath);
	}

    return exists;
}
//END checkMapFile


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for initializing the object      *
 * property exclusion dialog.                                        *
 *     This function adds all common schema properties for the object*
 * type to the listboxes.  Previously excluded properties will be    *
 * placed in the excluded listbox and all other will be placed in the*
 * included listbox.  Since more than one object is allowable, we    *
 * have a combobox that holds the objects whose properties can be    *
 * enumerated, and the listboxes show the properties for the object  *
 * selected in the combobox.                                         *
 *                                                                   *
 *********************************************************************/

//BEGIN initpropdlg
void initpropdlg(HWND hwndDlg)
{
/* local constants */
	const WCHAR DELIMITER[3] = L",\0";//used to seperate names in the string

/* local variables */
	CListBox				propIncList;
	CListBox				propExcList;
	CComboBox				typeCombo;
	CString					sPropName;
	CString					sPropOID;
	CString					sType2;
	CString					sExList1;
	CString					sExList2 = L"";
    CString                 Type1, Type2 = L"";
	CStringList				ExList1, ExList2;
	_bstr_t					text;
    HRESULT                 hr;
	long					srcVer = 5;
	POSITION				currentPos;
	
/* function body */
	CWaitCursor wait;
    /* get list(s) of previously excluded properties and set type
	   related variables */
	if (migration==w_computer)
	{
		  //get the previous computer exclusion list
	   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps));
	   sExList1 = (WCHAR *)text;
	   Type1 = L"computer";  //set the type to computer
	      //set the parent text
	   sType1 = GET_STRING(IDS_COMPUTERPROPS);
	}
	else if (migration==w_account)
	{
		  //get the previous user exclusion list
	   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps));
	   sExList1 = (WCHAR *)text;
	      //if also migrating groups, set 2nd parent information
	   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyMemberOf));
	   if (!UStrICmp((WCHAR*)text,(WCHAR const *) yes))
	   {
		      //get the previous group exclusion list
	      text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps));
	      sExList2 = (WCHAR *)text;
	      Type2 = L"group"; //set 2nd type to group
	         //set 2nd parent text
	      sType2 = GET_STRING(IDS_GROUPPROPS);
	   }
	   Type1 = L"user";  //set type to user
	      //set the parent text
	   sType1 = GET_STRING(IDS_USERPROPS);
	}
	else if (migration==w_group || migration==w_groupmapping)
	{
		  //get the previous group exclusion list
	   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps));
	   sExList1 = (WCHAR *)text;
	      //if also migrating users, set 2nd parent information
	   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyContainerContents));
	   if (!UStrICmp((WCHAR*)text,(WCHAR const *) yes))
	   {
		      //get the previous user exclusion list
	      text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps));
	      sExList2 = (WCHAR *)text;
	      Type2 = L"user"; //set 2nd type to user
	         //set 2nd parent text
	      sType2 = GET_STRING(IDS_USERPROPS);
	   }
	   Type1 = L"group";  //set type to group
	      //set the parent text
	   sType1 = GET_STRING(IDS_GROUPPROPS);
	}

	/* place comma seperated exclusion strings parts into lists */
	   //place each substring in the 1st exclusion string into a list
	if (!sExList1.IsEmpty())
	{
	   CString sTemp = sExList1;
	   WCHAR* pStr = sTemp.GetBuffer(0);
	   WCHAR* pTemp = wcstok(pStr, DELIMITER);
	   while (pTemp != NULL)
	   {
		  ExList1.AddTail(pTemp);
			//get the next item
		  pTemp = wcstok(NULL, DELIMITER);
	   }
	   sTemp.ReleaseBuffer();
	}

	   //place each substring in the 2nd exclusion string into a list
	if (!sExList2.IsEmpty())
	{
	   CString sTemp = sExList2;
	   WCHAR* pStr = sTemp.GetBuffer(0);
	   WCHAR* pTemp = wcstok(pStr, DELIMITER);
	   while (pTemp != NULL)
	   {
		  ExList2.AddTail(pTemp);
			//get the next item
		  pTemp = wcstok(NULL, DELIMITER);
	   }
	   sTemp.ReleaseBuffer();
	}

    /* place the type(s) in the combobox */
    typeCombo.Attach(GetDlgItem(hwndDlg, IDC_OBJECTCMBO));
	typeCombo.ResetContent();
    typeCombo.InsertString(-1, sType1);
	if (!sType2.IsEmpty())
	   typeCombo.InsertString(-1, sType2);
	   //select type 1 in the combobox
	typeCombo.SelectString(-1, sType1);
	typeCombo.Detach();

       //get a list of all properties names and their OIDs for this object type
	PropIncMap1.RemoveAll();
	PropExcMap1.RemoveAll();
    hr = BuildPropertyMap(Type1, srcVer, &PropIncMap1);

	/* remove excluded properties from the inclusion map and place that property in
	   the exclusion map */
	if (!ExList1.IsEmpty())
	{
		  //get the position and string of the first property in the previous
		  //exclusion list
	   currentPos = ExList1.GetHeadPosition();
		  //while there is another entry to retrieve from the list, then 
		  //get a property name from the list,remove it from the inclusion map, and
	      //place it in the exclusion list
	   while (currentPos != NULL)
	   {
			//get the next string in the list, starts with the first
		  sPropName = ExList1.GetNext(currentPos);

	         //if we find the property in the inclusion map, remove it and 
		     //add to the exclusion map
	      if (PropIncMap1.Lookup(sPropName, sPropOID))
		  {
		     PropIncMap1.RemoveKey(sPropName); //remove it from the inc map
	         PropExcMap1.SetAt(sPropName, sPropOID);//add it to the exc map
		  }//end if found in map
	   }
	}

	/* add the type1 properties to the appropriate listboxes */
    listproperties(hwndDlg);

	   //init "Exclude Prop" checkbox
	text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
	   //if not checked, disable all other controls
	if (UStrICmp(text,(WCHAR const * ) yes))
	{
	   CheckDlgButton( hwndDlg,IDC_EXCLUDEPROPS, BST_UNCHECKED);
	   disable(hwndDlg,IDC_OBJECTCMBO);
	   disable(hwndDlg,IDC_INCLUDELIST);
	   disable(hwndDlg,IDC_EXCLUDELIST);
	   disable(hwndDlg,IDC_EXCLUDEBTN);
	   disable(hwndDlg,IDC_INCLUDEBTN);
	}
	else //eles enable them
	{
	   CheckDlgButton( hwndDlg,IDC_EXCLUDEPROPS, BST_CHECKED);
	   enable(hwndDlg,IDC_OBJECTCMBO);
	   enable(hwndDlg,IDC_INCLUDELIST);
	   enable(hwndDlg,IDC_EXCLUDELIST);
	   enable(hwndDlg,IDC_EXCLUDEBTN);
	   enable(hwndDlg,IDC_INCLUDEBTN);
	}

	   //if no 2nd type to be displayed, leave
	if (Type2.IsEmpty())
	   return;

	/* enumerate and add all mapped properties, for the 2nd type, to the maps */
       //get a list of all properties names and their OIDs for this object type
	PropIncMap2.RemoveAll();  //clear the property map
	PropExcMap2.RemoveAll();  //clear the property map
    hr = BuildPropertyMap(Type2, srcVer, &PropIncMap2);

	/* remove excluded properties from the inclusion map and place that property in
	   the exclusion map */
	if (!ExList2.IsEmpty())
	{
		  //get the position and string of the first name in the previous
		  //exclusion list
	   currentPos = ExList2.GetHeadPosition();
		  //while there is another entry to retrieve from the list, then 
		  //get a name from the list,remove it from the inclusion map, and
	      //place it in the exclusion list
	   while (currentPos != NULL)
	   {
			 //get the next string in the list, starts with the first
		  sPropName = ExList2.GetNext(currentPos);
	         //if we find the property in the inclusion map, remove it and 
		     //add to the exclusion map
	      if (PropIncMap2.Lookup(sPropName, sPropOID))
		  {
		     PropIncMap2.RemoveKey(sPropName); //remove it from the inc map
	         PropExcMap2.SetAt(sPropName, sPropOID);//add it to the exc map
		  }//end if found in map
	   }
	}
}
//END initpropdlg


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 OCT 2000                                                 *
 *                                                                   *
 *     This function is used by "initpropdlg" to retrieve a given    *
 * object's properties, and their associated OIDs, from the schema.  *
 *     The property names and OIDs are placed in a given             *
 * string-to-string map using the OID as the key.  Property          *
 * enumeration is accomplished using the ObjPropBuilder class.       *
 *                                                                   *
 *********************************************************************/

//BEGIN BuildPropertyMap
HRESULT BuildPropertyMap(CString Type, long lSrcVer, CMapStringToString * pPropMap)
{
/* local variables */
    IObjPropBuilderPtr      pObjProp(__uuidof(ObjPropBuilder));
    IVarSetPtr              pVarTemp(__uuidof(VarSet));
    IUnknown              * pUnk;
    HRESULT                 hr;
    long                    lRet=0;
    SAFEARRAY             * keys = NULL;
    SAFEARRAY             * vals = NULL;
    VARIANT                 var;
	CString					sPropName;
	CString					sPropOID;

/* function body */
    VariantInit(&var);

       //get an IUnknown pointer to the Varset for passing it around.
    hr = pVarTemp->QueryInterface(IID_IUnknown, (void**)&pUnk);
    if (FAILED(hr))
	   return hr;

	   //fill the varset with a list of properties in common between the source
	   //and target domain for the first type being migrated
    hr = pObjProp->raw_MapProperties(_bstr_t(Type), _bstr_t(sourceNetbios), 
		                             lSrcVer, _bstr_t(Type), _bstr_t(targetNetbios), 
									 5, 1, &pUnk);
    if (SUCCEEDED(hr) || (hr == DCT_MSG_PROPERTIES_NOT_MAPPED))
	{
       hr = pVarTemp->getItems(L"", L"", 1, 10000, &keys, &vals, &lRet);
       if (SUCCEEDED(hr)) 
	   {
          for ( long x = 0; x < lRet; x++ )
		  {
             ::SafeArrayGetElement(keys, &x, &var);
             if (V_VT(&var) != VT_EMPTY)
			 {
                sPropOID = (WCHAR*)(var.bstrVal);
                VariantClear(&var);

                ::SafeArrayGetElement(vals, &x, &var);
                if (V_VT(&var) != VT_EMPTY)
				{
                   sPropName = (WCHAR*)(var.bstrVal);
                   VariantClear(&var);

			          //place the OID and Name in the map with the name as the key
			       pPropMap->SetAt(sPropName, sPropOID);
				}
			 }
		  }
	   }
	}
	return hr;
}
//END BuildPropertyMap


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 27 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for moving properties to and from*
 * the inclusion and exclusion listboxes.  If the boolean parameter  *
 * is true, then we are moving properties from the inclusion listbox *
 * to the exclusion listbox.  We will also move the properties from  *
 * the global inclusion and exclusion maps.                          *
 *                                                                   *
 *********************************************************************/

//BEGIN moveproperties
void moveproperties(HWND hwndDlg, bool bExclude)
{
/* local constants */
	const int MAX_LB_SELECTIONS = 2000;

/* local variables */
	CListBox				propToList;
	CListBox				propFromList;
	CComboBox				typeCombo;
    CMapStringToString	*	pPropFromMap;
    CMapStringToString	*	pPropToMap;
	CStringList				sMoveList;
	CString					sPropName;
	CString					sTempName;
	CString					sTempOID;
	POSITION				currentPos;
	int						SelectedItems[MAX_LB_SELECTIONS];
	int						ndx;
	int						nFound;

/* function body */
	/* find out whether type1 or type2 is having properties moved and
	   setup map pointer accordingly */
    typeCombo.Attach(GetDlgItem(hwndDlg, IDC_OBJECTCMBO));
	   //if type1, use the type1 maps
	if (typeCombo.FindString(-1, sType1) == typeCombo.GetCurSel())
	{
	   if (bExclude)
	   {
	      pPropToMap = &PropExcMap1;
	      pPropFromMap = &PropIncMap1;
	   }
	   else
	   {
	      pPropToMap = &PropIncMap1;
	      pPropFromMap = &PropExcMap1;
	   }
	}
	else //else use type2 maps
	{
	   if (bExclude)
	   {
	      pPropToMap = &PropExcMap2;
	      pPropFromMap = &PropIncMap2;
	   }
	   else
	   {
	      pPropToMap = &PropIncMap2;
	      pPropFromMap = &PropExcMap2;
	   }
	}
	typeCombo.Detach();

	/* attach to the proper listboxes */
	if (bExclude)
	{
       propToList.Attach(GetDlgItem(hwndDlg, IDC_EXCLUDELIST));
       propFromList.Attach(GetDlgItem(hwndDlg, IDC_INCLUDELIST));
	}
	else
	{
       propToList.Attach(GetDlgItem(hwndDlg, IDC_INCLUDELIST));
       propFromList.Attach(GetDlgItem(hwndDlg, IDC_EXCLUDELIST));
	}

	/* get the items selected for moving and place the names in a list */
	sMoveList.RemoveAll();
	int num_selected = propFromList.GetSelItems(MAX_LB_SELECTIONS, 
											  (LPINT)&SelectedItems);
	if ( num_selected != LB_ERR)//if got selected items,
	{	
			//for each selected item, move maps and listboxes
		for (ndx = 0; ndx < num_selected; ndx++)
		{
		  	propFromList.GetText(SelectedItems[ndx], sTempName);//get item text
			sMoveList.AddTail(sTempName);
		}
	}

	/* move the properties in the listboxes and the maps */
	if (!sMoveList.IsEmpty())
	{
	   currentPos = sMoveList.GetHeadPosition();
		  //while there is another entry to retrieve from the move list, then 
		  //get a name from the 'from' list, remove it from the 'from' map and 
	      //listbox, and place it in the 'to' map and listbox list
	   while (currentPos != NULL)
	   {
			 //get the next string in the list, starts with the first
		  sTempName = sMoveList.GetNext(currentPos);
	         //remove the property from the 'from' listbox
		  if ((nFound = propFromList.FindString(-1, sTempName)) != LB_ERR)
		  {
		     propFromList.DeleteString(nFound);
		        //add it to the 'to' listbox
	         propToList.AddString(sTempName);
		  }

		  /* find the property in the 'from' map, remove it, and add it to the
		     'to' map */
	         //if we find the property in the inclusion map, remove it and 
		     //add to the exclusion map
	      if (pPropFromMap->Lookup(sTempName, sTempOID))
		  {
		     pPropFromMap->RemoveKey(sTempName); //remove it from the from map
	         pPropToMap->SetAt(sTempName, sTempOID);//add it to the to map
		  }//end if found in map
	   }//end while more props to move
	}//end if props to move
	propToList.Detach();
	propFromList.Detach();
}
//END moveproperties


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 27 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for listing properties in the    *
 * inclusion and exclusion listboxes based on the current object type*
 * selected in the combobox.                                         *
 *     We will retrieve the properties from the global inclusion and *
 * exclusion maps.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN listproperties
void listproperties(HWND hwndDlg)
{
/* local variables */
	CListBox				propIncList;
	CListBox				propExcList;
	CComboBox				typeCombo;
    CMapStringToString	*	pPropIncMap;
    CMapStringToString	*	pPropExcMap;
	CString					sPropName;
	CString					sPropOID;
	POSITION				currentPos;

/* function body */
	/* find out whether type1 or type2 is having properties listed and
	   setup map pointer accordingly */
    typeCombo.Attach(GetDlgItem(hwndDlg, IDC_OBJECTCMBO));
	   //if type1, use the type1 maps
	if (typeCombo.FindString(-1, sType1) == typeCombo.GetCurSel())
	{
       pPropIncMap = &PropIncMap1;
	   pPropExcMap = &PropExcMap1;
	}
	else //else use type2 maps
	{
       pPropIncMap = &PropIncMap2;
	   pPropExcMap = &PropExcMap2;
	}
	typeCombo.Detach();

	/* attach to the proper listboxes */
    propIncList.Attach(GetDlgItem(hwndDlg, IDC_INCLUDELIST));
    propExcList.Attach(GetDlgItem(hwndDlg, IDC_EXCLUDELIST));
    propIncList.ResetContent();
    propExcList.ResetContent();

	/* populate the include listbox from the include map */
	if (!pPropIncMap->IsEmpty())
	{
	      //get the position of the first name in the list
	   currentPos = pPropIncMap->GetStartPosition();
	      //for each property in the include map, place it in 
	      //the include listbox
	   while (currentPos != NULL)
	   {
	         //get the next name and associated OID from the map, starts with the first
	      pPropIncMap->GetNextAssoc(currentPos, sPropName, sPropOID);
	      propIncList.AddString(sPropName);
	   }//end while more to list
	}//end if props to list

	/* populate the exclude listbox from the exclude map */
	if (!pPropExcMap->IsEmpty())
	{
	      //get the position of the first name in the list
	   currentPos = pPropExcMap->GetStartPosition();
	      //for each property in the include map, place it in 
	      //the include listbox
	   while (currentPos != NULL)
	   {
	         //get the next name and associated OID from the map, starts with the first
	      pPropExcMap->GetNextAssoc(currentPos, sPropName, sPropOID);
	      propExcList.AddString(sPropName);
	   }//end while more to list
	}//end if props to list

	propIncList.Detach();
	propExcList.Detach();
}
//END listproperties


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 31 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for storing excluded properties  *
 * in the proper varset field.  The excluded properties are retrieved*
 * from the global exclusion maps.  Properties are store in the      *
 * varset string as a comma-seperated string of the properties' IOD. *
 *                                                                   *
 *********************************************************************/

//BEGIN saveproperties
void saveproperties(HWND hwndDlg)
{
/* local variables */
	CComboBox				typeCombo;
	CString					sPropName;
	CString					sPropOID;
	CString					sType2 = L"";
	CString					sType;
	CString					sExList;
	POSITION				currentPos;
	int						ndx;
	_bstr_t					text;
	_bstr_t					key1;
	_bstr_t					key2;

/* function body */
	/* see if there is a second type listed in the combobox */
    typeCombo.Attach(GetDlgItem(hwndDlg, IDC_OBJECTCMBO));

	for (ndx = 0; ndx < typeCombo.GetCount(); ndx++)
	{
	   typeCombo.GetLBText(ndx, sType); //get the next type listed
	   if (sType != sType1)
		   sType2 = sType;
	}
	typeCombo.Detach();

    /* find the proper varset key for each type */
	if (sType1 == GET_STRING(IDS_USERPROPS))
	   key1 = GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps);
	if (sType1 == GET_STRING(IDS_GROUPPROPS))
	   key1 = GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps);
	if (sType1 == GET_STRING(IDS_COMPUTERPROPS))
	   key1 = GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps);

	if (!sType2.IsEmpty())
	{
	   if (sType2 == GET_STRING(IDS_USERPROPS))
	      key2 = GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps);
	   if (sType2 == GET_STRING(IDS_GROUPPROPS))
	      key2 = GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps);
	   if (sType2 == GET_STRING(IDS_COMPUTERPROPS))
	      key2 = GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps);
	}

	/* populate the varset key for Type1 from the exclusion map */
	sExList = L"";
	if (!PropExcMap1.IsEmpty())
	{
	      //get the position of the first name in the list
	   currentPos = PropExcMap1.GetStartPosition();
	      //for each property in the exclusion map, place it's name in 
	      //the comma-seperated varset string
	   while (currentPos != NULL)
	   {
	         //get the next name and associated OID from the map, starts with the first
	      PropExcMap1.GetNextAssoc(currentPos, sPropName, sPropOID);
	      sExList += sPropName;
	      sExList += L",";
	   }//end while more to add
	      //remove the trailing ','
	   sExList.SetAt((sExList.GetLength() - 1), L'\0');
	}//end if props to record

	/* store the Type1 excluded properties in the varset */
	pVarSet->put(key1, _bstr_t(sExList));

	/* if a Type2, populate the varset key for Type2 from the exclusion map */
	if (!sType2.IsEmpty())
	{
	   sExList = L"";
	   if (!PropExcMap2.IsEmpty())
	   {
	         //get the position of the first name in the list
	      currentPos = PropExcMap2.GetStartPosition();
	         //for each property in the exclusion map, place it's name in 
	         //the comma-seperated varset string
	      while (currentPos != NULL)
		  {
	            //get the next name and associated OID from the map, starts with the first
	         PropExcMap2.GetNextAssoc(currentPos, sPropName, sPropOID);
	         sExList += sPropName;
	         sExList += L",";
		  }//end while more to add
	         //remove the trailing ','
	      sExList.SetAt((sExList.GetLength() - 1), L'\0');
	   }//end if props to record
	}//end if props to record

	/* if Type2, store the Type2 excluded properties in the varset */
	if (!sType2.IsEmpty())
	   pVarSet->put(key2, _bstr_t(sExList));
}
//END saveproperties


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 17 NOV 2000                                                 *
 *                                                                   *
 *     This function is responsible for making an RPC call into the  *
 * given Password DC to see if it is ready to perform password       *
 * migrations.  We return if it is ready or not.  If the DC is not   *
 * ready, we also fill in the msg and title strings.                 *
 *                                                                   *
 *********************************************************************/

//BEGIN IsPasswordDCReady
bool IsPasswordDCReady(CString server, CString& msg, CString& title, UINT *msgtype)
{
/* local variables */
   IPasswordMigrationPtr     pPwdMig(__uuidof(PasswordMigration));
   DOMAIN_CONTROLLER_INFO  * pTgtDomCtrlInfo = NULL;
   HRESULT					 hr = S_OK;
   DWORD                     rc = 0;
   CString					 sTemp;
   TErrorDct				 err;
   _bstr_t					 sText;
   _bstr_t					 sTgtDC = L"";
   WCHAR					 sMach[1000];
   DWORD					 dwMachLen = 1000;
   IErrorInfoPtr			 pErrorInfo = NULL;
   BSTR						 bstrDescription;

/* function body */
      //get a DC from this domain.  We will set a VARSET key so that we use this DC for
      //password migration (and other acctrepl operations)
   rc = DsGetDcName(NULL, targetDNS, NULL, NULL, 0, &pTgtDomCtrlInfo);
   if (rc == NO_ERROR)
   {
      sTgtDC = pTgtDomCtrlInfo->DomainControllerName;
      NetApiBufferFree(pTgtDomCtrlInfo);
   }
   else  //else if failed, get this machine's name
   {
      if (GetComputerNameEx(ComputerNameDnsFullyQualified, sMach, &dwMachLen))
	     sTgtDC = sMach;
   }
      
      //make sure the server name starts with "\\"
   if (wcsncmp((WCHAR*)sTgtDC, L"\\\\", 2))
   {
      _bstr_t sTempName = L"\\\\";
      sTempName += sTgtDC;
	  sTgtDC = sTempName;
   }

      //store this DC to use later for the actual migration
   targetServer = (WCHAR*)sTgtDC;

      //try to establish the session, which will check all requirements
   hr = pPwdMig->raw_EstablishSession(_bstr_t(server), sTgtDC);
   if (SUCCEEDED(hr)) //if success, return true
      return true;

      //try to get the rich error information
   if (SUCCEEDED(GetErrorInfo(0, &pErrorInfo)))
   {
      HRESULT hrTmp = pErrorInfo->GetDescription(&bstrDescription);
      if (SUCCEEDED(hrTmp)) //if got rich error info, use it
	     sText = _bstr_t(bstrDescription, false);
	  else //else, prepare a standard message and return
	  {
         sTemp.LoadString(IDS_MSG_PWDDC_NOT_READY);
	     msg.Format((LPCTSTR)sTemp, (LPCTSTR)server, (LPCTSTR)server);
	     title.LoadString(IDS_MSG_ERROR);
	     *msgtype = MB_ICONERROR | MB_OK;
		 return false;
	  }
   }
   else //else, prepare a standard message and return
   {
      sTemp.LoadString(IDS_MSG_PWDDC_NOT_READY);
	  msg.Format((LPCTSTR)sTemp, (LPCTSTR)server, (LPCTSTR)server);
	  title.LoadString(IDS_MSG_ERROR);
	  *msgtype = MB_ICONERROR | MB_OK;
	  return false;
   }

      //if not enabled on the src, add special question to error info
   if (hr == PM_E_PASSWORD_MIGRATION_NOT_ENABLED)
   {
      sTemp.LoadString(IDS_MSG_PWDDC_DISABLED);
	  msg = (LPCTSTR)sText;
	  msg += sTemp; //add a question to the end of the error text
	  title.LoadString(IDS_MSG_WARNING);
	  *msgtype = MB_ICONQUESTION | MB_YESNO;
   }
      //else display the error info
   else
   {
	  msg = (LPCTSTR)sText;
	  title.LoadString(IDS_MSG_ERROR);
	  *msgtype = MB_ICONERROR | MB_OK;
   }

   return false;
}
//END IsPasswordDCReady

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 7 FEB 2001                                                  *
 *                                                                   *
 *     This function is a helper function responsible for checking   *
 * the existance of a directory path, and create any needed          *
 * directories for this path. The given path should not include a    *
 * file and should be a full path and not a relative path.           *
 *     The function returns the newly created path.                  *
 *                                                                   *
 *********************************************************************/

//BEGIN CreatePath
CString CreatePath(CString sDirPath)
{
/* local variables */
   int			tosubtract,tosubtract2, final;
   CString		dir;
   CString		root;
   CString		sEmpty = L"";
   int			nStart = 1;

/* function body */
      //remove any trailing '\' or '/'
   tosubtract = sDirPath.ReverseFind(L'\\');
   tosubtract2 = sDirPath.ReverseFind(L'/');
   final = (tosubtract > tosubtract2) ? tosubtract : tosubtract2;
   if (final==-1)
	  return sEmpty;
   if (sDirPath.GetLength() == (final+1))
      dir = sDirPath.Left(final);
   else
	  dir = sDirPath;

      //try to convert a local relative dir path to a full path
   if (dir.GetAt(0) != L'\\')
   {
      CString szPath;
      LPTSTR pszFilePart;
      CString tempPath = dir;
      tempPath += "\\*.*";
      DWORD cchPath = GetFullPathName(tempPath, 2000, szPath.GetBuffer(2000), &pszFilePart);
      szPath.ReleaseBuffer();
      if ((cchPath != 0) && (cchPath <= 2000))
	  {
         final = szPath.ReverseFind(L'\\');
	     dir = szPath.Left(final);
	  }
   }
   else
      nStart = 2;

   if ((dir.Right(1) == L':') && (validDir(dir)))
	  return dir;

      //find the first '\' or '/' past the "C:" or "\\" at the beginning
   tosubtract = dir.Find(L'\\', nStart);
   tosubtract2 = dir.Find(L'/', nStart);
   if ((tosubtract != -1))
   {
      final = tosubtract;
	  if ((tosubtract2 != -1) && (tosubtract2 < final))
	     final = tosubtract2;
   }
   else if ((tosubtract2 != -1))
      final = tosubtract2;
   else
      return sEmpty;

   final++; //move to the next character
   root = dir.Left(final);
   dir = dir.Right(dir.GetLength()-final);

      //create needed directories
   final = dir.FindOneOf(L"\\/");
   while (final!=-1)
   {
      root += dir.Left(final);
      if (!validDir(root))
	  {
	     int create=CreateDirectory(root.GetBuffer(1000),NULL);
		 root.ReleaseBuffer();
		 if (create==0)return sEmpty;
	  }
	  root += L"\\";
	  dir = dir.Right(dir.GetLength()-final-1);
	  final = dir.FindOneOf(L"\\/");
   }
   root += dir;
   if (!validDir(root))
   {
      int create=CreateDirectory(root.GetBuffer(1000),NULL);
	  root.ReleaseBuffer();
	  if (create==0)return sEmpty;
   }
   return root;	
}
//END CreatePath

void GetValidPathPart(CString sFullPath, CString & sDirectory, CString & sFileName)
{
		//remove the file off the path
    int tosubtract = sFullPath.ReverseFind(L'\\');
	int tosubtract2 = sFullPath.ReverseFind(L'/');
	int final = (tosubtract > tosubtract2) ? tosubtract : tosubtract2;
	if (final == -1) 
	{
		sDirectory = L"";
		sFileName = L"";
		return;
	}

	sDirectory = sFullPath;
	sFileName = sFullPath.Right(sFullPath.GetLength()-(final+1)); //save the filename

	while (final != -1)
	{
		   //see if this shorter path exists
		sDirectory = sDirectory.Left(final);
		if (validDir(sDirectory))
			return;

		   //strip off the next directory from the path
		tosubtract = sDirectory.ReverseFind(L'\\');
		tosubtract2 = sDirectory.ReverseFind(L'/');
		final = (tosubtract > tosubtract2) ? tosubtract : tosubtract2;
	}

	sDirectory = L"";
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\callback.cpp ===
#include "stdafx.h"
#include "Callback.h"

#ifndef IADsContainerPtr
_COM_SMARTPTR_TYPEDEF(IADsContainer, IID_IADsContainer);
#endif

extern BOOL GetDomainAndUserFromUPN(WCHAR const * UPNname,CString& domainNetbios, CString& user);

INT_PTR CALLBACK
IntServiceInfoButtonProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			HWND hLC6= GetDlgItem(hwndDlg,IDC_LIST_SERVICE);
			m_serviceBox.Attach(hLC6);

			CString column;
			column.LoadString(IDS_COLUMN_COMPUTER); m_serviceBox.InsertColumn( 1, column,LVCFMT_LEFT,100,1);
			column.LoadString(IDS_COLUMN_SERVICE); m_serviceBox.InsertColumn( 2, column,LVCFMT_LEFT,0,1);
			column.LoadString(IDS_COLUMN_ACCOUNT); m_serviceBox.InsertColumn( 3, column,LVCFMT_LEFT,100,1);
			column.LoadString(IDS_COLUMN_STATUS); m_serviceBox.InsertColumn( 4, column,LVCFMT_LEFT,85,1);
			//new
			column.LoadString(IDS_COLUMN_SERVICE_DISPLAY); m_serviceBox.InsertColumn( 5, column,LVCFMT_LEFT,75,1);
			getService();
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_TOGGLE:
				{
					OnTOGGLE();
					break;
				}
			case IDC_UPDATE:
				{
					OnUPDATE(hwndDlg);
					break;
				}

			default :	
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					sort(m_serviceBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
					break;
				}
	
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{
					activateServiceButtons(hwndDlg);
					break;
				}				
			case PSN_SETACTIVE :
				
			    disable(hwndDlg,IDC_UPDATE);
				disable(hwndDlg,IDC_TOGGLE);
				
				if (migration==w_service && (pdata->refreshing && !alreadyRefreshed))
				{
					refreshDB(hwndDlg);
					alreadyRefreshed = true;
					getService();
				}
			    if (pdata->refreshing) 
				   PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
				else
			       PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);				

				break;
			case PSN_WIZNEXT :
				{
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				CString	computer ,service,account,c;
				CString skip,include;
	            skip.LoadString(IDS_SKIP); include.LoadString(IDS_INCLUDE); 

				for (int i=0;i<m_serviceBox.GetItemCount();i++)
				{
					computer = m_serviceBox.GetItemText(i,0);
					service = m_serviceBox.GetItemText(i,1);
					account = m_serviceBox.GetItemText(i,2);
					c = m_serviceBox.GetItemText(i,3);
					if (c== skip)
					{
						db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account),SvcAcctStatus_DoNotUpdate);
					}
					else if (c==include)
					{
						db->SetServiceAcctEntryStatus(_bstr_t(computer), _bstr_t(service), _bstr_t(account), SvcAcctStatus_NotMigratedYet);
					}
				}
				//find and remove from varset
				break;
				}
			case PSN_WIZBACK :
				if (!pdata->refreshing && migration==w_service)
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_REFRESH);
					return TRUE;
				}
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_RESET :
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_SERVICE_ACCOUNT_INFO );
					break;
				}
				
			default :
				break;		
			}
			break;
		}
	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_SERVICE_ACCOUNT_INFO );
			break;
		}		
		
	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK
IntServiceInfoProc(
				   IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			CheckRadioButton(hwndDlg,IDC_UPDATE,IDC_SKIP,IDC_UPDATE);
			HWND hLC6= GetDlgItem(hwndDlg,IDC_LIST_SERVICE);
			m_serviceBox.Attach(hLC6);

			CString column;
			column.LoadString(IDS_COLUMN_COMPUTER); m_serviceBox.InsertColumn( 1, column,LVCFMT_LEFT,100,1);
			column.LoadString(IDS_COLUMN_SERVICE); m_serviceBox.InsertColumn( 2, column,LVCFMT_LEFT,0,1);
			column.LoadString(IDS_COLUMN_ACCOUNT); m_serviceBox.InsertColumn( 3, column,LVCFMT_LEFT,100,1);
			column.LoadString(IDS_COLUMN_STATUS); m_serviceBox.InsertColumn( 4, column,LVCFMT_LEFT,85,1);
			//new
			column.LoadString(IDS_COLUMN_SERVICE_DISPLAY); m_serviceBox.InsertColumn( 5, column,LVCFMT_LEFT,75,1);

			getService();
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_TOGGLE:
				{
					OnTOGGLE();
					break;
				}
			case IDC_SKIP:
				{
					disable(hwndDlg,IDC_TOGGLE);
					disable(hwndDlg,IDC_LIST_SERVICE);					
					break;
				}
			case IDC_UPDATE:
				{
					enable(hwndDlg,IDC_LIST_SERVICE);					
					break;
				}
			default :
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{

			case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					sort(m_serviceBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
				break;
				}
	
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{

					activateServiceButtons2(hwndDlg);
					break;
				}				

			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				disable(hwndDlg,IDC_TOGGLE);

				if (pdata->refreshing && !alreadyRefreshed)
				{
					put(DCTVS_Options_Wizard, L"service");
					refreshDB(hwndDlg);
					put(DCTVS_Options_Wizard, L"user");
					alreadyRefreshed = true;
				}
				getService();
	
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					if(IsDlgButtonChecked(hwndDlg,IDC_SKIP))
					{
						setDBStatusSkip();
					}
					else if(IsDlgButtonChecked(hwndDlg,IDC_UPDATE))
					{
						if (setDBStatusInclude(hwndDlg))
						{
							CString message,title;
							message.LoadString(IDS_MSG_LOCAL);title.LoadString(IDS_MSG_WARNING);
							MessageBox(hwndDlg,message,title,MB_OK|MB_ICONINFORMATION);
						}
					}					
	
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_RESET :
				break;		
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_SERVICE_ACCOUNT_INFO );
					break;
				}
			default :
				break;		
			}
			break;
		}
			case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_SERVICE_ACCOUNT_INFO );
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK
IntServiceRefreshProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			
			IUnknown * pUnk;
			pVarSetService->QueryInterface(IID_IUnknown, (void**) &pUnk);
			db->GetServiceAccount(L"",&pUnk);
			pUnk->Release();
			
			_bstr_t text;
			text = pVarSetService->get(L"ServiceAccountEntries");
			int numItems=_ttoi((WCHAR const *)text);
			if (numItems==0 )
			{
				CheckRadioButton(hwndDlg,IDC_REFRESH,IDC_NO_REFRESH,IDC_REFRESH) ;
				disable(hwndDlg,IDC_NO_REFRESH);
			}
			else
				CheckRadioButton(hwndDlg,IDC_REFRESH,IDC_NO_REFRESH,IDC_NO_REFRESH);
			
			
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				
				if (IsDlgButtonChecked(hwndDlg,IDC_REFRESH) )
				{
					pdata->refreshing = true;
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION1);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION1);
					return TRUE;
				}
				else
				{
					pdata->refreshing = false;
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SA_INFO_BUTTON);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO_BUTTON);
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					return TRUE;
				}	
				
				break;
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_REFRESH_INFO);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}
			case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_REFRESH_INFO);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

//this function is no longer used
INT_PTR CALLBACK 
IntOptionsFromUserProc(
    IN HWND     hwndDlg,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{
	CString editHeader;
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);

		    CString toformat;
			toformat.LoadString(IDS_30);
			calculateDate(hwndDlg,toformat);
			SetDlgItemText(hwndDlg,IDC_yo,toformat);
			disable(hwndDlg,IDC_yo);
			disable(hwndDlg,IDC_DATE);
			disable(hwndDlg,IDC_TEXT);

			initcheckbox( hwndDlg,IDC_TRANSLATE_ROAMING_PROFILES,DCTVS_AccountOptions_TranslateRoamingProfiles);
		
//			initdisablebox(hwndDlg,IDC_DISABLE_SOURCE_ACCOUNTS,IDC_DISABLE_COPIED_ACCOUNTS,IDC_DISABLE_NEITHER_ACCOUNT,
//				L"AccountOptions.DisableSourceAccounts",L"AccountOptions.DisableCopiedAccounts");		

			if (IsDlgButtonChecked(hwndDlg,IDC_DISABLE_SOURCE_ACCOUNTS))
			{
			   disable(hwndDlg,IDC_SET_EXPIRATION);
			   disable(hwndDlg,IDC_yo);
			}
			else
			{
			   enable(hwndDlg,IDC_SET_EXPIRATION);
			   if (IsDlgButtonChecked(hwndDlg,IDC_SET_EXPIRATION))
			      enable(hwndDlg,IDC_yo);
			}

			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_SET_EXPIRATION :
				{
			        if (IsDlgButtonChecked(hwndDlg,IDC_SET_EXPIRATION))
					{     
						enable(hwndDlg,IDC_yo);
						enable(hwndDlg,IDC_DATE);
						enable(hwndDlg,IDC_TEXT);
				}
					else
					{
						disable(hwndDlg,IDC_yo);
						disable(hwndDlg,IDC_DATE);
						disable(hwndDlg,IDC_TEXT);
					}
					break;
				}
			case IDC_DISABLE_SOURCE_ACCOUNTS :
				{
					disable(hwndDlg,IDC_SET_EXPIRATION);
					disable(hwndDlg,IDC_yo);
					break;
				}
			case IDC_DISABLE_COPIED_ACCOUNTS :
				{
					enable(hwndDlg,IDC_SET_EXPIRATION);
					if (IsDlgButtonChecked(hwndDlg,IDC_SET_EXPIRATION))
					   enable(hwndDlg,IDC_yo);
					break;
				}
			case IDC_DISABLE_NEITHER_ACCOUNT :
				{
					enable(hwndDlg,IDC_SET_EXPIRATION);
					if (IsDlgButtonChecked(hwndDlg,IDC_SET_EXPIRATION))
					   enable(hwndDlg,IDC_yo);
					break;
				}
			default :
				break;
			}
			
			switch(HIWORD (wParam)){
			case EN_SETFOCUS :
			    bChangeOnFly=true;
				break;
			case EN_KILLFOCUS :
			    bChangeOnFly=false;
				break;
			case EN_CHANGE:	
				{
					if ((!bChangeOnFly) || (LOWORD(wParam) != IDC_yo))
						break;
					CString s;
					GetDlgItemText(hwndDlg,IDC_yo,s.GetBuffer(1000),1000);
					s.ReleaseBuffer();
					   //make sure all chars are digits
					bool bInvalid = false;
					int ndx=0;
					while ((ndx < s.GetLength()) && (!bInvalid))
					{
						if (!iswdigit(s[ndx]))
						   bInvalid = true;
						ndx++;
					}
					if (bInvalid)
					{
						  //for invalid days, blank out the date
					   SetDlgItemText(hwndDlg,IDC_DATE,L"");
					}
					else //else continue checking for validity
					{
					   long ndays = _wtol(s);
					   if (((ndays <= THREE_YEARS) && (ndays >= 1)) ||
						   (!UStrICmp(s,L"0")))
					      calculateDate(hwndDlg,s);
					   else
					   {
						     //for invalid days, blank out the date
					      SetDlgItemText(hwndDlg,IDC_DATE,L"");
					   }
					}
					break;
				}
			default :
				break;
			}

			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					
					checkbox( hwndDlg,IDC_DISABLE_SOURCE_ACCOUNTS,DCTVS_AccountOptions_DisableSourceAccounts);
					checkbox( hwndDlg,IDC_DISABLE_COPIED_ACCOUNTS,DCTVS_AccountOptions_DisableCopiedAccounts);
					_variant_t varX;
					if ((IsWindowEnabled(GetDlgItem(hwndDlg, IDC_SET_EXPIRATION))) && 
						(IsDlgButtonChecked( hwndDlg,IDC_SET_EXPIRATION)))
					{
						time_t t;
						if (timeInABox(hwndDlg,t))
						{
							varX =t;
							put(DCTVS_AccountOptions_ExpireSourceAccounts,varX);
						}
						else 
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_TIME,IDS_MSG_ERROR);
//							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DISABLE);
						    SetFocus(GetDlgItem(hwndDlg, IDC_yo));
						    SendDlgItemMessage(hwndDlg, IDC_yo, EM_SETSEL, 
											  (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						    return TRUE;
						}
					}
					else
					{
						varX = L"";
						put(DCTVS_AccountOptions_ExpireSourceAccounts,varX);
					}
					
					checkbox( hwndDlg,IDC_TRANSLATE_ROAMING_PROFILES,DCTVS_AccountOptions_TranslateRoamingProfiles);
					
					if (someServiceAccounts(pdata->accounts,hwndDlg))
					{
						pdata->someService=true;
//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SA_INFO);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO);
						return TRUE;
					}
					else
					{
						pdata->someService=false;
//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_END_GROUP);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_GROUP);
						return TRUE;
					}
					
					
					break;
				}
			case PSN_WIZBACK :
				break;							
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_GROUP_MEMBER_OPTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_GROUP_MEMBER_OPTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK
IntOptionsProc(
			   IN HWND hwndDlg,
			   IN UINT uMsg,
			   IN WPARAM wParam,
			   IN LPARAM lParam
			   ){
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initnoncollisionrename(hwndDlg);
			initcheckbox( hwndDlg,IDC_TRANSLATE_ROAMING_PROFILES,DCTVS_AccountOptions_TranslateRoamingProfiles);
			initcheckbox( hwndDlg,IDC_UPDATE_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
			initcheckbox( hwndDlg,IDC_MIGRATE_GROUPS_OF_USERS,DCTVS_AccountOptions_CopyMemberOf);
			initcheckbox( hwndDlg,IDC_REMIGRATE_OBJECTS,DCTVS_AccountOptions_IncludeMigratedAccts);
			initcheckbox( hwndDlg,IDC_FIX_MEMBERSHIP,DCTVS_AccountOptions_FixMembership);
			if (IsDlgButtonChecked(hwndDlg,IDC_MIGRATE_GROUPS_OF_USERS))
			{
				pdata->memberSwitch=true;
				enable(hwndDlg,IDC_REMIGRATE_OBJECTS);
//				CheckDlgButton(hwndDlg,IDC_FIX_MEMBERSHIP,true);
			}
			else
				disable(hwndDlg,IDC_REMIGRATE_OBJECTS);

			if (pdata->sameForest)
			{
				CheckDlgButton(hwndDlg,IDC_FIX_MEMBERSHIP,true);
				disable(hwndDlg,IDC_FIX_MEMBERSHIP);
			}

			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_MIGRATE_GROUPS_OF_USERS:
				{
					pdata->memberSwitch=(!pdata->memberSwitch);
					pdata->memberSwitch ? enable(hwndDlg,IDC_REMIGRATE_OBJECTS):disable(hwndDlg,IDC_REMIGRATE_OBJECTS);
//					CheckDlgButton(hwndDlg,IDC_FIX_MEMBERSHIP,true);
					bChangedMigrationTypes=true;
					break;
				}
			case IDC_RADIO_NONE :
				{
					disable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_PRE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_SUF,false);
					break;
				}	
			case IDC_RADIO_PRE :
				{
					enable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_SUF,false);
				    SetFocus(GetDlgItem(hwndDlg, IDC_PRE));
					SendDlgItemMessage(hwndDlg, IDC_PRE, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			case IDC_RADIO_SUF :
				{
					disable(hwndDlg,IDC_PRE);
					enable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_PRE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					SetFocus(GetDlgItem(hwndDlg, IDC_SUF));
					SendDlgItemMessage(hwndDlg, IDC_SUF, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			default :
				break;
			}
			break;
		}

	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
			{
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				checkbox( hwndDlg,IDC_TRANSLATE_ROAMING_PROFILES,DCTVS_AccountOptions_TranslateRoamingProfiles);
				checkbox( hwndDlg,IDC_UPDATE_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
				checkbox( hwndDlg,IDC_MIGRATE_GROUPS_OF_USERS,DCTVS_AccountOptions_CopyMemberOf);
				checkbox( hwndDlg,IDC_MIGRATE_GROUPS_OF_USERS,DCTVS_AccountOptions_CopyLocalGroups);		
				checkbox( hwndDlg,IDC_FIX_MEMBERSHIP,DCTVS_AccountOptions_FixMembership);

				if (IsDlgButtonChecked(hwndDlg,IDC_MIGRATE_GROUPS_OF_USERS))
					checkbox( hwndDlg,IDC_REMIGRATE_OBJECTS,DCTVS_AccountOptions_IncludeMigratedAccts);
				else if (pdata->sameForest)
				{
					CString yo;
					yo.LoadString(IDS_GRATUITIOUS_MESSAGE);
					CString warning;
					warning.LoadString(IDS_MSG_WARNING);
					MessageBox(hwndDlg,yo,warning,MB_OK| MB_ICONINFORMATION);
				} 	
			
				if ( !noncollisionrename(hwndDlg))
				{
					int nID = IDC_PRE;
					MessageBoxWrapperFormat1(hwndDlg,IDS_MSG_INVALIDCHARS,IDS_INVALID_STRING,IDS_MSG_INPUT);
//					SetWindowLong(hwndDlg,DWL_MSGRESULT,IDD_OPTIONS);
					   //set focus on invalid string
	                if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_SUF))
					   nID = IDC_SUF;
					SetFocus(GetDlgItem(hwndDlg, nID));
					SendDlgItemMessage(hwndDlg, nID, EM_SETSEL, 
									  (WPARAM)0, (LPARAM)-1); 
				    SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
					return TRUE;
				}
					
			    if ((pdata->sourceIsNT4))
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_RENAMING);
					return TRUE;
				}
				if (pdata->sameForest && migration==w_account)
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENAMING);
					return TRUE;
				}
				break;
			}
			case PSN_WIZBACK :
				if (pdata->sameForest && migration==w_account)
				{
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
					return TRUE;
				}
				else
				{
					
					if (pdata->IsSidHistoryChecked)
					{								
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						return TRUE;
					}
					else
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DISABLE);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DISABLE);
						return TRUE;
					}
				}
				break;							
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_USER_OPTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_USER_OPTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK
IntOptionsReportingProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			HWND hLC7= GetDlgItem(hwndDlg,IDC_LIST_REPORTING);
			m_reportingBox.Attach(hLC7);
			CString column;
			column.LoadString(IDS_COLUMN_REPORT); m_reportingBox.InsertColumn( 1, column,LVCFMT_LEFT,150,1);
			column.LoadString(IDS_COLUMN_LASTGENERATEDON); m_reportingBox.InsertColumn( 2,column,LVCFMT_LEFT,280,1);
			getReporting();
			break;
		}	

		case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
//			(m_reportingBox.GetFirstSelectedItemPosition())? 
			(m_reportingBox.GetNextItem(-1, LVNI_SELECTED) != -1)? 
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT):
			    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);				
				break;
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK :
				{
//					(m_reportingBox.GetFirstSelectedItemPosition())? 
					(m_reportingBox.GetNextItem(-1, LVNI_SELECTED) != -1)? 
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT):
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
					break;
				}
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					putReporting();
					_bstr_t text= get(DCTVS_Reports_AccountReferences);
					if (!UStrICmp(text ,(WCHAR const *) yes))
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION1);
						return TRUE;
					}
					else
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_END_REPORTING);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_REPORTING);
						return TRUE;
					}				
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_REPORT_SELECTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_REPORT_SELECTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK
IntRetryProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			CWaitCursor w;
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			HWND hLC= GetDlgItem(hwndDlg,IDC_LIST_RETRY);
			m_cancelBox.Attach(hLC);
			
			CString column;
			column.LoadString(IDS_COLUMN_SERVER); m_cancelBox.InsertColumn( 1, column,LVCFMT_LEFT,90,1);
			column.LoadString(IDS_COLUMN_JOBFILE); m_cancelBox.InsertColumn( 2, column,LVCFMT_LEFT,0,1);
			column.LoadString(IDS_COLUMN_STATUS); m_cancelBox.InsertColumn( 3, column,LVCFMT_LEFT,140,1);
			column.LoadString(IDS_COLUMN_ACTION); m_cancelBox.InsertColumn( 4, column,LVCFMT_LEFT,115,1);
			column.LoadString(IDS_COLUMN_ACTIONID); m_cancelBox.InsertColumn( 5, column,LVCFMT_LEFT,0,1);
			column.LoadString(IDS_COLUMN_SKIPINCLUDE); m_cancelBox.InsertColumn( 6, column,LVCFMT_LEFT,80,1);
			getFailed(hwndDlg);
			disable(hwndDlg,IDC_CANCEL);
			disable(hwndDlg,IDC_TOGGLE);
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_CANCEL :
				{
					CWaitCursor w;
					CString toggleWarning,title;
					title.LoadString(IDS_MSG_WARNING);
					toggleWarning.LoadString(IDS_MSG_PERMANENT_REMOVE);
					if (MessageBox(hwndDlg,toggleWarning,title,MB_OKCANCEL|MB_ICONEXCLAMATION)==IDOK)
					{
						handleCancel(hwndDlg);
						if (m_cancelBox.GetItemCount()==0) 	PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
					}
					
					!SomethingToRetry() ? 
						PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK ):
					PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
					break;
				}
			case IDC_TOGGLE :
				{
					OnRetryToggle();
					!SomethingToRetry() ? 
						PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK ):
					PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
					break;
				}
			default :
				break;
			}
			activateCancelIfNecessary(hwndDlg);
			break;
		}
		
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
						case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					//sort(m_cancelBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
				break;
				}
	
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{
					activateCancelIfNecessary(hwndDlg);
					break;
				}				
				
			case PSN_SETACTIVE :
				!SomethingToRetry() ? 
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK):
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				if (!SomethingToRetry())
				{
					MessageBoxWrapper(hwndDlg,IDS_MSG_CANCEL,IDS_MSG_ERROR);
//					SetWindowLong(hwndDlg,DWL_MSGRESULT,IDD_RETRY);
					SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_RETRY);
					return TRUE;
				}
				else
					OnRETRY();
						
				break;
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_TASK_SELECTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_TASK_SELECTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK
IntPasswordProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
	CString editHeader;
	bool bPopulated = true;
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initpasswordbox(hwndDlg,IDC_GENERATE_STRONG_PASSWORDS,IDC_GENERATE_STRONG_PASSWORDS_NOT, IDC_MIG_PASSWORDS,
							L"AccountOptions.GenerateStrongPasswords", L"AccountOptions.CopyPasswords");
            bPopulated = populatePasswordDCs(hwndDlg, IDC_PASSWORD_DC, pdata->sourceIsNT4);
			
		    if (IsDlgButtonChecked(hwndDlg,IDC_MIG_PASSWORDS))
			{
			   disable(hwndDlg,IDC_BROWSE);
			   switchboxes(hwndDlg, IDC_PASSWORD_FILE, IDC_PASSWORD_DC);
			   editHeader.LoadString(IDS_PASSWORD_DC_HDR);
			   SetDlgItemText(hwndDlg,IDC_PASSWORD_EDIT,editHeader);
			   
			   if (!bPopulated)
				  addStringToComboBox(hwndDlg,IDC_PASSWORD_DC,sourceDC);
			   initDCcombobox( hwndDlg,IDC_PASSWORD_DC,DCTVS_AccountOptions_PasswordDC);
			}
			else
			{
			   enable(hwndDlg,IDC_BROWSE);
			   switchboxes(hwndDlg, IDC_PASSWORD_DC, IDC_PASSWORD_FILE);
			   editHeader.LoadString(IDS_PASSWORD_FILE_HDR);
			   SetDlgItemText(hwndDlg,IDC_PASSWORD_EDIT,editHeader);
			   initeditbox( hwndDlg,IDC_PASSWORD_FILE,DCTVS_AccountOptions_PasswordFile);
			
			   if (IsDlgItemEmpty(hwndDlg,IDC_PASSWORD_FILE))
			   {
				  CString toinsert;
				  GetDirectory(toinsert.GetBuffer(1000));
				  toinsert.ReleaseBuffer();
				  toinsert+="Logs\\passwords.txt";
				  SetDlgItemText(hwndDlg,IDC_PASSWORD_FILE,toinsert);
			   }
			}
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{			
			case IDC_BROWSE :
				OnFileBrowse(hwndDlg,IDC_PASSWORD_FILE);
				break;
			case IDC_MIG_PASSWORDS :
			    disable(hwndDlg,IDC_BROWSE);
			    switchboxes(hwndDlg, IDC_PASSWORD_FILE, IDC_PASSWORD_DC);
			    editHeader.LoadString(IDS_PASSWORD_DC_HDR);
			    SetDlgItemText(hwndDlg,IDC_PASSWORD_EDIT,editHeader);
			   
			    if (!populatePasswordDCs(hwndDlg, IDC_PASSWORD_DC, pdata->sourceIsNT4))
				   addStringToComboBox(hwndDlg,IDC_PASSWORD_DC,sourceDC);
			    initDCcombobox( hwndDlg,IDC_PASSWORD_DC,DCTVS_AccountOptions_PasswordDC);
				break;
			case IDC_GENERATE_STRONG_PASSWORDS :
			case IDC_GENERATE_STRONG_PASSWORDS_NOT :
			    enable(hwndDlg,IDC_BROWSE);
			    switchboxes(hwndDlg, IDC_PASSWORD_DC, IDC_PASSWORD_FILE);
			    editHeader.LoadString(IDS_PASSWORD_FILE_HDR);
			    SetDlgItemText(hwndDlg,IDC_PASSWORD_EDIT,editHeader);
			    initeditbox( hwndDlg,IDC_PASSWORD_FILE,DCTVS_AccountOptions_PasswordFile);
			
			    if (IsDlgItemEmpty(hwndDlg,IDC_PASSWORD_FILE))
				{
				   CString toinsert;
				   GetDirectory(toinsert.GetBuffer(1000));
				   toinsert.ReleaseBuffer();
				   toinsert+="Logs\\passwords.txt";
				   SetDlgItemText(hwndDlg,IDC_PASSWORD_FILE,toinsert);
				}
			    break;
			default:
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
                bPopulated = populatePasswordDCs(hwndDlg, IDC_PASSWORD_DC, pdata->sourceIsNT4);
			    initDCcombobox( hwndDlg,IDC_PASSWORD_DC,DCTVS_AccountOptions_PasswordDC);
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
					BOOL bMigPwd = FALSE;
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					checkbox( hwndDlg,IDC_GENERATE_STRONG_PASSWORDS,DCTVS_AccountOptions_GenerateStrongPasswords);
					checkbox( hwndDlg,IDC_MIG_PASSWORDS,DCTVS_AccountOptions_CopyPasswords);
					if (IsDlgButtonChecked(hwndDlg,IDC_MIG_PASSWORDS))
					{
						_variant_t varX = yes;
						pVarSet->put(GET_BSTR(DCTVS_AccountOptions_GenerateStrongPasswords), varX);
						bMigPwd = TRUE;
					}

					if ((!bMigPwd) && (!checkFile(hwndDlg)))
					{	
						MessageBoxWrapper(hwndDlg,IDS_MSG_FILE,IDS_MSG_INPUT);
//						SetWindowLong(hwndDlg,DWL_MSGRESULT,IDD_PASSWORD);
						SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_PASSWORD);
						return TRUE;
					}

					if (IsDlgButtonChecked(hwndDlg,IDC_MIG_PASSWORDS))
					    editbox( hwndDlg,IDC_PASSWORD_DC,DCTVS_AccountOptions_PasswordDC);					
					else
					    editbox( hwndDlg,IDC_PASSWORD_FILE,DCTVS_AccountOptions_PasswordFile);
					
					   //check to see if the password DC has the DLL installed and ready
					if (bMigPwd)
					{
					   CString msg, title;
					   UINT msgtype;
					   _bstr_t sTemp;
					   sTemp = _bstr_t(get(DCTVS_AccountOptions_PasswordDC));
					   CString srcSvr = (WCHAR*)sTemp;
					   if (!IsPasswordDCReady(srcSvr, msg, title, &msgtype))
					   {
						   if (MessageBox(hwndDlg, msg, title, msgtype) != IDNO)
						   {
						      SetFocus(GetDlgItem(hwndDlg, IDC_PASSWORD_DC));
						      SendDlgItemMessage(hwndDlg, IDC_PASSWORD_DC, EM_SETSEL, 
											     (WPARAM)0, (LPARAM)-1); 
				              SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						      return TRUE;
						   }
					   }
					   else  //else, store this tgtDC used in this check for use during the migration
						  pVarSet->put(GET_BSTR(DCTVS_Options_TargetServerOverride), _bstr_t(targetServer));
					}

					if (IsDlgButtonChecked(hwndDlg,IDC_GENERATE_STRONG_PASSWORDS_NOT))
					{
						ShowWarning(hwndDlg);
					}
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_PASSWORD_OPTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_PASSWORD_OPTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK
IntTargetGroupProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_BROWSE:
				{
					HRESULT hr = pDsObjectPicker2->InvokeDialog(hwndDlg, &pdo2);
					if (FAILED(hr)) return 0;	 
					if (hr == S_OK) {
						ProcessSelectedObjects2(pdo2,hwndDlg);
						pdo2->Release();
					}
					break;
				}
			default :
				break;
			}
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				enableNextIfNecessary(hwndDlg,IDC_TARGET_GROUP);
				break;
			default: 
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				enableNextIfNecessary(hwndDlg,IDC_TARGET_GROUP);
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					_bstr_t text = get(DCTVS_Accounts_NumItems);
					int count = _ttoi((WCHAR * const) text);
					CString base=L"",toadd;
					_variant_t varX;
					for (int i = 0;i<count;i++)
					{
						base.Format(L"Accounts.%ld.TargetName",i);
						GetDlgItemText(hwndDlg,IDC_TARGET_GROUP,toadd.GetBuffer(1000),1000);
						toadd.ReleaseBuffer();
						varX = toadd;
						pVarSet->put(_bstr_t(base),varX);
					}
					break;
					}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_TARGET_GROUP_SELECTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_TARGET_GROUP_SELECTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK
IntTrustProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{CWaitCursor w;
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			HWND hLC= GetDlgItem(hwndDlg,IDC_LIST_SERVICE);
			m_trustBox.Attach(hLC);
			CString column;
			column.LoadString(IDS_COLUMN_DOMAIN); m_trustBox.InsertColumn( 1, column,LVCFMT_LEFT,155,1);
			column.LoadString(IDS_COLUMN_DIRECTION); m_trustBox.InsertColumn( 2, column,LVCFMT_LEFT,80,1);
			column.LoadString(IDS_COLUMN_ATTRIBUTES); m_trustBox.InsertColumn( 3, column,LVCFMT_LEFT,80,1);
			column.LoadString(IDS_COLUMN_EXISTSFORTARGET); m_trustBox.InsertColumn( 4, column,LVCFMT_LEFT,90,1);
			disable(hwndDlg,IDC_MIGRATE);
			
			if (pdata->newSource)
			{
				m_trustBox.DeleteAllItems();
				getTrust();
				pdata->newSource=false;
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
			}
        break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_MIGRATE:
				{
					bool atleast1succeeded=false;
					HRESULT hr = MigrateTrusts(hwndDlg,atleast1succeeded);
					if (SUCCEEDED(hr))
					{
						if (atleast1succeeded)
						{
							PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
							pdata->proceed= true;
						}
					}
					else
					{
						ErrorWrapper(hwndDlg,hr);
					}


					  activateTrustButton(hwndDlg);

					
					break;
				}
			default :
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
						case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					//sort(m_trustBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
				break;
				}
	

			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{
					activateTrustButton(hwndDlg);
					break;
				}				

			case PSN_SETACTIVE :				
				if (pdata->newSource)
				{
					m_trustBox.DeleteAllItems();
					getTrust();
					pdata->newSource=false;
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				}
				
				pdata->proceed ? 
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT):
				PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				if (!pdata->proceed)
				{
					MessageBoxWrapper(hwndDlg,IDS_MSG_SELECT_TRUST,IDS_MSG_INPUT);
//					SetWindowLong(hwndDlg,DWL_MSGRESULT,IDD_TRUST_INFO);
					SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_TRUST_INFO);
					return TRUE;
				}		
				break;
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_TRUST_INFO);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_TRUST_INFO);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK
IntRebootProc(
			  IN HWND hwndDlg,
			  IN UINT uMsg,
			  IN WPARAM wParam,
			  IN LPARAM lParam
			  )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initnoncollisionrename(hwndDlg);
			addrebootValues(hwndDlg);
			initeditbox(hwndDlg,IDC_COMBO2,DCTVS_Options_GuiOnlyRebootSaver);
			if (IsDlgItemEmpty(hwndDlg,IDC_COMBO2))
			{
				CString s;
		
				s.LoadString(IDS_FIVE);
				SetDlgItemText(hwndDlg,IDC_COMBO2,s);
			}
			break;
		}
		
	case WM_COMMAND :
		{
			switch(LOWORD(wParam))
			{
			case IDC_RADIO_NONE :
				{
					disable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_PRE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_SUF,false);
					break;
				}	
			case IDC_RADIO_PRE :
				{
					enable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_SUF,false);
				    SetFocus(GetDlgItem(hwndDlg, IDC_PRE));
					SendDlgItemMessage(hwndDlg, IDC_PRE, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			case IDC_RADIO_SUF :
				{
					disable(hwndDlg,IDC_PRE);
					enable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_PRE,false);
				    SetFocus(GetDlgItem(hwndDlg, IDC_SUF));
					SendDlgItemMessage(hwndDlg, IDC_SUF, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			default:
				{
					break;
				}
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				enableNextIfNecessary(hwndDlg,IDC_COMBO2);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				if (validReboot(hwndDlg,IDC_COMBO2))
				{
					editbox(hwndDlg,IDC_COMBO2,DCTVS_Options_GuiOnlyRebootSaver);
					pdata->rebootDelay=rebootbox( hwndDlg,IDC_COMBO2);
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				}
				else
				{
					MessageBoxWrapper(hwndDlg,IDS_MSG_REBOOT,IDS_MSG_INPUT);
//					SetWindowLong(hwndDlg,DWL_MSGRESULT,IDD_REBOOT);
					SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_REBOOT);
					return TRUE;
				}
				if ( !noncollisionrename(hwndDlg))
				{
					int nID = IDC_PRE;
					MessageBoxWrapperFormat1(hwndDlg,IDS_MSG_INVALIDCHARS,IDS_INVALID_STRING,IDS_MSG_INPUT);
					   //set focus on invalid string
	                if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_SUF))
					   nID = IDC_SUF;
					SetFocus(GetDlgItem(hwndDlg, nID));
					SendDlgItemMessage(hwndDlg, nID, EM_SETSEL, 
									  (WPARAM)0, (LPARAM)-1); 
				    SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
					return TRUE;
//					SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_REBOOT);
				}

				if (pdata->sourceIsNT4)
				{
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENAMING);
					return TRUE;
				}
				break;
			case PSN_WIZBACK :
				{
					if (migration==w_computer)
					{
						if (!pdata->translateObjects)
						{
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION);
							return TRUE;
						}
						else
						{					
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION_MODE);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION_MODE);
							return TRUE;
						}
					}
				}
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_COMPUTER_OPTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_COMPUTER_OPTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}
INT_PTR CALLBACK
IntTranslationProc(
				   IN HWND hwndDlg,
				   IN UINT uMsg,
				   IN WPARAM wParam,
				   IN LPARAM lParam
				   )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initcheckbox( hwndDlg,IDC_FILES,DCTVS_Security_TranslateFiles);
			initcheckbox( hwndDlg,IDC_SHARES,DCTVS_Security_TranslateShares);
			initcheckbox( hwndDlg,IDC_PRINTERS,DCTVS_Security_TranslatePrinters);
			initcheckbox( hwndDlg,IDC_USER_RIGHTS,DCTVS_Security_TranslateUserRights);
			initcheckbox( hwndDlg,IDC_LOCAL_GROUPS,DCTVS_Security_TranslateLocalGroups);
			initcheckbox( hwndDlg,IDC_USER_PROFILES,DCTVS_Security_TranslateUserProfiles);
			initcheckbox( hwndDlg,IDC_REGISTRY,DCTVS_Security_TranslateRegistry);
			if ((IsDlgButtonChecked(hwndDlg,IDC_FILES)) ||
			    (IsDlgButtonChecked(hwndDlg,IDC_SHARES)) ||
			    (IsDlgButtonChecked(hwndDlg,IDC_PRINTERS)) ||
			    (IsDlgButtonChecked(hwndDlg,IDC_USER_RIGHTS)) ||
 			    (IsDlgButtonChecked(hwndDlg,IDC_LOCAL_GROUPS)) ||
			    (IsDlgButtonChecked(hwndDlg,IDC_USER_PROFILES)) ||
			    (IsDlgButtonChecked(hwndDlg,IDC_REGISTRY)) ||
				(migration==w_computer))
			{
			   PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
			}
			else
			   PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);

			break;
		}
	case WM_COMMAND:
		{
			bool bCheck = false;
			switch(LOWORD (wParam))
			{
			case IDC_FILES :
				bCheck = true;
				break;
			case IDC_SHARES :		
				bCheck = true;
				break;
			case IDC_PRINTERS :
				bCheck = true;
				break;
			case IDC_USER_RIGHTS :
				bCheck = true;
				break;
			case IDC_LOCAL_GROUPS :
				bCheck = true;
				break;
			case IDC_USER_PROFILES :
				bCheck = true;
				break;
			case IDC_REGISTRY :
				bCheck = true;
				break;
			default:
				break;
			}

			if (bCheck)
			{
			    if ((IsDlgButtonChecked(hwndDlg,IDC_FILES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_SHARES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_PRINTERS)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_USER_RIGHTS)) ||
 			       (IsDlgButtonChecked(hwndDlg,IDC_LOCAL_GROUPS)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_USER_PROFILES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_REGISTRY)) ||
				   (migration==w_computer))
				{
			       PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				}
			    else
			       PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
			    if ((IsDlgButtonChecked(hwndDlg,IDC_FILES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_SHARES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_PRINTERS)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_USER_RIGHTS)) ||
 			       (IsDlgButtonChecked(hwndDlg,IDC_LOCAL_GROUPS)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_USER_PROFILES)) ||
			       (IsDlgButtonChecked(hwndDlg,IDC_REGISTRY)) ||
				   (migration==w_computer))
				{
			       PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				}
			    else
			       PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
			    break;
			case PSN_WIZNEXT :
				checkbox( hwndDlg,IDC_FILES,DCTVS_Security_TranslateFiles);
				checkbox( hwndDlg,IDC_SHARES,DCTVS_Security_TranslateShares);
				checkbox( hwndDlg,IDC_PRINTERS,DCTVS_Security_TranslatePrinters);
				checkbox( hwndDlg,IDC_USER_RIGHTS,DCTVS_Security_TranslateUserRights);
				checkbox( hwndDlg,IDC_LOCAL_GROUPS,DCTVS_Security_TranslateLocalGroups);
				checkbox( hwndDlg,IDC_USER_PROFILES,DCTVS_Security_TranslateUserProfiles);
				checkbox( hwndDlg,IDC_REGISTRY,DCTVS_Security_TranslateRegistry);
				if (IsDlgButtonChecked(hwndDlg,IDC_FILES) ||
					(IsDlgButtonChecked(hwndDlg,IDC_SHARES) ||
					(IsDlgButtonChecked(hwndDlg,IDC_PRINTERS) ||
					(IsDlgButtonChecked(hwndDlg,IDC_USER_RIGHTS) ||
 					(IsDlgButtonChecked(hwndDlg,IDC_LOCAL_GROUPS) ||
					(IsDlgButtonChecked(hwndDlg,IDC_USER_PROFILES) ||
					(IsDlgButtonChecked(hwndDlg,IDC_REGISTRY))))))))
				{
					
					if (IsDlgButtonChecked(hwndDlg,IDC_USER_PROFILES))
					{
						_variant_t varX = L"{0EB9FBE9-397D-4D09-A65E-ABF1790CC470}";
						pVarSet->put(L"PlugIn.0",varX);
					}
					pdata->translateObjects=true;

//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION_MODE);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION_MODE);
					return TRUE;
				}
				else
				{
					pdata->translateObjects=false;
				    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_REBOOT);
				    return TRUE;
				}
					
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				break;
			case PSN_WIZBACK :
			
	break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_OBJECTTYPE_SELECTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_OBJECTTYPE_SELECTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK
IntUndoProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
	IPerformMigrationTaskPtr      w;  

	HRESULT hr = w.CreateInstance(CLSID_Migrator);
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			CString s;
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			BSTR desc = NULL;
			w->GetTaskDescription(IUnknownPtr(pVarSetUndo), &desc);
			s = desc;
			SysFreeString(desc);
			SetDlgItemText(hwndDlg, IDC_UNDO_TASK,s);
			break;
		}
	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_UNDO);
			break;
		}	
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				{
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);

				break;
				}
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					//set up the undo task
					IUnknownPtr pUnk;
					w->GetUndoTask(IUnknownPtr(pVarSetUndo), &pUnk);
					if (pVarSet)
					{
						pVarSet->Release();
						pVarSet = NULL;
					}
					pUnk->QueryInterface(IID_IVarSet,(void**)&pVarSet);
					
					put(DCTVS_Options_AppendToLogs,yes);
					_bstr_t s1=get(DCTVS_Options_SourceDomainDns);
					_bstr_t t1=get(DCTVS_Options_TargetDomainDns);
					
					CString s= (WCHAR const*) s1;
					CString t= (WCHAR const*) t1;
					HRESULT hr=S_OK;
		
					_bstr_t text=get(DCTVS_Options_Wizard);
			
					pdata->sameForest=CheckSameForest(t,s,hr);
					if (!SUCCEEDED(hr))
					{
							ErrorWrapper4(hwndDlg,hr,s);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_UNDO);						
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_UNDO);						
							return TRUE;
					}
					else
					{
						if (pdata->sameForest)
						{
							CString yo,title;
							yo.LoadString(IDS_MSG_MESSAGE8);title.LoadString(IDS_MSG_WARNING);
							MessageBox(hwndDlg,yo,title,MB_OK|MB_ICONINFORMATION);						
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS);						
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);						
							return TRUE;
						}
//*						else if (!UStrICmp(text,(WCHAR const *)GET_BSTR1(IDS_WIZARD_COMPUTER)))
//						else if (!UStrICmp(text, L"computer"))
//						{
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS2);
//							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS2);
//							return TRUE;
//						}
						else
						{
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_END_UNDO);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_UNDO);
							return TRUE;
						}
					}
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_UNDO);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK EndDlgProc (
						  HWND hwndDlg,
						  UINT uMsg,
						  WPARAM wParam,
						  LPARAM lParam
						  )
{
	
	IPerformMigrationTaskPtr      w;  
	CString s;
	HRESULT hr = w.CreateInstance(CLSID_Migrator);
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{	pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//		SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
		SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
		HWND hwndControl = GetDlgItem(hwndDlg, IDC_END_TITLE);
		SetWindowFont(hwndControl,pdata->hTitleFont, TRUE);				
		break;
		}
	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_CONFIRMATION);
			break;
		}		
	
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code) 
			{				
			case PSN_SETACTIVE : 
				{
					BSTR desc = NULL;
					w->GetTaskDescription(IUnknownPtr(pVarSet), &desc);
					s= desc;
					SysFreeString(desc);
					SetDlgItemText(hwndDlg,IDC_SETTINGS,s);					
					PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_FINISH);
					break;
				}
			case PSN_WIZBACK :{
				if (migration==w_reporting)
				{
					_bstr_t text= get(DCTVS_Reports_AccountReferences);
					if (!UStrICmp(text ,(WCHAR const *) yes))
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION1);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION1);
						return TRUE;
					}
					else
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_OPTIONS_REPORTING);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OPTIONS_REPORTING);
						return TRUE;
					}
				}
				else if (migration==w_account)
				{
					if (pdata->someService)
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SA_INFO);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO);
						return TRUE;
					}
					else
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_RENAMING);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENAMING);
						return TRUE;
					}
				}
				else if (migration==w_security)
				{
					if (pdata->translateObjects)
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION_MODE);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION_MODE);
						return TRUE;
					}
					else
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION);
						return TRUE;
					}
				}
				else if (migration==w_groupmapping)
				{
					if (!pdata->IsSidHistoryChecked)
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_OPTIONS_GROUPMAPPING);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OPTIONS_GROUPMAPPING);
						return TRUE;
					}
				}
				else if (migration==w_group)
				{
					if (pdata->migratingGroupMembers && !pdata->sameForest)
					{
						if (pdata->someService)
						{
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SA_INFO);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO);
							return TRUE;
						}
						else 
						{
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DISABLE);
							return TRUE;
						}						
					}
					else
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_RENAMING);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_RENAMING);
						return TRUE;
					}
				}
				
				else if (migration==w_undo)
				{
					if (!pdata->sameForest)
					{
//				        SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_UNDO);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_UNDO);
						return TRUE;
					}
					else
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						return TRUE;
					}
				}
				
				break;
				}
			case PSN_WIZFINISH :
				{
					
					if (migration == w_computer)
						populateTime(pdata->rebootDelay,pdata->servers);
					if (migration == w_reporting)
						populateReportingTime();
				
					
					if (migration!=w_service)
					{
						try
						{CWaitCursor w2;
	//						pVarSet->DumpToFile(L"C:\\FINAL.out");
					w->PerformMigrationTask(IUnknownPtr(pVarSet),(LONG_PTR)hwndDlg);							
						}	
						catch (const _com_error &e)
						{
							if (e.Error() == MIGRATOR_E_PROCESSES_STILL_RUNNING)
							{
								CString str;
								str.LoadString(IDS_ADMT_PROCESSES_STILL_RUNNING);
								::AfxMessageBox(str);
							}
							else
							{
								::AfxMessageBox(e.ErrorMessage());
							}
							break;
						}
					}
					if (migration!=w_undo)
						handleDB();
					break;					
				}
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_RESET :
				break;
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_CONFIRMATION);
					break;
				}
			default :
				break;	
			}
			break;
		}	
	default:
		break;
	}
	return 0;
}
INT_PTR CALLBACK IntroDlgProc (
							HWND hwndDlg,
							UINT uMsg,
							WPARAM wParam,
							LPARAM lParam
							)
{	IPerformMigrationTaskPtr      w;  
	CString s;
	HRESULT hr = w.CreateInstance(CLSID_Migrator);

//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
			HWND hwndControl = GetDlgItem(hwndDlg, IDC_BEGIN_TITLE);
			SetWindowFont(hwndControl,pdata->hTitleFont, TRUE);
			break;
		}
	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_WELCOME);
			break;
		}		

	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE : 
			{
					BSTR desc = NULL;
					w->GetTaskDescription(IUnknownPtr(pVarSet), &desc);
					s= desc;
					SysFreeString(desc);
					SetDlgItemText(hwndDlg,IDC_SETTINGS,s);				
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
				break;
			}
			case PSN_WIZNEXT :
				{
					if (migration==w_undo)
					{
						_bstr_t b=pVarSetUndo->get(GET_BSTR(DCTVS_Options_SourceDomain));
						CString s=(WCHAR *) b;
						CString sourceDomainController; 
						PDOMAIN_CONTROLLER_INFOW pdomc;	
						HRESULT res = DsGetDcNameW(NULL,(LPCTSTR const)s,NULL,NULL,	DS_DIRECTORY_SERVICE_PREFERRED,&pdomc); 
						if (res!=NO_ERROR)
						{
							NetApiBufferFree(pdomc);
							ErrorWrapper3(hwndDlg,res,sourceNetbios);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_INTRO_UNDO);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_INTRO_UNDO);
							return TRUE;
						}
						else
						{
							sourceDomainController = pdomc->DomainControllerName;
							NetApiBufferFree(pdomc);
						}
						bool isNt4;
						hr =validDomain(sourceDomainController,isNt4);
						if (!SUCCEEDED(hr))
						{
							ErrorWrapper4(hwndDlg,hr,s);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_INTRO_UNDO);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_INTRO_UNDO);
							return TRUE;
						}
						if(!isNt4)
						{HRESULT hr;
							if (!targetNativeMode(b,hr))
							{	
								MessageBoxWrapper(hwndDlg,IDS_MSG_MESSAGE9,IDS_MSG_ERROR);
//								SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_INTRO_UNDO);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_INTRO_UNDO);
								return TRUE;
							}
						}						
					}
					break;
				}
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_RESET :
				break;
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_WELCOME);
					break;
				}
			default :
				break;
			}
			break;
		}
		
	default:
		break;
	}
	return 0;
}

INT_PTR CALLBACK IntDomainSelectionProc (
									  HWND hwndDlg,
									  UINT uMsg,
									  WPARAM wParam,
									  LPARAM lParam
									  )
{
	HRESULT hr;	
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	//TRACE1("Message:%ld\n",uMsg);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			HWND hLC4= GetDlgItem(hwndDlg,IDC_EDIT_DOMAIN);
			sourceDrop.Attach(hLC4);
			HWND hLC5= GetDlgItem(hwndDlg,IDC_EDIT_DOMAIN2);
			targetDrop.Attach(hLC5);
			populateList(sourceDrop);
			populateList(targetDrop);
			initeditbox( hwndDlg,IDC_EDIT_DOMAIN,DCTVS_Options_SourceDomainDns);
			initeditbox( hwndDlg, IDC_EDIT_DOMAIN2,DCTVS_Options_TargetDomainDns );
//  			SetDlgItemText(hwndDlg,IDC_EDIT_DOMAIN,L"MCSDEV");
//			SetDlgItemText(hwndDlg,IDC_EDIT_DOMAIN2,L"DEVRAPTORW2K");
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					CString sourceDomainController=L"";
					CString targetDomainController=L""; 
					
					if (IsDlgItemEmpty(hwndDlg,IDC_EDIT_DOMAIN) ||
						IsDlgItemEmpty(hwndDlg,IDC_EDIT_DOMAIN2) )
					{
						MessageBoxWrapper(hwndDlg,IDS_MSG_DOMAIN,IDS_MSG_INPUT);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
						return TRUE;
					}
					else if ((migration!=w_security) && (!verifyprivs(hwndDlg,sourceDomainController,targetDomainController,pdata)))
					{
//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
						return TRUE;
					}
					else if ((migration==w_security) && (!verifyprivsSTW(hwndDlg,sourceDomainController,targetDomainController,pdata)))
					{
//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
						return TRUE;
					}
					else
					{
						if (sourceDC != sourceDomainController)
						{
							sourceDC = sourceDomainController;
							DCList.RemoveAll();
						}

//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
						if (migration==w_groupmapping && pdata->sameForest)
						{
			                MessageBoxWrapper(hwndDlg,IDS_MSG_GROUPMAPPING,IDS_MSG_ERROR);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
						return TRUE;
						}
						put(DCTVS_Options_SourceDomain, (LPCTSTR)sourceNetbios);
						put(DCTVS_Options_TargetDomain, (LPCTSTR)targetNetbios);
						put(DCTVS_Options_SourceDomainDns, (LPCTSTR)sourceDNS);
						put(DCTVS_Options_TargetDomainDns, (LPCTSTR)targetDNS);
						clearCredentialsName = pdata->newSource;
						if (migration!=w_trust &&
							(migration!=w_retry &&
							(migration!=w_undo &&
							(migration!=w_exchangeDir &&
							(migration!=w_exchangeSrv)))))
						{	
							if ((migration==w_service) || (migration==w_reporting))
							{
								hr =InitObjectPicker2(pDsObjectPicker,true,sourceDomainController,pdata->sourceIsNT4);
							}
							else if (migration==w_security)
							{
								hr =InitObjectPicker2(pDsObjectPicker,true,targetDomainController,false);
							}
							else
							{
								hr =InitObjectPicker(pDsObjectPicker,true,sourceDomainController,pdata->sourceIsNT4);
							}
							
							if (FAILED(hr)) 
							{
								MessageBoxWrapper(hwndDlg,IDS_MSG_OBJECTPICKER_SOURCE,IDS_MSG_ERROR);		
//								SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
								return TRUE;
							}
							
							if (migration==w_groupmapping)
							{
								hr = InitObjectPicker(pDsObjectPicker2,false,targetDomainController,pdata->sourceIsNT4);							
								if (FAILED(hr)) 
								{
									MessageBoxWrapper(hwndDlg,IDS_MSG_OBJECTPICKER_TARGET,IDS_MSG_ERROR);		
//									SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_DOMAIN_SELECTION);
									SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DOMAIN_SELECTION);
									return TRUE;
								}
							}
						}
					}				
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_DOMAIN_SELECTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_DOMAIN_SELECTION);
			break;
		}		
		
	default:
		break;
		}
		return 0;				
}

INT_PTR CALLBACK IntDisableProc (
							  HWND hwndDlg,
							  UINT uMsg,
							  WPARAM wParam,
							  LPARAM lParam
							  )
{
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);

			   //init the sidhistory checkbox
            if (migration==w_account)
			{
			   CString toformat;
			   toformat.LoadString(IDS_SIDHISTORY_CTRL_TEXT);
		       SetDlgItemText(hwndDlg,IDC_ROAMING_OR_SIDHISTORY,toformat);
	           initcheckbox( hwndDlg,IDC_ROAMING_OR_SIDHISTORY,DCTVS_AccountOptions_AddSidHistory);
			   if (pdata->sameForest)
			   {
				  CheckDlgButton(hwndDlg,IDC_ROAMING_OR_SIDHISTORY,true);
				  disable(hwndDlg,IDC_ROAMING_OR_SIDHISTORY);
			   }
			}
			else //else init the box for roaming profile
			{
			   CString toformat;
			   toformat.LoadString(IDS_ROAMING_PROFILE_CTRL_TEXT);
			   SetDlgItemText(hwndDlg,IDC_ROAMING_OR_SIDHISTORY,toformat);
			   initcheckbox( hwndDlg,IDC_ROAMING_OR_SIDHISTORY,DCTVS_AccountOptions_TranslateRoamingProfiles);
			}

			initdisablesrcbox(hwndDlg);		

			inittgtstatebox(hwndDlg);		

			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_SRC_EXPIRE_ACCOUNTS :
				{
			        if (IsDlgButtonChecked(hwndDlg,IDC_SRC_EXPIRE_ACCOUNTS))
					{     
						enable(hwndDlg,IDC_yo);
						enable(hwndDlg,IDC_DATE);
						enable(hwndDlg,IDC_TEXT);
					}
					else
					{
						disable(hwndDlg,IDC_yo);
						disable(hwndDlg,IDC_DATE);
						disable(hwndDlg,IDC_TEXT);
					}
					break;
				}
			default :
				break;
			}
			
			switch(HIWORD (wParam)){
			case EN_SETFOCUS :
			    bChangeOnFly=true;
				break;
			case EN_KILLFOCUS :
			    bChangeOnFly=false;
				break;
			case EN_CHANGE:	
				{
					if ((!bChangeOnFly) || (LOWORD(wParam) != IDC_yo))
						break;
					CString s;
					GetDlgItemText(hwndDlg,IDC_yo,s.GetBuffer(1000),1000);
					s.ReleaseBuffer();
					   //make sure all chars are digits
					bool bInvalid = false;
					int ndx=0;
					while ((ndx < s.GetLength()) && (!bInvalid))
					{
						if (!iswdigit(s[ndx]))
						   bInvalid = true;
						ndx++;
					}
					if (bInvalid)
					{
						  //for invalid days, blank out the date
					   SetDlgItemText(hwndDlg,IDC_DATE,L"");
					}
					else //else continue checking for validity
					{
					   long ndays = _wtol(s);
					   if (((ndays <= THREE_YEARS) && (ndays >= 1)) ||
						   (!UStrICmp(s,L"0")))
					      calculateDate(hwndDlg,s);
					   else
					   {
						     //for invalid days, blank out the date
					      SetDlgItemText(hwndDlg,IDC_DATE,L"");
					   }
					}
					break;
				}
			default :
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{			

			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					checkbox(hwndDlg,IDC_SRC_DISABLE_ACCOUNTS,DCTVS_AccountOptions_DisableSourceAccounts);
					checkbox(hwndDlg,IDC_TGT_DISABLE_ACCOUNTS,DCTVS_AccountOptions_DisableCopiedAccounts);
					checkbox(hwndDlg,IDC_TGT_SAME_AS_SOURCE,DCTVS_AccountOptions_TgtStateSameAsSrc);
					_variant_t varX;
					if (IsDlgButtonChecked(hwndDlg,IDC_SRC_EXPIRE_ACCOUNTS))
					{
					    CString s;
					    GetDlgItemText(hwndDlg,IDC_yo,s.GetBuffer(1000),1000);
					    s.ReleaseBuffer();
							//make sure all chars are digits
						int ndx=0;
						while (ndx < s.GetLength())
						{
							if (!iswdigit(s[ndx]))
							{
								MessageBoxWrapper(hwndDlg,IDS_MSG_TIME,IDS_MSG_ERROR);
								SetFocus(GetDlgItem(hwndDlg, IDC_yo));
								SendDlgItemMessage(hwndDlg, IDC_yo, EM_SETSEL, 
												  (WPARAM)0, (LPARAM)-1); 
								SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
								return TRUE;
							}
							ndx++;
						}
					    long ndays = _wtol(s);
					    if (((ndays <= THREE_YEARS) && (ndays >= 1)) ||
						    (!UStrICmp(s,L"0")))
						{
						    varX = (LPCTSTR)s;
						    put(DCTVS_AccountOptions_ExpireSourceAccounts,varX);
						}
						else 
						{
						    MessageBoxWrapper(hwndDlg,IDS_MSG_TIME,IDS_MSG_ERROR);
						    SetFocus(GetDlgItem(hwndDlg, IDC_yo));
						    SendDlgItemMessage(hwndDlg, IDC_yo, EM_SETSEL, 
											  (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						    return TRUE;
						}
					}
					else
					{
						varX = L"";
						put(DCTVS_AccountOptions_ExpireSourceAccounts,varX);
					}

					if (migration==w_account)
					{
					   if (IsDlgButtonChecked(hwndDlg,IDC_ROAMING_OR_SIDHISTORY) && !pdata->sameForest)
					   {
						  HRESULT  hr = doSidHistory(hwndDlg);
						  if (!SUCCEEDED(hr) && hr!=E_ABORT)
						  {
							 ErrorWrapper(hwndDlg,hr);
							 CheckDlgButton(hwndDlg,IDC_ROAMING_OR_SIDHISTORY,false);
						  }
						  else if (hr==E_ABORT)
						     CheckDlgButton(hwndDlg,IDC_ROAMING_OR_SIDHISTORY,false);
					   }
					
					   checkbox(hwndDlg,IDC_ROAMING_OR_SIDHISTORY,DCTVS_AccountOptions_AddSidHistory);										
					   pdata->IsSidHistoryChecked =(IsDlgButtonChecked( hwndDlg,IDC_ROAMING_OR_SIDHISTORY)==BST_CHECKED)?true:false;
					   if (pdata->IsSidHistoryChecked )
					   {
						  SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						  return TRUE;
					   }
					   else
					   {
						  SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_OPTIONS);
						  return TRUE;
					   }
					}//end if user migration
					else //else set or clear the translate roaming profile key
					   checkbox( hwndDlg,IDC_ROAMING_OR_SIDHISTORY,DCTVS_AccountOptions_TranslateRoamingProfiles);

					if (someServiceAccounts(pdata->accounts,hwndDlg))
					{
						pdata->someService=true;
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO);
						return TRUE;
					}
					else
					{
						pdata->someService=false;
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_GROUP);
						return TRUE;
					}
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				{
				   GetError(0); //clear any old com errors
				   break;
				}
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_ACCOUNTTRANSITION_OPTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_ACCOUNTTRANSITION_OPTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK IntTranslationModeProc (
									  HWND hwndDlg,
									  UINT uMsg,
									  WPARAM wParam,
									  LPARAM lParam
									  )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			inittranslationbox( hwndDlg,
				IDC_TRANSLATION_MODE_REPLACE,IDC_TRANSLATION_MODE_ADD,IDC_TRANSLATION_MODE_REMOVE,
				DCTVS_Security_TranslationMode,pdata->sameForest);
			break;
		}

	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
			{
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				
				translationbox( hwndDlg,
					IDC_TRANSLATION_MODE_REPLACE,IDC_TRANSLATION_MODE_ADD,IDC_TRANSLATION_MODE_REMOVE,
					DCTVS_Security_TranslationMode);

					//if not add mode and user rights translation selected previously, them
					//post an informational message
				_bstr_t TransUserRights = get(DCTVS_Security_TranslateUserRights);
                if ((!IsDlgButtonChecked( hwndDlg, IDC_TRANSLATION_MODE_ADD)) &&
					(!UStrCmp(TransUserRights,(WCHAR const *) yes)))
				{
					CString message;
					CString title;
					message.LoadString(IDS_MSG_TRANSUR_ADDONLY);
					title.LoadString(IDS_MSG_TRANSUR_TITLE);
					MessageBox(hwndDlg,message,title,MB_OK | MB_ICONINFORMATION);
				}
				break;
			}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_SECURITY_OPTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_SECURITY_OPTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}
INT_PTR CALLBACK IntOptionsGroupMappingProc(
								   HWND hwndDlg,
								   UINT uMsg,
								   WPARAM wParam,
								   LPARAM lParam
								   )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			
			initcheckbox( hwndDlg,IDC_COPY_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
			initcheckbox( hwndDlg,IDC_ADD_SID_HISTORY,DCTVS_AccountOptions_AddSidHistory);

			if (pdata->sameForest)
			{
				CheckDlgButton(hwndDlg,IDC_ADD_SID_HISTORY,true);
				disable(hwndDlg,IDC_ADD_SID_HISTORY);
			}
	
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				checkbox( hwndDlg,IDC_COPY_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
				
				if (IsDlgButtonChecked(hwndDlg,IDC_ADD_SID_HISTORY) && !pdata->sameForest)
				{
					HRESULT  hr = doSidHistory(hwndDlg);
					if (!SUCCEEDED(hr)&& hr!=E_ABORT)
					{
						ErrorWrapper(hwndDlg,hr);
						CheckDlgButton(hwndDlg,IDC_ADD_SID_HISTORY,false);
					}
									else if (hr==E_ABORT)
						CheckDlgButton(hwndDlg,IDC_ADD_SID_HISTORY,false);

				}
				
				checkbox( hwndDlg,IDC_ADD_SID_HISTORY,DCTVS_AccountOptions_AddSidHistory);
				pdata->IsSidHistoryChecked =(IsDlgButtonChecked( hwndDlg,IDC_ADD_SID_HISTORY)==BST_CHECKED)?true:false;
				
				if (pdata->IsSidHistoryChecked )
				{
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
					return TRUE;
				}
				else
				{
//					SetWindowLong(hwndDlg, DWL_MSGRESULT,IDD_END_GROUPMAPPING);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_END_GROUPMAPPING);
					return TRUE;
				}				
				break;
			case PSN_WIZBACK :
					
	break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_GROUP_OPTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_GROUP_OPTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK IntGroupOptionsProc (
								   HWND hwndDlg,
								   UINT uMsg,
								   WPARAM wParam,
								   LPARAM lParam
								   )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			
			initnoncollisionrename(hwndDlg);

			initcheckbox( hwndDlg,IDC_COPY_GROUP_MEMBERS,DCTVS_AccountOptions_CopyContainerContents);
			initcheckbox( hwndDlg,IDC_COPY_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
			initcheckbox( hwndDlg,IDC_ADD_SID_HISTORY,DCTVS_AccountOptions_AddSidHistory);
			initcheckbox( hwndDlg,IDC_REMIGRATE_OBJECTS,DCTVS_AccountOptions_IncludeMigratedAccts);
			initcheckbox( hwndDlg,IDC_FIX_MEMBERSHIP,DCTVS_AccountOptions_FixMembership);
			if (IsDlgButtonChecked(hwndDlg,IDC_COPY_GROUP_MEMBERS))
			{
				pdata->memberSwitch=true;
				enable(hwndDlg,IDC_REMIGRATE_OBJECTS);
//				CheckDlgButton(hwndDlg,IDC_FIX_MEMBERSHIP,true);
			}
			else
			{
				disable(hwndDlg,IDC_REMIGRATE_OBJECTS);
			}
			if (pdata->sameForest)
			{
				CheckDlgButton(hwndDlg,IDC_ADD_SID_HISTORY,true);
				disable(hwndDlg,IDC_ADD_SID_HISTORY);
				CheckDlgButton(hwndDlg,IDC_FIX_MEMBERSHIP,true);
				disable(hwndDlg,IDC_FIX_MEMBERSHIP);
			}
			if (migration==w_group && pdata->sameForest)
			{
				CheckDlgButton(hwndDlg,IDC_REMIGRATE_OBJECTS,false);
				disable(hwndDlg,IDC_REMIGRATE_OBJECTS);
			}
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
			case IDC_COPY_GROUP_MEMBERS:
				{
					pdata->memberSwitch=(!pdata->memberSwitch);
		            if (migration!=w_group)
			           pdata->memberSwitch ? enable(hwndDlg,IDC_REMIGRATE_OBJECTS):disable(hwndDlg,IDC_REMIGRATE_OBJECTS);
                    else if (migration==w_group && !pdata->sameForest)
			           pdata->memberSwitch ? enable(hwndDlg,IDC_REMIGRATE_OBJECTS):disable(hwndDlg,IDC_REMIGRATE_OBJECTS);
//		            CheckDlgButton(hwndDlg,IDC_FIX_MEMBERSHIP,true);
					bChangedMigrationTypes=true;
					break;
				}
			case IDC_RADIO_NONE :
				{
					disable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					break;
				}	
			case IDC_RADIO_PRE :
				{
					enable(hwndDlg,IDC_PRE);
					disable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_SUF,false);
				    SetFocus(GetDlgItem(hwndDlg, IDC_PRE));
					SendDlgItemMessage(hwndDlg, IDC_PRE, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			case IDC_RADIO_SUF :
				{
					disable(hwndDlg,IDC_PRE);
					enable(hwndDlg,IDC_SUF);
					CheckDlgButton(hwndDlg,IDC_RADIO_NONE,false);
					CheckDlgButton(hwndDlg,IDC_RADIO_PRE,false);
				    SetFocus(GetDlgItem(hwndDlg, IDC_SUF));
					SendDlgItemMessage(hwndDlg, IDC_SUF, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
					break;
				}	
			default :
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				checkbox( hwndDlg,IDC_COPY_GROUP_MEMBERS,DCTVS_AccountOptions_CopyContainerContents);
				checkbox( hwndDlg,IDC_COPY_GROUP_MEMBERS,DCTVS_AccountOptions_CopyUsers);
				checkbox( hwndDlg,IDC_COPY_USER_RIGHTS,DCTVS_AccountOptions_UpdateUserRights);
				checkbox( hwndDlg,IDC_FIX_MEMBERSHIP,DCTVS_AccountOptions_FixMembership);
				
				if (IsDlgButtonChecked(hwndDlg,IDC_COPY_GROUP_MEMBERS) && pdata->sameForest)
				{
					CString yo;
					yo.LoadString(IDS_GRATUITIOUS_MESSAGE2);
					CString warning;
					warning.LoadString(IDS_MSG_WARNING);
					MessageBox(hwndDlg,yo,warning,MB_OK| MB_ICONINFORMATION);
				} 	

				
				if (IsDlgButtonChecked(hwndDlg,IDC_ADD_SID_HISTORY) && !pdata->sameForest)
				{	
					HRESULT  hr = doSidHistory(hwndDlg);
					if (!SUCCEEDED(hr) && hr!=E_ABORT)
					{
						ErrorWrapper(hwndDlg,hr);
						CheckDlgButton(hwndDlg,IDC_ADD_SID_HISTORY,false);
					}
					else if (hr==E_ABORT)
						CheckDlgButton(hwndDlg,IDC_ADD_SID_HISTORY,false);

				}
				
				checkbox( hwndDlg,IDC_ADD_SID_HISTORY,DCTVS_AccountOptions_AddSidHistory);
				pdata->IsSidHistoryChecked =(IsDlgButtonChecked( hwndDlg,IDC_ADD_SID_HISTORY)==BST_CHECKED)?true:false;
				if (IsDlgButtonChecked(hwndDlg,IDC_COPY_GROUP_MEMBERS))
				{
					checkbox( hwndDlg,IDC_REMIGRATE_OBJECTS,DCTVS_AccountOptions_IncludeMigratedAccts);
					pdata->migratingGroupMembers=true;				
				}
				else
				{
					pdata->migratingGroupMembers=false;				
				}
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				
				if ( !noncollisionrename(hwndDlg))
				{
					int nID = IDC_PRE;
					MessageBoxWrapperFormat1(hwndDlg,IDS_MSG_INVALIDCHARS,IDS_INVALID_STRING,IDS_MSG_INPUT);
//					SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_OPTIONS_GROUP);
					   //set focus on invalid string
	                if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_SUF))
					   nID = IDC_SUF;
					SetFocus(GetDlgItem(hwndDlg, nID));
					SendDlgItemMessage(hwndDlg, nID, EM_SETSEL, 
									  (WPARAM)0, (LPARAM)-1); 
				    SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
					return TRUE;
				}
				
				if (pdata->sourceIsNT4 || pdata->sameForest)
				{
					if (pdata->IsSidHistoryChecked )
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						return TRUE;
					}
					else
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_RENAMING);
						return TRUE;
					}				
				}
				break;
			case PSN_WIZBACK :
	

				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_GROUP_OPTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_GROUP_OPTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}
INT_PTR CALLBACK IntExchangeSelectionProc (
								   HWND hwndDlg,
								   UINT uMsg,
								   WPARAM wParam,
								   LPARAM lParam
								   )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initeditbox( hwndDlg,IDC_EXCHANGE_SERVER,DCTVS_Security_TranslateContainers);
			break;
		}
				
	case WM_COMMAND:
		{
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				{
					enableNextIfNecessary(hwndDlg,IDC_EXCHANGE_SERVER);
					break;
				}
			default: 
				break;
			}
			break;
		}

	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :

				IsDlgItemEmpty(hwndDlg,IDC_EXCHANGE_SERVER) ?
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK):
				PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
					CWaitCursor ex;
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					CString so;GetDlgItemText(hwndDlg,IDC_EXCHANGE_SERVER,so.GetBuffer(1000),1000);so.ReleaseBuffer();
					SERVER_INFO_100         * servInfo = NULL;
					so.TrimLeft();so.TrimRight();
					if (NetServerGetInfo(so.GetBuffer(1000),100,(LPBYTE *)&servInfo)!=NERR_Success)
					{
						so.ReleaseBuffer();
						MessageBoxWrapper(hwndDlg,IDS_MSG_INVALIDEXCHANGE,IDS_MSG_ERROR);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_EXCHANGE_SELECTION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_EXCHANGE_SELECTION);
						if ( servInfo )
						{
							NetApiBufferFree(servInfo);
						}
						return TRUE;
					}
					else
					so.ReleaseBuffer();
					if ( servInfo )
					{
						NetApiBufferFree(servInfo);
					}					
					editbox( hwndDlg,IDC_EXCHANGE_SERVER,DCTVS_Security_TranslateContainers);
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_EXCHANGE_SERVER_SELECTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_EXCHANGE_SERVER_SELECTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK IntCommitProc (
								   HWND hwndDlg,
								   UINT uMsg,
								   WPARAM wParam,
								   LPARAM lParam
								   )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			CheckRadioButton(hwndDlg,IDC_CHANGEIT,IDC_DONTCHANGE,IDC_DONTCHANGE);
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :					

				PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				checkbox( hwndDlg,IDC_DONTCHANGE,DCTVS_Options_NoChange);
				break;
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_COMMIT);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_COMMIT);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK IntOuSelectionProc (
								  HWND hwndDlg,
								  UINT uMsg,
								  WPARAM wParam,
								  LPARAM lParam
								  )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			break; 
		}
		
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
				
			case IDC_BROWSE :
				{
                   HMODULE           hMod = NULL;
                   hMod = LoadLibrary(L"dsuiext.dll");
                   if ( hMod )
				   {
                      WCHAR               sDomPath[255];
                      wsprintf(sDomPath, L"LDAP://%s", (LPCTSTR)targetDNS);
                      DsBrowseForContainerX = (DSBROWSEFORCONTAINER)GetProcAddress(hMod, "DsBrowseForContainerW");
                      WCHAR             * sContPath, * sContName;
                      if ( !BrowseForContainer(hwndDlg, sDomPath, &sContPath, &sContName) )
					  {
                         SetDlgItemText(hwndDlg, IDC_TARGET_OU, sContPath);
                         CoTaskMemFree(sContPath);
                         CoTaskMemFree(sContName);
					  }
			          FreeLibrary(hMod);
				   }
				   break;
				}
			default:
				break;
			}
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				{
					enableNextIfNecessary(hwndDlg,IDC_TARGET_OU);
					break;
				}
			default: 
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				pdata->resetOUPATH ? SetDlgItemText( hwndDlg,IDC_TARGET_OU,L""): initeditbox( hwndDlg,IDC_TARGET_OU,DCTVS_Options_OuPath);
				pdata->resetOUPATH =false;
//				SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
				
				enableNextIfNecessary(hwndDlg,IDC_TARGET_OU);
				break;
			case PSN_WIZNEXT :
				{CWaitCursor ex;
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					IADsContainerPtr pCont;
 
					   //since group, user, and computer migrations only bring up this dialog, we will
					   //use this occasion to clear the exclude properties flag if the source
					   //domain is NT 4.0
					if (pdata->sourceIsNT4)
					   put(DCTVS_AccountOptions_ExcludeProps, no);

					CString c,d,toenter;
					GetDlgItemText(hwndDlg,IDC_TARGET_OU,c.GetBuffer(1000),1000);
					c.ReleaseBuffer();
					d=c.Left(7);d.TrimLeft();d.TrimRight();
					if (!d.CompareNoCase(L"LDAP://"))
					{
						toenter=c;
					}
					else
					{
						toenter.Format(L"LDAP://%s/%s",targetDNS,c);
                        SetDlgItemText(hwndDlg, IDC_TARGET_OU, (LPCTSTR)toenter);
					}
					if (ADsGetObject(toenter,IID_IADsContainer,(void**)&pCont)!=S_OK)
					{ 
						  //if buffer was big enough, say invalid OU
						long len = toenter.GetLength();
						if (len < 999)
						{
						   MessageBoxWrapper(hwndDlg,IDS_MSG_INVALIDOU,IDS_MSG_ERROR);
						   SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OU_SELECTION);
						   pdata->resetOUPATH =true;
					       SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					       return TRUE;
						}
						else //else if buffer too small, tell user OU path too long
						{
						   MessageBoxWrapper(hwndDlg,IDS_OU_TOO_LONG,IDS_MSG_ERROR);
						   SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OU_SELECTION);
						   pdata->resetOUPATH =true;
					       SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					       return TRUE;
						}
					}
				
					editbox( hwndDlg,IDC_TARGET_OU,DCTVS_Options_OuPath);
					if (pdata->sameForest&& migration==w_account)
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						return TRUE;
					}
					break;
				}
			case PSN_WIZBACK :
				editbox( hwndDlg,IDC_TARGET_OU,DCTVS_Options_OuPath);
				
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_OU_SELECTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_OU_SELECTION);
			break;
		}		
		
	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK IntCredentials2Proc (
								   HWND hwndDlg,
								   UINT uMsg,
								   WPARAM wParam,
								   LPARAM lParam
								   )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initeditbox( hwndDlg,IDC_CREDENTIALS_DOMAIN2,DCTVS_Options_Credentials_Domain);
if (!clearCredentialsName)
			initeditbox( hwndDlg, IDC_CREDENTIALS_USERNAME2,DCTVS_Options_Credentials_UserName );
			initeditbox( hwndDlg, IDC_CREDENTIALS_PASSWORD2,DCTVS_Options_Credentials_Password );
			SetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN2,sourceNetbios);

			if (migration ==w_reporting)
			{
				CString yo;
				yo.LoadString(IDS_SEC_CRED2);
				SetDlgItemText(hwndDlg,IDC_STATIC_ID,yo);
			}
			else if(migration ==w_security)
			{
				CString yo;
				yo.LoadString(IDS_SEC_CRED2);
				SetDlgItemText(hwndDlg,IDC_STATIC_ID,yo);
			    SetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN2,targetNetbios);
			}
			HWND h=GetDlgItem(hwndDlg,IDC_CREDENTIALS_DOMAIN2);
			break;
		}
	case WM_COMMAND:
		{
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				{
					if (enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_DOMAIN2))
						enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_USERNAME2);
					break;
				}
			case EN_KILLFOCUS:	
				{
					if (GetDlgItem(hwndDlg,IDC_CREDENTIALS_USERNAME) == (HWND)lParam)
					{
						CString aUPNName, aUser=L"", aDomain=L"";
						int index;
						GetDlgItemText(hwndDlg,IDC_CREDENTIALS_USERNAME,aUPNName.GetBuffer(1000),1000);
						aUPNName.ReleaseBuffer();
							//if possibly listed in UPN format, extract username and domain from that UPN
							//and convert to DNS domain name to its netbios name
						if ((index = aUPNName.Find(L'@')) != -1)
						{
							if (GetDomainAndUserFromUPN(&*aUPNName, aDomain, aUser))
							{
								SetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN,aDomain);
								SetDlgItemText(hwndDlg,IDC_CREDENTIALS_USERNAME,aUser);
							}
						}
					}
					break;
				}
			default: 
				break;
			}
			break;
		}
		
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				if (enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_DOMAIN2))
					enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_USERNAME2);
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					
					CString dom,user,pass;
					GetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN2,dom.GetBuffer(1000),1000);
					GetDlgItemText(hwndDlg,IDC_CREDENTIALS_USERNAME2,user.GetBuffer(1000),1000);
					GetDlgItemText(hwndDlg,IDC_CREDENTIALS_PASSWORD2,pass.GetBuffer(1000),1000);
					dom.ReleaseBuffer(); user.ReleaseBuffer(); pass.ReleaseBuffer();
					
					DWORD returncode= VerifyPassword(user.GetBuffer(1000),pass.GetBuffer(1000),dom.GetBuffer(1000));
					dom.ReleaseBuffer(); user.ReleaseBuffer(); pass.ReleaseBuffer();
					if (returncode!=ERROR_LOGON_FAILURE)
					{
						
						editbox( hwndDlg,IDC_CREDENTIALS_DOMAIN2,DCTVS_Options_Credentials_Domain);
						editbox( hwndDlg,IDC_CREDENTIALS_USERNAME2,DCTVS_Options_Credentials_UserName);
						editbox( hwndDlg,IDC_CREDENTIALS_PASSWORD2,DCTVS_Options_Credentials_Password);
					}
					else
					{
						ErrorWrapper(hwndDlg,returncode);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS2);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS2);
						return TRUE;
					}
					break;
				}
			case PSN_WIZBACK :
				{
					if (migration==w_security && !pdata->translateObjects)
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION);
						return TRUE;
					}
					if (migration==w_security && pdata->translateObjects)
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION_MODE);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION_MODE);
						return TRUE;
					}
					
					else if (migration==w_computer)
					{
						if (!pdata->translateObjects)
						{
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION);
							return TRUE;
						}
						else
						{					
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_TRANSLATION_MODE);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION_MODE);
							return TRUE;
						}
					}
				if (migration==w_undo &&pdata->sameForest)
				{				
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
							return TRUE;
						}
				else if (migration==w_undo &&!pdata->sameForest)
				{
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_UNDO);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_UNDO);
							return TRUE;
						}
				


					break;		
				}
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					int id;
					if (migration==w_reporting)
						id =IDH_WINDOW_REPORT_CREDENTIALS;
					else
						id =IDH_WINDOW_SECURITY_CREDENTIALS;
					helpWrapper(hwndDlg,id);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}
	case WM_HELP :
		{
			int id;
			if (migration==w_reporting)
				id =IDH_WINDOW_REPORT_CREDENTIALS;
			else
				id =IDH_WINDOW_SECURITY_CREDENTIALS;
			helpWrapper(hwndDlg,id);
			break;
		}		
		
	default:
		break;
	}

	return 0;
}

		
INT_PTR CALLBACK IntCredentialsProc (
								  HWND hwndDlg,
								  UINT uMsg,
								  WPARAM wParam,
								  LPARAM lParam
								  )
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initeditbox( hwndDlg,IDC_CREDENTIALS_DOMAIN,DCTVS_AccountOptions_SidHistoryCredentials_Domain);
			
			if (!clearCredentialsName)			initeditbox( hwndDlg, IDC_CREDENTIALS_USERNAME,DCTVS_AccountOptions_SidHistoryCredentials_UserName );
			initeditbox( hwndDlg, IDC_CREDENTIALS_PASSWORD,DCTVS_AccountOptions_SidHistoryCredentials_Password );
			enable(hwndDlg,IDC_CREDENTIALS_DOMAIN);
			enable(hwndDlg,IDC_CREDENTIALS_USERNAME);
			enable(hwndDlg,IDC_CREDENTIALS_PASSWORD);
			SetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN,sourceNetbios);
			if (pdata->sameForest)
			{
				SetDlgItemText(hwndDlg,IDC_MYTITLE,GET_CSTRING(IDS_MYTITLE2));
			SetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN,targetNetbios);
			}
			if (migration==w_exchangeDir)
				SetDlgItemText(hwndDlg,IDC_MYTITLE,GET_CSTRING(IDS_MYTITLE3));
			break;
		}
	case WM_COMMAND:
		{
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				{
					if (enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_DOMAIN))
						enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_USERNAME);
					break;
				}
			case EN_KILLFOCUS:	
				{
					if (GetDlgItem(hwndDlg,IDC_CREDENTIALS_USERNAME) == (HWND)lParam)
					{
						CString aUPNName, aUser=L"", aDomain=L"";
						int index;
						GetDlgItemText(hwndDlg,IDC_CREDENTIALS_USERNAME,aUPNName.GetBuffer(1000),1000);
						aUPNName.ReleaseBuffer();
							//if possibly listed in UPN format, extract username and domain from that UPN
							//and convert to DNS domain name to its netbios name
						if ((index = aUPNName.Find(L'@')) != -1)
						{
							if (GetDomainAndUserFromUPN(&*aUPNName, aDomain, aUser))
							{
								SetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN,aDomain);
								SetDlgItemText(hwndDlg,IDC_CREDENTIALS_USERNAME,aUser);
							}
						}
					}
					break;
				}
			default: 
				break;
			}
			break;
		}
		
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				if (enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_DOMAIN))
					enableNextIfNecessary(hwndDlg,IDC_CREDENTIALS_USERNAME);
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);					
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);					
					CString dom,user,pass;
					GetDlgItemText(hwndDlg,IDC_CREDENTIALS_DOMAIN,dom.GetBuffer(1000),1000);
					GetDlgItemText(hwndDlg,IDC_CREDENTIALS_USERNAME,user.GetBuffer(1000),1000);
					GetDlgItemText(hwndDlg,IDC_CREDENTIALS_PASSWORD,pass.GetBuffer(1000),1000);
					dom.ReleaseBuffer(); user.ReleaseBuffer(); pass.ReleaseBuffer();
					
					DWORD returncode = VerifyPassword(user.GetBuffer(1000),pass.GetBuffer(1000),dom.GetBuffer(1000));
					dom.ReleaseBuffer(); user.ReleaseBuffer(); pass.ReleaseBuffer();
					if (returncode!=ERROR_LOGON_FAILURE)
					{
						editbox( hwndDlg,IDC_CREDENTIALS_DOMAIN,DCTVS_AccountOptions_SidHistoryCredentials_Domain);
						editbox( hwndDlg, IDC_CREDENTIALS_USERNAME,DCTVS_AccountOptions_SidHistoryCredentials_UserName );
						editbox( hwndDlg, IDC_CREDENTIALS_PASSWORD,DCTVS_AccountOptions_SidHistoryCredentials_Password );
					}
					else
					{
						ErrorWrapper(hwndDlg,returncode);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						return TRUE;
					}
					if (migration==w_undo)
					{
//						_bstr_t text=get(DCTVS_Options_Wizard);
//						
//*						if (!UStrICmp(text,(WCHAR const *)GET_BSTR1(IDS_WIZARD_COMPUTER)))
//						if (!UStrICmp(text, L"computer"))
//						{
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS2);
//							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS2);
//							return TRUE;
//						}
//						else
//						{
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_END_UNDO);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_UNDO);
							return TRUE;
//						}
					}
					break;
				}
			case PSN_WIZBACK :
				{
					if (pdata->sameForest && migration==w_account)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OU_SELECTION);
						return TRUE;
					}
					else if (migration==w_account)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DISABLE);
						return TRUE;
					}
					else if (pdata->sourceIsNT4 || pdata->sameForest && migration==w_group)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_OPTIONS_GROUP);
						return TRUE;
					}				
					break;
				}
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_SIDHISTORY_CREDENTIALS);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_SIDHISTORY_CREDENTIALS);
			break;
		}		

	default:
		break;
	}
	return 0;				
}


INT_PTR CALLBACK IntRenameProc (
							 HWND hwndDlg,
							 UINT uMsg,
							 WPARAM wParam,
							 LPARAM lParam
							 )
{
		//find out if copy user's groups are being copied. If not then disable the
		//replace existing group member checkbox
	bool bCopyGroups = true;
	_bstr_t strCopyGroups = get(DCTVS_AccountOptions_CopyMemberOf);
	if (((!UStrCmp(strCopyGroups,(WCHAR const *) yes)) && (migration==w_account)) || 
		(migration==w_group))
		bCopyGroups = true;
	else
		bCopyGroups = false;

//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
/**/		handleInitRename(hwndDlg, pdata->sameForest, bCopyGroups);
			if (migration==w_computer)
			{
				CString yo;
				yo.LoadString(IDS_COMPUTER_RENAME_TITLE);
				SetDlgItemText(hwndDlg,IDC_THERENAMINGTITLE,yo);
			}
			if (IsDlgButtonChecked(hwndDlg, IDC_SKIP_CONFLICTING_ACCOUNTS))
			{
				pdata->renameSwitch=1;
				disable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				disable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				disable(hwndDlg,IDC_PREFIX);
				disable(hwndDlg,IDC_SUFFIX);
				disable(hwndDlg,IDC_RADIO_PREFIX);
				disable(hwndDlg,IDC_RADIO_SUFFIX);
			}
			else if (IsDlgButtonChecked(hwndDlg, IDC_REPLACE_CONFLICTING_ACCOUNTS))
			{
				pdata->renameSwitch=2;
				enable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				enable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				if ((migration!=w_computer) && (bCopyGroups)) 
					enable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				else
				{
					disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
					CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
				}

				disable(hwndDlg,IDC_PREFIX);
				disable(hwndDlg,IDC_SUFFIX);
				disable(hwndDlg,IDC_RADIO_PREFIX);
				disable(hwndDlg,IDC_RADIO_SUFFIX);
			}
			else 
			{
				CheckDlgButton( hwndDlg,IDC_RENAME_CONFLICTING_ACCOUNTS,true);
				pdata->renameSwitch=3;
				disable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				disable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				enable(hwndDlg,IDC_RADIO_PREFIX);
				enable(hwndDlg,IDC_RADIO_SUFFIX);
				
				_bstr_t text2 = get(DCTVS_AccountOptions_Prefix);
				_bstr_t text3 = get(DCTVS_AccountOptions_Suffix);
				
				if (UStrICmp(text3,L""))
				{
					disable(hwndDlg,IDC_PREFIX);
					enable(hwndDlg,IDC_SUFFIX);				
					CheckRadioButton(hwndDlg,IDC_RADIO_PREFIX,IDC_RADIO_SUFFIX,IDC_RADIO_SUFFIX);
				}
				else 
				{
					enable(hwndDlg,IDC_PREFIX);
					disable(hwndDlg,IDC_SUFFIX);				
					CheckRadioButton(hwndDlg,IDC_RADIO_PREFIX,IDC_RADIO_SUFFIX,IDC_RADIO_PREFIX);
				}				 	
			}
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{
/*			case IDC_REPLACE_EXISTING_GROUP_MEMBERS:
				if (IsDlgButtonChecked(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS) && migration==w_account)
				{
					_bstr_t text = get(DCTVS_AccountOptions_CopyMemberOf);
					if (UStrCmp(text,(WCHAR const *) yes))
					{
						MessageBoxWrapper(hwndDlg,IDC_MSG_SELECT_COPY_MEMBER,IDS_MSG_ERROR);
						CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
					}
				}
				break;				
*/			case IDC_SKIP_CONFLICTING_ACCOUNTS :
				pdata->renameSwitch=1;
				disable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				disable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				disable(hwndDlg,IDC_PREFIX);
				disable(hwndDlg,IDC_SUFFIX);
				disable(hwndDlg,IDC_RADIO_PREFIX);
				disable(hwndDlg,IDC_RADIO_SUFFIX);
				break;
			case IDC_REPLACE_CONFLICTING_ACCOUNTS :		
				pdata->renameSwitch=2;
				enable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				enable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				if ((migration!=w_computer) && (bCopyGroups))
					enable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				else
				{
					disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
					CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
				}
				disable(hwndDlg,IDC_PREFIX);
				disable(hwndDlg,IDC_SUFFIX);
				disable(hwndDlg,IDC_RADIO_PREFIX);
				disable(hwndDlg,IDC_RADIO_SUFFIX);
				break;
			case IDC_RENAME_CONFLICTING_ACCOUNTS :
				pdata->renameSwitch=3;
				disable(hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS);
				disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
				disable(hwndDlg,IDC_REMOVE_EXISTING_LOCATION);
				enable(hwndDlg,IDC_RADIO_PREFIX);
				enable(hwndDlg,IDC_RADIO_SUFFIX);
				if (IsDlgButtonChecked(hwndDlg,IDC_RADIO_SUFFIX))
				{
				   enable(hwndDlg,IDC_SUFFIX);
				   CheckRadioButton(hwndDlg,IDC_RADIO_PREFIX,IDC_RADIO_SUFFIX,IDC_RADIO_SUFFIX);
				}
				else
				{
				   enable(hwndDlg,IDC_PREFIX);
				   CheckRadioButton(hwndDlg,IDC_RADIO_PREFIX,IDC_RADIO_SUFFIX,IDC_RADIO_PREFIX);
				}
				break;
			case IDC_RADIO_SUFFIX :
				enable(hwndDlg,IDC_SUFFIX);
				disable(hwndDlg,IDC_PREFIX);
				CheckDlgButton(hwndDlg,IDC_RADIO_PREFIX,false);
				SetFocus(GetDlgItem(hwndDlg, IDC_SUFFIX));
				SendDlgItemMessage(hwndDlg, IDC_SUFFIX, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
				break;
			case IDC_RADIO_PREFIX :
				enable(hwndDlg,IDC_PREFIX);
				disable(hwndDlg,IDC_SUFFIX);
				CheckDlgButton(hwndDlg,IDC_RADIO_SUFFIX,false);
				SetFocus(GetDlgItem(hwndDlg, IDC_PREFIX));
				SendDlgItemMessage(hwndDlg, IDC_PREFIX, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
				break;
			default:
				break;
			}
			break;
		}
		
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				if (IsDlgButtonChecked(hwndDlg, IDC_REPLACE_CONFLICTING_ACCOUNTS))
				{
					if ((migration==w_computer) || (!bCopyGroups))
					{
						disable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
						CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
					}
					else
					{
						enable(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS);
						initcheckbox(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,DCTVS_AccountOptions_ReplaceExistingGroupMembers);
					}
				}
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);					
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);					
					if (IsDlgButtonChecked (hwndDlg,IDC_SKIP_CONFLICTING_ACCOUNTS))
					{
						put(DCTVS_AccountOptions_Prefix,L"");
						put(DCTVS_AccountOptions_Suffix,L"");
						put(DCTVS_AccountOptions_ReplaceExistingAccounts,L"");
						put(DCTVS_AccountOptions_RemoveExistingUserRights,L"");
						put(DCTVS_AccountOptions_ReplaceExistingGroupMembers,L"");
						put(DCTVS_AccountOptions_MoveReplacedAccounts,L"");
					}
					else if (IsDlgButtonChecked (hwndDlg,IDC_REPLACE_CONFLICTING_ACCOUNTS))
					{
						put(DCTVS_AccountOptions_Prefix,L"");
						put(DCTVS_AccountOptions_Suffix,L"");
						put(DCTVS_AccountOptions_ReplaceExistingAccounts,yes);
						checkbox( hwndDlg,IDC_REMOVE_EXISTING_USER_RIGHTS,DCTVS_AccountOptions_RemoveExistingUserRights);
						checkbox( hwndDlg,IDC_REMOVE_EXISTING_LOCATION,DCTVS_AccountOptions_MoveReplacedAccounts);
						if (IsDlgButtonChecked(hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS) && (migration==w_account))						
						{
							if (!bCopyGroups)
							{
//								MessageBoxWrapper(hwndDlg,IDC_MSG_SELECT_COPY_MEMBER,IDS_MSG_ERROR);
								CheckDlgButton( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,false);
							}
						}
						if (migration!=w_computer)
						    checkbox( hwndDlg,IDC_REPLACE_EXISTING_GROUP_MEMBERS,DCTVS_AccountOptions_ReplaceExistingGroupMembers);

					}
					else if (IsDlgButtonChecked (hwndDlg,IDC_RENAME_CONFLICTING_ACCOUNTS) && 
						IsDlgButtonChecked (hwndDlg,IDC_RADIO_PREFIX))
					{
						if (!validString(hwndDlg,IDC_PREFIX))
						{
							MessageBoxWrapperFormat1(hwndDlg,IDS_MSG_INVALIDCHARS,IDS_INVALID_STRING,IDS_MSG_INPUT);
//							SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_RENAMING);
					        SetFocus(GetDlgItem(hwndDlg, IDC_PREFIX));
					        SendDlgItemMessage(hwndDlg, IDC_PREFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
					        return TRUE;
						}
						else if (IsDlgItemEmpty(hwndDlg,IDC_PREFIX))
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_BLANK,IDS_MSG_INPUT);
//							SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_RENAMING);
					        SetFocus(GetDlgItem(hwndDlg, IDC_PREFIX));
					        SendDlgItemMessage(hwndDlg, IDC_PREFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}
						else if (findInVarSet(hwndDlg,IDC_PREFIX,L"Options.Prefix"))
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_EXTENSION_PREFIX,IDS_MSG_INPUT);
//							SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_RENAMING);
					        SetFocus(GetDlgItem(hwndDlg, IDC_PREFIX));
					        SendDlgItemMessage(hwndDlg, IDC_PREFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}
						else if (tooManyChars(hwndDlg,IDC_PREFIX))
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_EXTENSION_MAX_PRE,IDS_MSG_INPUT);
//							SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_RENAMING);
					        SetFocus(GetDlgItem(hwndDlg, IDC_PREFIX));
					        SendDlgItemMessage(hwndDlg, IDC_PREFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}
						else
						{
							editbox( hwndDlg, IDC_PREFIX,DCTVS_AccountOptions_Prefix );
							put(DCTVS_AccountOptions_Suffix,L"");
							put(DCTVS_AccountOptions_ReplaceExistingAccounts,L"");					
							put(DCTVS_AccountOptions_RemoveExistingUserRights,L"");
							put(DCTVS_AccountOptions_ReplaceExistingGroupMembers,L"");
						    put(DCTVS_AccountOptions_MoveReplacedAccounts,L"");
						}
					
					
					}
					else if (IsDlgButtonChecked (hwndDlg,IDC_RENAME_CONFLICTING_ACCOUNTS) && 
						IsDlgButtonChecked (hwndDlg,IDC_RADIO_SUFFIX))
					{
						if (!validString(hwndDlg,IDC_SUFFIX))
						{
							MessageBoxWrapperFormat1(hwndDlg,IDS_MSG_INVALIDCHARS,IDS_INVALID_STRING,IDS_MSG_INPUT);
//							SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_RENAMING);
					        SetFocus(GetDlgItem(hwndDlg, IDC_SUFFIX));
					        SendDlgItemMessage(hwndDlg, IDC_SUFFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}					
						else if (IsDlgItemEmpty(hwndDlg,IDC_SUFFIX))
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_BLANK,IDS_MSG_INPUT);
//							SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_RENAMING);
					        SetFocus(GetDlgItem(hwndDlg, IDC_SUFFIX));
					        SendDlgItemMessage(hwndDlg, IDC_SUFFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}
						else if (findInVarSet(hwndDlg,IDC_SUFFIX,L"Options.Suffix"))
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_EXTENSION_SUFFIX,IDS_MSG_INPUT);
//							SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_RENAMING);
					        SetFocus(GetDlgItem(hwndDlg, IDC_SUFFIX));
					        SendDlgItemMessage(hwndDlg, IDC_SUFFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}
						else if (tooManyChars(hwndDlg,IDC_SUFFIX))
						{
							MessageBoxWrapper(hwndDlg,IDS_MSG_EXTENSION_MAX_SUF,IDS_MSG_INPUT);
//							SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_RENAMING);
					        SetFocus(GetDlgItem(hwndDlg, IDC_SUFFIX));
					        SendDlgItemMessage(hwndDlg, IDC_SUFFIX, EM_SETSEL, 
									           (WPARAM)0, (LPARAM)-1); 
				            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
							return TRUE;
						}

						else
						{
							editbox( hwndDlg, IDC_SUFFIX,DCTVS_AccountOptions_Suffix );
							put(DCTVS_AccountOptions_Prefix,L"");
							put(DCTVS_AccountOptions_ReplaceExistingAccounts,L"");					
							put(DCTVS_AccountOptions_RemoveExistingUserRights,L"");
							put(DCTVS_AccountOptions_ReplaceExistingGroupMembers,L"");
						    put(DCTVS_AccountOptions_MoveReplacedAccounts,L"");
						}
					}	


					if (migration==w_account)
					{
						if (someServiceAccounts(pdata->accounts,hwndDlg))
						{
							pdata->someService=true;
//							SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
							SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SA_INFO);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SA_INFO);
							return TRUE;
						}
						else
						{
							pdata->someService=false;
//							SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
							SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_END_ACCOUNT);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_ACCOUNT);
							return TRUE;
						}
					}
					else if (migration==w_group)
					{
						if (pdata->migratingGroupMembers && !pdata->sameForest)
						{
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_PASSWORD);
							return TRUE;
						}
						else
						{
							pdata->someService=false;
//							SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
							SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_END_GROUP);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_END_GROUP);
							return TRUE;
						}
					}


					break;
				}
			case PSN_WIZBACK :
				{
					if (pdata->IsSidHistoryChecked && migration==w_group)
					{
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_CREDENTIALS);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						return TRUE;
					}
					if (!pdata->sourceIsNT4 && !pdata->sameForest && migration==w_account)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_PROP_EXCLUSION);
						return TRUE;
					}
					else if (migration==w_account)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OPTIONS);
						return TRUE;
					}
					else if (migration==w_computer && pdata->sourceIsNT4)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_REBOOT);
						return TRUE;
					}
					else if (pdata->sourceIsNT4 || pdata->sameForest && migration==w_group)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_OPTIONS_GROUP);
						return TRUE;
					}
					else if (migration==w_group)
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_PROP_EXCLUSION);
						return TRUE;
					}

					break;		
				}
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_NAME_CONFLICT);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_NAME_CONFLICT);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

INT_PTR CALLBACK IntSelectionSecurityProc (
								HWND hwndDlg,
								UINT uMsg,
								WPARAM wParam,
								LPARAM lParam
								)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
			HWND hLC= GetDlgItem(hwndDlg,IDC_LIST_MEMBERS1);
			m_listBox.Attach(hLC);
			setupColumns(pdata->sourceIsNT4);
			m_listBox.DeleteAllItems();
			disable(hwndDlg,IDC_REMOVE_BUTTON);
			PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
			HWND hLC4= GetDlgItem(hwndDlg,IDC_ADDITIONAL_TRUSTING_DOMAIN);
			additionalDrop.Attach(hLC4);
			if ((migration==w_security) && (pdata->secWithMapFile))
			{  //get the netbios name of the machine we are running on
               WCHAR  sTempName[MAX_PATH];
               DWORD  lenName = MAX_PATH;

               if (GetComputerName(sTempName, &lenName))
			   {
	              PDOMAIN_CONTROLLER_INFOW pdomc;
				  CString sTempUPN, aDomain, aUser;
				  HRESULT res = DsGetDcNameW((LPCTSTR)sTempName,NULL,NULL,NULL,DS_DIRECTORY_SERVICE_PREFERRED,&pdomc); 
	              if (res==NO_ERROR)
				  {
					 targetDNS = pdomc->DomainName;
		             sTempUPN = L"administrator@" + targetDNS;
					 if (GetDomainAndUserFromUPN(&*sTempUPN, aDomain, aUser))
                        targetNetbios = aDomain;
		             NetApiBufferFree(pdomc);
				  }
			   }
			}
			else if ((migration==w_security) && (!pdata->secWithMapFile))
               lastInitializedTo=targetNetbios;
			else
               lastInitializedTo=sourceNetbios;
			populateList(additionalDrop);
			break;
		}
	case WM_HELP :
		{
				int id =IDH_WINDOW_COMPUTER_SELECTION;
				
			helpWrapper(hwndDlg,id);
			break;
		}		

	case WM_COMMAND :
		{
			switch(LOWORD (wParam))
			{
			case IDC_ADD_BUTTON :
				{CWaitCursor w;
					HRESULT hr=S_OK;
					CString tempTrustingDomain;
					PDOMAIN_CONTROLLER_INFOW pdomc;	
					GetDlgItemText(hwndDlg,IDC_ADDITIONAL_TRUSTING_DOMAIN,tempTrustingDomain.GetBuffer(1000),1000);
					tempTrustingDomain.ReleaseBuffer();
					tempTrustingDomain.TrimLeft();tempTrustingDomain.TrimRight();
					
					if (tempTrustingDomain.IsEmpty() && (lastInitializedTo.CompareNoCase(sourceNetbios)) && (migration!=w_security))
					{			
						CString temp;
						HRESULT res = DsGetDcNameW(NULL,(LPCTSTR const)sourceNetbios,NULL,NULL,	DS_DIRECTORY_SERVICE_PREFERRED,&pdomc); 
						temp=pdomc->DomainControllerName;
						if (res==NO_ERROR)								
						{
						lastInitializedTo=sourceNetbios;

							hr =InitObjectPicker2(pDsObjectPicker,true,temp,false);
						}else
							hr=E_UNEXPECTED;
					}
//					else if (tempTrustingDomain.IsEmpty() && (lastInitializedTo.CompareNoCase(targetNetbios)) && (migration==w_security))
					else if (tempTrustingDomain.IsEmpty() && (migration==w_security))
					{			
						CString temp;
						HRESULT res = DsGetDcNameW(NULL,(LPCTSTR const)targetNetbios,NULL,NULL,	DS_DIRECTORY_SERVICE_PREFERRED,&pdomc); 
						temp=pdomc->DomainControllerName;
						if (res==NO_ERROR)								
						{
						    lastInitializedTo=targetNetbios;
							hr =InitObjectPicker2(pDsObjectPicker,true,temp,pdata->sourceIsNT4);
						}else
							hr=E_UNEXPECTED;
					}
					else if (lastInitializedTo.CompareNoCase(tempTrustingDomain) && !tempTrustingDomain.IsEmpty())
					{
						CString additionalDomainController;
						if (!verifyprivs2(hwndDlg,additionalDomainController,tempTrustingDomain))
						{
//							SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
							SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
//							SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION4);
							SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION4);
							return TRUE;
						}
                        lastInitializedTo=tempTrustingDomain;
						hr =ReInitializeObjectPicker(pDsObjectPicker,true,additionalDomainController,pdata->sourceIsNT4);
					}
				
					if (FAILED(hr)) 
					{
						MessageBoxWrapper(hwndDlg,IDS_MSG_OBJECTPICKER_SOURCE2,IDS_MSG_ERROR);		
						SetDlgItemText(hwndDlg,IDC_ADDITIONAL_TRUSTING_DOMAIN,L"");
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION4);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION4);
						return TRUE;
					}
					
//					if (migration==w_security)
//					   OnADD(hwndDlg,false);
//					else
					   OnADD(hwndDlg,pdata->sourceIsNT4);
					sort(m_listBox,0,pdata->sort[0]);
					enableNextIfObjectsSelected(hwndDlg);
					break;
				}
			case IDC_REMOVE_BUTTON :
				OnREMOVE(hwndDlg);
				enableNextIfObjectsSelected(hwndDlg);
				break;
			default :
				break;
			}		
					enableRemoveIfNecessary(hwndDlg);
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE : 
				{
					if (pdata->newSource)
					{
						m_listBox.DeleteAllItems();
						pdata->newSource=false;
//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					}
					if (m_listBox.GetItemCount()==0) 
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
					else
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
					break;	
				}
			case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					sort(m_listBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
				break;
				}
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{
					enableRemoveIfNecessary(hwndDlg);
					break;
				}				
			case PSN_WIZNEXT :
				{CWaitCursor w;
					if (m_listBox.GetItemCount()==0)
				{
					MessageBoxWrapper(hwndDlg,IDS_MSG_OBJECT,IDS_MSG_INPUT);
					
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION1);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION1);
					return TRUE;
				}
				OnMIGRATE(hwndDlg,pdata->accounts,pdata->servers);
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				break;
				}
			case PSN_WIZBACK :
				{
				   if (migration==w_security)
				   {
					  _bstr_t text= get(DCTVS_AccountOptions_SecurityInputMOT);
					  if (UStrICmp(text ,(WCHAR const *) yes))
					  {
						 SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_TRANSLATION_SRC);
						 return TRUE;
					  }
				   }
				   break;
				}
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					int id=IDH_WINDOW_COMPUTER_SELECTION;
						
					helpWrapper(hwndDlg,id);
					break;
				}
			case PSN_RESET :
				break;
			default :
				break;
			}
			break;
		}
		
	default:
		break;
	}
	return 0;
}




INT_PTR CALLBACK IntSelectionProc (
								HWND hwndDlg,
								UINT uMsg,
								WPARAM wParam,
								LPARAM lParam
								)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
			HWND hLC= GetDlgItem(hwndDlg,IDC_LIST_MEMBERS1);
			m_listBox.Attach(hLC);
			setupColumns(pdata->sourceIsNT4);
			m_listBox.DeleteAllItems();
			disable(hwndDlg,IDC_REMOVE_BUTTON);
			PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
			break;
		}
	case WM_HELP :
		{
			int id=0;
			if (migration==w_computer || (migration==w_security || migration==w_reporting))
				id =IDH_WINDOW_COMPUTER_SELECTION;
			else if (migration==w_account)
				id =IDH_WINDOW_USER_SELECTION;
			else if (migration==w_group || migration==w_groupmapping)
				id =IDH_WINDOW_GROUP_SELECTION;
			else if (migration==w_service)
				id =IDH_WINDOW_SERVICE_ACCOUNT_SELECTION;
			
			helpWrapper(hwndDlg,id);
			break;
		}		

	case WM_COMMAND :
		{
			switch(LOWORD (wParam))
			{
			case IDC_ADD_BUTTON :
				OnADD(hwndDlg,pdata->sourceIsNT4);
				//sort(m_listBox,0,pdata->sort[0]);
				enableNextIfObjectsSelected(hwndDlg);
				break;
			case IDC_REMOVE_BUTTON :
				OnREMOVE(hwndDlg);
				enableNextIfObjectsSelected(hwndDlg);
				break;
			default :
				break;
			}		
		    enableRemoveIfNecessary(hwndDlg);
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE : 
				{
					if (pdata->newSource)
					{
						m_listBox.DeleteAllItems();
						pdata->newSource=false;
//						SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
						SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					}PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
					if (m_listBox.GetItemCount()==0) 
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
					else
						PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
					break;	
				}
			case LVN_COLUMNCLICK:
				{
					LPNMLISTVIEW pnmv = (NM_LISTVIEW FAR *) lParam;
					pdata->sort[pnmv->iSubItem] = !pdata->sort[pnmv->iSubItem];
					//sort(m_listBox,pnmv->iSubItem,pdata->sort[pnmv->iSubItem] );
//					SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);			
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);			
				break;
				}
			case NM_SETFOCUS :
			case NM_KILLFOCUS :
			case NM_CLICK:
				{
					enableRemoveIfNecessary(hwndDlg);
					break;
				}				
			case PSN_WIZNEXT :
				{CWaitCursor w;

				if (m_listBox.GetItemCount()==0)
				{
					MessageBoxWrapper(hwndDlg,IDS_MSG_OBJECT,IDS_MSG_INPUT);
					
//					SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_SELECTION1);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_SELECTION1);
					return TRUE;
				}
				OnMIGRATE(hwndDlg,pdata->accounts,pdata->servers);
//				SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
				SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
				break;
				}
			case PSN_WIZBACK :
				break;
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					int id=0;
					if (migration==w_computer || (migration==w_security || migration==w_reporting))
						id =IDH_WINDOW_COMPUTER_SELECTION;
					else if (migration==w_account)
						id =IDH_WINDOW_USER_SELECTION;
					else if (migration==w_group || migration==w_groupmapping)
						id =IDH_WINDOW_GROUP_SELECTION;
					else if (migration==w_service)
						id =IDH_WINDOW_SERVICE_ACCOUNT_SELECTION;
						
					helpWrapper(hwndDlg,id);
					break;
				}
			case PSN_RESET :
				break;
			default :
				break;
			}
			break;
		}
		
	default:
		break;
	}
	return 0;
}

INT_PTR CALLBACK
IntHTMLLocationProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initeditbox( hwndDlg,IDC_HTML_TARGET,DCTVS_Reports_Directory);
		if (IsDlgItemEmpty(hwndDlg,IDC_HTML_TARGET))
			{
				CString toinsert;
				GetDirectory(toinsert.GetBuffer(1000));
				toinsert.ReleaseBuffer();
				toinsert+="Reports";
				SetDlgItemText(hwndDlg,IDC_HTML_TARGET,toinsert);
			}

			//load the data from the database and display in the listbox.
			break;
		}

	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{			
			case IDC_BROWSE :
				OnBROWSE(hwndDlg,IDC_HTML_TARGET);
				break;
			default:
				break;
			}
			switch(HIWORD(wParam))
			{
			case EN_CHANGE :
				enableNextIfNecessary(hwndDlg,IDC_HTML_TARGET);
				break;
			default: 
				break;
			}
			break;
		}

	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
							IsDlgItemEmpty(hwndDlg,IDC_HTML_TARGET) ?
					PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK):
				PostMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK|PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
//					SetWindowLong(hwndDlg, GWL_USERDATA,  (long )pdata);
					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					if (IsDlgItemEmpty(hwndDlg,IDC_HTML_TARGET))
					{
						MessageBoxWrapper(hwndDlg,IDS_MSG_DIRECTORY,IDS_MSG_INPUT);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_HTML_LOCATION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_HTML_LOCATION);
						return TRUE;
					}
					else if (!validDirectoryString(hwndDlg,IDC_HTML_TARGET))
					{
						MessageBoxWrapper(hwndDlg,IDS_MSG_DIRECTORY,IDS_MSG_INPUT);
//						SetWindowLong(hwndDlg, DWL_MSGRESULT, IDD_HTML_LOCATION);
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_HTML_LOCATION);
						return TRUE;
					}
					else
					{			
						editbox( hwndDlg,IDC_HTML_TARGET,DCTVS_Reports_Directory);
					}
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
					helpWrapper(hwndDlg,IDH_WINDOW_DIRECTORY_SELECTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}
	case WM_HELP :
		{
			helpWrapper(hwndDlg,IDH_WINDOW_DIRECTORY_SELECTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 3 OCT 2000                                                  *
 *                                                                   *
 *     This callback function is responsible for handling the windows*
 * messages for the new Translation Input dialog.                    *
 *                                                                   *
 *********************************************************************/

//BEGIN IntTranslationInputProc
INT_PTR CALLBACK
IntTranslationInputProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			initsecinputbox(hwndDlg,IDC_TRANS_FROM_MOT,IDC_TRANS_FROM_FILE,DCTVS_AccountOptions_SecurityInputMOT);
			
		    if (IsDlgButtonChecked(hwndDlg,IDC_TRANS_FROM_MOT))
			{
			   disable(hwndDlg,IDC_BROWSE);
			   disable(hwndDlg,IDC_MAPPING_FILE);
			}
			else
			{
			   enable(hwndDlg,IDC_BROWSE);
			   enable(hwndDlg,IDC_MAPPING_FILE);
			   initeditbox( hwndDlg,IDC_MAPPING_FILE,DCTVS_AccountOptions_SecurityMapFile);
			}
			break;
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{			
			case IDC_BROWSE :
				OnMapFileBrowse(hwndDlg,IDC_MAPPING_FILE);
				break;
			case IDC_TRANS_FROM_MOT :
			    disable(hwndDlg,IDC_BROWSE);
			    disable(hwndDlg,IDC_MAPPING_FILE);
			    break;
			case IDC_TRANS_FROM_FILE :
			    enable(hwndDlg,IDC_BROWSE);
			    enable(hwndDlg,IDC_MAPPING_FILE);
			    initeditbox( hwndDlg,IDC_MAPPING_FILE,DCTVS_AccountOptions_SecurityMapFile);
			    break;
			default:
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;
			case PSN_WIZNEXT :
				{
					  //set some data fields since we don't know source or target domains
				    pdata->sameForest = false;
					pdata->sourceIsNT4 = true;
					checkbox( hwndDlg,IDC_TRANS_FROM_MOT,DCTVS_AccountOptions_SecurityInputMOT);
					if (IsDlgButtonChecked(hwndDlg,IDC_TRANS_FROM_FILE))
					{
					    pdata->secWithMapFile = true;
						   //check if a file is given
			            if (IsDlgItemEmpty(hwndDlg,IDC_MAPPING_FILE))
						{	
						   MessageBoxWrapper(hwndDlg,IDS_MAPFILE_EMPTY,IDS_MAPFILE_TITLE);
						   SetFocus(GetDlgItem(hwndDlg, IDC_MAPPING_FILE));
						   SendDlgItemMessage(hwndDlg, IDC_MAPPING_FILE, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
				           SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						   return TRUE;
						}
			               //see if the given file exists
						else if (!checkMapFile(hwndDlg))
						{	
						   MessageBoxWrapper(hwndDlg,IDS_MAPFILE_MISSING,IDS_MAPFILE_TITLE);
						   SetFocus(GetDlgItem(hwndDlg, IDC_MAPPING_FILE));
						   SendDlgItemMessage(hwndDlg, IDC_MAPPING_FILE, EM_SETSEL, 
											(WPARAM)0, (LPARAM)-1); 
				           SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,-1);
						   return TRUE;
						}
						else
						{
							  //save sid mapping file specified
						   editbox(hwndDlg,IDC_MAPPING_FILE,DCTVS_AccountOptions_SecurityMapFile);
						      //if input from Sid mapping file, go to the security selection screen and do not
						      //retrieve domain information
				           SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,IDD_SELECTION4);
						   return TRUE;
						}
					}
					else
					    pdata->secWithMapFile = false;

					SetWindowLongPtr(hwndDlg, GWLP_USERDATA,  (LONG_PTR)pdata);
					break;
				}
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
//					helpWrapper(hwndDlg,IDH_WINDOW_PASSWORD_OPTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
//			helpWrapper(hwndDlg,IDH_WINDOW_PASSWORD_OPTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}
//END IntTranslationInputProc

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 25 OCT 2000                                                 *
 *                                                                   *
 *     This callback function is responsible for handling the windows*
 * messages for the new Object Property Exclusion dialog.  This      *
 * dialog allows the user to exclude certain properties, on a W2K to *
 * W2K inter-forest migration, from being copied to the target       *
 * account.                                                          *
 *                                                                   *
 *********************************************************************/

//BEGIN IntPropExclusionProc
INT_PTR CALLBACK
IntPropExclusionProc(
				IN HWND hwndDlg,
				IN UINT uMsg,
				IN WPARAM wParam,
				IN LPARAM lParam
				)
{
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	switch (uMsg)
	{
	case WM_INITDIALOG :
		{
			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);

			initpropdlg(hwndDlg);
		}
	case WM_COMMAND:
		{
			switch(LOWORD (wParam))
			{			
			case IDC_EXCLUDEPROPS :
	            if (!IsDlgButtonChecked(hwndDlg,IDC_EXCLUDEPROPS))
				{
					disable(hwndDlg,IDC_OBJECTCMBO);
					disable(hwndDlg,IDC_INCLUDELIST);
					disable(hwndDlg,IDC_EXCLUDELIST);
					disable(hwndDlg,IDC_EXCLUDEBTN);
					disable(hwndDlg,IDC_INCLUDEBTN);
				}
				else
				{
					enable(hwndDlg,IDC_OBJECTCMBO);
					enable(hwndDlg,IDC_INCLUDELIST);
					enable(hwndDlg,IDC_EXCLUDELIST);
					enable(hwndDlg,IDC_EXCLUDEBTN);
					enable(hwndDlg,IDC_INCLUDEBTN);
				}
				break;
			case IDC_EXCLUDEBTN :
				moveproperties(hwndDlg, true);
				break;
			case IDC_INCLUDEBTN :
				moveproperties(hwndDlg, false);
				break;
			default:
				break;
			}
			switch(HIWORD (wParam))
			{
			case CBN_SELCHANGE :
				if (LOWORD (wParam) == IDC_OBJECTCMBO)
				   listproperties(hwndDlg);
				break;
			case LBN_DBLCLK :
				if (LOWORD (wParam) == IDC_INCLUDELIST)
				   moveproperties(hwndDlg, true);
				else if (LOWORD (wParam) == IDC_EXCLUDELIST)
				   moveproperties(hwndDlg, false);
				break;
			default:
				break;
			}
			break;
		}
	case WM_NOTIFY :
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;
			switch (lpnm->code)
			{
			case PSN_SETACTIVE :
				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				if (bChangedMigrationTypes)
				{
					initpropdlg(hwndDlg);
					bChangedMigrationTypes=false;
				}
				break;
			case PSN_WIZNEXT :
				checkbox(hwndDlg,IDC_EXCLUDEPROPS,DCTVS_AccountOptions_ExcludeProps);
				saveproperties(hwndDlg);
				if (migration==w_account)
				{
//					SetWindowLong(hwndDlg, DWL_MSGRESULT,IDD_OPTIONS);
					SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_RENAMING);
					return TRUE;
				}
				else if (migration==w_group)
				{
					if (pdata->IsSidHistoryChecked )
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CREDENTIALS);
						return TRUE;
					}
					else
					{
						SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT,IDD_RENAMING);
						return TRUE;
					}
				}				
				break;
			case PSN_WIZBACK :
				break;		
			case PSN_QUERYCANCEL :
				GetError(0); //clear any old com errors
				break;	
			case PSN_HELP :
				{	
//					helpWrapper(hwndDlg,IDH_WINDOW_PASSWORD_OPTION);
					break;
				}
			case PSN_RESET :
				break;		
			default :
				break;		
			}
			break;
		}	case WM_HELP :
		{
//			helpWrapper(hwndDlg,IDH_WINDOW_PASSWORD_OPTION);
			break;
		}		

	default:
		break;
	}
	return 0;				
}
//END IntPropExclusionProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\oupicker.cpp ===
// OUPicker.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "OUPicker.h"

#include "MainFrm.h"
#include "OUPickerDoc.h"
#include "OUPickerView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COUPickerApp

BEGIN_MESSAGE_MAP(COUPickerApp, CWinApp)
	//{{AFX_MSG_MAP(COUPickerApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COUPickerApp construction

COUPickerApp::COUPickerApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only COUPickerApp object

COUPickerApp theApp;

/////////////////////////////////////////////////////////////////////////////
// COUPickerApp initialization

BOOL COUPickerApp::InitInstance()
{
	AfxEnableControlContainer();
   CoInitialize(NULL);
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(COUPickerDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(COUPickerView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void COUPickerApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// COUPickerApp message handlers


int COUPickerApp::ExitInstance() 
{
	// TODO: Add your specialized code here and/or call the base class
	CoUninitialize();
	return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\guiutils.h ===
#pragma once
#include "Globals.h"

const int THREE_YEARS = 1095;

BOOL CanSkipVerification();

void SetItemText(CListCtrl& yo, int nItem, int subItem,CString& text);
void SetItemText(CListCtrl& yo, int nItem, int subItem,TCHAR const * text);
void SetItemText(CListCtrl& yo, int nItem, int subItem,TCHAR * text);
void SetItemText(CListCtrl& yo, int nItem, int subItem,_bstr_t text);
bool GetCheck(CListCtrl & yo,int nItem);
void SetCheck(CListCtrl & yo,int nItem,bool checkit);
void setupColumns(bool sourceIsNT4);
void ShowWarning(HWND hwndDlg);
void ErrorWrapper2(HWND hwndDlg,HRESULT returncode);
void OnFileBrowse(HWND hwndDlg,int id);
void ErrorWrapper(HWND hwndDlg,HRESULT returncode);
void ErrorWrapper4(HWND hwndDlg,HRESULT returncode,CString domainName);
_bstr_t	GET_BSTR1(int id);
void doNothingToVarset();
bool enableNextIfNecessary(HWND hwndDlg,int id);
void enableNextIfObjectsSelected(HWND hwndDlg);
HRESULT InitObjectPicker2(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString targetComputer,bool sourceIsNT4);
bool validString(HWND hwndDlg,int id);
void JobFileGetActionText(WCHAR const * filename,CString & text);
DWORD  VerifyPassword(WCHAR * sUserName, WCHAR * sPassword, WCHAR * sDomain);
void obtainTrustCredentials(HWND hwdDlg);
void activateServiceButtons(HWND hwndDlg);
void activateTrustButton(HWND hwndDlg);
void activateServiceButtons2(HWND hwndDlg);
void activateCancelIfNecessary(HWND hwndDlg);
bool CheckSameForest(CString& domain1,CString& domain2,HRESULT& hr);
bool findInVarSet(HWND hwndDlg,int id, BSTR bstr);
void initnoncollisionrename(HWND hwndDlg);
bool noncollisionrename(HWND hwndDlg);
void handleDB();
CString GET_CSTRING(int id);
bool number(CString num);
HRESULT doSidHistory(HWND hwndDlg);
bool administrator(CString m_Computer,HRESULT& hr);
bool targetNativeMode(_bstr_t b,HRESULT &hr);
HRESULT validDomain(CString m_Computer,bool &isNt4);
bool validDir(CString dir);
bool checkFile(HWND hwndDlg);
bool verifyprivs(HWND hwndDlg,CString &sourceDomainController,CString &targetDomainController,LPSHAREDWIZDATA& pdata);
bool someServiceAccounts(int accounts,HWND hwndDlg);
void swap(CString yo1,CString yo2);
void refreshDB(HWND hwndDlg);
void populateList(CComboBox&);
void getReporting();
bool tooManyChars(HWND hwndDlg,int id);

void putReporting();
void populateReportingTime();
CString timeToCString(int varsetKey);			
void MessageBoxWrapper(HWND hwndDlg,int m,int t);
void getFailed(HWND hwndDlg);
void handleCancel(HWND hwndDlg);
void getService();
void OnADD(HWND hwndDlg,bool sourceIsNT4);
void enable(HWND hwndDlg,int id);
void disable(HWND hwndDlg,int id);
void OnREMOVE(HWND);
void OnMIGRATE(HWND,int & accounts,int& servers);
void initpasswordbox(HWND hwndDlg,int id1,int id2,int id3, BSTR bstr1, BSTR bstr2);
void initdisablesrcbox(HWND hwndDlg);
void inittgtstatebox(HWND hwndDlg);
bool DC(WCHAR*,CString);
bool IsDlgItemEmpty(HWND hwndDlg,int id);
HRESULT InitObjectPicker(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString targetComputer,bool sourceIsNT4);
void ProcessSelectedObjects(IDataObject *pdo,HWND hwndDlg,bool sourceIsNT4);
void ProcessSelectedObjects2(IDataObject *pdo,HWND hwndDlg);
_variant_t get(int i);
void put(int i,_variant_t v);
void initcheckbox(HWND hwndDlg,int id,int varsetKey);
void initeditbox(HWND hwndDlg,int id,int varsetKey);
void inittranslationbox(HWND hwndDlg,int id1,int id2,int id3,int varsetKey,bool sameForest);
void checkbox(HWND hwndDlg,int id,int varsetKey);
void editbox(HWND hwndDlg,int id,int varsetKey);
void translationbox(HWND hwndDlg,int id1,int id2,int id3,int varsetKey);
long rebootbox(HWND hwndDlg,int id);
void handleInitRename(HWND hwndDlg,bool sameForest,bool bCopyGroups);
void addrebootValues(HWND hwndDlg);
BOOL GetDirectory(WCHAR* filename);
void populateTime(long rebootDelay,int servers);
void OnTOGGLE();
void OnRetryToggle();
void OnRETRY();
void setDBStatusSkip();
bool setDBStatusInclude(HWND hwndDlg);
HRESULT MigrateTrusts(HWND hwndDlg,bool& atleast1succeeded);
void OnBROWSE(HWND hwndDlg,int id);
void OnUPDATE(HWND hwndDlg);
void enableRemoveIfNecessary(HWND hwndDlg);
bool validDirectoryString(HWND hwndDlg,int id);
bool validReboot(HWND hwndDlg,int id);
bool SomethingToRetry();
void helpWrapper(HWND hwndDlg, int t);
HRESULT GetHelpFileFullPath( BSTR *bstrHelp );
bool timeInABox(HWND hwndDlg,time_t& t);
void ErrorWrapper3(HWND hwndDlg,HRESULT returncode,CString domainName);
void MessageBoxWrapper3(HWND hwndDlg,int m,int t,CString domainName);
void MessageBoxWrapperFormat1(HWND hwndDlg,int f,int m, int t);
void getTrust();
HRESULT BrowseForContainer(HWND hWnd,//Handle to window that should own the browse dialog.
                    LPOLESTR szRootPath, //Root of the browse tree. NULL for entire forest.
                    LPOLESTR *ppContainerADsPath, //Return the ADsPath of the selected container.
                    LPOLESTR *ppContainerClass //Return the ldapDisplayName of the container's class.
                    );
void sort(CListCtrl & listbox,int col,bool order);
HRESULT ReInitializeObjectPicker(IDsObjectPicker *pDsObjectPicker,bool multiselect,CString additionalDomainController,bool sourceIsNT4) ;
bool verifyprivs2(HWND hwndDlg,CString& additionalDomainController,CString domainName);

void calculateDate(HWND hwndDlg,CString s);
bool verifyprivsSTW(HWND hwndDlg,CString &sourceDomainController,CString &targetDomainController,LPSHAREDWIZDATA& pdata);
void switchboxes(HWND hwndDlg,int oldid, int newid);
bool populatePasswordDCs(HWND hwndDlg, int id, bool bNT4);
HRESULT QueryW2KDomainControllers(CString domainDNS, IEnumVARIANT*& pEnum);
HRESULT QueryNT4DomainControllers(CString domainDNS, IEnumVARIANT*& pEnum);
void addStringToComboBox(HWND hwndDlg, int id, CString s);
void initDCcombobox(HWND hwndDlg, int id, int varsetKey);
void initsecinputbox(HWND hwndDlg,int id1,int id2,int varsetKey);
void OnMapFileBrowse(HWND hwndDlg,int id);
bool checkMapFile(HWND hwndDlg);
void initpropdlg(HWND hwndDlg);
HRESULT BuildPropertyMap(CString Type, long lSrcVer, CMapStringToString * pPropMap);
void moveproperties(HWND hwndDlg,bool bExclude);
void listproperties(HWND hwndDlg);
void saveproperties(HWND hwndDlg);
bool IsPasswordDCReady(CString server, CString &msg, CString &title, UINT *msgtype);
CString CreatePath(CString sDirPath);
void GetValidPathPart(CString sFullPath, CString &sDirectory, CString &sFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\oupicker.h ===
// OUPicker.h : main header file for the OUPICKER application
//

#if !defined(AFX_OUPICKER_H__5C1F291C_01A6_425B_A0A7_8CED36B6E817__INCLUDED_)
#define AFX_OUPICKER_H__5C1F291C_01A6_425B_A0A7_8CED36B6E817__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// COUPickerApp:
// See OUPicker.cpp for the implementation of this class
//

class COUPickerApp : public CWinApp
{
public:
	COUPickerApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COUPickerApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(COUPickerApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUPICKER_H__5C1F291C_01A6_425B_A0A7_8CED36B6E817__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\globals.h ===
#pragma once
#include "resource.h"		// main symbols


// From VC98/MFC/Include
#include <afx.h>
#include <afxdisp.h>


// From VC98/Include
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <FCNTL.H>
#include <sys/stat.h>

#define INC_OLE2

#include <windowsx.h>  // for SetWindowFont
#include <objbase.h>
#include <PrSht.h>
#include <shlobj.h>
#include <lm.h>


// From Platform SDK/Include
#include <HtmlHelp.h>
#include <objsel.h>

#include <DSCLIENT.H>
#include <dsgetdc.h>


#include "ResStr.h"
#include "TReg.hpp"
#include "ErrDct.hpp"
#include "WNetUtil.h"
#include "OuSelect.h"
#include "TrstDlg.h"
#include "HelpID.h"
#include "sidflags.h"
#include "UString.hpp"
#include "HrMsg.h"
#include "Validation.h"
//#include "TxtSid.h"

//#import "\bin\MigDrvr.tlb" no_namespace, named_guids
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\DBManager.tlb" no_namespace, named_guids
//#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids
//#import "\bin\ScmMigr.tlb" no_namespace, named_guids
//#import "\bin\TrustMgr.tlb" no_namespace, named_guids
#import "MigDrvr.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace, named_guids
#import "WorkObj.tlb" no_namespace, named_guids
#import "ScmMigr.tlb" no_namespace, named_guids
#import "TrustMgr.tlb" no_namespace, named_guids
#import "AdsProp.tlb" no_namespace
#import "MsPwdMig.tlb" no_namespace

#define SvcAcctStatus_NotMigratedYet			0
#define SvcAcctStatus_DoNotUpdate			   1
#define SvcAcctStatus_Updated				      2
#define SvcAcctStatus_UpdateFailed			   4
#define SvcAcctStatus_NeverAllowUpdate       8

#define w_account                       1
#define w_group                         2
#define w_computer                      3
#define w_security                      4
#define w_service                       5
#define w_undo                          6
#define w_exchangeDir                   7
#define w_reporting                     8
#define w_retry                         9
#define w_trust                         10
#define w_exchangeSrv                   11
#define w_groupmapping                  12
#ifndef BIF_USENEWUI
#define BIF_USENEWUI					0x0040
#endif

#define REAL_PSH_WIZARD97               0x01000000

typedef int (CALLBACK * DSBROWSEFORCONTAINER)(PDSBROWSEINFOW dsInfo);
extern DSBROWSEFORCONTAINER DsBrowseForContainerX;
typedef struct SHAREDWIZDATA {
	HFONT hTitleFont;
	bool IsSidHistoryChecked;
	int renameSwitch;
	bool prefixorsuffix;
	bool expireSwitch;
	bool refreshing;
	bool someService;
	bool memberSwitch;
	bool proceed;
	bool translateObjects;
	long rebootDelay;
	int accounts,servers;
	bool sameForest;
	bool newSource;
	bool resetOUPATH;
	bool sourceIsNT4;
	bool targetIsNT4;
	bool sort[6];
	bool migratingGroupMembers;
	bool targetIsMixed;
	bool secWithMapFile;
	
} SHAREDWIZDATA, *LPSHAREDWIZDATA;


extern					CEdit pEdit ;

extern IVarSet *			pVarSet;  
extern IVarSet *			pVarSetUndo; 
extern IVarSet *			pVarSetService;
extern IIManageDB *		db;
extern UINT g_cfDsObjectPicker;
extern IDsObjectPicker *pDsObjectPicker;
extern IDataObject *pdo;
extern IDsObjectPicker *pDsObjectPicker2;
extern IDataObject *pdo2;
extern int migration;
extern CComModule _Module;
extern CListCtrl m_listBox;
extern CListCtrl m_cancelBox;
extern CListCtrl m_reportingBox;
extern CListCtrl m_serviceBox;
extern CComboBox m_rebootBox;
extern CListCtrl m_trustBox;
extern CString sourceDNS;
extern CString targetDNS;
extern CString sourceNetbios;
extern CString targetNetbios;
extern StringLoader 			gString;
extern TErrorDct 			err;
extern CComboBox sourceDrop;
extern CComboBox targetDrop;
extern bool alreadyRefreshed;
extern BOOL gbNeedToVerify;
extern _bstr_t yes,no;
extern _bstr_t yes,no;
extern CString lastInitializedTo;
extern CComboBox additionalDrop;
extern bool clearCredentialsName;
extern CString sourceDC;
extern CStringList DCList;
extern CMapStringToString	PropIncMap1;
extern CMapStringToString	PropExcMap1;
extern CMapStringToString	PropIncMap2;
extern CMapStringToString	PropExcMap2;
extern CString	sType1;
extern bool bChangedMigrationTypes;
extern bool bChangeOnFly;
extern CString targetServer;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\oupickerdoc.h ===
// OUPickerDoc.h : interface of the COUPickerDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_OUPICKERDOC_H__8A267B0C_578D_4135_9566_E0350CC4CB0D__INCLUDED_)
#define AFX_OUPICKERDOC_H__8A267B0C_578D_4135_9566_E0350CC4CB0D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class COUPickerDoc : public CDocument
{
protected: // create from serialization only
	COUPickerDoc();
	DECLARE_DYNCREATE(COUPickerDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COUPickerDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~COUPickerDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(COUPickerDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUPICKERDOC_H__8A267B0C_578D_4135_9566_E0350CC4CB0D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\oupickerview.h ===
// OUPickerView.h : interface of the COUPickerView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_OUPICKERVIEW_H__A0B3535C_4E19_47E3_B49D_1DC89C883FD4__INCLUDED_)
#define AFX_OUPICKERVIEW_H__A0B3535C_4E19_47E3_B49D_1DC89C883FD4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class COUPickerView : public CView
{
protected: // create from serialization only
	COUPickerView();
	DECLARE_DYNCREATE(COUPickerView)

// Attributes
public:
	COUPickerDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COUPickerView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~COUPickerView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(COUPickerView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in OUPickerView.cpp
inline COUPickerDoc* COUPickerView::GetDocument()
   { return (COUPickerDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUPICKERVIEW_H__A0B3535C_4E19_47E3_B49D_1DC89C883FD4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\sidflags.h ===
/*---------------------------------------------------------------------------
  File: SidFlags.h

  Comments: Flags that are used by access checker to return from the
            CanAddSidHistory function.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Created : 9/24/1999 Sham Chauthani
  ---------------------------------------------------------------------------
*/

#ifndef SIDFLAG_H
#define SIDFLAG_H

#define  F_WORKS                    0x00000000
#define  F_WRONGOS                  0x00000001
#define  F_NO_REG_KEY               0x00000002
#define  F_NO_AUDITING_SOURCE       0x00000004
#define  F_NO_AUDITING_TARGET       0x00000008
#define  F_NO_LOCAL_GROUP           0x00000010

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\migrvar.cpp ===
// EnumVar.cpp: implementation of the CEnumVar class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <COMDEF.h>
#include "MigrVar.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnumVar::CEnumVar(IEnumVARIANT  * pEnum)
{
   m_pEnum = pEnum;
   m_pEnum->AddRef();
}

CEnumVar::~CEnumVar()
{
   m_pEnum->Release();
}

BOOL CEnumVar::Next(long flag, SAttrInfo * pAttr)
{
   // This function enumerates through and gets name strings for the Values
   ULONG                     ulFetched=0;
   IADs                    * pADs=NULL;
   _variant_t                var;
   BSTR                      bstrName;
   
   if ( !m_pEnum )
   {
      return FALSE;
   }

   HRESULT hr = m_pEnum->Next(1, &var, &ulFetched);

   if ( ulFetched == 0 || FAILED(hr) )
      return FALSE;

   if ( var.vt == VT_BSTR )
   {
      // We have a bstring so lets just return that as names
      wcscpy(pAttr->sName, var.bstrVal);
      wcscpy(pAttr->sSamName, var.bstrVal);
   }
   else
   {
      if ( flag == NULL )
         return FALSE;
      // We have a Dispatch Pointer
      IDispatch * pDisp = V_DISPATCH(&var);
      // We ask for a IAds pointer
      hr = pDisp->QueryInterface( IID_IADs, (void**)&pADs); 
      // and Ask IAds pointer to give us the name of the container.

      // Now fill up information that they need.
      
      // Common Name
      if ( flag | F_Name )
      {
         hr = pADs->get_Name(&bstrName);
         if ( FAILED(hr) )
            return FALSE;
         wcscpy( pAttr->sName, bstrName);
      }

      // SAM Account Name
      if ( flag | F_SamName )
      {
         hr = pADs->Get(L"sAMAccountName", &var);
         if ( FAILED(hr) )
            return FALSE;
         wcscpy( pAttr->sSamName, var.bstrVal);
      }

      // Class name of the object.
      if ( flag | F_Class )
      {
         hr = pADs->get_Class(&bstrName);
         if ( FAILED(hr) )
            return FALSE;
         wcscpy( pAttr->sClass, bstrName);
      }

      // Group Type
 /*     if ( flag | F_GroupType )
      {
         hr = pADs->Get(L"groupType", &var);
         if ( FAILED(hr) )
         {
            var.vt = VT_I4;
            var.lVal = -1;
         }
         pAttr->groupType = var.lVal;
      }
*/   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\ouselect.h ===
#if !defined(AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_)
#define AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ContainerSelectionDlg.h : header file
//
#include "resource.h"
//#import "\bin\NetEnum.tlb" no_namespace
#import "NetEnum.tlb" no_namespace

/////////////////////////////////////////////////////////////////////////////
// CContainerSelectionDlg dialog

class CContainerSelectionDlg : public CDialog
{
// Construction
public:
	HRESULT FindContainer();
	CImageList ilist;
	BOOL LoadImageList();
	HRESULT ExpandCompletely(HTREEITEM tvItem, _bstr_t parentCont);
	HRESULT PopulateContainer(HTREEITEM tvItemParent,_bstr_t sContName, INetObjEnumeratorPtr pQuery);
	CString m_strDomain;
	CContainerSelectionDlg(CWnd* pParent = NULL);   // standard constructor
   COLORREF GetFirstBitmapPixel(CWnd * window,UINT idbBitmap);
   HTREEITEM OpenContainer(CString strCont, HTREEITEM root);

// Dialog Data
	//{{AFX_DATA(CContainerSelectionDlg)
	enum { IDD = IDD_CONT_SELECTION };
	CButton	m_btnOK;
	CTreeCtrl	m_trOUTree;
	CString	m_strCont;
	//}}AFX_DATA
   BSTR domain;
   HRESULT BrowseForContainer(HWND hWnd,//Handle to window that should own the browse dialog.
                       LPOLESTR szRootPath, //Root of the browse tree. NULL for entire forest.
                       LPOLESTR *ppContainerADsPath, //Return the ADsPath of the selected container.
                       LPOLESTR *ppContainerClass //Return the ldapDisplayName of the container's class.
                    );


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContainerSelectionDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CContainerSelectionDlg)
	afx_msg void OnOk();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkTree1(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wizards.rc
//
#define IDS_MYTITLE2                    1
#define IDS_VALID_DIGITS                2
#define IDS_COLON                       3
#define IDS_TRUST_INFO                  3
#define ID_DIALOG_FONTSIZE              8
#define IDS_REBOOT_SUB                  12
#define IDS_UNDO                        13
#define IDS_UNDO_SUB                    14
#define IDS_SECURITY                    15
#define IDS_SECURITY_SUB                16
#define IDM_ABOUTBOX                    0x0010
#define IDS_SECURITY_OPTIONS            17
#define IDS_SECURITY_OPTIONS_SUB        18
#define IDS_SECURITY_FURTHER            19
#define IDS_SECURITY_FURTHER_SUB        20
#define IDS_SECURITY_SUB2               21
#define IDS_MSG_SELECT_TRUST            22
#define IDS_COMPUTER                    23
#define IDS_COMPUTER_SUB                24
#define IDS_COMPUTER_OPTIONS            25
#define IDS_COMPUTER_OPTIONS_SUB        26
#define IDS_COMPUTER_FURTHER            27
#define IDS_COMPUTER_FURTHER_SUB        28
#define IDS_CLOSED                      29
#define IDS_CLOSED_SUB                  30
#define IDS_CREDENTIALS                 31
#define IDS_CREDENTIALS_SUB             32
#define IDS_EXCHANGE                    33
#define IDS_MSG_EXTENSION_PREFIX        33
#define IDS_EXCHANGE_SUB                34
#define IDS_MSG_EXTENSION_SUFFIX        34
#define IDS_ACCOUNT_TITLE               35
#define IDS_DOMAIN2                     36
#define IDS_COMPUTER_TITLE              37
#define IDS_SECURITY_TITLE              38
#define IDS_CREDENTIALS2                39
#define IDS_CREDENTIALS_SUB2            40
#define IDS_GROUP_TITLE                 41
#define IDS_UNDO_TITLE                  42
#define IDS_CREDENTIALS3                43
#define IDS_CREDENTIALS_SUB3            44
#define IDS_RETRY_TITLE                 45
#define IDS_RETRY                       46
#define IDS_RETRY_SUB                   47
#define IDS_MSG_NO_REPORT               48
#define IDS_COMMIT                      48
#define IDS_MSG_NO_REPORT2              49
#define IDS_COMMIT_SUB                  49
#define IDS_MSG_NO_REPORT3              50
#define IDS_TRUST_TITLE                 50
#define IDS_MSG_NO_REPORT4              51
#define IDS_TRUST                       51
#define IDS_MSG_NO_REPORT5              52
#define IDS_TRUST_SUB                   52
#define IDS_MSG_NO_REPORT6              53
#define IDS_CREDENTIALS_TRUST           53
#define IDS_MSG_NO_REPORT7              54
#define IDS_CREDENTIALS_TRUST_SUB       54
#define IDS_MSG_NO_REPORT8              55
#define IDS_GROUPMAPPING_TITLE          55
#define IDS_MSG_NO_REPORT9              56
#define IDS_GROUPMAPPING                56
#define IDS_MSG_NO_REPORT10             57
#define IDS_GROUPMAPPING_SUB            57
#define IDS_REBOOT_SUB2                 57
#define IDS_OPTIONS_FROM_USER           57
#define IDS_MSG_NO_REPORT11             58
#define IDS_GROUP_MAPPING               58
#define IDS_MSG_NO_REPORT12             59
#define IDS_GROUP_MAPPING_SUB           59
#define IDS_TARGET_GROUP                60
#define IDS_TARGET_GROUP_SUB            61
#define IDS_MSG_FOREST                  62
#define IDS_MSG_DISABLED_TRUST          63
#define IDS_MSG_CANCEL                  64
#define IDS_MSG_PASSWORD_POLICY         65
#define IDC_MSG_SELECT_COPY_MEMBER      66
#define IDS_MSG_DIRECTION_TRUST         67
#define IDS_MSG_GROUPMAPPING            68
#define IDS_OPTIONS_FROM_USER_SUB       69
#define IDS_NOT_CREATED                 70
#define IDS_FIVE                        71
#define IDS_TEXT                        72
#define IDS_30                          73
#define IDS_STRING104                   99
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_DELETEME_DIALOG             102
#define IDD_ACCOUNT_INTRO               103
#define IDD_INTRO_ACCOUNT               103
#define IDD_COMPUTER_INTRO              104
#define IDD_INTRO_COMPUTER              104
#define IDD_SECURITY_INTRO              105
#define IDD_INTRO_SECURITY              105
#define IDD_UNDO_INTRO                  106
#define IDD_INTRO_UNDO                  106
#define IDD_FOR_REAL                    108
#define IDD_REBOOT                      108
#define IDD_UNDO                        109
#define IDD_DOMAIN_SELECTION            111
#define IDD_UNDO_END                    112
#define IDD_END_UNDO                    112
#define IDD_ACCOUNT_SELECTION           114
#define IDD_SELECTION                   114
#define IDD_COMPUTER_SELECTION          115
#define IDD_SECURITY_SELECTION          116
#define IDD_ACCOUNT_OPTIONS             117
#define IDD_COMPUTER_OPTIONS            118
#define IDD_SECURITY_OPTIONS            119
#define IDD_ACCOUNT_FURTHER             120
#define IDD_COMPUTER_FURTHER            121
#define IDD_SECURITY_END                122
#define IDD_END_SECURITY                122
#define IDD_CLOSED_SET                  123
#define IDD_COMPUTER_END                124
#define IDD_END_COMPUTER                124
#define IDD_ACCOUNT_END                 125
#define IDD_END_ACCOUNT                 125
#define IDR_OUPICKTYPE                  129
#define IDD_CONT_SELECTION              130
#define IDB_CONT                        132
#define IDB_OU                          133
#define IDB_OPEN_CONT                   134
#define IDB_OPEN_DIR                    135
#define IDB_OPEN_OU                     136
#define IDD_HISTORY                     138
#define IDD_SECURITY_EXCHANGE           139
#define IDD_EXCHANGE                    139
#define IDD_OPTIONS_EXCHANGE            139
#define IDD_GROUP_END                   140
#define IDD_END_GROUP                   140
#define IDD_GROUP_FURTHER               141
#define IDD_GROUP_INTRO                 142
#define IDD_INTRO_GROUP                 142
#define IDD_GROUP_SELECTION             144
#define IDD_CREDENTIALS                 145
#define IDD_SID_HISTORY                 147
#define IDD_ACCOUNT_OPTIONS2            148
#define IDD_ACCOUNT_OPTIONS3            149
#define IDD_ACCOUNT_OPTIONS4            150
#define IDD_ACCOUNT_OPTIONS5            151
#define IDD_ACCOUNT_OPTIONS6            152
#define IDD_ACCOUNT_OPTIONS7            153
#define IDD_ACCOUNT_OPTIONS8            154
#define IDD_ACCOUNT_OPTIONS9            155
#define IDD_ACCOUNT_OPTIONS10           156
#define IDD_ACCOUNT_OPTIONS11           157
#define IDD_ACCOUNT_OPTIONS12           158
#define IDC_ACCOUNT_BEGIN_TITLE         200
#define IDC_GROUP_BEGIN_TITLE           200
#define IDC_ACCOUNT_END_TITLE           201
#define IDC_GROUP_END_TITLE             201
#define IDC_COMPUTER_BEGIN_TITLE        202
#define IDC_COMPUTER_END_TITLE          203
#define IDC_SECURITY_BEGIN_TITLE        204
#define IDC_SECURITY_END_TITLE          205
#define IDC_UNDO_BEGIN_TITLE            206
#define IDC_UNDO_END_TITLE              207
#define IDC_GROUP2                      210
#define IDC_GROUP1                      211
#define IDC_NOCHANGE                    212
#define IDC_CHANGEIT                    212
#define IDC_EDIT_DOMAIN                 300
#define IDC_EDIT_DOMAIN2                301
#define IDC_LIST_MEMBERS1               302
#define IDC_LIST_MEMBERS2               303
#define IDC_LIST_MEMBERS3               304
#define IDC_OPEN_SELECTION1             305
#define IDC_OPEN_SELECTION2             305
#define IDC_BACKTRACK1                  306
#define IDC_BACKTRACK2                  306
#define IDC_EDIT_Container1             307
#define IDC_EDIT_Container2             307
#define IDC_OPEN_SELECTION3             308
#define IDC_BACKTRACK3                  309
#define IDC_EDIT_Container3             310
#define IDC_GO1                         311
#define IDC_GO2                         312
#define IDC_GO3                         313
#define IDR_MAINFRAME                   500
#define IDC_TREE1                       1000
#define IDC_HISTORY                     1001
#define IDC_EDIT1                       1001
#define IDC_HISTORY_TITLE               1002
#define IDC_ADDITIONAL_TRUSTING_DOMAIN  1002
#define IDC_COPY_USERS                  1039
#define IDC_COPY_GLOBAL_GROUPS          1040
#define IDC_COPY_GROUPS                 1040
#define IDC_COPY_LOCAL_GROUPS           1041
#define IDC_COPY_COMPUTERS              1042
#define IDC_COPY_OUS                    1043
#define IDC_COPY_UNIVERSAL_GROUPS       1044
#define IDC_SETTINGS3                   1045
#define IDC_ADD_SID_HISTORY             1050
#define IDC_REMOVE_EXISTING_USER_RIGHTS 1051
#define IDC_FIX_MEMBERSHIP              1051
#define IDC_COPY_CONTAINER_CONTENTS     1052
#define IDC_UPDATE_USER_RIGHTS          1053
#define IDC_DISABLE_SOURCE_ACCOUNTS     1054
#define IDC_REPLACE_EXISTING_ACCOUNTS   1055
#define IDC_DISABLE_COPIED_ACCOUNTS     1056
#define IDC_REPLACE_EXISTING_GROUP_MEMBERS 1057
#define IDC_DISABLE_NEITHER_ACCOUNT     1058
#define IDC_TRANSLATE_ROAMING_PROFILES  1059
#define IDC_RESELECT                    1060
#define IDC_ABORT                       1061
#define IDC_GATHER                      1062
#define IDC_UPDATE                      1062
#define IDC_SETTINGS1                   1063
#define IDC_SETTINGS                    1063
#define IDC_SETTINGS2                   1064
#define IDC_FILES2                      1065
#define IDC_ADD_SID_HISTORY2            1066
#define IDC_SHARES2                     1067
#define IDC_REMOVE_EXISTING_USER_RIGHTS2 1068
#define IDC_COPY_CONTAINER_CONTENTS2    1069
#define IDC_MAPI_PROFILE                1069
#define IDC_UPDATE_USER_RIGHTS2         1070
#define IDC_TRANSLATE_MAILBOXES         1070
#define IDC_TRANSLATE_CONTAINERS        1071
#define IDC_TARGET_OU                   1071
#define IDC_PREFIX                      1073
#define IDC_SUFFIX                      1074
#define IDC_CREDENTIALS_DOMAIN          1075
#define IDC_ADD_TO_GROUP                1075
#define IDC_CREDENTIALS_USERNAME        1076
#define IDC_ADD_TO_GROUP_ON_SOURCE_DOMAIN 1076
#define IDC_CREDENTIALS_PASSWORD        1077
#define IDC_PASSWORD_FILE               1077
#define IDC_DOMAINNAME                  1078
#define IDC_DISABLE_COPIED_ACCOUNTS2    1080
#define IDC_REPLACE_EXISTING_ACCOUNTS2  1081
#define IDC_PRINTERS2                   1082
#define IDC_DISABLE_SOURCE_ACCOUNTS2    1083
#define IDC_USER_RIGHTS2                1084
#define IDC_REPLACE_EXISTING_GROUP_MEMBERS2 1085
#define IDC_REGISTRY2                   1085
#define IDC_LOCAL_GROUPS2               1086
#define IDC_GENERATE_STRONG_PASSWORDS2  1087
#define IDC_USER_PROFILES2              1088
#define IDC_TRANSLATE_ROAMING_PROFILES2 1089
#define IDC_TRANSLATION_MODE_REPLACE2   1090
#define IDC_TRANSLATION_MODE_REMOVE2    1091
#define IDC_TRANSLATION_MODE_ADD2       1092
#define IDC_GATHER_INFORMATION2         1093
#define IDC_COPY_USERS2                 1100
#define IDC_COPY_GLOBAL_GROUPS2         1101
#define IDC_COPY_UNIVERSAL_GROUPS2      1102
#define IDC_COPY_LOCAL_GROUPS2          1103
#define IDC_COPY_COMPUTERS2             1104
#define IDC_FILES3                      2065
#define IDC_ADD_SID_HISTORY3            2066
#define IDC_SHARES3                     2067
#define IDC_REMOVE_EXISTING_USER_RIGHTS3 2068
#define IDC_COPY_CONTAINER_CONTENTS3    2069
#define IDC_UPDATE_USER_RIGHTS3         2070
#define IDC_DISABLE_COPIED_ACCOUNTS3    2080
#define IDC_REPLACE_EXISTING_ACCOUNTS3  2081
#define IDC_PRINTERS3                   2082
#define IDC_DISABLE_SOURCE_ACCOUNTS3    2083
#define IDC_USER_RIGHTS3                2084
#define IDC_REPLACE_EXISTING_GROUP_MEMBERS3 2085
#define IDC_LOCAL_GROUPS3               2086
#define IDC_GENERATE_STRONG_PASSWORDS3  2087
#define IDC_USER_PROFILES3              2088
#define IDC_TRANSLATE_ROAMING_PROFILES3 2089
#define IDC_TRANSLATION_MODE_REPLACE3   2090
#define IDC_TRANSLATION_MODE_REMOVE3    2091
#define IDC_TRANSLATION_MODE_ADD3       2092
#define IDC_GATHER_INFORMATION3         2093
#define IDC_REGISTRY3                   2093
#define IDC_SETTINGS4                   3000
#define IDC_SETTINGS5                   3001
#define IDC_UNDO_TASK                   3002
#define IDC_TRANSLATE_EXCHANGE          4000
#define IDC_BROWSE                      4001
#define IDC_GENERATE_STRONG_PASSWORDS   4003
#define IDB_WATERMARK                   4004
#define IDB_WATERMARK_USER              4004
#define IDC_SET_EXPIRATION              4005
#define IDB_HEADER                      4005
#define IDB_HEADER_ARROW                4005
#define IDC_SRC_EXPIRE_ACCOUNTS         4005
#define IDC_GENERATE_STRONG_PASSWORDS_NOT 4006
#define IDR_ACCELERATOR1                4006
#define IDC_EXPIRATION_DATE             4007
#define IDC_DISABLE_NEITHER_ACCOUNT2    4007
#define IDC_MIGRATE_GROUPS_OF_USERS     4008
#define IDC_SKIP_CONFLICTING_ACCOUNTS   4009
#define IDC_REPLACE_CONFLICTING_ACCOUNTS 4010
#define IDC_RENAME_CONFLICTING_ACCOUNTS 4011
#define IDC_RADIO4                      4012
#define IDC_RADIO_PREFIX                4012
#define IDC_RADIO2                      4013
#define IDC_RADIO_SUFFIX                4013
#define IDC_RADIO_SKIP                  4013
#define IDC_REBOOT                      4014
#define IDC_ADD_BUTTON                  4014
#define IDC_RADIO_NONE                  4014
#define IDC_CREDENTIALS_DOMAIN2         4015
#define IDC_CREDENTIALS_USERNAME2       4016
#define IDC_REMOVE_BUTTON               4016
#define IDC_CREDENTIALS_PASSWORD2       4017
#define IDC_FILES                       4018
#define IDB_WATERMARK_SECURITY          4018
#define IDC_SHARES                      4019
#define IDC_PRINTERS                    4020
#define IDB_WATERMARK_GROUP             4020
#define IDC_USER_RIGHTS                 4021
#define IDC_LOCAL_GROUPS                4022
#define IDB_WATERMARK_COMPUTER          4022
#define IDC_USER_PROFILES               4023
#define IDC_REGISTRY                    4024
#define IDC_TRANSLATION_MODE_REPLACE    4025
#define IDC_TRANSLATION_MODE_ADD        4026
#define IDB_HEADER_KEY                  4026
#define IDC_TRANSLATION_MODE_REMOVE     4027
#define IDC_COPY_GROUP_MEMBERS          4029
#define IDC_COPY_USER_RIGHTS            4030
#define IDB_WATERMARK_EXCHANGE          4030
#define IDC_DESCRIPTION_TITLE           4031
#define IDB_WATERMARK_REPORTING         4031
#define IDC_MIGRATION_END               4032
#define IDB_WATERMARK_SERVICE_ACCOUNT   4032
#define IDC_yo                          4033
#define IDB_HEADER_BOOK                 4033
#define IDC_DATE                        4034
#define IDD_TRANSLATION_SRC             4038
#define IDD_PROP_EXCLUSION              4039
#define IDC_COMBO2                      4044
#define IDC_RADIO_GATHER                4047
#define IDC_RADIO1                      4048
#define IDC_REFRESH                     4048
#define IDC_CHANGE                      4048
#define IDC_DONTCHANGE                  4048
#define IDC_MIG_PASSWORDS               4048
#define IDC_TRANS_FROM_MOT              4048
#define IDC_ROAMING_OR_SIDHISTORY       4048
#define IDC_RADIO3                      4049
#define IDC_NO_REFRESH                  4049
#define IDC_SRC_LEAVE_ACCOUNTS          4049
#define IDC_DATETIMEPICKER1             4050
#define IDC_TRANS_FROM_FILE2            4050
#define IDC_TRANS_FROM_FILE             4050
#define IDC_EXCLUDE_BUTTON              4053
#define IDC_EXCLUDE_BUTTON2             4055
#define IDC_UPDATE_BUTTON2              4056
#define IDC_SKIP                        4057
#define IDC_LIST_SERVICE                4058
#define IDC_LIST_SERVICE2               4059
#define IDC_END_TITLE                   4063
#define IDC_BEGIN_TITLE                 4065
#define IDC_HTML_TARGET                 4066
#define IDC_LIST_REPORTING              4069
#define IDC_STATIC_ID                   4071
#define IDC_LIST_RETRY                  4072
#define IDC_CANCEL                      4073
#define IDC_TOGGLE                      4074
#define IDC_MIGRATE                     4077
#define IDC_OK                          4078
#define IDC_PASSWORD                    4080
#define IDC_USERNAME                    4081
#define IDC_REMIGRATE_OBJECTS           4082
#define IDC_EXCHANGE_SERVER             4083
#define IDC_PRE                         4084
#define IDC_SUF                         4085
#define IDC_RADIO_SUF                   4086
#define IDC_RADIO_PRE                   4087
#define IDC_ADD_SOURCE                  4088
#define IDC_ADD_TARGET                  4090
#define IDC_CREATEMAPPING               4092
#define IDC_TARGET                      4095
#define IDC_BUTTON1                     4096
#define IDC_TARGET_GROUP                4097
#define IDC_SCROLLBAR1                  4099
#define IDC_MYTITLE                     4107
#define IDC_TEXT                        4111
#define IDC_THERENAMINGTITLE            4113
#define IDC_PASSWORD_EDIT               4114
#define IDC_PASSWORD_DC                 4118
#define IDC_MAPPING_FILE                4119
#define IDC_REMOVE_EXISTING_LOCATION    4120
#define IDC_PROPTREE                    4121
#define IDC_INCLUDEBTN                  4122
#define IDC_INCLUDELIST                 4123
#define IDC_EXCLUDELIST                 4124
#define IDC_EXCLUDEBTN                  4125
#define IDC_OBJECTCMBO                  4126
#define IDC_EXCLUDEPROPS                4127
#define IDC_DATEPICKER                  4133
#define IDC_TGT_ENABLE_ACCOUNT          4134
#define IDC_SRC_DISABLE_ACCOUNTS        4135
#define IDC_TGT_ENABLE_ACCOUNTS         4136
#define IDC_SRC_DISABLE_ACCOUNTS_LATER  4137
#define IDC_TGT_DISABLE_ACCOUNTS        4138
#define IDC_TGT_SAME_AS_SOURCE          4139
#define IDS_ACCOUNT_FURTHER             4464
#define IDD_USER_RIGHTS                 5001
#define IDD_RENAMING                    5002
#define IDD_DISABLE                     5003
#define IDD_PASSWORD                    5004
#define IDD_TRANSLATE_ROAMING_PROFILES  5005
#define IDD_OPTIONS                     5005
#define IDD_OU_SELECTION                5006
#define IDD_ADD_TO_GROUP                5007
#define IDD_REPLACE_EXISTING_GROUP_MEMBERS 5008
#define IDD_TRANSLATION                 5009
#define IDD_TRANSLATION_MODE            5010
#define IDD_CREDENTIALS2                5011
#define IDD_OPTIONS_GROUP               5012
#define IDD_INTRO_EXCHANGESERVICE       5014
#define IDD_INTRO_SERVICE               5015
#define IDD_INTRO_REPORTING             5016
#define IDD_INTRO_EXCHANGE              5017
#define IDD_INTRO_EXCHANGE_DIR          5017
#define IDD_END_SERVICE                 5018
#define IDD_END_EXCHANGESERVICE         5019
#define IDD_END_REPORTING               5020
#define IDD_END_EXCHANGE                5021
#define IDD_END_EXCHANGE_SRV            5021
#define IDD_SA_REFRESH                  5023
#define IDD_SA_GATHER                   5024
#define IDD_SA_GATHER_INITIAL           5025
#define IDD_SA_INFO                     5026
#define IDD_SA_INFO2                    5027
#define IDD_HTML_LOCATION               5028
#define IDS_DOMAIN                      10000
#define IDS_SID_HISTORY                 10001
#define IDS_SID_HISTORY_SUB             10002
#define IDS_USER_RIGHTS                 10003
#define IDS_USER_RIGHTS_SUB             10004
#define IDS_RENAMING                    10005
#define IDS_RENAMING_SUB                10006
#define IDS_RENAMING_SUB1               10006
#define IDS_DISABLE                     10007
#define IDS_DISABLE_SUB                 10008
#define IDS_PASSWORD                    10009
#define IDS_PASSWORD_SUB                10010
#define IDS_TRANSLATE_ROAMING_PROFILES  10011
#define IDS_OPTIONS                     10011
#define IDS_TRANSLATE_ROAMING_PROFILES_SUB 10012
#define IDS_OPTIONS_SUB                 10012
#define IDS_OU_SELECTION                10013
#define IDS_OU_SELECTION_SUB            10014
#define IDS_ADD_TO_GROUP                10015
#define IDS_ADD_TO_GROUP_SUB            10016
#define IDS_OPTIONS_GROUP               10017
#define IDS_OPTIONS_GROUP_SUB           10018
#define IDS_SELECTION                   10019
#define IDS_SELECTION_SUB               10020
#define IDS_REPLACE_EXISTING            10021
#define IDS_REPLACE_EXISTING_SUB        10022
#define IDS_TRANSLATION_MODE            10023
#define IDS_RENAMING_SUB3               10023
#define IDS_TRANSLATION_MODE_SUB        10024
#define IDS_TRANSLATION                 10025
#define IDS_TRANSLATION_SUB             10026
#define IDS_GROUP                       10027
#define IDS_GROUP_SUB                   10028
#define IDS_RENAMING_SUB2               10029
#define IDS_SERVICE_TITLE               10030
#define IDS_SERVICE                     10031
#define IDS_SERVICE_SUB                 10032
#define IDS_REPORTING_TITLE             10033
#define IDS_REPORTING                   10034
#define IDS_REPORTING_SUB               10035
#define IDS_OPTIONS_REPORTING           10036
#define IDS_OPTIONS_REPORTING_SUB       10037
#define IDD_OPTIONS_REPORTING           10038
#define IDS_OPTIONS_EXCHANGE            10038
#define IDS_OPTIONS_GROUPMAPPING_SUB    10038
#define IDS_EXCHANGE_TITLE              10039
#define IDD_END_RETRY                   10039
#define IDS_EXCHANGESERVICE_TITLE       10040
#define IDD_INTRO_RETRY                 10040
#define IDS_EXCHANGESERVICE             10041
#define IDD_RETRY                       10041
#define IDS_EXCHANGESERVICE_SUB         10042
#define IDD_SA_INFO_BUTTON              10042
#define IDB_DIR                         10043
#define IDS_OPTIONS_EXCHANGE_SUB        10043
#define IDD_COMMIT                      10043
#define IDS_SA_INFO                     10044
#define IDD_END_TRUST                   10044
#define IDS_SA_INFO_SUB                 10045
#define IDD_INTRO_TRUST                 10045
#define IDS_SA_GATHER                   10046
#define IDD_TRUST_INFO                  10046
#define IDS_SA_GATHER_SUB               10047
#define IDD_CREDENTIALS_TRUST           10047
#define IDS_SA_REFRESH                  10048
#define IDD_INTRO_EXCHANGE_SRV          10048
#define IDS_SA_REFRESH_SUB              10049
#define IDD_END_EXCHANGE_DIR            10049
#define IDS_HTML_LOCATION               10050
#define IDD_EXCHANGE_SELECTION          10050
#define IDS_HTML_LOCATION_SUB           10051
#define IDD_INTRO_GROUPMAPPING          10051
#define IDS_EXCHANGE_DIR_TITLE          10052
#define IDD_END_GROUPMAPPING            10052
#define IDD_GROUPMAPPING                10053
#define IDD_TARGET_GROUP                10053
#define IDS_EXCHANGE_SRV_TITLE          10054
#define IDD_OPTIONS_GROUPMAPPING        10054
#define IDS_EXCHANGE_SELECTION          10055
#define IDD_OPTIONS_FROM_USER           10055
#define IDS_EXCHANGE_SELECTION_SUB      10056
#define IDD_SELECTION1                  10056
#define IDS_VALID_STRING                10057
#define IDD_SELECTION2                  10057
#define IDS_VALID_REBOOT                10058
#define IDD_SELECTION3                  10058
#define IDD_SELECTION4                  10059
#define IDS_ACCOUNT_FURTHER_SUB         14464
#define IDS_DOMAIN_SUB                  20000
#define IDS_MSG_INPUT                   20001
#define IDS_MSG_ERROR                   20002
#define IDS_MSG_REPORT                  20003
#define IDS_MSG_DIRECTORY               20004
#define IDS_MSG_OBJECTPICKER            20005
#define IDS_MSG_OBJECTPICKER_SOURCE     20005
#define IDS_MSG_OU                      20006
#define IDS_MSG_CREDENTIALS             20007
#define IDS_MSG_OBJECT                  20008
#define IDS_MSG_UNIQUE                  20009
#define IDS_MSG_SOURCE                  20010
#define IDS_MSG_TARGET                  20011
#define IDS_MSG_TARGET_ADMIN            20012
#define IDS_MSG_SOURCE_ADMIN            20013
#define IDS_MSG_TARGET_NATIVE           20014
#define IDS_MSG_PATH                    20015
#define IDS_MSG_DC                      20016
#define IDC_MSG_CANCEL                  20017
#define IDS_MSG_FAILED                  20018
#define IDS_MSG_STRING                  20019
#define IDS_MSG_SERVICE                 20020
#define IDS_MSG_CREDENTIALS2            20021
#define IDS_MSG_TRUST                   20022
#define IDS_MSG_DIRECTORY1              20023
#define IDS_MSG_REBOOT                  20024
#define IDS_MSG_EXCHANGE                20025
#define IDS_HELPFILE                    20026
#define IDS_MSG_OBJECTPICKER_TARGET     20027
#define IDS_MSG_BLANK                   20028
#define IDS_MSG_WARNING                 20029
#define IDS_MSG_WARNING_LENGTH          20030
#define IDS_MSG_ERRORBUF                20031
#define IDS_MSG_PERMANENT_REMOVE        20032
#define IDS_MSG_ENABLE_TARGET           20033
#define IDS_MSG_ENABLE_SOURCE           20034
#define IDS_MSG_REGKEY                  20035
#define IDS_MSG_SID_HISTORY             20036
#define IDS_MSG_REBOOT_SID              20037
#define IDS_MSG_DOMAIN                  20038
#define IDS_MSG_TIME                    20039
#define IDS_MSG_LOCAL_GROUP             20040
#define IDS_MSG_TRUST_LOADER            20041
#define IDS_MSG_MESSAGE2                20042
#define IDS_MESSAGE_TWO                 20043
#define IDS_MSG_HELP                    20049
#define IDS_ACCOUNT_CLOSED              24464
#define IDS_ACCOUNT                     30000
#define ID_REMOVE_BUTTON                32771
#define IDS_ACCOUNT_CLOSED_SUB          34464
#define IDS_ACCOUNT_SUB                 40000
#define IDS_ACCOUNT_OPTIONS             40500
#define IDS_DOMAIN_REPORTING_SUB        44464
#define IDS_COLUMN_COMPUTER             50000
#define IDS_COLUMN_SERVICE              50001
#define IDS_COLUMN_ACCOUNT              50002
#define IDS_COLUMN_REPORT               50004
#define IDS_COLUMN_STATUS               50005
#define IDS_COLUMN_LASTGENERATEDON      50006
#define IDS_COLUMN_SERVER               50007
#define IDS_COLUMN_JOBFILE              50008
#define IDS_COLUMN_ACTION               50009
#define IDS_COLUMN_ACTIONID             50010
#define IDS_COLUMN_SKIPINCLUDE          50011
#define IDS_COLUMN_DOMAIN               50012
#define IDS_COLUMN_DIRECTION            50013
#define IDS_COLUMN_ATTRIBUTES           50014
#define IDS_COLUMN_EXISTSFORTARGET      50015
#define IDS_COLUMN_NAME                 50016
#define IDS_COLUMN_OBJECTPATH           50017
#define IDS_COLUMN_SAMNAME              50018
#define IDS_COLUMN_DISPLAYNAME          50019
#define IDS_COLUMN_DESCRIPTION          50020
#define IDS_COLUMN_OWNER                50021
#define IDS_COLUMN_FULLNAME             50022
#define IDS_NAME_CONFLICTS              50023
#define IDS_ACCOUNT_REFERENCES          50024
#define IDS_EXPIRED_COMPUTERS           50025
#define IDS_MIGRATED_COMPUTERS          50026
#define IDS_MIGRATED_ACCOUNTS           50027
#define IDS_INCLUDE                     50028
#define IDS_UPDATED                     50029
#define IDS_UPDATEFAILED                50030
#define IDS_SKIP                        50031
#define IDS_CREDENTIALS_EXCHANGE_SUB    50032
#define IDS_COLUMN_NAMECONFLICTS        50033
#define IDS_COLUMN_ACCOUNTREFERENCES    50034
#define IDS_COLUMN_EXPIREDCOMPUTERS     50035
#define IDS_COLUMN_MIGRATEDCOMPUTERS    50036
#define IDS_COLUMN_MIGRATEDACCOUNTS     50037
#define IDS_CANNOT                      50038
#define IDS_ACCOUNT_OPTIONS_SUB         60000
#define IDS_SEC_CRED                    60001
#define IDS_MSG_INVALID_TIME            60002
#define IDS_COLUMN_SERVICE_DISPLAY      65000
#define IDS_MSG_LOCAL                   65001
#define IDS_MSG_INVALIDOU               65002
#define IDS_MSG_INVALIDEXCHANGE         65003
#define IDS_MSG_FILE                    65004
#define IDS_MSG_MESSAGE                 65005
#define IDS_TEMPORARY                   65006
#define IDS_MSG_MESSAGE8                65006
#define IDS_TEMPORARY_SUB               65007
#define IDD_TEMPORARY                   65008
#define IDS_TRUST_DOMAIN                65009
#define IDS_SERVICE_CREDENTIALS         65010
#define IDS_SERVICE_DOMAIN              65011
#define IDS_CREDENTIALS_EXCHANGE        65012
#define IDS_CREDENTIALS_ACCOUNT         65013
#define IDS_DOMAIN_GROUP                65014
#define IDS_DOMAIN_ACCOUNT              65015
#define IDS_DOMAIN_COMPUTERS            65016
#define IDS_DOMAIN_SECURITY             65017
#define IDS_DOMAIN_DIRECTORY            65018
#define IDS_MSG_MESSAGE9                65019
#define IDS_PASSWORDS                   65024
#define IDS_MASKS                       65025
#define IDS_OUTBOUND                    65026
#define IDS_INBOUND                     65027
#define IDS_BIDIRECTIONAL               65028
#define IDS_DISABLED                    65029
#define IDS_ONE                         65030
#define IDS_TEN                         65031
#define IDS_SIXTY                       65032
#define IDS_FORMAT_MESSAGE              65033
#define IDS_SELECTOR                    65034
#define IDS_BROWSER                     65035
#define IDS_MSG_ERRORBUF2               65036
#define IDS_WIZARD_USER                 65037
#define IDS_WIZARD_GROUP                65038
#define IDS_WIZARD_COMPUTER             65039
#define IDS_WIZARD_SECURITY             65040
#define IDS_WIZARD_UNDO                 65041
#define IDS_WIZARD_RETRY                65042
#define IDS_WIZARD_REPORTING            65043
#define IDS_WIZARD_SERVICE              65044
#define IDS_WIZARD_EXCHANGEDIR          65045
#define IDS_WIZARD_EXCHANGESRV          65046
#define IDS_WIZARD_TRUST                65047
#define IDS_WIZARD_GROUPMAPPING         65048
#define IDS_MIGRATE_COMPUTER            65049
#define IDS_GATHER_SERVICEACCOUNT       65050
#define IDS_TRANSLATE_SECURITY          65051
#define IDS_GATHER_INFORMATION          65052
#define IDS_MSG_ERRORBUF3               65053
#define IDS_MSG_ERRORBUF20              65054
#define IDS_MSG_OBJECTPICKER_SOURCE2    65055
#define IDS_SEC_CRED2                   65056
#define IDS_MSG_SA_FAILED               65057
#define IDS_MYTITLE3                    65058
#define IDS_COMPUTER_RENAME_TITLE       65059
#define IDS_GRATUITIOUS_MESSAGE         65060
#define IDS_GRATUITIOUS_MESSAGE2        65061
#define IDS_MSG_EXTENSION_MAX_PRE       65062
#define IDS_MSG_EXTENSION_MAX_SUF       65063
#define IDS_INVALID_STRING              65065
#define IDS_MSG_INVALIDCHARS            65066
#define IDS_MSG_TRANSUR_ADDONLY         65067
#define IDS_MSG_TRANSUR_TITLE           65068
#define IDS_COLUMN_UPN                  65069
#define IDS_MSG_NOOBJECTS               65070
#define IDS_MSG_NOSOURCESID             65071
#define IDS_PASSWORD_FILE_HDR           65072
#define IDS_PASSWORD_DC_HDR             65073
#define IDS_MAPFILE_TITLE               65074
#define IDS_MAPFILE_EMPTY               65075
#define IDS_MAPFILE_MISSING             65076
#define IDS_PROPEX                      65077
#define IDS_PROPEX_SUB                  65078
#define IDS_MSG_PWDDC_NOT_READY         65079
#define IDS_MSG_PWDDC_DISABLED          65080
#define IDS_MSG_PWDDC_WRONG_ENCRYPTION_KEY 65081
#define IDS_MSG_PWD_WRONG_ENCRYPTION_PACK 65082
#define IDS_MIGRATION_RUNNING           65083
#define IDS_APP_CAPTION                 65084
#define IDS_OU_TOO_LONG                 65085
#define IDS_BROWSE_REPORT_TITLE         65086
#define IDS_PASSWORD_SUB_GRP            65087
#define IDS_PASSWORD_GRP                65088
#define IDS_SIDHISTORY_CTRL_TEXT        65089
#define IDS_ROAMING_PROFILE_CTRL_TEXT   65090
#define IDS_DISABLE_GRP                 65091
#define IDS_DISABLE_SUB_GRP             65092
#define IDS_ADMT_PROCESSES_STILL_RUNNING 65093

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        4041
#define _APS_NEXT_COMMAND_VALUE         32804
#define _APS_NEXT_CONTROL_VALUE         4143
#define _APS_NEXT_SYMED_VALUE           4000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__220B8985_4139_11D3_AF77_0090275A583D__INCLUDED_)
#define AFX_STDAFX_H__220B8985_4139_11D3_AF77_0090275A583D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
//#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC Automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <iads.h>
#include <adshlp.h>
#include <comdef.h>
#include <atlbase.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__220B8985_4139_11D3_AF77_0090275A583D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wizards.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\trstdlg.cpp ===
// TrusterDlg.cpp : implementation file
//

#include "stdafx.h"
#include "TrstDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTrusterDlg dialog


CTrusterDlg::CTrusterDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTrusterDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTrusterDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CTrusterDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_USERNAME, m_strUser);
	DDX_Text(pDX, IDC_PASSWORD, m_strPassword);
	DDX_Text(pDX, IDC_DOMAINNAME, m_strDomain);

	//{{AFX_DATA_MAP(CTrusterDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTrusterDlg, CDialog)
	//{{AFX_MSG_MAP(CTrusterDlg)
	ON_BN_CLICKED(IDC_OK, OnOK)
	ON_BN_CLICKED(IDC_CANCEL, OnCancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTrusterDlg message handlers


DWORD  CTrusterDlg::VerifyPassword(WCHAR  * sUserName, WCHAR * sPassword, WCHAR * sDomain)
{
	CWaitCursor wait;
	DWORD		   retVal = 0;
	CString     strDomainUserName;
	CString     localIPC;
   WCHAR         localMachine[MAX_PATH];
    NETRESOURCE nr;
   
   memset(&nr,0,(sizeof nr));

    strDomainUserName.Format(L"%s\\%s",sDomain,sUserName);
   // get the name of the local machine
   if (  GetComputerName(localMachine,&len) )
   {
      localIPC.Format(L"\\\\%s",localMachine);
      nr.dwType = RESOURCETYPE_ANY;
      nr.lpRemoteName = localIPC.GetBuffer(0);
      retVal = WNetAddConnection2(&nr,sPassword,strDomainUserName,0);
      if ( ! retVal )
      {
         retVal = WNetCancelConnection2(localIPC.GetBuffer(0),0,TRUE);
         if ( retVal )
            retVal = 0;
      }
      else if ( retVal == ERROR_SESSION_CREDENTIAL_CONFLICT )
      {
         // skip the password check in this case
         retVal = 0;
      }
   }
   else
   {
      retVal = GetLastError();
   }
   return 0;
}
void CTrusterDlg::OnOK() 
{
	toreturn =false;
	UpdateData(TRUE);
	m_strUser.TrimLeft();m_strUser.TrimRight();
	m_strDomain.TrimLeft();m_strDomain.TrimRight();
	m_strPassword.TrimLeft();m_strPassword.TrimRight();
	if (m_strUser.IsEmpty() || m_strDomain.IsEmpty())
	{
		CString c;
		c.LoadString(IDS_MSG_DOMAIN);
		CString d;
		d.LoadString(IDS_MSG_INPUT);
		MessageBox(c,d,MB_OK);
		toreturn =false;
	}
	else
	{
		DWORD returncode = VerifyPassword(m_strUser.GetBuffer(1000),m_strPassword.GetBuffer(1000),m_strDomain.GetBuffer(1000));
		m_strDomain.ReleaseBuffer(); m_strUser.ReleaseBuffer(); m_strPassword.ReleaseBuffer();
		if (returncode==ERROR_LOGON_FAILURE || m_strUser.IsEmpty())
		{
			CString e;
			err.ErrorCodeToText(returncode,1000,e.GetBuffer(1000));
			e.ReleaseBuffer();
			CString txt;
			swprintf(txt.GetBuffer(1000),L"%u",returncode);
			txt.ReleaseBuffer();
			CString text;
			text.LoadString(IDS_MSG_ERRORBUF);
			e += text;
			e+=txt;
			e+=L")";
			CString title;
			title.LoadString(IDS_MSG_ERROR);
			MessageBox(e,title,MB_OK);
			toreturn =false;
		}
		else
		{
			toreturn =true;
		}
	}
	CDialog::OnOK();	
}

void CTrusterDlg::OnCancel() 
{
	toreturn=false;
	// TODO: Add your control notification handler code here
	CDialog::OnCancel();
}

BOOL CTrusterDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	toreturn =false;
	if ( m_strDomain.IsEmpty() )
      return TRUE;
	else
		UpdateData(FALSE);
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\ouselect.cpp ===
// ContainerSelectionDlg.cpp : implementation file
//

#include "stdafx.h"
#include "OuSelect.h"
#include "iads.h"
#include <DSCLIENT.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CContainerSelectionDlg dialog

typedef int (CALLBACK * DSBROWSEFORCONTAINER)(PDSBROWSEINFOW dsInfo);
DSBROWSEFORCONTAINER DsBrowseForContainerX;

const BSTR sQuery = L"(|(objectClass=organizationalUnit) (objectClass=container))";
HTREEITEM root;

CContainerSelectionDlg::CContainerSelectionDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CContainerSelectionDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CContainerSelectionDlg)
	m_strCont = _T("");
	//}}AFX_DATA_INIT
}


void CContainerSelectionDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CContainerSelectionDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_TREE1, m_trOUTree);
	DDX_Text(pDX, IDC_EDIT1, m_strCont);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CContainerSelectionDlg, CDialog)
	//{{AFX_MSG_MAP(CContainerSelectionDlg)
	ON_BN_CLICKED(IDOK, OnOk)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREE1, OnSelchangedTree1)
	ON_NOTIFY(NM_DBLCLK, IDC_TREE1, OnDblclkTree1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CContainerSelectionDlg message handlers

void PadOUName(WCHAR * sPath)
{
   WCHAR                     sTemp[255];
   int                       off = 0;
   WCHAR                     sSpecial[] = L"#+\"<>=\\;,/";
   // Find the first = sign
   wcscpy(sTemp, sPath);
   for ( DWORD i = 0; i < wcslen(sTemp); i++ )
   {
      if ( wcschr(sSpecial, sTemp[i])  )
      {
         sPath[i + off] = L'\\';
         off++;
      }
      sPath[i + off] = sTemp[i];
   }
   sPath[i+off] = L'\0';
}

void UnPadOUName(WCHAR * sPath)
{
   WCHAR                     sTemp[255];
   int                       off = 0;
   DWORD                     i = 0;
   // Copy everything after the first = sign (if one exists)
   WCHAR * pTemp = wcschr(sPath, L'=');
   if ( pTemp )
   {
      wcscpy(sTemp, ++pTemp);
      off = wcslen(pTemp) - wcslen(sPath);
   }
   else
      wcscpy(sTemp, sPath);

   for ( ; i < wcslen(sTemp); i++ )
   {
      if ( sTemp[i] == L'\\'  )
      {
         i++;
         off++;
      }
      sPath[i - off] = sTemp[i];
   }
   sPath[i-off] = L'\0';
}

void CContainerSelectionDlg::OnOk() 
{
   CDialog::OnOK();	
}

BOOL CContainerSelectionDlg::OnInitDialog() 
{
//   CWaitCursor wait;
	CDialog::OnInitDialog();
/*   if ( m_strDomain.IsEmpty() )
      return TRUE;

   LoadImageList();

   root = m_trOUTree.InsertItem(m_strDomain, 0, 1);
   domain = _bstr_t(m_strDomain);
   ExpandCompletely(root, L"");
   ::SysFreeString(domain);
   FindContainer();
*/
   HMODULE           hMod = NULL;
   hMod = LoadLibrary(L"dsuiext.dll");
   if ( hMod )
   {
      WCHAR               sDomPath[255];
      wsprintf(sDomPath, L"LDAP://%s", (WCHAR*) m_strDomain);
      DsBrowseForContainerX = (DSBROWSEFORCONTAINER)GetProcAddress(hMod, "DsBrowseForContainerW");
      WCHAR             * sContPath, * sContName;
      BrowseForContainer(m_hWnd, sDomPath, &sContPath, &sContName);
      m_strCont = sContPath;
      CoTaskMemFree(sContPath);
      CoTaskMemFree(sContName);
      UpdateData(FALSE);
   }
   OnOK();
   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE

}

HRESULT CContainerSelectionDlg::PopulateContainer(
                                                  HTREEITEM tvItemParent,        //in- Item to expand
                                                  _bstr_t   sContName,           //in- Name of the container.
                                                  INetObjEnumeratorPtr pQuery    //in- Query Object
                                                 )
{
   HRESULT                   hr = E_FAIL;
   IEnumVARIANT            * pEnum = NULL;
   SAFEARRAY               * psaCols = NULL;
   SAFEARRAYBOUND            bd = { 2, 0 };
   LPWSTR                    pCols[] = { L"name", L"objectClass" };
   BSTR  HUGEP             * pData;
   _variant_t                var;
   DWORD                     dwFetch = 0;
   SAFEARRAY               * psaVals;
   _bstr_t                   sValName;
   _bstr_t                   sType;
   _variant_t              * pDataVar;
   _variant_t                varVal;
   WCHAR                     sTempName[255];
   WCHAR                     sPath[255];
   int                       img = 0;

   psaCols = SafeArrayCreate(VT_BSTR, 1, &bd);
   if ( psaCols )
   {
      hr = SafeArrayAccessData(psaCols, (void HUGEP **)&pData);
      if ( SUCCEEDED(hr) )
      {
         pData[0] = SysAllocString(pCols[0]);
         pData[1] = SysAllocString(pCols[1]);
      }
      SafeArrayUnaccessData(psaCols);
   }


   if ( SUCCEEDED(hr))
      hr = pQuery->raw_SetQuery(sContName, domain, sQuery, ADS_SCOPE_ONELEVEL, FALSE);

   if ( SUCCEEDED(hr) )
      hr = pQuery->raw_SetColumns(psaCols);

   if ( SUCCEEDED(hr))
      hr = pQuery->raw_Execute(&pEnum);

   if ( pEnum )
   {
      while ( pEnum->Next(1, &var, &dwFetch) == S_OK )
      {
         psaVals = V_ARRAY(&var);
         hr = SafeArrayAccessData(psaVals, (void**)&pDataVar);
         if ( SUCCEEDED(hr) )
         {
            varVal = pDataVar[0];
            if ( varVal.vt == VT_BSTR ) sValName = V_BSTR(&varVal);
            varVal = pDataVar[1];
            if ( varVal.vt == VT_BSTR ) sType = V_BSTR(&varVal);
            SafeArrayUnaccessData(psaVals);
         }


         if ( SUCCEEDED(hr) )
         {
            //
            wcscpy(sPath, (WCHAR*) sValName);
            PadOUName(sPath);
            if ( wcsicmp(sType, L"organizationalUnit") == 0 )
            {
               wsprintf(sTempName, L"OU=%s", sPath);
               img = 4;
            }
            else
            {
               wsprintf(sTempName, L"CN=%s", sPath);
               img = 2;
            }
            if ( wcsicmp(sTempName, L"CN=System") != 0 )
               m_trOUTree.InsertItem(sTempName, img, img+1, tvItemParent);
         }
      }
   }
   
   // Clean up
   if ( pEnum ) pEnum->Release();
   VariantInit(&var);
   return hr;
}


HRESULT CContainerSelectionDlg::ExpandCompletely(HTREEITEM tvItem, _bstr_t parentCont)
{
   HTREEITEM                 tvChild;
   WCHAR                     currCont[255];
   CString                   sContName;
   HRESULT                   hr = S_OK;
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));

   // First populate this container
   hr = PopulateContainer( tvItem, parentCont, pQuery);

   // Check if it has children. If it does then for each child call this function recursively
   if ( m_trOUTree.ItemHasChildren(tvItem) )
   {
      tvChild = m_trOUTree.GetChildItem(tvItem);
      while ( tvChild )
      {
         // Get the name of the 
         sContName = m_trOUTree.GetItemText(tvChild);
         if ( wcslen(parentCont) > 0 )
            wsprintf(currCont, L"%s,%s", sContName, (WCHAR*)parentCont);
         else
            wcscpy(currCont, sContName);
         ExpandCompletely(tvChild, currCont);
         tvChild = m_trOUTree.GetNextSiblingItem(tvChild);
      }
   }
   return hr;
}

BOOL CContainerSelectionDlg::LoadImageList()
{
 	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	// set up icon list for list box
   // use bitmaps 
   CBitmap           cont;
   CBitmap           ou;
   CBitmap           openCont;
   CBitmap           openOU;
   CBitmap           dir;
   CBitmap           dirOpen;
   
   COLORREF          cr = 0x000000;
   if (
      dir.LoadBitmap(IDB_DIR)
      && dirOpen.LoadBitmap(IDB_OPEN_DIR)
      && cont.LoadBitmap(IDB_CONT)
      && ou.LoadBitmap(IDB_OU)
      && openCont.LoadBitmap(IDB_OPEN_CONT)
      && openOU.LoadBitmap(IDB_OPEN_OU)
   )
   {
      cr = GetFirstBitmapPixel(this,IDB_CONT);
      ilist.Create(IDB_DIR, 16, 16, cr);
      ilist.Add(&dirOpen, cr);
      ilist.Add(&cont,cr);
      ilist.Add(&openCont,cr);
      ilist.Add(&ou,cr);
      ilist.Add(&openOU,cr);
      m_trOUTree.SetImageList(&ilist,TVSIL_NORMAL);
   }
   return TRUE;
}

COLORREF CContainerSelectionDlg::GetFirstBitmapPixel(CWnd * window,UINT idbBitmap)
{
   CBitmap     bmp;
   COLORREF    color = 0x00ffffff;
   
   if ( bmp.LoadBitmap(idbBitmap) )
   {
      // Get Device context       
      CDC                  * windowDC = window->GetDC();
      HDC                    hdcImage = ::CreateCompatibleDC(windowDC->m_hDC);
      CBitmap              * tempBmp = (CBitmap *)::SelectObject(hdcImage,(HBITMAP)bmp);
      // now get the pixel
      if ( windowDC && hdcImage && tempBmp )
      {
         color = GetPixel(hdcImage,0, 0);
      }
      if ( tempBmp )
         ::SelectObject(hdcImage,tempBmp);
      if ( hdcImage )
         ::DeleteObject(hdcImage);
   }
   return color;
}

void CContainerSelectionDlg::OnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult) 
{
   m_strCont = L"";
	HTREEITEM                 tvSelected, tvParent;
   NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
   tvSelected = m_trOUTree.GetSelectedItem();
   if ( tvSelected )
   {
      // We dont want to process the domain name in the Container name so go upto
      // the point where we have a parent. i.e. Child of the domain node.
      while( tvParent = m_trOUTree.GetParentItem(tvSelected) )
      {
         // Build the container list by walking up the tree.
         if ( m_strCont.IsEmpty() )
            m_strCont = m_trOUTree.GetItemText(tvSelected);
         else
            m_strCont = m_strCont + CString(L",") + m_trOUTree.GetItemText(tvSelected);
         tvSelected = tvParent;
      }
   }
   m_btnOK.EnableWindow(!m_strCont.IsEmpty());
   UpdateData(FALSE);
	*pResult = 0;
}

void CContainerSelectionDlg::OnDblclkTree1(NMHDR* pNMHDR, LRESULT* pResult) 
{
   UpdateData();
   if ( !m_strCont.IsEmpty() )
      OnOk();	
	*pResult = 0;
}

HRESULT CContainerSelectionDlg::FindContainer()
{
   CString                   strName;
   int                       ndx = 0, oldNdx = -1;
   // We can find the container iff there is one specified.
   if (!m_strCont.IsEmpty())
   {
      OpenContainer(m_strCont, root);
   }
   return S_OK;
}

HTREEITEM CContainerSelectionDlg::OpenContainer(CString strCont, HTREEITEM rootSub)
{
   int                       ndx = -1;
   CString                   strLeft, strRight;
   HTREEITEM                 tvItem = NULL;
   WCHAR                     sTemp[255];

   if ( !strCont.IsEmpty() && rootSub ) 
   {
      ndx = strCont.Find(L",", 0);
      if ( ndx > -1 )
      {
         // Get the right side of the comma string and Call this again to open the parent container.
         strLeft = strCont.Left(ndx);
         strRight = strCont.Mid(ndx + 1);
         tvItem = OpenContainer(strRight, rootSub);
         tvItem = OpenContainer(strLeft, tvItem);
      }
      else
      {
         // We have a container name so lets find it below rootSub node.
         wcscpy(sTemp,strCont);
         UnPadOUName(sTemp);
         strCont = CString(sTemp);
         tvItem = m_trOUTree.GetChildItem(rootSub);
         while (tvItem)
         {
            if ( m_trOUTree.GetItemText(tvItem) == strCont )
            {
               m_trOUTree.Expand(tvItem, 0);
               m_trOUTree.Select(tvItem, TVGN_CARET);
               break;
            }
            tvItem = m_trOUTree.GetNextSiblingItem(tvItem);
         }
      }
   }
   return tvItem;
}
 
HRESULT CContainerSelectionDlg::BrowseForContainer(HWND hWnd,//Handle to window that should own the browse dialog.
                    LPOLESTR szRootPath, //Root of the browse tree. NULL for entire forest.
                    LPOLESTR *ppContainerADsPath, //Return the ADsPath of the selected container.
                    LPOLESTR *ppContainerClass //Return the ldapDisplayName of the container's class.
                    )
{
   HRESULT hr = E_FAIL;
   DSBROWSEINFO dsbi;
   OLECHAR szPath[1000];
   OLECHAR szClass[MAX_PATH];
   DWORD result;
 
   if (!ppContainerADsPath)
     return E_POINTER;
 
   ::ZeroMemory( &dsbi, sizeof(dsbi) );
   dsbi.hwndOwner = hWnd;
   dsbi.cbStruct = sizeof (DSBROWSEINFO);
   dsbi.pszCaption = L"Browse for Container"; // The caption (titlebar text)
   dsbi.pszTitle = L"Select a target container."; //Text for the dialog.
   dsbi.pszRoot = szRootPath; //ADsPath for the root of the tree to display in the browser.
                   //Specify NULL with DSBI_ENTIREDIRECTORY flag for entire forest.
                   //NULL without DSBI_ENTIREDIRECTORY flag displays current domain rooted at LDAP.
   dsbi.pszPath = szPath; //Pointer to a unicode string buffer.
   dsbi.cchPath = sizeof(szPath)/sizeof(OLECHAR);//count of characters for buffer.
   dsbi.dwFlags = DSBI_RETURN_FORMAT | //Return the path to object in format specified in dwReturnFormat
               DSBI_RETURNOBJECTCLASS; //Return the object class
   dsbi.pfnCallback = NULL;
   dsbi.lParam = 0;
   dsbi.dwReturnFormat = ADS_FORMAT_X500; //Specify the format.
                       //This one returns an ADsPath. See ADS_FORMAT enum in IADS.H
   dsbi.pszObjectClass = szClass; //Pointer to a unicode string buffer.
   dsbi.cchObjectClass = sizeof(szClass)/sizeof(OLECHAR);//count of characters for buffer.
 
   //if root path is NULL, make the forest the root.
   if (!szRootPath)
     dsbi.dwFlags |= DSBI_ENTIREDIRECTORY;
 
 
 
   //Display browse dialog box.
   result = DsBrowseForContainerX( &dsbi ); // returns -1, 0, IDOK or IDCANCEL
   if (result == IDOK)
   {
       //Allocate memory for string
       *ppContainerADsPath = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(wcslen(szPath)+1));
       if (*ppContainerADsPath)
       {
           wcscpy(*ppContainerADsPath, szPath);
           //Caller must free using CoTaskMemFree
           hr = S_OK;
       }
       else
           hr=E_FAIL;
       if (ppContainerClass)
       {
           //Allocate memory for string
           *ppContainerClass = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(wcslen(szClass)+1));
       if (*ppContainerClass)
       {
           wcscpy(*ppContainerClass, szClass);
           //Call must free using CoTaskMemFree
           hr = S_OK;
       }
       else
           hr=E_FAIL;
       }
   }
   else
       hr = E_FAIL;
 
   return hr;
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\wnetutil.h ===
/*============================================================================*\
     Windows Network Domain Enumeration APIs.  These are a shell around the
     TNetDomainEnum class member function.  The handle used is nothing more
     than the "this" pointer to the instantiated object.
\*============================================================================*/
#include "TCHAR.H"

#define EA_MAX_DOMAIN_NAME_SIZE 30

typedef  struct  EaWNetDomainInfo
{
   TCHAR                   name[EA_MAX_DOMAIN_NAME_SIZE]; // domain name string
}  EaWNetDomainInfo;


//-----------------------------------------------------------------------------
// EaWNetDomainEnumOpen
//
// Creates the enumeration object and gives the caller the handle
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumOpen(
      void                ** handle        // out-opaque handle addr to enum
   );


//-----------------------------------------------------------------------------
// EaWNetDomainEnumNext
//
// Sets the domain string buffer to the next domain name in the enumeration
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumNext(
      void                 * handle       ,// i/o-opaque handle to enumeration
      EaWNetDomainInfo     * domain        // out-domain information structure
   );


//-----------------------------------------------------------------------------
// EaWNetDomainEnumFirst
//
// Sets the domain string buffer to the first domain name in the enumeration
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumFirst(
      void                 * handle       ,// i/o-opaque handle to enumeration
      EaWNetDomainInfo     * domain        // out-domain information structure
   );

//-----------------------------------------------------------------------------
// EaWNetDomainEnumClose
//
// Closes and destroys the enumeration handle and the objects it contains
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumClose(
      void                 * handle        // i/o-opaque handle addr to enum
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\wnetutil.cpp ===
#include "StdAfx.h"

#include "WNetUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define  VALD_NETDOMAIN_ENUM  1000666      // bad pointer validation signature
#define  DOM_BUFFER_SIZE      (32768)      // buffer size held allocated by class

class TNetDomainEnum
{
public:
                        TNetDomainEnum();
                        ~TNetDomainEnum();
   DWORD                GetMsNetProvider( NETRESOURCE * resourceInfo, DWORD infoSize );
   WCHAR *              GetNext();
   DWORD                GetLastRc() const { return rc; };
   BOOL                 IsValid() const { return vald == VALD_NETDOMAIN_ENUM; };

private:
   DWORD                     vald;
   HANDLE                    hEnum;
   NETRESOURCE             * resourceBuffer;
   DWORD                     rc,
                             totEntries,
                             nextEntry,
                             buffSize;
};


//-----------------------------------------------------------------------------
// TNetDomainEnum::TNetDomainEnum
//-----------------------------------------------------------------------------
TNetDomainEnum::TNetDomainEnum()
{
   //--------------------------
   // Initialize Class Members
   //--------------------------
   vald  = VALD_NETDOMAIN_ENUM;
   hEnum = INVALID_HANDLE_VALUE;

   // init currEntry > totEntries to force first-time read
   totEntries = 0;
   nextEntry = 1;

   resourceBuffer = (NETRESOURCE *)new char[DOM_BUFFER_SIZE];
   if ( !resourceBuffer )
   {
      rc = 1;
   }
   else
   {
      //-----------------------------------
      // Determine Network Provider to Use
      //-----------------------------------
      char                      buffer[16384];
      NETRESOURCE *             info = (NETRESOURCE *)buffer;

      rc = GetMsNetProvider( info, sizeof(buffer));
      if ( ! rc )
      {
         rc = WNetOpenEnum( RESOURCE_GLOBALNET,
                            RESOURCETYPE_ANY,
                            RESOURCEUSAGE_CONTAINER,
                            info,
                            &hEnum );
         delete [] info->lpProvider;
      }

      if ( rc )
      {
         if ( resourceBuffer )
         {
            delete resourceBuffer;
            resourceBuffer = NULL;
         }
      }
   }
}

//-----------------------------------------------------------------------------
// TNetDomainEnum::~TNetDomainEnum
//-----------------------------------------------------------------------------
TNetDomainEnum::~TNetDomainEnum()
{
   if ( hEnum != INVALID_HANDLE_VALUE )
   {
      WNetCloseEnum( hEnum );
      hEnum = INVALID_HANDLE_VALUE;
   }

   vald = 0;

   if ( resourceBuffer )
   {
      delete resourceBuffer;
   }
}

//-----------------------------------------------------------------------------
// GetMsNetProvider - Retrieves network resource information for the 'Microsoft
//                    Windows Network' provider.
//
// Input: A pointer to a NETRESOURCE structure that we will fill if we find a
//        resource meeting our needs.
//
// Output: 0 of we found a provider. resourceInfo populated in this case
//         non-zero if no provider. resourceInfo contents undefined
//-----------------------------------------------------------------------------
DWORD TNetDomainEnum::GetMsNetProvider( NETRESOURCE * resourceInfo, DWORD infoSize )
{
	_TCHAR szProvider[_MAX_PATH];
	DWORD cchProvider = sizeof(szProvider) / sizeof(szProvider[0]);

	DWORD dwError = WNetGetProviderName(WNNC_NET_LANMAN, szProvider, &cchProvider);

	if (dwError == NO_ERROR)
	{
		memset(resourceInfo, 0, infoSize);
		resourceInfo->dwScope = RESOURCE_GLOBALNET;
		resourceInfo->dwType = RESOURCETYPE_ANY;
		resourceInfo->dwDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
		resourceInfo->dwUsage = RESOURCEUSAGE_CONTAINER;
		resourceInfo->lpProvider = new _TCHAR[_tcslen(szProvider) + 1];

		if (resourceInfo->lpProvider)
		{
			_tcscpy(resourceInfo->lpProvider, szProvider);

			rc = NO_ERROR;
		}
		else
		{
			rc = ERROR_OUTOFMEMORY;
		}
	}
	else
	{
		rc = dwError;
	}

	return rc;
}


//-----------------------------------------------------------------------------
// TNetDomainEnum::GetNext()
//-----------------------------------------------------------------------------
WCHAR *
   TNetDomainEnum::GetNext()
{
   rc = (DWORD)-1;      // init rc to internal error before reset

   if ( hEnum == INVALID_HANDLE_VALUE )
      return NULL;
   if ( !resourceBuffer )
      return NULL;
   if ( nextEntry >= totEntries )
   {
      buffSize = DOM_BUFFER_SIZE;
      totEntries = (DWORD)-1;
      rc = WNetEnumResource(
                     hEnum,
                     &totEntries,
                     (void *)resourceBuffer,
                     &buffSize );
      if ( rc == 0 )
         nextEntry = 0;
      else
      {
         totEntries = 0;
         return NULL;
      }
   }
   else
      rc = 0;

   return  resourceBuffer[nextEntry++].lpRemoteName;
}


//#pragma page()
/*============================================================================*\
     Windows Network Domain Enumeration APIs.  These are a shell around the
     TNetDomainEnum class member function.  The handle used is nothing more
     than the "this" pointer to the instantiated object.
\*============================================================================*/

//-----------------------------------------------------------------------------
// EaWNetDomainEnumOpen
//
// Creates the enumeration object and gives the caller the handle
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumOpen(
      void                ** handle        // out-opaque handle addr to enum
   )
{
   TNetDomainEnum          * domainEnum = new TNetDomainEnum();

   *handle = (PVOID)domainEnum;
   if ( ! domainEnum )
      return (DWORD)-1;                    // internal error

   return domainEnum->GetLastRc();
}


//-----------------------------------------------------------------------------
// EaWNetDomainEnumNext
//
// Sets the domain string buffer to the next domain name in the enumeration
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumNext(
      void                 * handle       ,// i/o-opaque handle to enumeration
      EaWNetDomainInfo     * domain        // out-domain information structure
   )
{
   TNetDomainEnum          * domainEnum = (TNetDomainEnum *)handle;
   WCHAR                   * str;

   if ( !domainEnum  ||  !domainEnum->IsValid() )
      return ERROR_INVALID_PARAMETER;      // caller's error - invalid handle

   str = domainEnum->GetNext();

   if ( !str )
   {
      domain->name[0] = _T('\0');
   }
   else
   {
      wcsncpy(domain->name, str, EA_MAX_DOMAIN_NAME_SIZE);
      domain->name[EA_MAX_DOMAIN_NAME_SIZE - 1] = _T('\0');
   }

   return domainEnum->GetLastRc();
}


//-----------------------------------------------------------------------------
// EaWNetDomainEnumFirst
//
// Sets the domain string buffer to the first domain name in the enumeration
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumFirst(
      void                 * handle       ,// i/o-opaque handle to enumeration
      EaWNetDomainInfo     * domain        // out-domain information structure
   )
{
   // We're cheating here by making the first/next the same.  We probably want to
   // change this eventually to make "first" really properly reset the enum to the
   // start
   return EaWNetDomainEnumNext(handle, domain);
}

//-----------------------------------------------------------------------------
// EaWNetDomainEnumClose
//
// Closes and destroys the enumeration handle and the objects it contains
//-----------------------------------------------------------------------------
DWORD _stdcall                             // ret-0 or error code
   EaWNetDomainEnumClose(
      void                 * handle        // i/o-opaque handle addr to enum
   )
{
   TNetDomainEnum          * domainEnum = (TNetDomainEnum *)handle;

   if ( !domainEnum  ||  !domainEnum->IsValid() )
      return ERROR_INVALID_PARAMETER;      // caller's error - invalid handle

   delete domainEnum;

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\wizards.h ===
// wizards.h : main header file for the WIZARDS DLL
//
#pragma once

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "Callback.h"
/////////////////////////////////////////////////////////////////////////////
// CWizardsApp
// See wizards.cpp for the implementation of this class
//
extern "C" __declspec(dllexport) int runWizard(int, HWND);

class CWizardsApp : public CWinApp
{
public:
	CWizardsApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWizardsApp)
	//}}AFX_VIRTUAL
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//{{AFX_MSG(CWizardsApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

int doAccount();
int doComputer();
int doSecurity();
int doGroup();
int doService();
int doExchangeDir();
int doExchangeSrv();
int doReporting();
int doUndo();		
int doRetry();		
int doTrust();
int doGroupMapping();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\wizards.cpp ===
// wizards.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "wizards.h"
#include <MigrationMutex.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



IVarSet *			pVarSet;  
IVarSet *			pVarSetUndo; 
IVarSet *			pVarSetService;
IIManageDB *		db;
UINT g_cfDsObjectPicker;
IDsObjectPicker *pDsObjectPicker;
IDataObject *pdo;
IDsObjectPicker *pDsObjectPicker2;
IDataObject *pdo2;

int migration;
CEdit pEdit;
CComModule _Module;
CListCtrl m_listBox;
CListCtrl m_cancelBox;
CListCtrl m_reportingBox;
CListCtrl m_serviceBox;
CComboBox m_rebootBox;
CString sourceNetbios;
CString targetNetbios;
CListCtrl m_trustBox;
CString sourceDNS;
CString targetDNS;
CComboBox sourceDrop;
CComboBox additionalDrop;
CComboBox targetDrop;
StringLoader 			gString;
TErrorDct 			err;
TError				& errCommon = err;
bool alreadyRefreshed;
DSBROWSEFORCONTAINER DsBrowseForContainerX;
BOOL gbNeedToVerify=FALSE;
_bstr_t yes,no;
CString lastInitializedTo;
bool clearCredentialsName;
CString sourceDC;
CStringList DCList;
CMapStringToString		PropIncMap1;
CMapStringToString		PropExcMap1;
CMapStringToString		PropIncMap2;
CMapStringToString		PropExcMap2;
CString					sType1;
bool bChangedMigrationTypes;
bool bChangeOnFly;
CString targetServer;
HWND s_hParentWindow;

/////////////////////////////////////////////////////////////////////////////
// CWizardsApp

BEGIN_MESSAGE_MAP(CWizardsApp, CWinApp)
	//{{AFX_MSG_MAP(CWizardsApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizardsApp construction

CWizardsApp::CWizardsApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

// Forward decleration for this function
HRESULT BrowseForContainer(HWND hWnd,//Handle to window that should own the browse dialog.
                    LPOLESTR szRootPath, //Root of the browse tree. NULL for entire forest.
                    LPOLESTR *ppContainerADsPath, //Return the ADsPath of the selected container.
                    LPOLESTR *ppContainerClass //Return the ldapDisplayName of the container's class.
                    );

/////////////////////////////////////////////////////////////////////////////
// The one and only CWizardsApp object
CWizardsApp theApp;
/////////////////////////////////////////////////////////////////////////////
// CDeletemeApp initialization
BOOL CWizardsApp::InitInstance()
{
	ATLTRACE(_T("{wizards.dll}CWizardsApp::InitInstance() : m_hInstance=0x%08X\n"), m_hInstance);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
	return bInit;
}

int CWizardsApp::ExitInstance()
{
	ATLTRACE(_T("{wizards.dll}CWizardsApp::ExitInstance() : m_hInstance=0x%08X\n"), m_hInstance);
	return CWinApp::ExitInstance();
}

//extern "C" __declspec(dllexport) int runWizard(int whichWizard, HWND hParentWindow) 
int LocalRunWizard(int whichWizard, HWND hParentWindow)
{
	//declare variables
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CMigrationMutex mutexMigration(ADMT_MUTEX);

	if (mutexMigration.ObtainOwnership(0) == false)
	{
		CString strCaption;
		strCaption.LoadString(IDS_APP_CAPTION);
		CString strMessage;
		strMessage.LoadString(IDS_MIGRATION_RUNNING);

		CWnd* pWnd = theApp.GetMainWnd();

		if (pWnd)
		{
			pWnd->MessageBox(strMessage, strCaption);
		}
		else
		{
			MessageBox(NULL, strMessage, strCaption, MB_OK);
		}

		GetError(0);

		return 0;
	}

	int result=0;
yes=GET_BSTR(IDS_YES);no=GET_BSTR(IDS_No);
	migration =whichWizard;
   gbNeedToVerify = CanSkipVerification();
	//migration varset
	IVarSetPtr  pVs(__uuidof(VarSet));
	HRESULT hr = pVs->QueryInterface(IID_IVarSet, (void**) &pVarSet);
	
	//undo varset
	IVarSetPtr  pVs2(__uuidof(VarSet));
	hr = pVs2->QueryInterface(IID_IVarSet, (void**) &pVarSetUndo);

	IVarSetPtr  pVs4(__uuidof(VarSet));
	hr = pVs4->QueryInterface(IID_IVarSet, (void**) &pVarSetService);

	//database
	IIManageDBPtr	pDb;
	hr = pDb.CreateInstance(__uuidof(IManageDB));

	if (FAILED(hr))
	{
		return 0;
	}

	hr = pDb->QueryInterface(IID_IIManageDB, (void**) &db);



	IUnknown * pUnk;
	
	if (migration!=w_undo)
		pVarSet->QueryInterface(IID_IUnknown, (void**) &pUnk);
	else 
		pVarSetUndo->QueryInterface(IID_IUnknown, (void**) &pUnk);
	db->GetSettings(&pUnk);
	pUnk->Release();

	if (migration!= w_undo)
	{
		IVarSetPtr  leaves;
		hr=pVarSet->raw_getReference(L"Accounts",&leaves);
		if (SUCCEEDED(hr))
			leaves->Clear();
		hr = pVarSet->raw_getReference(L"Servers",&leaves);
		if (SUCCEEDED(hr))
			leaves->Clear();
		
		g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
		pDsObjectPicker = NULL;
		pdo = NULL;
		hr = CoCreateInstance(CLSID_DsObjectPicker,NULL,CLSCTX_INPROC_SERVER,IID_IDsObjectPicker,(void **) &pDsObjectPicker);
		sourceNetbios = L"";
		targetNetbios = L"";
      sourceDNS = L"";
      targetDNS = L"";
		if (FAILED(hr)) return 0;
	}

	if (migration==w_groupmapping)
	{
		pDsObjectPicker2 = NULL;
		pdo2 = NULL;
		hr = CoCreateInstance(CLSID_DsObjectPicker,NULL,CLSCTX_INPROC_SERVER,IID_IDsObjectPicker,(void **) &pDsObjectPicker2);
		if (FAILED(hr)) return 0;
	}

	s_hParentWindow = hParentWindow;

	switch (whichWizard)
	{
	case w_account:
		result =doAccount();
		break;
	case w_group:
		result =doGroup();
		break;
	case w_computer: 
		result =doComputer();
		break;
	case w_security: 
		result =doSecurity();			
		break;
	case w_service:
		result =doService();
		break;
	case w_exchangeDir:
		result =doExchangeDir();
		break;
	case w_exchangeSrv:
		result =doExchangeSrv();
		break;
	case w_reporting: 
		result =doReporting();
		break;
	case w_undo: 
		result =doUndo();			
		break;
	case w_retry: 
		result =doRetry();			
		break;
	case w_trust: 
		result =doTrust();			
		break;
	case w_groupmapping: 
		result =doGroupMapping();			
		break;
	}	

	s_hParentWindow = 0;

	m_listBox.Detach();
	m_trustBox.Detach();
	m_reportingBox.Detach();
	m_cancelBox.Detach();
	m_serviceBox.Detach();

	sourceDrop.Detach();
	additionalDrop.Detach();
	targetDrop.Detach();
	m_rebootBox.Detach();

	if (pDsObjectPicker2)
	{
		pDsObjectPicker2->Release();
		pDsObjectPicker2 = NULL;
	}

	if (pDsObjectPicker)
	{
		pDsObjectPicker->Release();
		pDsObjectPicker = NULL;
	}

	if (pVarSet)
	{
		pVarSet->Release();
		pVarSet = NULL;
	}

	if (pVarSetService)
	{
		pVarSetService->Release();
		pVarSetService = NULL;
	}

	if (pVarSetUndo)
	{
		pVarSetUndo->Release();
		pVarSetUndo = NULL;
	}

	if (db)
	{
		db->Release();
		db = NULL;
	}

	mutexMigration.ReleaseOwnership();

	return result;
}


extern "C" __declspec(dllexport) int runWizard(int whichWizard, HWND hParentWindow)
{
   return LocalRunWizard(whichWizard, hParentWindow);
}


void setpdatavars(SHAREDWIZDATA& wizdata,LOGFONT& TitleLogFont)
{

	WCHAR filename[500];
	BOOL  yo = GetDirectory(filename);
	CString temp=filename;
	CString temp2 =filename;

	put(DCTVS_Options_MaxThreads, L"20");
	put(DCTVS_Options_DispatchLog, _bstr_t(temp+L"Logs\\dispatch.log"));


	put(DCTVS_Options_Logfile, _bstr_t(temp+L"Logs\\Migration.log"));	
	pVarSet->put(L"PlugIn.0",L"");
	put(DCTVS_Options_AppendToLogs,yes);
	put(DCTVS_Reports_Generate,no);
	wizdata.hTitleFont = CreateFontIndirect(&TitleLogFont);
	wizdata.renameSwitch=1;
	wizdata.refreshing = false;
	wizdata.prefixorsuffix =false;
	wizdata.expireSwitch =false;
	wizdata.someService =false;
	alreadyRefreshed = false;
	wizdata.memberSwitch =false;
	wizdata.proceed=false;
	for (int i =0;i<6;i++)wizdata.sort[i]=true;
	wizdata.sourceIsNT4=true;
	wizdata.secWithMapFile=false;
	bChangedMigrationTypes=false;
	bChangeOnFly = false;
       //make sure we don't hide the progress dialogs if set by scripting
	put(DCTVS_Options_AutoCloseHideDialogs, L"0");
	put(DCTVS_Options_DontBeginNewLog, no);//always start a new log
	   //don't use any specific server yet
    put(DCTVS_Options_TargetServerOverride, L"");


	switch (migration)
	{
	case w_account:
		put(DCTVS_AccountOptions_CopyUsers, yes);
		put(DCTVS_AccountOptions_CopyLocalGroups, no);
		put(DCTVS_AccountOptions_CopyComputers, no);
		put(DCTVS_AccountOptions_CopyContainerContents, no);
		put(DCTVS_Security_TranslateContainers, L"");
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_USER));
		put(DCTVS_Options_Wizard, L"user");
		put(DCTVS_AccountOptions_FixMembership, yes);
//		put(DCTVS_AccountOptions_MoveReplacedAccounts, no);
		break;
	case w_group: 
		put(DCTVS_AccountOptions_CopyLocalGroups, yes);
		put(DCTVS_AccountOptions_CopyComputers, no);
		put(DCTVS_AccountOptions_CopyMemberOf,no);
		put(DCTVS_Security_TranslateContainers, L"");
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_GROUP));
		put(DCTVS_Options_Wizard, L"group");
		put(DCTVS_AccountOptions_FixMembership, yes);
		break;
	case w_computer: 
		put(DCTVS_AccountOptions_CopyUsers, no);
		put(DCTVS_AccountOptions_CopyLocalGroups, no);
		put(DCTVS_AccountOptions_CopyComputers, yes);
		put(DCTVS_Security_TranslateContainers, L"");
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_COMPUTER));
		put(DCTVS_Options_Wizard, L"computer");
		put(DCTVS_AccountOptions_AddSidHistory,L"");
		put(DCTVS_AccountOptions_CopyContainerContents, no);
		put(DCTVS_AccountOptions_CopyMemberOf, no);
		put(DCTVS_AccountOptions_CopyLocalGroups, no);
		put(DCTVS_AccountOptions_FixMembership, yes);
		break;
	case w_security:
		put(DCTVS_AccountOptions_CopyUsers, no);
		put(DCTVS_AccountOptions_CopyLocalGroups, no);
		put(DCTVS_AccountOptions_CopyComputers, no);
		put(DCTVS_Security_TranslateContainers, L"");
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_SECURITY));
		put(DCTVS_Options_Wizard, L"security");
		pVarSet->put(L"PlugIn.0",L"None");
		put(DCTVS_AccountOptions_AddSidHistory,L"");
		put(DCTVS_AccountOptions_SecurityInputMOT, yes);
		break;
	case w_undo:
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_UNDO));
		put(DCTVS_Options_Wizard, L"undo");
		put(DCTVS_Security_TranslateContainers, L"");
		break;
	case w_retry:
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_RETRY));
		put(DCTVS_Options_Wizard, L"retry");
		put(DCTVS_Security_TranslateContainers, L"");
		break;
	case w_reporting:
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_REPORTING));
		put(DCTVS_Options_Wizard, L"reporting");
		put(DCTVS_GatherInformation, yes);
		put(DCTVS_Security_TranslateContainers, L"");
		pVarSet->put(L"PlugIn.0",L"None");
		break;
	case w_service:
		{
			_bstr_t t= get(DCTVS_AccountOptions_PasswordFile);
			CString yo=(WCHAR *) t;
			yo.TrimLeft();yo.TrimRight();
			if (yo.IsEmpty())
			{	
				CString toinsert;
				GetDirectory(toinsert.GetBuffer(1000));
				toinsert.ReleaseBuffer();
				toinsert+="Logs\\passwords.txt";
				put(DCTVS_AccountOptions_PasswordFile,_bstr_t(toinsert));
			}
			put(DCTVS_Security_TranslateContainers, L"");
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_SERVICE));
		put(DCTVS_Options_Wizard, L"service");
		break;
		}
	case w_exchangeDir:
		put(DCTVS_AccountOptions_AddSidHistory,L"");
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_EXCHANGEDIR));
		put(DCTVS_Options_Wizard, L"exchangeDir");
		break;
	case w_exchangeSrv:
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_EXCHANGESRV));
		put(DCTVS_Options_Wizard, L"exchangeDrv");
		break;
	case w_trust:
		put(DCTVS_Security_TranslateContainers, L"");
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_TRUST));
		put(DCTVS_Options_Wizard, L"trust");
		break;
	case w_groupmapping:
//*		put(DCTVS_Options_Wizard, GET_BSTR1(IDS_WIZARD_GROUPMAPPING));
		put(DCTVS_Options_Wizard, L"groupmapping");
		put(DCTVS_AccountOptions_ReplaceExistingAccounts, yes);
		put(DCTVS_AccountOptions_CopyContainerContents, no);
		put(DCTVS_AccountOptions_CopyUsers, no);
		put(DCTVS_AccountOptions_CopyLocalGroups, yes);
		put(DCTVS_AccountOptions_CopyComputers, L"");
		put(DCTVS_AccountOptions_ReplaceExistingGroupMembers, no);
		put(DCTVS_Security_TranslateContainers, L"");
		put(DCTVS_AccountOptions_FixMembership, yes);
		break;
	}
}

void intropage(HPROPSHEETPAGE	ahpsp[],PROPSHEETPAGE& psp,int dialog,
			  int pagenum,SHAREDWIZDATA& wizdata,int dialogtitle,DLGPROC p)
{
	psp.dwSize =		sizeof(psp);
	psp.dwFlags =		PSP_DEFAULT|PSP_HIDEHEADER|PSP_USETITLE |PSP_HASHELP;
	psp.hInstance =		AfxGetInstanceHandle();
	psp.lParam =		(LPARAM) &wizdata; 
	psp.pszTitle =		MAKEINTRESOURCE(dialogtitle);
	psp.pszTemplate =	MAKEINTRESOURCE(dialog);
	psp.pfnDlgProc =	p;
	ahpsp[pagenum] =	CreatePropertySheetPage(&psp);
	
}

void definepage(HPROPSHEETPAGE	ahpsp[],PROPSHEETPAGE& psp,int title,int subtitle,int dialog,
			   int pagenum,int dialogtitle,DLGPROC p)
{
	psp.dwFlags =			PSP_DEFAULT|PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE|PSP_USETITLE|PSP_HASHELP;
	psp.pszTitle =			MAKEINTRESOURCE(dialogtitle);
	psp.pszHeaderTitle =	MAKEINTRESOURCE(title);
	psp.pszHeaderSubTitle =	MAKEINTRESOURCE(subtitle);
	psp.pszTemplate =		MAKEINTRESOURCE(dialog);
	psp.pfnDlgProc =	p;
	ahpsp[pagenum] =		CreatePropertySheetPage(&psp);
}

void endpage(HPROPSHEETPAGE	ahpsp[],PROPSHEETPAGE& psp,int dialog,int pagenum,int dialogtitle,DLGPROC p)
{
	psp.dwFlags =		PSP_DEFAULT|PSP_HIDEHEADER|PSP_USETITLE|PSP_HASHELP;
	psp.pszTitle =		MAKEINTRESOURCE(dialogtitle);
	psp.pszTemplate =	MAKEINTRESOURCE(dialog);
	psp.pfnDlgProc =	p;
	ahpsp[pagenum] =			CreatePropertySheetPage(&psp);
}

int defineSheet(HPROPSHEETPAGE	ahpsp[],PROPSHEETHEADER& psh,int numpages,SHAREDWIZDATA& wizdata
				 ,int headerGraphic,int waterGraphic)
{
	psh.dwSize =			sizeof(psh);
	psh.hInstance =			AfxGetInstanceHandle();
	psh.hwndParent =		s_hParentWindow;
	psh.phpage =			ahpsp;
	psh.dwFlags =		REAL_PSH_WIZARD97|PSH_WATERMARK|PSH_HEADER;
	psh.pszbmWatermark =	MAKEINTRESOURCE(waterGraphic);
	psh.pszbmHeader	=	MAKEINTRESOURCE(headerGraphic);
	psh.nStartPage =		0;
	psh.nPages =			numpages;
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
	LOGFONT TitleLogFont = ncm.lfMessageFont;
	TitleLogFont.lfWeight = FW_BOLD;
	CString s;
	s.LoadString(IDS_TEXT);

	lstrcpy(TitleLogFont.lfFaceName, s.GetBuffer(1000));
	s.ReleaseBuffer();
	HDC hdc = GetDC(NULL); //gets the screen DC
	INT FontSize = 12;
	TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
	setpdatavars(wizdata,TitleLogFont);
	ReleaseDC(NULL, hdc);
//	int a=PropertySheet(&psh);
	int a=(int)PropertySheet(&psh);
	DeleteObject(wizdata.hTitleFont);
	return a;
}
int doTrust()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[4] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_TRUST,0,wizdata,IDS_TRUST_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_TRUST_DOMAIN,IDD_DOMAIN_SELECTION,1,IDS_TRUST_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_TRUST,IDS_TRUST_SUB,IDD_TRUST_INFO,2,IDS_TRUST_TITLE,	IntTrustProc);
	endpage(ahpsp,psp,IDD_END_TRUST,3,IDS_TRUST_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,4,wizdata,IDB_HEADER_KEY,IDB_WATERMARK_SECURITY);
	return result;
}
int doGroupMapping()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[9] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_GROUPMAPPING,0,wizdata,IDS_GROUPMAPPING_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_GROUPMAPPING_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_SUB,IDD_DOMAIN_SELECTION,2,IDS_GROUPMAPPING_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_GROUP_MAPPING,IDS_GROUP_MAPPING_SUB,IDD_SELECTION2,3,IDS_GROUPMAPPING_TITLE,IntSelectionProc);
	definepage(ahpsp,psp,IDS_TARGET_GROUP,IDS_TARGET_GROUP_SUB,IDD_TARGET_GROUP,4,IDS_GROUPMAPPING_TITLE,IntTargetGroupProc);
	definepage(ahpsp,psp,IDS_OU_SELECTION,IDS_OU_SELECTION_SUB,IDD_OU_SELECTION,5,IDS_GROUPMAPPING_TITLE,IntOuSelectionProc);
	definepage(ahpsp,psp,IDS_OPTIONS_GROUP,IDS_OPTIONS_GROUPMAPPING_SUB,IDD_OPTIONS_GROUPMAPPING,6,IDS_GROUPMAPPING_TITLE,IntOptionsGroupMappingProc);
	definepage(ahpsp,psp,IDS_CREDENTIALS_ACCOUNT,IDS_CREDENTIALS_SUB,IDD_CREDENTIALS,7,IDS_GROUPMAPPING_TITLE,IntCredentialsProc);
	endpage(ahpsp,psp,IDD_END_GROUPMAPPING,8,IDS_GROUPMAPPING_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,9,wizdata,IDB_HEADER_KEY,IDB_WATERMARK_GROUP);
	return result;
}


int doAccount()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[13] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_ACCOUNT,0,wizdata,IDS_ACCOUNT_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_ACCOUNT_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_ACCOUNT,IDD_DOMAIN_SELECTION,2,IDS_ACCOUNT_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_ACCOUNT,IDS_ACCOUNT_SUB,IDD_SELECTION3,3,IDS_ACCOUNT_TITLE,IntSelectionProc);
	definepage(ahpsp,psp,IDS_OU_SELECTION,IDS_OU_SELECTION_SUB,IDD_OU_SELECTION,4,IDS_ACCOUNT_TITLE,IntOuSelectionProc);
	definepage(ahpsp,psp,IDS_PASSWORD,IDS_PASSWORD_SUB,IDD_PASSWORD,5,IDS_ACCOUNT_TITLE,IntPasswordProc);
	definepage(ahpsp,psp,IDS_DISABLE,IDS_DISABLE_SUB,IDD_DISABLE,6,IDS_ACCOUNT_TITLE,IntDisableProc);
	definepage(ahpsp,psp,IDS_CREDENTIALS_ACCOUNT,IDS_CREDENTIALS_SUB,IDD_CREDENTIALS,7,IDS_ACCOUNT_TITLE,IntCredentialsProc);
	definepage(ahpsp,psp,IDS_OPTIONS,IDS_OPTIONS_SUB,IDD_OPTIONS,8,IDS_ACCOUNT_TITLE,IntOptionsProc);
	definepage(ahpsp,psp,IDS_PROPEX,IDS_PROPEX_SUB,IDD_PROP_EXCLUSION,9,IDS_ACCOUNT_TITLE,IntPropExclusionProc);
	definepage(ahpsp,psp,IDS_RENAMING,IDS_RENAMING_SUB1,IDD_RENAMING,10,IDS_ACCOUNT_TITLE,IntRenameProc);
	definepage(ahpsp,psp,IDS_SA_INFO,IDS_SA_INFO_SUB,IDD_SA_INFO,11,IDS_ACCOUNT_TITLE,IntServiceInfoProc);
	endpage(ahpsp,psp,IDD_END_ACCOUNT,12,IDS_ACCOUNT_TITLE,EndDlgProc);
	int result = defineSheet(ahpsp,psh,13,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_USER);
	return result;
}

int doGroup()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[13] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_GROUP,0,wizdata,IDS_GROUP_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_GROUP_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_GROUP,IDD_DOMAIN_SELECTION,2,IDS_GROUP_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_GROUP,IDS_GROUP_SUB,IDD_SELECTION2,3,IDS_GROUP_TITLE,	IntSelectionProc);
	definepage(ahpsp,psp,IDS_OU_SELECTION,IDS_OU_SELECTION_SUB,IDD_OU_SELECTION,4,IDS_GROUP_TITLE,IntOuSelectionProc);
	definepage(ahpsp,psp,IDS_OPTIONS_GROUP,IDS_OPTIONS_GROUP_SUB,IDD_OPTIONS_GROUP,5,IDS_GROUP_TITLE,IntGroupOptionsProc);
	definepage(ahpsp,psp,IDS_PROPEX,IDS_PROPEX_SUB,IDD_PROP_EXCLUSION,6,IDS_GROUP_TITLE,IntPropExclusionProc);
	definepage(ahpsp,psp,IDS_CREDENTIALS_ACCOUNT,IDS_CREDENTIALS_SUB,IDD_CREDENTIALS,7,IDS_GROUP_TITLE,IntCredentialsProc);
	definepage(ahpsp,psp,IDS_RENAMING,IDS_RENAMING_SUB2,IDD_RENAMING,8,IDS_GROUP_TITLE,	IntRenameProc);
	definepage(ahpsp,psp,IDS_PASSWORD_GRP,IDS_PASSWORD_SUB_GRP,IDD_PASSWORD,9,IDS_GROUP_TITLE,IntPasswordProc);
	definepage(ahpsp,psp,IDS_DISABLE_GRP,IDS_DISABLE_SUB_GRP,IDD_DISABLE,10,IDS_GROUP_TITLE,IntDisableProc);
//	definepage(ahpsp,psp,IDS_OPTIONS_FROM_USER,IDS_OPTIONS_FROM_USER_SUB,IDD_OPTIONS_FROM_USER,10,IDS_GROUP_TITLE,	IntOptionsFromUserProc);
	definepage(ahpsp,psp,IDS_SA_INFO,IDS_SA_INFO_SUB,IDD_SA_INFO,11,IDS_GROUP_TITLE,IntServiceInfoProc);
	endpage(ahpsp,psp,IDD_END_GROUP,12,IDS_GROUP_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,13,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_GROUP);
	return result;
}
int doComputer()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[11] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_COMPUTER,0,wizdata,IDS_COMPUTER_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_COMPUTER_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_COMPUTERS,IDD_DOMAIN_SELECTION,2,IDS_COMPUTER_TITLE,	IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_COMPUTER,IDS_COMPUTER_SUB,IDD_SELECTION1,3,IDS_COMPUTER_TITLE,	IntSelectionProc);
	definepage(ahpsp,psp,IDS_OU_SELECTION,IDS_OU_SELECTION_SUB,IDD_OU_SELECTION,4,IDS_COMPUTER_TITLE,	IntOuSelectionProc);
	definepage(ahpsp,psp,IDS_TRANSLATION,IDS_TRANSLATION_SUB,IDD_TRANSLATION,5,IDS_COMPUTER_TITLE,	IntTranslationProc);
	definepage(ahpsp,psp,IDS_SECURITY_OPTIONS,IDS_TRANSLATION_MODE_SUB,IDD_TRANSLATION_MODE,6,IDS_COMPUTER_TITLE,	IntTranslationModeProc);
//	definepage(ahpsp,psp,IDS_CREDENTIALS2,IDS_CREDENTIALS_SUB2,IDD_CREDENTIALS2,7,IDS_COMPUTER_TITLE,	IntCredentials2Proc);
	definepage(ahpsp,psp,IDS_COMPUTER_OPTIONS,IDS_REBOOT_SUB,IDD_REBOOT,7,IDS_COMPUTER_TITLE,	IntRebootProc);
	definepage(ahpsp,psp,IDS_PROPEX,IDS_PROPEX_SUB,IDD_PROP_EXCLUSION,8,IDS_COMPUTER_TITLE,IntPropExclusionProc);
	definepage(ahpsp,psp,IDS_RENAMING,IDS_RENAMING_SUB3,IDD_RENAMING,9,IDS_COMPUTER_TITLE,	IntRenameProc);
	endpage(ahpsp,psp,IDD_END_COMPUTER,10,IDS_COMPUTER_TITLE, EndDlgProc);
	int result = defineSheet(ahpsp,psh,11,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_COMPUTER);
	return result;
}

int doSecurity()
{		
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[8] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_SECURITY,0,wizdata,IDS_SECURITY_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_SECURITY_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_SECURITY_OPTIONS,IDS_TRANSLATION_MODE_SUB,IDD_TRANSLATION_SRC,2,IDS_SECURITY_TITLE,IntTranslationInputProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_SECURITY,IDD_DOMAIN_SELECTION,3,IDS_SECURITY_TITLE	,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_SECURITY,IDS_SECURITY_SUB,IDD_SELECTION4,4,IDS_SECURITY_TITLE,IntSelectionSecurityProc);
	definepage(ahpsp,psp,IDS_TRANSLATION,IDS_TRANSLATION_SUB,IDD_TRANSLATION,5,IDS_SECURITY_TITLE,	IntTranslationProc);
	definepage(ahpsp,psp,IDS_SECURITY_OPTIONS,IDS_TRANSLATION_MODE_SUB,IDD_TRANSLATION_MODE,6,IDS_SECURITY_TITLE,IntTranslationModeProc);
//	definepage(ahpsp,psp,IDS_CREDENTIALS2,IDS_CREDENTIALS_SUB2,IDD_CREDENTIALS2,7,IDS_SECURITY_TITLE,	IntCredentials2Proc);
	endpage(ahpsp,psp,IDD_END_SECURITY,7,IDS_SECURITY_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,8,wizdata,IDB_HEADER_KEY,IDB_WATERMARK_SECURITY);
	return result;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
int doExchangeDir()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[7] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_EXCHANGE_DIR,0,wizdata,IDS_EXCHANGE_DIR_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_EXCHANGE_DIR_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_DIRECTORY,IDD_DOMAIN_SELECTION,2,IDS_EXCHANGE_DIR_TITLE,	IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_SECURITY_OPTIONS,IDS_TRANSLATION_MODE_SUB,IDD_TRANSLATION_MODE,3,IDS_EXCHANGE_DIR_TITLE,	IntTranslationModeProc);
	definepage(ahpsp,psp,IDS_EXCHANGE_SELECTION,IDS_EXCHANGE_SELECTION_SUB,IDD_EXCHANGE_SELECTION,4,IDS_EXCHANGE_DIR_TITLE,IntExchangeSelectionProc);
	definepage(ahpsp,psp,IDS_CREDENTIALS_EXCHANGE,IDS_CREDENTIALS_EXCHANGE_SUB,IDD_CREDENTIALS,5,IDS_EXCHANGE_DIR_TITLE,IntCredentialsProc);
	endpage(ahpsp,psp,IDD_END_EXCHANGE_DIR,6,IDS_EXCHANGE_DIR_TITLE,	EndDlgProc);
	int result = 	defineSheet(ahpsp,psh,7,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_EXCHANGE);
	return result;
}
int doExchangeSrv()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[5] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_EXCHANGE_SRV,0,wizdata,IDS_EXCHANGE_SRV_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_COMMIT,IDS_COMMIT_SUB,IDD_COMMIT,1,IDS_EXCHANGE_SRV_TITLE,IntCommitProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_SUB,IDD_DOMAIN_SELECTION,2,IDS_EXCHANGE_SRV_TITLE,	IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_EXCHANGE_SELECTION,IDS_EXCHANGE_SELECTION_SUB,IDD_EXCHANGE_SELECTION,3,IDS_EXCHANGE_SRV_TITLE,IntExchangeSelectionProc);
	endpage(ahpsp,psp,IDD_END_EXCHANGE_SRV,4,IDS_EXCHANGE_SRV_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,5,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_EXCHANGE);
	return result;
}
int doUndo()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[4] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_UNDO,0,wizdata,IDS_UNDO_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_UNDO,IDS_UNDO_SUB,IDD_UNDO,1,IDS_UNDO_TITLE,IntUndoProc);
	definepage(ahpsp,psp,IDS_CREDENTIALS_ACCOUNT,IDS_CREDENTIALS_SUB,IDD_CREDENTIALS,2,IDS_UNDO_TITLE,IntCredentialsProc);
//	definepage(ahpsp,psp,IDS_CREDENTIALS2,IDS_CREDENTIALS_SUB2,IDD_CREDENTIALS2,3,IDS_UNDO_TITLE,	IntCredentials2Proc);
	endpage(ahpsp,psp,IDD_END_UNDO,3,IDS_UNDO_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,4,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_USER);
	return result;
}
int doRetry()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[3] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_RETRY,0,wizdata,IDS_RETRY_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_RETRY,IDS_RETRY_SUB,IDD_RETRY,1,IDS_RETRY_TITLE,IntRetryProc);
//	definepage(ahpsp,psp,IDS_CREDENTIALS2,IDS_CREDENTIALS_SUB2,IDD_CREDENTIALS2,2,IDS_RETRY_TITLE,IntCredentials2Proc);
	endpage(ahpsp,psp,IDD_END_RETRY,2,IDS_RETRY_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,3,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_USER);
	return result;
}

int doReporting()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[6] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_REPORTING,0,wizdata,IDS_REPORTING_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_REPORTING_SUB,IDD_DOMAIN_SELECTION,1,IDS_REPORTING_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_HTML_LOCATION,IDS_HTML_LOCATION_SUB,IDD_HTML_LOCATION,2,IDS_REPORTING_TITLE,IntHTMLLocationProc);
	definepage(ahpsp,psp,IDS_OPTIONS_REPORTING,IDS_OPTIONS_REPORTING_SUB,IDD_OPTIONS_REPORTING,3,IDS_REPORTING_TITLE,IntOptionsReportingProc);	
//	definepage(ahpsp,psp,IDS_CREDENTIALS3,IDS_CREDENTIALS_SUB3,IDD_CREDENTIALS2,4,IDS_REPORTING_TITLE,	IntCredentials2Proc);
	definepage(ahpsp,psp,IDS_REPORTING,IDS_REPORTING_SUB,IDD_SELECTION1,4,IDS_REPORTING_TITLE,IntSelectionProc);
	endpage(ahpsp,psp,IDD_END_REPORTING,5,IDS_REPORTING_TITLE,	EndDlgProc);
	int result = defineSheet(ahpsp,psh,6,wizdata,IDB_HEADER_BOOK,IDB_WATERMARK_REPORTING);
	return result;
}

int doService()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[6]=	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	intropage(ahpsp,psp,IDD_INTRO_SERVICE,0,wizdata,IDS_SERVICE_TITLE,IntroDlgProc);
	definepage(ahpsp,psp,IDS_DOMAIN,IDS_SERVICE_DOMAIN,IDD_DOMAIN_SELECTION,1,IDS_SERVICE_TITLE,IntDomainSelectionProc);
	definepage(ahpsp,psp,IDS_SA_REFRESH,IDS_SA_REFRESH_SUB,IDD_SA_REFRESH,2,IDS_SERVICE_TITLE,IntServiceRefreshProc);
	definepage(ahpsp,psp,IDS_SERVICE,IDS_SERVICE_SUB,IDD_SELECTION1,3,IDS_SERVICE_TITLE,IntSelectionProc);
//	definepage(ahpsp,psp,IDS_CREDENTIALS2,IDS_SERVICE_CREDENTIALS,IDD_CREDENTIALS2,4,IDS_SERVICE_TITLE,	IntCredentials2Proc);
	definepage(ahpsp,psp,IDS_SA_INFO,IDS_SA_INFO_SUB,IDD_SA_INFO_BUTTON,4,IDS_SERVICE_TITLE,IntServiceInfoButtonProc);
	endpage(ahpsp,psp,IDD_END_SERVICE,5,IDS_SERVICE_TITLE,EndDlgProc);
	int result = defineSheet(ahpsp,psh,6,wizdata,IDB_HEADER_ARROW,IDB_WATERMARK_SERVICE_ACCOUNT);
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\acctrepl.h ===
/*---------------------------------------------------------------------------
  File: AcctRepl.h

  Comments: Definition of account replicator COM object.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:18:21

 ---------------------------------------------------------------------------
*/

	
// AcctRepl.h : Declaration of the CAcctRepl

#ifndef __ACCTREPL_H_
#define __ACCTREPL_H_

#include "resource.h"       // main symbols

#include "ProcExts.h"

//#import "\bin\McsVarSetMin.tlb" no_namespace
//#import "\bin\MoveObj.tlb" no_namespace
//#import "VarSet.tlb" no_namespace rename("property", "aproperty")//already #imported by ProcExts.h
#import "MoveObj.tlb" no_namespace

#include "UserCopy.hpp"
#include "TNode.hpp"
#include "Err.hpp"

#include "ResStr.h"

/////////////////////////////////////////////////////////////////////////////
// CAcctRepl
class ATL_NO_VTABLE CAcctRepl :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAcctRepl, &CLSID_AcctRepl>,
	public IAcctRepl

{
public:
	CAcctRepl()
	{
		m_pUnkMarshaler = NULL;
      m_UpdateUserRights = FALSE;
      m_ChangeDomain = FALSE;
      m_Reboot = FALSE;
      m_RenameOnly = FALSE;
      m_pExt = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_ACCTREPL)
/*
static HRESULT WINAPI UpdateRegistry( BOOL bUpdateRegistry )
{
   _bstr_t                      pid, pidver, name;
   pidver = GET_BSTR(IDS_COM_AcctReplPidVer);
   name = GET_BSTR(IDS_COM_AcctReplName);
   pid = GET_BSTR(IDS_COM_AcctReplPid);

   _ATL_REGMAP_ENTRY         regMap[] =
   {
      { OLESTR("PIDVER"), pidver },
      { OLESTR("OBJNAME"), name },
      { OLESTR("PID"), pid },
      { 0, 0 }
   };
   return _Module.UpdateRegistryFromResourceD( IDR_ACCTREPL, bUpdateRegistry, regMap );
}
*/

DECLARE_NOT_AGGREGATABLE(CAcctRepl)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAcctRepl)
	COM_INTERFACE_ENTRY(IAcctRepl)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

   // IAcctRepl
public:
	HRESULT Create2KObj( TAcctReplNode * pAcct, Options * pOptions);
   STDMETHOD(Process)(IUnknown * pWorkItemIn);
protected:
	HRESULT ResetMembersForUnivGlobGroups(Options * pOptions, TAcctReplNode * pAcct);
	HRESULT FillNodeFromPath( TAcctReplNode * pAcct, Options * pOptions, TNodeListSortable * acctList );
   Options                   opt;
   TNodeListSortable         acctList;
   BOOL                      m_UpdateUserRights;
   BOOL                      m_ChangeDomain;
   BOOL                      m_Reboot;
   BOOL                      m_RenameOnly;

   void  LoadOptionsFromVarSet(IVarSet * pVarSet);
   void  LoadResultsToVarSet(IVarSet * pVarSet);
   DWORD PopulateAccountListFromVarSet(IVarSet * pVarSet);
   BOOL  PopulateAccountListFromFile(WCHAR const * filename);
   DWORD UpdateUserRights(IStatusObj * pStatus);
   //void  ReadPasswordPolicy();
   void  WriteOptionsToLog();
   // DWORD GetAccountType(TAcctReplNode * pNode);
   int CopyObj(
      Options              * options,      // in -options
      TNodeListSortable    * acctlist,     // in -list of accounts to process
      ProgressFn           * progress,     // in -window to write progress messages to
      TError               & error,        // in -window to write error messages to
      IStatusObj           * pStatus,      // in -status object to support cancellation
      void                   WindowUpdate (void )    // in - window update function
   );

   int UndoCopy(
      Options              * options,      // in -options
      TNodeListSortable    * acctlist,     // in -list of accounts to process
      ProgressFn           * progress,     // in -window to write progress messages to
      TError               & error,        // in -window to write error messages to
      IStatusObj           * pStatus,      // in -status object to support cancellation
      void                   WindowUpdate (void )    // in - window update function
   );

   bool BothWin2K( Options * pOptions );
   int CopyObj2K( Options * pOptions, TNodeListSortable * acctList, ProgressFn * progress, IStatusObj * pStatus );
   int DeleteObject( Options * pOptions, TNodeListSortable * acctList, ProgressFn * progress, IStatusObj * pStatus );
   HRESULT UpdateGroupMembership(Options * pOptions, TNodeListSortable * acctlist,ProgressFn * progress, IStatusObj * pStatus );
  // HRESULT UpdateNT4GroupMembership(Options * pOptions, TNodeListSortable * acctlist,ProgressFn * progress, IStatusObj * pStatus, void WindowUpdate(void));
private:
	HRESULT UpdateMemberToGroups(TNodeListSortable * acctList, Options * pOptions, BOOL bGrpsOnly);
	BOOL StuffComputerNameinLdapPath(WCHAR * sAdsPath, DWORD nPathLen, WCHAR * sSubPath, Options * pOptions, BOOL bTarget = TRUE);
	BOOL CheckBuiltInWithNTApi( PSID pSid, WCHAR * pNode, Options * pOptions );
	HRESULT GetTargetGroupType( WCHAR * sPath, DWORD& grpType);
	bool GetClosestDC( Options * pOpt, long flags = 0 );
	BOOL GetNt4Type( WCHAR const * sComp, WCHAR const * sAcct, WCHAR * sType);
	BOOL GetSamFromPath(_bstr_t sPath, _bstr_t& sSam, _bstr_t& sType, _bstr_t& sName, long& grpType, Options * pOptions);
	BOOL IsContainer( TAcctReplNode * pNode, IADsContainer ** ppCont);
	BOOL ExpandContainers( TNodeListSortable    * acctlist, Options *pOptions, ProgressFn * progress );
   CProcessExtensions      * m_pExt;
   HRESULT CAcctRepl::RemoveMembers(TAcctReplNode * pAcct, Options * pOptions);
   bool FillPathInfo(TAcctReplNode * pAcct,Options * pOptions);
   bool AcctReplFullPath(TAcctReplNode * pAcct, Options * pOptions);
   BOOL NeedToProcessAccount(TAcctReplNode * pAcct, Options * pOptions);
   BOOL ExpandMembership(TNodeListSortable *acctlist, Options *pOptions, TNodeListSortable *pNewAccts, ProgressFn * progress, BOOL bGrpsOnly);
   int MoveObj2K(Options * options, TNodeListSortable * acctlist, ProgressFn * progress, IStatusObj * pStatus);
   HRESULT ResetObjectsMembership(Options * pOptions, TNodeListSortable * pMember, IIManageDBPtr pDb);
   HRESULT RecordAndRemoveMemberOf ( Options * pOptions, TAcctReplNode * pAcct,  TNodeListSortable * pMember);
   HRESULT RecordAndRemoveMember (Options * pOptions,TAcctReplNode * pAcct,TNodeListSortable * pMember);
   HRESULT MoveObject( TAcctReplNode * pAcct,Options * pOptions,IMoverPtr pMover);
   HRESULT ResetGroupsMembers( Options * pOptions, TAcctReplNode * pAcct, TNodeListSortable * pMember, IIManageDBPtr pDb );
   HRESULT ADsPathFromDN( Options * pOptions,_bstr_t sDN,WCHAR * sPath, bool bWantLDAP = true);
   void SimpleADsPathFromDN( Options * pOptions,WCHAR const * sDN,WCHAR * sPath);
   BOOL FillNamingContext(Options * pOptions);
   HRESULT MakeAcctListFromMigratedObjects(Options * pOptions, long lUndoActionID, TNodeListSortable *& pAcctList,BOOL bReverseDomains);
   void AddPrefixSuffix( TAcctReplNode * pNode, Options * pOptions );
   HRESULT LookupAccountInTarget(Options * pOptions, WCHAR * sSam, WCHAR * sPath);
   void UpdateMemberList(TNodeListSortable * pMemberList,TNodeListSortable * acctlist);
   void BuildTargetPath(WCHAR const * sCN, WCHAR const * tgtOU, WCHAR * stgtPath);
   HRESULT BetterHR(HRESULT hr);
   HRESULT BuildSidPath(
                        WCHAR const * sPath,    //in- path returned by the enumerator.
                        WCHAR *       sSidPath, //out-path to the LDAP://<SID=###> object
                        WCHAR *       sSam,     //out-Sam name of the object
                        WCHAR *       sDomain,  //out-Domain name where this object resides.
                        Options *     pOptions, //in- Options
                        PSID  *       ppSid     //out-Pointer to the binary sid
                      );
   HRESULT CheckClosedSetGroups(
      Options              * pOptions,          // in - options for the migration
      TNodeListSortable    * pAcctList,         // in - list of accounts to migrate
      ProgressFn           * progress,          // in - progress function to display progress messages
      IStatusObj           * pStatus            // in - status object to support cancellation
   );

   BOOL CanMoveInMixedMode(TAcctReplNode *pAcct,TNodeListSortable * acctlist,Options * pOptions);
   HRESULT QueryPrimaryGroupMembers(BSTR cols, Options * pOptions, DWORD rid, IEnumVARIANT*& pEnum);
   bool GetRidForGroup(Options * pOptions, WCHAR * sGroupSam, DWORD& rid);
   HRESULT AddPrimaryGroupMembers(Options * pOptions, SAFEARRAY * multiVals, WCHAR * sGroupSam);
   HRESULT GetThePrimaryGroupMembers(Options * pOptions, WCHAR * sGroupSam, IEnumVARIANT *& pVar);
   BOOL TruncateSam(WCHAR * tgtname, TAcctReplNode * acct, Options * options, TNodeListSortable * acctList);
   BOOL DoesTargetObjectAlreadyExist(TAcctReplNode * pAcct, Options * pOptions);
   void GetAccountUPN(Options * pOptions, _bstr_t sSName, _bstr_t& sSUPN);
   HRESULT UpdateManagement(TNodeListSortable * acctList, Options * pOptions);
   _bstr_t GetUnEscapedNameWithFwdSlash(_bstr_t strName);
   _bstr_t GetCNFromPath(_bstr_t sPath);
   BOOL ReplaceSourceInLocalGroup(TNodeListSortable * acctList, Options * pOptions, IStatusObj *pStatus);
   _bstr_t GetDomainOfMigratedForeignSecPrincipal(_bstr_t sPath);
   void RemoveSourceAccountFromGroup(IADsGroup * pGroup, IVarSetPtr pMOTVarSet, Options * pOptions);
};

typedef void ProgressFn(WCHAR const * mesg);

typedef HRESULT (CALLBACK * ADSGETOBJECT)(LPWSTR, REFIID, void**);
extern ADSGETOBJECT            ADsGetObject;

#endif //__ACCTREPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\wizards\trstdlg.h ===
#if !defined(AFX_TRUSTERDLG_H__00348D40_621E_11D3_AF7D_0090275A583D__INCLUDED_)
#define AFX_TRUSTERDLG_H__00348D40_621E_11D3_AF7D_0090275A583D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TrusterDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTrusterDlg dialog
#include "resource.h"
#include "ErrDct.hpp"
class CTrusterDlg : public CDialog
{
// Construction
public:
	CTrusterDlg(CWnd* pParent = NULL);   // standard constructor
	CString m_strDomain;
	CString m_strPassword;
	CString m_strUser;
	DWORD len;
	bool toreturn;
	TErrorDct 			err;
	DWORD  VerifyPassword(WCHAR  * sUserName, WCHAR * sPassword, WCHAR * sDomain);

// Dialog Data
	//{{AFX_DATA(CTrusterDlg)
	enum { IDD = IDD_CREDENTIALS_TRUST };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTrusterDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTrusterDlg)
	afx_msg void OnOK();
	afx_msg void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRUSTERDLG_H__00348D40_621E_11D3_AF7D_0090275A583D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\arutil.cpp ===
/*---------------------------------------------------------------------------
  File: ARUtil.cpp

  Comments: Helper functions and command-line parsing for Account Replicator

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 6/23/98 4:26:54 PM

 ---------------------------------------------------------------------------
*/

#include "StdAfx.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define INCL_NETUSER
#define INCL_NETGROUP
#define INCL_NETERRORS
#include <lm.h>

#include "Mcs.h"
#include "Common.hpp"                    
#include "TNode.hpp"
#include "UString.hpp"                   

#include "ErrDct.hpp"

//#import "\bin\McsDctWorkerObjects.tlb"
//#import "WorkObj.tlb" //#imported via ARUtil.hpp below

#include "UserCopy.hpp"
#include "ARUtil.hpp"
#include "PWGen.hpp"
#include "ResStr.h"


extern TErrorDct             err;
bool                         bAllowReplicateOnSelf;
                                                       
extern PSID                  srcSid;   // SID of source domain

/***************************************************************************************************
 CompVal: used as a compare function for TANode trees

   It compares a UNICODE string, with the name field in the node
   
   Return Values:
                     0    tn->acct_name == actname 
                     1    tn->acct_name <  actname
                    -1    tn->acct_name >  actname 

/***************************************************************************************************/

int 
   CompVal(
      const TNode          * tn,          //in -tree node  
      const void           * actname      //in -name to look for  
   )
{

   LPWSTR                    str1 = ((TANode *)tn)->GetName();
   LPWSTR                    str2 = (LPWSTR) actname;
  
   return UStrICmp(str1,str2);
}
/***************************************************************************************************/
/* CompNode:  used as a compare function for TANode Trees
     
   It compares the name fields of TANodes
   
   Return Values:
                  0     t1->acct_name == t2->acct_name
                  1     t1->acct_name >  t2->acct_name
                 -1     t1->acct_name <  t2->acct_name

   Error Handling:
      if given bad inputs, CompN displays an error message and returns 0
/***************************************************************************************************/

int 
   CompNode(
      const TNode          * v1,       //in -first node to compare
      const TNode          * v2        //in -second node to compare
   )
{  

   TANode                  * t1 = (TANode *)v1;
   TANode                  * t2 = (TANode *)v2;
  
   return UStrICmp(t1->GetName(),t2->GetName());
} 


int 
   CompareSid(
      PSID const             sid1,  // in - first SID to compare
      PSID const             sid2   // in - second SID to compare
   )
{
   DWORD                     len1,
                             len2;
   int                       retval = 0;

   len1 = GetLengthSid(sid1);
   len2 = GetLengthSid(sid2);

   if ( len1 < len2 )
   {
      retval = -1;
   }
   if ( len1 > len2 )
   {
      retval = 1;
   }
   if ( len1 == len2 )
   {
      retval = memcmp(sid1,sid2,len1);
   }

   return retval;
}


int 
   CompSid(
      const TNode          * v1,      // in -first node to compare
      const TNode          * v2       // in -second node to compare
   )
{
   TANode                  * t1 = (TANode *)v1;
   TANode                  * t2 = (TANode *)v2;

   return CompareSid(t1->GetSid(),t2->GetSid());
}

int 
   CompSidVal(
      const TNode          * tn,     // in -node to compare
      const void           * pVal    // in -value to compare
   )
{
   TANode                  * node = (TANode *)tn;
   PSID                      pSid = (PSID)pVal;

   return CompareSid(node->GetSid(),pSid);
}

//#pragma page()
//------------------------------------------------------------------------------
// CopyServerName: Ensures that server name is in UNC form and checks its len
//------------------------------------------------------------------------------
DWORD
   CopyServerName(
      TCHAR                 * uncServ     ,// out-UNC server name
      TCHAR const           * server       // in -\\server or domain name
   )
{
   short                      l = (short) UStrLen(server);
   WCHAR                    * uncPDC;
   API_RET_TYPE               rc;
   DWORD                      retcode = 0;

   if ( (server[0] == '\\'  &&  l > UNCLEN )
     || (server[0] != '\\'  &&  l > DNLEN) )
   {
     retcode = NERR_MaxLenExceeded;
   }

   UStrCpy(uncServ, server, CNLEN+3);
   
   if ( server[0] != '\\' )
   {
      rc = NetGetDCName(NULL, uncServ, (PBYTE*)&uncPDC);
      if ( ! rc )
         UStrCpy(uncServ, uncPDC);
      retcode = rc;
      NetApiBufferFree(uncPDC);
   }
   return retcode;
}

BOOL                                      // ret-FALSE is addto: is not a group account
   AddToGroupResolveType(
      Options              * options      // i/o-options
   )
{
   DWORD                     rc = 0;
   DWORD                     lenDomain,
                             lenSid;
   WCHAR                     wszDomain[DNLEN+1];
   SID_NAME_USE              sidNameUse;   // Type of SID
   BYTE                      sid[LEN_Sid];
   WCHAR                     server[LEN_Computer];

   // Target domain AddTo group
   if ( *options->addToGroup )
   {
      safecopy(server,options->tgtComp);
      lenSid = sizeof sid;
      lenDomain = DIM(wszDomain);
      wszDomain[0] = L'\0';
      if ( !LookupAccountName(server,
                              options->addToGroup,
                              (PSID)sid,
                              &lenSid,
                              wszDomain,
                              &lenDomain,
                              &sidNameUse ) )
      {
         rc = GetLastError();
         if ( rc == ERROR_NONE_MAPPED )
         {
            // the add-to group does not exist. Try to create it
            LOCALGROUP_INFO_1   lgInfo;
            WCHAR               comment[LEN_Comment];

            swprintf(comment,GET_STRING(IDS_AddToGroupOnTargetDescription_S),options->srcDomain);
         
            lgInfo.lgrpi1_name = options->addToGroup;
            lgInfo.lgrpi1_comment = comment;
         
            if (! options->nochange )
            {
               rc = NetLocalGroupAdd(server,1,(LPBYTE)&lgInfo,NULL);
            }
            else
            {
               rc = 0;
            }
            if ( rc && rc != ERROR_ALIAS_EXISTS )
            {
               err.SysMsgWrite(ErrW,rc,DCT_MSG_CREATE_ADDTO_GROUP_FAILED_SD,options->addToGroup,rc);
            }
         }
         else
         {
            err.SysMsgWrite(0, rc, DCT_MSG_RESOLVE_ADDTO_FAILED_SSD, options->addToGroup, server, rc );
         }
      }
      else
      {
         rc = 0;
         if ( sidNameUse == SidTypeAlias )
            options->flags |= F_AddToGroupLocal;
         else if ( sidNameUse != SidTypeGroup )
         {
            rc = 1;
            err.MsgWrite(0, DCT_MSG_ADDTO_NOT_GROUP_SD, options->addToGroup, sidNameUse );
         }
      }
   }
   
   // Source domain addto group
   if ( *options->addToGroupSource )
   {
      safecopy(server,options->srcComp);
      lenSid = sizeof sid;
      lenDomain = DIM(wszDomain);
      wszDomain[0] = L'\0';
      if ( !LookupAccountName(server,
                              options->addToGroupSource,
                              (PSID)sid,
                              &lenSid,
                              wszDomain,
                              &lenDomain,
                              &sidNameUse ) )
      {
         rc = GetLastError();
         if ( rc == ERROR_NONE_MAPPED )
         {
            // the add-to group does not exist. Try to create it
            LOCALGROUP_INFO_1   lgInfo;
            WCHAR               comment[LEN_Comment];

            swprintf(comment,GET_STRING(IDS_AddToGroupOnSourceDescription_S),options->tgtDomain);
         
            lgInfo.lgrpi1_name = options->addToGroupSource;
            lgInfo.lgrpi1_comment = comment;
         
            if (! options->nochange )
            {
               rc = NetLocalGroupAdd(server,1,(LPBYTE)&lgInfo,NULL);
            }
            else
            {
               rc = 0;
            }
            if ( rc && rc != ERROR_ALIAS_EXISTS )
            {
               err.SysMsgWrite(ErrW,rc,DCT_MSG_CREATE_ADDTO_GROUP_FAILED_SD,options->addToGroupSource,rc);
            }
         }
         else
         {
            err.SysMsgWrite(0, rc, DCT_MSG_RESOLVE_ADDTO_FAILED_SSD, options->addToGroupSource, server, rc );
         }
      }
      else
      {
         rc = 0;
         if ( sidNameUse == SidTypeAlias )
            options->flags |= F_AddToSrcGroupLocal;
         else if ( sidNameUse != SidTypeGroup )
         {
            rc = 1;
            err.MsgWrite(0, DCT_MSG_ADDTO_NOT_GROUP_SD, options->addToGroup, sidNameUse );
         }
      }
   }
   

   return rc == 0;
}

BOOL                                            // ret-TRUE if the password is successfully generated
   PasswordGenerate(
      Options const        * options,           // in  -includes PW Generating options
      WCHAR                * password,          // out -buffer for generated password
      DWORD                  dwPWBufferLength,  // in  -DIM length of password buffer
      BOOL                   isAdminAccount     // in  -Whether to use the Admin rules 
   )
{
   DWORD                     rc = 0;
   DWORD                     dwMinUC;           // minimum upper case chars
   DWORD                     dwMinLC;           // minimum lower case chars
   DWORD                     dwMinDigit;        // minimum numeric digits
   DWORD                     dwMinSpecial;      // minimum special chars
   DWORD                     dwMaxConsecutiveAlpha; // maximum consecutive alpha chars
   DWORD                     dwMinLength;       // minimum length
   WCHAR                     eaPassword[PWLEN+1];  // EA generated password
   DWORD                     dwEaBufferLength = DIM(eaPassword);// DIM length of newPassword

   // default values, if not enforcing PW strength through EA or MS DLL
   dwMinUC = 0;
   dwMinLC = 0;
   dwMinDigit = 1;            // if no enforcement, require one digit (this is what the GUI does)
   dwMinSpecial = 0;
   dwMaxConsecutiveAlpha = 0;
   dwMinLength = options->minPwdLength;
   
   
   // Get password enforcement rules, if in effect
   dwMinUC = options->policyInfo.minUpper;
   dwMinLC = options->policyInfo.minLower;
   dwMinDigit = options->policyInfo.minDigits;
   dwMinSpecial = options->policyInfo.minSpecial;
   dwMaxConsecutiveAlpha = options->policyInfo.maxConsecutiveAlpha;
   
   rc = EaPasswordGenerate(dwMinUC,dwMinLC,dwMinDigit,dwMinSpecial,
            dwMaxConsecutiveAlpha,dwMinLength,eaPassword,dwEaBufferLength);
   
   if ( ! rc )
   {
      UStrCpy(password,eaPassword,dwPWBufferLength);
   }
   else
   {
      if ( dwPWBufferLength )
         password[0] = 0;
   }
   
   return rc;
}


PSID 
   GetWellKnownSid(
      DWORD                  wellKnownAccount,  // in - constant defined in this file, representing well-known account
      Options              * opt,               // in - migration options 
      BOOL                   bTarget            // in - flag, whether to use source or target domain information
   )
{
   PSID                      pSid = NULL;
   PUCHAR                    numsubs = NULL;
   DWORD                   * rid = NULL;
   BOOL                      error = FALSE;
   DWORD                     rc;
   DWORD                     wellKnownRid = wellKnownAccount;
   BOOL                      bNeedToBuildDomainSid = FALSE;
   
   
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY creatorIA =    SECURITY_CREATOR_SID_AUTHORITY;
   
    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //
   switch ( wellKnownAccount )
   {
      case CREATOR_OWNER:
         if( ! AllocateAndInitializeSid(
                  &creatorIA,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  SECURITY_CREATOR_OWNER_RID,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case ADMINISTRATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ADMINS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case ACCOUNT_OPERATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case BACKUP_OPERATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_BACKUP_OPS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case DOMAIN_ADMINS:
        wellKnownRid = DOMAIN_GROUP_RID_ADMINS;
        bNeedToBuildDomainSid = TRUE;
         break;
      case DOMAIN_USERS:
         wellKnownRid = DOMAIN_GROUP_RID_USERS;
         bNeedToBuildDomainSid = TRUE;
         break;
      case DOMAIN_CONTROLLERS:
         wellKnownRid = DOMAIN_GROUP_RID_CONTROLLERS;
         bNeedToBuildDomainSid = TRUE;
         break;
      case DOMAIN_COMPUTERS:
         wellKnownRid = DOMAIN_GROUP_RID_COMPUTERS;
         bNeedToBuildDomainSid = TRUE;
         break;
      default:
         wellKnownRid = wellKnownAccount;
         bNeedToBuildDomainSid = TRUE;
         break;
   }

   if ( bNeedToBuildDomainSid )
   {
      // For the default case we can return a SID by using the wellKnownAccount parameter as a RID
      // this one is based on the sid for the domain
      // Get the domain SID
      USER_MODALS_INFO_2  * uinf = NULL;
      MCSASSERT(opt);
      srcSid = bTarget ? opt->tgtSid : opt->srcSid;
      if ( ! srcSid )
      {
         rc = NetUserModalsGet(bTarget ? opt->tgtComp :opt->srcComp,2,(LPBYTE*)&uinf);
         if ( rc )
         {
            err.SysMsgWrite(ErrE,rc,DCT_MSG_NO_DOMAIN_SID_SD,bTarget ? opt->tgtDomain :opt->srcDomain,rc );
            error = TRUE;
            srcSid = NULL;
         }
         else
         {
            srcSid = uinf->usrmod2_domain_id;
            // make a copy of the SID to keep in the Options structure for next time
            PSID     temp = LocalAlloc(LPTR,GetLengthSid(srcSid));
            
            memcpy(temp,srcSid,GetLengthSid(srcSid));

            if ( bTarget )
               opt->tgtSid = temp;
            else
               opt->srcSid = temp;
            NetApiBufferFree(uinf);
            srcSid = temp;
         }
      }
      if ( srcSid )
      {
         numsubs = GetSidSubAuthorityCount(srcSid);
         if (! AllocateAndInitializeSid(
            &sia,
            (*numsubs)+1,
            0,0,0,0,0,0,0,0,
            &pSid) )
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         if ( ! CopySid(GetLengthSid(srcSid), pSid, srcSid) )
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_COPY_SID_FAILED_D,GetLastError());
         }
         // reset number of subauthorities in pSid, since we just overwrote it with information from srcSid
         numsubs = GetSidSubAuthorityCount(pSid);
         (*numsubs)++; 
         rid = GetSidSubAuthority(pSid,(*numsubs)-1);
         *rid = wellKnownRid;
         
      }
   }
   if ( error )
   {
      LocalFree(pSid);
      pSid = NULL;
   }
   return pSid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\chdom.cpp ===
/*---------------------------------------------------------------------------
  File: ChangeDomain.cpp

  Comments: Implementation of COM object that changes the domain affiliation on 
  a computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:21:07

 ---------------------------------------------------------------------------
*/

// ChangeDomain.cpp : Implementation of CChangeDomain
#include "stdafx.h"
#include "WorkObj.h"
#include "ChDom.h"

#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include "ResStr.h"
#include "ErrDct.hpp"
#include "TxtSid.h"

/////////////////////////////////////////////////////////////////////////////
// CChangeDomain


#include "LSAUtils.h"

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "NetEnum.tlb" no_namespace 
#import "VarSet.tlb" no_namespace rename("property", "aproperty")

//#include <ntdsapi.h>
//#include <iads.h>
#include <lm.h>         // for NetXxx API
#include <lmjoin.h>
//#include <mapiwin.h>
#include <winbase.h>

TErrorDct errLocal;

// constants from lmjoin.h needed for NetJoinDomain which does not exist on NT 4.
#define NETSETUP_JOIN_DOMAIN    0x00000001      // If not present, workgroup is joined
#define NETSETUP_ACCT_CREATE    0x00000002      // Do the server side account creation/rename
#define NETSETUP_ACCT_DELETE    0x00000004      // Delete the account when a domain is left
#define NETSETUP_WIN9X_UPGRADE  0x00000010      // Invoked during upgrade of Windows 9x to
                                                // Windows NT
#define NETSETUP_DOMAIN_JOIN_IF_JOINED  0x00000020  // Allow the client to join a new domain
                                                // even if it is already joined to a domain
#define NETSETUP_JOIN_UNSECURE  0x00000040      // Performs an unsecure join

#define NETSETUP_INSTALL_INVOCATION 0x00040000  // The APIs were invoked during install




typedef NET_API_STATUS
NET_API_FUNCTION
PNETJOINDOMAIN(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDomain,
    IN  LPCWSTR lpAccountOU, OPTIONAL
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fJoinOptions
    );

HINSTANCE                    hDll = NULL;
PNETJOINDOMAIN             * gNetJoinDomain = NULL;

BOOL GetNetJoinDomainFunction()
{
   BOOL                      bSuccess = FALSE;

   hDll = LoadLibrary(L"NetApi32.dll");
   if ( hDll )
   {
      gNetJoinDomain = (PNETJOINDOMAIN*)GetProcAddress(hDll,"NetJoinDomain");
      if ( gNetJoinDomain )
      {
         bSuccess = TRUE;
      }
   }
   return bSuccess;
   
}

typedef HRESULT (CALLBACK * ADSGETOBJECT)(LPWSTR, REFIID, void**);
extern ADSGETOBJECT            ADsGetObject;

/*BOOL GetLDAPPath(WCHAR * sTgtDomain, WCHAR * sSAM, WCHAR * sPath)
{
   if ( pOptions->tgtDomainVer < 5 )
   {
      // for NT4 we can just build the path and send it back. 
      wsprintf(sPath, L"WinNT://%s/%s", pOptions->tgtDomain, sSam);
      return S_OK;
   }
   // Use the net object enumerator to lookup the account in the target domain.
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   IEnumVARIANT            * pEnum = NULL;
   SAFEARRAYBOUND            bd = { 1, 0 };
   SAFEARRAY               * pszColNames;
   BSTR  HUGEP             * pData = NULL;
   BSTR                      sData[] = { L"aDSPath" };
   WCHAR                     sQuery[LEN_Path];
   WCHAR                     sDomPath[LEN_Path];
   DWORD                     ret = 0;
   _variant_t                var, varVal;
   HRESULT                   hr = S_OK;
   WCHAR                     tgtNamingContext[LEN_Path];
   WCHAR                     aPath[LEN_Path];
   IADs                    * pAds;
   BOOL						 bFoundNC = FALSE;
   BOOL						 bConverted = FALSE;

   errLocal.DbgMsgWrite(0,L"GetLDAPPath for %ls in %ls", sSAM, sTgtDomain);
   wsprintf(aPath, L"LDAP://%s/rootDSE", sTgtDomain);
   hr = ADsGetObject(aPath, IID_IADs, (void**)&pAds);
   if ( SUCCEEDED(hr) )
   {
      errLocal.DbgMsgWrite(0,L"ADsGetObject Succeeded");
	  hr = pAds->Get(L"defaultNamingContext", &var);
	  if ( SUCCEEDED(hr) )
	  {
         pAds->Release();
         wcscpy(tgtNamingContext, (WCHAR*) V_BSTR(&var));
         errLocal.DbgMsgWrite(0,L"NamingContext is %ls", tgtNamingContext);
		 bFoundNC = TRUE;
	  }
   }
   if (!bFoundNC)
	   return FALSE;

   wsprintf(sDomPath, L"LDAP://%s/%s", sTgtDomain, tgtNamingContext);
   WCHAR                     sTempSamName[LEN_Path];
   wcscpy(sTempSamName, sSAM);
   if ( sTempSamName[0] == L' ' )
   {
      WCHAR               sTemp[LEN_Path];
      wsprintf(sTemp, L"\\20%s", sTempSamName + 1); 
      wcscpy(sTempSamName, sTemp);
   }
   wsprintf(sQuery, L"(sAMAccountName=%s)", sTempSamName);
   errLocal.DbgMsgWrite(0,L"Query for %ls", sQuery);

   hr = pQuery->raw_SetQuery(sDomPath, sTgtDomain, sQuery, ADS_SCOPE_SUBTREE, FALSE);

   // Set up the columns that we want back from the query ( in this case we need SAM accountname )
   pszColNames = ::SafeArrayCreate(VT_BSTR, 1, &bd);
   hr = ::SafeArrayAccessData(pszColNames, (void HUGEP **)&pData);
   if ( SUCCEEDED(hr) )
      pData[0] = sData[0];

   if ( SUCCEEDED(hr) )
      hr = ::SafeArrayUnaccessData(pszColNames);

   if ( SUCCEEDED(hr) )
      hr = pQuery->raw_SetColumns(pszColNames);

   // Time to execute the plan.
   if ( SUCCEEDED(hr) )
      hr = pQuery->raw_Execute(&pEnum);

   if ( SUCCEEDED(hr) )
   {
      // if this worked that means we can only have one thing in the result.
      if ( (pEnum->Next(1, &var, &ret) == S_OK) && ( ret > 0 ) )
      {
         SAFEARRAY * pArray = var.parray;
         long        ndx = 0;
         hr = SafeArrayGetElement(pArray,&ndx,&varVal);
         if ( SUCCEEDED(hr) )
		 {
            wcscpy(sPath, (WCHAR*)varVal.bstrVal);
            errLocal.DbgMsgWrite(0,L"Got LDAP of %ls", sPath);
			bConverted = TRUE;
		 }
         else
            hr = HRESULT_FROM_WIN32(NERR_UserNotFound);
      }
      else
         hr = HRESULT_FROM_WIN32(NERR_UserNotFound);

      VariantInit(&var);
   }
   if ( pEnum ) pEnum->Release();
   return bConverted;
}
*/

/*BOOL GetLDAPPath(WCHAR* Domain, WCHAR* Account, WCHAR* sLDAPPath, WCHAR* srcDomainDNS)
{
	PDS_NAME_RESULT         pNamesOut = NULL;
	WCHAR                 * pNamesIn[1];
	HANDLE                  hDs = NULL;
	WCHAR					OrigAccount[MAX_PATH];
	BOOL					bConverted = FALSE;


	errLocal.DbgMsgWrite(0,L"Parameters %ls, %ls, %ls", Domain, Account, srcDomainDNS);
	wcscpy(sLDAPPath, L"LDAP://");
	wcscat(sLDAPPath, Domain);
	_wcsupr(sLDAPPath);
	errLocal.DbgMsgWrite(0,L"Start of LDAP Path, %ls", sLDAPPath);

	wcscpy(OrigAccount, Domain);
	wcscat(OrigAccount, L"\\");
	wcscat(OrigAccount, Account);
	errLocal.DbgMsgWrite(0,L"Oringinal Account Name, %ls", OrigAccount);

    pNamesIn[0] = &OrigAccount[0];

		//bind to that source domain
	HRESULT hr = DsBind(NULL,srcDomainDNS,&hDs);
	if ( !hr )
	{
	    errLocal.DbgMsgWrite(0,L"Bound to %ls", srcDomainDNS);
	    //get UPN name of this account from DSCrackNames
	    hr = DsCrackNames(hDs,DS_NAME_NO_FLAGS,DS_NT4_ACCOUNT_NAME,DS_FQDN_1779_NAME,1,pNamesIn,&pNamesOut);
	    if ( !hr )
		{     //if got the UPN name, retry DB query for that account in the
	        errLocal.DbgMsgWrite(0,L"DSCrackNames Succeeded");
	    	//service account database
		    if ( pNamesOut->rItems[0].status == DS_NAME_NO_ERROR )
			{
			    wcscat(sLDAPPath, pNamesOut->rItems[0].pName);
	            errLocal.DbgMsgWrite(0,L"New LDAP path, %ls", sLDAPPath);
				bConverted = TRUE;
			}
			else if (pNamesOut->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY)
	            errLocal.DbgMsgWrite(0,L"DS_NAME_ERROR_DOMAIN_ONLY = %ls", pNamesOut->rItems[0].pDomain);
			else if (pNamesOut->rItems[0].status == DS_NAME_ERROR_NO_MAPPING)
	            errLocal.DbgMsgWrite(0,L"DS_NAME_ERROR_NO_MAPPING");
			else if (pNamesOut->rItems[0].status == DS_NAME_ERROR_NOT_FOUND)
	            errLocal.DbgMsgWrite(0,L"DS_NAME_ERROR_NOT_FOUND");
			else if (pNamesOut->rItems[0].status == DS_NAME_ERROR_NOT_UNIQUE)
	            errLocal.DbgMsgWrite(0,L"DS_NAME_ERROR_NOT_UNIQUE");
			else if (pNamesOut->rItems[0].status == DS_NAME_ERROR_RESOLVING)
	            errLocal.DbgMsgWrite(0,L"DS_NAME_ERROR_RESOLVING");
			else
	            errLocal.DbgMsgWrite(0,L"General DSCrackNames Error");

	        DsFreeNameResult(pNamesOut);
		}
	}
	return bConverted;
}
*/

STDMETHODIMP 
   CChangeDomain::ChangeToDomain(
      BSTR                   activeComputerName,   // in - computer name currently being used (old name if simultaneously renaming and changing domain)
      BSTR                   domain,               // in - domain to move computer to
      BSTR                   newComputerName,      // in - computer name the computer will join the new domain as (the name that will be in effect on reboot, if simultaneously renaming and changing domain)
      BSTR                 * errReturn             // out- string describing any errors that occurred
   )
{
   HRESULT                   hr = S_OK;

   return hr;
}



STDMETHODIMP 
   CChangeDomain::ChangeToDomainWithSid(
      BSTR                   activeComputerName,   // in - computer name currently being used (old name if simultaneously renaming and changing domain)
      BSTR                   domain,               // in - domain to move computer to
      BSTR                   domainSid,            // in - sid of domain, as string
      BSTR                   domainController,     // in - domain controller to use
      BSTR                   newComputerName,      // in - computer name the computer will join the new domain as (the name that will be in effect on reboot, if simultaneously renaming and changing domain)
      BSTR                   srcPath,		   // in - source account original LDAP path
      BSTR                 * errReturn             // out- string describing any errors that occurred
   )
{
   HRESULT                   hr = S_OK;
   LSA_HANDLE                PolicyHandle = NULL;
   LPWSTR                    Workstation; // target machine of policy update
   WCHAR                     Password[LEN_Password];
   PSID                      DomainSid=NULL;      // Sid representing domain to trust
   LPWSTR                    PrimaryDC=NULL;    // name of that domain's PDC
   PSERVER_INFO_101          si101 = NULL;
   DWORD                     Type;
   NET_API_STATUS            nas;
   NTSTATUS                  Status;
   WCHAR                     errMsg[1000];
   BOOL                      bSessionEstablished = TRUE;
   WCHAR                     TrustedDomainName[LEN_Domain];
   WCHAR                     LocalMachine[MAX_PATH] = L"";
   DWORD                     lenLocalMachine = DIM(LocalMachine);
   LPWSTR                    activeWorkstation = L"";
//   WCHAR                   * errString = GET_BSTR(IDS_Unspecified_Failure);
//   WCHAR					 sPaths[MAX_PATH];
//   BOOL						 bLDAP;
   
   // initialize output parameters
   (*errReturn) = NULL;
   // commenting out the line below will write a log file that is useful for debugging
// errLocal.LogOpen(L"C:\\ChangeDomain.log",0);
//sleep for 3 minutes so I can attach in the debugger
//errLocal.DbgMsgWrite(0,L"Started 3 minute sleep");
//SleepEx(120000, FALSE);
//errLocal.DbgMsgWrite(0,L"Ended 3 minute sleep");

   // use the target name, if provided
   if ( newComputerName && UStrLen((WCHAR*)newComputerName) )
   {
      Workstation = (WCHAR*)newComputerName;
      if ( ! activeComputerName || ! UStrLen((WCHAR*)activeComputerName) )
      {
         activeWorkstation = LocalMachine;
      }
      else
      {
         activeWorkstation = (WCHAR*)activeComputerName;
      }
   }
   else
   {
      
      if (! activeComputerName || ! UStrLen((WCHAR*)activeComputerName) )
      {
         GetComputerName(LocalMachine,&lenLocalMachine);
         Workstation = LocalMachine;
         activeWorkstation = L"";
      }
      else
      {
         Workstation = (WCHAR*)activeComputerName;
         activeWorkstation = Workstation;
      }
      
   }
   wcscpy(TrustedDomainName,(WCHAR*)domain);
   
   if ( Workstation[0] == L'\\' )
      Workstation += 2;

   // Use a default password
   for ( UINT p = 0 ; p < wcslen(Workstation) ; p++ )
      Password[p] = towlower(Workstation[p]);
   Password[wcslen(Workstation)] = 0;

   // ensure that the password is truncated at 14 characters
   Password[14] = 0;

   //
   // insure the target machine is NOT a DC, as this operation is
   // only appropriate against a workstation.
   //
   do // once  
   { 
      nas = NetServerGetInfo(activeWorkstation, 101, (LPBYTE *)&si101);
      if(nas != NERR_Success) 
      {
         hr = HRESULT_FROM_WIN32(nas);
         errLocal.DbgMsgWrite(0,L"NetServerGetInfo failed, rc=%ld",nas);
         break;
      }
      errLocal.DbgMsgWrite(0,L"NetServerGetInfo succeeded, version=%ld.",si101->sv101_version_major);
      errLocal.DbgMsgWrite(0,L"Workstation=%ls, Password=%ls, activeWorkstation=%ls",Workstation,Password,activeWorkstation);
      GetNetJoinDomainFunction();
      if ( si101->sv101_version_major >= 5 && gNetJoinDomain != NULL )
//      if ( si101->sv101_version_major >= 5 )
      {
         BOOL              bImpersonating = FALSE;
         if ( m_account.length() )
         {
            errLocal.DbgMsgWrite(0,L"Trying to establish session using credentials %ls\\%ls",(WCHAR*)m_domain,(WCHAR*)m_account);
         
            HANDLE      hLogon;

            if ( LogonUser(m_account,m_domain,m_password,LOGON32_LOGON_INTERACTIVE,LOGON32_PROVIDER_DEFAULT,&hLogon) )
            {
               errLocal.DbgMsgWrite(0,L"LogonUser succeeded!");
               if ( ! ImpersonateLoggedOnUser(hLogon) )
               {
                  errLocal.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_IMPERSONATION_FAILED_SSD,(WCHAR*)m_domain,(WCHAR*)m_account,GetLastError());
               }
               else
               {
                  errLocal.DbgMsgWrite(0,L"Impersonating!");
                  bImpersonating = TRUE;
               }
               CloseHandle(hLogon);
            }
            else
            {
               errLocal.DbgMsgWrite(0,L"LogonUser failed,rc=%ld",GetLastError());
            }
         }
		 
/*		 bLDAP = GetLDAPPath(TrustedDomainName, Workstation, sPaths);
		 if (bLDAP)
            errLocal.DbgMsgWrite(0,L"GetLDAPPath Success with %ls", sPaths);
		 else
            errLocal.DbgMsgWrite(0,L"GetLDAPPath Failure");
*/
         // Use NetJoinDomain
/*		 WCHAR amachine[MAX_PATH];
		 if (UStrLen((WCHAR*)activeWorkstation))
			wcscpy(amachine, (WCHAR*)activeWorkstation);
		 else
			wcscpy(amachine, LocalMachine);
 		 errLocal.DbgMsgWrite(0,L"Calling NetUnjoinDomain(%ls,%ls,xxxxxx)",amachine,(WCHAR*)m_domainAccount);

		 hr = NetUnjoinDomain(amachine,m_domainAccount,m_password,NETSETUP_ACCT_DELETE);
		 if (hr == NERR_Success)
		 {
			errLocal.DbgMsgWrite(0,L"Calling NetJoinDomain(%ls,%ls,%ls,xxxxxx)",amachine,(WCHAR*)TrustedDomainName,
				(WCHAR*)m_domainAccount);
			hr = NetJoinDomain(amachine,TrustedDomainName,
				NULL,m_domainAccount,m_password,NETSETUP_JOIN_DOMAIN | NETSETUP_DOMAIN_JOIN_IF_JOINED | NETSETUP_JOIN_UNSECURE);
			errLocal.DbgMsgWrite(0,L"NetJoinDomain returned %ld",hr);
			if (hr == ERROR_NO_TRUST_SAM_ACCOUNT)
			{
				IADs        * pADs = NULL;
				VARIANT		var;
				VariantInit(&var);
				long		ControlNum;

				errLocal.DbgMsgWrite(0,L"NetJoinDomain failed");
//				if (bLDAP)
				if (TRUE)
				{
					errLocal.DbgMsgWrite(0,L"Call ADsGetObject for %ls", srcPath);
					hr = ADsGetObject(srcPath,IID_IADs,(void**)&pADs);
					if ( SUCCEEDED(hr) )
					{
					   errLocal.DbgMsgWrite(0,L"ADsGetObject Succeeded for %ls", srcPath);
					   hr = pADs->Get(SysAllocString(L"userAccountControl"),&var);
					   if ( SUCCEEDED(hr) )
					   {
						   ControlNum = var.lVal;
						   errLocal.DbgMsgWrite(0,L"userAccountControl was %ld", ControlNum);
						   ControlNum -= 2;
						   errLocal.DbgMsgWrite(0,L"userAccountControl will be %ld", ControlNum);
						   var.lVal = ControlNum;
						   hr = pADs->Put(SysAllocString(L"userAccountControl"),var);
						   VariantClear(&var);
						   if ( SUCCEEDED(hr) )
						   {
						      errLocal.DbgMsgWrite(0,L"userAccountControl now set to %ld", ControlNum);
							  hr = pADs->SetInfo();
					          if ( SUCCEEDED(hr) )
							  {
						         errLocal.DbgMsgWrite(0,L"userAccountControl Set!");
								 hr = NetJoinDomain(amachine,TrustedDomainName,
										NULL,m_domainAccount,m_password,NETSETUP_JOIN_DOMAIN | NETSETUP_DOMAIN_JOIN_IF_JOINED | NETSETUP_JOIN_UNSECURE);
								 errLocal.DbgMsgWrite(0,L"NetJoinDomain returned %ld",hr);
							  }
						   }
					   }
				       if ( FAILED(hr) )
						  errLocal.DbgMsgWrite(0,L"Failed to get userAccountControl for %ls", srcPath);
				       pADs->Release();
				    }
				}
			}
			else if ( hr )
			{
				hr = HRESULT_FROM_WIN32(hr);
				break;
			}
		 }
*/		 errLocal.DbgMsgWrite(0,L"Calling NetJoinDomain(%ls,%ls,%ls,xxxxxx)",(WCHAR*)activeWorkstation,(WCHAR*)TrustedDomainName,
				(WCHAR*)m_domainAccount);

         // if specified, use preferred domain controller

         _bstr_t strDomain = domain;

         if (domainController && *domainController)
         {
            strDomain += L"\\";
            strDomain += domainController;
         }

         hr = (*gNetJoinDomain)(activeWorkstation,strDomain,
            NULL,m_domainAccount,m_password,NETSETUP_JOIN_DOMAIN | NETSETUP_DOMAIN_JOIN_IF_JOINED | NETSETUP_JOIN_UNSECURE);

         errLocal.DbgMsgWrite(0,L"NetJoinDomain returned %ld",hr);

         if ( hr )
         {
            hr = HRESULT_FROM_WIN32(hr);
            break;
         }

         if ( bImpersonating )
         {
            errLocal.DbgMsgWrite(0,L"Reverting to self.");
            RevertToSelf();
         }
      }
      else
      {
         errLocal.DbgMsgWrite(0,L"NetJoinDomain function is not available.  Using LSA APIs instead.");
         // Use LSA APIs
         Type = si101->sv101_type;
         
         if( (Type & SV_TYPE_DOMAIN_CTRL) ||
           (Type & SV_TYPE_DOMAIN_BAKCTRL) ) 
         {
            swprintf(errMsg,GET_STRING(IDS_NotAllowedOnDomainController));
            errLocal.DbgMsgWrite(ErrE,L"Cannot migrate domain controller");
            hr = E_NOTIMPL;
            break;

         }
         errLocal.DbgMsgWrite(0,L"This computer is not a Domain Controller.");
         //
         // do not allow a workstation to trust itself
         //
         if(lstrcmpiW(TrustedDomainName, Workstation) == 0) 
         {
            swprintf(errMsg,GET_STRING(IDS_CannotTrustSelf),
               TrustedDomainName);
            errLocal.DbgMsgWrite(0,L"Cannot trust workstation itself");
            hr = E_INVALIDARG; 
            break;
         }
      
         if( lstrlenW(TrustedDomainName ) > MAX_COMPUTERNAME_LENGTH )
         {
            TrustedDomainName[MAX_COMPUTERNAME_LENGTH] = L'\0'; // truncate
         }

         //
         // get the name of the domain DC
         //
         if(!GetDomainDCName(TrustedDomainName,&PrimaryDC)) 
         {
            swprintf(errMsg,GET_STRING(IDS_CannotGetDCName),TrustedDomainName);
            hr = HRESULT_FROM_WIN32(GetLastError());
            errLocal.DbgMsgWrite(ErrE,L"GetDomainDCName(%ls), rc=%ld",TrustedDomainName,GetLastError());
            break;
         }
         errLocal.DbgMsgWrite(0,L"GetDomainDCName succeeded.");
         
         if ( ! m_bNoChange )
         {
            //
            // build the DomainSid of the domain to trust
            //
            DomainSid = SidFromString(domainSid);
            if(!DomainSid ) 
            {
               //DisplayError(errMsg,"GetDomainSid", GetLastError(),NULL);
               hr = HRESULT_FROM_WIN32(GetLastError());
               errLocal.DbgMsgWrite(ErrE,L"GetDomainSid(%ls), rc=%ld",PrimaryDC,GetLastError());
               break;
            }
            errLocal.DbgMsgWrite(0,L"GetDomainSid succeeded.");
         
         }
         errLocal.DbgMsgWrite(0,L"m_bNoChange=%ld, version=%ld",m_bNoChange,si101->sv101_version_major);
         if ( (!m_bNoChange) && (si101->sv101_version_major < 4) )
         {
            // For NT 3.51 machines, we must move the computer to a workgroup, and 
            // then move it into the new domain
            hr = ChangeToWorkgroup(SysAllocString(activeWorkstation),SysAllocString(L"WORKGROUP"),errReturn);
            QueryWorkstationTrustedDomainInfo(PolicyHandle,DomainSid,m_bNoChange);
            if ( FAILED(hr) )
            {
               errLocal.DbgMsgWrite(0,L"ChangeToWorkgroup failed, hr=%lx",hr);
            }
            else
            {
               errLocal.DbgMsgWrite(0,L"ChangeToWorkgroup succeeded, hr=%lx",hr);
            }
         }
         //
         // see if the computer account exists on the domain
         //
         
         //
         // open the policy on this computer
         //
         Status = OpenPolicy(
                  activeWorkstation,
                  DELETE                      |    // to remove a trust
                  POLICY_VIEW_LOCAL_INFORMATION | // to view trusts
                  POLICY_CREATE_SECRET |  // for password set operation
                  POLICY_TRUST_ADMIN,     // for trust creation
                  &PolicyHandle
                  );

         if( Status != STATUS_SUCCESS ) 
         {
            hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
            errLocal.DbgMsgWrite(ErrE,L"OpenPolicy failed,hr=%lx",hr);
            break;
         }

         errLocal.DbgMsgWrite(ErrE,L"OpenPolicy succeeded.");
 
         if ( ! m_bNoChange )
         {
            QueryWorkstationTrustedDomainInfo(PolicyHandle,DomainSid,m_bNoChange);
            Status = SetWorkstationTrustedDomainInfo(
                  PolicyHandle,
                  DomainSid,
                  TrustedDomainName,
                  Password,
                  errMsg
                  );
         }

         if( Status != STATUS_SUCCESS ) 
         {
            hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
            errLocal.DbgMsgWrite(ErrE,L"SetWorkstationTrustedDomainInfo failed,hr=%lx",Status);
            break;
         }
         errLocal.DbgMsgWrite(ErrE,L"SetWkstaTrustedDomainInfo succeeded.");

         //
         // Update the primary domain to match the specified trusted domain
         //
         if (! m_bNoChange )
         {
            Status = SetPrimaryDomain(PolicyHandle, DomainSid, TrustedDomainName);

            if(Status != STATUS_SUCCESS) 
            {
           //    DisplayNtStatus(errMsg,"SetPrimaryDomain", Status,NULL);
               hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
               errLocal.DbgMsgWrite(ErrE,L"SetPrimaryDomain failed,hr=%lx",hr);
               break;
            }
            errLocal.DbgMsgWrite(ErrE,L"SetPrimaryDomain succeeded.");
         }
         
         NetApiBufferFree(si101);
      }    
   } while (false);  // do once 

   // Cleanup
   //
   // free the buffer allocated for the PDC computer name
   //
   if(PrimaryDC)
   {
      NetApiBufferFree(PrimaryDC);
   }

   //LocalFree(Workstation);

   //
   // free the Sid which was allocated for the TrustedDomain Sid
   //
   if(DomainSid)
   {
      FreeSid(DomainSid);
   }

   //
   // close the policy handle
   //
   if ( PolicyHandle )
   {
      LsaClose(PolicyHandle);
   }
   
   if ( bSessionEstablished )
   {
      EstablishSession(activeWorkstation,m_domain,m_account,m_password,FALSE);
   }

/*   if ( hDll )
   {
      FreeLibrary(hDll);
      hDll = NULL;
   }
*/   if ( FAILED(hr) )
   {
      (*errReturn) = NULL;
   }
   return hr;
}


STDMETHODIMP 
   CChangeDomain::ChangeToWorkgroup(
      BSTR                   Computer,       // in - name of computer to update
      BSTR                   Workgroup,      // in - name of workgroup to join
      BSTR                 * errReturn       // out- text describing error if failure
   )
{
    HRESULT                   hr = S_OK;
   LSA_HANDLE                PolicyHandle;
   LPWSTR                    Workstation; // target machine of policy update
   LPWSTR                    TrustedDomainName; // domain to join
//   LPWSTR                    PrimaryDC=NULL;    // name of that domain's PDC
   PSERVER_INFO_101          si101;
   DWORD                     Type;
   NET_API_STATUS            nas;
   NTSTATUS                  Status;
   WCHAR                     errMsg[1000];
//   BOOL                      bSessionEstablished = FALSE;

   // initialize output parameters
   (*errReturn) = NULL;

   Workstation = (WCHAR*)Computer;
   TrustedDomainName = (WCHAR*)Workgroup;
    
   errLocal.DbgMsgWrite(0,L"Changing to workgroup...");
   //
   // insure the target machine is NOT a DC, as this operation is
   // only appropriate against a workstation.
   //
   do // once  
   { 
      /*if ( m_account.length() )
      {
         // Establish our credentials to the target machine
         if (! EstablishSession(Workstation,m_domain,m_account,m_password, TRUE) )
         {
           // DisplayError(errMsg,"EstablishSession",GetLastError(),NULL);
            hr = GetLastError();
         }
         else
         {
            bSessionEstablished = TRUE;
         }
      }
      */
      nas = NetServerGetInfo(Workstation, 101, (LPBYTE *)&si101);
   
      if(nas != NERR_Success) 
      {
         //DisplayError(errMsg, "NetServerGetInfo", nas,NULL);
         hr = E_FAIL;
         break;
      }

      Type = si101->sv101_type;
      NetApiBufferFree(si101);

      if( (Type & SV_TYPE_DOMAIN_CTRL) ||
        (Type & SV_TYPE_DOMAIN_BAKCTRL) ) 
      {
         swprintf(errMsg,L"Operation is not valid on a domain controller.\n");
         hr = E_FAIL;
         break;

      }

      //
      // do not allow a workstation to trust itself
      //
      if(lstrcmpiW(TrustedDomainName, Workstation) == 0) 
      {
         swprintf(errMsg,L"Error:  Domain %ls cannot be a member of itself.\n",
            TrustedDomainName);
         hr = E_FAIL; 
         break;
      }

      if( lstrlenW(TrustedDomainName ) > MAX_COMPUTERNAME_LENGTH )
      {
         TrustedDomainName[MAX_COMPUTERNAME_LENGTH] = L'\0'; // truncate
      }

      //
      // open the policy on this computer
      //
      Status = OpenPolicy(
               Workstation,
               DELETE                      |    // to remove a trust
               POLICY_VIEW_LOCAL_INFORMATION | // to view trusts
               POLICY_CREATE_SECRET |  // for password set operation
               POLICY_TRUST_ADMIN,     // for trust creation
               &PolicyHandle
               );

      if( Status != STATUS_SUCCESS ) 
      {
         //DisplayNtStatus(errMsg,"OpenPolicy", Status,NULL);
         hr = LsaNtStatusToWinError(Status);
         break;
      }

      if( Status != STATUS_SUCCESS ) 
      {
         hr = E_FAIL;
         break;
      }


      //
      // Update the primary domain to match the specified trusted domain
      //
      if (! m_bNoChange )
      {
         Status = SetPrimaryDomain(PolicyHandle, NULL, TrustedDomainName);

         if(Status != STATUS_SUCCESS) 
         {
            //DisplayNtStatus(errMsg,"SetPrimaryDomain", Status,NULL);
            hr = LsaNtStatusToWinError(Status);
            break;
         }

      }
   } while (false);  // do once 

   // Cleanup
   //
   // close the policy handle
   //
   
   LsaClose(PolicyHandle);
   
   /*if ( bSessionEstablished )
   {
      EstablishSession(Workstation,m_domain,m_account,m_password,FALSE);
   }
   */
   if ( FAILED(hr) )
   {
      hr = S_FALSE;
      (*errReturn) = SysAllocString(errMsg);
   }
   return hr;

}

STDMETHODIMP 
   CChangeDomain::ConnectAs(
      BSTR                   domain,            // in - domain name to use for credentials
      BSTR                   user,              // in - account name to use for credentials
      BSTR                   password           // in - password to use for credentials
   )
{
	m_domain = domain;
   m_account = user;
   m_password = password;
   m_domainAccount = domain;
   m_domainAccount += L"\\";
   m_domainAccount += user;
   return S_OK;
}

STDMETHODIMP 
   CChangeDomain::get_NoChange(
      BOOL                 * pVal              // out- flag, whether to write changes
   )
{
	(*pVal) = m_bNoChange;
	return S_OK;
}

STDMETHODIMP 
   CChangeDomain::put_NoChange(
      BOOL                   newVal           // in - flag, whether to write changes
   )
{
	m_bNoChange = newVal;
   return S_OK;
}


// ChangeDomain worknode:  Changes the domain affiliation of a workstation or server
//                         (This operation cannot be performed on domain controllers)
//
// VarSet syntax:
//
// Input:  
//          ChangeDomain.Computer: <ComputerName>
//          ChangeDomain.TargetDomain: <Domain>
//          ChangeDomain.DomainIsWorkgroup: <Yes|No>           default is No
//          ChangeDomain.ConnectAs.Domain: <Domain>            optional credentials to use
//          ChangeDomain.ConnectAs.User : <Username>
//          ChangeDomain.ConnectAs.Password : <Password>
//
// Output:
//          ChangeDomain.ErrorText : <string-error message>

// This function is not currently used by the domain migration tool.
// it is here to provide an alternate API for scripting clients
STDMETHODIMP 
   CChangeDomain::Process(
      IUnknown             * pWorkItem
   )
{
   HRESULT                   hr = S_OK;
   
    
   IVarSetPtr                pVarSet = pWorkItem;
   _bstr_t                   computer;
   _bstr_t                   domain;
   _bstr_t                   text;
   BOOL                      bWorkgroup = FALSE;
   BSTR                      errText = NULL;

   computer = pVarSet->get(L"ChangeDomain.Computer");
   domain = pVarSet->get(L"ChangeDomain.TargetDomain");
   text = pVarSet->get(L"ChangeDomain.DomainIsWorkgroup");
   if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      bWorkgroup = TRUE;
   }
   _bstr_t userdomain = pVarSet->get(L"ChangeDomain.ConnectAs.Domain");
   _bstr_t username = pVarSet->get(L"ChangeDomain.ConnectAs.User");
   _bstr_t password = pVarSet->get(L"ChangeDomain.ConnectAs.Password");
   if ( username.length() )
   {
      ConnectAs(userdomain,username,password);
   }
   if ( bWorkgroup )
   {
      hr = ChangeToWorkgroup(computer,domain,&errText);      
   }
   else
   {
      hr = ChangeToDomain(computer,domain,NULL,&errText);
   }
   if ( text.length() )
   {
      pVarSet->put(L"ChangeDomain.ErrorText",errText);
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\dctstat.h ===
#define DCT_STATUS_NOT_STARTED         (0x00000001)
#define DCT_STATUS_IN_PROGRESS         (0x00000002)
#define DCT_STATUS_ABORTING            (0x00000004)
#define DCT_STATUS_ABORTED             (0x00000008)
#define DCT_STATUS_COMPLETED           (0x00000010)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\acctrepl.cpp ===
/*---------------------------------------------------------------------------
  File: AcctRepl.cpp

  Comments: Implementation of Account Replicator COM object.
  This COM object handles the copying or moving of directory objects.

  Win2K to Win2K migration is implemented in this file.
  NT -> Win2K migration is implemented in UserCopy.cpp

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/12/99 10:08:44

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

// AcctRepl.cpp : Implementation of CAcctRepl
#include "stdafx.h"
#include "WorkObj.h"

#include "AcctRepl.h"
#include "BkupRstr.hpp"
#include "StrHelp.h"

/////////////////////////////////////////////////////////////////////////////
// CAcctRepl

#include "Err.hpp"
#include "ErrDct.hpp"
#include "EaLen.hpp"
#include <dsgetdc.h>

#include "UserRts.h" 
#include "RebootU.h"

#include "DCTStat.h"
#include "ResStr.h"
#include "LSAUtils.h"
#include "ARUtil.hpp"
#include "Names.hpp"
#include <lm.h>
#include <iads.h>
//#include <adshlp.h>
#include "RegTrans.h"
#include "TEvent.hpp"
#include "RecNode.hpp"
#include "ntdsapi.h"
#include "TxtSid.h"
#include "ExLDAP.h"
#include "Win2KErr.h"

//#import "\bin\McsDctWorkerObjects.tlb"
//#import "\bin\McsVarSetMin.tlb" no_namespace
//#import "\bin\AdsProp.tlb" no_namespace
//#import "\bin\NetEnum.tlb" no_namespace 
//#import "\bin\DBManager.tlb" no_namespace
//#import "WorkObj.tlb" //already #imported via ARUtil.cpp
//#import "VarSet.tlb" no_namespace rename("property", "aproperty")//already #imported by AcctRepl.h
#import "AdsProp.tlb" no_namespace
#import "NetEnum.tlb" no_namespace 
//#import "DBMgr.tlb" no_namespace //already #imported via ARUtil.cpp

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IVarSet                    * g_pVarSet = NULL;

TErrorDct                    err;
TError                     & errCommon = err;
extern bool				     g_bAddSidWorks;
DWORD                        g_dwOpMask = OPS_All;  // Global OpSeq by default all ops

bool                         bAbortMessageWritten = false;

BOOL BuiltinRid(DWORD rid);

typedef HRESULT (CALLBACK * DSGETDCNAME)(LPWSTR, LPWSTR, GUID*, LPWSTR, DWORD, PDOMAIN_CONTROLLER_INFO*);
ADSGETOBJECT            ADsGetObject;
typedef BOOL (CALLBACK * TConvertStringSidToSid)(LPCWSTR   StringSid,PSID   *Sid);
TConvertStringSidToSid  ConvertStringSidToSid;

bool                    firstTime = true;

typedef struct _Lookup {
   WCHAR             * pName;
   WCHAR             * pType;
} Lookup;

//Function to sort by account sam name only
int TNodeCompareNameOnly(TNode const * t1,TNode const * t2)
{
   // Sort function to sort by Type(dec) and Name(asc)
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   TAcctReplNode     const * n2 = (TAcctReplNode *)t2;


   return UStrICmp(n1->GetSourceSam(), n2->GetTargetSam());
}

// Function to do a find on the Account list that is sorted with TNodeCompareNameOnly function.
int TNodeFindByNameOnly(TNode const * t1, void const * pVoid)
{
   TAcctReplNode  const * n1 = (TAcctReplNode *) t1;
   WCHAR                * pLookup = (WCHAR *) pVoid;

   return UStrICmp(n1->GetTargetSam(), pLookup);
}


int TNodeCompareAccountType(TNode const * t1,TNode const * t2)
{
   // Sort function to sort by Type(dec) and Name(asc)
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   TAcctReplNode     const * n2 = (TAcctReplNode *)t2;

   // Compare types
   int retVal = UStrICmp(n2->GetType(), n1->GetType());
   if ( retVal == 0 ) 
   {
      // If same type then compare names.
      return UStrICmp(n1->GetName(), n2->GetName());
   }
   else
      return retVal;
}

// Function to sort by Account type and then by SamAccountName
int TNodeCompareAccountSam(TNode const * t1,TNode const * t2)
{
   // Sort function to sort by Type(dec) and Name(asc)
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   TAcctReplNode     const * n2 = (TAcctReplNode *)t2;

   // Compare types Sort in decending order
   int retVal = UStrICmp(n2->GetType(), n1->GetType());
   if ( retVal == 0 ) 
   {
      // If same type then compare Sam Account names.
      return UStrICmp(n1->GetSourceSam(), n2->GetSourceSam());
   }
   else
      return retVal;
}

// Function to do a find on the Account list that is sorted with TNodeCompareAccountType function.
int TNodeFindAccountName(TNode const * t1, void const * pVoid)
{
   TAcctReplNode  const * n1 = (TAcctReplNode *) t1;
   Lookup               * pLookup = (Lookup *) pVoid;

   int retVal = UStrICmp(pLookup->pType, n1->GetType());
   if ( retVal == 0 )
   {
      return UStrICmp(n1->GetSourceSam(), pLookup->pName);
   }
   else
      return retVal;
}

int TNodeCompareMember(TNode const * t1, TNode const * t2)
{
   TRecordNode const * n1 = (TRecordNode *) t1;
   TRecordNode const * n2 = (TRecordNode *) t2;

   if ( n1->GetARNode() < n2->GetARNode() )
      return -1;
   if ( n1->GetARNode() > n2->GetARNode() )
      return 1;
   return UStrICmp(n1->GetMember(), n2->GetMember());
}

int TNodeCompareMemberName(TNode const * t1, TNode const * t2)
{
   TRecordNode const * n1 = (TRecordNode *) t1;
   TRecordNode const * n2 = (TRecordNode *) t2;

   return UStrICmp(n1->GetMember(), n2->GetMember());
}

int TNodeCompareMemberDN(TNode const * t1, TNode const * t2)
{
   TRecordNode const * n1 = (TRecordNode *) t1;
   TRecordNode const * n2 = (TRecordNode *) t2;

   return UStrICmp(n1->GetDN(), n2->GetDN());
}


int TNodeCompareMemberItem(TNode const * t1, void const * t2)
{
   TRecordNode const * n1 = (TRecordNode *) t1;
   WCHAR const * n2 = (WCHAR const *) t2;

   return UStrICmp(n1->GetDN(),n2);
}

int TNodeCompareAcctNode(TNode const * t1, TNode const * t2)
{
   TRecordNode const * n1 = (TRecordNode *) t1;
   TRecordNode const * n2 = (TRecordNode *) t2;
   
   if ( n1->GetARNode() < n2->GetARNode() )
      return -1;
   if ( n1->GetARNode() > n2->GetARNode() )
      return 1;
   return 0;
}

// Checks to see if the account is from the BUILTIN domain.
BOOL IsBuiltinAccount(Options * pOptions, WCHAR * sAcctName)
{
   BOOL                      ret = FALSE;
   PSID                      sid = new BYTE[35];
   SID_NAME_USE              use;
   WCHAR                     sDomain[LEN_Path];
   DWORD                     dwDom, dwsid;

   if (!sid)
      return TRUE;
   dwDom = DIM(sDomain);
   dwsid = 35;
   if ( LookupAccountName(pOptions->srcComp, sAcctName, sid, &dwsid, sDomain, &dwDom, &use) )
   {
      ret = !_wcsicmp(sDomain, L"BUILTIN");
   }
   else
   {
//      DWORD rd = GetLastError();
   }
   if ( sid ) delete [] sid;
   return ret;
}

// global counters defined in usercopy.cpp
extern AccountStats          warnings;
extern AccountStats          errors;
extern AccountStats          created;
extern AccountStats          replaced;
extern AccountStats          processed;

// updates progress indicator
// this updates the stats entries in the VarSet
// this information will be returned to clients who call DCTAgent::QueryJobStatus
// while the job is running.
void 
   Progress(
      WCHAR          const * mesg          // in - progress message
   )
{
   if ( g_pVarSet )
   {
      g_pVarSet->put(GET_WSTR(DCTVS_CurrentPath),mesg);
      
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Users_Examined),processed.users);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Users_Created),created.users);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Users_Replaced),replaced.users);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Users_Warnings),warnings.users);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Users_Errors),errors.users);

      g_pVarSet->put(GET_WSTR(DCTVS_Stats_GlobalGroups_Examined),processed.globals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_GlobalGroups_Created),created.globals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_GlobalGroups_Replaced),replaced.globals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_GlobalGroups_Warnings),warnings.globals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_GlobalGroups_Errors),errors.globals);


      g_pVarSet->put(GET_WSTR(DCTVS_Stats_LocalGroups_Examined),processed.locals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_LocalGroups_Created),created.locals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_LocalGroups_Replaced),replaced.locals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_LocalGroups_Warnings),warnings.locals);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_LocalGroups_Errors),errors.locals);


      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Computers_Examined),processed.computers);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Computers_Created),created.computers);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Computers_Replaced),replaced.computers);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Computers_Warnings),warnings.computers);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Computers_Errors),errors.computers);

      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Generic_Examined),processed.generic);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Generic_Created),created.generic);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Generic_Replaced),replaced.generic);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Generic_Warnings),warnings.generic);
      g_pVarSet->put(GET_WSTR(DCTVS_Stats_Generic_Errors),errors.generic);
      
   }
   
}


// Gets the domain sid for the specified domain
BOOL                                       // ret- TRUE if successful
   GetSidForDomain(
      LPWSTR                 DomainName,   // in - name of domain to get SID for
      PSID                 * pDomainSid    // out- SID for domain, free with FreeSid
   )
{
   PSID                      pSid = NULL;
//   DWORD                     lenSid = 200;
   DWORD                     rc = 0;
   WCHAR                   * domctrl = NULL;
   
   if ( DomainName[0] != L'\\' )
   {
      rc = NetGetDCName(NULL,DomainName,(LPBYTE*)&domctrl);
   }
   if ( ! rc )
   {
      rc = GetDomainSid(domctrl,&pSid);
      NetApiBufferFree(domctrl);
   }
   (*pDomainSid) = pSid;
   
   return ( pSid != NULL);
}


STDMETHODIMP 
   CAcctRepl::Process(
      IUnknown             * pWorkItemIn   // in - VarSet defining account replication job
   )
{
   HRESULT                                     hr =  S_OK;
   IVarSetPtr                                  pVarSet = pWorkItemIn;
   
   MCSDCTWORKEROBJECTSLib::IStatusObjPtr       pStatus;
   BOOL                                        bSameForest = FALSE;

   HMODULE hMod = LoadLibrary(L"activeds.dll");
   if ( hMod == NULL )
   {
      DWORD eNum = GetLastError();
      err.SysMsgWrite(ErrE, eNum, DCT_MSG_LOAD_LIBRARY_FAILED_SD, L"activeds.dll", eNum);
      Mark(L"errors",L"generic");
   }

   ADsGetObject = (ADSGETOBJECT)GetProcAddress(hMod, "ADsGetObject");

   g_pVarSet = pVarSet;

   try{
      pStatus = pVarSet->get(GET_BSTR(DCTVS_StatusObject));
      opt.pStatus = pStatus;
   }
   catch (...)
   {
      // Oh well, keep going
   }
   // Load the options specified by the user including the account information
   WCHAR                  mesg[LEN_Path];
   wcscpy(mesg, GET_STRING(IDS_BUILDING_ACCOUNT_LIST));
   Progress(mesg);
   LoadOptionsFromVarSet(pVarSet);

   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   if ( BothWin2K(&opt) )
   {
      hr = pAccess->raw_IsInSameForest(opt.srcDomainDns,opt.tgtDomainDns, (long*)&bSameForest);
   }
   if ( SUCCEEDED(hr) )
   {
      opt.bSameForest = bSameForest;
   }

   // We are going to initialize the Extension objects
   m_pExt = new CProcessExtensions(pVarSet);
   
   TNodeListSortable    newList;
   if ( opt.expandMemberOf && ! opt.bUndo )  // always expand the member-of property, since we want to update the member-of property for migrated accounts
   {
      // Expand the containers and the membership
      wcscpy(mesg, GET_STRING(IDS_EXPANDING_MEMBERSHIP));
      Progress(mesg);
      // Expand the list to include all the groups that the accounts in this list are members of
      newList.CompareSet(&TNodeCompareAccountType);
      if ( newList.IsTree() ) newList.ToSorted();
      ExpandMembership( &acctList, &opt, &newList, Progress, FALSE);
   }

   if ( opt.expandContainers && !opt.bUndo)
   {
      // Expand the containers and the membership
      wcscpy(mesg, GET_STRING(IDS_EXPANDING_CONTAINERS));
      Progress(mesg);
      // Expand the list to include all the members of the containers.
      acctList.CompareSet(&TNodeCompareAccountType);
      ExpandContainers(&acctList, &opt, Progress);
   }

   // Add the newly created list ( if one was created )
   if ( opt.expandMemberOf && !opt.bUndo )
   {
      wcscpy(mesg, GET_STRING(IDS_MERGING_EXPANDED_LISTS));
      Progress(mesg);
      // add the new and the old list
      acctList.CompareSet(&TNodeCompareAccountType);
      for ( TNode * acct = newList.Head(); acct; )
      {
         TNode * temp = acct->Next();
         if ( ! acctList.InsertIfNew(acct) )
            delete acct;
         acct = temp;
      }
      Progress(L"");
   }
   do { // once

      // Copy the NT accounts for users, groups and/or computers
      if ( pStatus!= NULL && (pStatus->Status & DCT_STATUS_ABORTING) )
         break;
      int res;
      
      if ( opt.bUndo )
         res = UndoCopy(&opt,&acctList,&Progress, err,(IStatusObj *)((MCSDCTWORKEROBJECTSLib::IStatusObj *)pStatus),NULL);
      else
         res = CopyObj( &opt,&acctList,&Progress, err,(IStatusObj *)((MCSDCTWORKEROBJECTSLib::IStatusObj *)pStatus),NULL);
      // Close the password log
      if ( opt.passwordLog.IsOpen() )
      {
         opt.passwordLog.LogClose();
      }

      if ( pStatus != NULL && (pStatus->Status & DCT_STATUS_ABORTING) )
         break;
      // Update Rights for user and group accounts
      if ( m_UpdateUserRights )
      {
//         DWORD rc = UpdateUserRights((IStatusObj *)((MCSDCTWORKEROBJECTSLib::IStatusObj *)pStatus));
         UpdateUserRights((IStatusObj *)((MCSDCTWORKEROBJECTSLib::IStatusObj *)pStatus));
      }

      if ( pStatus != NULL && (pStatus->Status & DCT_STATUS_ABORTING) )
         break;
   
      // Change of Domain affiliation on computers and optional reboot will be done by local agent 
         
   } while (false);
   
   LoadResultsToVarSet(pVarSet);
   
   // Cleanup the account list
   if ( acctList.IsTree() )
   {
      acctList.ToSorted();
   }

   TNodeListEnum             e;
   TAcctReplNode           * tnode;
   TAcctReplNode           * tnext;


   for ( tnode = (TAcctReplNode *)e.OpenFirst(&acctList) ; tnode ; tnode = tnext )
   {
      tnext = (TAcctReplNode*)e.Next();
      acctList.Remove(tnode);
      delete tnode;
   }
   e.Close();
   err.LogClose();
   Progress(L"");
   if (m_pExt)
      delete m_pExt;
   
   g_pVarSet = NULL;
   if ( hMod )
      FreeLibrary(hMod);
      
   return hr;
}

//------------------------------------------------------------------------------
// CopyObj: When source and target domains are both Win2k this function calls
//          The 2kobject functions. Other wise it calls the User copy functions.
//------------------------------------------------------------------------------
int CAcctRepl::CopyObj(
                        Options              * options,      // in -options
                        TNodeListSortable    * acctlist,     // in -list of accounts to process
                        ProgressFn           * progress,     // in -window to write progress messages to
                        TError               & error,        // in -window to write error messages to
                        IStatusObj           * pStatus,      // in -status object to support cancellation
                        void                   WindowUpdate (void )    // in - window update function
                    )
{
   BOOL bSameForest = FALSE;
   long rc;
   HRESULT hr = S_OK;
   // if the Source/Target domain is NT4 then use the UserCopy Function. If both domains are Win2K then use
   // the CopyObj2K function to do so.
   if ( BothWin2K( options ) ) 
   {
      // Since these are Win2k domains we need to process it with Win2k code.
      MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
      // First of all we need to find out if they are in the same forest.
      HRESULT hr = pAccess->raw_IsInSameForest(options->srcDomainDns,options->tgtDomainDns, (long*)&bSameForest);
      if ( SUCCEEDED(hr) )
      {
         options->bSameForest = bSameForest;
         if ( !bSameForest || (options->flags & F_COMPUTERS) ) // always copy the computer accounts
         {
			 // Different forest we need to copy.
            rc = CopyObj2K(options, acctlist, progress, pStatus);
			if (opt.fixMembership)
			{
				// Update the group memberships
				rc = UpdateGroupMembership(options, acctlist, progress, pStatus);
				if ( !options->expandMemberOf )
				{
				   hr = UpdateMemberToGroups(acctlist, options, FALSE);
				   rc = HRESULT_CODE(hr);
				}
				else //if groups migrated, still expand but only for groups
				{
				   hr = UpdateMemberToGroups(acctlist, options, TRUE);
				   rc = HRESULT_CODE(hr);
				}
			}
			     //for user or group, migrate the manager\directReports or
			     //managedBy\managedObjects properties respectively
            if ((options->flags & F_USERS) || (options->flags & F_GROUP)) 
			     UpdateManagement(acctlist, options);
         }
         else 
         {
            // Within a forest we can move the object around.
            rc = MoveObj2K(options, acctlist, progress, pStatus);
         }

         if ( progress )
            progress(L"");
      }
      else
      {
         rc = -1;
         err.SysMsgWrite(ErrE, hr, DCT_MSG_ACCESS_CHECKER_FAILED_D, hr);
         Mark(L"errors",L"generic");
      }
   }
   else
   {
      // Create the object.
      rc = CopyObj2K(options, acctlist, progress, pStatus);
	  if (opt.fixMembership)
	  {
		rc = UpdateGroupMembership(options, acctlist, progress, pStatus);
		if ( !options->expandMemberOf )
		{
		   hr = UpdateMemberToGroups(acctlist, options, FALSE);
		   rc = HRESULT_CODE(hr);
		}
		else //if groups migrated, still expand but only for groups
		{
		   hr = UpdateMemberToGroups(acctlist, options, TRUE);
		   rc = HRESULT_CODE(hr);
		}
	  }
      // Call NT4 Code to update the group memberships
      //UpdateNT4GroupMembership(options, acctlist, progress, pStatus, WindowUpdate);
   }
   return rc;
}

//------------------------------------------------------------------------------
// BothWin2k: Checks to see if Source and Target domains are both Win2k.
//------------------------------------------------------------------------------
bool CAcctRepl::BothWin2K(                                     // True if both domains are win2k
                              Options  * pOptions              //in- options
                          )
{
   // This function checks for the version on the Source and Target domain. If either one is
   // a non Win2K domain then it returns false
   bool retVal = true;

   if ( (pOptions->srcDomainVer > -1) && (pOptions->tgtDomainVer > -1) )
      return ((pOptions->srcDomainVer > 4) && (pOptions->tgtDomainVer > 4));
   
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   HRESULT                      hr;
   DWORD                        verMaj, verMin, sp;
   
   hr = pAccess->raw_GetOsVersion(pOptions->srcComp, &verMaj, &verMin, &sp);

   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE,hr, DCT_MSG_GET_OS_VER_FAILED_SD, pOptions->srcDomain, hr);
      Mark(L"errors", L"generic");
      retVal = false;
   }
   else
   {
      pOptions->srcDomainVer = verMaj;
      if (verMaj < 5)
         retVal = false;
   }

   hr = pAccess->raw_GetOsVersion(pOptions->tgtComp, &verMaj, &verMin, &sp);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE, hr,DCT_MSG_GET_OS_VER_FAILED_SD, pOptions->tgtDomain , hr);
      Mark(L"errors", L"generic");
      retVal = false;
   }
   else
   {
      pOptions->tgtDomainVer = verMaj;
      if  (verMaj < 5)
         retVal = false;
   }
   return retVal;
}

int CAcctRepl::CopyObj2K( 
                           Options              * pOptions,    //in -Options that we recieved from the user
                           TNodeListSortable    * acctlist,    //in -AcctList of accounts to be copied.
                           ProgressFn           * progress,    //in -Progress Function to display messages
                           IStatusObj           * pStatus      // in -status object to support cancellation
                        )
{
   // This function copies the object from Win2K domain to another Win2K domain.

   TNodeTreeEnum             tenum;
   TAcctReplNode           * acct;
   IObjPropBuilderPtr        pObjProp(__uuidof(ObjPropBuilder));
   IVarSetPtr                pVarset(__uuidof(VarSet));
   IUnknown                * pUnk;
   HRESULT                   hr;
   _bstr_t                   currentType = L"";
//   TNodeListSortable		 pMemberOf;

   // sort the account list by Source Type\Source Name
   acctlist->CompareSet(&TNodeCompareAccountType);

   if ( acctlist->IsTree() ) acctlist->ToSorted();
   acctlist->SortedToScrambledTree();
   acctlist->Sort(&TNodeCompareAccountType);
   acctlist->Balance();

   if ( pOptions->flags & F_AddSidHistory )
	{
		//Need to Add Sid history on the target account. So lets bind it and go from there
		g_bAddSidWorks = BindToDS( pOptions->tgtComp, pOptions );
	}

	if ( pOptions->flags & F_TranslateProfiles )
	{
	  GetBkupRstrPriv((WCHAR*)NULL);
	  GetPrivilege((WCHAR*)NULL,SE_SECURITY_NAME);
	}

   // Get the defaultNamingContext for the source domain
   _variant_t                var;

   // Get an IUnknown pointer to the Varset for passing it around.
   hr = pVarset->QueryInterface(IID_IUnknown, (void**)&pUnk);

   for ( acct = (TAcctReplNode *)tenum.OpenFirst(acctlist) ; acct ; acct = (TAcctReplNode *)tenum.Next() )
   {
        //record group membership for intra-forest computer migrations
/*	  if ((opt.bSameForest) && (pOptions->flags & F_COMPUTERS))
	  {
         WCHAR mesg[LEN_Path];
         wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBEROF_S), acct->GetName());
         Progress(mesg);
         RecordAndRemoveMemberOf( pOptions, acct, &pMemberOf );
	  }
*/
      if (m_pExt && acct->CallExt())
      {
         hr = m_pExt->Process(acct, pOptions->tgtDomain, pOptions,TRUE);
      }
      // We will process accounts only if the corresponding check boxes (for object types to copy) are checked.
      if ( !NeedToProcessAccount( acct, pOptions ) )
         continue;

      // If we are told not to copy the object then we will obey
      if ( !acct->CreateAccount() )
         continue;

	  //if the UPN name conflicted, then the UPNUpdate extension set the hr to
	  //ERROR_OBJECT_ALREADY_EXISTS.  If so, set flag for "no change" mode
	  if (acct->GetHr() == ERROR_OBJECT_ALREADY_EXISTS)
	  {
	     acct->bUPNConflicted = TRUE;
		 acct->SetHr(S_OK);
	  }

      // Mark processed object count and update the status display
      Mark(L"processed", acct->GetType());
	   
      if ( pStatus )
      {
         LONG                status = 0;
         HRESULT             hr = pStatus->get_Status(&status);
         
         if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
         {
            if ( !bAbortMessageWritten ) 
            {
               err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
               bAbortMessageWritten = true;
            }
            break;
         }
      }

      // Create the target object
      WCHAR                  mesg[LEN_Path];
      wsprintf(mesg, GET_STRING(IDS_CREATING_S), acct->GetName());
      if ( progress )
         progress(mesg);

      HRESULT hrCreate = Create2KObj(acct, pOptions);
      
      acct->SetHr(hrCreate);
      if ( SUCCEEDED(hrCreate) )
      {
         err.MsgWrite(0, DCT_MSG_ACCOUNT_CREATED_S, acct->GetTargetName());
      }
      else 
      {
         // if the object already exists and the Replce flag is set then we should tell the user that we are replcing the target.
         if ((HRESULT_CODE(hrCreate) == ERROR_OBJECT_ALREADY_EXISTS) )
         {
            if (pOptions->flags & F_REPLACE)
            {
               // don't say we've replaced the account yet, because the replace may fail
               //err.MsgWrite(0, DCT_MSG_ACCOUNT_REPLACED_S, acct->GetTargetName());
            }
         }
         else 
         {
            if ( acct->IsCritical() )
            {
               err.SysMsgWrite(ErrE,ERROR_SPECIAL_ACCOUNT,DCT_MSG_REPLACE_FAILED_SD,acct->GetName(),ERROR_SPECIAL_ACCOUNT);
               Mark(L"errors", acct->GetType());
            }
            else
            {
               if ( HRESULT_CODE(hrCreate) == ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH )
               {
                  err.MsgWrite(ErrE, DCT_MSG_CANT_REPLACE_DIFFERENT_TYPE_SS, acct->GetTargetPath(), acct->GetSourcePath() );
                  Mark(L"errors", acct->GetType());
               }
               else
               {
                  err.SysMsgWrite(ErrE, hrCreate, DCT_MSG_CREATE_FAILED_SSD, acct->GetName(), pOptions->tgtDomain, hrCreate);
                  Mark(L"errors", acct->GetType());
               }
            }
         }
      }   
      
   	  if ( acct->WasCreated() )
      {
         // Do we need to add sid history
			if ( pOptions->flags & F_AddSidHistory )
			{
				// Global flag tells us if we should try the AddSidHistory because
				// for some special cases if it does not work once it will not work
				// see the AddSidHistory function for more details.
				if ( g_bAddSidWorks )
				{
                   WCHAR                  mesg[LEN_Path];
                   wsprintf(mesg, GET_STRING(IDS_ADDING_SIDHISTORY_S), acct->GetName());
                   if ( progress )
                      progress(mesg);
				   if (! AddSidHistory( pOptions, acct->GetSourceSam(), acct->GetTargetSam(), pStatus ) )
				   {
                     Mark(L"errors", acct->GetType());
				   }
//               CopySidHistoryProperty(pOptions, acct, pStatus);
				}
			}
	  }
   }
/*     //fix group membership for intra-forest computer migrations
   if ((opt.bSameForest) && (pOptions->flags & F_COMPUTERS))
   {
      WCHAR mesg[LEN_Path];
      wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RESET_MEMBERSHIP_S));
      Progress(mesg);
      ResetObjectsMembership( pOptions,&pMemberOf, pOptions->pDb );
   }
*/
   tenum.Close();

   bool bWin2k = BothWin2K(pOptions);
   TErrorEventLog					  evtLog(pOptions->srcComp, GET_STRING(IDS_EVENT_SOURCE));


   for ( acct = (TAcctReplNode *)tenum.OpenFirst(acctlist) ; acct ; acct = (TAcctReplNode *)tenum.Next() )
   {
      if ( pStatus )
      {
         LONG                status = 0;
         HRESULT             hr = pStatus->get_Status(&status);
         
         if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
         {
            if ( !bAbortMessageWritten ) 
            {
               err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
               bAbortMessageWritten = true;
            }
            break;
         }
      }
      // We are told not to copy the properties to the account so we ignore it.
      if ( acct->CopyProps() )
      {
         // If the object type is different from the one that was processed prior to this then we need to map properties
         if ((!pOptions->nochange) && (_wcsicmp(acct->GetType(),currentType) != 0))
         {
            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, GET_STRING(IDS_MAPPING_PROPS_S), acct->GetType());
            if ( progress )
               progress(mesg);
            // Set the current type
            currentType = acct->GetType();
            // Clear the current mapping 
            pVarset->Clear();
            // Get a new mapping
            if ( BothWin2K(pOptions) )
			{
               hr = pObjProp->raw_MapProperties(currentType, pOptions->srcDomain, pOptions->srcDomainVer, currentType, pOptions->tgtDomain, pOptions->tgtDomainVer, 0, &pUnk);
			   if (hr == DCT_MSG_PROPERTIES_NOT_MAPPED)
			   {
                  err.MsgWrite(ErrW,DCT_MSG_PROPERTIES_NOT_MAPPED, acct->GetType());
				  hr = S_OK;
			   }
			}
            else
               hr = S_OK;

            if ( FAILED( hr ) )
            {
               err.SysMsgWrite(ErrE, hr, DCT_MSG_PROPERTY_MAPPING_FAILED_SD, (WCHAR*)currentType, hr);
               Mark(L"errors", currentType);
               // No properties should be set if mapping fails
               pVarset->Clear();
            }
         }
         // We update the properties if the object was created or it already existed and the replce flag is set.
		 BOOL bExists = FALSE;
	     if (HRESULT_CODE(acct->GetHr()) == ERROR_OBJECT_ALREADY_EXISTS)
			 bExists = TRUE;

         if ( ((SUCCEEDED(acct->GetHr()) && (!bExists)) || ((bExists) && (pOptions->flags & F_REPLACE))) )
         {
            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, GET_STRING(IDS_UPDATING_PROPS_S), acct->GetName());
            if ( progress )
               progress(mesg);
            // Create the AccountList object and update the list variable
            if ( !pOptions->nochange )
            {
				_bstr_t sExcList;

				if (pOptions->bExcludeProps)
				{
					if (!_wcsicmp(acct->GetType(), L"user"))
						sExcList = pOptions->sExcUserProps;
					if (!_wcsicmp(acct->GetType(), L"group"))
						sExcList = pOptions->sExcGroupProps;
					if (!_wcsicmp(acct->GetType(), L"computer"))
						sExcList = pOptions->sExcCmpProps;
				}

               if ( bWin2k )
               {
				      //if ask to, exclude any properties desired by the user and create a new varset
                   if (pOptions->bExcludeProps)
				   {
                      IVarSetPtr pVarsetTemp(__uuidof(VarSet));
				      IUnknown * pUnkTemp;
                      hr = pVarsetTemp->QueryInterface(IID_IUnknown, (void**)&pUnkTemp);
				      if (SUCCEEDED(hr))
					  {
                         hr = pObjProp->raw_ExcludeProperties(sExcList, pUnk, &pUnkTemp);
					  }

				      if (SUCCEEDED(hr))
					  {
                            // Call the win 2k code to copy all but excluded props
                         hr = pObjProp->raw_CopyProperties(const_cast<WCHAR*>(acct->GetSourcePath()), pOptions->srcDomain, 
                                                           const_cast<WCHAR*>(acct->GetTargetPath()), pOptions->tgtDomain, pUnkTemp, pOptions->pDb);
					  }
				      else
					  {
                            // Call the win 2k code to copy all props
                         hr = pObjProp->raw_CopyProperties(const_cast<WCHAR*>(acct->GetSourcePath()), pOptions->srcDomain, 
                                                           const_cast<WCHAR*>(acct->GetTargetPath()), pOptions->tgtDomain, pUnk, pOptions->pDb);
					  }
				      pUnkTemp->Release();
				   }//end if asked to exclude
				   else
				   {
                        // Call the win 2k code to copy all props
                      hr = pObjProp->raw_CopyProperties(const_cast<WCHAR*>(acct->GetSourcePath()), pOptions->srcDomain, 
                                                        const_cast<WCHAR*>(acct->GetTargetPath()), pOptions->tgtDomain, pUnk, pOptions->pDb);
				   }
               }
               else
               {
                  // Otherwise let the Net APIs do their thing.
                  hr = pObjProp->raw_CopyNT4Props(const_cast<WCHAR*>(acct->GetSourceSam()), 
                                                  const_cast<WCHAR*>(acct->GetTargetSam()),
                                                  pOptions->srcComp, pOptions->tgtComp, 
                                                  const_cast<WCHAR*>(acct->GetType()),
                                                  acct->GetGroupType(),
                                                  sExcList);
               }
            }
            else
               // we are going to assume that copy properties would work
               hr = S_OK;

            if ( FAILED(hr) )
            {
               if ( (acct->GetStatus() & AR_Status_Special) )
               {
                  err.MsgWrite(ErrE,DCT_MSG_FAILED_TO_REPLACE_SPECIAL_ACCT_S,acct->GetTargetSam());
               }
               else
               {
                  err.SysMsgWrite(ErrE, HRESULT_CODE(hr), DCT_MSG_COPY_PROPS_FAILED_SD, acct->GetTargetName(), hr);
               }
               acct->MarkError();
               Mark(L"errors", acct->GetType());
            } 
            else
            {
	            // Create an event logger to log events to the source PDC
	            if ( !pOptions->nochange )
               {
                  evtLog.MsgWrite(0, DCT_MSG_ACCT_COPIED_SSS, acct->GetName(), pOptions->tgtDomain, acct->GetTargetName());
               }

               if (HRESULT_CODE(acct->GetHr()) == ERROR_OBJECT_ALREADY_EXISTS)
               {
                  acct->MarkAlreadyThere();
                  acct->MarkReplaced();
                  Mark(L"replaced",acct->GetType());
                  err.MsgWrite(0, DCT_MSG_ACCOUNT_REPLACED_S, acct->GetTargetName());
               }
            }
         }
      }
        // do we need to call extensions. Only if Extension flag is set and the object is copied.
      if ((!pOptions->nochange) && (acct->CallExt()) && (acct->WasCreated() || acct->WasReplaced()))
      {
         // Let the Extension objects do their thing.
         WCHAR                  mesg[LEN_Path];
         wsprintf(mesg,GET_STRING(IDS_RUNNING_EXTS_S), acct->GetName());
         if ( progress )
            progress(mesg);

         // Close the log file if it is open
         WCHAR          filename[LEN_Path];
         err.LogClose();
		 if (m_pExt)
            hr = m_pExt->Process(acct, pOptions->tgtDomain, pOptions,FALSE);
         safecopy (filename,opt.logFile);
         err.LogOpen(filename,1 /*append*/);
         
      }
     

      // only do these updates for account's we're copying
      //    and only do updates if the account was actually created
      //    .. or if the account was replaced, 
      //          or if we intentionally didn't replace the account (as in the group merge case)
      if ( acct->CreateAccount()          
            && ( acct->WasCreated()       
                  || (  acct->WasReplaced() 
                       || !acct->CopyProps()   
                     ) 
                ) 
         )
      {
         WCHAR                  mesg[LEN_Path];
         wsprintf(mesg, GET_STRING(IDS_TRANSLATE_ROAMING_PROFILE_S), acct->GetName());
         if ( progress )
            progress(mesg);

         //Set the new profile if needed 
		   if ( pOptions->flags & F_TranslateProfiles && (_wcsicmp(acct->GetType(), L"user") == 0))
		   {
			   WCHAR				tgtProfilePath[MAX_PATH];
            GetBkupRstrPriv((WCHAR*)NULL);
            GetPrivilege((WCHAR*)NULL,SE_SECURITY_NAME);
            if ( wcslen(acct->GetSourceProfile()) > 0 )
            {
			      DWORD ret = TranslateRemoteProfile( acct->GetSourceProfile(), 
											                  tgtProfilePath,
											                  acct->GetSourceSam(),
											                  acct->GetTargetSam(),
											                  pOptions->srcDomain,
											                  pOptions->tgtDomain,
											                  pOptions->pDb,
											                  pOptions->lActionID,
															  NULL,
                                                              pOptions->nochange);
			      if ( !ret )  
			      {
                  WCHAR                  tgtuser[LEN_Path];
                  USER_INFO_3          * tgtinfo;
                  DWORD                  nParmErr;
                  wcscpy(tgtuser, acct->GetTargetSam());
				      // Get information for the target account
				      long rc = NetUserGetInfo(const_cast<WCHAR *>(pOptions->tgtComp),
							      tgtuser,
							      3,
							      (LPBYTE *) &tgtinfo);

                  if (!pOptions->nochange)
                  {
				         // Set the new profile path
				         tgtinfo->usri3_profile = tgtProfilePath;
				         // Set the information back for the account.
				         rc = NetUserSetInfo(const_cast<WCHAR *>(pOptions->tgtComp),
                              tgtuser,
                              3,
                              (LPBYTE)tgtinfo,
                              &nParmErr);
                     NetApiBufferFree((LPVOID) tgtinfo);
				         if (rc)
				         {
					         err.MsgWrite(ErrE, DCT_MSG_SETINFO_FAIL_SD, tgtuser, rc);
                        Mark(L"errors", acct->GetType());
				         }
                  }
               }
			   }
		   }
      
         if ( acct->WasReplaced() )
         {
            
            // Do we need to add sid history
			   if ( pOptions->flags & F_AddSidHistory )
			   {
				   WCHAR                  mesg[LEN_Path];
               wsprintf(mesg, GET_STRING(IDS_ADDING_SIDHISTORY_S), acct->GetName());
               if ( progress )
                  progress(mesg);

            	// Global flag tells us if we should try the AddSidHistory because
					// for some special cases if it does not work once it will not work
					// see the AddSidHistory function for more details.
					if ( g_bAddSidWorks )
					{
						if (! AddSidHistory( pOptions, acct->GetSourceSam(), acct->GetTargetSam(), pStatus ) )
                  {
                     Mark(L"errors", acct->GetType());
                  }
//                  CopySidHistoryProperty(pOptions, acct, pStatus);
					}
			   }

		   }      
         wsprintf(mesg, L"", acct->GetName());
         if ( progress )
            progress(mesg);
      }
   }
   
   // Cleanup
   pUnk->Release();
   tenum.Close();
   return 0;
}

void CAcctRepl::LoadOptionsFromVarSet(IVarSet * pVarSet)
{
   _bstr_t                   text;
   DWORD                     rc;
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));

      //store the name of the wizard being run
   opt.sWizard = pVarSet->get(GET_BSTR(DCTVS_Options_Wizard));

   // Read General Options
   // open log file first, so we'll be sure to get any errors!
   text = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
   safecopy(opt.logFile,(WCHAR*)text);

   WCHAR                      filename[MAX_PATH];

   safecopy (filename,opt.logFile);

   err.LogOpen(filename,1 /*append*/);

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Domain));
	safecopy(opt.authDomain ,(WCHAR*)text);

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_UserName));
	safecopy(opt.authUser ,(WCHAR*)text);

	text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password));
	safecopy(opt.authPassword,(WCHAR*)text);
   
	text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   safecopy(opt.srcDomain,(WCHAR*)text);

   text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
   safecopy(opt.tgtDomain,(WCHAR*)text);

   text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
   safecopy(opt.srcDomainDns,(WCHAR*)text);

   text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomainDns));
   safecopy(opt.tgtDomainDns,(WCHAR*)text);

   _bstr_t strSourceServer = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServer));
   _bstr_t strTargetServer = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServer));

   if (strSourceServer.length() && strTargetServer.length())
   {
      UStrCpy(opt.srcComp, (WCHAR*)strSourceServer);
      UStrCpy(opt.tgtComp, (WCHAR*)strTargetServer);
   }
   else
   {
      if ( GetClosestDC(&opt) )
      {
         pVarSet->put(GET_BSTR(DCTVS_Options_SourceServer), opt.srcComp);
         pVarSet->put(GET_BSTR(DCTVS_Options_TargetServer), opt.tgtComp);
      }
      else
      {
         rc = GetLastError();
         err.SysMsgWrite(ErrE,rc,DCT_MSG_DOMAIN_NOT_FOUND_S,opt.srcDomain);
         Mark(L"errors", L"generic");
      }
   }

   text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServerOverride));
   if ( text.length() )
   {
      UStrCpy(opt.srcComp,(WCHAR*)text);
   }
   
   text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServerOverride));
   if ( text.length() )
   {
      UStrCpy(opt.tgtComp,(WCHAR*)text);
   }
   
   text = pVarSet->get(GET_BSTR(DCTVS_Options_NoChange));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      opt.nochange = TRUE;
   }
   else
   {
      opt.nochange = FALSE;
   }
   
   // Read Account Replicator Options
   
   // initialize
   safecopy(opt.prefix, L"");
   safecopy(opt.suffix, L"");
   safecopy(opt.globalPrefix, L"");
   safecopy(opt.globalSuffix, L"");

   DWORD flags = 0;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingAccounts));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      flags |= F_REPLACE;
   }
   else
   {
      // Prefix/Suffix only apply if the Replace flag is not set.
      text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_Prefix));
      safecopy(opt.prefix,(WCHAR*)text);

      text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_Suffix));
      safecopy(opt.suffix,(WCHAR*)text);
   }

   // Global flags apply no matter what
   text = pVarSet->get(GET_BSTR(DCTVS_Options_Prefix));
   safecopy(opt.globalPrefix,(WCHAR*)text);

   text = pVarSet->get(GET_BSTR(DCTVS_Options_Suffix));
   safecopy(opt.globalSuffix,(WCHAR*)text);

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyContainerContents));
   if ( text == _bstr_t(GET_BSTR(IDS_YES)) )
      opt.expandContainers = TRUE;
   else
      opt.expandContainers = FALSE;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyMemberOf));
   if ( text == _bstr_t(GET_BSTR(IDS_YES)) )
      opt.expandMemberOf = TRUE;
   else
      opt.expandMemberOf = FALSE;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_FixMembership));
   if ( text == _bstr_t(GET_BSTR(IDS_YES)) )
      opt.fixMembership = TRUE;
   else
      opt.fixMembership = FALSE;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_AddToGroup));
   safecopy(opt.addToGroup,(WCHAR*)text);

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_AddToGroupOnSourceDomain));
   safecopy(opt.addToGroupSource,(WCHAR*)text);


   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_TranslateRoamingProfiles));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_TranslateProfiles;
   
   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyUsers));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_USERS;
   
   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyGlobalGroups));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_GROUP;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_COMPUTERS;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyOUs));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_OUS;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyContainerContents));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_COPY_CONT_CONTENT;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_IncludeMigratedAccts));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_COPY_MIGRATED_ACCT;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyLocalGroups));
   if (! UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_LGROUP;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
   if (! UStrICmp(text,GET_STRING(IDS_All)) )
      flags |= F_DISABLE_ALL;
   else if (! UStrICmp(text,GET_STRING(IDS_Special)) )
      flags |= F_DISABLE_SPECIAL;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableSourceAccounts));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_DISABLESOURCE;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_GenerateStrongPasswords));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_STRONGPW_ALL;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordFile));
   if ( text.length() )
   {
      // don't need this anymore, since it is handled by a plug-in
      // opt.passwordLog.LogOpen(text,TRUE);
   }

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_UpdateUserRights));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      m_UpdateUserRights = TRUE;
   }
   
   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingGroupMembers));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_REMOVE_OLD_MEMBERS;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_RemoveExistingUserRights));
   if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_RevokeOldRights;
   
   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_MoveReplacedAccounts));
   if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
      flags |= F_MOVE_REPLACED_ACCT;
   
   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      flags |= F_MACHINE;
   }

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_AddSidHistory));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      flags |= F_AddSidHistory;
   }

   opt.flags = flags;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_RenameOnly));
   if (! UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      m_RenameOnly = TRUE;
   }

   text = pVarSet->get(GET_BSTR(DCTVS_Options_Undo));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      // this is an undo operation
      opt.bUndo = TRUE;
   }
   else
   {
      opt.bUndo = FALSE;
   }

   // What undo action are we performing.
   if ( opt.bUndo )
   {
      _variant_t var = pVarSet->get(L"UndoAction");
      if (var.vt == VT_I4)
         opt.lUndoActionID = var.lVal;
      else
         opt.lUndoActionID = -2;
   }
   else
   {
      _variant_t var = pVarSet->get(L"ActionID");
      if (var.vt == VT_I4)
         opt.lActionID = var.lVal;
      else
         opt.lActionID = -1;
   }

   // Read the password policy from the varset

   // We used to get the strong password policy from the target EA Server, so we can generate strong passwords
   // that meet the policy.
   // we don't do that anymore, since we have removed all depenedencies on EA.
   LONG           len = 10;

   // set the password settings to default values
   opt.policyInfo.bEnforce = TRUE;

   opt.policyInfo.maxConsecutiveAlpha = (LONG)pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MaxConsecutiveAlpha));
   opt.policyInfo.minDigits = (LONG)pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinDigit));
   opt.policyInfo.minLower = (LONG)pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinLower));
   opt.policyInfo.minUpper = (LONG)pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinUpper));
   opt.policyInfo.minSpecial = (LONG)pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinSpecial));   
   
   HRESULT hrAccess = pAccess->raw_GetPasswordPolicy(opt.tgtDomain,&len);   
   if ( SUCCEEDED(hrAccess) )
   {
      opt.minPwdLength = len;

      pVarSet->put(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinLength),len);
   }
   
   WriteOptionsToLog();

   // Build List of Accounts to Copy
   // Clear the account list first though
   TNodeListEnum             e;
   TAcctReplNode           * acct;
   for ( acct = (TAcctReplNode *)e.OpenFirst(&acctList) ; acct ; acct = (TAcctReplNode *)e.Next() )
   {
      acctList.Remove((TNode*)acct);
   }

   BothWin2K(&opt);

   // See if a global operation mask specified.
   _variant_t vdwOpMask = pVarSet->get(GET_BSTR(DCTVS_Options_GlobalOperationMask));
   if ( vdwOpMask.vt == VT_I4 )
      g_dwOpMask = (DWORD)vdwOpMask.lVal;

   // Then build the new list
   text = pVarSet->get(GET_BSTR(DCTVS_Accounts_InputFile));
   if ( text.length() )
   {
      if ( ! PopulateAccountListFromFile(text) )
         return;
   }
   else
   {
      // otherwise, expect a list of accounts to copy in the VarSet
      if ( ! opt.bUndo )
      {
         rc = PopulateAccountListFromVarSet(pVarSet);
         if  ( rc )
            return;    // abort 
      }
   }
   
   // If we have an NT5 source domain then we need to fillin the path info
   DWORD maj, min, sp;
   HRESULT hr = pAccess->raw_GetOsVersion(opt.srcComp, &maj, &min, &sp);
   if (SUCCEEDED(hr))
   {
      // Ask the auxiliarry function to fill in the the Path for the source object if the AcctNode is not filled
      for ( acct = (TAcctReplNode *)e.OpenFirst(&acctList) ; acct ; acct = (TAcctReplNode *)e.Next() )
      {
         if ((!acct->IsFilled) && (maj > 4))
         {
            FillPathInfo(acct, &opt);
            AddPrefixSuffix(acct, &opt);
         }
		 else if ((maj == 4) && (!_wcsicmp(acct->GetType(),L"computer")))
            FillPathInfo(acct, &opt);
      }
   }
 
   // Check for incompatible options!
   if ( (flags & F_RevokeOldRights) && !m_UpdateUserRights )
   {
      err.MsgWrite(ErrW,DCT_MSG_RIGHTS_INCOMPATIBLE_FLAGS);
      Mark(L"warnings", "generic");
   }

   text = pVarSet->get(GET_BSTR(DCTVS_Options_OuPath));
   if ( text.length() )
   {
      wcscpy(opt.tgtOUPath, text);
   }

     //store the object property exclusion lists in the options structure
   opt.sExcUserProps = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps));
   opt.sExcGroupProps = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps));
   opt.sExcCmpProps = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps));
   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      opt.bExcludeProps = TRUE;
   else
      opt.bExcludeProps = FALSE;
}

DWORD 
   CAcctRepl::PopulateAccountListFromVarSet(
      IVarSet              * pVarSet       // in - varset containing account list
   )
{
   _bstr_t                   val;
   long                      numAccounts;
   _bstr_t                   text;
   DWORD maj, min, sp;
   PSID                      pSrcSid = NULL;
   WCHAR					 txtSid[200] = L"";
   DWORD					 lenTxt = DIM(txtSid);
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   
   numAccounts = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   
   // Set up the account list functionality
   acctList.CompareSet(&TNodeCompareNameOnly);
   if ( acctList.IsTree() ) acctList.ToSorted();

      //get the source domain's Sid so we can store it as part of the node
   _bstr_t source = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   GetSidForDomain((WCHAR*)source,&pSrcSid);

   for ( int i = 0 ; i < numAccounts ; i++ )
   {
      WCHAR                  key[LEN_Path];
      UCHAR                  acctName[LEN_Account];
      TAcctReplNode        * curr = new TAcctReplNode;

	  if (!curr)
	     return ERROR_NOT_ENOUGH_MEMORY;

      if ( opt.pStatus )
      {
         LONG                status = 0;
         HRESULT             hr = opt.pStatus->get_Status(&status);

         if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
         {
            if ( !bAbortMessageWritten ) 
            {
               err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
               bAbortMessageWritten = true;
            }
            break;
         }
      }


      // The object type must be specified
      swprintf(key,GET_STRING(DCTVSFmt_Accounts_Type_D),i);
      val = pVarSet->get(key);
      curr->SetType(val);
      
      swprintf(key,GET_STRING(DCTVSFmt_Accounts_D),i);
      text = pVarSet->get(key);
      if ( ! text.length() )
      {
         // oops, no name specified 
         // skip this entry and try the next one
         err.MsgWrite(ErrW,DCT_MSG_NO_NAME_IN_VARSET_S,key);
         Mark(L"warnings",L"generic");
         delete curr;
         continue;
      }
      
	     //set the source domain's sid
	  curr->SetSourceSid(pSrcSid);

      // Set the operation to the global mask then check if we need to overwrite with the individual setting.
      curr->operations = g_dwOpMask;

      swprintf(key, GET_STRING(DCTVS_Accounts_D_OperationMask), i);
      _variant_t vOpMask = pVarSet->get(key);
      if ( vOpMask.vt == VT_I4 )
         curr->operations = (DWORD)vOpMask.lVal;
      
      // Get the rest of the info from the VarSet.
      if ( ( (text.length() > 7 ) && (_wcsnicmp((WCHAR*) text, L"LDAP://",UStrLen(L"LDAP://")) == 0) )
        || ( (text.length() > 8 ) && (_wcsnicmp((WCHAR*)text, L"WinNT://",UStrLen(L"WinNT://")) == 0)) )
      {
         //hmmmm... They are giving use ADsPath. Lets get all the info we can from the object then.
         curr->SetSourcePath((WCHAR*) text);
         FillNodeFromPath(curr, &opt, &acctList);
   
         // Get the target name if one is specified.
         swprintf(key,GET_STRING(DCTVSFmt_Accounts_TargetName_D),i);
         text = pVarSet->get(key);

         if ( text.length() )
         {
            // if target name is specified then use that.
            curr->SetTargetName((WCHAR*) text);
            curr->SetTargetSam((WCHAR*) text);
         }

         curr->IsFilled = true;
      }
      else
      {
         FillNamingContext(&opt);
         // if this is a computer account, make sure the trailing $ is included in the name
         curr->SetName(text);
         curr->SetTargetName(text);
         if ( !UStrICmp(val,L"computer") )
         {
//            if ( ((WCHAR*)text)[text.length() - 1] != L'$' ) //comment out to fix 89513.
            text += L"$";
         }
         curr->SetSourceSam(text);
         curr->SetTargetSam(text);
         safecopy(acctName,(WCHAR*)text);

         // optional target name
         swprintf(key,GET_STRING(DCTVSFmt_Accounts_TargetName_D),i);
         text = pVarSet->get(key);
      
         if ( text.length() )
            curr->SetTargetName(text);

//         HRESULT hr = pAccess->raw_GetOsVersion(opt.srcComp, &maj, &min, &sp);
         pAccess->raw_GetOsVersion(opt.srcComp, &maj, &min, &sp);
         if ( maj < 5 )
            AddPrefixSuffix(curr,&opt);

         // if this is a computer account, make sure the trailing $ is included in the name
         if ( !UStrICmp(val,L"computer") )
         {
            if ( text.length() && ((WCHAR*)text)[text.length() - 1] != L'$' )
            text += L"$";
         }
         if ( text.length() )
         {
            if ( ((WCHAR*)text)[text.length() - 1] != L'$' )
            text += L"$";
            curr->SetTargetSam(text);
         }
         curr->IsFilled = false;
      }      

      if ( _wcsicmp(val, L"") != 0 )
      {
         acctList.InsertBottom((TNode*)curr);
      }
      else
      {
         err.MsgWrite(ErrW,DCT_MSG_BAD_ACCOUNT_TYPE_SD,curr->GetName(),val);
         Mark(L"warnings",L"generic");
         delete curr;
      }
   }
   return 0;
}

BOOL 
   CAcctRepl::PopulateAccountListFromFile(
      WCHAR          const * filename      // in - filename containing account list
   )
{
   BOOL                      bSuccess = TRUE;
   _bstr_t                   text;
   FILE                    * pFile;
   WCHAR                     sourceName[UNLEN];
   WCHAR                     targetName[UNLEN];
   WCHAR                     type[UNLEN];
   DWORD                     status;
   DWORD                     srcRid;
   DWORD                     tgtRid;
   int                       count = 0;
   UCHAR                     srcName[LEN_Account];
   TAcctReplNode           * curr;

   // The input file should have the format:
   // the last 3 fields can be filled with 0s
   // SourceName, TargetName, Type, Status, sourceRid, targetRid
   
   pFile = _wfopen(filename,L"rb");
   if ( pFile )
   {
      int result;
      do 
      {
         result = fwscanf(pFile,L"%[^\t]\t%[^\t]\t%[^\t]\t%lx\t%lx\t%lx\r\n",sourceName,targetName,&type,&status,&srcRid, &tgtRid);

         if ( result != 6 )
            break;

         curr = new TAcctReplNode;
		 if (!curr)
		    return FALSE;
   
         curr->SetName(sourceName);
         curr->SetSourceSam(sourceName);
         curr->SetTargetName(targetName);
         curr->SetTargetSam(targetName);
         if ( _wcsicmp(type, L"") == 0 )
         {
            // TODO:  we may want to add code to get the object type if needed 
            // if type is not present, abort for now
            
            // Couldn't get the account type, skip this account
            safecopy(srcName,curr->GetName());
            err.MsgWrite(ErrW,DCT_MSG_ACCOUNT_GET_INFO_ERROR_sD,srcName,0);
            Mark(L"warnings",L"generic");
            continue;
         }
         else
         {
            curr->SetType( type ); 
         }
         // Do we want to do something with the status field 
         // to allow us to go back and only do operations that failed before?

         acctList.InsertBottom((TNode*)curr);
         count++;

      } while ( result == 6 ); // 6 fields read and assigned

      if ( result )
      {
         err.MsgWrite(ErrW,DCT_MSG_ERROR_READING_INPUT_FILE_S,filename);
         Mark(L"warnings",L"generic");
      }
      err.MsgWrite(0,DCT_MSG_ACCOUNTS_READ_FROM_FILE_DS,count,filename);
      fclose(pFile);
   }
   else
   {
      err.MsgWrite(ErrE,DCT_MSG_ERROR_OPENING_FILE_S,filename);
      Mark(L"errors", L"generic");
      bSuccess = FALSE;
   }

   return bSuccess;
}


DWORD 
   CAcctRepl::UpdateUserRights(
      IStatusObj           * pStatus       // in - status object
   )
{
   DWORD                     rc = 0;
   TAcctReplNode           * acct;
   TNodeListEnum             e;
   IUserRights             * pUserRights = NULL;
  

   // Update user rights on the PDC of the target domain
   HRESULT hr = CoCreateInstance(CLSID_UserRights,NULL,CLSCTX_ALL,IID_IUserRights,(void**)&pUserRights);
   if ( FAILED(hr) )
   {
      return hr;
   }

   hr = pUserRights->OpenSourceServer(SysAllocString(opt.srcComp));
   if ( SUCCEEDED(hr) )
   {
      hr = pUserRights->OpenTargetServer(SysAllocString(opt.tgtComp));
   }

   if ( SUCCEEDED(hr) )
   {
      pUserRights->put_NoChange(opt.nochange);
      pUserRights->put_RemoveOldRightsFromTargetAccounts((opt.flags & F_RevokeOldRights) != 0);

      if ( acctList.IsTree() )
      {
         acctList.ToSorted();
      }
      for ( acct = (TAcctReplNode *)e.OpenFirst(&acctList) ; acct ; acct = (TAcctReplNode *)e.Next() )
      {
         if ( pStatus )
         { 
            LONG                status = 0;
            HRESULT             hr = pStatus->get_Status(&status);

            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
            {
               if ( !bAbortMessageWritten ) 
               {
                  err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                  bAbortMessageWritten = true;
               }
               break;
            }
         }
         if ( _wcsicmp(acct->GetType(), L"computer") != 0  ) // only update rights for users and groups, not computer accounts
         {
            // if the account wasn't created or replaced, don't bother 
            if ( acct->GetStatus() & ( AR_Status_Created | AR_Status_Replaced ) ) 
            {
               if ( opt.bSameForest && acct->GetSourceRid() && acct->GetTargetRid() )
               {
                  WCHAR         srcSidStr[LEN_Path] = L"";
                  WCHAR         tgtSidStr[LEN_Path] = L"";
                  PSID          srcSid = NULL;
                  PSID          tgtSid = NULL;
                  DWORD         sidLen = DIM(srcSidStr);

                  srcSid = GetWellKnownSid(acct->GetSourceRid(),&opt,FALSE);
                  tgtSid = GetWellKnownSid(acct->GetTargetRid(),&opt,TRUE);

                  if ( srcSid )
                  {
                     GetTextualSid(srcSid,srcSidStr,&sidLen);
                  }
                  if ( tgtSid )
                  {
                     sidLen = DIM(tgtSidStr);
                     GetTextualSid(tgtSid,tgtSidStr,&sidLen);
                  }

               
                  // build the source and target SIDs for the account
                  hr = pUserRights->CopyUserRightsWithSids(SysAllocString(acct->GetSourceSam()),SysAllocString(srcSidStr),SysAllocString(acct->GetTargetSam()),SysAllocString(tgtSidStr));
                  FreeSid(srcSid);
                  FreeSid(tgtSid);
                  srcSid = NULL;
                  tgtSid = NULL;
            
               }
               else
               {
                  hr = pUserRights->CopyUserRights(SysAllocString(acct->GetSourceSam()),SysAllocString(acct->GetTargetSam()));
               }
            
               if ( ! rc )
               {
                  err.MsgWrite(0,DCT_MSG_UPDATED_RIGHTS_S,acct->GetTargetName() );
                  acct->MarkRightsUpdated();
               }
               else
               {
                  err.SysMsgWrite(ErrE,rc,DCT_MSG_UPDATE_RIGHTS_FAILED_SD,acct->GetTargetName(),rc);
                  acct->MarkError();
                  Mark(L"errors", acct->GetType());
               }
            }
         }
      }
      e.Close();
   }
   if ( pUserRights )
      pUserRights->Release();
   Progress(L"");
   return rc;
}

void 
   CAcctRepl::WriteOptionsToLog()
{
   // This will make it easier to tell if arguments are ignored because they
   // were specified in the wrong format, or misspelled, etc.

   WCHAR                   cmdline[1000];
   
   UStrCpy(cmdline ,GET_STRING(IDS_AccountMigration));
   
   if ( opt.nochange )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_WriteChanges_No));
   }
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   UStrCpy(cmdline + UStrLen(cmdline),opt.srcDomain);
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   UStrCpy(cmdline + UStrLen(cmdline),opt.tgtDomain);
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   if ( opt.flags & F_USERS )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyUsers_Yes));
   }
   else 
   {
      UStrCpy(cmdline + UStrLen(cmdline), GET_STRING(IDS_CopyUsers_No));
   }
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   if ( opt.flags & F_GROUP )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyGlobalGroups_Yes));
   }
   else 
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyGlobalGroups_No));
   }
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   
   if ( opt.flags & F_LGROUP )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyLocalGroups_Yes));
   }
   else 
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyLocalGroups_No));
   }
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   
   if ( opt.flags & F_MACHINE )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyComputers_Yes));
   }
   else 
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_CopyComputers_No));
   }
   UStrCpy(cmdline + UStrLen(cmdline),L" ");
   
   if ( opt.flags & F_REPLACE )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_ReplaceExisting_Yes));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   if ( opt.flags & F_DISABLE_ALL )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_DisableAll_Yes));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   else if ( opt.flags & F_DISABLE_SPECIAL )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_DisableSpecial_Yes));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   if ( opt.flags & F_DISABLESOURCE )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_DisableSourceAccounts_Yes));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   if ( opt.flags & F_STRONGPW_ALL )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_StrongPwd_All));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   else if ( opt.flags & F_STRONGPW_SPECIAL )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_StrongPwd_Special));
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   if ( *opt.addToGroup )
   {
      UStrCpy(cmdline + UStrLen(cmdline),GET_STRING(IDS_AddToGroup));
      UStrCpy(cmdline + UStrLen(cmdline),opt.addToGroup);
      UStrCpy(cmdline + UStrLen(cmdline),L" ");
   }
   
   err.MsgWrite(0,DCT_MSG_GENERIC_S,cmdline);
}

void 
   CAcctRepl::LoadResultsToVarSet(
      IVarSet              * pVarSet      // i/o - VarSet 
   )
{
   _bstr_t                   text;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CSVResultFile));
   if ( text.length() )
   {
      CommaDelimitedLog         results;

      if ( results.LogOpen((WCHAR*)text,FALSE) )
      {
         // Write the results to a comma-separated file 
         // as SrcName,TgtName,AccountType,Status, srcRid, tgtRid
         // This file can be used by ST as input.
         TNodeListEnum             e;
         TAcctReplNode           * tnode;

         if ( acctList.IsTree() )
         {
            acctList.ToSorted();
         }
         
         for ( tnode = (TAcctReplNode *)e.OpenFirst(&acctList) ; tnode ; tnode = (TAcctReplNode *)e.Next() )
         {
            results.MsgWrite(L"%s,%s,%lx,%lx,%lx,%lx",tnode->GetName(),tnode->GetTargetSam(), tnode->GetType(),tnode->GetStatus(),tnode->GetSourceRid(),tnode->GetTargetRid());   
         }
         e.Close();
         results.LogClose();
      }
      else
      {
         err.MsgWrite(ErrE,DCT_MSG_FAILED_TO_WRITE_ACCOUNT_STATS_S,text);
         Mark(L"errors", "generic");
      }
   }
   long                     level = pVarSet->get(GET_BSTR(DCTVS_Results_ErrorLevel));
   
   if ( level < err.GetMaxSeverityLevel() )
   {
      pVarSet->put(GET_BSTR(DCTVS_Results_ErrorLevel),(LONG)err.GetMaxSeverityLevel());
   }
}

IADsGroup * GetWellKnownTargetGroup(long groupID,Options * pOptions)
{
   IADsGroup         * pGroup = NULL;
   HRESULT             hr;
   PSID                pSid;
   WCHAR               strSid[LEN_Path];
   WCHAR               sPath[LEN_Path];
   CLdapConnection     c;

   // Get the SID for the Domain Computers group
   
   pSid = GetWellKnownSid(groupID,pOptions,TRUE);
   if ( pSid )
   {
      c.BytesToString((LPBYTE)pSid,strSid,GetLengthSid(pSid));

      swprintf(sPath,L"LDAP://%ls/<SID=%ls>",pOptions->tgtDomain,strSid);
      
      hr = ADsGetObject(sPath,IID_IADsGroup,(void**)&pGroup);
      FreeSid(pSid);
   }

   return pGroup;
}

void PadCnName(WCHAR * sTarget)
{
	// escape character
	const WCHAR ESCAPE_CHARACTER = L'\\';
	// characters that need escaping for RDN format
	static WCHAR SPECIAL_CHARACTERS[] = L"\"#+,;<=>\\";

	// copy old name
	WCHAR szOldName[LEN_Path];
	wcscpy(szOldName, sTarget);

	WCHAR* pchNew = sTarget;

	// for each character in old name...

	for (WCHAR* pchOld = szOldName; *pchOld; pchOld++)
	{
		// if special character...

		if (wcschr(SPECIAL_CHARACTERS, *pchOld))
		{
			// then add escape character
			*pchNew++ = ESCAPE_CHARACTER;
		}

		// add character
		*pchNew++ = *pchOld;
	}

	// null terminate new name
	*pchNew = L'\0';
}

//------------------------------------------------------------------------------
// Create2KObj: Creates a Win2K object. This code uses LDAP to create a new
//              object of specified type in the specified container.
//              If any information is incorrect or If there are any access
//              problems then it simply returns the Failed HRESULT.
//------------------------------------------------------------------------------
HRESULT CAcctRepl::Create2KObj(
                                 TAcctReplNode           * pAcct,       //in -TNode with account information
                                 Options                 * pOptions     //in -Options set by the user.
                              )
{
   // This function creates a Win2K object.
   IADs                    * pAds = NULL;
   WCHAR                     sAdsPath[LEN_Path];
   DWORD					 nPathLen = LEN_Path;
   WCHAR                     sSubPath[LEN_Path];
   WCHAR                     sClass[LEN_Path];
   HRESULT                   hr;
   WCHAR                     sTarget[LEN_Path];
   _variant_t                varT;
   _bstr_t                   strName;
   WCHAR                     strTarget[LEN_Path];
   IADsContainer           * pCont = NULL;
   IDispatch               * pDisp = NULL;


   // Get the name of the class for the source object so we can use that to create the new object.
   wcscpy(sClass, pAcct->GetType());

   // check if the sourceAdsPath, for LDAP paths only, is correct before creating this object on the target.  If not fail now.
   if (!wcsncmp(L"LDAP://", pAcct->GetSourcePath(), 7))
   {
      wcsncpy(sAdsPath, pAcct->GetSourcePath(), nPathLen-1);
      hr = ADsGetObject(sAdsPath, IID_IADs, (void**)&pAds);
      if (FAILED(hr))
	  {
         err.SysMsgWrite(ErrE,hr, DCT_MSG_LDAP_CALL_FAILED_SD, sAdsPath, hr);
         Mark(L"errors", pAcct->GetType());
         return hr;
	  }
   }
      
   pAds = NULL;
   // Now that we have the classname we can go ahead and create an object in the target domain.
   // First we need to get IAdsContainer * to the domain.
   wcscpy(sSubPath, pOptions->tgtOUPath);
   
   if ( !wcsncmp(L"LDAP://", sSubPath, 7) )
      StuffComputerNameinLdapPath(sAdsPath, nPathLen, sSubPath, pOptions);
   else
      MakeFullyQualifiedAdsPath(sAdsPath, nPathLen, sSubPath, pOptions->tgtComp, pOptions->tgtNamingContext);

   hr = ADsGetObject(sAdsPath, IID_IADsContainer, (void**)&pCont);
   if ( FAILED(hr) )
   {
      if ( firstTime ) 
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_CONTAINER_NOT_FOUND_SSD, pOptions->tgtOUPath, pOptions->tgtDomain, hr);
         firstTime = false;
         Mark(L"errors", pAcct->GetType());
      }
      if ( _wcsicmp((WCHAR*)sClass, L"computer") == 0 )
      {
         MakeFullyQualifiedAdsPath(sAdsPath, nPathLen, L"CN=Computers", pOptions->tgtDomain, pOptions->tgtNamingContext);
         hr = ADsGetObject(sAdsPath, IID_IADsContainer, (void**)&pCont);
      }
      else
      {
         MakeFullyQualifiedAdsPath(sAdsPath, nPathLen, L"CN=Users", pOptions->tgtDomain, pOptions->tgtNamingContext);
         hr = ADsGetObject(sAdsPath, IID_IADsContainer, (void**)&pCont);
      }
      if ( FAILED(hr) ) 
      {
         err.SysMsgWrite(ErrE, hr, DCT_MSG_DEFAULT_CONTAINER_NOT_FOUND_SD, sAdsPath, hr);
         Mark(L"errors", pAcct->GetType());
         return (hr);
      }
   }

   WCHAR                     pref[LEN_Path], suf[LEN_Path];
   // Call the create method on the container.
   wcscpy(sTarget, pAcct->GetTargetName());

   // In case of the NT4 source domain the source and the target name have no CN= so we need
   // to add this to the target name.  The target name from the group mapping wizard also needs a "CN="
   // added to the target name.
   if ((pOptions->srcDomainVer < 5) || (!_wcsicmp(sClass, L"computer")) || (!_wcsicmp((WCHAR*)pOptions->sWizard, L"groupmapping")))
   {
      WCHAR                sTemp[LEN_Path];
      wcscpy(sTemp, pAcct->GetTargetName());
      PadCnName(sTemp);
      // if the CN part is not there add it.
      if ( _wcsicmp(sClass, L"organizationalUnit") == 0 )
         wsprintf(sTarget, L"OU=%s", sTemp);
      else
         wsprintf(sTarget, L"CN=%s", sTemp);
      pAcct->SetTargetName(sTarget);
   }

   // we need to truncate CN name to less that 64 characters
   for ( DWORD z = 0; z < wcslen(sTarget); z++ )
   {
      if ( sTarget[z] == L'=' ) break;
   }
   
   if ( z < wcslen(sTarget) )
   {
      // Get the prefix part ex.CN=
      wcsncpy(pref, sTarget, z+1);
      pref[z+1] = 0;
      wcscpy(suf, sTarget+z+1);
   }

   // The CN for the account could be greater than 64 we need to truncate it.
   WCHAR                        sTempCn[LEN_Path];

   if ( wcslen(suf) > 64 )
   {
      if ( wcslen(pOptions->globalSuffix) )
      {
         // in case of a global suffix we need to remove the suffix and then truncate the account and then readd the suffix.
         suf[wcslen(suf) - wcslen(pOptions->globalSuffix)] = L'\0';
      }
      int truncate = 64 - wcslen(pOptions->globalSuffix);
      wcsncpy(sTempCn, suf, truncate);
      sTempCn[truncate] = L'\0';
      if (wcslen(pOptions->globalSuffix))
         wcscat(sTempCn, pOptions->globalSuffix);
      err.MsgWrite(1, DCT_MSG_TRUNCATE_CN_SS, pAcct->GetTargetName(), sTempCn);
   }
   else
      wcscpy(sTempCn, suf);
   
   wsprintf(sTarget, L"%s%s", pref, sTempCn);
   pAcct->SetTargetName(sTarget);

   // even for a local group the object type of the group has to be a local group
   if ( !_wcsicmp((WCHAR*)sClass, L"lgroup") )
   {
      wcscpy((WCHAR*)sClass,L"group");
   }

   // Call the create method on the container.
   wcscpy(sTarget, pAcct->GetTargetName());
   hr = pCont->Create(sClass, sTarget, &pDisp);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE, hr,DCT_MSG_CREATE_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
      Mark(L"errors", pAcct->GetType());
      pCont->Release();
      return hr;
   }
   // Get the IADs interface to get the path to newly created object.
   hr = pDisp->QueryInterface(IID_IADs, (void**)&pAds);
   pDisp->Release();
   pDisp = NULL;
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE, hr, DCT_MSG_GET_IADS_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
      Mark(L"errors", pAcct->GetType());
      pCont->Release();
      return hr;
   }
   
   // Set the Target Account Sam name if not an OU.
   wcscpy(strTarget, pAcct->GetTargetSam());
   StripSamName(strTarget);
   pAcct->SetTargetSam(strTarget);

   // check if the $ is at the end of the SAM name for computer accounts.
   if ( !_wcsicmp(sClass, L"computer") )
   {
      // also make sure the target SAM name is not too long
      if ( UStrLen(strTarget) > 16 )
      {
         strTarget[15] = 0;
      }
      if (strTarget[wcslen(strTarget)-1] != L'$')
      {
         WCHAR       sTemp[LEN_Path];
         wsprintf(sTemp, L"%s$", strTarget);
         wcscpy(strTarget, sTemp);
         pAcct->SetTargetSam(strTarget);
      }
   }

   varT = strTarget;
   if ( _wcsicmp(sClass, L"organizationalUnit") != 0)
      // organizational unit has no sam account name
      hr = pAds->Put(L"sAMAccountName", varT);

   if ( _wcsicmp(sClass, L"group") == 0 )
   {
      varT = _variant_t(pAcct->GetGroupType());
      if ( pOptions->srcDomainVer < 5 )
      {
         // all NT4 accounts are security accounts but they tell us that they are Dist accts so lets set them straight.
         varT.lVal |= 0x80000000;
      }
      hr = pAds->Put(L"groupType", varT);
   }
   else if ( !_wcsicmp(sClass, L"user") )
   {
      // Get the source profile path and store it in the path
      _variant_t  var;
      IADs                 * pAdsSource = NULL;

      hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADs, (void**)&pAdsSource);
      if ( SUCCEEDED(hr) ) 
      {
         // Don't know why it is different for WinNT to ADSI
         if ( pOptions->srcDomainVer > 4 )
            hr = pAdsSource->Get(L"profilePath", &var);
         else
            hr = pAdsSource->Get(L"profile", &var);

         if ( SUCCEEDED(hr))
         {
            pAcct->SetSourceProfile((WCHAR*) V_BSTR(&var));
         }
         pAdsSource->Release();
      }
   }
 
   // In no change mode we do not call the set info.
   if ( !pOptions->nochange )
   {
      hr = pAds->SetInfo();
      if ( FAILED(hr) )
      {
		   if (HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS) 
		   {
            if ( wcslen(pOptions->prefix) > 0 )
            {
               WCHAR               tgt[LEN_Path];
               WCHAR               pref[LEN_Path], suf[LEN_Path];
               WCHAR               sTempSam[LEN_Path];
               _variant_t          varStr;

               // Here I am adding a prefix and then lets see if we can setinfo that way
               // find the '=' sign
               wcscpy(tgt, pAcct->GetTargetName());
               for ( DWORD z = 0; z < wcslen(tgt); z++ )
               {
                  if ( tgt[z] == L'=' ) break;
               }
               
               if ( z < wcslen(tgt) )
               {
                  // Get the prefix part ex.CN=
                  wcsncpy(pref, tgt, z+1);
                  pref[z+1] = 0;
                  wcscpy(suf, tgt+z+1);
               }

               // The CN for the account could be greater than 64 we need to truncate it.
               WCHAR                        sTempCn[LEN_Path];

               if ( wcslen(suf) + wcslen(pOptions->prefix) > 64 )
               {
                  int truncate = 64 - wcslen(pOptions->prefix);
                  wcsncpy(sTempCn, suf, truncate);
                  sTempCn[truncate] = L'\0';
                  err.MsgWrite(1, DCT_MSG_TRUNCATE_CN_SS, pAcct->GetTargetName(), sTempCn);
               }
               else
                  wcscpy(sTempCn, suf);
               
               // Remove the \ if it is escaping the space
               if ( sTempCn[0] == L'\\' && sTempCn[1] == L' ' )
               {
                  WCHAR       sTemp[LEN_Path];
                  wcscpy(sTemp, sTempCn+1);
                  wcscpy(sTempCn, sTemp);
               }
               // Build the target string with the Prefix
               wsprintf(tgt, L"%s%s%s", pref, pOptions->prefix, sTempCn);

               pAcct->SetTargetName(tgt);

               // Create the object in the container
               hr = pCont->Create(sClass, tgt, &pDisp);
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE, hr,DCT_MSG_CREATE_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
                  Mark(L"errors", pAcct->GetType());
                  pCont->Release();
                  pAds->Release();
                  pDisp->Release();
                  return hr;
               }
               // Get the IADs interface to get the path to newly created object.
               pAds->Release();
               hr = pDisp->QueryInterface(IID_IADs, (void**)&pAds);
               pDisp->Release();
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE, hr, DCT_MSG_GET_IADS_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
                  Mark(L"errors", pAcct->GetType());
                  pCont->Release();
                  return hr;
               }
               
               // truncate to allow prefix/suffix to fit in 20 characters.
               int resLen = wcslen(pOptions->prefix) + wcslen(pAcct->GetTargetSam());
               if ( !_wcsicmp(pAcct->GetType(), L"computer") )
               {
                  // Computer name can be only 15 characters long + $
                  if ( resLen > 16 )
                  {
                     WCHAR       sTruncatedSam[LEN_Path];
                     wcscpy(sTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        sTruncatedSam[wcslen(sTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }

                     int truncate = 16 - wcslen(pOptions->prefix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 1 ) truncate = 1;
                     wcsncpy(sTempSam, sTruncatedSam, truncate - 1);
                     sTempSam[truncate-1] = L'\0';              // Dont forget the $ sign and terminate string.
                     wcscat(sTempSam, pOptions->globalSuffix);
                     wcscat(sTempSam, L"$");
                  }
                  else
                     wcscpy(sTempSam, pAcct->GetTargetSam());

                  // Add the prefix
                  wsprintf(tgt, L"%s%s", pOptions->prefix,sTempSam);
               }
               else if ( !_wcsicmp(pAcct->GetType(), L"user") )
               {
                  if ( resLen > 20 )
                  {
                     WCHAR       sTruncatedSam[LEN_Path];
                     wcscpy(sTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        sTruncatedSam[wcslen(sTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }
                     int truncate = 20 - wcslen(pOptions->prefix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 0 ) truncate = 0;
                     wcsncpy(sTempSam, sTruncatedSam, truncate);
                     sTempSam[truncate] = L'\0';
                     wcscat(sTempSam, pOptions->globalSuffix);
                  }
                  else
                     wcscpy(sTempSam, pAcct->GetTargetSam());

                  // Add the prefix
                  wsprintf(tgt, L"%s%s", pOptions->prefix,sTempSam);
               }
               else
                  wsprintf(tgt, L"%s%s", pOptions->prefix,pAcct->GetTargetSam());

               StripSamName(tgt);
               pAcct->SetTargetSam(tgt);
               varStr = tgt;
               pAds->Put(L"sAMAccountName", varStr);
               if ( _wcsicmp(sClass, L"group") == 0 )
               {
                  varT = _variant_t(pAcct->GetGroupType());
                  if ( pOptions->srcDomainVer < 5 )
                  {
                     // all NT4 accounts are security accounts but they tell us that they are Dist accts so lets set them straight.
                     varT.lVal |= 0x80000000;
                  }
                  hr = pAds->Put(L"groupType", varT);
               }
               hr = pAds->SetInfo();
               if ( SUCCEEDED(hr) )
               {
					  Mark(L"created", sClass);
					  pAcct->MarkCreated();
					  WCHAR * sTgtPath;
					  HRESULT temphr = pAds->get_ADsPath(&sTgtPath);
					  if ( SUCCEEDED(temphr) )
						 pAcct->SetTargetPath(sTgtPath);
					  else
						 pAcct->SetTargetPath(L"");
               }
               else if ( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS )
               {
    		         pAcct->MarkAlreadyThere();
                  err.MsgWrite(ErrE, DCT_MSG_PREF_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                  Mark(L"errors",pAcct->GetType());
               }
               else
               {
    		         pAcct->MarkError();
                  err.SysMsgWrite(ErrE, hr, DCT_MSG_CREATE_FAILED_SSD, pAcct->GetTargetSam(), pOptions->tgtOUPath, hr);
                  Mark(L"errors",pAcct->GetType());
               }
            }
			   else if ( wcslen(pOptions->suffix) > 0 )
			   {
               WCHAR               tgt[LEN_Path];
               WCHAR               pref[LEN_Path], suf[LEN_Path];
               WCHAR               sTempSam[LEN_Path];
               _variant_t          varStr;
               
               wcscpy(tgt, pAcct->GetTargetName());
               for ( DWORD z = 0; z < wcslen(tgt); z++ )
               {
                  if ( tgt[z] == L'=' ) break;
               }
               
               if ( z < wcslen(tgt) )
               {
                  // Get the prefix part ex.CN=
                  wcsncpy(pref, tgt, z+1);
                  pref[z+1] = 0;
                  wcscpy(suf, tgt+z+1);
               }

               // The CN for the account could be greater than 64 we need to truncate it.
               WCHAR                        sTempCn[LEN_Path];

               if ( wcslen(suf) + wcslen(pOptions->suffix) + wcslen(pOptions->globalSuffix) > 64 )
               {
                  if ( wcslen(pOptions->globalSuffix) )
                  {
                     // in case of a global suffix we need to remove the suffix and then truncate the account and then readd the suffix.
                     suf[wcslen(suf) - wcslen(pOptions->globalSuffix)] = L'\0';
                  }
                  int truncate = 64 - wcslen(pOptions->suffix) - wcslen(pOptions->globalSuffix); 
                  wcsncpy(sTempCn, suf, truncate);
                  sTempCn[truncate] = L'\0';
                  wcscat(sTempCn, pOptions->globalSuffix);
                  err.MsgWrite(1, DCT_MSG_TRUNCATE_CN_SS, pAcct->GetTargetName(), suf);
               }
               else
                  wcscpy(sTempCn, suf);

               // Remove the trailing space \ escape sequence
               wcscpy(tgt, sTempCn);
               for ( int i = wcslen(tgt)-1; i >= 0; i-- )
               {
                  if ( tgt[i] != L' ' )
                     break;
               }

               if ( tgt[i] == L'\\' )
               {
                  WCHAR * pTemp = &tgt[i];
                  *pTemp = 0;
                  wcscat(pref, tgt);
                  wcscpy(suf, pTemp+1);
               }
               else
               {
                  wcscat(pref, tgt);
                  wcscpy(suf, L"");
               }
               wsprintf(tgt, L"%s%s%s", pref, suf, pOptions->suffix);
               pAcct->SetTargetName(tgt);

               // Create the object in the container
               hr = pCont->Create(sClass, tgt, &pDisp);
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE, hr,DCT_MSG_CREATE_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
                  Mark(L"errors", pAcct->GetType());
                  pCont->Release();
                  pAds->Release();
                  return hr;
               }
               // Get the IADs interface to get the path to newly created object.
               pAds->Release();
               hr = pDisp->QueryInterface(IID_IADs, (void**)&pAds);
               pDisp->Release();
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE, hr, DCT_MSG_GET_IADS_FAILED_SSD, pAcct->GetTargetName(), pOptions->tgtOUPath, hr);
                  Mark(L"errors", pAcct->GetType());
                  pCont->Release();
                  return hr;
               }

               // truncate to allow prefix/suffix to fit in valid length
               int resLen = wcslen(pOptions->suffix) + wcslen(pAcct->GetTargetSam());
               if ( !_wcsicmp(pAcct->GetType(), L"computer") )
               {
                  // Computer name can be only 15 characters long + $
                  if ( resLen > 16 )
                  {
                     WCHAR       sTruncatedSam[LEN_Path];
                     wcscpy(sTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        sTruncatedSam[wcslen(sTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }
                     int truncate = 16 - wcslen(pOptions->suffix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 1 ) truncate = 1;
                     wcsncpy(sTempSam, sTruncatedSam, truncate - 1);
                     sTempSam[truncate-1] = L'\0';
                     // Re add the global suffix after the truncation.
                     wcscat(sTempSam, pOptions->globalSuffix);
                     wcscat(sTempSam, L"$");
                  }
                  else
                     wcscpy(sTempSam, pAcct->GetTargetSam());

                  // Add the suffix taking into account the $ sign
                  if ( sTempSam[wcslen(sTempSam) - 1] == L'$' )
                     sTempSam[wcslen(sTempSam) - 1] = L'\0';
                  wsprintf(tgt, L"%s%s$", sTempSam, pOptions->suffix);
               }
               else if ( !_wcsicmp(pAcct->GetType(), L"user") )
               {
                  if ( resLen > 20 )
                  {
                     WCHAR       sTruncatedSam[LEN_Path];
                     wcscpy(sTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        sTruncatedSam[wcslen(sTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }
                     int truncate = 20 - wcslen(pOptions->suffix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 0 ) truncate = 0;
                     wcsncpy(sTempSam, sTruncatedSam, truncate);
                     sTempSam[truncate] = L'\0';
                     wcscat(sTempSam, pOptions->globalSuffix);
                  }
                  else
                     wcscpy(sTempSam, pAcct->GetTargetSam());

                  // Add the suffix.
                  wsprintf(tgt, L"%s%s", sTempSam, pOptions->suffix);
               }
               else
                  wsprintf(tgt, L"%s%s", pAcct->GetTargetSam(), pOptions->suffix);


               StripSamName(tgt);
               pAcct->SetTargetSam(tgt);
               varStr = tgt;

               pAds->Put(L"sAMAccountName", varStr);
               if ( _wcsicmp(sClass, L"group") == 0 )
               {
                  varT = _variant_t(pAcct->GetGroupType());
                  if ( pOptions->srcDomainVer < 5 )
                  {
                     // all NT4 accounts are security accounts but they tell us that they are Dist accts so lets set them straight.
                     varT.lVal |= 0x80000000;
                  }
                  hr = pAds->Put(L"groupType", varT);
               }
               hr = pAds->SetInfo();
               if ( SUCCEEDED(hr) )
               {
					  Mark(L"created", sClass);
					  pAcct->MarkCreated();
					  WCHAR * sTgtPath;
					  HRESULT temphr = pAds->get_ADsPath(&sTgtPath);
					  if ( SUCCEEDED(temphr) )
						 pAcct->SetTargetPath(sTgtPath);
					  else
						 pAcct->SetTargetPath(L"");
               }
               else if ( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS )
               {
    		         pAcct->MarkAlreadyThere();
                  err.MsgWrite(ErrE, DCT_MSG_PREF_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                  Mark(L"errors",pAcct->GetType());
               }
               else
               {
    		         pAcct->MarkError();
                  err.SysMsgWrite(ErrE, hr, DCT_MSG_CREATE_FAILED_SSD, pAcct->GetTargetSam(), pOptions->tgtOUPath, hr);
                  Mark(L"errors",pAcct->GetType());
               }
			}
            else
            {
			   if (pOptions->flags & F_REPLACE)
               {
                  WCHAR                     sPath[LEN_Path], sQuery[LEN_Path];
                  WCHAR                     sPath9[LEN_Path];
			      SAFEARRAY               * pszColNames = NULL;
			      BSTR     HUGEP          * pData;
			      LPWSTR                    sData[] = { L"ADsPath", L"profilePath", L"objectClass" };
			      INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
			      IEnumVARIANT            * pEnumMem = NULL;
			      _variant_t                var;
			      DWORD                     dwFetch;
			      HRESULT                   temphr;
			      int                       nElt = DIM(sData);
			      SAFEARRAYBOUND            bd = { nElt, 0 };
                  BOOL                      bIsCritical = FALSE;
                  BOOL                      bIsDifferentType = FALSE;

			         // Since the object already exists we need to get the ADsPath to the object and update the acct structure
			         // Set up the query and the path
			      wsprintf(sPath, L"LDAP://%s/%s", pOptions->tgtComp+2, pOptions->tgtNamingContext);
                  WCHAR                     sTempSamName[LEN_Path];
                  wcscpy(sTempSamName, pAcct->GetTargetSam());
                  if ( sTempSamName[0] == L' ' )
                  {
                     WCHAR               sTemp[LEN_Path];
                     wsprintf(sTemp, L"\\20%s", sTempSamName + 1); 
                     wcscpy(sTempSamName, sTemp);
                  }
                  wsprintf(sQuery, L"(sAMAccountName=%s)", sTempSamName);

			         temphr = pQuery->raw_SetQuery(sPath, pOptions->tgtDomainDns, sQuery, ADS_SCOPE_SUBTREE, FALSE);
			         if ( FAILED(temphr) )
                  {
                     pCont->Release();
                     pAds->Release();
                     return temphr;
                  }

			         // Set up the columns so we get the ADsPath of the object.
			         pszColNames = ::SafeArrayCreate(VT_BSTR, 1, &bd);
			         temphr = ::SafeArrayAccessData(pszColNames, (void HUGEP **)&pData);
			         if ( FAILED(temphr) )
                  {
                     pCont->Release();
                     pAds->Release();
                     SafeArrayDestroy(pszColNames);
                     return temphr;
                  }
			         for ( long i = 0; i < nElt; i++ )
			         {
				        pData[i] = SysAllocString(sData[i]);
			         }
			         temphr = ::SafeArrayUnaccessData(pszColNames);
			         if ( FAILED(temphr) )
                  {
                     ::SafeArrayDestroy(pszColNames);
                     pCont->Release();
                     pAds->Release();
                     return temphr;
                  }
			         temphr = pQuery->raw_SetColumns(pszColNames);
			         if ( FAILED(temphr) )
                  {
                     pCont->Release();
                     pAds->Release();
                     ::SafeArrayDestroy(pszColNames);
                     return temphr;
                  }
                  // Time to execute the plan.
			         temphr = pQuery->raw_Execute(&pEnumMem);
			         if ( FAILED(temphr) )
                  {
                     ::SafeArrayDestroy(pszColNames);
                     pCont->Release();
                     pAds->Release();
                     return temphr;
                  }
                  ::SafeArrayDestroy(pszColNames);
			      temphr = pEnumMem->Next(1, &var, &dwFetch);
			      if ( temphr == S_OK )
			      {
				     // This would only happen if the member existed in the target domain.
				     // We now have a Variant containing an array of variants so we access the data
                    _variant_t    * pVar;
					_bstr_t		    sConfName = pAcct->GetTargetName();
				    _bstr_t	        sOldCont;
					pszColNames = V_ARRAY(&var);
					SafeArrayAccessData(pszColNames, (void HUGEP **)&pVar);
					wcscpy(sAdsPath, (WCHAR*)pVar[0].bstrVal);
					pAcct->SetTargetPath(sAdsPath);

                    // Check if the object we are about to replace is of the same type.
                    if ( _wcsicmp(pAcct->GetType(), (WCHAR*) pVar[2].bstrVal) )
                       bIsDifferentType = TRUE;

				    SafeArrayUnaccessData(pszColNames);
                    
                    IADs * pAdsNew = NULL;
                    temphr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetTargetPath()), IID_IADs, (void**)&pAdsNew);
                    if ( SUCCEEDED(temphr) )
                    {
						  //see if critical
                       _variant_t   varCritical;
                       temphr = pAdsNew->Get(L"isCriticalSystemObject", &varCritical);
                       if (SUCCEEDED(temphr))
                       {
                           bIsCritical = V_BOOL(&varCritical) == -1 ? TRUE : FALSE;
                       }
					      //get the name
                       BSTR  sTgtName = NULL;
                       temphr = pAdsNew->get_Name(&sTgtName);
                       if ( SUCCEEDED(temphr) )
					      sConfName = _bstr_t(sTgtName, false);

					      //get the parent container of the conflicting object
                       BSTR  sTgtCont = NULL;
                       temphr = pAdsNew->get_Parent(&sTgtCont);
                       if ( SUCCEEDED(temphr) )
					      sOldCont = _bstr_t(sTgtCont, false);
                    }
                    if ( pAdsNew )
                    {
                       pAdsNew->Release();
                       pAdsNew = NULL;
                    }

                    if ( bIsDifferentType )
                    {
                       // Since the source and target accounts are of different types we do not want to replace these.
                       hr = HRESULT_FROM_WIN32(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
                    }
				       //else if not critical then move the account
                    else if ( !bIsCritical )
                    {
					      //if user selected to move that account into the user-specified OU, then move it
					   if (pOptions->flags & F_MOVE_REPLACED_ACCT)
					   {
                          temphr = pCont->MoveHere(const_cast<WCHAR*>(pAcct->GetTargetPath()), const_cast<WCHAR*>(pAcct->GetTargetName()), &pDisp);
						     //if move failed due to CN conflict, do not migrate
                          if ( FAILED(temphr) ) 
						  {
                             // The move failed one of the reasons might be that there is a conflict in container name ( CN )
						     DWORD						nPathLen = LEN_Path;
                             WCHAR                      path9[LEN_Path];
                             IADs                     * pAds9 = NULL;

                             // Build the path to the target object
                             MakeFullyQualifiedAdsPath(sPath9, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
                             WCHAR * pRelativeTgtOUPath = wcschr(sPath9 + UStrLen(L"LDAP://") + 2,L'/');

                             if ( pRelativeTgtOUPath )
							 {
                                *pRelativeTgtOUPath = 0;
                                swprintf(path9,L"%ls/%ls,%ls",sPath9,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
							 }

                             if ( _wcsicmp(path9, pAcct->GetTargetPath()) )
							 {
                                HRESULT phr = ADsGetObject(path9, IID_IADs, (void**)&pAds9);
                                if ( SUCCEEDED(phr) )
								{
                                   // Object with that CN exists so we can not move the object
                                   err.MsgWrite(ErrE, DCT_MSG_MOVE_FAILED_CN_CONFLICT_SSS, pAcct->GetTargetName(), pRelativeTgtOUPath+1);
                                   Mark(L"errors", pAcct->GetType());
                                   pAds9->Release();
								}
							 }
                             pAds->Release();
                             pCont->Release();
                             return temphr;
						  }
					   }
					   else //else try to rename the CN of the object (I'll use the same MoveHere API)
					   {
                          IADsContainer  * pOldCont = NULL;
                          temphr = ADsGetObject(sOldCont, IID_IADsContainer, (void**)&pOldCont);
                          if (SUCCEEDED(temphr))
						  {
                             temphr = pOldCont->MoveHere(const_cast<WCHAR*>(pAcct->GetTargetPath()), const_cast<WCHAR*>(pAcct->GetTargetName()), &pDisp);
                             pOldCont->Release();
						  }
						     //if failed to rename the CN, do not migrate
                          if ( FAILED(temphr) ) 
						  {
                             // The CN rename failed due to conflicting CN in this container
                             err.MsgWrite(ErrE, DCT_MSG_CN_RENAME_CONFLICT_SSS, (WCHAR*)sConfName, pAcct->GetTargetName(), (WCHAR*)sOldCont);
                             Mark(L"errors", pAcct->GetType());
                             pAds->Release();
                             pCont->Release();
							    //if we couldn't rename the CN, change the error code so we don't continue migrating this user
                             if ((HRESULT_CODE(temphr) == ERROR_OBJECT_ALREADY_EXISTS))
                                temphr = HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX);
                             return temphr;
						  }
					   }

                       // Get the new location of the object.
                       BSTR       sNewPath;
                       temphr = pDisp->QueryInterface(IID_IADs, (void**)&pAdsNew);
                       pDisp->Release();
                       if ( FAILED(temphr) )
					   {
                          pCont->Release();
                          pAds->Release();
                          return temphr;
					   }
                       temphr = pAdsNew->get_ADsPath(&sNewPath);
                       pAdsNew->Release();
                       if ( FAILED(temphr) )
					   {
                          pCont->Release();
                          pAds->Release();
                          return temphr;
					   }
                       // And store that in the target path
                       pAcct->SetTargetPath((WCHAR*) sNewPath);
                       SysFreeString(sNewPath);

				           // If the account is a group account and the Replace Existing members flag is set then we need to 
				           // remove all the members of this group.
				       if ( (_wcsicmp(L"group", pAcct->GetType()) == 0 ) && (pOptions->flags & F_REMOVE_OLD_MEMBERS) )
					      RemoveMembers(pAcct, pOptions);

                       pAcct->MarkAlreadyThere();
				       pAcct->MarkReplaced();
					}
			        else
					{
                       //if this is a special account that we need to mark as such
					   if (bIsCritical)
					   {
                          pAcct->MarkCritical();
                          hr = HRESULT_FROM_WIN32(ERROR_SPECIAL_ACCOUNT);
					   }
                    }
                  }
                  else
                  {
                     // Sam Account name is not in the target domain and we have a conflict see if it is a CN conf
                     WCHAR                      sPath9[LEN_Path];
					 DWORD						nPathLen = LEN_Path;
                     WCHAR                      path9[LEN_Path];
                     IADs                     * pAdsNew = NULL;

                     // Build the path to the target object
                     MakeFullyQualifiedAdsPath(sPath9, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
                     WCHAR * pRelativeTgtOUPath = wcschr(sPath9 + UStrLen(L"LDAP://") + 2,L'/');

                     if ( pRelativeTgtOUPath )
                     {
                        *pRelativeTgtOUPath = 0;
                        swprintf(path9,L"%ls/%ls,%ls",sPath9,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
                     }

                     temphr = ADsGetObject(path9, IID_IADs, (void**) &pAdsNew);
                     if ( SUCCEEDED(temphr) )
                     {
                        // Object with that CN exists so we use it
                        BSTR sTgtPath;
                        HRESULT temphr = pAdsNew->get_ADsPath(&sTgtPath);
                        if (SUCCEEDED(temphr))
                           pAcct->SetTargetPath(sTgtPath);
                        else
                           pAcct->SetTargetPath(L"");
                           
                        // Check if the object we are about to replace is of the same type.
						BSTR sClass;
                        temphr = pAdsNew->get_Class(&sClass);
                        if ((SUCCEEDED(temphr)) && (!_wcsicmp(pAcct->GetType(), (WCHAR*)sClass)))
                           bIsDifferentType = FALSE;
						else
                           bIsDifferentType = TRUE;

                        _variant_t   varCritical;
                        temphr = pAdsNew->Get(L"isCriticalSystemObject", &varCritical);
                        if (SUCCEEDED(temphr))
                           bIsCritical = V_BOOL(&varCritical) == -1 ? TRUE : FALSE;

                           //if the source and target accounts are of different types we do not want to replace these.
                        if (bIsDifferentType)
						{
                           hr = HRESULT_FROM_WIN32(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
						}
						   //else if not critical then fix the SAM name and other related chores
                        else if ( !bIsCritical )
						{
                              //get the old Target Account Sam name
                           _variant_t varOldSAM = pAcct->GetTargetSam();
                           temphr = pAdsNew->Get(L"sAMAccountName", &varOldSAM);
                              // Set the Target Account Sam name
                           _variant_t varSAM = pAcct->GetTargetSam();
                           temphr = pAdsNew->Put(L"sAMAccountName", varSAM);
                           if (SUCCEEDED(temphr))
                              temphr = pAdsNew->SetInfo();
						   if ( FAILED(temphr) ) 
						   {
                              // The SAM rename failed due to conflicting SAM, do not migrate
                              err.MsgWrite(ErrE, DCT_MSG_SAM_RENAME_CONFLICT_SS, (WCHAR*)(varOldSAM.bstrVal), pAcct->GetTargetSam());
                              Mark(L"errors", pAcct->GetType());
                              pAds->Release();
                              pCont->Release();
                              pAdsNew->Release();
                              return temphr;
						   }

				              // If the account is a group account and the Replace Existing members flag is set then we need to 
				              // remove all the members of this group.
				           if ( (_wcsicmp(L"group", pAcct->GetType()) == 0 ) && (pOptions->flags & F_REMOVE_OLD_MEMBERS) )
					          RemoveMembers(pAcct, pOptions);

                           pAcct->MarkAlreadyThere();
		                   pAcct->MarkReplaced();
						}
			            else
						{
                           //if this is a special account that we need to mark as such
					       if (bIsCritical)
						   {
                              pAcct->MarkCritical();
                              hr = HRESULT_FROM_WIN32(ERROR_SPECIAL_ACCOUNT);
						   }
						}

                        if ( pAdsNew )
						{
                           pAdsNew->Release();
                           pAdsNew = NULL;
						}
                     }
                     else
                     {
                        // This should only happen if the replace fails because the object that already has 
                        // this SAM Account Name is a special Win2K builtin object or container
                        // One example of this problem is "Service".
                        pAcct->SetStatus(pAcct->GetStatus()|AR_Status_Special);
                        err.SysMsgWrite(ErrE,ERROR_SPECIAL_ACCOUNT,DCT_MSG_REPLACE_FAILED_SD,pAcct->GetName(),ERROR_SPECIAL_ACCOUNT);
                        Mark(L"errors", pAcct->GetType());
                     }
                  }
                  pEnumMem->Release();
                  VariantInit(&var);
               }
               else
               {
    		      pAcct->MarkAlreadyThere();
                  err.MsgWrite(ErrW,DCT_MSG_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                  Mark(L"warnings",pAcct->GetType());
               }
            }
         }
      }
      else
      {
         Mark(L"created", pAcct->GetType());
		   pAcct->MarkCreated();
         BSTR  sTgtPath = NULL;
         HRESULT temphr = pAds->get_ADsPath(&sTgtPath);
         if ( SUCCEEDED(temphr) )
         {
            pAcct->SetTargetPath(sTgtPath);
            SysFreeString(sTgtPath);
         }
         else
            pAcct->SetTargetPath(L"");

         // Add computers to 
         if ( !_wcsicmp(sClass,L"computer") )
         {
            IADsGroup * pGroup = GetWellKnownTargetGroup(DOMAIN_COMPUTERS,pOptions);
            if ( pGroup )
            {
               temphr = pGroup->Add(SysAllocString(pAcct->GetTargetPath()));
               pGroup->Release();
               if ( SUCCEEDED(temphr) )
               {
                  // if we successfully added the computer to Domain computers, now set Domain Computers as 
                  // the primary group
                  temphr = pAds->Put(L"primaryGroupID",_variant_t(LONG(515)));
                  if ( SUCCEEDED(temphr) )
                  {
                     temphr = pAds->SetInfo();
                  }
                  if ( SUCCEEDED(hr) )
                  {
                     // if this worked, now we can remove the computer from Domain Users
                     pGroup = GetWellKnownTargetGroup(DOMAIN_USERS,pOptions);
                     if ( pGroup )
                     {
                        temphr = pGroup->Remove(SysAllocString(pAcct->GetTargetPath()));
                        pGroup->Release();
                     }
                  }
               }
            }
         }
         
      }  
   }
   else
   {
      // This is the No change mode. All we need to do here is to see if there might be a collision.
      WCHAR                  sPath[LEN_Path];
      WCHAR                  sPath9[LEN_Path];
	  DWORD				     nPathLen = LEN_Path;
      WCHAR                  path9[LEN_Path];
      IADs                 * pAdsNew = NULL;
	  BOOL					 bConflict = FALSE;

	  /* see if the CN conflicts */
         // Build the path to the target object
      MakeFullyQualifiedAdsPath(sPath9, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
      WCHAR * pRelativeTgtOUPath = wcschr(sPath9 + UStrLen(L"LDAP://") + 2,L'/');
      if ( pRelativeTgtOUPath )
      {
         *pRelativeTgtOUPath = 0;
         swprintf(path9,L"%ls/%ls,%ls",sPath9,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
      }

      HRESULT temphr = ADsGetObject(path9, IID_IADs, (void**) &pAdsNew);
      if (SUCCEEDED(temphr))
	  {
	     bConflict = TRUE;
         pAdsNew->Release();
         pAdsNew = NULL;
	  }
      
	  /* if no CN conflict, see if the SAM conflicts */
	  if (!bConflict)
	  {
         hr = LookupAccountInTarget(pOptions, const_cast<WCHAR*>(pAcct->GetTargetSam()), sPath);
         if ( hr == S_OK )
	        bConflict = TRUE;
	  }

	  if (!bConflict)
	  {
         // There is no such account on the target. We can go ahead and assume that it would have worked.
         hr = S_OK;
         Mark(L"created", pAcct->GetType());
         pAcct->MarkCreated();

	        //if the UPN conflicted, post a message
	     if (pAcct->bUPNConflicted)
            err.MsgWrite(ErrE, DCT_MSG_UPN_CONF, pAcct->GetTargetSam());
      }
      else
      {
         bConflict = FALSE; //reset the conflict flag
		 // there is a conflict. See if we need to add prefix or suffix. Or simply replace the account.
         if ( wcslen(pOptions->prefix) > 0 )
         {
            // Prefix was specified so we need to try that.
            WCHAR               tgt[LEN_Path];
            WCHAR               pref[LEN_Path], suf[LEN_Path];
            _variant_t          varStr;

            // Here I am adding a prefix and then lets see if we can setinfo that way
            // find the '=' sign
            wcscpy(tgt, pAcct->GetTargetName());
            for ( DWORD z = 0; z < wcslen(tgt); z++ )
            {
               if ( tgt[z] == L'=' ) break;
            }
            
            if ( z < wcslen(tgt) )
            {
               // Get the prefix part ex.CN=
               wcsncpy(pref, tgt, z+1);
               pref[z+1] = 0;
               wcscpy(suf, tgt+z+1);
            }

            // Build the target string with the Prefix
            wsprintf(tgt, L"%s%s%s", pref, pOptions->prefix, suf);
            pAcct->SetTargetName(tgt);

            // Build the target SAM name with the prefix.
            wsprintf(tgt, L"%s%s", pOptions->prefix, pAcct->GetTargetSam());
            StripSamName(tgt);
            pAcct->SetTargetSam(tgt);

               //see if the CN still conflicts
			swprintf(path9,L"%ls/%ls,%ls",sPath9,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
            temphr = ADsGetObject(path9, IID_IADs, (void**) &pAdsNew);
            if (SUCCEEDED(temphr))
			{
	           bConflict = TRUE;
               pAdsNew->Release();
               pAdsNew = NULL;
			}
            
			   //if no CN conflict, see if the SAM name conflicts
			if (!bConflict)
			{
			   hr = LookupAccountInTarget(pOptions, const_cast<WCHAR*>(pAcct->GetTargetSam()), sPath);
               if ( hr == S_OK )
                  bConflict = TRUE;
			}

			if (!bConflict)
			{
               hr = 0;
               Mark(L"created", sClass);
               pAcct->MarkCreated();
            }
            else
            {
               hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
               pAcct->MarkAlreadyThere();
               err.MsgWrite(ErrE, DCT_MSG_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
               Mark(L"errors",pAcct->GetType());
            }

	           //if the UPN conflicted, post a message
	        if (pAcct->bUPNConflicted)
               err.MsgWrite(ErrE, DCT_MSG_UPN_CONF, pAcct->GetTargetSam());
         }
	     else if ( wcslen(pOptions->suffix) > 0 )
		 {
            // Suffix was specified so we will try that.
            WCHAR               tgt[LEN_Path];
            _variant_t          varStr;
            
            // Here I am adding a prefix and then lets see if we can setinfo that way
            wsprintf(tgt, L"%s%s", pAcct->GetTargetName(), pOptions->suffix);
            // Build the target SAM name with the prefix.
            wsprintf(tgt, L"%s%s", pAcct->GetTargetSam(), pOptions->suffix);
            StripSamName(tgt);
            pAcct->SetTargetSam(tgt);

               //see if the CN still conflicts
			swprintf(path9,L"%ls/%ls,%ls",sPath9,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
            temphr = ADsGetObject(path9, IID_IADs, (void**) &pAdsNew);
            if (SUCCEEDED(temphr))
			{
	           bConflict = TRUE;
               pAdsNew->Release();
               pAdsNew = NULL;
			}
            
			   //if no CN conflict, see if the SAM name conflicts
			if (!bConflict)
			{
			   hr = LookupAccountInTarget(pOptions, const_cast<WCHAR*>(pAcct->GetTargetSam()), sPath);
               if ( hr == S_OK )
                  bConflict = TRUE;
			}

			if (!bConflict)
            {
               hr = 0;
               Mark(L"created", sClass);
               pAcct->MarkCreated();
            }
            else
            {
               hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
               pAcct->MarkAlreadyThere();
               err.MsgWrite(ErrE, DCT_MSG_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
               Mark(L"errors",pAcct->GetType());
            }

	           //if the UPN conflicted, post a message
	        if (pAcct->bUPNConflicted)
               err.MsgWrite(ErrE, DCT_MSG_UPN_CONF, pAcct->GetTargetSam());
         }
         else if (pOptions->flags & F_REPLACE)
         {
            // Replace the account.
            hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
         }
         else
         {
            // The account is already there and we really cant do anything about it. So tell the user.
            hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
            pAcct->MarkAlreadyThere();
            err.MsgWrite(ErrE, DCT_MSG_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
            Mark(L"errors",pAcct->GetType());
         }
      }
   }
   // Cleanup
   pCont->Release();
   pAds->Release();
   
   return hr;
}

void VariantSidToString(_variant_t & varSid)
{
   if ( varSid.vt == VT_BSTR )
   {
      return;
   }
   else if ( varSid.vt == ( VT_ARRAY | VT_UI1) )
   {
      // convert the array of bits to a string
      CLdapConnection   c;
      LPBYTE            pByte = NULL;
      WCHAR             str[LEN_Path];

      SafeArrayAccessData(varSid.parray,(void**)&pByte);
      c.BytesToString(pByte,str,GetLengthSid(pByte));
      SafeArrayUnaccessData(varSid.parray);
      
      varSid = SysAllocString(str);

   }
   else
   {
      varSid.ChangeType(VT_BSTR);
   }
}

HRESULT CAcctRepl::UpdateGroupMembership(
                                          Options              * pOptions,    //in -Options set by the user
                                          TNodeListSortable    * acctlist,    //in -List of all accounts being copied
                                          ProgressFn           * progress,    //in -Progress update 
                                          IStatusObj           * pStatus      //in -Status update
                                        )
{
   IADsGroup               * pGroup = NULL;
   IADsGroup               * pTarget = NULL;
   IADsMembers             * pMem = NULL;
   IVarSetPtr                pVs(__uuidof(VarSet));
   TAcctReplNode           * acct = NULL;
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   IEnumVARIANT            * pVar = NULL;
   _variant_t                var, v2;
   BSTR                      sPath;
   WCHAR                     sTgtPath[LEN_Path];
   _bstr_t                   sSam;
   IADs                    * pAds = NULL;
   IIManageDBPtr             pDB = pOptions->pDb;
   IUnknown                * pUnk = NULL;
   TNodeTreeEnum             tenum;
   HRESULT                   hr = S_OK;   
   DWORD                     ret = 0;
   IDispatch               * pDisp = NULL;
   bool                      bFoundGroups = false;
   WCHAR                     sDomain[LEN_Path];
   BSTR                      sClass;
   DWORD                     grpType = 0;
   
   pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
   
   // sort the account list by Source Type\Source Sam Name
   if ( acctlist->IsTree() ) acctlist->ToSorted();
   acctlist->SortedToScrambledTree();
   acctlist->Sort(&TNodeCompareAccountSam);
   acctlist->Balance();
   
   for ( acct = (TAcctReplNode *)tenum.OpenFirst(acctlist) ; acct ; acct = (TAcctReplNode *)tenum.Next() )
   {      
      if ( !acct->ProcessMem() )
         continue;
      if ( pStatus )
      {
         LONG                status = 0;
         HRESULT             hr = pStatus->get_Status(&status);
         
         if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
         {
            if ( !bAbortMessageWritten ) 
            {
               err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
               bAbortMessageWritten = true;
            }
            break;
         }
      }

      // Since the list is sorted by account type we can continue to ignore everything till we get to the
      // group type and once it is found and processed the rest of types can be ignored
      if ( _wcsicmp(acct->GetType(), L"group") != 0 )
      {
         if ( !bFoundGroups )
            continue;
         else
            break;
      }
      else
      {
         bFoundGroups = true;
      }
      
      
      // If we are here this must be a group type so tell the progrss function what we are doing
      WCHAR                  mesg[LEN_Path];
      PSID                   pSid = NULL;
      bool                   bGotPrimaryGroups = false;

      wsprintf(mesg, GET_STRING(IDS_UPDATING_GROUP_MEMBERSHIPS_S), acct->GetName());
      if ( progress )
         progress(mesg);

      if ( acct->CreateAccount() && (!acct->WasCreated() && !acct->WasReplaced()) )
         // if the account was not copied then why should we even process it?
         // Bad idea. We need to process the account membership because the group may have been previously copied and
         // in this run we simply need to update the membership. Changing the expansion code to mark the account as created.
         // that should fix the problem.
         continue;

      if ( !_wcsicmp(acct->GetType(), L"group") && *acct->GetTargetPath() )
      {
         err.MsgWrite(0, DCT_MSG_PROCESSING_GROUP_MEMBER_S, (WCHAR*) acct->GetTargetName());
         if ( !pOptions->nochange )
         {
            hr = ADsGetObject(const_cast<WCHAR*>(acct->GetTargetPath()), IID_IADsGroup, (void**) &pTarget);
            if (FAILED(hr)) 
            {
               err.SysMsgWrite(ErrE, 0, DCT_MSG_OBJECT_NOT_FOUND_SSD, acct->GetTargetPath(), pOptions->tgtDomain, hr );
               Mark(L"errors", acct->GetType());
               continue;    // we cant possibly do any thing without the source group
            }
         }
         else
            hr = S_OK;

         hr = GetTargetGroupType(const_cast<WCHAR*>(acct->GetTargetPath()), grpType);

         hr = ADsGetObject(const_cast<WCHAR*>(acct->GetSourcePath()), IID_IADsGroup, (void**) &pGroup);
         if (FAILED(hr)) 
         {
            if ( pTarget )pTarget->Release();
            err.SysMsgWrite(ErrE, 0, DCT_MSG_OBJECT_NOT_FOUND_SSD, acct->GetSourcePath(), pOptions->srcDomain, hr );
            Mark(L"errors", acct->GetType());
            continue;    // we cant possibly do any thing for this group without the target group
         }

         // Now we get the members interface.
         if ( SUCCEEDED(hr) )
            hr = pGroup->Members(&pMem);

         // Ask for an enumeration of the members
         if ( SUCCEEDED(hr) )
            hr = pMem->get__NewEnum((IUnknown **)&pVar);

         // Now enumerate through all the objects in the Group
         while ( SUCCEEDED(pVar->Next(1, &var, &ret)) )
         {
            // Check if user wants to abort the operation
            if ( pOptions->pStatus )
            {
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
         
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               {
                  if ( !bAbortMessageWritten ) 
                  {
                     err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                     bAbortMessageWritten = true;
                  }
                  break;
               }
            }
            // If no values are returned that means we are done with all members
            if ( ret == 0  || var.vt == VT_EMPTY)
            {
               if ( bGotPrimaryGroups )
                  break;
               else
               {
                  // Go through and add all the users that have this group as their primary group.
                  bGotPrimaryGroups = true;
                  if (pVar) pVar->Release();
                  pVar = NULL;
                  hr = GetThePrimaryGroupMembers(pOptions, const_cast<WCHAR*>(acct->GetSourceSam()), pVar);
                  continue;
               }
            }

            // Depending on what we are looking at we get two variant types. In case of members we get
            // IDispatch pointer in a variant. In case of primary group members we get variant(bstr) array 
            // So we need to branch here depending on what we get
            if ( bGotPrimaryGroups )
            {
               // first element is the ADsPath of the object so use that to get the object and continue
               if ( var.vt == (VT_ARRAY | VT_VARIANT) )
               {
                  SAFEARRAY * pArray = var.parray;
                  _variant_t            * pDt;

                  hr = SafeArrayAccessData(pArray, (void**) &pDt);
                  if (SUCCEEDED(hr))
                  {
                     if ( pDt[0].vt == VT_BSTR )
                        hr = ADsGetObject((WCHAR*)pDt[0].bstrVal, IID_IADs, (void**) &pAds);
                     else
                        hr = E_FAIL;
                     SafeArrayUnaccessData(pArray);
                  }
                  VariantInit(&var);
               }
               else
                  hr = E_FAIL;
            }
            else
            {
               // We have a dispatch pointer in the VARIANT so we will get the IADs pointer to it and
               // then get the ADs path to that object and then remove it from the group
               pDisp = V_DISPATCH(&var);  
               hr = pDisp->QueryInterface(IID_IADs, (void**) &pAds);
            }

            if ( SUCCEEDED(hr) )
            {
               hr = pAds->get_ADsPath(&sPath);
               if ( SUCCEEDED(hr) )
               {               
                  // Parse out the domain name from the LDAP path.
                  if ( !wcsncmp(L"WinNT://", (WCHAR*)sPath, 8) )
                  {
                     //Grab the domain name from the WinNT path.
                     WCHAR             sTemp[LEN_Path];
                     WCHAR * p = (WCHAR*)sPath;
                     wcscpy(sTemp, p+8);
                     p = wcschr(sTemp, L'/');
                     if ( p )
                        *p = L'\0';
                     else
                     {
                        //we have the path in this format "WinNT://S-1-5....."
                        // in this case we need to get the SID and then try and get its domain and account name
                        PSID                         pSid = NULL;
                        WCHAR                        sName[255];
                        DWORD                        rc = 1;

                        pSid = SidFromString(sTemp);
                        if ( pSid )
                        {
                           rc = GetName(pSid, sName, sTemp);
                           if ( !rc )
                           {
                              // Give it a winnt path. This way we get the path that we can use
                              sPath = _bstr_t(L"WinNT://") + sTemp + _bstr_t(L"/") + sName;
                           }
						   FreeSid(pSid);
                        }

                        if ( rc ) 
                        {
                           // Log a message that we cant resolve this guy
                           err.SysMsgWrite(ErrE, rc, DCT_MSG_PATH_NOT_RESOLVED_SD, sTemp, rc);
                           if ( pAds ) pAds->Release();
                           pAds = NULL;
                           Mark("errors", acct->GetType());
                           continue;
                        }
                     }
                     wcscpy(sDomain, sTemp);
                  }
                  else
                  {
                     // Get the domain name from the LDAP path. Convert domain name to the NETBIOS name.
                     WCHAR             sTemp[LEN_Path];
                     WCHAR             sp[LEN_Path];
                     WCHAR * p = (WCHAR*)sPath;
                     wcscpy(sTemp, p+7);
                     p = wcschr(sTemp, L'/');
                     if ( p )
                        *p = L'\0';
               
                     // Now run this domain name through the Function to get the NETBIOS name.
                     GetDnsAndNetbiosFromName(sTemp, sDomain, sp);
                  }
               }

               if ( SUCCEEDED(hr) )
               {
                  if ( !(acct->GetGroupType() & 4) )
                  {
                     // Global/Universal groups are easy all we have to do is use the path we got back and get the info from that object
                     hr = pAds->get_Class(&sClass);
                     hr = pAds->Get(L"samAccountName", &v2);
                     if ( SUCCEEDED(hr) )
                        sSam = v2;
                     else
                     {
                        // make sure it is a WinNT:// path 
                        sSam = L"";
                        if ( !wcsncmp((WCHAR*)sPath, L"WinNT://", 8) )
                        {
                           // it must be a non NT4 account we are going to have to parse the path to get samName
                           // ignore the WinNT://<domain>/ part and you got yourself the sam name
                           WCHAR * t = (WCHAR*) sPath;
                           WCHAR * sTemp = wcschr(t+(8), L'/');
                           if ( sTemp )
                           {
                              sSam = ++sTemp;
                              hr = S_OK;
                           }
                        }
                     }
					    //if universal group change domain if foreign security principal
                     if ((acct->GetGroupType() & 8))
					 {
						_bstr_t sTempDomain = GetDomainOfMigratedForeignSecPrincipal(sPath);
						if (sTempDomain.length())
						   wcscpy(sDomain, sTempDomain);
					 }
                  }
                  else
                  {
                     // Local group we need to get the SID LDAP path and then use that to add the account to the group.
                     WCHAR                   sSidPath[LEN_Path];
                     WCHAR                   sSamName[LEN_Path];
                     HRESULT                 hrGetSid;

                     if ( pSid )
                     {
                        delete pSid;
                        pSid = NULL;
                     }

                     hrGetSid = BuildSidPath(sPath, sSidPath, sSamName, sDomain, pOptions,&pSid);

                     if (SUCCEEDED(hrGetSid))
                     {
						_bstr_t sTempDomain = GetDomainOfMigratedForeignSecPrincipal(sPath);
						if (sTempDomain.length())
						   wcscpy(sDomain, sTempDomain);
                        sPath = sSidPath;
                        sSam = sSamName;
                     }
                  }
               }
            }
            if ( pAds ) pAds->Release();
      
            if ( SUCCEEDED(hr) )
            {
               // Now that we have the SamAccountname and the path we can lookup the info from the DB
               hr = pDB->GetAMigratedObject((WCHAR*)sSam, sDomain, pOptions->tgtDomain, &pUnk);
               if ( pOptions->nochange )
               {
                  WCHAR                   targetPath[LEN_Path];
                  // in this case the account was not really copied so we need to make sure that we 
                  // we include the accounts that would have been added if this was a true migration.
                  Lookup      p;
                  p.pName = (WCHAR*) sSam;
                  p.pType = (WCHAR*) sClass;
                  TAcctReplNode * pNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                  if (pNode)
                  {
                     v2 = pNode->GetTargetSam();
                     pVs->put(L"MigratedObjects.TargetSamName", v2);

                     v2 = pNode->GetTargetName();
                     BuildTargetPath( (WCHAR*) v2.bstrVal, pOptions->tgtOUPath, targetPath);
                     v2 = targetPath;
                     pVs->put(L"MigratedObjects.TargetAdsPath", v2);
                     hr = S_OK;
                  }
               }
               if ( hr == S_OK )
               {
                  // Since we have previously copied the account we can simply add the one that we copied.
                  v2 = pVs->get(L"MigratedObjects.TargetAdsPath");
                  if ( v2.vt == VT_BSTR )
                  {
                     if ( !pOptions->nochange )
                        hr = pTarget->Add(v2.bstrVal);
                     else
                        hr = S_OK;

                     if ( SUCCEEDED(hr) )
					 {
                        err.MsgWrite(0, DCT_MSG_ADDED_TO_GROUP_S, (WCHAR*)v2.bstrVal);

						   //if this is not a global group, remove the source account from the group, if there
						if (!(acct->GetGroupType() & 2))
						   RemoveSourceAccountFromGroup(pTarget, pVs, pOptions);
					 }
                     else
                     {
                        hr = BetterHR(hr);
                        switch ( HRESULT_CODE(hr) )
                        {
                           case NERR_UserNotFound:
                           case 0x5000:
                              err.SysMsgWrite(0, hr, DCT_MSG_MEMBER_NONEXIST_SS, (WCHAR *)v2.bstrVal, acct->GetTargetName(), hr);
                              break;
                           default:
                              {
                                 err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_ADD_TO_GROUP_SSD, (WCHAR *)v2.bstrVal, acct->GetTargetName(), hr);
                                 Mark(L"warnings", acct->GetType());
                              }
                        }
                     }
                  }
               }
               else
               {
                  // We have not migrated the accounts from source domain to the target domain.
                  // so we now have to branch for different group types.
                  WCHAR                     domain[LEN_Path];
                  DWORD                     cbDomain = DIM(domain);
//                  DWORD                     rc = 0;
                  SID_NAME_USE              use;

                  if ( grpType & 2 )
                  {
                     // For the global groups we simply say that account has not been migrated.
                     err.MsgWrite(0, DCT_MSG_MEMBER_NONEXIST_SS, (WCHAR*)sSam, acct->GetTargetName());
                  }
                  else
                  {
                     //Process local/universal groups ( can add objects from non-target domains )
                     // 1. See if we have migrated this account to some other domain.
                     // 2. Is the Source accounts SID valid here (trust) if so add that.
                     // 3. See if we can find an account with the same name in the target.
                     // if any of these operations yield a valid account then just add it.
                  
                     // we are going to lookup migrated objects table to find migration of this object
                     // from source domain to any other domain.
                     hr = pDB->raw_GetAMigratedObjectToAnyDomain((WCHAR*)sSam, sDomain, &pUnk);
                     if ( hr == S_OK )
                     {
                        // we have migrated the object to some other domain. So we will get the path to that object and try to add it to the group
                        // it may fail if there is no trust/forest membership of the target domain and the domain that this object resides in. 
                        v2 = pVs->get(L"MigratedObjects.TargetAdsPath");
                        if ( v2.vt == VT_BSTR )
                        {
                           // Since the object is in a different domain, we will have to get the SID of the object, 
                           // and use that for the Add
                           IADs                 * pAds = NULL;
                           _variant_t             varSid;
                     
                           hr = ADsGetObject(v2.bstrVal,IID_IADs,(void**)&pAds);
                           if ( SUCCEEDED(hr) )
                           {
                              hr = pAds->Get(SysAllocString(L"objectSid"),&varSid);
                              pAds->Release();
                           }
                           if ( SUCCEEDED(hr) )
                           {
                              // Make sure the SID we got was in string format
                              VariantSidToString(varSid);
                              UStrCpy(sTgtPath,L"LDAP://<SID=");
                              UStrCpy(sTgtPath + UStrLen(sTgtPath),varSid.bstrVal);
                              UStrCpy(sTgtPath + UStrLen(sTgtPath),L">");
                        
                              if ( !pOptions->nochange )
                                 hr = pTarget->Add(sTgtPath);
                              else
                                 hr = S_OK;
                           }
                        
                           if ( SUCCEEDED(hr) )
						   {
                              err.MsgWrite(0, DCT_MSG_ADDED_TO_GROUP_S, (WCHAR*)v2.bstrVal);

						         //remove the source account from the group, if there
						      RemoveSourceAccountFromGroup(pTarget, pVs, pOptions);
						   }
                           else
                           {
                              hr = BetterHR(hr);
                              if ( HRESULT_CODE(hr) == NERR_UserExists )
                              {
                                 err.MsgWrite(0,DCT_MSG_USER_IN_GROUP_SS,(WCHAR*)v2.bstrVal,acct->GetTargetName());
                              }
                              else if ( HRESULT_CODE(hr) == NERR_UserNotFound )
                              {
                                 err.SysMsgWrite(0, hr, DCT_MSG_MEMBER_NONEXIST_SS, (WCHAR*)v2.bstrVal, acct->GetTargetName(), hr);
                              }
                              else
                              {
                                 // message for the generic failure case
                                 err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_ADD_TO_GROUP_SSD, (WCHAR*)v2.bstrVal, acct->GetTargetName(), hr);
                                 Mark(L"warnings", acct->GetType());
                              }
                           }
                        }
                     }
                     else
                     {
                        // we have never migrated this account. So we will try to add the original account to the target domain.
                        // This would work if the target domain and the domain where this object is satisfy the requirements of
                        // forest membership/ trusts imposed by Universal/Local groups respectively.
                     
                        // Get the sid of the source account
            //            IADs                 * pAds = NULL;
                        _variant_t             varSid;
                     
                        // check whether the target domain knows this sid
                        // Before we try to add, make sure the target domain knows this account
                        WCHAR                      name[LEN_Path];
                        DWORD                      lenName = DIM(name);
                        cbDomain = DIM(domain);
                     
                        if ( grpType & 8 )
                        {
                           // in case of the Universal group we need to make sure that domains are in 
						   // the same forest. We will use access checker for this
                           BOOL           bIsSame = FALSE;
                           _bstr_t sSrcDomainDNS = GetDomainDNSFromPath(sPath);
                           hr = pAccess->raw_IsInSameForest(pOptions->tgtDomainDns, sSrcDomainDNS, (long*)&bIsSame);
                           if ( SUCCEEDED(hr) && bIsSame )
                           {
                              // We have accounts that are in same forest so we can simply add the account.
                              if ( !pOptions->nochange )
                                 hr = pTarget->Add(sPath);
                              else
                                 hr = S_OK;
                           }
						   else
							  hr = HRESULT_FROM_WIN32(NERR_UserNotFound);

                           if ( SUCCEEDED(hr) )
                           {
                              WCHAR sWholeName[LEN_Path];
                              wcscpy(sWholeName, sSrcDomainDNS);
                              wcscat(sWholeName, L"\\");
                              wcscat(sWholeName, sSam);
                              err.MsgWrite(0, DCT_MSG_ADDED_TO_GROUP_S, sWholeName);
                           }
                           else
                           {
                              hr = BetterHR(hr);
                              err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_ADD_TO_GROUP_SSD, (WCHAR*) sSam, acct->GetTargetName(), hr);
                              Mark(L"warnings", acct->GetType());
                           }
                        }
                        else
                        {
                           if ( !pOptions->nochange )
                              hr = pTarget->Add(sPath);
                           else
                              hr = S_OK;

                           // In case of local groups If we know the SID in the target domain then we can simply
                           // add that account to the target group
                           if ( LookupAccountSid(pOptions->tgtComp,pSid,name,&lenName,domain,&cbDomain,&use) )
                           {
                              WCHAR sWholeName[LEN_Path];
                              wcscpy(sWholeName, domain);
                              wcscat(sWholeName, L"\\");
                              wcscat(sWholeName, sSam);
                              err.MsgWrite(0, DCT_MSG_ADDED_TO_GROUP_S, sWholeName);
                           }
                           else
                           {
                              // log the fact that the SID could not be resolved in the target domain
                              // this will happen when the target domain does not trust the source domain
                              WCHAR sWholeName[LEN_Path];
                              wcscpy(sWholeName, sDomain);
                              wcscat(sWholeName, L"\\");
                              wcscat(sWholeName, sSam);
                              err.MsgWrite(0, DCT_MSG_CANNOT_RESOLVE_SID_IN_TARGET_SS, sWholeName, acct->GetTargetName(), HRESULT_FROM_WIN32(GetLastError()));
                           }
                        }
                     }
                  }  // if group type
               }  // if not migrated to the target domain.
            }  // if can get to the member. 
            VariantClear(&var);
         }  //while
         if ( pMem ) pMem->Release();
         if ( pGroup ) pGroup->Release();
         if ( pVar ) pVar->Release();
         if ( pTarget ) pTarget->Release();
      }
      if( pSid )
         delete pSid;
   }
   if ( pUnk )
      pUnk->Release();
   return hr;
}

HRESULT CAcctRepl::LookupAccountInTarget(Options * pOptions, WCHAR * sSam, WCHAR * sPath)
{
   if ( pOptions->tgtDomainVer < 5 )
   {
      // for NT4 we can just build the path and send it back. 
      wsprintf(sPath, L"WinNT://%s/%s", pOptions->tgtDomain, sSam);
      return S_OK;
   }
   // Use the net object enumerator to lookup the account in the target domain.
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   IEnumVARIANT            * pEnum = NULL;
   SAFEARRAYBOUND            bd = { 1, 0 };
   SAFEARRAY               * pszColNames;
   BSTR  HUGEP             * pData = NULL;
   LPWSTR                    sData[] = { L"aDSPath" };
   WCHAR                     sQuery[LEN_Path];
   WCHAR                     sDomPath[LEN_Path];
   DWORD                     ret = 0;
   _variant_t                var, varVal;
   HRESULT                   hr = S_OK;

   wsprintf(sDomPath, L"LDAP://%s/%s", pOptions->tgtDomainDns, pOptions->tgtNamingContext);
   WCHAR                     sTempSamName[LEN_Path];
   wcscpy(sTempSamName, sSam);
   if ( sTempSamName[0] == L' ' )
   {
      WCHAR               sTemp[LEN_Path];
      wsprintf(sTemp, L"\\20%s", sTempSamName + 1); 
      wcscpy(sTempSamName, sTemp);
   }
   wsprintf(sQuery, L"(sAMAccountName=%s)", sTempSamName);

   hr = pQuery->raw_SetQuery(sDomPath, pOptions->tgtDomain, sQuery, ADS_SCOPE_SUBTREE, FALSE);

   // Set up the columns that we want back from the query ( in this case we need SAM accountname )
   pszColNames = ::SafeArrayCreate(VT_BSTR, 1, &bd);
   hr = ::SafeArrayAccessData(pszColNames, (void HUGEP **)&pData);
   if ( SUCCEEDED(hr) )
      pData[0] = SysAllocString(sData[0]);

   if ( SUCCEEDED(hr) )
      hr = ::SafeArrayUnaccessData(pszColNames);

   if ( SUCCEEDED(hr) )
      hr = pQuery->raw_SetColumns(pszColNames);

   // Time to execute the plan.
   if ( SUCCEEDED(hr) )
      hr = pQuery->raw_Execute(&pEnum);

   if ( SUCCEEDED(hr) )
   {
      // if this worked that means we can only have one thing in the result.
      if ( (pEnum->Next(1, &var, &ret) == S_OK) && ( ret > 0 ) )
      {
         SAFEARRAY * pArray = var.parray;
         long        ndx = 0;
         hr = SafeArrayGetElement(pArray,&ndx,&varVal);
         if ( SUCCEEDED(hr) )
            wcscpy(sPath, (WCHAR*)varVal.bstrVal);
         else
            hr = HRESULT_FROM_WIN32(NERR_UserNotFound);
      }
      else
         hr = HRESULT_FROM_WIN32(NERR_UserNotFound);

      VariantInit(&var);
   }
   if ( pEnum ) pEnum->Release();
   return hr;
}

//----------------------------------------------------------------------------
// RemoveMembers : This function enumerates through all the members of the 
//                 given group and removes them one at a time.
//----------------------------------------------------------------------------
HRESULT CAcctRepl::RemoveMembers(
                                    TAcctReplNode * pAcct,  //in- AccountReplicator Node with the Account info
                                    Options * pOptions      //in- Options set by the user.
                                )

{
   IADsMembers             * pMem = NULL;
   IADs                    * pAds = NULL;
   IADsGroup               * pGrp = NULL;
  // IUnknown                * pUnk;
   IEnumVARIANT            * pVar = NULL;
   IDispatch               * pDisp = NULL;
   DWORD                     ret = 0;
   _variant_t                var;
   WCHAR                   * sPath;

   // First we make sure that this is really a group otherwise we ignore it.
   if (_wcsicmp((WCHAR*)pAcct->GetType(),L"group"))
      return S_OK;

   // Lets get a IADsGroup * to the group object.
   HRESULT hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetTargetPath()), IID_IADsGroup, (void **) &pGrp);

   // Now we get the members interface.
   if ( SUCCEEDED(hr) )
      hr = pGrp->Members(&pMem);

   // Ask for an enumeration of the members
   if ( SUCCEEDED(hr) )
      hr = pMem->get__NewEnum((IUnknown **)&pVar);

   // Now enumerate through all the objects in the Group and for each one remove it from the group
   while ( SUCCEEDED(pVar->Next(1, &var, &ret)) )
   {
      // If no values are returned that means we are done with all members so break out of this loop
      if ( ret == 0 )
         break;

      // We hace a dispatch pointer in the VARIANT so we will get the IADs pointer to it and
      // then get the ADs path to that object and then remove it from the group
      pDisp = V_DISPATCH(&var);  
      hr = pDisp->QueryInterface(IID_IADs, (void**) &pAds);

      if ( SUCCEEDED(hr) )
         hr = pAds->get_ADsPath(&sPath);
      if ( pAds ) pAds->Release();
      
      if ( SUCCEEDED(hr) )
      {
         _bstr_t bstrPath(sPath);
         if ( !pOptions->nochange )
            hr = pGrp->Remove(bstrPath);
      }
      VariantClear(&var);
   }
   if ( pMem ) pMem->Release();
   if ( pGrp ) pGrp->Release();
   if ( pVar ) pVar->Release();
   return hr;
}

//----------------------------------------------------------------------------
// FillPathInfo : This function looks up the ADs path from the source domain 
//                for a given SAMAccountName
//----------------------------------------------------------------------------
bool CAcctRepl::FillPathInfo(
                              TAcctReplNode * pAcct,  //in- AccountReplicator Node with the Account info
                              Options * pOptions      //in- Options set by the user.
                            )
{
   WCHAR                     sPath[LEN_Path];
   _bstr_t					 sTgtPath;
   WCHAR                     sQuery[LEN_Path];
//   WCHAR                     sPrefix[LEN_Path];
//   WCHAR                     sTgtName[LEN_Path];
   WCHAR                     sProfPath[LEN_Path];
   WCHAR                     sName[LEN_Path];
   // Fill the naming context for the domains. If the Naming context does not work then it is not a Win2kDomain
   // so we need to stop right here.
   if ( wcslen(pOptions->srcNamingContext) == 0 ) 
      FillNamingContext(pOptions);

   if ( wcslen(pOptions->srcNamingContext) == 0 )
   {
      // this is probably an NT 4 source domain
      // construct the source path
      if ( ! *pAcct->GetSourcePath() )
      {
         swprintf(sPath,L"WinNT://%ls/%ls",pOptions->srcDomain,pAcct->GetName());
         pAcct->SetSourcePath(sPath);
      }
      return true;
   }

   WCHAR                     strName[LEN_Path];
   wcscpy(strName, pAcct->GetName());
   // Check if the Name field is a LDAP sub path or not. If we have LDAP subpath then we
   // call the AcctReplFullPath function to fillup the path information.
   if ( (wcslen(strName) > 3) && (strName[2] == (L'=')) )
   {
      AcctReplFullPath(pAcct, pOptions);
      return true;
   }

   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   HRESULT                   hr;
   LPWSTR                    sData[] = { L"ADsPath", L"distinguishedName", L"name", L"profilePath", L"groupType" };
   long                      nElt = DIM(sData);
   BSTR  HUGEP             * pData;
   SAFEARRAY               * pszColNames;
   IEnumVARIANT            * pEnum;
   _variant_t                var;
   DWORD                     dwFetch;

   // We are going to update all fields that we know about
//   pAcct->SetSourceSam(pAcct->GetName());
 
   // Set the LDAP path to the whole domain and then the query to the SAMAccountname
   wsprintf(sPath, L"LDAP://%s/%s", pOptions->srcDomain, pOptions->srcNamingContext);
   WCHAR                     sTempSamName[LEN_Path];
   wcscpy(sTempSamName, pAcct->GetSourceSam());
   if ( sTempSamName[0] == L' ' )
   {
      WCHAR               sTemp[LEN_Path];
      wsprintf(sTemp, L"\\20%s", sTempSamName + 1); 
      wcscpy(sTempSamName, sTemp);
   }
   wsprintf(sQuery, L"(sAMAccountName=%s)", sTempSamName);

   // Set the enumerator query
   hr = pQuery->raw_SetQuery(sPath, pOptions->srcDomain, sQuery, ADS_SCOPE_SUBTREE, FALSE);

   if (SUCCEEDED(hr))
   {
      // Create a safearray of columns we need from the enumerator.
      SAFEARRAYBOUND bd = { nElt, 0 };
   
      pszColNames = ::SafeArrayCreate(VT_BSTR, 1, &bd);
      HRESULT hr = ::SafeArrayAccessData(pszColNames, (void HUGEP **)&pData);
      if ( SUCCEEDED(hr) )
      {
         for( long i = 0; i < nElt; i++)
         {
            pData[i] = SysAllocString(sData[i]);
         }
   
         hr = ::SafeArrayUnaccessData(pszColNames);
      }

      if (SUCCEEDED(hr))
      {
         // Set the columns on the enumerator object.
         hr = pQuery->raw_SetColumns(pszColNames);
      }
   }

   if (SUCCEEDED(hr))
   {
      // Now execute.
      hr = pQuery->raw_Execute(&pEnum);
   }

   if (SUCCEEDED(hr))
   {
      // We should have recieved only one value. So we will get the value and set it into the Node.
      hr = pEnum->Next(1, &var, &dwFetch);
   }

   if ( SUCCEEDED(hr) && ( var.vt & VT_ARRAY) )
   {
      // This would only happen if the member existed in the target domain.
      // We now have a Variant containing an array of variants so we access the data
      _variant_t               * pVar;
      pszColNames = V_ARRAY(&var);
      SafeArrayAccessData(pszColNames, (void HUGEP **)&pVar);
      
      // Get the AdsPath first
      sTgtPath = pVar[0].bstrVal;
      if (sTgtPath.length() > 0)
      {
         // Set the source Path in the Account node
         pAcct->SetSourcePath(sTgtPath);

         // Then we get the distinguishedName to get the prefix string
         sTgtPath = V_BSTR(&pVar[1]);

         // We also get the name value to set the target name
         wcscpy(sName, (WCHAR*) V_BSTR(&pVar[2]));

         // We also get the profile path so we can translate it
         wcscpy(sProfPath, (WCHAR*) V_BSTR(&pVar[3]));
         pAcct->SetTargetProfile(sProfPath);

         if ( pVar[4].vt == VT_I4 )
         {
            // We have the object type property so lets set it.
            pAcct->SetGroupType(pVar[4].lVal);
         }
      
         SafeArrayUnaccessData(pszColNames);
      
         pEnum->Release();
         VariantInit(&var);
         return true;
      }
      else
      {
         //There is no account with this SAM name in this domain
         err.SysMsgWrite(ErrE, 2, DCT_MSG_PATH_NOT_FOUND_SS, pAcct->GetName(), pOptions->tgtDomain);
         Mark(L"errors", pAcct->GetType());
         SafeArrayUnaccessData(pszColNames);
      }

   }
   
   if (SUCCEEDED(hr))
      pEnum->Release();

   return false;
}

//--------------------------------------------------------------------------
// AcctReplFullPath : Fills up Account node when the account information
//                 coming in is a LDAP sub path.
//--------------------------------------------------------------------------
bool CAcctRepl::AcctReplFullPath(                              
                                    TAcctReplNode * pAcct,  //in- AccountReplicator Node with the Account info
                                    Options * pOptions      //in- Options set by the user.
                                )
{
   WCHAR                     sName[LEN_Path];
   WCHAR                     sPath[LEN_Path];
   IADs                    * pAds;
   _variant_t                var;

   // Build a full path and save it to the Account node
   wsprintf(sPath, L"LDAP://%s/%s,%s", pOptions->srcDomain, pAcct->GetName(), pOptions->srcNamingContext);
   pAcct->SetSourcePath(sPath);

   // Do the same for Target account.
   wcscpy(sName, pAcct->GetTargetName());
   if ( !wcslen(sName) ) 
   {
      // Since Target name not specified we will go ahead and use the source name as the target name,
      wcscpy(sName, pAcct->GetName());
      pAcct->SetTargetName(sName);
   }

   // Build a full path from the sub path
/*   wsprintf(sPath, L"LDAP://%s/%s,%s", pOptions->tgtDomain, sName, pOptions->tgtNamingContext);
   pAcct->SetTargetPath(sPath);
*/
   // Lets try and get the SAM name for the source account
   HRESULT hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADs, (void**) &pAds);
   if ( FAILED(hr)) return false;

   hr = pAds->Get(L"sAMAccountName", &var);
   pAds->Release();
   if ( SUCCEEDED(hr) )
      pAcct->SetSourceSam((WCHAR*)var.bstrVal);

   // SAM account name for the target account
   // Since we are here we have a LDAP sub path. So we can copy string from 3rd character to end of line or
   // till the first ','
   wcscpy(sName, pAcct->GetTargetName());
   WCHAR * p = wcschr(sName, L',');
   int ndx = wcslen(sName);
   if ( p )
   {
      // There is a , So we can find how many characters that is by subtracting two pointers
      ndx = (int)(p - sName);
   }
   ndx -= 3;   // We are going to ignore the first three characters
 
   // Copy from third character on to the , or End of line this is going to be the SAM name for target
   wcsncpy(sPath, sName + 3, ndx);
   sPath[ndx] = 0;   // Truncate it.
   pAcct->SetTargetSam(sPath);

   return true;
}

//--------------------------------------------------------------------------
// NeedToProcessAccount : This function tells us if the user has set the 
//                         options to copy certain types of accounts.
//--------------------------------------------------------------------------
BOOL CAcctRepl::NeedToProcessAccount(                               
                                       TAcctReplNode * pAcct,  //in- AccountReplicator Node with the Account info
                                       Options * pOptions      //in- Options set by the user.
                                    )
{
   if (_wcsicmp(pAcct->GetType(), L"user") == 0)
      return (pOptions->flags & F_USERS);
   else if ( _wcsicmp(pAcct->GetType(), L"group") == 0)
      return ((pOptions->flags & F_GROUP) || (pOptions->flags & F_LGROUP));
   else if ( _wcsicmp(pAcct->GetType(), L"computer") == 0)
      return pOptions->flags & F_COMPUTERS;
   else if ( _wcsicmp(pAcct->GetType(), L"organizationalUnit") == 0)
      return pOptions->flags & F_OUS;
   else
   {
      err.MsgWrite(0,DCT_MSG_SKIPPING_OBJECT_TYPE_SS,pAcct->GetName(),pAcct->GetType());
      return false;
   }
}

// Compares the DC=...,DC=com part of two ads paths to determine if the objects
// are in the same domain.
BOOL CompareDCPath(WCHAR const * sPath, WCHAR const * sPath2)
{
   WCHAR                   * p1 = NULL, * p2 = NULL;
   p1 = wcsstr(sPath, L"DC=");
   p2 = wcsstr(sPath2, L"DC=");

   if ( p1 && p2 )
      return !_wcsicmp(p1, p2);
   else
      return FALSE;
}

_bstr_t  PadDN(_bstr_t sDN)
{
   _bstr_t retVal = sDN;
   int offset = 0;
   WCHAR sLine[LEN_Path];
   WCHAR sOut[LEN_Path];

   safecopy(sLine, (WCHAR*) sDN);

   for ( DWORD i = 0; i < wcslen(sLine); i++ )
   {
      if ( sLine[i] == L'/' )
      {
         sOut[i + offset] = L'\\';
         offset++;
      }
      sOut[i + offset] = sLine[i];
   }
   sOut[i+offset] = 0;
   retVal = sOut;
   return retVal;
}

//--------------------------------------------------------------------------
// ExpandContainers : Adds all the members of a container/group to the 
//                    account list recursively.
//--------------------------------------------------------------------------
BOOL CAcctRepl::ExpandContainers(
                                    TNodeListSortable *acctlist,     //in- Accounts being processed
                                    Options           *pOptions,     //in- Options specified by the user
                                    ProgressFn        *progress      //in- Show status
                                 )
{
   TAcctReplNode           * pAcct;
   IEnumVARIANT            * pEnum;
   HRESULT                   hr;
   _variant_t                var;
   DWORD                     dwf;
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   LPWSTR                    sCols[] = { L"member" };
   LPWSTR                    sCols1[] = { L"ADsPath" };
   int                       nElt = DIM(sCols);
   SAFEARRAY               * cols;
   SAFEARRAY               * vals;
   SAFEARRAY               * multiVals;
   SAFEARRAYBOUND            bd = { nElt, 0 };
   BSTR  HUGEP             * pData = NULL;
//   _bstr_t                 * pBstr = NULL;
   _variant_t              * pDt = NULL;
   _variant_t              * pVar = NULL;
   _variant_t                vx;
   _bstr_t                   sCont, sQuery;
   _bstr_t                   sPath;
   _bstr_t                   sSam; 
   _bstr_t                   sType;
   _bstr_t                   sName;
   DWORD                     dwMaj, dwMin, dwSP;
//   IIManageDBPtr             pDb(__uuidof(IManageDB));
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk;
   long                      lgrpType;
   WCHAR                     sAcctType[LEN_Path];
   WCHAR                     mesg[LEN_Path];
   WCHAR                     sSourcePath[LEN_Path];
   bool                      bExpanded = true;

   pVs->QueryInterface(IID_IUnknown, (void **) &pUnk);
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   
   // Change from a tree to a sorted list
   if ( acctlist->IsTree() ) acctlist->ToSorted();

   // Check the domain type for the source domain.
   hr = pAccess->raw_GetOsVersion(pOptions->srcComp, &dwMaj, &dwMin, &dwSP);
   if (FAILED(hr)) return FALSE;

   if ( dwMaj < 5 )
   {
      while ( bExpanded )
      {
         bExpanded = false;
         pAcct = (TAcctReplNode *)acctlist->Head();
         while (pAcct)
         {
            if ( pOptions->pStatus )
            {
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
   
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               {
                  if ( !bAbortMessageWritten ) 
                  {
                     err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                     bAbortMessageWritten = true;
                  }
                  break;
               }
            }

            // If we have already expanded the account then we dont need to process it again.
            if ( pAcct->bExpanded )
            {
               pAcct = (TAcctReplNode *) pAcct->Next();
               continue;
            }

            //Set the flag to say that we expanded something.
            bExpanded = true;
            pAcct->bExpanded = true;

            if ( UStrICmp(pAcct->GetType(), L"group") || UStrICmp(pAcct->GetType(), L"lgroup") )
            {
               // Build the column array
               cols = SafeArrayCreate(VT_BSTR, 1, &bd);
               SafeArrayAccessData(cols, (void HUGEP **) &pData);
               for ( int i = 0; i < nElt; i++)
                  pData[i] = SysAllocString(sCols1[i]);
               SafeArrayUnaccessData(cols);
            
               // Build the NT4 recognizable container name
               sCont = _bstr_t(pAcct->GetName()) + L",CN=GROUPS";
               sQuery = L"";  // ignored.

               // Query the information
               hr = pQuery->raw_SetQuery(sCont, pOptions->srcDomain, sQuery, ADS_SCOPE_SUBTREE, TRUE);
               if (FAILED(hr)) return FALSE;
               hr = pQuery->raw_SetColumns(cols);
               if (FAILED(hr)) return FALSE;
               hr = pQuery->raw_Execute(&pEnum);
               if (FAILED(hr)) return FALSE;

               while (pEnum->Next(1, &var, &dwf) == S_OK)
               {
                  if ( pOptions->pStatus )
                  {
                     LONG                status = 0;
                     HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                     if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                     {
                        if ( !bAbortMessageWritten ) 
                        {
                           err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                           bAbortMessageWritten = true;
                        }
                        break;
                     }
                  }
                  vals = var.parray;
                  // Get the first column which is the name of the object.
                  SafeArrayAccessData(vals, (void HUGEP**) &pDt);
                  sPath = pDt[0];
                  SafeArrayUnaccessData(vals);

                  // Enumerator returns empty strings which we need to ignore.
                  if ( sPath.length() > 0 )
                  {
                     // Look if we have migrated the group
                     if ( pOptions->flags & F_COPY_MIGRATED_ACCT )
                        // We want to copy it again even if it was already copied.
                        hr = S_FALSE;
                     else
                        hr = pOptions->pDb->raw_GetAMigratedObject(sPath, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);

                     if ( hr != S_OK )
                     {
                        if ( !IsBuiltinAccount(pOptions, (WCHAR*)sPath) )
                        {
                           // We don't care about the objects that we have migrated because they will be picked up automatically
                           // Find the type of this account.
                           if ( GetNt4Type(pOptions->srcComp, (WCHAR*) sPath, sAcctType) )
                           {
                              // Expand the containers and the membership
                              wsprintf(mesg, GET_STRING(IDS_EXPANDING_ADDING_SS) , pAcct->GetName(), (WCHAR*) sPath);
                              Progress(mesg);
                              TAcctReplNode * pNode = new TAcctReplNode();
							  if (!pNode)
							     return FALSE;
                              pNode->SetName((WCHAR*)sPath);
                              pNode->SetTargetName((WCHAR*)sPath);
                              pNode->SetSourceSam((WCHAR*)sPath);
                              WCHAR             tgtName[LEN_Path];
                              wcscpy(tgtName, (WCHAR*) sPath);
                              TruncateSam(tgtName, pNode, pOptions, acctlist);
                              pNode->SetTargetSam(tgtName);
                              pNode->SetType(sAcctType);
                              if ( !UStrICmp(sAcctType,L"group") )
                              {
                                 // in NT4, only global groups can be members of other groups
                                 pNode->SetGroupType(2);
                              }
						         //Get the source domain sid from the user
                              pNode->SetSourceSid(pAcct->GetSourceSid());
                              AddPrefixSuffix(pNode, pOptions);
                              // build a source WinNT path
                              wsprintf(sSourcePath, L"WinNT://%s/%s", pOptions->srcDomain, (WCHAR*)sPath);
                              pNode->SetSourcePath(sSourcePath);
                              if (! acctlist->InsertIfNew(pNode) )
                                 delete pNode;

                           }
                           else
                           {
                              wsprintf(mesg,GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sPath);
                              Progress(mesg);
                           }
                        }
                        else
                        {
                           err.MsgWrite(ErrW, DCT_MSG_IGNORING_BUILTIN_S, (WCHAR*)sPath);
                           Mark("warnings", pAcct->GetType());
                        }
                     }
                     else
                     {
                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sPath);
                        Progress(mesg);
                     }
                  }
               }
               pEnum->Release();
               VariantInit(&var);
            }
            pAcct = (TAcctReplNode *) pAcct->Next();
         }
      }
      pUnk->Release();
      return TRUE;
   }

   // If we are here that means that we are dealing with Win2k
   while ( bExpanded )   
   {
      bExpanded = false;
      // Go through the list of accounts and expand them one at a time
      pAcct = (TAcctReplNode *)acctlist->Head();
      while (pAcct)
      {
         // If we have already expanded the account then we dont need to process it again.
         if ( pAcct->bExpanded )
         {
            pAcct = (TAcctReplNode *) pAcct->Next();
            continue;
         }

         //Set the flag to say that we expanded something.
         bExpanded = true;
         pAcct->bExpanded = true;

         if ( pOptions->pStatus )
         {
            LONG                status = 0;
            HRESULT             hr = pOptions->pStatus->get_Status(&status);

            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
            {
               if ( !bAbortMessageWritten ) 
               {
                  err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                  bAbortMessageWritten = true;
               }
               break;
            }
         }
         DWORD    scope = 0;
         sCont = pAcct->GetSourcePath();
         sQuery = L"(objectClass=*)";
         if ( wcslen(pAcct->GetSourceSam()) == 0 )
         {
            scope = ADS_SCOPE_SUBTREE;
            // Build the column array
            cols = SafeArrayCreate(VT_BSTR, 1, &bd);
            SafeArrayAccessData(cols, (void HUGEP **) &pData);
            for ( int i = 0; i < nElt; i++)
               pData[i] = SysAllocString(sCols1[i]);
            SafeArrayUnaccessData(cols);
         }
         else
         {
            scope = ADS_SCOPE_BASE;
            // Build the column array
            cols = SafeArrayCreate(VT_BSTR, 1, &bd);
            SafeArrayAccessData(cols, (void HUGEP **) &pData);
            for ( int i = 0; i < nElt; i++)
               pData[i] = SysAllocString(sCols[i]);
            SafeArrayUnaccessData(cols);
         }
      
         hr = pQuery->raw_SetQuery(sCont, pOptions->srcDomain, sQuery, scope, TRUE);
         if (FAILED(hr)) return FALSE;
         hr = pQuery->raw_SetColumns(cols);
         if (FAILED(hr)) return FALSE;
         hr = pQuery->raw_Execute(&pEnum);
         if (FAILED(hr)) return FALSE; 

         while (pEnum->Next(1, &var, &dwf) == S_OK)
         {
            if ( pOptions->pStatus )
            {
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
   
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               {
                  if ( !bAbortMessageWritten ) 
                  {
                     err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                     bAbortMessageWritten = true;
                  }
                  break;
               }
            }
            vals = var.parray;
            // Get the VARIANT Array out
            SafeArrayAccessData(vals, (void HUGEP**) &pDt);
            vx = pDt[0];
            SafeArrayUnaccessData(vals);

            if ( vx.vt == VT_BSTR )
            {
               // We got back a BSTR which could be the value that we are looking for
               sPath = V_BSTR(&vx);
               // Enumerator returns empty strings which we need to ignore.
               if ( sPath.length() > 0 )
               {
                  if ( GetSamFromPath(sPath, sSam, sType, sName,lgrpType, pOptions)  && CompareDCPath((WCHAR*)sPath, pAcct->GetSourcePath()))
                  {
                     if ( pOptions->flags & F_COPY_MIGRATED_ACCT )
                        hr = S_FALSE;
                     else
                        hr = pOptions->pDb->raw_GetAMigratedObject(sSam, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);

                     if ( hr != S_OK )
                     {
                        // We don't care about the objects that we have migrated because they will be picked up automatically
                        if ( _wcsicmp((WCHAR*) sType, L"computer") != 0 )
                        {
                           TAcctReplNode * pNode = new TAcctReplNode();
						   if (!pNode)
						      return FALSE;
                           pNode->SetSourceSam((WCHAR*)sSam);
                           pNode->SetTargetSam((WCHAR*)sSam);
                           pNode->SetName((WCHAR*)sName);
                           pNode->SetTargetName((WCHAR*)sName);
                           pNode->SetType((WCHAR*)sType);
                           pNode->SetSourcePath((WCHAR*)sPath);
                           pNode->SetGroupType(lgrpType);
						      //Get the source domain sid from the user
                           pNode->SetSourceSid(pAcct->GetSourceSid());
                           AddPrefixSuffix(pNode, pOptions);
                           if ( ! acctlist->InsertIfNew(pNode) )
                              delete pNode;
                           wsprintf(mesg, GET_STRING(IDS_EXPANDING_ADDING_SS), pAcct->GetName(), (WCHAR*) sSam);
                           Progress(mesg);
                        }
                        else
                        {
                           wsprintf(mesg, GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sSam);
                           Progress(mesg);
                        }
                     }
                     else
                     {
                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sSam);
                        Progress(mesg);
                     }
                  }
               }
   //            continue;
            }

   //         if (! ( vx.vt & VT_ARRAY ) )
   //            continue;
            if ( vx.vt & VT_ARRAY )
               // We must have got an Array of multivalued properties
               multiVals = vx.parray; 
            else
            {
               // We need to also process the accounts that have this group as its primary group.
               SAFEARRAYBOUND bd = { 0, 0 };
               multiVals = SafeArrayCreate(VT_VARIANT, 1, &bd);
            }
            AddPrimaryGroupMembers(pOptions, multiVals, const_cast<WCHAR*>(pAcct->GetTargetSam()));

            // Access the BSTR elements of this variant array
            SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
            for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
            {
               if ( pOptions->pStatus )
               {
                  LONG                status = 0;
                  HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                  if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                  {
                     if ( !bAbortMessageWritten ) 
                     {
                        err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                        bAbortMessageWritten = true;
                     }
                     break;
                  }
               }
               
               _bstr_t sDN = _bstr_t(pVar[dw]);
               sDN = PadDN(sDN);

               sPath = _bstr_t(L"LDAP://") + _bstr_t(pOptions->srcDomain) + _bstr_t(L"/") + sDN;
               if ( GetSamFromPath(sPath, sSam, sType, sName, lgrpType, pOptions)  && CompareDCPath((WCHAR*)sPath, pAcct->GetSourcePath()))
               {
                  if ( pOptions->flags & F_COPY_MIGRATED_ACCT ) 
                     hr = S_FALSE;
                  else
                     hr = pOptions->pDb->raw_GetAMigratedObject(sSam, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);

                  if ( hr != S_OK )
                  {
                     // We don't care about the objects that we have migrated because they will be picked up automatically
                     if ( _wcsicmp((WCHAR*) sType, L"computer") != 0 )
                     {
                        TAcctReplNode * pNode = new TAcctReplNode();
						if (!pNode)
						   return FALSE;
                        pNode->SetSourceSam((WCHAR*)sSam);
                        pNode->SetTargetSam((WCHAR*)sSam);
                        pNode->SetName((WCHAR*)sName);
                        pNode->SetTargetName((WCHAR*)sName);
                        pNode->SetType((WCHAR*)sType);
                        pNode->SetSourcePath((WCHAR*)sPath);
                        pNode->SetGroupType(lgrpType);
						   //Get the source domain sid from the user
                        pNode->SetSourceSid(pAcct->GetSourceSid());
                        AddPrefixSuffix(pNode, pOptions);
                        if (! acctlist->InsertIfNew(pNode) )
                           delete pNode;
                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_ADDING_SS), pAcct->GetName(), (WCHAR*) sSam);
                        Progress(mesg);
                     }
                     else
                     {
                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sSam);
                        Progress(mesg);
                     }
                  }
                  else
                  {
                     wsprintf(mesg, GET_STRING(IDS_EXPANDING_IGNORING_SS), pAcct->GetName(), (WCHAR*) sSam);
                     Progress(mesg);
                  }
               }
            }
            SafeArrayUnaccessData(multiVals);
         }
         pEnum->Release();
         VariantInit(&var);
         pAcct = (TAcctReplNode*)pAcct->Next();
      }
   }
   pUnk->Release();
   return TRUE;
}

//--------------------------------------------------------------------------
// IsContainer : Checks if the account in question is a container type
//               if it is then it returns a IADsContainer * to it.
//--------------------------------------------------------------------------
BOOL CAcctRepl::IsContainer(TAcctReplNode *pNode, IADsContainer **ppCont)
{
   HRESULT                   hr;
   hr = ADsGetObject(const_cast<WCHAR*>(pNode->GetSourcePath()), IID_IADsContainer, (void**)ppCont);
   return SUCCEEDED(hr);
}

BOOL CAcctRepl::GetSamFromPath(_bstr_t sPath, _bstr_t &sSam, _bstr_t &sType, _bstr_t &sName, long& grpType, Options * pOptions)
{
   HRESULT                   hr;
   IADs                    * pAds = NULL;
   _variant_t                var;
   BSTR                      sClass;
   BOOL                      bIsCritical = FALSE;
   BOOL                      rc = TRUE;

   sSam = L"";
   // Get the object so we can ask the questions from it.
   hr = ADsGetObject((WCHAR*)sPath, IID_IADs, (void**)&pAds);
   if ( FAILED(hr) ) return FALSE;

   if ( SUCCEEDED(hr))
   {
      hr = pAds->Get(L"isCriticalSystemObject", &var);
      if ( SUCCEEDED(hr) )
      {
         // This will only succeed for the Win2k objects.
         bIsCritical = V_BOOL(&var) == -1 ? TRUE : FALSE;
      }
      else
      {
         // This must be a NT4 account. We need to get the SID and check if
         // it's RID belongs to the BUILTIN rids.
         hr = pAds->Get(L"objectSID", &var);
         if ( SUCCEEDED(hr) )
         {
            SAFEARRAY * pArray = V_ARRAY(&var);
            PSID                 pSid;
            hr = SafeArrayAccessData(pArray, (void**)&pSid);
            if ( SUCCEEDED(hr) )
            {
               DWORD * dwCnt = (DWORD *) GetSidSubAuthorityCount(pSid);
               DWORD * rid = (DWORD *) GetSidSubAuthority(pSid, (*dwCnt)-1);
               bIsCritical = BuiltinRid(*rid);
               if ( bIsCritical ) 
               {
                  BSTR           sName;
                  hr = pAds->get_Name(&sName);
                  bIsCritical = CheckBuiltInWithNTApi(pSid, (WCHAR*)sName, pOptions);
               }
               hr = SafeArrayUnaccessData(pArray);
            }
         }
      }
   }

   // Get the class from the object. If it is a container/ou class then it will not have a SAM name so put the CN= or OU= into the list
   hr = pAds->get_Class(&sClass);
   if ( FAILED(hr) ) rc = FALSE;

   if ( rc ) 
   {
      sType = _bstr_t(sClass);
   
      if (UStrICmp((WCHAR*) sType, L"organizationalUnit") == 0)
      {
         hr = pAds->get_Name(&sClass);
         sName = _bstr_t(L"OU=") + _bstr_t(sClass);
         sSam = L"";
         if ( FAILED(hr) ) rc = FALSE;
      }
      else if (UStrICmp((WCHAR*) sType, L"container") == 0)
      {
         hr = pAds->get_Name(&sClass);
         sName = _bstr_t(L"CN=") + _bstr_t(sClass);
         sSam = L"";
         if ( FAILED(hr) ) rc = FALSE;
      }
      else
      {
         hr = pAds->get_Name(&sClass);
         sName = _bstr_t(sClass);

	     //if the name includes a '/', then we have to get the escaped version from the path
	     //due to a bug in W2K.
	     if (wcschr((WCHAR*)sName, L'/'))
		 {
		    _bstr_t sCNName = GetCNFromPath(sPath);
		    if (sCNName.length() != 0)
               sName = sCNName;
		 }

         hr = pAds->Get(L"sAMAccountName", &var);
         if ( FAILED(hr)) rc = FALSE;
         sSam = var;
         if ( UStrICmp((WCHAR*) sType, L"group") == 0)
         {
            // we need to get and set the group type
            pAds->Get(L"groupType", &var);
            if ( SUCCEEDED(hr))
               grpType = V_INT(&var);              
         }
      }
      if ( bIsCritical )
      {
         // Builtin account so we are going to ignore this account. 
         //Don't log this message in IntraForest because we do mess with it
         // Also if it is a Domain Users group we add the migrated objects to it by default.
         if ( !pOptions->bSameForest && _wcsicmp((WCHAR*) sSam, pOptions->sDomUsers))    
         {
            err.MsgWrite(ErrW, DCT_MSG_IGNORING_BUILTIN_S, (WCHAR*)sPath);
            Mark(L"warnings", (WCHAR*) sType);
         }
         rc = FALSE;
      }
   }
   if (pAds) pAds->Release();
   return rc;
}

//-----------------------------------------------------------------------------
// ExpandMembership : This method expands the account list to encorporate the
//                    groups that contain the members in the account list.
//-----------------------------------------------------------------------------
BOOL CAcctRepl::ExpandMembership(
                                 TNodeListSortable *acctlist,     //in- Accounts being processed
                                 Options           *pOptions,     //in- Options specified by the user
                                 TNodeListSortable *pNewAccts,    //out-The newly Added accounts.
                                 ProgressFn        *progress,     //in- Show status
                                 BOOL				bGrpsOnly	  //in- Expand for groups only
								 )
{
   TAcctReplNode           * pAcct;
   HRESULT                   hr = S_OK;
   _variant_t                var;
   WCHAR                     sGrpPath[LEN_Path];
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   DWORD                     dwMaj, dwMin, dwSP;
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk = NULL;
   PSID                      pSid = NULL;
   SID_NAME_USE              use;
   DWORD                     dwNameLen = LEN_Path;
   DWORD                     dwDomName = LEN_Path;
   WCHAR                     sDomUsers[LEN_Path], sDomain[LEN_Path];
   BOOL                      rc = FALSE;
   long                      lgrpType;
   WCHAR                     mesg[LEN_Path];

   pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);

   // Change from a tree to a sorted list
   if ( acctlist->IsTree() ) acctlist->ToSorted();

   // Get the Domain Users group name
   pSid = GetWellKnownSid(DOMAIN_USERS, pOptions,FALSE);
   if ( pSid )
   {
      // since we have the well known SID now we can get its name
      if ( ! LookupAccountSid(pOptions->srcComp, pSid, sDomUsers, &dwNameLen, sDomain, &dwDomName, &use) )
         hr = HRESULT_FROM_WIN32(GetLastError());
      else
         wcscpy(pOptions->sDomUsers, sDomUsers);
      FreeSid(pSid);
   }

   // Check the domain type for the source domain.
   if ( SUCCEEDED(hr) )
      hr = pAccess->raw_GetOsVersion(pOptions->srcComp, &dwMaj, &dwMin, &dwSP);
   
   if ( SUCCEEDED(hr))
   {
      if ( dwMaj < 5 ) 
      {
         // NT4 objects we need to use NT API to get the groups that this account is a member of.

         LPGROUP_USERS_INFO_0            pBuf = NULL;
         DWORD                           dwLevel = 0;
         DWORD                           dwPrefMaxLen = 0xFFFFFFFF;
         DWORD                           dwEntriesRead = 0;
         DWORD                           dwTotalEntries = 0;
         NET_API_STATUS                  nStatus;
         WCHAR                           sGrpName[LEN_Path];
         WCHAR                           sNewGrpName[LEN_Path];
         WCHAR                           sType[LEN_Path];
         BOOL                            bBuiltin;

         for ( pAcct = (TAcctReplNode*)acctlist->Head(); pAcct; pAcct = (TAcctReplNode*)pAcct->Next())
         {
            if ( pOptions->pStatus )
            {
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               {
                  if ( !bAbortMessageWritten ) 
                  {
                     err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                     bAbortMessageWritten = true;
                  }
                  break;
               }
            }

			   //if user
			if (!_wcsicmp(pAcct->GetType(), L"user"))
			{
               //User object
               nStatus = NetUserGetGroups(pOptions->srcComp, pAcct->GetName(), 0, (LPBYTE*)&pBuf, dwPrefMaxLen, &dwEntriesRead, &dwTotalEntries );
               if (nStatus == NERR_Success)
			   {
                  for ( DWORD i = 0; i < dwEntriesRead; i++ )
				  {
                     if ( pOptions->pStatus )
					 {
                        LONG                status = 0;
                        HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                        if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
						{
                           if ( !bAbortMessageWritten ) 
						   {
                              err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                              bAbortMessageWritten = true;
						   }
                           break;
						}
					 }
					    //see if this group was not migrated due to a conflict, if so then
					    //we need to fix up this membership
					 bool		 bInclude = true;
					 Lookup      p;
					 p.pName = sGrpName;
					 p.pType = sType;
                     TAcctReplNode * pFindNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                     if (pFindNode && (pFindNode->WasCreated() || pFindNode->WasReplaced()) && (bGrpsOnly))
					    bInclude = false;

                     bBuiltin = IsBuiltinAccount(pOptions, pBuf[i].grui0_name);
                     // Ignore the Domain users group.
                     if ( (_wcsicmp(pBuf[i].grui0_name, sDomUsers) != 0) && !bBuiltin && bInclude)
					 {
                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_GROUP_ADDING_SS), pAcct->GetName(), pBuf[i].grui0_name);
                        Progress(mesg);
                        // This is the global group type by default
                        wcscpy(sType, L"group");
                        // Get the name of the group and add it to the list if it does not already exist in the list.
                        wcscpy(sGrpName, pBuf[i].grui0_name);

                        TAcctReplNode * pNode = new TAcctReplNode();
					    if (!pNode)
					       return FALSE;
                        // Source name stays as is
                        pNode->SetName(sGrpName);
                        pNode->SetSourceSam(sGrpName);
                        pNode->SetType(sType);
                        pNode->SetGroupType(2);
                        pNode->SetTargetName(sGrpName);
						   //Get the source domain sid from the user
                        pNode->SetSourceSid(pAcct->GetSourceSid());
                        // Look if we have migrated the group
                        hr = pOptions->pDb->raw_GetAMigratedObject(sGrpName, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
                        if ( hr == S_OK )
						{
                           var = pVs->get(L"MigratedObjects.SourceAdsPath");
                           pNode->SetSourcePath(var.bstrVal);
                           //Get the target name and assign that to the node
                           var = pVs->get(L"MigratedObjects.TargetSamName");
                           wcscpy(sNewGrpName, (WCHAR*)V_BSTR(&var));
                           pNode->SetTargetSam(sNewGrpName);
                           // Get the path too
                           var = pVs->get(L"MigratedObjects.TargetAdsPath");
                           wcscpy(sGrpPath, (WCHAR*)V_BSTR(&var));
                           pNode->SetTargetPath(sGrpPath);
                           // Get the type too
                           var = pVs->get(L"MigratedObjects.Type");
                           wcscpy(sType, (WCHAR*)V_BSTR(&var));
                           pNode->SetType(sType);
                     
						      //if they dont want to copy migrated objects, or they do but it was .
                           if (!(pOptions->flags & F_COPY_MIGRATED_ACCT))      
						   {
                              pNode->operations = 0;
                              pNode->operations |= OPS_Process_Members;
                              // Since the account has already been created we should go ahead and mark it created
                              // so that the processing of group membership can continue.
                              pNode->MarkCreated();
						   }
						      //else if already migrated, mark already there so that we fix group membership whether we migrate the group or not
						   else if (bInclude)
						   {
                              if (pOptions->flags & F_REPLACE)
                                 pNode->operations |= OPS_Process_Members;
							  else
                                 pNode->operations = OPS_Create_Account | OPS_Process_Members;
                              pNode->sMemberName = pAcct->GetSourceSam();
                              pNode->sMemberType = pAcct->GetType();
                              pNode->MarkAlreadyThere();
						   }

                           if ( !pOptions->expandMemberOf )
						   {
                              // We need to add the account to the list with the member field set so that we can add the
                              // member to the migrated group
                              pNode->sMemberName = pAcct->GetSourceSam();
                              pNode->sMemberType = pAcct->GetType();
                              pNewAccts->Insert((TNode *) pNode);
						   }
						}
                        else
						{
                           // account has not been previously copied so we will set it up
                           if ( pOptions->expandMemberOf )
						   {
                              TruncateSam(sGrpName, pNode, pOptions, acctlist);
                              pNode->SetTargetSam(sGrpName);
                              FillPathInfo(pNode,pOptions);
                              AddPrefixSuffix(pNode, pOptions);
						   }
                           else
						   {
                              delete pNode;
						   }
						}
                        if ( pOptions->expandMemberOf )
						{
                           if ( ! pNewAccts->InsertIfNew((TNode*) pNode) )
                              delete pNode;
						}
					 }

                     if (bBuiltin)
					 {
                        // BUILTIN account error message
                        err.MsgWrite(ErrW, DCT_MSG_IGNORING_BUILTIN_S, pBuf[i].grui0_name);
                        Mark(L"warnings", pAcct->GetType());
					 }
                  }//end for each group
               }//if got groups
               if (pBuf != NULL)
                  NetApiBufferFree(pBuf);

               // Process local groups
               pBuf = NULL;
               dwLevel = 0;
               dwPrefMaxLen = 0xFFFFFFFF;
               dwEntriesRead = 0;
               dwTotalEntries = 0;
               DWORD dwFlags = 0 ;
               nStatus = NetUserGetLocalGroups(pOptions->srcComp, pAcct->GetName(), 0, dwFlags, (LPBYTE*)&pBuf, dwPrefMaxLen, &dwEntriesRead, &dwTotalEntries );
               if (nStatus == NERR_Success)
			   {
                  for ( DWORD i = 0; i < dwEntriesRead; i++ )
				  {
                     if ( pOptions->pStatus )
					 {
                        LONG                status = 0;
                        HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                        if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
						{
                           if ( !bAbortMessageWritten ) 
						   {
                              err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                              bAbortMessageWritten = true;
						   }
                           break;
						}
					 }
					    //see if this group was not migrated due to a conflict, if so then
					    //we need to fix up this membership
					 bool		 bInclude = true;
					 Lookup      p;
					 p.pName = sGrpName;
					 p.pType = sType;
                     TAcctReplNode * pFindNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                     if (pFindNode && (pFindNode->WasCreated() || pFindNode->WasReplaced()) && (bGrpsOnly))
					    bInclude = false;

                     if (!IsBuiltinAccount(pOptions, pBuf[i].grui0_name))
					 {
                        wcscpy(sType, L"group");
                        // Get the name of the group and add it to the list if it does not already exist in the list.
                        wcscpy(sGrpName, pBuf[i].grui0_name);
                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_GROUP_ADDING_SS), pAcct->GetName(), (WCHAR*) sGrpName);
                        Progress(mesg);
                        TAcctReplNode * pNode = new TAcctReplNode();
					    if (!pNode)
					       return FALSE;
                        pNode->SetName(sGrpName);
                        pNode->SetSourceSam(sGrpName);
                        pNode->SetType(sType);
                        pNode->SetGroupType(4);
                        pNode->SetTargetName(sGrpName);
						   //Get the source domain sid from the user
                        pNode->SetSourceSid(pAcct->GetSourceSid());
                        // Look if we have migrated the group
                        hr = pOptions->pDb->raw_GetAMigratedObject(sGrpName, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
                        if ( hr == S_OK )
						{
                           var = pVs->get(L"MigratedObjects.SourceAdsPath");
                           pNode->SetSourcePath(var.bstrVal);
                           //Get the target name and assign that to the node
                           var = pVs->get(L"MigratedObjects.TargetSamName");
                           wcscpy(sNewGrpName, (WCHAR*)V_BSTR(&var));
                           // Get the path too
                           var = pVs->get(L"MigratedObjects.TargetAdsPath");
                           wcscpy(sGrpPath, (WCHAR*)V_BSTR(&var));
                           pNode->SetTargetPath(sGrpPath);
                           // Get the type too
                           var = pVs->get(L"MigratedObjects.Type");
                           wcscpy(sType, (WCHAR*)V_BSTR(&var));
						      //if they dont want to copy migrated objects, or they do but it was .
                           if (!(pOptions->flags & F_COPY_MIGRATED_ACCT))      
						   {
                              pNode->operations = 0;
                              pNode->operations |= OPS_Process_Members;
                              // Since the account has already been created we should go ahead and mark it created
                              // so that the processing of group membership can continue.
                              pNode->MarkCreated();
						   }
 						      //else if already migrated, mark already there so that we fix group membership whether we migrate the group or not
						   else if (bInclude)
						   {
                              if (pOptions->flags & F_REPLACE)
                                 pNode->operations |= OPS_Process_Members;
							  else
                                 pNode->operations = OPS_Create_Account | OPS_Process_Members;
                              pNode->sMemberName = pAcct->GetSourceSam();
                              pNode->sMemberType = pAcct->GetType();
                              pNode->MarkAlreadyThere();
						   }

                           pNode->SetType(sType);
                           pNode->SetGroupType(4);
                           pNode->SetTargetName(sGrpName);
                           pNode->SetTargetSam(sNewGrpName);
                           if ( !pOptions->expandMemberOf )
						   {
                              // We need to add the account to the list with the member field set so that we can add the
                              // member to the migrated group
                              pNode->sMemberName = pAcct->GetSourceSam();
                              pNode->sMemberType = pAcct->GetType();
                              pNewAccts->Insert((TNode *) pNode);
						   }
						}//if migrated
                        else
						{
                           // account has not been previously copied so we will set it up
                           if ( pOptions->expandMemberOf )
						   {
                              TruncateSam(sGrpName, pNode, pOptions, acctlist);
                              pNode->SetTargetSam(sGrpName);
                              FillPathInfo(pNode,pOptions);
                              AddPrefixSuffix(pNode, pOptions);
						   }
                           else
						   {
                              delete pNode;
						   }
                        }
                        if ( pOptions->expandMemberOf )
						{
                           if ( ! pNewAccts->InsertIfNew((TNode*) pNode) )
						   {
                              delete pNode;
						   }
						}
					 }//end if not built-in
                     else
					 {
                        // BUILTIN account error message
                        err.MsgWrite(ErrW, DCT_MSG_IGNORING_BUILTIN_S, pBuf[i].grui0_name);
                        Mark(L"warnings", pAcct->GetType());
					 }
				  }//for each local group
               }//if any local groups
               if (pBuf != NULL)
                  NetApiBufferFree(pBuf);
			}//end if user and should expand

			   //if group, expand membership of previously migrated groups
			if (!_wcsicmp(pAcct->GetType(), L"group"))
			{
               long			 numGroups = 0, ndx = 0;

				 //fill a varset with all migrated groups
               hr = pOptions->pDb->raw_GetMigratedObjectByType(-1, _bstr_t(L""), _bstr_t(L"group"), &pUnk);
               if ( SUCCEEDED(hr) )
			   {
                     //get the num of objects in the varset
                  numGroups = pVs->get(L"MigratedObjects");

			         //for each group, find local groups and check for account as member
		          for (ndx = 0; ndx < numGroups; ndx++)
				  {
                     _bstr_t          tgtAdsPath = L"";
                     WCHAR            text[MAX_PATH];
					 IADsGroup		* pGrp = NULL;
                     VARIANT_BOOL	  bIsMem = VARIANT_FALSE;
					 _variant_t       var;

					    //check for abort
                     if ( pOptions->pStatus )
					 {
                        LONG                status = 0;
                        HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                        if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
						{
                           if ( !bAbortMessageWritten ) 
						   {
                              err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                              bAbortMessageWritten = true;
						   }
                           break;
						}
					 }

			            //get this group's target ADSPath
                     swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_TargetAdsPath));
                     tgtAdsPath = pVs->get(text);
			         if (!tgtAdsPath.length())
						break;
					 
					    //connect to the target group
					 hr = ADsGetObject(tgtAdsPath, IID_IADsGroup, (void**)&pGrp);
					 if (FAILED(hr))
					    continue;
					    //get this group's type					 
                     hr = pGrp->Get(L"groupType", &var);
					    //if this is a local group, see if this account is a member
                     if ((SUCCEEDED(hr)) && (var.lVal & 4))
					 {
					       //get the source object's sid from the migrate objects table 
						   //(source AdsPath will not work)
						WCHAR  strSid[MAX_PATH];
						WCHAR  strRid[MAX_PATH];
						DWORD  lenStrSid = DIM(strSid);
						GetTextualSid(pAcct->GetSourceSid(), strSid, &lenStrSid);
                        _bstr_t sSrcDmSid = strSid;
                        _ltow((long)(pAcct->GetSourceRid()), strRid, 10);
                        _bstr_t sSrcRid = strRid;
                        if ((!sSrcDmSid.length()) || (!sSrcRid.length()))
						   continue;

						   //build an LDAP path to the src object in the group
						_bstr_t sSrcSid = sSrcDmSid + _bstr_t(L"-") + sSrcRid;
						_bstr_t sSrcLDAPPath = L"LDAP://";
						sSrcLDAPPath += _bstr_t(pOptions->tgtComp + 2);
						sSrcLDAPPath += L"/CN=";
						sSrcLDAPPath += sSrcSid;
						sSrcLDAPPath += L",CN=ForeignSecurityPrincipals,";
						sSrcLDAPPath += pOptions->tgtNamingContext;
						
					       //got the source LDAP path, now see if that account is in the group
                        hr = pGrp->IsMember(sSrcLDAPPath, &bIsMem);
						   //if it is a member, then add this groups to the list
                        if (SUCCEEDED(hr) && bIsMem)
						{
						   _bstr_t sTemp;
							  //create a new node to add to the list
                           swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceSamName));
                           sTemp = pVs->get(text);
                           wsprintf(mesg, GET_STRING(IDS_EXPANDING_GROUP_ADDING_SS), pAcct->GetName(), (WCHAR*)sTemp);
                           Progress(mesg);
                           TAcctReplNode * pNode = new TAcctReplNode();
					       if (!pNode)
					          return FALSE;
                           pNode->SetName(sTemp);
                           pNode->SetSourceSam(sTemp);
                           pNode->SetTargetName(sTemp);
                           pNode->SetGroupType(4);
                           pNode->SetTargetPath(tgtAdsPath);
                           swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_TargetSamName));
                           sTemp = pVs->get(text);
                           pNode->SetTargetSam(sTemp);
                           swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceDomainSid));
                           sTemp = pVs->get(text);
                           pNode->SetSourceSid(SidFromString((WCHAR*)sTemp));
                           swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceAdsPath));
                           sTemp = pVs->get(text);
                           pNode->SetSourcePath(sTemp);
                           swprintf(text,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_Type));
                           sTemp = pVs->get(text);
                           pNode->SetType(sTemp);
                           if ( !(pOptions->flags & F_COPY_MIGRATED_ACCT))
						   {
                              // Since the account already exists we can tell it just to update group memberships
                              pNode->operations = 0;
                              pNode->operations |= OPS_Process_Members;
                              // Since the account has already been created we should go ahead and mark it created
                              // so that the processing of group membership can continue.
                              pNode->MarkCreated();
						   }
                              // We need to add the account to the list with the member field set so that we can add the
                              // member to the migrated group
                           pNode->sMemberName = pAcct->GetSourceSam();
                           pNode->sMemberType = pAcct->GetType();
                           pNewAccts->Insert((TNode *) pNode);
						}//end if local group has as member
					 }//end if local group
					 if (pGrp) 
					    pGrp->Release();
				  }//end for each group
			   }//end if got migrated groups
			}//end if group
         }//for each account in the list
      }//end if NT 4.0 objects
      else
      {
         // Win2k objects so we need to go to active directory and query the memberOf field of each of these objects and update the
         // list.
         IEnumVARIANT            * pEnum;
         INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
         LPWSTR                    sCols[] = { L"memberOf" };
         int                       nCols = DIM(sCols);
         SAFEARRAY               * psaCols;
         SAFEARRAYBOUND            bd = { nCols, 0 };
         BSTR  HUGEP             * pData;
         WCHAR                     sQuery[LEN_Path];
         _variant_t   HUGEP      * pDt, * pVar;
         _variant_t                vx;
         _variant_t                varMain;
         DWORD                     dwf = 0;

         for ( pAcct = (TAcctReplNode*)acctlist->Head(); pAcct; pAcct = (TAcctReplNode*)pAcct->Next())
         {
            if ( pOptions->pStatus )
            {
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               {
                  if ( !bAbortMessageWritten ) 
                  {
                     err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                     bAbortMessageWritten = true;
                  }
                  break;
               }
            }
            // Get the Accounts Primary group. This is not in the memberOf property for some reason.(Per Richard Ault in Firstwave NewsGroup)
            IADs                    * pAds;
            _variant_t                varRid;
            _bstr_t                   sPath;
            _bstr_t                   sSam;
            _bstr_t                   sType;
            _bstr_t                   sName;

            hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADs, (void**)&pAds);
            if ( SUCCEEDED(hr))
            {
               hr = pAds->Get(L"primaryGroupID", &varRid);
               pAds->Release();
            }
         
            if ( SUCCEEDED(hr) )
            {
               WCHAR                  sAcctName[LEN_Path];
               WCHAR                  sDomain[LEN_Path];
               DWORD                  cbName = LEN_Path;
               DWORD                  cbDomain = LEN_Path;
               SID_NAME_USE           sidUse;
               // Get the SID from the RID
               PSID sid = GetWellKnownSid(varRid.lVal, pOptions);
               // Lookup the sAMAccountNAme from the SID
               if ( LookupAccountSid(pOptions->srcComp, sid, sAcctName, &cbName, sDomain, &cbDomain, &sidUse) )
               {
					 //see if this group was not migrated due to a conflict, if so then
					 //we need to fix up this membership
				  bool bInclude = true;
				  Lookup p;
				  p.pName = (WCHAR*)sSam;
				  p.pType = (WCHAR*)sType;
                  TAcctReplNode * pFindNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                  if (pFindNode && (pFindNode->WasCreated() || pFindNode->WasReplaced()) && (bGrpsOnly))
					 bInclude = false;

                  // We have the SAM Account name for the Primary group so lets Fill the node and add it to the list.
                  // Ignore in case of the Domain Users group.
                  if ( varRid.lVal != DOMAIN_GROUP_RID_USERS)
                  {
                     TAcctReplNode * pNode = new TAcctReplNode();
					 if (!pNode)
					    return FALSE;
                     pNode->SetName((WCHAR*)sAcctName);
                     pNode->SetTargetName((WCHAR*) sAcctName);
                     pNode->SetSourceSam((WCHAR*) sAcctName);
                     pNode->SetTargetSam((WCHAR*) sAcctName);
                     pNode->SetType(L"group");
						//Get the source domain sid from the user
                     pNode->SetSourceSid(pAcct->GetSourceSid());
                     AddPrefixSuffix(pNode, pOptions);
                     FillPathInfo(pNode, pOptions);
                     // See if the object is migrated
                     hr = pOptions->pDb->raw_GetAMigratedObject((WCHAR*)sAcctName, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
                     if ( hr == S_OK )
                     {
                        if ((!(pOptions->expandMemberOf) || ((pOptions->expandMemberOf) && ((!(pOptions->flags & F_COPY_MIGRATED_ACCT)) || (bInclude)))) ||
							 (!_wcsicmp(pAcct->GetType(), L"group")))
                        {
                           // Get the target name
                           var = pVs->get(L"MigratedObjects.TargetSamName");
                           sSam = V_BSTR(&var);
                           pNode->SetTargetSam((WCHAR*) sSam);
                           // Also Get the Ads path
                           var = pVs->get(L"MigratedObjects.TargetAdsPath");
                           sPath = V_BSTR(&var);
                           pNode->SetTargetPath((WCHAR*)sPath);
                           // Since the account is already copied we only want it to update its Group memberships
						   if (!(pOptions->flags & F_COPY_MIGRATED_ACCT))
						   {
                              pNode->operations = 0;
                              pNode->operations |= OPS_Process_Members;
                              // Since the account has already been created we should go ahead and mark it created
                              // so that the processing of group membership can continue.
                              pNode->MarkCreated();
						   }
						   else if (bInclude)//else if already migrated, mark already there so that we fix group membership whether we migrate the group or not
						   {
                              if (pOptions->flags & F_REPLACE)
                                 pNode->operations |= OPS_Process_Members;
							  else
                                 pNode->operations = OPS_Create_Account | OPS_Process_Members;
                              pNode->MarkAlreadyThere();
						   }

                           if ((!pOptions->expandMemberOf) || (!_wcsicmp(pAcct->GetType(), L"group")) || (bInclude))
                           {
                              // We need to add the account to the list with the member field set so that we can add the
                              // member to the migrated group
                              pNode->sMemberName = pAcct->GetSourceSam();
                              pNode->sMemberType = pAcct->GetType();
                              pNewAccts->Insert((TNode *) pNode);
                           }
                        }
                     }
                     else if ( !pOptions->expandMemberOf )
                     {
                        delete pNode;
                     }
                     if (( pOptions->expandMemberOf ) && (_wcsicmp(pAcct->GetType(), L"group")))
                     {
                        if ( ! pNewAccts->InsertIfNew(pNode) )
                           delete pNode;
                     }
                  }
               }
               if ( sid )
                  FreeSid(sid);
            }
            // Build query stuff
	        if (!_wcsicmp(pAcct->GetType(), L"user"))
               wsprintf(sQuery, L"(&(sAMAccountName=%s)(objectCategory=Person)(objectClass=user))", pAcct->GetSourceSam());
	        else
               wsprintf(sQuery, L"(&(sAMAccountName=%s)(objectCategory=Group))", pAcct->GetSourceSam());
            psaCols = SafeArrayCreate(VT_BSTR, 1, &bd);
            SafeArrayAccessData(psaCols, (void HUGEP **)&pData);
            for ( int i = 0; i < nCols; i++ )
               pData[i] = SysAllocString(sCols[i]);
            SafeArrayUnaccessData(psaCols);
            // Tell the object to run the query and report back to us
            hr = pQuery->raw_SetQuery(const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions->srcDomain, sQuery, ADS_SCOPE_BASE, TRUE);
            if (FAILED(hr)) return FALSE;
            hr = pQuery->raw_SetColumns(psaCols);
            if (FAILED(hr)) return FALSE;
            hr = pQuery->raw_Execute(&pEnum);
            if (FAILED(hr)) return FALSE;

            while (pEnum->Next(1, &varMain, &dwf) == S_OK)
            {
               if ( pOptions->pStatus )
               {
                  LONG                status = 0;
                  HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                  if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                  {
                     if ( !bAbortMessageWritten ) 
                     {
                        err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                        bAbortMessageWritten = true;
                     }
                     break;
                  }
               }
               SAFEARRAY * vals = V_ARRAY(&varMain);
               // Get the VARIANT Array out
               SafeArrayAccessData(vals, (void HUGEP**) &pDt);
               vx = pDt[0];
               SafeArrayUnaccessData(vals);
               if ( vx.vt == VT_BSTR )
               {
                  _bstr_t sDN = _bstr_t(_bstr_t(vx));
				  if (wcslen((WCHAR*)sDN) == 0)
				     continue;

                  sDN = PadDN(sDN);
                  sPath = _bstr_t(L"LDAP://") + _bstr_t(pOptions->srcDomainDns) + _bstr_t(L"/") + sDN;
                  if ( GetSamFromPath(sPath, sSam, sType, sName, lgrpType, pOptions) && CompareDCPath((WCHAR*)sPath, pAcct->GetSourcePath()))
                  {
					    //see if this group was not migrated due to a conflict, if so then
					    //we need to fix up this membership
					 bool bInclude = true;
					 Lookup p;
					 p.pName = (WCHAR*)sSam;
					 p.pType = (WCHAR*)sType;
                     TAcctReplNode * pFindNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                     if (pFindNode && (pFindNode->WasCreated() || pFindNode->WasReplaced()) && (bGrpsOnly))
					    bInclude = false;

                     // Ignore the Domain users group and group already being migrated
                     if ((_wcsicmp(sSam, sDomUsers) != 0) && (bInclude))
                     {
                        wsprintf(mesg, GET_STRING(IDS_EXPANDING_GROUP_ADDING_SS), pAcct->GetName(), (WCHAR*) sSam);
                        Progress(mesg);
                        TAcctReplNode * pNode = new TAcctReplNode();
					    if (!pNode)
					       return FALSE;
                        pNode->SetName((WCHAR*)sName);
                        pNode->SetTargetName((WCHAR*) sName);
                        pNode->SetType((WCHAR*)sType);
                        pNode->SetSourcePath((WCHAR*)sPath);
                        pNode->SetSourceSam((WCHAR*) sSam);
                        pNode->SetTargetSam((WCHAR*)sSam);
						   //Get the source domain sid from the user
                        pNode->SetSourceSid(pAcct->GetSourceSid());
                        AddPrefixSuffix(pNode, pOptions);
                        pNode->SetGroupType(lgrpType);
                        // See if the object is migrated
                        hr = pOptions->pDb->raw_GetAMigratedObject((WCHAR*)sSam, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
                        if ( hr == S_OK )
                        {
                           if ((!(pOptions->expandMemberOf) || ((pOptions->expandMemberOf) && ((!(pOptions->flags & F_COPY_MIGRATED_ACCT)) || (bInclude)))) ||
							   (!_wcsicmp(pAcct->GetType(), L"group")))
                           {
                              // Get the target name
                              var = pVs->get(L"MigratedObjects.TargetSamName");
                              sSam = V_BSTR(&var);
                              pNode->SetTargetSam((WCHAR*) sSam);
                              // Also Get the Ads path
                              var = pVs->get(L"MigratedObjects.TargetAdsPath");
                              sPath = V_BSTR(&var);
                              pNode->SetTargetPath((WCHAR*)sPath);
                              // Since the account is already copied we only want it to update its Group memberships
							  if (!(pOptions->flags & F_COPY_MIGRATED_ACCT))
							  {
                                 pNode->operations = 0;
                                 pNode->operations |= OPS_Process_Members;
                                 // Since the account has already been created we should go ahead and mark it created
                                 // so that the processing of group membership can continue.
                                 pNode->MarkCreated();
							  }
						      else if (bInclude)//else if already migrated, mark already there so that we fix group membership whether we migrate the group or not
							  {
                                 if (pOptions->flags & F_REPLACE)
                                    pNode->operations |= OPS_Process_Members;
							     else
                                    pNode->operations = OPS_Create_Account | OPS_Process_Members;
                                 pNode->MarkAlreadyThere();
							  }

                              if ((!pOptions->expandMemberOf) || (!_wcsicmp(pAcct->GetType(), L"group")) || (bInclude))
                              {
                                 // We need to add the account to the list with the member field set so that we can add the
                                 // member to the migrated group
                                 pNode->sMemberName = pAcct->GetSourceSam();
                                 pNode->sMemberType = pAcct->GetType();
                                 pNewAccts->Insert((TNode *) pNode);
                              }
                           }
                        }
                        else if ( ! pOptions->expandMemberOf )
                        {
                           // if the user doesn't want to copy the member-ofs, we just add them to update their memberships
                           delete pNode;
                        }
                        
                        if (( pOptions->expandMemberOf ) && (_wcsicmp(pAcct->GetType(), L"group")))
                        {
                           if (! pNewAccts->InsertIfNew(pNode) )
                              delete pNode;
                        }
                     }
                  }
               }
               else if ( vx.vt & VT_ARRAY )
               {
                  // We must have got an Array of multivalued properties
                  // Access the BSTR elements of this variant array
                  SAFEARRAY * multiVals = vx.parray; 
                  SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
                  for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
                  {
                     if ( pOptions->pStatus )
                     {
                        LONG                status = 0;
                        HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
                        if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                        {
                           if ( !bAbortMessageWritten ) 
                           {
                              err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                              bAbortMessageWritten = true;
                           }
                           break;
                        }
                     }
                     WCHAR                      sTemp[LEN_Path];
                     _bstr_t sDN = _bstr_t(V_BSTR(&pVar[dw]));
                     sDN = PadDN(sDN);

                     wsprintf(sTemp, L"LDAP://%s/%s", pOptions->srcDomainDns, (WCHAR*)sDN);
                     sPath = sTemp;
                     if ( GetSamFromPath(sPath, sSam, sType, sName,lgrpType, pOptions)  && CompareDCPath((WCHAR*)sPath, pAcct->GetSourcePath()))
                     {
					       //see if this group was not migrated due to a conflict, if so then
					       //we need to fix up this membership
					    bool bInclude = true;
					    Lookup p;
					    p.pName = (WCHAR*)sSam;
					    p.pType = (WCHAR*)sType;
                        TAcctReplNode * pFindNode = (TAcctReplNode *) acctlist->Find(&TNodeFindAccountName, &p);
                        if (pFindNode && (pFindNode->WasCreated() || pFindNode->WasReplaced()) && (bGrpsOnly))
					       bInclude = false;

                        // Ignore the Domain users group and group already being migrated
                        if ((_wcsicmp(sSam, sDomUsers) != 0) && (bInclude))
                        {
                           wsprintf(mesg, GET_STRING(IDS_EXPANDING_GROUP_ADDING_SS), pAcct->GetName(), (WCHAR*) sSam);
                           Progress(mesg);
                           TAcctReplNode * pNode = new TAcctReplNode();
					       if (!pNode)
					          return FALSE;
                           pNode->SetName((WCHAR*)sName);
                           pNode->SetTargetName((WCHAR*) sName);
                           pNode->SetType((WCHAR*)sType);
                           pNode->SetSourcePath((WCHAR*)sPath);
                           pNode->SetSourceSam((WCHAR*) sSam);
                           pNode->SetTargetSam((WCHAR*) sSam);
						      //Get the source domain sid from the user
                           pNode->SetSourceSid(pAcct->GetSourceSid());
                           AddPrefixSuffix(pNode, pOptions);
                           pNode->SetGroupType(lgrpType);
                           // See if the object is migrated
                           hr = pOptions->pDb->raw_GetAMigratedObject((WCHAR*)sSam, pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
                           if ( hr == S_OK )
                           {
                              if ((!(pOptions->expandMemberOf) || ((pOptions->expandMemberOf) && ((!(pOptions->flags & F_COPY_MIGRATED_ACCT)) || (bInclude)))) ||
							      (!_wcsicmp(pAcct->GetType(), L"group")))
                              {
                                 // Get the target name
                                 var = pVs->get(L"MigratedObjects.TargetSamName");
                                 sSam = V_BSTR(&var);
                                 pNode->SetTargetSam((WCHAR*) sSam);
                                 // Also Get the Ads path
                                 var = pVs->get(L"MigratedObjects.TargetAdsPath");
                                 sPath = V_BSTR(&var);
                                 pNode->SetTargetPath((WCHAR*)sPath);
                                 // Since the account is already copied we only want it to update its Group memberships
							     if (!(pOptions->flags & F_COPY_MIGRATED_ACCT))
								 {
                                    pNode->operations = 0;
                                    pNode->operations |= OPS_Process_Members;
                                    // Since the account has already been created we should go ahead and mark it created
                                    // so that the processing of group membership can continue.
                                    pNode->MarkCreated();
								 }
						         else if (bInclude)//else if already migrated, mark already there so that we fix group membership whether we migrate the group or not
								 {
                                    if (pOptions->flags & F_REPLACE)
                                       pNode->operations |= OPS_Process_Members;
							        else
                                       pNode->operations = OPS_Create_Account | OPS_Process_Members;
                                    pNode->MarkAlreadyThere();
								 }

                                 if ((!pOptions->expandMemberOf) || (!_wcsicmp(pAcct->GetType(), L"group")) || (bInclude))
                                 {
                                    // We need to add the account to the list with the member field set so that we can add the
                                    // member to the migrated group
                                    pNode->sMemberName = pAcct->GetSourceSam();
                                    pNode->sMemberType = pAcct->GetType();
                                    pNewAccts->Insert((TNode *) pNode);
                                    pNode = NULL;
                                 }
                              }
                           }
                           else if ( ! pOptions->expandMemberOf )
                           {
                              // if the user doesn't want to copy the member-ofs, we just add them to update their memberships
                              delete pNode;
                              pNode = NULL;
                           }
                           if (pNode)
                           {
                              if (( pOptions->expandMemberOf ) && (_wcsicmp(pAcct->GetType(), L"group")))
                              {
                                 if (! pNewAccts->InsertIfNew(pNode) )
                                    delete pNode;
                              }
                              else
                              {
                                 delete pNode;
                              }
                           }
                        }
                     }
                  }
                  SafeArrayUnaccessData(multiVals);
               }
            }
            pEnum->Release();
            VariantInit(&vx);
            VariantInit(&varMain);
            SafeArrayDestroy(psaCols);
         }
      }
      rc = TRUE;
   }
   if ( pUnk ) pUnk->Release();
   return rc;
}

HRESULT CAcctRepl::BuildSidPath(
                                 WCHAR const * sPath,    //in- path returned by the enumerator.
                                 WCHAR *       sSidPath, //out-path to the LDAP://<SID=###> object
                                 WCHAR *       sSam,     //out-Sam name of the object
                                 WCHAR *       sDomain,  //out-Domain name where this object resides.
                                 Options *     pOptions, //in- Options
                                 PSID        * ppSid      //out- pointer to the binary SID
                               )
{
   HRESULT                   hr = S_OK;
   IADs                    * pAds = NULL;
   DWORD                     cbName = LEN_Path, cbDomain = LEN_Path;
   PSID                      sid = (PSID) new BYTE[100];
   CLdapConnection           c;
   SID_NAME_USE              use;
   _variant_t                var;
   
   if (!sid)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   // Get the object and get the objectSID
   hr = ADsGetObject(const_cast<WCHAR*>(sPath), IID_IADs, (void**) &pAds);
   if ( SUCCEEDED(hr) )
      hr = pAds->Get(L"objectSid", &var);

   if ( SUCCEEDED(hr) )
   {
      // Make sure the SID we got was in string format
      VariantSidToString(var);
      UStrCpy(sSidPath,L"LDAP://<SID=");
      UStrCpy(sSidPath + UStrLen(sSidPath),var.bstrVal);
      UStrCpy(sSidPath + UStrLen(sSidPath),L">");
   }
   
   if (c.StringToBytes(var.bstrVal, (BYTE*)sid))
   {
      if (!LookupAccountSid(pOptions->srcComp, sid, sSam, &cbName, sDomain, &cbDomain, &use))
         hr = HRESULT_FROM_WIN32(GetLastError());
   }
   else
      hr = HRESULT_FROM_WIN32(GetLastError());

   if ( SUCCEEDED(hr) )
   {
      (*ppSid) = sid;
   }
   else
   {
      delete [] sid;
      (*ppSid) = NULL;
   }
   return hr;
}

BOOL
   CAcctRepl::CanMoveInMixedMode(TAcctReplNode *pAcct,TNodeListSortable * acctlist, Options * pOptions)
{
   HRESULT                         hr = S_OK;
   BOOL                            ret = TRUE;
   IADsGroup                     * pGroup = NULL;
   IADsMembers                   * pMembers = NULL;
   IEnumVARIANT                  * pEnum = NULL;
   IDispatch                     * pDisp = NULL;
   IADs                          * pAds = NULL;
   _bstr_t                         sSam;
   _variant_t                      vSam;
   BSTR                            sClass;
   IVarSetPtr                      pVs(__uuidof(VarSet));
   IUnknown                      * pUnk = NULL;


   pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
   // in case of a global group we need to check if we have/are migrating all the members. If we 
   // are then we can move it and if not then we need to use the parallel group theory.
   if ( pAcct->GetGroupType() & 2 )
   {
      // This is a global group. What we need to do now is to see if we have/will migrate all its members.
      // First enumerate the members.
      hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADsGroup, (void**)&pGroup);

      if ( SUCCEEDED(hr) )
         hr = pGroup->Members(&pMembers);

      if (SUCCEEDED(hr)) 
         hr = pMembers->get__NewEnum((IUnknown**)&pEnum);
      
      if ( SUCCEEDED(hr) )
      {
         _variant_t              var;
         DWORD                   fetch = 0;
         while ( pEnum->Next(1, &var, &fetch) == S_OK )
         {
            // Get the sAMAccount name from the object so we can do the lookups
            pDisp = V_DISPATCH(&var);
            hr = pDisp->QueryInterface(IID_IADs, (void**)&pAds);

            if (SUCCEEDED(hr))
               hr = pAds->Get(L"sAMAccountName", &vSam);

            if (SUCCEEDED(hr))
               hr = pAds->get_Class(&sClass);

            if ( SUCCEEDED(hr))
            {
               sSam = vSam;
               // To see if we will migrate all its members check the account list.
               Lookup                        lup;
               lup.pName = (WCHAR*) sSam;
               lup.pType = (WCHAR*) sClass;

               TAcctReplNode * pNode = (TAcctReplNode*)acctlist->Find(&TNodeFindAccountName, &lup);
               if ( !pNode )     
               {
                  // we are not copying this in this pirticular instance but we might have copied it
                  // in previous instances so we need to check the migrated objects table.
                  hr = pOptions->pDb->raw_GetAMigratedObject(sSam, pOptions->srcDomain, pOptions->tgtDomain, (IUnknown**) &pUnk);
                  if ( hr != S_OK )
                  {
                     // This member has never been copied and it is not in the account list this time so we need to copy this group
                     ret = FALSE;
                     err.MsgWrite(0,DCT_MSG_CANNOT_MOVE_GG_FROM_MIXED_MODE_SS,pAcct->GetSourceSam(),(WCHAR*)sSam);
                     break;      
                  }
               }
            }
         }
         if ( pEnum ) pEnum->Release();
         if ( pAds ) pAds->Release();
         if ( pGroup ) pGroup->Release();
         if ( pMembers ) pMembers->Release();
      }
   }
   else
      // For a local group we always return false because we can not truely move a local group
      ret = TRUE;
      // Local groups can be moved, if all of their members are removed first


   return ret;
}

HRESULT 
   CAcctRepl::CheckClosedSetGroups(
      Options              * pOptions,          // in - options for the migration
      TNodeListSortable    * pAcctList,         // in - list of accounts to migrate
      ProgressFn           * progress,          // in - progress function to display progress messages
      IStatusObj           * pStatus            // in - status object to support cancellation
   )
{
   HRESULT                   hr = S_OK;
   TNodeListEnum             e;
   TAcctReplNode           * pAcct;

   if ( pAcctList->IsTree() ) 
      pAcctList->ToSorted();

   for ( pAcct = (TAcctReplNode*)e.OpenFirst(pAcctList) ; pAcct ; pAcct = (TAcctReplNode*)e.Next() )
   {
      if ( (pAcct->operations & OPS_Create_Account ) == 0 )
         continue;

      if ( !UStrICmp(pAcct->GetType(),L"user") )
      {
         // users, we will always move
         err.MsgWrite(0,DCT_MSG_USER_WILL_BE_MOVED_S,pAcct->GetName());
         pAcct->operations = OPS_Move_Object | OPS_Call_Extensions;
      }
      else if (! UStrICmp(pAcct->GetType(),L"group") )
      {
         if ( CanMoveInMixedMode(pAcct,pAcctList,pOptions) )
         {
            pAcct->operations = OPS_Move_Object | OPS_Call_Extensions;
            err.MsgWrite(0,DCT_MSG_GROUP_WILL_BE_MOVED_S,pAcct->GetName());
         }
      }
      else
      {
         err.MsgWrite(0,DCT_MSG_CANT_MOVE_UNKNOWN_TYPE_SS,pAcct->GetName(), pAcct->GetType());
      }
   }
   e.Close();
   
   pAcctList->SortedToTree();

   return hr;
}

void LoadNecessaryFunctions()
{
   HMODULE hPro = LoadLibrary(L"advapi32.dll");
   if ( hPro )
      ConvertStringSidToSid = (TConvertStringSidToSid)GetProcAddress(hPro, "ConvertStringSidToSidW");
   else
   {
      err.SysMsgWrite(ErrE, GetLastError(), DCT_MSG_LOAD_LIBRARY_FAILED_SD, L"advapi32.dll");
      Mark(L"errors", L"generic");
   }
}
//---------------------------------------------------------------------------------------------------------
// MoveObj2k - This function moves objects within a forest.
//---------------------------------------------------------------------------------------------------------
int CAcctRepl::MoveObj2K( 
                           Options              * pOptions,    //in -Options that we recieved from the user
                           TNodeListSortable    * acctlist,    //in -AcctList of accounts to be copied.
                           ProgressFn           * progress,    //in -Progress Function to display messages
                           IStatusObj           * pStatus      // in -status object to support cancellation
                        )
{
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   IObjPropBuilderPtr  pClass(__uuidof(ObjPropBuilder));
   TNodeListSortable          pMemberOf, pMember;

   LoadNecessaryFunctions();
   FillNamingContext(pOptions);
   // Make sure we are connecting to the DC that has RID Pool Allocator FSMO role.
   GetRidPoolAllocator(pOptions);

   // Since we are in the same forest we need to turn off the AddSidHistory functionality.
   // because it is always going to fail.
   pOptions->flags &= ~F_AddSidHistory;

   BOOL bSrcNative = false;
   BOOL bTgtNative = false;
   HRESULT  hr = S_OK;
   _variant_t                var;
   _bstr_t                   sTargetDomain = pOptions->tgtDomain;
   
   pAccess->raw_IsNativeMode(pOptions->srcDomain, (long*)&bSrcNative);
   pAccess->raw_IsNativeMode(pOptions->tgtDomain, (long*)&bTgtNative);

   IMoverPtr      pMover(__uuidof(Mover));
   TNodeTreeEnum  e;

   // build the source and target DSA names
   WCHAR                sourceDSA[LEN_Path];
   WCHAR                targetDSA[LEN_Path];
   WCHAR                sSubPath[LEN_Path];
   WCHAR                sAdsPath[LEN_Path];
   DWORD				nPathLen = LEN_Path;
   TAcctReplNode      * pAcct = NULL;

   UStrCpy(sourceDSA,pOptions->srcComp);
   UStrCpy(sourceDSA + UStrLen(sourceDSA),L".");
   UStrCpy(sourceDSA + UStrLen(sourceDSA),pOptions->srcDomainDns);

   UStrCpy(targetDSA,pOptions->tgtComp);
   UStrCpy(targetDSA + UStrLen(targetDSA),L".");
   UStrCpy(targetDSA + UStrLen(targetDSA),pOptions->tgtDomainDns);


   err.LogClose();
   // In this call the fourth parameter is the log file name. We are piggy backing this value
   // so that we will not have to change the interface for the IMover object.
   hr = pMover->raw_Connect(sourceDSA, targetDSA, pOptions->authDomain, 
      pOptions->authUser, pOptions->authPassword, pOptions->logFile, L"", L"");

   err.LogOpen(pOptions->logFile, 1);
   if ( SUCCEEDED(hr) )
   {
      // make sure the target OU Path is in the proper format
      wcscpy(sSubPath, pOptions->tgtOUPath);
   
      if ( !wcsncmp(L"LDAP://", sSubPath, 7) )
         StuffComputerNameinLdapPath(sAdsPath, nPathLen, sSubPath, pOptions);
      else
         MakeFullyQualifiedAdsPath(sAdsPath, nPathLen, sSubPath, pOptions->tgtComp, pOptions->tgtNamingContext);

      // make sure the account list is in the proper format
      if (acctlist->IsTree()) acctlist->ToSorted();
      acctlist->CompareSet(&TNodeCompareAccountType);

      // sort the account list by Source Type\Source Name
      if ( acctlist->IsTree() ) acctlist->ToSorted();
      acctlist->CompareSet(&TNodeCompareAccountType);

      acctlist->SortedToScrambledTree();
      acctlist->Sort(&TNodeCompareAccountType);
      acctlist->Balance();

      pMemberOf.CompareSet(&TNodeCompareMember);
      pMember.CompareSet(&TNodeCompareMember);

      /* The account list is sorted in descending order by type, then in ascending order by object name
      this means that the user accounts will be moved first.
      Here are the steps we will perform for native mode MoveObject.
      1.  For each object to be copied, Remove (and record) the group memberships
      2.    If the object is a group, convert it to universal (to avoid having to remove any members that are not 
            being migrated.
      3.    Move the object.
      
      4.  For each migrated group that was converted to a universal group, change it back to its original 
          type, if possible.
      5.  Restore the group memberships for all objects.
      
      Here are the steps we will perform for mixed mode MoveObject
      1.  If closed set is not achieved, copy the groups, rather than moving them
      2.  For each object to be copied, Remove (and record) the group memberships
      3.    If the object is a group, remove all of its members
      4.    Move the object.
      
      5.  For each migrated group try to add all of its members back 
      6.  Restore the group memberships for all objects.
      */

      if ( ! bSrcNative )
      {
         CheckClosedSetGroups(pOptions,acctlist,progress,pStatus);   
         // this will copy any groups that cannot be moved from the source domain
         // if groups are copied in this fashion, SIDHistory cannot be used, and reACLing must be performed
         CopyObj2K(pOptions,acctlist,progress,pStatus);
      }

      // This is the start of the Move loop
      try { 
      for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist); 
                            pAcct; 
                            pAcct = (TAcctReplNode *)e.Next() )
      {
          
         if ( m_pExt )
         {
            if ( pAcct->operations & OPS_Call_Extensions )
            {
               m_pExt->Process(pAcct,sTargetDomain,pOptions,TRUE);
            }
         }
         // Do we need to abort ?
         if ( pStatus )
         {
            LONG                status = 0;
            HRESULT             hr = pStatus->get_Status(&status);
         
            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
            {
               if ( !bAbortMessageWritten ) 
               {
                  err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                  bAbortMessageWritten = true;
               }
               break;
            }
         }

         // in the mixed-mode case, skip any accounts that we've already copied
         if ( ! bSrcNative && ((pAcct->operations & OPS_Move_Object)==0 ) )
             continue;

         if ( bSrcNative && 
               ( (pAcct->operations & OPS_Create_Account)==0 ) 
            )
            continue;

	     //if the UPN name conflicted, then the UPNUpdate extension set the hr to
	     //ERROR_OBJECT_ALREADY_EXISTS.  If so, set flag for "no change" mode
	     if (pAcct->GetHr() == ERROR_OBJECT_ALREADY_EXISTS)
		 {
	        pAcct->bUPNConflicted = TRUE;
		    pAcct->SetHr(S_OK);
		 }

	     Mark(L"processed", pAcct->GetType());
         
         WCHAR                  mesg[LEN_Path] = L"";
         if ( progress )
            progress(mesg);

         if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
         {
            // First, record the group type, so we can change it back later if needed
            IADsGroup * pGroup = NULL;
            VARIANT     var;

            VariantInit(&var);

            // get the group type
            hr = ADsGetObject( const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADsGroup, (void**) &pGroup);
            if (SUCCEEDED(hr) )
            {
               hr = pGroup->Get(L"groupType", &var);
               pGroup->Release();
            }
            if ( SUCCEEDED(hr) ) 
            {
               pAcct->SetGroupType(var.lVal);
            }
            else
            {
               pAcct->SetGroupType(0);
            }
                 // make sure it is native and group is a global group
            if ( bSrcNative && bTgtNative )
            {
               if ( pAcct->GetGroupType() & 2) 
               {
                  // We are going to convert the group type to universal groups so we can easily move them
                  
                  WCHAR                  mesg[LEN_Path];
                  wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_CHANGE_GROUP_TYPE_S), pAcct->GetName());
                  Progress(mesg);
                  // Convert global groups to universal, so we can move them without de-populating
                  if ( ! pOptions->nochange )
                  {
                     WCHAR sPath[LEN_Path];
					 DWORD nPathLen = LEN_Path;
                     StuffComputerNameinLdapPath(sPath, nPathLen, const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions, FALSE);
                     hr = pClass->raw_ChangeGroupType(sPath, 8);
                  }
                  else
                  {
                     hr = S_OK;
                  }
                  if (FAILED(hr)) 
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_FAILED_TO_CONVERT_GROUP_TO_UNIVERSAL_SD, pAcct->GetSourceSam(), hr);
                     pAcct->MarkError();
                     Mark(L"errors", pAcct->GetType());
                     continue; // skip any further processing of this group.  
                  }
               }
               else  if ( ! ( pAcct->GetGroupType() & 8 ) ) // don't need to depopulate universal groups
               {
                  // For local groups we are going to depopulate the group and move it and then repopulate it.
                  // In mixed mode, there are no universal groups, so we must depopulate all of the groups
                  // before we can move them out to the new domain. We will RecordAndRemove members of all Group type
                  // move them to the target domain and then change their type to Universal and then add all of its 
                  // members back to it.
                  
                  WCHAR                  mesg[LEN_Path];
                  wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBER_S), pAcct->GetName());
                  Progress(mesg);
                  RecordAndRemoveMember(pOptions, pAcct, &pMember);
               }
         
            }
            else
            {
               // for mixed mode source domain, we must depopulate all of the groups
                WCHAR                  mesg[LEN_Path];
                wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBER_S), pAcct->GetName());
                if ( progress )
                  progress(mesg);
               RecordAndRemoveMember(pOptions, pAcct, &pMember);
            }
            
         }

         // We need to remove this object from any global groups so that it can be moved.
         if ( ! pOptions->nochange )
         {
            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBEROF_S), pAcct->GetName());
            Progress(mesg);
            RecordAndRemoveMemberOf( pOptions, pAcct, &pMemberOf );
         }

         BOOL bObjectExists = DoesTargetObjectAlreadyExist(pAcct, pOptions);

         if ( bObjectExists )
         {
            // The object exists, see if we need to rename
            if ( wcslen(pOptions->prefix) > 0 )
            {
               // Add a prefix to the account name
               WCHAR               tgt[LEN_Path];
               WCHAR               pref[LEN_Path], suf[LEN_Path];
               WCHAR               sTempSam[LEN_Path];
               _variant_t          varStr;

               
               // find the '=' sign
               wcscpy(tgt, pAcct->GetTargetName());
               for ( DWORD z = 0; z < wcslen(tgt); z++ )
               {
                  if ( tgt[z] == L'=' ) break;
               }
            
               if ( z < wcslen(tgt) )
               {
                  // Get the prefix part ex.CN=
                  wcsncpy(pref, tgt, z+1);
                  pref[z+1] = 0;
                  wcscpy(suf, tgt+z+1);
               }

               // Build the target string with the Prefix
               wsprintf(tgt, L"%s%s%s", pref, pOptions->prefix, suf);
               pAcct->SetTargetName(tgt);

               // truncate to allow prefix/suffix to fit in 20 characters.
               int resLen = wcslen(pOptions->prefix) + wcslen(pAcct->GetTargetSam());
               if ( !_wcsicmp(pAcct->GetType(), L"computer") )
               {
                  // Computer name can be only 15 characters long + $
                  if ( resLen > 16 )
                  {
                     WCHAR       sTruncatedSam[LEN_Path];
                     wcscpy(sTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        sTruncatedSam[wcslen(sTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }
                     int truncate = 16 - wcslen(pOptions->prefix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 1 ) truncate = 1;
                     wcsncpy(sTempSam, sTruncatedSam, truncate - 1);
                     sTempSam[truncate - 1] = L'\0';
                     wcscat(sTempSam, pOptions->globalSuffix);
                     wcscat(sTempSam, L"$");
                  }
                  else
                     wcscpy(sTempSam, pAcct->GetTargetSam());

                  // Add the prefix
                  wsprintf(tgt, L"%s%s", pOptions->prefix,sTempSam);
               }
               else if ( !_wcsicmp(pAcct->GetType(), L"group") )
               {
                  if ( resLen > 64 )
                  {
                     int truncate = 64 - wcslen(pOptions->prefix);
                     if ( truncate < 0 ) truncate = 0;
                     wcsncpy(sTempSam, pAcct->GetTargetSam(), truncate);
                     sTempSam[truncate] = L'\0';
                  }
                  else
                     wcscpy(sTempSam, pAcct->GetTargetSam());

                  // Add the prefix
                  wsprintf(tgt, L"%s%s", pOptions->prefix,sTempSam);
               }
               else
               {
                  if ( resLen > 20 )
                  {
                     WCHAR       sTruncatedSam[LEN_Path];
                     wcscpy(sTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        sTruncatedSam[wcslen(sTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }
                     int truncate = 20 - wcslen(pOptions->prefix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 0 ) truncate = 0;
                     wcsncpy(sTempSam, sTruncatedSam, truncate);
                     sTempSam[truncate] = L'\0';
                     wcscat(sTempSam, pOptions->globalSuffix);
                  }
                  else
                     wcscpy(sTempSam, pAcct->GetTargetSam());

                  // Add the prefix
                  wsprintf(tgt, L"%s%s", pOptions->prefix,sTempSam);
               }
               StripSamName(tgt);
//               TruncateSam(tgt,pAcct,pOptions,acctlist);
               pAcct->SetTargetSam(tgt);
               if ( DoesTargetObjectAlreadyExist(pAcct, pOptions) )
               {
                  // Double collision lets log a message and forget about this account
    		         pAcct->MarkAlreadyThere();
                  err.MsgWrite(ErrE, DCT_MSG_PREF_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                  Mark(L"errors",pAcct->GetType());
                  continue;
               }
            }
			   else if ( wcslen(pOptions->suffix) > 0 )
			   {
               // Add a suffix to the account name
               WCHAR               tgt[LEN_Path];
               WCHAR               sTempSam[LEN_Path];
               
               wsprintf(tgt, L"%s%s", pAcct->GetTargetName(), pOptions->suffix);
               pAcct->SetTargetName(tgt);
               //Update the sam account name
               // truncate to allow prefix/suffix to fit in valid length
               int resLen = wcslen(pOptions->suffix) + wcslen(pAcct->GetTargetSam());
               if ( !_wcsicmp(pAcct->GetType(), L"computer") )
               {
                  // Computer name can be only 15 characters long + $
                  if ( resLen > 16 )
                  {
                     WCHAR       sTruncatedSam[LEN_Path];
                     wcscpy(sTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        sTruncatedSam[wcslen(sTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }
                     int truncate = 16 - wcslen(pOptions->suffix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 1 ) truncate = 1;
                     wcsncpy(sTempSam, sTruncatedSam, truncate - 1);
                     sTempSam[truncate - 1] = L'\0';
                     wcscat(sTempSam, pOptions->globalSuffix);
                     wcscat(sTempSam, L"$");
                  }
                  else
                     wcscpy(sTempSam, pAcct->GetTargetSam());

                  // Add the suffix taking into account the $ sign
                  if ( sTempSam[wcslen(sTempSam) - 1] == L'$' )
                     sTempSam[wcslen(sTempSam) - 1] = L'\0';
                  wsprintf(tgt, L"%s%s$", sTempSam, pOptions->suffix);
               }
               else if ( !_wcsicmp(pAcct->GetType(), L"group") )
               {
                  if ( resLen > 64 )
                  {
                     int truncate = 64 - wcslen(pOptions->suffix);
                     if ( truncate < 0 ) truncate = 0;
                     wcsncpy(sTempSam, pAcct->GetTargetSam(), truncate);
                     sTempSam[truncate] = L'\0';
                  }
                  else
                     wcscpy(sTempSam, pAcct->GetTargetSam());

                  // Add the suffix.
                  wsprintf(tgt, L"%s%s", sTempSam, pOptions->suffix);
               }
               else
               {
                  if ( resLen > 20 )
                  {
                     WCHAR       sTruncatedSam[LEN_Path];
                     wcscpy(sTruncatedSam, pAcct->GetTargetSam());
                     if ( wcslen( pOptions->globalSuffix ) )
                     {
                        // We must remove the global suffix if we had one.
                        sTruncatedSam[wcslen(sTruncatedSam) - wcslen(pOptions->globalSuffix)] = L'\0';
                     }
                     int truncate = 20 - wcslen(pOptions->suffix) - wcslen(pOptions->globalSuffix);
                     if ( truncate < 0 ) truncate = 0;
                     wcsncpy(sTempSam, sTruncatedSam, truncate);
                     sTempSam[truncate] = L'\0';
                     wcscat(sTempSam, pOptions->globalSuffix);
                  }
                  else
                     wcscpy(sTempSam, pAcct->GetTargetSam());

                  // Add the suffix.
                  wsprintf(tgt, L"%s%s", sTempSam, pOptions->suffix);
               }
               StripSamName(tgt);
//               TruncateSam(tgt,pAcct,pOptions,acctlist);
               pAcct->SetTargetSam(tgt);
               if ( DoesTargetObjectAlreadyExist(pAcct, pOptions) )
               {
                  // Double collision lets log a message and forget about this account
    		         pAcct->MarkAlreadyThere();
                  err.MsgWrite(ErrE, DCT_MSG_PREF_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
                  Mark(L"errors",pAcct->GetType());
                  continue;
               }
            }
            else
            {
               // if the skip existing option is specified, and the object exists in the target domain,
               // we just skip it
               err.MsgWrite(0, DCT_MSG_ACCOUNT_EXISTS_S, pAcct->GetTargetSam());
               continue;
            }
         }

         // If a prefix/suffix is added to the target sam name then we need to rename the account.
         // on the source domain and then move it to the target domain.
         if ( bObjectExists || (_wcsicmp(pAcct->GetSourceSam(), pAcct->GetTargetSam()) && !pOptions->bUndo ))
         {
            // we need to rename the account to the target SAM name before we try to move it
            // Get an ADs pointer to the account
            IADs        * pADs = NULL;

            WCHAR               sPaths[LEN_Path];
			DWORD				nPathLen = LEN_Path;

            StuffComputerNameinLdapPath(sPaths, nPathLen, const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions, FALSE);
            hr = ADsGetObject(sPaths,IID_IADs,(void**)&pADs);
            if ( SUCCEEDED(hr) )
            {
               hr = pADs->Put(SysAllocString(L"sAMAccountName"),_variant_t(pAcct->GetTargetSam()));
               if ( SUCCEEDED(hr) && !pOptions->nochange )
               {
                  hr = pADs->SetInfo();
                  if ( SUCCEEDED(hr) )
                     err.MsgWrite(0,DCT_MSG_ACCOUNT_RENAMED_SS,pAcct->GetSourceSam(),pAcct->GetTargetSam());
               }
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_RENAME_FAILED_SSD,pAcct->GetSourceSam(),pAcct->GetTargetSam(), hr);
                  Mark(L"errors",pAcct->GetType());
               }
               pADs->Release();
            }
         }

		 WCHAR  sName[MAX_PATH];
         DWORD  cbDomain = MAX_PATH, cbSid = MAX_PATH;
         PSID   pSrcSid = new BYTE[MAX_PATH];
         WCHAR  sDomain[MAX_PATH];
         SID_NAME_USE  use;

		 if (!pSrcSid)
		    return ERROR_NOT_ENOUGH_MEMORY;

         // Get the source account's rid
         wsprintf(sName, L"%s\\%s", pOptions->srcDomain, pAcct->GetSourceSam());
         if (LookupAccountName(pOptions->srcComp, sName, pSrcSid, &cbSid, sDomain, &cbDomain, &use))
		 {
			pAcct->SetSourceSid(pSrcSid);
		 }

         // Now we move it
         hr = MoveObject( pAcct, pOptions, pMover );

         // don't bother with this in nochange mode
         if ( pOptions->nochange )
         {
            // we haven't modified the accounts in any way, so nothing else needs to be done for nochange mode
            continue;
         }
         // Now, we have attempted to move the object - we need to put back the memberships

         // UNDO -- 
         if ( _wcsicmp(pAcct->GetSourceSam(), pAcct->GetTargetSam()) &&  pAcct->WasReplaced() && pOptions->bUndo )
         {
            // Since we undid a prior migration that renamed the account we need
            // to rename the account back to its original name.
            // Get an ADs pointer to the account
            IADs        * pADs = NULL;

            WCHAR               sPaths[LEN_Path];
			DWORD				nPathLen = LEN_Path;

            StuffComputerNameinLdapPath(sPaths, nPathLen, const_cast<WCHAR*>(pAcct->GetTargetPath()), pOptions, TRUE);
            hr = ADsGetObject(sPaths,IID_IADs,(void**)&pADs);
            if ( SUCCEEDED(hr) )
            {
               hr = pADs->Put(SysAllocString(L"sAMAccountName"),_variant_t(pAcct->GetTargetSam()));
               if ( SUCCEEDED(hr) && !pOptions->nochange )
               {
                  hr = pADs->SetInfo();
                  if ( SUCCEEDED(hr) )
                     err.MsgWrite(0,DCT_MSG_ACCOUNT_RENAMED_SS,pAcct->GetSourceSam(),pAcct->GetTargetSam());
               }
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_RENAME_FAILED_SSD,pAcct->GetSourceSam(),pAcct->GetTargetSam(), hr);
                  Mark(L"errors",pAcct->GetType());
               }
               pADs->Release();
            }
         }
         // -- UNDO

         // FAILED Move ----
         if ( (bObjectExists || _wcsicmp(pAcct->GetSourceSam(), pAcct->GetTargetSam())) && ! pAcct->WasReplaced() )
         {
            // if we changed the SAM account name, and the move still failed, we need to change it back now
            IADs        * pADs = NULL;

            WCHAR               sPaths[LEN_Path];
			DWORD				nPathLen = LEN_Path;

            StuffComputerNameinLdapPath(sPaths, nPathLen, const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions, FALSE);
            hr = ADsGetObject(sPaths,IID_IADs,(void**)&pADs);
            if ( SUCCEEDED(hr) )
            {
               hr = pADs->Put(SysAllocString(L"sAMAccountName"),_variant_t(pAcct->GetSourceSam()));
               if ( SUCCEEDED(hr) )
               {
                  hr = pADs->SetInfo();
                  if ( SUCCEEDED(hr) )
                     err.MsgWrite(0,DCT_MSG_ACCOUNT_RENAMED_SS,pAcct->GetTargetSam(),pAcct->GetSourceSam());
               }
               if ( FAILED(hr) )
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_RENAME_FAILED_SSD,pAcct->GetTargetSam(),pAcct->GetSourceSam(), hr);
                  Mark(L"errors",pAcct->GetType());
               }
               pADs->Release();
            }
         }// --- Failed Move
      } // end of Move-Loop
      e.Close();    
      }
      catch ( ... )
      {
         err.MsgWrite(ErrE,DCT_MSG_MOVE_EXCEPTION);
         Mark(L"errors", L"generic");
      }
      
      try { // if we've moved any of the members, update the member records to use the target names
         WCHAR                  mesg[LEN_Path];
         wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_UPDATE_MEMBER_LIST_S));
         Progress(mesg);
         UpdateMemberList(&pMember,acctlist);
         UpdateMemberList(&pMemberOf,acctlist);
      }
      catch (... )
      {
         err.MsgWrite(ErrE,DCT_MSG_RESET_MEMBER_EXCEPTION);
         Mark(L"errors", L"generic");
      }
      
      for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist); 
                            pAcct; 
                            pAcct = (TAcctReplNode *)e.Next() )
      {
         if ( m_pExt && !pOptions->nochange )
         {
            if ( pAcct->WasReplaced() && (pAcct->operations & OPS_Call_Extensions) )
            {
               m_pExt->Process(pAcct,sTargetDomain,pOptions,FALSE);
            }
         }
            //translate the roaming profile if requested 
	     if ( pOptions->flags & F_TranslateProfiles && (_wcsicmp(pAcct->GetType(), L"user") == 0))
		 {
            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, GET_STRING(IDS_TRANSLATE_ROAMING_PROFILE_S), pAcct->GetName());
            if ( progress )
               progress(mesg);

		    WCHAR  tgtProfilePath[MAX_PATH];

            GetBkupRstrPriv((WCHAR*)NULL);
            GetPrivilege((WCHAR*)NULL,SE_SECURITY_NAME);
            if ( wcslen(pAcct->GetSourceProfile()) > 0 )
			{
			   DWORD ret = TranslateRemoteProfile(pAcct->GetSourceProfile(), 
								                  tgtProfilePath,
								                  pAcct->GetSourceSam(),
								                  pAcct->GetTargetSam(),
								                  pOptions->srcDomain,
								                  pOptions->tgtDomain,
											      pOptions->pDb,
											      pOptions->lActionID,
											      pAcct->GetSourceSid(),
                                                  pOptions->nochange);
			}
		 }
      }
      e.Close();

      for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist); 
             pAcct; 
             pAcct = (TAcctReplNode *)e.Next() )
      {
         try 
         { 
            if (bSrcNative && bTgtNative)
            {
               if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
               {
                  WCHAR                  mesg[LEN_Path];
                  wsprintf(mesg, GET_STRING(IDS_UPDATING_GROUP_MEMBERSHIPS_S), pAcct->GetName());
                  if ( progress )
                    progress(mesg);
                  if ( pAcct->GetGroupType() & 4 )
                  {
                     WCHAR                  mesg[LEN_Path];
                     wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RESET_GROUP_MEMBERS_S), pAcct->GetName());
                     Progress(mesg);
                     ResetGroupsMembers(pOptions, pAcct, &pMember, pOptions->pDb);
                  }
                  else
                  {
                     // we need to update the members of these Universal/Global groups to 
                     // point members to the target domain if those members have been migrated
                     // in previous runs.
                     ResetMembersForUnivGlobGroups(pOptions, pAcct);
                  }
               }
            }
            else
            {      
               if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
               {
                  WCHAR                  mesg[LEN_Path];
                  wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RESET_GROUP_MEMBERS_S), pAcct->GetName());
                  if ( progress )
                    progress(mesg);
                  ResetGroupsMembers(pOptions, pAcct, &pMember, pOptions->pDb);
               }
            }
         }
         catch (... )
         { 
            err.MsgWrite(ErrE,DCT_MSG_GROUP_MEMBERSHIPS_EXCEPTION);
            Mark(L"errors", pAcct->GetType());
         }
      }

      bool bChangedAny = true;   // Have to go through it atleast once.
      while ( bChangedAny )
      {
         bChangedAny = false;
         for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist); 
                pAcct; 
                pAcct = (TAcctReplNode *)e.Next() )
         {
             if ( pOptions->nochange )
                continue;

             if ( bSrcNative && bTgtNative )
             {
               // We have changed the migrated global groups to universal groups
               // now we need to change them back to their original types, if possible
               if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
               {
                  if ( pAcct->GetGroupType() & 2 )
                  {
                     if ( pAcct->bChangedType )
                        continue;

                     // attempt to change it back to its original type
                     if ( pAcct->WasReplaced() )
                     {
                        // the account was moved, use the target name
                        hr = pClass->raw_ChangeGroupType(const_cast<WCHAR*>(pAcct->GetTargetPath()), pAcct->GetGroupType());
                     }
                     else
                     {
                        // we failed to move the account, use the source name
                        hr = pClass->raw_ChangeGroupType(const_cast<WCHAR*>(pAcct->GetSourcePath()), pAcct->GetGroupType());
                     }
                     pAcct->SetHr(hr);

                     if ( SUCCEEDED(hr) )
                     {
                        pAcct->bChangedType = true;
                        bChangedAny = true;
                     }
                  }
               }
            }
            else
            {
               // for mixed->native mode migration we can change the group type and add all the members back
               if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
               {
                  if ( !(pAcct->GetGroupType() & 4) && !pAcct->bChangedType )
                  {
                     if ( pAcct->WasReplaced() )
                     {
                        hr = pClass->raw_ChangeGroupType(const_cast<WCHAR*>(pAcct->GetTargetPath()), pAcct->GetGroupType());
                     }
                     else
                     {
                        hr = pClass->raw_ChangeGroupType(const_cast<WCHAR*>(pAcct->GetSourcePath()), pAcct->GetGroupType());
                     }
                     pAcct->SetHr(hr);

                     if ( SUCCEEDED(hr) )
                     {
                        pAcct->bChangedType = true;
                        bChangedAny = true;
                     }
                  }
               } // if group
            }  // Native/Mixed
         }     //for
      } 

      // Log a message for all the groups that we were not able to change back to original type
      for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist); 
             pAcct; 
             pAcct = (TAcctReplNode *)e.Next() )
      {
          if ( pOptions->nochange )
             continue;
          if ( bSrcNative && bTgtNative )
          {
            // We have changed the migrated global groups to universal groups
            // now we need to change them back to their original types, if possible
            if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
            {
               if ( pAcct->GetGroupType() & 2 )
               {
                  if (FAILED(pAcct->GetHr())) 
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_GROUP_CHANGETYPE_FAILED_SD, pAcct->GetTargetPath(), hr);
                     Mark(L"errors", pAcct->GetType());
                  }
               }
            }
         }
         else
         {
            // for mixed->native mode migration we can change the group type and add all the members back
            if ( _wcsicmp(pAcct->GetType(), L"group") == 0 || _wcsicmp(pAcct->GetType(), L"lgroup") == 0 )
            {
               if ( !(pAcct->GetGroupType() & 4) )
               {
                  if (FAILED(pAcct->GetHr())) 
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_GROUP_CHANGETYPE_FAILED_SD, pAcct->GetTargetPath(), hr);
                     Mark(L"errors", pAcct->GetType());
                  }
               }
            } // if group
         }  // Native/Mixed
      }     //for
      
      WCHAR                  mesg[LEN_Path];
      wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RESET_MEMBERSHIP_S));
      Progress(mesg);
      ResetObjectsMembership( pOptions,&pMemberOf, pOptions->pDb );
   }
   else
   {
      // Connection failed.
      err.SysMsgWrite(ErrE,hr,DCT_MSG_MOVEOBJECT_CONNECT_FAILED_D,hr);
      Mark(L"errors", ((TAcctReplNode*)acctlist->Head())->GetType());
   }
   if ( progress )
      progress(L"");
   pMover->Close();
   return 0;
}


//---------------------------------------------------------------------------------------------------------
// MoveObject - This method does the actual move on the object calling the Mover object.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::MoveObject( 
                               TAcctReplNode * pAcct,
                               Options * pOptions,
                               IMoverPtr pMover
                             )
{
   HRESULT                   hr = S_OK;
   WCHAR                     sourcePath[LEN_Path];
   WCHAR                     targetPath[LEN_Path];
   DWORD				     nPathLen = LEN_Path;
   WCHAR                   * pRelativeTgtOUPath = NULL;

   safecopy(sourcePath,pAcct->GetSourcePath());

   WCHAR                  mesg[LEN_Path];
   wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_MOVING_S), pAcct->GetName());
   Progress(mesg); 

   if ( ! pOptions->bUndo )
   {
      MakeFullyQualifiedAdsPath(targetPath, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
   }
   else
   {
      swprintf(targetPath,L"LDAP://%ls/%ls",pOptions->tgtDomain,pOptions->tgtOUPath);
   }
		//make sourcePath and targetPath all lowercase to avoid a W2K bug in ntdsa.dll
   _wcslwr(targetPath);
   _wcslwr(sourcePath);
	    //due to lowercase force above, we have to replace "ldap://" with "LDAP://" in
		//order for subsequent ADsGetObjects calls to succeed
   if ( !_wcsnicmp(L"LDAP://", targetPath, 7) )
   {
      WCHAR  aNewPath[LEN_Path] = L"LDAP";
      UStrCpy(aNewPath+UStrLen(aNewPath), targetPath+UStrLen(aNewPath));
      wcscpy(targetPath, aNewPath);
   }
   if ( !_wcsnicmp(L"LDAP://", sourcePath, 7) )
   {
      WCHAR  aNewPath[LEN_Path] = L"LDAP";
      UStrCpy(aNewPath+UStrLen(aNewPath), sourcePath+UStrLen(aNewPath));
      wcscpy(sourcePath, aNewPath);
   }

   WCHAR                     sTargetRDN[LEN_Path];
   wcscpy(sTargetRDN, pAcct->GetTargetName());
   WCHAR                   * pTemp = NULL;
   pTemp = wcsstr(sTargetRDN, L"CN=");
   if ( pTemp != sTargetRDN )
   {
      wsprintf(sTargetRDN, L"CN=%s", pAcct->GetTargetName());
      pAcct->SetTargetName(sTargetRDN);
   }

   if ( ! pOptions->nochange )
   {
      hr = pMover->raw_MoveObject(sourcePath,sTargetRDN,targetPath);
	     //if the Move operation failed due to a W2K bug for CNs which
	     //include a '/', un-escape the '/' and try again
	  if ((hr == E_INVALIDARG) && (wcschr(sTargetRDN, L'/')))
	  {
		 _bstr_t strName = GetUnEscapedNameWithFwdSlash(_bstr_t(sTargetRDN)); //remove any escape characters added
         hr = pMover->raw_MoveObject(sourcePath,(WCHAR*)strName,targetPath);
	  }
   }
   else
   {
      hr = pMover->raw_CheckMove(sourcePath,sTargetRDN,targetPath);
	     //if the Check Move operation failed due to a W2K bug for CNs which
	     //include a '/', un-escape the '/' and try again
	  if ((hr == E_INVALIDARG) && (wcschr(sTargetRDN, L'/')))
	  {
		 _bstr_t strName = GetUnEscapedNameWithFwdSlash(_bstr_t(sTargetRDN)); //remove any escape characters added
         hr = pMover->raw_CheckMove(sourcePath,(WCHAR*)strName,targetPath);
	  }
      if ( HRESULT_CODE(hr) == ERROR_DS_CANT_MOVE_ACCOUNT_GROUP 
         || HRESULT_CODE(hr) == ERROR_DS_CANT_MOVE_RESOURCE_GROUP
         || HRESULT_CODE(hr) == ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS
         || HRESULT_CODE(hr) == ERROR_USER_EXISTS )
      {
         hr = 0;
      }
   }
   if ( SUCCEEDED(hr) )
   {
      WCHAR                 path[LEN_Path];
	  DWORD				    nPathLen = LEN_Path;

      pAcct->MarkReplaced();
      Mark(L"created", pAcct->GetType());   
      // set the target path 
      UStrCpy(path,pAcct->GetTargetName());
      if ( *pOptions->tgtOUPath )
      {
         wcscat(path, L",");
         wcscat(path, pOptions->tgtOUPath);
      }
      pRelativeTgtOUPath = wcschr(targetPath + wcslen(L"LDAP://") + 2, L'/');

      if ( pRelativeTgtOUPath )
      {
         *pRelativeTgtOUPath = 0;
         swprintf(path,L"%ls/%ls,%ls",targetPath,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
         
      }
      else
      {
         MakeFullyQualifiedAdsPath(path, nPathLen, pOptions->tgtOUPath, pOptions->tgtComp, pOptions->tgtNamingContext);
      }

      pAcct->SetTargetPath(path);
      err.MsgWrite(0,DCT_MSG_OBJECT_MOVED_SS,pAcct->GetSourcePath(),pAcct->GetTargetPath());

   }
   else
   {
      pAcct->MarkError();
      Mark(L"errors", pAcct->GetType());
      if ( hr == 8524 )
      {
         err.MsgWrite(ErrE,DCT_MSG_MOVEOBJECT_FAILED_S8524,pAcct->GetName(),hr);
      }
      else
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_MOVEOBJECT_FAILED_SD,pAcct->GetName(),hr);
      }
   }

   return hr;
}

//---------------------------------------------------------------------------------------------------------
// RecordAndRemoveMemberOf : This method removes all values in the memberOf property and then records these
//                           memberships. These memberships are later updated.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::RecordAndRemoveMemberOf (
                                            Options * pOptions,         //in- Options specified by the user
                                           TAcctReplNode * pAcct,       //in- Account being migrated.
                                           TNodeListSortable * pMember  //out-List containing the MemberOf values.
                                         )
{
   // First Enumerate all the objects in the member of property
   INetObjEnumeratorPtr            pQuery(__uuidof(NetObjEnumerator));
   IEnumVARIANT                  * pEnum;
   LPWSTR                          sCols[] = { L"memberOf" };
   SAFEARRAY                     * pSa;
   BSTR                          * pData;
   SAFEARRAYBOUND                  bd = { 1, 0 };
//   long                            ind = 0;
   IADs                          * pAds;
   _bstr_t                         sObjDN;
   _bstr_t                         sGrpName;
   _variant_t                      var;
   _variant_t                    * pDt;
   _variant_t                      vx;
   DWORD                           ulFetch;
   _bstr_t                         sDN;
   WCHAR                           sPath[LEN_Path];
   IADsGroup                     * pGroup;
   _variant_t                    * pVar;

   if ( pMember->IsTree() ) pMember->ToSorted();

   WCHAR                     sPathSource[LEN_Path];
   DWORD					 nPathLen = LEN_Path;
   StuffComputerNameinLdapPath(sPathSource, nPathLen, const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions, FALSE);
   err.MsgWrite(0,DCT_STRIPPING_GROUP_MEMBERSHIPS_SS,pAcct->GetName(),sPathSource);
   // Get this users distinguished name.
   HRESULT hr = ADsGetObject(sPathSource, IID_IADs, (void**) &pAds);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE, hr, DCT_MSG_SOURCE_ACCOUNT_NOT_FOUND_SSD, pAcct->GetName(), pOptions->srcDomain, hr);
      Mark(L"errors", pAcct->GetType());
      return hr;
   }

   hr = pAds->Get(L"distinguishedName", &var);
   pAds->Release();
   if ( FAILED(hr))
      return hr;
   sObjDN = V_BSTR(&var);

   // Set up the column array
   pSa = SafeArrayCreate(VT_BSTR, 1, &bd);
   SafeArrayAccessData(pSa, (void HUGEP **) &pData);
   pData[0] = SysAllocString(sCols[0]);
   SafeArrayUnaccessData(pSa);

//   hr = pQuery->raw_SetQuery(const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions->srcDomain, L"(objectClass=*)", ADS_SCOPE_BASE, TRUE);
   hr = pQuery->raw_SetQuery(sPathSource, pOptions->srcDomain, L"(objectClass=*)", ADS_SCOPE_BASE, TRUE);
   hr = pQuery->raw_SetColumns(pSa);
   hr = pQuery->raw_Execute(&pEnum);
   
   while ( pEnum->Next(1, &var, &ulFetch) == S_OK )
   {
      SAFEARRAY * vals = var.parray;
      // Get the VARIANT Array out
      SafeArrayAccessData(vals, (void HUGEP**) &pDt);
      vx = pDt[0];
      SafeArrayUnaccessData(vals);

      // Single value in the property. Good enough for me though
      if ( vx.vt == VT_BSTR )
      {
         sDN = V_BSTR(&vx);
         sDN = PadDN(sDN);

         if ( sDN.length() > 0 )
         {
            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBEROF_SS), pAcct->GetName(), (WCHAR*) sDN);
            Progress(mesg);

            SimpleADsPathFromDN(pOptions, sDN, sPath);
            WCHAR                     sSourcePath[LEN_Path];
            WCHAR                     sPaths[LEN_Path];
			DWORD					  nPathLen = LEN_Path;

            wcscpy(sSourcePath, (WCHAR*) sPath);

            if ( !wcsncmp(L"LDAP://", sSourcePath, 7) )
               StuffComputerNameinLdapPath(sPaths, nPathLen, sSourcePath, pOptions, FALSE);
   
            // Get the IADsGroup pointer to each of the objects in member of and remove this object from the group
            hr = ADsGetObject(sPaths, IID_IADsGroup, (void**) &pGroup);
            if ( FAILED(hr) )
               continue;

            pGroup->Get(L"sAMAccountName", &var);
            sGrpName = V_BSTR(&var);
            hr = pGroup->Get(L"groupType",&var);
            if ( SUCCEEDED(hr) )
            {
               if ( var.lVal & 2 )
               {
                  // this is a global group

                  if ( !pOptions->nochange )
                     hr = pGroup->Remove(sPathSource);
                  else
                     hr = S_OK;

                  if ( SUCCEEDED(hr) )
                  {
//                     err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,sPath2,(WCHAR*)sGrpName);
                     err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,sPathSource,(WCHAR*)sPaths);
                  }
                  else
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sPathSource,sPaths,hr);
                     Mark(L"errors", pAcct->GetType());
                  }
               }
               else
               {
                  err.MsgWrite(0,DCT_MSG_NOT_REMOVING_MEMBER_FROM_GROUP_SS,sPathSource,sPaths);
                  pGroup->Release();
                  continue;
               }
            }
            pGroup->Release();
            if (FAILED(hr))
               continue;
            
            // Record this path into the list
            TRecordNode * pNode = new TRecordNode();
			if (!pNode)
               return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetMember((WCHAR*)sPath);
            pNode->SetMemberSam((WCHAR*)sGrpName);
            pNode->SetDN((WCHAR*)sDN);
            pNode->SetARNode(pAcct);
            if (! pMember->InsertIfNew((TNode*) pNode) )
               delete pNode;
         }
      }
      else if ( vx.vt & VT_ARRAY )
      {
         // We must have got an Array of multivalued properties
         // Access the BSTR elements of this variant array
         SAFEARRAY * multiVals = vx.parray; 
         SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
         for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
         {
            sDN = _bstr_t(pVar[dw]);
            sDN = PadDN(sDN);
            SimpleADsPathFromDN(pOptions, sDN, sPath);

            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBEROF_SS), pAcct->GetName(), (WCHAR*) sDN);
            Progress(mesg);

            WCHAR                     sSourcePath[LEN_Path];
            WCHAR                     sPaths[LEN_Path];
			DWORD					  nPathLen = LEN_Path;

            wcscpy(sSourcePath, (WCHAR*) sPath);

            if ( !wcsncmp(L"LDAP://", sSourcePath, 7) )
               StuffComputerNameinLdapPath(sPaths, nPathLen, sSourcePath, pOptions, FALSE);

            // Get the IADsGroup pointer to each of the objects in member of and remove this object from the group
            hr = ADsGetObject(sPaths, IID_IADsGroup, (void**) &pGroup);
            if ( FAILED(hr) )
               continue;

            pGroup->Get(L"sAMAccountName", &var);
            sGrpName = V_BSTR(&var);
            hr = pGroup->Get(L"groupType",&var);
            if ( SUCCEEDED(hr) )
            {
               if ( var.lVal & 2 )
               {
                  // This is a global group
                  if ( !pOptions->nochange )
                     hr = pGroup->Remove(sPathSource);
                  else
                     hr = S_OK;

                  if ( SUCCEEDED(hr) )
                  {
                     err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,sPathSource,sPaths);
                  }
                  else
                  {
                      err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sPathSource,sPaths);
                      Mark(L"errors", pAcct->GetType());
                  }
               }
               else
               {
                  err.MsgWrite(0,DCT_MSG_NOT_REMOVING_MEMBER_FROM_GROUP_SS,sPathSource,sPaths);
                  pGroup->Release();
                  continue;
               }
            }
            pGroup->Release();
            if (FAILED(hr))
               continue;

            // Record this path into the list
            TRecordNode * pNode = new TRecordNode();
			if (!pNode)
               return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetMember(sPath);
            pNode->SetMemberSam((WCHAR*)sGrpName);
            pNode->SetDN((WCHAR*)sDN);
            pNode->SetARNode(pAcct);
            if (! pMember->InsertIfNew((TNode*) pNode) )
               delete pNode;
         }
         SafeArrayUnaccessData(multiVals);
      }
   }
   pEnum->Release();
   VariantInit(&var);
   return S_OK;
}

//---------------------------------------------------------------------------------------------------------
// ResetObjectsMembership : This method restores the memberOf property of the object being migrated. It uses
//                          the information that was stored by RecordAndRemoveMemberOf function.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::ResetObjectsMembership(
                                     Options * pOptions,          //in- Options set by the user.
                                     TNodeListSortable * pMember, //in- The member list that is used to restore the values
                                     IIManageDBPtr pDb            //in- Database object to lookup migrated accounts.
                                    )
{
   IVarSetPtr                pVs(__uuidof(VarSet));
   _bstr_t                   sMember;
   IADs                    * pAds;
   IUnknown                * pUnk;
   _bstr_t                   sPath;
   _variant_t                var;
   _bstr_t                   sMyDN;
   IADsGroup               * pGroup = NULL;
   TAcctReplNode           * pAcct = NULL;
   HRESULT                   hr;
   WCHAR                     sPaths[LEN_Path];
   DWORD					 nPathLen = LEN_Path;
   

   // Sort the member list by the account nodes
  
   pMember->Sort(&TNodeCompareAcctNode);


   
   // For all the items in the member list lets add the member to the group.
   // First check in the migrated objects table to see if it has been migrated.
   for ( TRecordNode * pNode = (TRecordNode *)pMember->Head(); pNode; pNode = (TRecordNode *)pNode->Next())
   {
      pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);
      // get the needed information from the account node
      if ( pAcct != pNode->GetARNode() )
      {
         if ( pNode->GetARNode()->WasReplaced() )
         {
            // the account was moved successfully - add the target account to all of its old groups
            StuffComputerNameinLdapPath(sPaths, nPathLen, const_cast<WCHAR*>(pNode->GetARNode()->GetTargetPath()), pOptions);
            hr = ADsGetObject(sPaths, IID_IADs, (void**) &pAds);
         }
         else
         {
            // the move failed, add the source account back to its groups
            StuffComputerNameinLdapPath(sPaths, nPathLen, const_cast<WCHAR*>(pNode->GetARNode()->GetSourcePath()), pOptions, FALSE);
            hr = ADsGetObject(sPaths, IID_IADs, (void**) &pAds);
         }
         if ( SUCCEEDED(hr) )
         {
            pAds->Get(L"distinguishedName", &var);
            pAds->Release();
            sMyDN = V_BSTR(&var);
         }
         else 
         {
            continue;
         }
         pAcct = pNode->GetARNode();
         if ( pAcct->WasReplaced() )
         {
            err.MsgWrite(0,DCT_READDING_GROUP_MEMBERS_SS,pAcct->GetTargetName(),sPaths);
         }
         else
         {
            err.MsgWrite(0,DCT_READDING_GROUP_MEMBERS_SS,pAcct->GetName(),sPaths);
         }
      }
      
      sMember = pNode->GetMemberSam();
      if ( pAcct->WasReplaced() )
      {
         pVs->Clear();
         hr = pDb->raw_GetAMigratedObject((WCHAR*)sMember,pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
         pUnk->Release();
         if ( hr == S_OK )
            // Since we have already migrated this object lets use the target objects information.
            sPath = pVs->get(L"MigratedObjects.TargetAdsPath");
         else
            // Other wise use the source objects path to add.
            sPath = pNode->GetMember();
      }
      else
      {
         sPath = pNode->GetMember();
      }
      // We have a path to the object lets get the group interface and add this object as a member
      WCHAR                     sPath2[LEN_Path];
	  DWORD						nPathLen = LEN_Path;
      if ( SUCCEEDED(hr) )
      {
         StuffComputerNameinLdapPath(sPath2, nPathLen, (WCHAR*) sPath, pOptions, TRUE);
         hr = ADsGetObject(sPath2, IID_IADsGroup, (void**) &pGroup);
      }
      if ( SUCCEEDED(hr) )
      {
         if ( pAcct->WasReplaced() )
         {
            if ( ! pOptions->nochange )
               hr = pGroup->Add(sPaths);  
            else 
               hr = 0;
            if ( SUCCEEDED(hr) )
            {
               err.MsgWrite(0,DCT_MSG_READDED_MEMBER_SS,pAcct->GetTargetPath(),sPath2);
            }
            else
            {
               //hr = BetterHR(hr);
               if ( HRESULT_CODE(hr) == ERROR_DS_UNWILLING_TO_PERFORM )
               {
                  err.MsgWrite(0,DCT_MSG_READD_MEMBER_FAILED_CONSTRAINTS_SS,pAcct->GetTargetPath(),sPath2);  
               }
               else
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_READD_TARGET_MEMBER_FAILED_SSD,pAcct->GetTargetPath(),(WCHAR*)sPath2,hr);
               }
               Mark(L"errors", pAcct->GetType());
            }
         }
         else
         {
            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RESET_OBJECT_MEMBERSHIP_SS), (WCHAR*) sPath2, pAcct->GetTargetName());
            Progress(mesg);

            if ( ! pOptions->nochange )
               hr = pGroup->Add(sPaths);
            else
               hr = 0;
            if ( SUCCEEDED(hr) )
            {
               err.MsgWrite(0,DCT_MSG_READDED_MEMBER_SS,pAcct->GetSourcePath(),(WCHAR*)sPath2);
            }
            else
            {
               //hr = BetterHR(hr);
               if ( HRESULT_CODE(hr) == ERROR_DS_UNWILLING_TO_PERFORM )
               {
                  err.MsgWrite(0,DCT_MSG_READD_MEMBER_FAILED_CONSTRAINTS_SS,pAcct->GetTargetPath(),(WCHAR*)sPath2);  
               }
               else
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_READD_SOURCE_MEMBER_FAILED_SSD,pAcct->GetSourcePath(),(WCHAR*)sPath2,hr);
               }
               Mark(L"errors", pAcct->GetType());
            }
         }
      }
      else
      {
         // the member could not be added to the group
         hr = BetterHR(hr);
         err.SysMsgWrite(ErrW,hr,DCT_MSG_FAILED_TO_GET_OBJECT_SD,(WCHAR*)sPath2,hr);
         Mark(L"warnings", pAcct->GetType());
      }
      if ( pGroup )
      {
         pGroup->Release();
         pGroup = NULL;
      }
   }
   return hr;
}

//---------------------------------------------------------------------------------------------------------
// RecordAndRemoveMember : Records and removes the objects in the member property of the object(group) being
//                         migrated. The recorded information is later used to restore membership.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::RecordAndRemoveMember (
                                            Options * pOptions,         //in- Options set by the user.
                                           TAcctReplNode * pAcct,       //in- Account being copied.
                                           TNodeListSortable * pMember  //out-Membership list to be used later to restore membership
                                         )
{
   HRESULT                   hr;
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   IEnumVARIANT            * pEnum;
   LPWSTR                    sCols[] = { L"member" };
   SAFEARRAY               * pSa;
   SAFEARRAYBOUND            bd = { 1, 0 };
//   long                      ind = 0;
   WCHAR                     sPath[LEN_Path];
   DWORD					 nPathLen = LEN_Path;
   _bstr_t                   sDN;
   IADsGroup               * pGroup;
   _variant_t                var;
   DWORD                     ulFetch=0;
   IADs                    * pAds;
   _bstr_t                   sGrpName;
   _variant_t              * pDt;
   _variant_t                vx;
   BSTR  HUGEP             * pData;
   WCHAR                     sSourcePath[LEN_Path];
   WCHAR                     sAdsPath[LEN_Path];

   wcscpy(sSourcePath, pAcct->GetSourcePath());

   if ( !wcsncmp(L"LDAP://", sSourcePath, 7) )
      StuffComputerNameinLdapPath(sAdsPath, nPathLen, sSourcePath, pOptions, FALSE);
   
   hr = ADsGetObject(sAdsPath, IID_IADsGroup, (void**) &pGroup);
   if ( FAILED(hr) ) return hr;

   pSa = SafeArrayCreate(VT_BSTR, 1, &bd);
   hr = SafeArrayAccessData(pSa, (void HUGEP **)&pData);
   pData[0] = SysAllocString(sCols[0]);
   hr = SafeArrayUnaccessData(pSa);
   hr = pQuery->raw_SetQuery(sAdsPath, pOptions->srcDomain, L"(objectClass=*)", ADS_SCOPE_BASE, TRUE);
   hr = pQuery->raw_SetColumns(pSa);
   hr = pQuery->raw_Execute(&pEnum);
   
   err.MsgWrite(0,DCT_STRIPPING_GROUP_MEMBERS_SS,pAcct->GetName(),sAdsPath);
   while ( pEnum->Next(1, &var, &ulFetch) == S_OK )
   {
      SAFEARRAY * vals = var.parray;
      // Get the VARIANT Array out
      SafeArrayAccessData(vals, (void HUGEP**) &pDt);
      vx = pDt[0];
      SafeArrayUnaccessData(vals);

      // Single value in the property. Good enough for me though
      if ( vx.vt == VT_BSTR )
      {
         sDN = V_BSTR(&vx);
         sDN = PadDN(sDN);

         if ( sDN.length() )
         {
            ADsPathFromDN(pOptions, sDN, sPath);

            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBER_SS), pAcct->GetName(), (WCHAR*) sDN);
            Progress(mesg);
            // Get the IADs pointer to each of the objects in member and remove the object from the group
            hr = ADsGetObject((WCHAR*)sPath, IID_IADs, (void**) &pAds);

            if ( SUCCEEDED(hr) )
            {
               pAds->Get(L"sAMAccountName", &var);
               sGrpName = V_BSTR(&var);

               pAds->Get(L"distinguishedName", &var);
               sDN = V_BSTR(&var);
            }

            if ( !pOptions->nochange )
               hr = pGroup->Remove((WCHAR*) sPath);
            else
               hr = S_OK;

            if (FAILED(hr))
            {
               err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sAdsPath,(WCHAR*)sPath,hr);
               Mark(L"errors", pAcct->GetType());
               continue;
            }
            else
            {
               err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,(WCHAR*)sPath,sAdsPath);
            }
            // Record this path into the list
            TRecordNode * pNode = new TRecordNode();
			if (!pNode)
               return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetMember((WCHAR*)sPath);
            pNode->SetMemberSam((WCHAR*)sGrpName);
            pNode->SetDN((WCHAR*)sDN);
            pNode->SetARNode(pAcct);
            if (! pMember->InsertIfNew((TNode*) pNode) )
               delete pNode;
         }
      }
      else if ( vx.vt & VT_ARRAY )
      {
         // We must have got an Array of multivalued properties
         // Access the BSTR elements of this variant array
         _variant_t              * pVar;
         SAFEARRAY * multiVals = vx.parray; 
         SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
         for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
         {
            sDN = _bstr_t(pVar[dw]);
            _bstr_t sPadDN = PadDN(sDN);
            ADsPathFromDN(pOptions, sPadDN, sPath);

			WCHAR tempPath[LEN_Path];
			wcscpy(tempPath, sPath);
            if ( !wcsncmp(L"LDAP://", tempPath, 7) )
               StuffComputerNameinLdapPath(sPath, nPathLen, tempPath, pOptions, FALSE);

            WCHAR                  mesg[LEN_Path];
            wsprintf(mesg, (WCHAR*)GET_STRING(DCT_MSG_RECORD_REMOVE_MEMBER_SS), pAcct->GetName(), (WCHAR*) sPadDN);
            Progress(mesg);
            // Get the IADsGroup pointer to each of the objects in member of and remove this object from the group
            hr = ADsGetObject((WCHAR*)sPath, IID_IADs, (void**) &pAds);
            if ( SUCCEEDED(hr) )
            {
               hr = pAds->Get(L"sAMAccountName", &var);
               if ( SUCCEEDED(hr) )
			      {
				      sGrpName = V_BSTR(&var);
			      }

               hr = pAds->Get(L"distinguishedName", &var);
			      if ( SUCCEEDED(hr) )
			      {
			         sDN = V_BSTR(&var);
               }
         
               if ( !pOptions->nochange )
                  hr = pGroup->Remove((WCHAR*)sPath);
               else
                  hr = S_OK;

               if ( SUCCEEDED(hr) )
               {
                  err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,(WCHAR*)sPath,sAdsPath);
               }
               else
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sAdsPath,(WCHAR*)sPath,hr);
                  Mark(L"errors", pAcct->GetType());
               }
               if ( SUCCEEDED(hr) )
               {
                  // Record this path into the list
                  TRecordNode * pNode = new TRecordNode();
			      if (!pNode)
                     return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                  pNode->SetMember((WCHAR*)sPath);
                  pNode->SetMemberSam((WCHAR*)sGrpName);
                  pNode->SetDN((WCHAR*)sDN);
                  pNode->SetARNode(pAcct);
                  if ( ! pMember->InsertIfNew((TNode*) pNode) )
                     delete pNode;
               }
            }
            else
            {
               // Since we were not able to get this user. it has probably been migrated to another domain. 
               // we should use the DN to find where the object is migrated to and then use the migrated object 
               // to establish the membership instead.

               // Remove the rogue member
               if ( !pOptions->nochange )
                  hr = pGroup->Remove((WCHAR*)sPath);
               else
                  hr = S_OK;

               if ( SUCCEEDED(hr) )
               {
                  err.MsgWrite(0,DCT_MSG_REMOVED_MEMBER_FROM_GROUP_SS,(WCHAR*)sPath,sAdsPath);
               }
               else
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_MEMBER_FAILED_SSD,sAdsPath,(WCHAR*)sPath,hr);
                  Mark(L"errors", pAcct->GetType());
               }

               // Check in the DB to see where this object may have been migrated
               IUnknown * pUnk = NULL;
               IVarSetPtr  pVsMigObj(__uuidof(VarSet));

               hr = pVsMigObj->QueryInterface(IID_IUnknown, (void**)&pUnk);

               if ( SUCCEEDED(hr) )
                  hr = pOptions->pDb->raw_GetMigratedObjectBySourceDN(sPadDN, &pUnk);

               if (pUnk) pUnk->Release();

               if ( hr == S_OK )
               {
                  // Record this path into the list
                  TRecordNode * pNode = new TRecordNode();
			      if (!pNode)
                     return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                  WCHAR          sKey[500];
                  
                  wsprintf(sKey, L"MigratedObjects.%s", GET_STRING(DB_TargetAdsPath));
                  pNode->SetMember((WCHAR*)pVsMigObj->get(sKey).bstrVal);

                  wsprintf(sKey, L"MigratedObjects.%s", GET_STRING(DB_TargetSamName));
                  pNode->SetMemberSam((WCHAR*)pVsMigObj->get(sKey).bstrVal);
                  pNode->SetDN((WCHAR*)sDN);
                  pNode->SetARNode(pAcct);
                  if ( ! pMember->InsertIfNew((TNode*) pNode) )
                     delete pNode;
               }
               else
               {
                  //Log a message saying we can not find this object and the membership will not be updated on the other side.
                  err.MsgWrite(ErrE,DCT_MSG_MEMBER_NOT_FOUND_SS, pAcct->GetName(), (WCHAR*)sDN);
               }
            }
         }
         pAds->Release();
         SafeArrayUnaccessData(multiVals);
      }
   }
   pEnum->Release();
   VariantInit(&var);
   return S_OK;
}

void 
   CAcctRepl::UpdateMemberList(TNodeListSortable * pMemberList,TNodeListSortable * acctlist)
{
   // for each moved object in the account list, look it up in the member list
   TNodeTreeEnum        e;
   TAcctReplNode      * pAcct;
   TRecordNode        * pRec;
//   HRESULT              hr = S_OK;
   WCHAR                dn[LEN_Path];
   WCHAR        const * slash;

   pMemberList->Sort(TNodeCompareMemberDN);

   for ( pAcct = (TAcctReplNode *)e.OpenFirst(acctlist) ; pAcct ; pAcct = (TAcctReplNode *)e.Next())
   {
      if ( pAcct->WasReplaced() )
      {
         //err.DbgMsgWrite(0,L"UpdateMemberList:: %ls was replaced",pAcct->GetSourcePath());
         
         slash = wcschr(pAcct->GetSourcePath()+8,L'/');
         if ( slash )
         {
            safecopy(dn,slash+1);
           // err.DbgMsgWrite(0,L"Searching the member list for %ls",dn);
            // if the account was replaced, find any instances of it in the member list, and update them
            pRec = (TRecordNode *)pMemberList->Find(&TNodeCompareMemberItem,dn);
            while ( pRec )
            {
             // err.DbgMsgWrite(0,L"Found record: Member=%ls, changing it to %ls",pRec->GetMember(),pAcct->GetTargetPath());
               // change the member data to refer to the new location of the account
               pRec->SetMember(pAcct->GetTargetPath());
               pRec->SetMemberSam(pAcct->GetTargetSam());
               pRec->SetMemberMoved();
            
               pRec = (TRecordNode*)pRec->Next();
               if ( pRec && UStrICmp(pRec->GetDN(),dn) )
               {
                  // the next record is for a different node
                  pRec = NULL;
               }
            }
         }
      }
     // else
     //    err.DbgMsgWrite(0,L"UpdateMemberList:: %ls was not replaced",pAcct->GetSourcePath());
         
   }
   e.Close();
   // put the list back like it was before
   pMemberList->Sort(TNodeCompareMember);
}

void 
   CAcctRepl::SimpleADsPathFromDN(
      Options              * pOptions,
      WCHAR          const * sDN,
      WCHAR                * sPath
   )
{
   WCHAR             const * pDcPart = wcsstr(sDN,L",DC=");

   UStrCpy(sPath,L"LDAP://");

   if ( pDcPart )
   {
      WCHAR          const * curr;        // pointer to DN
      WCHAR                * sPathCurr;   // pointer to domain name part of the path
      
      for ( sPathCurr = sPath+UStrLen(sPath), curr = pDcPart + 4; *curr ; sPathCurr++ )
      {
         // replace each occurrence of ,DC= in the DN with '.' in this part of the domain
         if ( !UStrICmp(curr,L",DC=",4) )
         {
            (*sPathCurr) = L'.';
            curr+=4;
         }
         else
         {
            (*sPathCurr) = (*curr);
            curr++;
         }
      }
      // null-terminate the string
      (*sPathCurr) = 0;
   }
   else
   {
      // if we can't figure it out from the path for some reason, default to the source domain
      UStrCpy(sPath+UStrLen(sPath),pOptions->srcDomain);
   }
   
   UStrCpy(sPath+UStrLen(sPath),L"/");
   UStrCpy(sPath + UStrLen(sPath),sDN);

}

BOOL GetSidString(PSID sid, WCHAR* sSid)
{
   BOOL                   ret = false;
   SAFEARRAY            * pSa = NULL;
   SAFEARRAYBOUND         bd;
   HRESULT                hr = S_OK;
   LPBYTE                 pByte = NULL;
   _variant_t             var;
   
   if (IsValidSid(sid))
   {
      DWORD len = GetLengthSid(sid);
      bd.cElements = len;
      bd.lLbound = 0;
      pSa = SafeArrayCreate(VT_UI1, 1, &bd);
      if ( pSa )
         hr = SafeArrayAccessData(pSa, (void**)&pByte);

      if ( SUCCEEDED(hr) )
      {
         for ( DWORD x = 0; x < len; x++)
            pByte[x] = ((LPBYTE)sid)[x];
         hr = SafeArrayUnaccessData(pSa);
      }
      
      if ( SUCCEEDED(hr) )
      {
         var.vt = VT_UI1 | VT_ARRAY;
         var.parray = pSa;
         VariantSidToString(var);
         wcscpy(sSid, (WCHAR*) var.bstrVal);
         ret = true;
      }
   }
   return ret;
}
//---------------------------------------------------------------------------------------------------------
// ADsPathFromDN : Constructs the AdsPath from distinguished name by looking up the Global Catalog.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::ADsPathFromDN( 
                                 Options * pOptions,     //in -Options as set by the user
                                  _bstr_t sDN,           //in -Distinguished name to be converted
                                  WCHAR * sPath,         //out-The ads path of object referenced by the DN
                                  bool bWantLDAP         //in - Flag telling us if they want LDAP path or GC path.
                                )
{
   HRESULT                   hr;
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   WCHAR                     sCont[LEN_Path];
   IEnumVARIANT            * pEnum;
   WCHAR                     sQuery[LEN_Path];
   LPWSTR                    sCols[] = { L"ADsPath" };
   _variant_t                var;
   DWORD                     pFetch = 0;
   BSTR                    * pDt;
   _variant_t              * pvar;
   _variant_t                vx;
   SAFEARRAY               * pSa;
   SAFEARRAYBOUND            bd = { 1, 0 };
//   long                      ind = 0;
   long                      rc;

   pSa = SafeArrayCreate(VT_BSTR, 1, &bd);
   SafeArrayAccessData( pSa, (void HUGEP **) &pDt);
   pDt[0] = SysAllocString(sCols[0]);
   SafeArrayUnaccessData(pSa);
   wsprintf(sCont, L"GC://%s", pOptions->srcDomain);
   wsprintf(sQuery, L"(distinguishedName=%s)", (WCHAR*) sDN);
   hr = pQuery->raw_SetQuery(sCont, pOptions->srcDomain, sQuery, ADS_SCOPE_SUBTREE, TRUE);
   if ( FAILED(hr) )
      return hr;
   hr = pQuery->raw_SetColumns(pSa);
   if ( FAILED(hr) )
      return hr;
   hr = pQuery->raw_Execute(&pEnum);
   if ( FAILED(hr) )
      return hr;
   
   hr = pEnum->Next(1, &var, &pFetch);
   if ( SUCCEEDED(hr) && pFetch > 0 && (var.vt & VT_ARRAY) )
   {
      SAFEARRAY * vals = var.parray;
      // Get the VARIANT Array out
      rc = SafeArrayAccessData(vals, (void HUGEP**) &pvar);
      vx = pvar[0];
      rc = SafeArrayUnaccessData(vals);
      
      wcscpy(sPath, (WCHAR*)V_BSTR(&vx));
      if (bWantLDAP)
      {
         WCHAR   sTemp[LEN_Path];
         wsprintf(sTemp, L"LDAP%s", sPath + 2);
         wcscpy(sPath, sTemp);
      }
      hr = S_OK;
   }
   else
   {
      // This must not be from this forest so we need to use the LDAP://<SID=##> format
      wsprintf(sPath, L"LDAP://%s/%s", pOptions->srcDomain, (WCHAR*) sDN);
      hr = S_OK;
   }
   pEnum->Release();
   VariantInit(&var);
   return hr;
}
                                    

//---------------------------------------------------------------------------------------------------------
// FillNamingContext : Gets the naming context for both domains if they are Win2k
//---------------------------------------------------------------------------------------------------------
BOOL CAcctRepl::FillNamingContext(
                                    Options * pOptions      //in,out-Options as set by the user
                                 )
{
   // Get the defaultNamingContext for the source domain
   IADs                    * pAds = NULL;
   WCHAR                     sAdsPath[LEN_Path];
   VARIANT                   var;
   BOOL                      rc = TRUE;
   HRESULT                   hr;

   VariantInit(&var);
   // we should always be able to get the naming context for the target domain,
   // since the target domain will always be Win2K
   if ( ! *pOptions->tgtNamingContext )
   {
      wcscpy(sAdsPath, L"LDAP://");
      wcscat(sAdsPath, pOptions->srcDomain);
      wcscat(sAdsPath, L"/rootDSE");
   
      hr = ADsGetObject(sAdsPath, IID_IADs, (void**)&pAds);
      if ( FAILED(hr))
         rc = FALSE;

      if ( SUCCEEDED (hr) )
      {
         hr = pAds->Get(L"defaultNamingContext",&var);
         if ( SUCCEEDED( hr) )
            wcscpy(pOptions->srcNamingContext, var.bstrVal);
         VariantClear(&var);
      }
      if ( pAds )
      {
         pAds->Release();
         pAds = NULL;
      }
         
      wcscpy(sAdsPath, L"LDAP://");
      wcscat(sAdsPath, pOptions->tgtDomain);
      wcscat(sAdsPath, L"/rootDSE");
   
      hr = ADsGetObject(sAdsPath, IID_IADs, (void**)&pAds);
      if ( FAILED(hr))
         rc = FALSE;

      if ( SUCCEEDED (hr) )
      {
         hr = pAds->Get(L"defaultNamingContext",&var);
         if ( SUCCEEDED( hr) )
            wcscpy(pOptions->tgtNamingContext, var.bstrVal);
         VariantClear(&var);
      }
      if ( pAds )
         pAds->Release();
   }
   return rc;
}

//---------------------------------------------------------------------------------------------------------
// ResetGroupsMembers : This method re-adds the objects in the pMember list to the group account. This
//                      resets the group to its original form. ( as before the migration ). It also
//                      takes into account the MigratedObjects table which in turn allows to add the target
//                      information of newly migrated accounts to the group instead of the source account.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::ResetGroupsMembers( 
                                       Options * pOptions,           //in- Options as set by the user
                                       TAcctReplNode * pAcct,        //in- Account being copied
                                       TNodeListSortable * pMember,  //in- Membership list to restore
                                       IIManageDBPtr pDb             //in- DB object to look up migrated objects.
                                     )
{
   // Add all the members back to the group.
   IADsGroup               * pGroup;   
   HRESULT                   hr;
   _bstr_t                   sMember;
   _bstr_t                   sPath;
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk;
   DWORD                     groupType = 0;
   _variant_t                var;
   WCHAR                     sMemPath[LEN_Path];
   WCHAR                     sPaths[LEN_Path];
   DWORD					 nPathLen = LEN_Path;
   WCHAR                     subPath[LEN_Path];

   *sMemPath = L'\0';

   
   if ( pAcct->WasReplaced() )
   {
      wcscpy(subPath, pAcct->GetTargetPath());
      StuffComputerNameinLdapPath(sPaths, nPathLen, subPath, pOptions, TRUE);
      hr = ADsGetObject(sPaths, IID_IADsGroup, (void**) &pGroup);
      err.MsgWrite(0, DCT_READDING_MEMBERS_TO_GROUP_SS, pAcct->GetTargetName(), sPaths);
   }
   else
   {
      wcscpy(subPath, pAcct->GetSourcePath());
      StuffComputerNameinLdapPath(sPaths, nPathLen, subPath, pOptions, FALSE);
      hr = ADsGetObject(sPaths, IID_IADsGroup, (void**) &pGroup);
      err.MsgWrite(0, DCT_READDING_MEMBERS_TO_GROUP_SS, pAcct->GetName(), sPaths);
   }
   if ( FAILED(hr) ) return hr;

   hr = pGroup->Get(L"groupType", &var);
   if ( SUCCEEDED(hr) )
   {
      groupType = var.lVal;  
   }

   for ( TRecordNode * pNode = (TRecordNode*)pMember->Head(); pNode; pNode = (TRecordNode*)pNode->Next())
   {
      if ( pNode->GetARNode() != pAcct ) 
         continue;
      pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);

      sMember = pNode->GetMemberSam();
      if ( pAcct->WasReplaced() && sMember.length() && !pNode->IsMemberMoved() )
      {
         hr = pDb->raw_GetAMigratedObject(sMember,pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
      }
      else
      {
         hr = S_FALSE;  // if we don't have the sam name, don't bother trying to look this one up
      }
      pUnk->Release();
      if ( hr == S_OK )
         // Since we have already migrated this object lets use the target objects information.
         sPath = pVs->get(L"MigratedObjects.TargetAdsPath");
      else
         // Other wise use the source objects path to add.
         sPath = pNode->GetMember();
 
      if ( groupType & 4 )
      {
         // To add local group members we need to change the LDAP path to the SID type path
         IADs * pAds = NULL;
         hr = ADsGetObject((WCHAR*) sPath, IID_IADs, (void**) &pAds);
         if ( SUCCEEDED(hr) )
            hr = pAds->Get(L"objectSid", &var);

         if ( SUCCEEDED(hr) )
         {
            // Make sure the SID we got was in string format
            VariantSidToString(var);
            UStrCpy(sMemPath,L"LDAP://<SID=");
            UStrCpy(sMemPath + UStrLen(sMemPath),var.bstrVal);
            UStrCpy(sMemPath + UStrLen(sMemPath),L">");
         }
      }
      else
         wcscpy(sMemPath, (WCHAR*) sPath);

      WCHAR                  mesg[LEN_Path];
      wsprintf(mesg, GET_STRING(DCT_MSG_RESET_GROUP_MEMBERS_SS), pAcct->GetName(), (WCHAR*) sMemPath);
      Progress(mesg);

      if ( !pOptions->nochange )
         hr = pGroup->Add(sMemPath);
      else
         hr = S_OK;

      // Try again with LDAP path if SID path failed.
      if ( FAILED(hr) && ( groupType & 4 ) )
         hr = pGroup->Add((WCHAR*) sPath);

      if ( FAILED(hr) )
      {
         hr = BetterHR(hr);
         err.SysMsgWrite(ErrE, hr, DCT_MSG_FAILED_TO_READD_TO_GROUP_SSD,(WCHAR*)sPath, pAcct->GetName(),hr);
         Mark(L"errors", pAcct->GetType());
      }
      else
      {
         err.MsgWrite(0, DCT_MSG_READD_MEMBER_TO_GROUP_SS, (WCHAR*) sPath, pAcct->GetName());
      }
   }
   pGroup->Release();
   return hr;
}

BOOL CAcctRepl::TruncateSam(WCHAR * tgtname, TAcctReplNode * acct, Options * options, TNodeListSortable * acctList)
{
   // SInce we can not copy accounts with lenght more than 20 characters we will truncate
   // it and then add sequence numbers (0-99) in case there are duplicates.
   // we are also going to take into account the global prefix and suffix length while truncating
   // the account.
   BOOL                      ret = TRUE;
   int                       lenPref = wcslen(options->globalPrefix);
   int                       lenSuff = wcslen(options->globalSuffix);
   int                       lenOrig = wcslen(tgtname);
   int                       maxLen = 20;

   if ( !_wcsicmp(acct->GetType(), L"group") )
      maxLen = 255;
   else
      maxLen = 20;

   int                       lenTruncate = maxLen - ( 2 + lenPref + lenSuff );

   // we can not truncate accounts if prefix and suffix are > 20 characters themselves
   if ( lenPref + lenSuff > (maxLen - 2) ) return FALSE;

   if ( lenPref + lenSuff + lenOrig > maxLen )
   {
      WCHAR                sTemp[LEN_Path];
      wcsncpy(sTemp, tgtname, lenTruncate);
      sTemp[lenTruncate] = 0;
      int cnt = 0;
      bool cont = true;
      while (cont)
      {
         wsprintf(tgtname, L"%s%02d", sTemp, cnt);
         if ( CheckifAccountExists(options, tgtname) || acctList->Find(&TNodeFindByNameOnly, tgtname))
            cnt++;
         else
         {
            cont = false;
            // Account is truncated so log a message.
            err.MsgWrite(0, DCT_MSG_TRUNCATED_ACCOUNT_NAME_SS, acct->GetName(), tgtname);
         }

         if (cnt > 99)
         {
            // We only have 2 digits for numbers so any more than this we can not handle.
            err.MsgWrite(ErrW,DCT_MSG_FAILED_TO_TRUNCATE_S, acct->GetTargetName());
            Mark(L"warnings",acct->GetType());
            UStrCpy(tgtname, acct->GetTargetName());
            ret = FALSE;
            break;
         }
      }
   }
   return ret;
}
//---------------------------------------------------------------------------------------------------------
//  FillNodeFromPath : We will take the LDAP path that is provided to us and from that fill 
//                     in all the information that is required in AcctRepl node.
//---------------------------------------------------------------------------------------------------------
HRESULT CAcctRepl::FillNodeFromPath(
                                       TAcctReplNode *pAcct, // in-Account node to fillin
                                       Options * pOptions,   //in - Options set by the users
                                       TNodeListSortable * acctList
                                   )
{
   HRESULT                   hr = S_OK;
   IADs                    * pAds = NULL;
   VARIANT                   var;
   BSTR                      sText;
   WCHAR                     text[LEN_Account];
   BOOL                      bBuiltIn = FALSE;
   WCHAR                     sSam[LEN_Path];
//   DWORD                     dwLen = 0;
   

   VariantInit(&var);
   FillNamingContext(pOptions);

   hr = ADsGetObject(const_cast<WCHAR*>(pAcct->GetSourcePath()), IID_IADs, (void**)&pAds);
   if ( SUCCEEDED(hr) )
   {
      // Check if this is a BuiltIn account. 
      hr = pAds->Get(L"isCriticalSystemObject", &var);
      if ( SUCCEEDED(hr) )
      {
         bBuiltIn = V_BOOL(&var) == -1 ? TRUE : FALSE;
      }
      else
      {
         // This must be a NT4 account. We need to get the SID and check if
         // it's RID belongs to the BUILTIN rids.
         hr = pAds->Get(L"objectSID", &var);
         if ( SUCCEEDED(hr) )
         {
            SAFEARRAY * pArray = V_ARRAY(&var);
            PSID                 pSid;
            hr = SafeArrayAccessData(pArray, (void**)&pSid);
            if ( SUCCEEDED(hr) )
            {
               DWORD * dwCnt = (DWORD *) GetSidSubAuthorityCount(pSid);
               DWORD * rid = (DWORD *) GetSidSubAuthority(pSid, (*dwCnt)-1);
               bBuiltIn = BuiltinRid(*rid);
               if ( bBuiltIn ) 
               {
                  hr = pAds->get_Name(&sText);
                  if (SUCCEEDED(hr))
                  {
                     bBuiltIn = CheckBuiltInWithNTApi(pSid, (WCHAR*) sText, pOptions);
                  }
                  SysFreeString(sText);
                  sText = NULL;
               }
               hr = SafeArrayUnaccessData(pArray);
            }
            VariantClear(&var);
         }
      }

      hr = pAds->get_Class(&sText);
      if ( SUCCEEDED(hr) )
      {
         pAcct->SetType((WCHAR*) sText);
      }
      // check if it is a group. If it is then get the group type and store it in the node.
      if ( _wcsicmp((WCHAR*) sText, L"group") == 0 )
      {
         hr = pAds->Get(L"groupType", &var);
         if ( SUCCEEDED(hr) )
         {
            pAcct->SetGroupType((long) V_INT(&var));
         }
      }

      SysFreeString(sText);
      sText = NULL;
      hr = pAds->get_Name(&sText);
      if (SUCCEEDED(hr))
      {
         safecopy(text,(WCHAR*)sText);
         pAcct->SetTargetName(text);
         pAcct->SetName(text);
      }
	     //if the name includes a '/', then we have to get the escaped version from the path
	     //due to a bug in W2K.
	  if (wcschr((WCHAR*)sText, L'/'))
	  {
		 _bstr_t sCNName = GetCNFromPath(_bstr_t(pAcct->GetSourcePath()));
		 if (sCNName.length() != 0)
		 {
            pAcct->SetTargetName((WCHAR*)sCNName);
            pAcct->SetName((WCHAR*)sCNName);
		 }
	  }
      
      hr = pAds->Get(L"sAMAccountName", &var);
      if ( SUCCEEDED(hr))
      {
         // Add the prefix or the suffix as it is needed
         wcscpy(sSam, (WCHAR*)V_BSTR(&var));
         pAcct->SetSourceSam(sSam);
         pAcct->SetTargetSam(sSam);
         AddPrefixSuffix(pAcct, pOptions);
         VariantClear(&var);
     }
      else
      {
         pAcct->SetSourceSam((WCHAR*) sText);
         TruncateSam((WCHAR*)sText, pAcct, pOptions, acctList);
         pAcct->SetTargetSam((WCHAR*) sText);
         AddPrefixSuffix(pAcct, pOptions);
      }

      SysFreeString(sText);
      sText = NULL;
      
      // Don't know why it is different for WinNT to ADSI
      if ( pOptions->srcDomainVer > 4 )
         hr = pAds->Get(L"profilePath", &var);
      else
         hr = pAds->Get(L"profile", &var);

      if ( SUCCEEDED(hr))
      {
         pAcct->SetSourceProfile((WCHAR*) V_BSTR(&var));
         VariantClear(&var);
      }

      if ( bBuiltIn )
      {
         // Builtin account so we are going to ignore this account. ( by setting the operation mask to 0 )
         err.MsgWrite(ErrW, DCT_MSG_IGNORING_BUILTIN_S, pAcct->GetSourceSam());
         Mark(L"warnings", pAcct->GetType());
         pAcct->operations = 0;
      }
   }
   else
   {
      err.SysMsgWrite(ErrE, hr, DCT_MSG_OBJECT_NOT_FOUND_SSD, pAcct->GetSourcePath(), opt.srcDomain, hr);
      Mark(L"errors", pAcct->GetType());
   }
   if ( pAds )
      pAds->Release();
   return hr;
}


//---------------------------------------------------------------------------------------------------------
// GetNt4Type : Given the account name and the domain finds the type of account.
//---------------------------------------------------------------------------------------------------------
BOOL CAcctRepl::GetNt4Type(const WCHAR *sComp, const WCHAR *sAcct, WCHAR *sType)
{
   DWORD                     rc = 0;
   USER_INFO_0             * buf;
   BOOL                      ret = FALSE;
   USER_INFO_1             * specialBuf;

   if ( (rc = NetUserGetInfo(sComp, sAcct, 1, (LPBYTE *) &specialBuf)) == NERR_Success )
   {
      if ( specialBuf->usri1_flags & UF_WORKSTATION_TRUST_ACCOUNT 
         || specialBuf->usri1_flags & UF_SERVER_TRUST_ACCOUNT 
         || specialBuf->usri1_flags & UF_INTERDOMAIN_TRUST_ACCOUNT )
      {
         // this is not really a user (maybe a computer or a trust account) So we will ignore it.
         ret = FALSE;
      }
      else
      {
         wcscpy(sType, L"user");
         ret = TRUE;
      }
      NetApiBufferFree(specialBuf);
   }
   else if ( (rc = NetGroupGetInfo(sComp, sAcct, 0, (LPBYTE *) &buf)) == NERR_Success )
   {
      wcscpy(sType, L"group");
      NetApiBufferFree(buf);
      ret = TRUE;
   }
   else if ( (rc = NetLocalGroupGetInfo(sComp, sAcct, 0, (LPBYTE *) &buf)) == NERR_Success )
   {
      wcscpy(sType, L"group");
      NetApiBufferFree(buf);
      ret = TRUE;
   }

   return ret;
}

bool CAcctRepl::GetClosestDC(Options * pOpt, long flags)
{
   DOMAIN_CONTROLLER_INFO  * pSrcDomCtrlInfo = NULL;
   DWORD                     rc = 0;
   DSGETDCNAME DsGetDcName = NULL;
   
   HMODULE hPro = LoadLibrary(L"NetApi32.dll");
   if ( hPro )
      DsGetDcName = (DSGETDCNAME)GetProcAddress(hPro, "DsGetDcNameW");
   else
   {
      err.SysMsgWrite(ErrE, rc, DCT_MSG_LOAD_LIBRARY_FAILED_SD, L"NetApi32.dll");
      Mark(L"errors", L"generic");
   }

   if (DsGetDcName)   
   {
      rc = DsGetDcName(
                        NULL                                  ,// LPCTSTR ComputerName ?
                        pOpt->srcDomain                       ,// LPCTSTR DomainName
                        NULL                                  ,// GUID *DomainGuid ?
                        NULL                                  ,// LPCTSTR SiteName ?
                        flags                                 ,// ULONG Flags ?
                        &pSrcDomCtrlInfo                       // PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
                     );
      if ( rc ) 
      {
         err.SysMsgWrite(ErrE, rc, DCT_MSG_DOMAIN_NOT_FOUND_S, pOpt->srcDomain);
         Mark(L"errors", L"generic");
      }
      else
      {
         wcscpy(pOpt->srcComp, pSrcDomCtrlInfo->DomainControllerName);
      }
      NetApiBufferFree( pSrcDomCtrlInfo );

      rc = DsGetDcName(
                        NULL                                  ,// LPCTSTR ComputerName ?
                        pOpt->tgtDomain                       ,// LPCTSTR DomainName
                        NULL                                  ,// GUID *DomainGuid ?
                        NULL                                  ,// LPCTSTR SiteName ?
                        flags                                 ,// ULONG Flags ?
                        &pSrcDomCtrlInfo                       // PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
                     );
      if ( rc ) 
      {
         err.SysMsgWrite(ErrE, rc, DCT_MSG_DOMAIN_NOT_FOUND_S, pOpt->tgtDomain);
         Mark(L"errors", L"generic");
      }
      else
      {
         wcscpy(pOpt->tgtComp, pSrcDomCtrlInfo->DomainControllerName);
      }
      NetApiBufferFree( pSrcDomCtrlInfo );
   }
   if ( hPro )
      FreeLibrary(hPro);
   return ( rc == 0 );
}

//------------------------------------------------------------------------------
// UndoCopy: This function Undoes the copying of the accounts. It currently
//           does the following tasks. Add to it if needed.
//           1. Deletes the target account if Inter-Forest, but replace source acocunts
//				in local groups for accounts migrated by ADMT.
//           2. Moves the object back to its original position if Intra-Forest.
//           3. Calls the Undo function on the Extensions 
//------------------------------------------------------------------------------
int CAcctRepl::UndoCopy(
                        Options              * options,      // in -options
                        TNodeListSortable    * acctlist,     // in -list of accounts to process
                        ProgressFn           * progress,     // in -window to write progress messages to
                        TError               & error,        // in -window to write error messages to
                        IStatusObj           * pStatus,      // in -status object to support cancellation
                        void                   WindowUpdate (void )    // in - window update function
                    )
{
   BOOL bSameForest = FALSE;
   
   // sort the account list by Source Type\Source Name
   acctlist->CompareSet(&TNodeCompareAccountType);

   acctlist->SortedToScrambledTree();
   acctlist->Sort(&TNodeCompareAccountType);
   acctlist->Balance();

   long rc;
   // Since these are Win2k domains we need to process it with Win2k code.
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   // First of all we need to find out if they are in the same forest.
   HRESULT hr = S_OK;
   if ( BothWin2K(options) )
   {
      hr = pAccess->raw_IsInSameForest(options->srcDomainDns,options->tgtDomainDns, (long*)&bSameForest);
   }
   if ( SUCCEEDED(hr) )
   {
      if ( !bSameForest )
         // Different forest we need to delete the one that we had previously created.
         rc = DeleteObject(options, acctlist, progress, pStatus);
      else
      {
         // Within a forest we can move the object around.
         TNodeListSortable          * pList = NULL;
         hr = MakeAcctListFromMigratedObjects(options, options->lUndoActionID, pList,TRUE);
         if ( SUCCEEDED(hr) && pList )
         {
            if ( pList->IsTree() ) pList->ToSorted();
            pList->CompareSet(&TNodeCompareAccountType);
            pList->UnsortedToTree();
            pList->Balance();
            rc = MoveObj2K(options, pList, progress, pStatus);
         }
         else
         {
            err.SysMsgWrite(ErrE,hr,DCT_MSG_FAILED_TO_LOAD_UNDO_LIST_D,hr);
            Mark(L"errors", L"generic");
         }
      }

      if ( progress )
         progress(L"");
   }
   return rc;
}

int CAcctRepl::DeleteObject( 
                           Options              * pOptions,    //in -Options that we recieved from the user
                           TNodeListSortable    * acctlist,    //in -AcctList of accounts to be copied.
                           ProgressFn           * progress,    //in -Progress Function to display messages
                           IStatusObj           * pStatus      // in -status object to support cancellation
                        )
{
   TNodeListSortable       * pList = NULL;
   TNodeTreeEnum             tenum;
   TAcctReplNode           * acct = NULL, * tNext = NULL;
   HRESULT                   hr = S_OK;
   DWORD                     rc = 0;
   WCHAR                     mesg[LEN_Path];
   IUnknown                * pUnk = NULL;
   IVarSetPtr                pVs(__uuidof(VarSet));
   _variant_t                var;
      
   hr = MakeAcctListFromMigratedObjects(pOptions, pOptions->lUndoActionID, pList,FALSE);
   
   if ( SUCCEEDED(hr) && pList )
   {
      if ( pList->IsTree() ) pList->ToSorted();
      pList->SortedToScrambledTree();
      pList->Sort(&TNodeCompareAccountSam);
      pList->Balance();
   
	  /* restore source account of account being deleted in local groups prior to deleting 
         the target account */
      wcscpy(mesg, GET_STRING(IDS_LG_MEMBER_FIXUP_UNDO));
      if ( progress )
         progress(mesg);
      ReplaceSourceInLocalGroup(pList, pOptions, pStatus);

      for ( acct = (TAcctReplNode *)tenum.OpenFirst(pList) ; acct ; acct = tNext)
      {
         // Call the extensions for undo
         wsprintf(mesg, GET_STRING(IDS_RUNNING_EXTS_S), acct->GetTargetPath());
         if ( progress )
            progress(mesg);
         Mark(L"processed",acct->GetType());
         // Close the log file if it is open
         WCHAR          filename[LEN_Path];
         err.LogClose();
         if (m_pExt)
            m_pExt->Process(acct, pOptions->tgtDomain, pOptions,FALSE);
         safecopy (filename,opt.logFile);
         err.LogOpen(filename,1 /*append*/ );

         if ( acct->GetStatus() & AR_Status_Created )
         {
            wsprintf(mesg, GET_STRING(IDS_DELETING_S), acct->GetTargetPath());
            if ( progress ) progress(mesg);
            if ( ! _wcsicmp(acct->GetType(),L"computer") )
            {
               // do not delete the computer accounts, because if we do,
               // the computer will be immediately locked out of the domain
               tNext = (TAcctReplNode *) tenum.Next();
               pList->Remove(acct);
               delete acct;
               continue;
            }
            // Now delete the account.
            if ( !_wcsicmp(acct->GetType(), L"user") )
               rc = NetUserDel(pOptions->tgtComp, acct->GetTargetSam());
            else
            {
               // Must be a group try both local and global.
               rc = NetGroupDel(pOptions->tgtComp, acct->GetTargetSam());
               if ( rc )
                  rc = NetLocalGroupDel(pOptions->tgtComp, acct->GetTargetSam());
            }
            
             // Log a message
            if ( !rc ) 
            {
               err.MsgWrite(0, DCT_MSG_ACCOUNT_DELETED_S, (WCHAR*)acct->GetTargetPath());
               Mark(L"created",acct->GetType());
            }
            else
            {
               err.SysMsgWrite(ErrE, rc, DCT_MSG_DELETE_ACCOUNT_FAILED_SD, (WCHAR*)acct->GetTargetPath(), rc);
               Mark(L"errors", acct->GetType());
            }
         }
         else
         {
            err.MsgWrite(ErrW, DCT_MSG_NO_DELETE_WAS_REPLACED_S, acct->GetTargetPath());
            Mark(L"warnings",acct->GetType());
         }
         tNext = (TAcctReplNode *) tenum.Next();
         pList->Remove(acct);
         delete acct;
      }
      tenum.Close();
      delete pList;
   }
   if ( pUnk ) pUnk->Release();
   tenum.Close();
   return rc;
}

HRESULT CAcctRepl::MakeAcctListFromMigratedObjects(Options * pOptions, long lUndoActionID, TNodeListSortable *& pAcctList,BOOL bReverseDomains)
{
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk = NULL;
   HRESULT                   hr = S_OK;
   _bstr_t                   sSName, sTName, sSSam, sTSam, sType, sSUPN, sSDSid;
   long						 lSRid, lTRid;
   long                      lStat;
   WCHAR                     sActionInfo[LEN_Path];

   hr = pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
   if ( SUCCEEDED(hr) )
      hr = pOptions->pDb->raw_GetMigratedObjects( pOptions->lUndoActionID, &pUnk);

   if ( SUCCEEDED(hr) )
   {
      pAcctList = new TNodeListSortable();
	  if (!pAcctList)
         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
      
      long lCnt = pVs->get("MigratedObjects");
   
      for ( long l = 0; l < lCnt; l++)
      {
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceAdsPath));      
         sSName = pVs->get(sActionInfo);

         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_TargetAdsPath));      
         sTName = pVs->get(sActionInfo);
         
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_status));      
         lStat = pVs->get(sActionInfo);
         
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_TargetSamName));      
         sTSam = pVs->get(sActionInfo);
         
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceSamName));      
         sSSam = pVs->get(sActionInfo);

         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_Type));      
         sType = pVs->get(sActionInfo);
       
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceDomainSid));      
         sSDSid = pVs->get(sActionInfo);
       
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceRid));      
         lSRid = pVs->get(sActionInfo);
       
         wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_TargetRid));      
         lTRid = pVs->get(sActionInfo);
       
		 TAcctReplNode * pNode = new TAcctReplNode();
	     if (!pNode)
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

         if ( bReverseDomains )
         {
            pNode->SetSourcePath((WCHAR*) sTName);
            pNode->SetTargetPath((WCHAR*) sSName);
            pNode->SetSourceSam((WCHAR*) sTSam);
            pNode->SetTargetSam((WCHAR*) sSSam);
            
			   //if we are moving the acounts back during an undo, get the source UPN for this account
			GetAccountUPN(pOptions, sSName, sSUPN);
            pNode->SetSourceUPN((WCHAR*) sSUPN);
         }
         else
         {
            pNode->SetSourcePath((WCHAR*) sSName);
            pNode->SetTargetPath((WCHAR*) sTName);
            pNode->SetSourceSam((WCHAR*) sSSam);
            pNode->SetTargetSam((WCHAR*) sTSam);
         }
         pNode->SetType((WCHAR*) sType);
         pNode->SetStatus(lStat);
         pNode->SetSourceSid(SidFromString((WCHAR*)sSDSid));
         pNode->SetSourceRid(lSRid);
         pNode->SetTargetRid(lTRid);
         pAcctList->InsertBottom((TNode*) pNode);
      }
   }
   return hr;
}

void CAcctRepl::AddPrefixSuffix( TAcctReplNode * pNode, Options * pOptions )
{
   DWORD dwLen = 0;
   WCHAR ss[LEN_Path];
   WCHAR tgt[LEN_Path];
   WCHAR pref[LEN_Path];
   WCHAR suf[LEN_Path];
   WCHAR sTemp[LEN_Path];
   WCHAR sTargetSamName[LEN_Path];

   wcscpy(sTargetSamName, pNode->GetTargetSam());
   if ( wcslen(pOptions->globalPrefix) )
   {
      int truncate = 255;
      if ( !_wcsicmp(pNode->GetType(), L"user") )
      {
         truncate = 20 - wcslen(pOptions->globalPrefix);
      }
      else  if ( !_wcsicmp(pNode->GetType(), L"computer") )
      {
         truncate = 16 - wcslen(pOptions->globalPrefix);
      }

      // make sure we truncate the account so we dont get account names that are very large.
      sTargetSamName[truncate] = L'\0';

      // Prefix is specified so lets just add that.
      wsprintf(sTemp, L"%s%s", pOptions->globalPrefix, sTargetSamName);

      wcscpy(tgt, pNode->GetTargetName());
      for ( DWORD z = 0; z < wcslen(tgt); z++ )
      {
         if ( tgt[z] == L'=' ) break;
      }
      
      if ( z < wcslen(tgt) )
      {
         // Get the prefix part ex.CN=
         wcsncpy(pref, tgt, z+1);
         pref[z+1] = 0;
         wcscpy(suf, tgt+z+1);
      }
      else
      {
         wcscpy(pref,L"");
         wcscpy(suf,tgt);
      }

      // Remove the \ if it is escaping the space
      if ( suf[0] == L'\\' && suf[1] == L' ' )
      {
         WCHAR       sTemp[LEN_Path];
         wcscpy(sTemp, suf+1);
         wcscpy(suf, sTemp);
      }
      // Build the target string with the Prefix
      wsprintf(tgt, L"%s%s%s", pref, pOptions->globalPrefix, suf);
   }
   else if ( wcslen(pOptions->globalSuffix) )
   {
      
      int truncate = 255;
      if ( !_wcsicmp(pNode->GetType(), L"user") )
      {
         truncate = 20 - wcslen(pOptions->globalSuffix);
      }
      else  if ( !_wcsicmp(pNode->GetType(), L"computer") )
      {
         truncate = 16 - wcslen(pOptions->globalSuffix);
      }

      // make sure we truncate the account so we dont get account names that are very large.
      sTargetSamName[truncate] = L'\0';

      // Suffix is specified.
      if ( !_wcsicmp( pNode->GetType(), L"computer") )
      {
         // We need to make sure we take into account the $ sign in computer sam name.
         dwLen = wcslen(sTargetSamName);
         // Get rid of the $ sign
         wcscpy(ss, sTargetSamName);
         if ( ss[dwLen - 1] == L'$' ) 
         {
            ss[dwLen - 1] = L'\0';
         }
         wsprintf(sTemp, L"%s%s$", ss, pOptions->globalSuffix);
      }
      else
      {
         //Simply add the suffix to all other accounts.
         wsprintf(sTemp, L"%s%s", sTargetSamName, pOptions->globalSuffix);
      }

      // Remove the trailing space \ escape sequence
      wcscpy(tgt, pNode->GetName());
      for ( int i = wcslen(tgt)-1; i >= 0; i-- )
      {
         if ( tgt[i] != L' ' )
            break;
      }

      if ( tgt[i] == L'\\' )
      {
         WCHAR * pTemp = &tgt[i];
         *pTemp = 0;
         wcscpy(pref, tgt);
         wcscpy(suf, pTemp+1);
      }
      else
      {
         wcscpy(pref, tgt);
         wcscpy(suf, L"");
      }
      wsprintf(tgt, L"%s%s%s", pref, suf, pOptions->globalSuffix);
   }
   else
   {
      wcscpy(sTemp, pNode->GetTargetSam());
      wcscpy(tgt, pNode->GetName());
   }

   pNode->SetTargetName(tgt);
   pNode->SetTargetSam(sTemp);
}

void CAcctRepl::BuildTargetPath(WCHAR const * sCN, WCHAR const * tgtOU, WCHAR * stgtPath)
{
   WCHAR pTemp[LEN_Path];

   wcscpy(pTemp, tgtOU);
   *stgtPath = L'\0';
   // Make sure it is a LDAP path.
   if ( !wcsncmp(L"LDAP://", pTemp, 7) )
   {
      // Get the LDAP://<DOMAIN>/ part.
      WCHAR * p = wcschr(pTemp + 7, L'/');
      // Build the string.
      if (p)
      {
         *p = L'\0';
         wsprintf(stgtPath, L"%s/%s,%s", pTemp, sCN, p+1);
      }
   }
}

HRESULT CAcctRepl::BetterHR(HRESULT hr)
{
   HRESULT temp = hr;
   if ( hr == 0x8007001f || hr == 0x80071392 ) temp = HRESULT_FROM_WIN32(NERR_UserExists);
   else if ( hr == 0x80072030 || hr == 0x80070534 ) temp = HRESULT_FROM_WIN32(NERR_UserNotFound);
   return temp;
}

HRESULT CAcctRepl::GetThePrimaryGroupMembers(Options * pOptions, WCHAR * sGroupSam, IEnumVARIANT *& pVar)
{
   // This function looks for accounts that have the primaryGroupID set to the rid of the
   // group in the argument. 
   BSTR                      pCols = L"aDSPath";
   DWORD                     rid = 0;
   HRESULT                   hr;
   if ( GetRidForGroup(pOptions, sGroupSam, rid) )
      hr = QueryPrimaryGroupMembers(pCols, pOptions, rid, pVar);
   else
      hr = HRESULT_FROM_WIN32(GetLastError());

   return hr;
}

HRESULT CAcctRepl::AddPrimaryGroupMembers(Options * pOptions, SAFEARRAY * multiVals, WCHAR * sGroupSam)
{
   // This function will get the accounts with primarygroupID = Group's RID and
   // adds the DN for these Accounts to the safearry in the argument list.
   BSTR                      pCols = L"distinguishedName";
   DWORD                     rid = 0, dwFetch = 0;
   IEnumVARIANT            * pEnum = NULL;
   HRESULT                   hr = S_OK;
   _variant_t                var;
   _variant_t              * var2;
   SAFEARRAYBOUND            bd;
   long                      lb, ub;
   _variant_t              * pData = NULL;

   SafeArrayGetLBound(multiVals, 1, &lb);
   SafeArrayGetUBound(multiVals, 1, &ub);
   bd.lLbound = lb;
   bd.cElements = ub - lb + 1;
   if ( GetRidForGroup(pOptions, sGroupSam, rid) )
   {
      hr = QueryPrimaryGroupMembers(pCols, pOptions, rid, pEnum);
      if ( SUCCEEDED(hr) )
      {
         while ( pEnum->Next(1, &var, &dwFetch) == S_OK )
         {
            if (var.vt == (VT_ARRAY|VT_VARIANT))
            {
               SAFEARRAY * pArray = var.parray;
               hr = SafeArrayAccessData(pArray, (void **)&var2);
               if ( SUCCEEDED(hr) )
               {
                  // Add one more element to the array.
                  bd.cElements++;
                  hr = SafeArrayRedim(multiVals, &bd);
               }

               // Fill in the new element with the information in the variant.
               if ( SUCCEEDED(hr) )
                  hr = SafeArrayAccessData(multiVals, (void HUGEP**) &pData);

               if ( SUCCEEDED(hr) )
               {
                  pData[++ub] = *var2;
                  SafeArrayUnaccessData(multiVals);
               }
               if ( SUCCEEDED(hr) )
                  SafeArrayUnaccessData(pArray);
               
               VariantInit(&var);
            }
            else
               // Something really bad happened we should not get here in normal cond
               hr = E_FAIL;
         }
      }
   }
   else
      hr = HRESULT_FROM_WIN32(GetLastError());

   if ( pEnum ) pEnum->Release();
   return hr;
}

bool CAcctRepl::GetRidForGroup(Options * pOptions, WCHAR * sGroupSam, DWORD& rid)
{
   // We lookup the Account name and get its SID. Once we have the SID we extract the RID and return that
   SID_NAME_USE              use;
   PSID                      sid = (PSID) new BYTE[LEN_Path];
   WCHAR                     dom[LEN_Path];
   DWORD                     cbsid = LEN_Path, cbDom = LEN_Path;
   bool                      ret = true;

   if (!sid)
      return false;

   if ( LookupAccountName(pOptions->srcComp, sGroupSam, sid, &cbsid, dom, &cbDom, &use) )
   {
      // we now have the sid so get its sub authority count.
      DWORD * pSubCnt = (DWORD*)GetSidSubAuthorityCount(sid);
      DWORD * pRid = GetSidSubAuthority(sid, (*pSubCnt) -1 );
      rid = *pRid;
   }
   else
      ret = false;
   
   delete [] sid;
   return ret;
}

HRESULT CAcctRepl::QueryPrimaryGroupMembers(BSTR cols, Options * pOptions, DWORD rid, IEnumVARIANT*& pEnum)
{
   WCHAR                     sQuery[LEN_Path];
   WCHAR                     sCont[LEN_Path];
   SAFEARRAY               * colNames;
   SAFEARRAYBOUND            bd = { 1, 0 };
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   BSTR                    * pData;
   HRESULT                   hr;

   wsprintf(sQuery, L"(primaryGroupID=%d)", rid);
   wsprintf(sCont, L"LDAP://%s", pOptions->srcDomainDns);

   colNames = SafeArrayCreate(VT_BSTR, 1, &bd);

   hr = SafeArrayAccessData(colNames, (void**)&pData);

   if ( SUCCEEDED(hr) )
   {
      pData[0] = SysAllocString(cols);
      hr = SafeArrayUnaccessData(colNames);
   }

   if ( SUCCEEDED(hr) )
      hr = pQuery->SetQuery(sCont, pOptions->srcDomain, sQuery, ADS_SCOPE_SUBTREE, FALSE);
   
   if ( SUCCEEDED(hr) )
      hr = pQuery->SetColumns(colNames);

   if ( SUCCEEDED(hr) )
      hr = pQuery->Execute(&pEnum);

   return hr;
}

HRESULT CAcctRepl::GetTargetGroupType(WCHAR *sPath, DWORD &grpType)
{
   // Here we lookup the group type for the object denoted by the path
   IADsGroup               * pGrp = NULL;
   HRESULT                   hr = S_OK;
   _variant_t                var;

   hr = ADsGetObject(sPath, IID_IADsGroup, (void**)&pGrp);
   if (SUCCEEDED(hr))
      hr = pGrp->Get(L"groupType", &var);

   if (SUCCEEDED(hr))
   {
      grpType = var.lVal;
   }

   if ( pGrp ) pGrp->Release();
   return hr;
}

// CheckBuiltInWithNTApi - This function makes sure that the account really is a 
//                          builtin account with the NT APIs. In case of NT4 accounts
//                         there are certain special accounts that the WinNT provider
//                         gives us a SID that is the SYSTEM sid ( example Service ).
//                         To make sure that this account exists we use LookupAccountName
//                         with domain qualified account name to make sure that the account
//                         is really builtin or not.
BOOL CAcctRepl::CheckBuiltInWithNTApi(PSID pSid, WCHAR *sSam, Options * pOptions)
{
   BOOL                      retVal = TRUE;
   WCHAR                     sName[LEN_Path];
   SID_NAME_USE              use;
   DWORD                     cbDomain = LEN_Path, cbSid = LEN_Path;
   PSID                      pAccSid = new BYTE[LEN_Path];
   WCHAR                     sDomain[LEN_Path];

   if (!pAccSid)
      return TRUE;

   wsprintf(sName, L"%s\\%s", pOptions->srcDomain, sSam);
   if ( LookupAccountName(pOptions->srcComp, sName, pAccSid, &cbSid, sDomain, &cbDomain, &use) )
   {
      // We found the account now we need to check the sid with the sid passed in and if they
      // are the same then this is a builtin account otherwise its not.
      retVal = EqualSid(pSid, pAccSid);
   }
   delete [] pAccSid;
   return retVal;
}

BOOL CAcctRepl::StuffComputerNameinLdapPath(WCHAR *sAdsPath, DWORD nPathLen, WCHAR *sSubPath, Options *pOptions, BOOL bTarget)
{
   BOOL                      ret = FALSE;
   _bstr_t					 sTemp;

   if ((!sAdsPath) || (!sSubPath))
      return FALSE;

   WCHAR * pTemp = wcschr(sSubPath + 7, L'/');     // Filter out the 'LDAP://<domain-name>/' from the path
   if ( pTemp )
   {                           
      sTemp = L"LDAP://";
      if ( bTarget )
         sTemp += (pOptions->tgtComp + 2);
	  else
         sTemp += (pOptions->srcComp + 2);
      sTemp += L"/";
      sTemp += (pTemp + 1);
	  wcsncpy(sAdsPath, sTemp, nPathLen-1);
//         wsprintf(sAdsPath, L"LDAP://%s/%s", pOptions->tgtComp + 2, pTemp + 1);  // LDAP path with the computer name.
//         wsprintf(sAdsPath, L"LDAP://%s/%s", pOptions->srcComp + 2, pTemp + 1);  // LDAP path with the computer name.
      ret = TRUE;
   }
   return ret;
}

BOOL CAcctRepl::DoesTargetObjectAlreadyExist(TAcctReplNode * pAcct, Options * pOptions)
{
   // Check to see if the target object already exists
   WCHAR          sPath[LEN_Path];
   DWORD		  nPathLen = LEN_Path;
   BOOL           bObjectExists = FALSE;
   WCHAR        * pRelativeTgtOUPath;
   WCHAR          path[LEN_Path] = L"";
   IADs         * pAdsTemp = NULL;
   WCHAR          sSrcTemp[LEN_Path];
   WCHAR          *  pTemp = NULL;



   // First, check the target path, to see if an object with the same CN already exists
   if ( ! pOptions->bUndo )
   {
      MakeFullyQualifiedAdsPath(sPath, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
      pRelativeTgtOUPath = wcschr(sPath + UStrLen(L"LDAP://") + 2,L'/');
   }
   else
   {
      UStrCpy(sPath,pAcct->GetTargetPath());
      pRelativeTgtOUPath = wcschr(sPath + UStrLen(L"LDAP://") + 2,L'/');
      
	  if (pRelativeTgtOUPath)
	  {
		  // get the target CN name
		  pTemp = pRelativeTgtOUPath + 1;
		  (*pRelativeTgtOUPath) = 0;
		  do 
		  {
             pRelativeTgtOUPath = wcschr(pRelativeTgtOUPath+1,L',');

		  } while ((pRelativeTgtOUPath) && ( *(pRelativeTgtOUPath-1) == L'\\' ));
	  }
   }

   if ( pRelativeTgtOUPath )
   {
      *pRelativeTgtOUPath = 0;
      if ( pOptions->bUndo && pTemp )
      {
         pAcct->SetTargetName(pTemp);
         // get the source CN name for the account
         UStrCpy(sSrcTemp,pAcct->GetSourcePath());
         WCHAR * start = wcschr(sSrcTemp + UStrLen(L"LDAP://")+2,L'/');
         *start = 0;
         start++;

         WCHAR * comma = start-1;
         do 
         {
            comma = wcschr(comma+1,L',');
         } while ( *(comma-1) == L'\\' );
         *comma = 0;
         pAcct->SetName(start);
      }
      swprintf(path,L"%ls/%ls,%ls",sPath,pAcct->GetTargetName(),pRelativeTgtOUPath+1);
      if ( pOptions->bUndo )
      {
         UStrCpy(pOptions->tgtOUPath,pRelativeTgtOUPath+1);
      }

   }
   else
   {
      MakeFullyQualifiedAdsPath(path, nPathLen, pOptions->tgtOUPath, pOptions->tgtDomain, pOptions->tgtNamingContext);
   }
   HRESULT hr = ADsGetObject(path,IID_IADs,(void**)&pAdsTemp);
   if ( SUCCEEDED(hr) )
   {
      pAdsTemp->Release();
      bObjectExists = TRUE;
   }

   // Also, check the SAM name to see if it exists on the target
   hr = LookupAccountInTarget(pOptions,const_cast<WCHAR*>(pAcct->GetTargetSam()),sPath);
   if ( SUCCEEDED(hr) )
   {
      bObjectExists = TRUE;
   }
   else
   {
      hr = 0;
   }

   return bObjectExists;
}


//-----------------------------------------------------------------------------------------
// UpdateMemberToGroups This function updates the groups that the accounts are members of.
//                      adding this member to all the groups that have been migrated.
//-----------------------------------------------------------------------------------------
HRESULT CAcctRepl::UpdateMemberToGroups(TNodeListSortable * acctList, Options *pOptions, BOOL bGrpsOnly)
{
   TNodeListSortable         newList;
   WCHAR                     mesg[LEN_Path];
   HRESULT                   hr = S_OK;
   BSTR                      sTargetName = NULL;

   // Expand the containers and the membership
   wcscpy(mesg, GET_STRING(IDS_EXPANDING_MEMBERSHIP));
   Progress(mesg);
   // Expand the list to include all the groups that the accounts in this list are members of
   newList.CompareSet(&TNodeCompareAccountType);
   if ( !newList.IsTree() ) newList.SortedToTree();
   // Call expand membership function to get a list of all groups that contain as members objects in our account list
   if ( ExpandMembership( acctList, pOptions, &newList, Progress, bGrpsOnly) )
   {
      if ( newList.IsTree() ) newList.ToSorted();
      TNodeListEnum                   e;
      TAcctReplNode                 * pNode = NULL;
      for ( pNode = (TAcctReplNode *)e.OpenFirst((TNodeList*)&newList); pNode; pNode = (TAcctReplNode*)e.Next())
      {
         // go through each of the account nodes in the newly added account list. Since
         // we have special fields that contain the member information we can use that

         // Find the account node that corresponds to the member information in this node
         Lookup      p;
         p.pName = (WCHAR*) pNode->sMemberName;
         p.pType = (WCHAR*) pNode->sMemberType;
         
         TAcctReplNode * pNodeMember = (TAcctReplNode *) acctList->Find(&TNodeFindAccountName, &p);

		 bool bIgnored = false;
		 if (pNodeMember)
			 bIgnored = ((!pNodeMember->WasReplaced()) && (pNodeMember->GetStatus() & AR_Status_AlreadyExisted));

         // If we found one ( we should always find one. ) and the member was successfuly
         // added or replaced the member information.
         if ( pNodeMember && ((pNodeMember->WasCreated() || pNodeMember->WasReplaced()) || bIgnored))
         {
            // Get the Group pointer and add the target object to the member.
            IADsGroup               * pGroup = NULL;
            hr = ADsGetObject(const_cast<WCHAR*>(pNode->GetTargetPath()), IID_IADsGroup, (void**)&pGroup);
            if ( SUCCEEDED(hr) )
            {
               pGroup->get_Name(&sTargetName);
               if ( pOptions->nochange )
               {
                  VARIANT_BOOL               bIsMem;
                  hr = pGroup->IsMember(const_cast<WCHAR*>(pNodeMember->GetTargetPath()), &bIsMem);
                  if ( SUCCEEDED(hr) )
                  {
                     if ( bIsMem )
                        hr = HRESULT_FROM_WIN32(NERR_UserExists);
                  }
               }
               else
			   {
				     //add the new account to the group
                  hr = pGroup->Add(const_cast<WCHAR*>(pNodeMember->GetTargetPath()));

				  /* if the new account's source account is also in the group, remove it */
                  IIManageDBPtr pDB = pOptions->pDb;
                  IVarSetPtr pVsTemp(__uuidof(VarSet));
                  IUnknown * pUnk;
            
			         //is this account in the migrated objects table	
                  pVsTemp->QueryInterface(IID_IUnknown, (void**) &pUnk);
                  HRESULT hrFind = pDB->raw_GetAMigratedObject(_bstr_t(pNodeMember->GetSourceSam()), pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
                  pUnk->Release();
                  if (hrFind == S_OK)
				  {
					    //remove the source account from the group
					 RemoveSourceAccountFromGroup(pGroup, pVsTemp, pOptions);
				  }
			   }
            }

            if ( SUCCEEDED(hr) )
               err.MsgWrite(0, DCT_MSG_ADDED_TO_GROUP_SS, pNodeMember->GetTargetPath(), (WCHAR*)sTargetName);
            else
            {
			   _bstr_t sGrpName = sTargetName;
			   if (sTargetName == NULL)
			      sGrpName = pNode->GetTargetPath(); 

               hr = BetterHR(hr);
               if ( HRESULT_CODE(hr) == NERR_UserExists )
               {
                  err.MsgWrite(0,DCT_MSG_USER_IN_GROUP_SS,pNodeMember->GetTargetPath(), (WCHAR*)sGrpName);
               }
               else if ( HRESULT_CODE(hr) == NERR_UserNotFound )
               {
                  err.SysMsgWrite(0, hr, DCT_MSG_MEMBER_NONEXIST_SS, pNodeMember->GetTargetPath(), (WCHAR*)sGrpName, hr);
               }
               else
               {
                  // message for the generic failure case
                  err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_ADD_TO_GROUP_SSD, pNodeMember->GetTargetPath(), (WCHAR*)sGrpName, hr);
                  Mark(L"warnings", pNodeMember->GetType());
               }
            }
         }
      }

      // Clean up the list.
      TAcctReplNode           * pNext = NULL;
      for ( pNode = (TAcctReplNode *)e.OpenFirst(&newList); pNode; pNode = pNext)
      {
         pNext = (TAcctReplNode *)e.Next();
         newList.Remove(pNode);
         delete pNode;
      }
   }
   return hr;
}

// This function enumerates all members of the Universal/Global groups and for each member
// checks if that member has been migrated. If it is then it removes the source member and 
// adds the target member.
HRESULT CAcctRepl::ResetMembersForUnivGlobGroups(Options *pOptions, TAcctReplNode *pAcct)
{
   IADsGroup               * pGroup;   
   HRESULT                   hr;
   _bstr_t                   sMember;
   _bstr_t                   sTgtMem;
   WCHAR                     sSrcPath[LEN_Path];
   WCHAR                     sTgtPath[LEN_Path];
   DWORD					 nPathLen = LEN_Path;
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk;
   IADsMembers             * pMembers = NULL;
   IEnumVARIANT            * pEnum = NULL;
   _variant_t                var;

   if ( pAcct->WasReplaced() )
   {
      WCHAR                     subPath[LEN_Path];
      WCHAR                     sPaths[LEN_Path];

      wcscpy(subPath, pAcct->GetTargetPath());
      StuffComputerNameinLdapPath(sPaths, nPathLen, subPath, pOptions, TRUE);
      hr = ADsGetObject(sPaths, IID_IADsGroup, (void**) &pGroup);
      err.MsgWrite(0, DCT_UPDATING_MEMBERS_TO_GROUP_SS, pAcct->GetTargetName(), sPaths);
   }
   else
      return S_OK;

   if ( FAILED(hr) ) return hr;

   hr = pGroup->Members(&pMembers);

   if ( SUCCEEDED(hr) )
   {
      hr = pMembers->get__NewEnum((IUnknown**)&pEnum);
   }

   if ( SUCCEEDED(hr) )
   {
      DWORD dwFet = 0;
      while ( pEnum->Next(1, &var, &dwFet) == S_OK )
      {
         IDispatch * pDisp = var.pdispVal;
         IADs * pAds = NULL;

         pDisp->QueryInterface(IID_IADs, (void**)&pAds);
         pAds->Get(L"distinguishedName", &var);
         pAds->Release();
         sMember = var;
         pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
         hr = pOptions->pDb->raw_GetMigratedObjectBySourceDN(sMember, &pUnk);
         pUnk->Release();
         if ( hr == S_OK )
         {
            // Since we have moved this member we should remove it from the group
            // and add target member to the group.
            sTgtMem = pVs->get(L"MigratedObjects.TargetAdsPath");
            _bstr_t sTgtType = pVs->get(L"MigratedObjects.Type");

            if ( !_wcsicmp(L"computer", (WCHAR*) sTgtType ) )
            {
               MakeFullyQualifiedAdsPath(sSrcPath, nPathLen, (WCHAR*)sMember, pOptions->srcComp + 2, L"");
               MakeFullyQualifiedAdsPath(sTgtPath, nPathLen, (WCHAR*)sTgtMem, pOptions->tgtComp + 2, L"");
//               HRESULT hr1 = pGroup->Remove(sSrcPath);
               pGroup->Remove(sSrcPath);

               if ( ! pOptions->nochange )
                  hr = pGroup->Add(sTgtPath);
               else 
                  hr = 0;

               if ( SUCCEEDED(hr) )
               {
                  err.MsgWrite(0, DCT_REPLACE_MEMBER_TO_GROUP_SSS, (WCHAR*)sMember, (WCHAR*) sTgtMem, pAcct->GetTargetName());
               }
               else
               {
                  err.SysMsgWrite(ErrE, hr, DCT_REPLACE_MEMBER_FAILED_SSS, (WCHAR*)sMember, (WCHAR*) sTgtMem, pAcct->GetTargetName());
               }
            }
         }
      }
   }

   if ( pEnum ) pEnum->Release();
   if ( pMembers ) pMembers->Release();
   return hr;
}

/* This function will get the varset from the action history table for the given
    undo action ID.  We will find the given source name and retrieve the UPN for
	that account */
void CAcctRepl::GetAccountUPN(Options * pOptions, _bstr_t sSName, _bstr_t& sSUPN)
{
   HRESULT hr;
   IUnknown * pUnk = NULL;
   IVarSetPtr  pVsAH(__uuidof(VarSet));

   sSUPN = L"";

   hr = pVsAH->QueryInterface(IID_IUnknown, (void**)&pUnk);

	//fill a varset with the setting from the action to be undone from the Action History table
   if ( SUCCEEDED(hr) )
      hr = pOptions->pDb->raw_GetActionHistory(pOptions->lUndoActionID, &pUnk);

   if (pUnk) pUnk->Release();

   if ( hr == S_OK )
   {
      WCHAR          key[MAX_PATH];
	  bool			 bFound = false;
	  int			 i = 0;
      long           numAccounts = pVsAH->get(GET_BSTR(DCTVS_Accounts_NumItems));
      _bstr_t        tempName;

	  while ((i<numAccounts) && (!bFound))
	  {
         swprintf(key,GET_STRING(DCTVSFmt_Accounts_D),i);
         tempName = pVsAH->get(key);
         if (_wcsicmp((WCHAR*)tempName, (WCHAR*)sSName) == 0)
		 {
			 bFound = true;
             swprintf(key,GET_STRING(DCTVSFmt_Accounts_SourceUPN_D),i);
             sSUPN = pVsAH->get(key);
		 }
		 i++;
	  }//end while
   }//end if S_OK
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 1 NOV 2000                                                  *
 *                                                                   *
 *     This function is responsible for updating the                 *
 * manager\directReports properties for a migrated user or the       *
 * managedBy\managedObjects properties for a migrated group.         *
 *                                                                   *
 *********************************************************************/

//BEGIN UpdateManagement
HRESULT CAcctRepl::UpdateManagement(TNodeListSortable * acctList, Options *pOptions)
{
/* local variables */
   HRESULT					 hr = S_OK;
   TAcctReplNode           * pAcct;
   IEnumVARIANT            * pEnum;
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   INetObjEnumeratorPtr      pQuery2(__uuidof(NetObjEnumerator));
   LPWSTR                    sUCols[] = { L"directReports",L"managedObjects", L"manager"};
   int                       nUCols = DIM(sUCols);
   LPWSTR                    sGCols[] = { L"managedBy" };
   int                       nGCols = DIM(sGCols);
   SAFEARRAY               * cols;
   SAFEARRAYBOUND            bdU = { nUCols, 0 };
   SAFEARRAYBOUND            bdG = { nGCols, 0 };
   BSTR  HUGEP             * pData = NULL;
   _bstr_t                   sQuery;
   _variant_t                varMgr;
   _variant_t                varDR;
   _variant_t                varMdO;
   _variant_t                varMain;
   _variant_t   HUGEP      * pDt, * pVar;
   DWORD                     dwf;
   _bstr_t                   sTPath;
   _bstr_t                   sPath;
   _bstr_t                   sSam;
   _bstr_t                   sType;
   _bstr_t                   sName;
   long                      lgrpType;
   WCHAR                     mesg[LEN_Path];
   IADs					   * pDSE = NULL;
   WCHAR                     strText[LEN_Path];
   _variant_t				 varGC;

/* function body */
      //change from a tree to a sorted list
   if ( acctList->IsTree() ) acctList->ToSorted();

      //prepare to connect to the GC
   _bstr_t	sGCDomain = pOptions->srcDomainDns;
   swprintf(strText,L"LDAP://%ls/RootDSE",pOptions->srcDomainDns);
   hr = ADsGetObject(strText,IID_IADs,(void**)&pDSE);
   if ( SUCCEEDED(hr) )
   {
      hr = pDSE->Get(L"RootDomainNamingContext",&varGC);
      if ( SUCCEEDED(hr) )
	     sGCDomain = GetDomainDNSFromPath(varGC.bstrVal);
   }
   _bstr_t sGCPath = _bstr_t(L"GC://") + sGCDomain;

      //for each account migrated, if not excluded, migrate the manager\directReports
   for ( pAcct = (TAcctReplNode*)acctList->Head(); pAcct; pAcct = (TAcctReplNode*)pAcct->Next())
   {
      if ( pOptions->pStatus )
      {
         LONG                status = 0;
         HRESULT             hr = pOptions->pStatus->get_Status(&status);
      
         if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
         {
            if ( !bAbortMessageWritten ) 
            {
               err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
               bAbortMessageWritten = true;
            }
            break;
         }
      }

         //update the message
      wsprintf(mesg, GET_STRING(IDS_UPDATING_MGR_PROPS_S), pAcct->GetName());
      Progress(mesg);

	     //build the path to the source object
      WCHAR sPathSource[LEN_Path];
	  DWORD	nPathLen = LEN_Path;
      StuffComputerNameinLdapPath(sPathSource, nPathLen, const_cast<WCHAR*>(pAcct->GetSourcePath()), pOptions, FALSE);

	     //connect to the GC instead of a specific DC
      WCHAR * pTemp = wcschr(sPathSource + 7, L'/');
      if ( pTemp )
	  {
	     _bstr_t sNewPath = sGCPath + _bstr_t(pTemp);
	     wcscpy(sPathSource, sNewPath);
	  }

	     //for user, migrate the manager\directReports relationship
	  if (!_wcsicmp(pAcct->GetType(), L"user"))
	  {
	        //if the manager property has explicitly been excluded from migration by the user, don't migrate it
	     if ((pOptions->bExcludeProps) && 
			 (IsStringInDelimitedString((WCHAR*)pOptions->sExcUserProps, L"manager", L',')))
		    continue;

         /* get the "manager", and "directReports", and "managedObjects" property */
            //build the column array
         cols = SafeArrayCreate(VT_BSTR, 1, &bdU);
         SafeArrayAccessData(cols, (void HUGEP **) &pData);
         for ( int i = 0; i < nUCols; i++)
            pData[i] = SysAllocString(sUCols[i]);
         SafeArrayUnaccessData(cols);
            
         sQuery = L"(objectClass=*)";

            //query the information
         hr = pQuery->raw_SetQuery(sPathSource, pOptions->srcDomain, sQuery, ADS_SCOPE_SUBTREE, TRUE);
         if (FAILED(hr)) return FALSE;
         hr = pQuery->raw_SetColumns(cols);
         if (FAILED(hr)) return FALSE;
         hr = pQuery->raw_Execute(&pEnum);
         if (FAILED(hr)) return FALSE;

         while (pEnum->Next(1, &varMain, &dwf) == S_OK)
         {
            SAFEARRAY * vals = V_ARRAY(&varMain);
               // Get the VARIANT Array out
            SafeArrayAccessData(vals, (void HUGEP**) &pDt);
            varDR =  pDt[0];
			varMdO = pDt[1];
            varMgr = pDt[2];
            SafeArrayUnaccessData(vals);
            
			   //process the manager by setting the manager on the moved user if the
			   //source user's manager has been migrated
			if ( varMgr.vt & VT_ARRAY )
            {
                  //we always get an Array of variants
               SAFEARRAY * multiVals = varMgr.parray; 
               SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
               for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
               {
                  _bstr_t sManager = _bstr_t(V_BSTR(&pVar[dw]));
                  sManager = PadDN(sManager);
				  _bstr_t sSrcDomain = GetDomainDNSFromPath(sManager);
                  sPath = _bstr_t(L"LDAP://") + sSrcDomain + _bstr_t(L"/") + sManager;
                  if (GetSamFromPath(sPath, sSam, sType, sName, lgrpType, pOptions))
				  {
                     IVarSetPtr                pVs(__uuidof(VarSet));
                     IUnknown                * pUnk = NULL;
				     pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);
					 WCHAR					   sDomainNB[LEN_Path];
					 WCHAR					   sDNS[LEN_Path];

					    //get NetBIOS of the objects source domain
                     GetDnsAndNetbiosFromName(sSrcDomain, sDomainNB, sDNS);

                        // See if the manager was migrated
                     hr = pOptions->pDb->raw_GetAMigratedObjectToAnyDomain((WCHAR*)sSam, sDomainNB, &pUnk);
                     if ( hr == S_OK )
					 {
					    _variant_t var;
                           //get the manager's target adspath
                        var = pVs->get(L"MigratedObjects.TargetAdsPath");
                        sTPath = V_BSTR(&var);
                        if ( wcslen((WCHAR*)sTPath) > 0 )
						{
			               IADsUser       * pUser = NULL;
                              //set the manager on the target object
                           hr = ADsGetObject((WCHAR*)pAcct->GetTargetPath(), IID_IADsUser, (void**)&pUser);
                           if ( SUCCEEDED(hr) )
						   {
							  _bstr_t sTemp = _bstr_t(wcsstr((WCHAR*)sTPath, L"CN="));
						      var = sTemp;
                              hr = pUser->Put(L"Manager", var);   
                              if ( SUCCEEDED(hr) )
							  {
						         hr = pUser->SetInfo();
                                 if (FAILED(hr))
                                    err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
							  }
						      else
                                 err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
                              pUser->Release();
						   }
						   else
                              err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
						}//end if got the path to the manager on the target
					 }//end if manager was migrated
				     pUnk->Release();
				  }//end if got source sam
			   }//for each manager (only one)
               SafeArrayUnaccessData(multiVals);
            }//end if variant array (it will be)

			   //process the directReports by setting the manager on the previously moved 
			   //user if the source user's manager has been migrated
			if ( varDR.vt & VT_ARRAY )
            {
                  //we always get an Array of variants
               SAFEARRAY * multiVals = varDR.parray; 
               SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
               for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
               {
                  _bstr_t sDirectReport = _bstr_t(V_BSTR(&pVar[dw]));
                  sDirectReport = PadDN(sDirectReport);
				  _bstr_t sSrcDomain = GetDomainDNSFromPath(sDirectReport);
                  sPath = _bstr_t(L"LDAP://") + sSrcDomain + _bstr_t(L"/") + sDirectReport;
                  if (GetSamFromPath(sPath, sSam, sType, sName, lgrpType, pOptions))
				  {
                     IVarSetPtr                pVs(__uuidof(VarSet));
                     IUnknown                * pUnk = NULL;
				     pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);
					 WCHAR					   sDomainNB[LEN_Path];
					 WCHAR					   sDNS[LEN_Path];

					    //get NetBIOS of the objects source domain
                     GetDnsAndNetbiosFromName(sSrcDomain, sDomainNB, sDNS);

                        // See if the direct report was migrated
                     hr = pOptions->pDb->raw_GetAMigratedObjectToAnyDomain((WCHAR*)sSam, sDomainNB, &pUnk);
                     if ( hr == S_OK )
					 {
					    _variant_t var;
                           //get the direct report's target adspath
                        var = pVs->get(L"MigratedObjects.TargetAdsPath");
                        sTPath = V_BSTR(&var);
                        if ( wcslen((WCHAR*)sTPath) > 0 )
						{
			               IADsUser       * pUser = NULL;
                              //set the manager on the target object
                           hr = ADsGetObject(sTPath, IID_IADsUser, (void**)&pUser);
                           if ( SUCCEEDED(hr) )
						   {
							  _bstr_t sTemp = _bstr_t(wcsstr((WCHAR*)pAcct->GetTargetPath(), L"CN="));
						      var = sTemp;
                              hr = pUser->Put(L"Manager", var);   
                              if ( SUCCEEDED(hr) )
							  {
						         hr = pUser->SetInfo();
                                 if (FAILED(hr))
                                    err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
							  }
							  else
                                 err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
                              pUser->Release();
						   }
						   else
                              err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
						}//end if got the path to the manager on the target
					 }//end if manager was migrated
				     pUnk->Release();
				  }//end if got source sam
			   }//for each directReport
               SafeArrayUnaccessData(multiVals);
            }//end if variant array (it will be)

            /* get the "managedObjects" property */
			   //process the managedObjects by setting the managedBy on the moved group if the
			   //source user's managed group has been migrated
			if ( varMdO.vt & VT_ARRAY )
            {
                  //we always get an Array of variants
               SAFEARRAY * multiVals = varMdO.parray; 
               SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
               for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
               {
                  _bstr_t sManaged = _bstr_t(V_BSTR(&pVar[dw]));
                  sManaged = PadDN(sManaged);
				  _bstr_t sSrcDomain = GetDomainDNSFromPath(sManaged);
                  sPath = _bstr_t(L"LDAP://") + sSrcDomain + _bstr_t(L"/") + sManaged;
                  if (GetSamFromPath(sPath, sSam, sType, sName, lgrpType, pOptions))
				  {
                     IVarSetPtr                pVs(__uuidof(VarSet));
                     IUnknown                * pUnk = NULL;
				     pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);
					 WCHAR					   sDomainNB[LEN_Path];
					 WCHAR					   sDNS[LEN_Path];

					    //get NetBIOS of the objects source domain
                     GetDnsAndNetbiosFromName(sSrcDomain, sDomainNB, sDNS);

                        // See if the managed object was migrated
                     hr = pOptions->pDb->raw_GetAMigratedObjectToAnyDomain((WCHAR*)sSam, sDomainNB, &pUnk);
                     if ( hr == S_OK )
					 {
					    _variant_t var;
                           //get the managed object's target adspath
                        var = pVs->get(L"MigratedObjects.TargetAdsPath");
                        sTPath = V_BSTR(&var);
                        if ( wcslen((WCHAR*)sTPath) > 0 )
						{
			               IADsGroup       * pGroup = NULL;
                              //set the manager on the target object
                           hr = ADsGetObject(sTPath, IID_IADsGroup, (void**)&pGroup);
                           if ( SUCCEEDED(hr) )
						   {
							  _bstr_t sTemp = _bstr_t(wcsstr((WCHAR*)pAcct->GetTargetPath(), L"CN="));
						      var = sTemp;
                              hr = pGroup->Put(L"ManagedBy", var);   
                              if ( SUCCEEDED(hr) )
							  {
						         hr = pGroup->SetInfo();
                                 if (FAILED(hr))
                                    err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
							  }
							  else
                                 err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
                              pGroup->Release();
						   }
						   else
                              err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)pAcct->GetTargetPath(), (WCHAR*)sTPath, hr);
						}//end if got the path to the manager on the target
					 }//end if manager was migrated
				  	 pUnk->Release();
				  }//end if got source sam
			   }//for each manager (only one)
               SafeArrayUnaccessData(multiVals);
            }//end if variant array (it will be)

            varMgr.Clear();
            varMdO.Clear();
            varDR.Clear();
            VariantInit(&varMain); // data not owned by varMain so clear VARTYPE
		 }

         if (pEnum)
		    pEnum->Release();
//         SafeArrayDestroy(cols);
      }//end if user

	     //for group, migrate the managedBy\managedObjects relationship
	  if (!_wcsicmp(pAcct->GetType(), L"group"))
	  {
	        //if the managedBy property has explicitly been excluded from migration by the user, don't migrate it
	     if (IsStringInDelimitedString((WCHAR*)pOptions->sExcGroupProps, L"managedBy", L','))
		    continue;

         /* get the "managedBy" property */
            //build the column array
         cols = SafeArrayCreate(VT_BSTR, 1, &bdG);
         SafeArrayAccessData(cols, (void HUGEP **) &pData);
         for ( int i = 0; i < nGCols; i++)
            pData[i] = SysAllocString(sGCols[i]);
         SafeArrayUnaccessData(cols);
            
         sQuery = L"(objectClass=*)";

            //query the information
         hr = pQuery->raw_SetQuery(sPathSource, pOptions->srcDomain, sQuery, ADS_SCOPE_BASE, TRUE);
         if (FAILED(hr)) return FALSE;
         hr = pQuery->raw_SetColumns(cols);
         if (FAILED(hr)) return FALSE;
         hr = pQuery->raw_Execute(&pEnum);
         if (FAILED(hr)) return FALSE;

         while (pEnum->Next(1, &varMain, &dwf) == S_OK)
         {
            SAFEARRAY * vals = V_ARRAY(&varMain);
               // Get the VARIANT Array out
            SafeArrayAccessData(vals, (void HUGEP**) &pDt);
            varMgr = pDt[0];
            SafeArrayUnaccessData(vals);
            
			   //process the managedBy by setting the managedBy on the moved group if the
			   //source group's manager has been migrated
			if ( varMgr.vt & VT_BSTR )
            {
               _bstr_t sManager = varMgr;
               sManager = PadDN(sManager);
			   _bstr_t sSrcDomain = GetDomainDNSFromPath(sManager);
               sPath = _bstr_t(L"LDAP://") + sSrcDomain + _bstr_t(L"/") + sManager;
               if (GetSamFromPath(sPath, sSam, sType, sName, lgrpType, pOptions))
			   {
                  IVarSetPtr                pVs(__uuidof(VarSet));
                  IUnknown                * pUnk = NULL;
				  pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);
				  WCHAR					    sDomainNB[LEN_Path];
				  WCHAR					    sDNS[LEN_Path];

					 //get NetBIOS of the objects source domain
                  GetDnsAndNetbiosFromName(sSrcDomain, sDomainNB, sDNS);

                     // See if the manager was migrated
                  hr = pOptions->pDb->raw_GetAMigratedObjectToAnyDomain((WCHAR*)sSam, sDomainNB, &pUnk);
                  if ( hr == S_OK )
				  {
				     _variant_t var;
                        //get the manager's target adspath
                     var = pVs->get(L"MigratedObjects.TargetAdsPath");
                     sTPath = V_BSTR(&var);
                     if ( wcslen((WCHAR*)sTPath) > 0 )
					 {
			            IADsGroup       * pGroup = NULL;
                           //set the manager on the target object
                        hr = ADsGetObject((WCHAR*)pAcct->GetTargetPath(), IID_IADsGroup, (void**)&pGroup);
                        if ( SUCCEEDED(hr) )
						{
						   _bstr_t sTemp = _bstr_t(wcsstr((WCHAR*)sTPath, L"CN="));
						   var = sTemp;
                           hr = pGroup->Put(L"ManagedBy", var);   
                           if ( SUCCEEDED(hr) )
						   {
						      hr = pGroup->SetInfo();
                              if (FAILED(hr))
                                 err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
						   }
						   else
                              err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
                           pGroup->Release();
						}
						else
                           err.SysMsgWrite(0, hr, DCT_MSG_MANAGER_MIG_FAILED, (WCHAR*)sTPath, (WCHAR*)pAcct->GetTargetPath(), hr);
					 }//end if got the path to the manager on the target
				  }//end if manager was migrated
				  pUnk->Release();
			   }//end if got source sam
            }//end if variant array (it will be)

            VariantClear(&varMgr);
            VariantClear(&varMain);
		 }

         if (pEnum)
		    pEnum->Release();
//         SafeArrayDestroy(cols);
	  }//end if group
   }//end for each account being migrated

   wcscpy(mesg, L"");
   Progress(mesg);

   return hr;
}
//END UpdateManagement


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 29 NOV 2000                                                 *
 *                                                                   *
 *     This function is responsible for removing the escape character*
 * in front of any '/' characters.                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN GetUnEscapedNameWithFwdSlash
_bstr_t CAcctRepl::GetUnEscapedNameWithFwdSlash(_bstr_t strName)
{
/* local variables */
	WCHAR   szNameOld[MAX_PATH];
	WCHAR   szNameNew[MAX_PATH];
	WCHAR * pchBeg = NULL;
	_bstr_t sNewName = L"";

/* function body */
	if (strName.length())
	{
		safecopy(szNameOld, (WCHAR*)strName);
		for (WCHAR* pch = wcschr(szNameOld, _T('\\')); pch; pch = wcschr(pch + 1, _T('\\')))
		{
			if ((*(pch + 1)) == L'/')
			{
				if (pchBeg == NULL)
				{
					wcsncpy(szNameNew, szNameOld, pch - szNameOld);
					szNameNew[pch - szNameOld] = L'\0';
				}
				else
				{
					size_t cch = wcslen(szNameNew);
					wcsncat(szNameNew, pchBeg, pch - pchBeg);
					szNameNew[cch + (pch - szNameOld)] = L'\0';
				}

				pchBeg = pch + 1;
			}
		}

		if (pchBeg == NULL)
			wcscpy(szNameNew, szNameOld);
		else
			wcscat(szNameNew, pchBeg);

		sNewName = szNameNew;
	}

	return sNewName;
}
//END GetUnEscapedNameWithFwdSlash


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 29 NOV 2000                                                 *
 *                                                                   *
 *     This function is responsible for gets the CN name of an object*
 * from an ADsPath and returns that CN name if it was retrieved or   *
 * NULL otherwise.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN GetCNFromPath
_bstr_t CAcctRepl::GetCNFromPath(_bstr_t sPath)
{
/* local variables */
   BOOL bFound = FALSE;
   WCHAR sName[MAX_PATH];
   WCHAR sTempPath[MAX_PATH];
   _bstr_t sCNName = L"";
   WCHAR * sTempDN;
  
/* function body */
   if (sPath.length() > 0)
   {
      wcscpy(sTempPath, (WCHAR*)sPath);
      sTempDN = wcsstr(sTempPath, L"CN=");
      if (sTempDN)
      {
         wcscpy(sName, sTempDN);
         sTempDN = wcsstr(sName, L",OU=");
         if (sTempDN)
         {
            bFound = TRUE;
            *sTempDN = L'\0';
         }
         sTempDN = wcsstr(sName, L",CN=");
         if (sTempDN)
         {
            bFound = TRUE;
            *sTempDN = L'\0';
         }
         sTempDN = wcsstr(sName, L",DC=");
         if (sTempDN)
         {
            bFound = TRUE;
            *sTempDN = L'\0';
         }
      }
   }
   if (bFound)
       sCNName = sName;

   return sCNName;
}
//END GetCNFromPath



/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 FEB 2001                                                 *
 *                                                                   *
 *     This function is responsible for replacing the source account *
 * for a given list of accounts in any local groups they are a member*
 * of on the target, if that account was migrated by ADMT.  This     *
 * function is called during the undo process.                       *
 *                                                                   *
 *********************************************************************/

//BEGIN ReplaceSourceInLocalGroup
BOOL CAcctRepl::ReplaceSourceInLocalGroup(TNodeListSortable *acctlist, //in- Accounts being processed
                                             Options        *pOptions, //in- Options specified by the user
                                             IStatusObj     *pStatus)  // in -status object to support cancellation
{
/* local variables */
   TAcctReplNode           * pAcct;
   IEnumVARIANT            * pEnum;
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   LPWSTR                    sCols[] = { L"memberOf" };
   int                       nCols = DIM(sCols);
   SAFEARRAY               * psaCols;
   SAFEARRAYBOUND            bd = { nCols, 0 };
   BSTR  HUGEP             * pData;
   WCHAR                     sQuery[LEN_Path];
   _variant_t   HUGEP      * pDt, * pVar;
   _variant_t                vx;
   _variant_t                varMain;
   DWORD                     dwf = 0;
   HRESULT                   hr = S_OK;
   _bstr_t					 sDomPath = L"";
   _bstr_t					 sDomain = L"";

/* function body */
   FillNamingContext(pOptions);

      //for each account, enumerate all local groups it is a member of and add the account's
      //source account in that local group
   for ( pAcct = (TAcctReplNode*)acctlist->Head(); pAcct; pAcct = (TAcctReplNode*)pAcct->Next())
   {
      // Do we need to abort ?
      if ( pStatus )
      {
         LONG                status = 0;
         HRESULT             hr = pStatus->get_Status(&status);
         
         if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
         {
            if ( !bAbortMessageWritten ) 
            {
               err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
               bAbortMessageWritten = true;
            }
            break;
         }
      }

         //enumerate the groups this account is a member of
	  sDomain = GetDomainDNSFromPath(pAcct->GetTargetPath());
	  if (!_wcsicmp(pAcct->GetType(), L"user"))
         wsprintf(sQuery, L"(&(sAMAccountName=%s)(objectCategory=Person)(objectClass=user))", pAcct->GetTargetSam());
	  else
         wsprintf(sQuery, L"(&(sAMAccountName=%s)(objectCategory=Group))", pAcct->GetTargetSam());
      psaCols = SafeArrayCreate(VT_BSTR, 1, &bd);
      SafeArrayAccessData(psaCols, (void HUGEP **)&pData);
      for ( int i = 0; i < nCols; i++ )
         pData[i] = SysAllocString(sCols[i]);
      SafeArrayUnaccessData(psaCols);
      hr = pQuery->raw_SetQuery(sDomPath, sDomain, sQuery, ADS_SCOPE_SUBTREE, FALSE);
      if (FAILED(hr)) return FALSE;
      hr = pQuery->raw_SetColumns(psaCols);
      if (FAILED(hr)) return FALSE;
      hr = pQuery->raw_Execute(&pEnum);
      if (FAILED(hr)) return FALSE;

	     //while more groups
      while (pEnum->Next(1, &varMain, &dwf) == S_OK)
      {
         SAFEARRAY * vals = V_ARRAY(&varMain);
         // Get the VARIANT Array out
         SafeArrayAccessData(vals, (void HUGEP**) &pDt);
         vx = pDt[0];
         SafeArrayUnaccessData(vals);
         if ( vx.vt == VT_BSTR )
         {
			_bstr_t            sPath;
            BSTR              sGrpName = NULL;
			IADsGroup		* pGrp = NULL;
			_variant_t         var;

            _bstr_t sDN = vx.bstrVal;
		    if (wcslen((WCHAR*)sDN) == 0)
			   continue;

            sDN = PadDN(sDN);
            sPath = _bstr_t(L"LDAP://") + sDomain + _bstr_t(L"/") + sDN;

			   //connect to the target group
		    hr = ADsGetObject(sPath, IID_IADsGroup, (void**)&pGrp);
			if (FAILED(hr))
			   continue;
			
			   //get this group's type and name				 
            hr = pGrp->get_Name(&sGrpName);
            hr = pGrp->Get(L"groupType", &var);

			   //if this is a local group, get this account source path and add it as a member
            if ((SUCCEEDED(hr)) && (var.lVal & 4))
			{
			      //add the account's source account to the local group, using the sid string format
			   WCHAR  strSid[MAX_PATH] = L"";
			   WCHAR  strRid[MAX_PATH] = L"";
			   DWORD  lenStrSid = DIM(strSid);
			   GetTextualSid(pAcct->GetSourceSid(), strSid, &lenStrSid);
               _bstr_t sSrcDmSid = strSid;
               _ltow((long)(pAcct->GetSourceRid()), strRid, 10);
               _bstr_t sSrcRid = strRid;
               if ((!sSrcDmSid.length()) || (!sSrcRid.length()))
			   {
				  hr = E_INVALIDARG;
                  err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_READD_TO_GROUP_SSD, pAcct->GetSourcePath(), (WCHAR*)sGrpName, hr);
				  continue;
			   }

				  //build an LDAP path to the src object in the group
			   _bstr_t sSrcSid = sSrcDmSid + _bstr_t(L"-") + sSrcRid;
			   _bstr_t sSrcLDAPPath = L"LDAP://";
			   sSrcLDAPPath += _bstr_t(pOptions->tgtComp + 2);
			   sSrcLDAPPath += L"/CN=";
			   sSrcLDAPPath += sSrcSid;
			   sSrcLDAPPath += L",CN=ForeignSecurityPrincipals,";
			   sSrcLDAPPath += pOptions->tgtNamingContext;

			      //add the source account to the local group
			   hr = pGrp->Add(sSrcLDAPPath);
			   if (SUCCEEDED(hr))
                  err.MsgWrite(0,DCT_MSG_READD_MEMBER_TO_GROUP_SS, pAcct->GetSourcePath(), (WCHAR*)sGrpName);
			   else
                  err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_READD_TO_GROUP_SSD, pAcct->GetSourcePath(), (WCHAR*)sGrpName, hr);
			}//end if local group
			if (pGrp) 
			   pGrp->Release();
		 }//end if bstr
		 else if ( vx.vt & VT_ARRAY )
         {
            // We must have got an Array of multivalued properties
            // Access the BSTR elements of this variant array
            SAFEARRAY * multiVals = vx.parray; 
            SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
			   //for each group
            for ( DWORD dw = 0; dw < multiVals->rgsabound->cElements; dw++ )
            {
               // Do we need to abort ?
               if ( pStatus )
			   {
                  LONG                status = 0;
                  HRESULT             hr = pStatus->get_Status(&status);
         
                  if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
				  {
                     if ( !bAbortMessageWritten ) 
					 {
                        err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                        bAbortMessageWritten = true;
					 }
                     break;
				  }
			   }
			   _bstr_t            sPath;
               BSTR               sGrpName = NULL;
			   IADsGroup		* pGrp = NULL;
			   _variant_t         var;

               _bstr_t sDN = _bstr_t(V_BSTR(&pVar[dw]));
               sDN = PadDN(sDN);
               sPath = _bstr_t(L"LDAP://") + sDomain + _bstr_t(L"/") + sDN;

			      //connect to the target group
		       hr = ADsGetObject(sPath, IID_IADsGroup, (void**)&pGrp);
			   if (FAILED(hr))
			      continue;
			
			      //get this group's type and name				 
               hr = pGrp->get_Name(&sGrpName);
               hr = pGrp->Get(L"groupType", &var);

			      //if this is a local group, get this account source path and add it as a member
               if ((SUCCEEDED(hr)) && (var.lVal & 4))
			   {
			         //add the account's source account to the local group, using the sid string format
			      WCHAR  strSid[MAX_PATH];
				  WCHAR  strRid[MAX_PATH];
				  DWORD  lenStrSid = DIM(strSid);
			      GetTextualSid(pAcct->GetSourceSid(), strSid, &lenStrSid);
                  _bstr_t sSrcDmSid = strSid;
                  _ltow((long)(pAcct->GetSourceRid()), strRid, 10);
                  _bstr_t sSrcRid = strRid;
                  if ((!sSrcDmSid.length()) || (!sSrcRid.length()))
				  {
				     hr = E_INVALIDARG;
                     err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_READD_TO_GROUP_SSD, pAcct->GetSourcePath(), (WCHAR*)sGrpName, hr);
				     continue;
				  }

				     //build an LDAP path to the src object in the group
				  _bstr_t sSrcSid = sSrcDmSid + _bstr_t(L"-") + sSrcRid;
				  _bstr_t sSrcLDAPPath = L"LDAP://";
				  sSrcLDAPPath += _bstr_t(pOptions->tgtComp + 2);
				  sSrcLDAPPath += L"/CN=";
				  sSrcLDAPPath += sSrcSid;
				  sSrcLDAPPath += L",CN=ForeignSecurityPrincipals,";
				  sSrcLDAPPath += pOptions->tgtNamingContext;

				     //add the source account to the local group
				  hr = pGrp->Add(sSrcLDAPPath);
			      if (SUCCEEDED(hr))
                     err.MsgWrite(0,DCT_MSG_READD_MEMBER_TO_GROUP_SS, pAcct->GetSourcePath(), (WCHAR*)sGrpName);
			      else
                     err.SysMsgWrite(ErrW, hr, DCT_MSG_FAILED_TO_READD_TO_GROUP_SSD, pAcct->GetSourcePath, (WCHAR*)sGrpName, hr);
			   }//end if local group
			   if (pGrp) 
			      pGrp->Release();
            }//end for each group
            SafeArrayUnaccessData(multiVals);
         }//end if array of groups
      }//end while groups
      pEnum->Release();
      VariantInit(&vx);
      VariantInit(&varMain);
      SafeArrayDestroy(psaCols);
   }//end for each account

   return TRUE;
}
//END ReplaceSourceInLocalGroup


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 MAR 2001                                                  *
 *                                                                   *
 *     This function is responsible for retrieving the actual source *
 * domain, from the Migrated Objects table, of a given path if that  *
 * path is one to a foreign security principal.                      *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDomainOfMigratedForeignSecPrincipal
_bstr_t CAcctRepl::GetDomainOfMigratedForeignSecPrincipal(_bstr_t sPath)
{
/* local variables */
   IVarSetPtr      pVs(__uuidof(VarSet));
   IUnknown      * pUnk = NULL;
   IADs          * pTempAds = NULL;
   HRESULT         hr = S_OK;   
   _variant_t      varName;
   _bstr_t		   sDomainSid, sRid;
   _bstr_t		   sDomain = L"";
   BOOL			   bSplit = FALSE;

/* function body */
      //if this account is outside the domain, lookup the account
	  //in the migrated objects table to retrieve it's actual source domain
   if (wcsstr((WCHAR*)sPath, L"CN=ForeignSecurityPrincipals"))
   {
         //get the sid of this account
      hr = ADsGetObject(sPath,IID_IADs,(void**)&pTempAds);
      if (SUCCEEDED(hr))
      {
         hr = pTempAds->Get(SysAllocString(L"name"),&varName);
         pTempAds->Release();
	     if (SUCCEEDED(hr))
		 {
			WCHAR sName[MAX_PATH];
			_bstr_t sTempName = varName;
			
			wcscpy(sName, sTempName);
			   //break the sid into domain sid and account rid
			WCHAR * pTemp = wcsrchr(sName, L'-');
			if (pTemp)
			{
			   sRid = (pTemp + 1);
			   *pTemp = L'\0';
			   sDomainSid = sName;
			   bSplit = TRUE;
			}
		 }
	  }
	
	     //if we got the rid and domain sid, look in MOT for account's
		 //real source domain
	  if (bSplit)
	  {
         pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
         try 
		 {
            IIManageDBPtr   pDB(CLSID_IManageDB);
            hr = pDB->raw_GetAMigratedObjectBySidAndRid(sDomainSid, sRid, &pUnk);
            if (SUCCEEDED(hr))
		       sDomain = pVs->get(L"MigratedObjects.SourceDomain");
		 }
         catch(_com_error& e)
		 {
            hr = e.Error();
		 }
         catch(...)
		 {
            hr = E_FAIL;
		 }
         
		 if (pUnk)
            pUnk->Release();
	  }
   }

   return sDomain;
}
//END GetDomainOfMigratedForeignSecPrincipal


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 APR 2001                                                 *
 *                                                                   *
 *     This function is responsible for removing the source account  *
 * object, represented by its VarSet entry from the Migrated Objects *
 * Table, from the given group.  This helper function is used by     *
 * "UpdateMemberToGroups" and "UpdateGroupMembership" after          *
 * successfully adding the cloned account to this same group.        *
 *                                                                   *
 *********************************************************************/

//BEGIN RemoveSourceAccountFromGroup
void CAcctRepl::RemoveSourceAccountFromGroup(IADsGroup * pGroup, IVarSetPtr pMOTVarSet, Options * pOptions)
{
/* local variables */
   _bstr_t			sSrcDmSid, sSrcRid, sSrcPath, sGrpName = L"";
   BSTR             bstrGrpName = NULL;
   HRESULT			hr = S_OK;   

/* function body */
      //get the target group's name
   hr = pGroup->get_Name(&bstrGrpName);
   if ( SUCCEEDED(hr) )
	  sGrpName = bstrGrpName;

      //get the source object's sid from the migrate objects table
   sSrcDmSid = pMOTVarSet->get(L"MigratedObjects.SourceDomainSid");
   sSrcRid = pMOTVarSet->get(L"MigratedObjects.SourceRid");
   sSrcPath = pMOTVarSet->get(L"MigratedObjects.SourceAdsPath");
   if ((wcslen((WCHAR*)sSrcDmSid) > 0) && (wcslen((WCHAR*)sSrcPath) > 0) 
       && (wcslen((WCHAR*)sSrcRid) > 0))
   {
         //build an LDAP path to the src object in the group
      _bstr_t sSrcSid = sSrcDmSid + _bstr_t(L"-") + sSrcRid;
	  _bstr_t sSrcLDAPPath = L"LDAP://";
	  sSrcLDAPPath += _bstr_t(pOptions->tgtComp + 2);
	  sSrcLDAPPath += L"/CN=";
	  sSrcLDAPPath += sSrcSid;
	  sSrcLDAPPath += L",CN=ForeignSecurityPrincipals,";
	  sSrcLDAPPath += pOptions->tgtNamingContext;
						
	  VARIANT_BOOL bIsMem = VARIANT_FALSE;
	     //got the source LDAP path, now see if that account is in the group
	  pGroup->IsMember(sSrcLDAPPath, &bIsMem);
	  if (bIsMem)
	  {
		 hr = pGroup->Remove(sSrcLDAPPath);//remove the src account
		 if ( SUCCEEDED(hr) )
			err.MsgWrite(0,DCT_MSG_REMOVE_FROM_GROUP_SS, (WCHAR*)sSrcPath, (WCHAR*)sGrpName);
	  }
   }
}
//END RemoveSourceAccountFromGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\checker.h ===
// AccessChecker.h : Declaration of the CAccessChecker

#ifndef __ACCESSCHECKER_H_
#define __ACCESSCHECKER_H_

#include "resource.h"       // main symbols

#include "WorkObj.h"
/////////////////////////////////////////////////////////////////////////////
// CAccessChecker
class ATL_NO_VTABLE CAccessChecker : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAccessChecker, &CLSID_AccessChecker>,
	public IDispatchImpl<IAccessChecker, &IID_IAccessChecker, &LIBID_MCSDCTWORKEROBJECTSLib>
{
public:
	CAccessChecker()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_ACCESSCHECKER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAccessChecker)
	COM_INTERFACE_ENTRY(IAccessChecker)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IAccessChecker
public:
	STDMETHOD(IsInSameForest)(BSTR srcDomain, BSTR tgtDomain, /*[out]*/ BOOL * pbIsSame);
	STDMETHOD(CanUseAddSidHistory)(BSTR srcDomain, BSTR tgtDomain, /*[out]*/ LONG * pbCanUseIt);
	STDMETHOD(IsNativeMode)(BSTR Domain, /*[out]*/ BOOL * pbIsNativeMode);
	STDMETHOD(GetOsVersion)(BSTR server, /*[out]*/ DWORD * pdwVerMaj, /*[out]*/ DWORD * pdwVerMin, /*[out]*/ DWORD * pdwVerSP);
	STDMETHOD(IsAdmin)(BSTR user, BSTR server, /*[out]*/ BOOL * pbIsAdmin);
   STDMETHOD(GetPasswordPolicy)(BSTR domain,/*[out]*/ LONG * dwPasswordLength);
   STDMETHOD(EnableAuditing)(/*[in]*/BSTR sDC);
   STDMETHOD(AddRegKey)(/*[in]*/BSTR sDC,LONG bReboot);
   STDMETHOD(AddLocalGroup)(/*[in]*/BSTR srcDomain,/*[in]*/BSTR srcDC);
private:
	long DetectAuditing(BSTR sDC);
};


#endif //__ACCESSCHECKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
//#include "WorkerObjects_p.c"
#include "WorkObj_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\chdom.h ===
/*---------------------------------------------------------------------------
  File: ChangeDomain.h

  Comments: Implementation class definition for COM object to change the domain
  affiliation of a remote computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:19

 ---------------------------------------------------------------------------
*/

// ChangeDomain.h : Declaration of the CChangeDomain

#ifndef __CHANGEDOMAIN_H_
#define __CHANGEDOMAIN_H_

#include "resource.h"       // main symbols
#include <comdef.h>

/////////////////////////////////////////////////////////////////////////////
// CChangeDomain
class ATL_NO_VTABLE CChangeDomain : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CChangeDomain, &CLSID_ChangeDomain>,
	public IDispatchImpl<IChangeDomain, &IID_IChangeDomain, &LIBID_MCSDCTWORKEROBJECTSLib>
{
   _bstr_t                   m_domain;
   _bstr_t                   m_account;
   _bstr_t                   m_password;
   _bstr_t                   m_domainAccount;
   BOOL                      m_bNoChange;

public:
	CChangeDomain()
	{
	   m_bNoChange = FALSE;
   }

DECLARE_REGISTRY_RESOURCEID(IDR_CHANGEDOMAIN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CChangeDomain)
	COM_INTERFACE_ENTRY(IChangeDomain)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IWorkNode
public:
   STDMETHOD(Process)(IUnknown *pWorkItem);
	
// IChangeDomain
public:
	STDMETHOD(get_NoChange)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_NoChange)(/*[in]*/ BOOL newVal);
	STDMETHOD(ConnectAs)(BSTR domain, BSTR user, BSTR password);
	STDMETHOD(ChangeToWorkgroup)(BSTR Computer, BSTR Workgroup, /*[out]*/ BSTR * errStatus);
	STDMETHOD(ChangeToDomain)(BSTR ActiveComputerName, BSTR Domain, BSTR TargetComputerName, /*[out]*/ BSTR * errStatus);
	STDMETHOD(ChangeToDomainWithSid)(BSTR ActiveComputerName, BSTR Domain,BSTR DomainSid, BSTR DomainController, BSTR TargetComputerName, BSTR SrcPath, /*[out]*/ BSTR * errStatus);
};

#endif //__CHANGEDOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\checker.cpp ===
// AccessChecker.cpp : Implementation of CAccessChecker
#include "stdafx.h"
#include "WorkObj.h"
#include "Checker.h"
#include <lm.h>
#include <dsgetdc.h>
#include <iads.h>
#include <comdef.h>
//#include <adshlp.h>
#include "treg.hpp"
#include "BkupRstr.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include "IsAdmin.hpp"
#include <ntsecapi.h>
#include <winerror.h>
#include "sidflags.h"
#include "rebootU.h"
#include "ResStr.h"
#include "Win2KErr.h"

//#import "\bin\NetEnum.tlb" no_namespace 
#import "NetEnum.tlb" no_namespace 

// Win2k function
typedef HRESULT (CALLBACK * DSGETDCNAME)(LPWSTR, LPWSTR, GUID*, LPWSTR, DWORD, PDOMAIN_CONTROLLER_INFO*);
typedef HRESULT (CALLBACK * ADSGETOBJECT)(LPWSTR, REFIID, void**);


/////////////////////////////////////////////////////////////////////////////
// CAccessChecker


STDMETHODIMP CAccessChecker::IsAdmin(BSTR user, BSTR server, BOOL * pbIsAdmin)
{
	HRESULT                   hr = 0;

   // initialize output variable
   (*pbIsAdmin) = FALSE;

   if ( ! user || ! *user )
   {
      // check the currently logged in account
//      if ( ! server || ! *server )
//      {
//         hr = IsAdminLocal();
//      }
//      else
//      {
//         hr = IsAdminRemote((WCHAR*)server);
//      }
      // removing explicit administrator check
      hr = S_OK;
      if ( hr == ERROR_SUCCESS )
      {
         (*pbIsAdmin) = TRUE;
      }
      else if ( hr == ERROR_ACCESS_DENIED )
      {
         (*pbIsAdmin) = FALSE;
         hr = S_OK;
      }
      else
      {
         hr = HRESULT_FROM_WIN32(hr);
      }
   }
   else
   {
      hr = E_NOTIMPL;
   }
   return hr;
}

STDMETHODIMP CAccessChecker::GetOsVersion(BSTR server, DWORD * pdwVerMaj, DWORD * pdwVerMin, DWORD * pdwVerSP)
{
   // This function looksup the OS version on the server specified and returns it.
   // CAUTION : This function always returns 0 for the ServicePack. 
   WKSTA_INFO_100       * pInfo;
   long rc = NetWkstaGetInfo(server,100,(LPBYTE*)&pInfo);
	if ( ! rc )
	{
      *pdwVerMaj = pInfo->wki100_ver_major;
      *pdwVerMin = pInfo->wki100_ver_minor;
      *pdwVerSP = 0;
      NetApiBufferFree(pInfo);
	}  
   else
      return HRESULT_FROM_WIN32(rc);

   return S_OK;
}

STDMETHODIMP CAccessChecker::IsNativeMode(BSTR Domain, BOOL * pbIsNativeMode)
{
   ADSGETOBJECT            ADsGetObject;
   HMODULE hMod = LoadLibrary(L"activeds.dll");
   if ( hMod == NULL )
   {
      return       HRESULT_FROM_WIN32(GetLastError());
   }

   ADsGetObject = (ADSGETOBJECT)GetProcAddress(hMod, "ADsGetObject");
   if (!ADsGetObject)
      return HRESULT_FROM_WIN32(GetLastError());

   IADs     			* pDomain;
   HRESULT				  hr;
   VARIANT				  var;
   _bstr_t             sDom( L"LDAP://" );
   sDom += Domain;

   hr = ADsGetObject(sDom, IID_IADs, (void **) &pDomain);
   if (SUCCEEDED(hr))
   {
      VariantClear(&var);
      
      //Get the ntMixedDomain attribute
      hr = pDomain->Get(L"ntMixedDomain", &var);
      if (SUCCEEDED(hr))
      {
         hr = E_FAIL;
         //Type should be VT_I4.
         if (var.vt==VT_I4)
         {
            //Zero means native mode.
            if (var.lVal == 0)
            {
               hr = S_OK;
               *pbIsNativeMode = true;
            }
            //One means mixed mode.
            else if(var.lVal == 1)
            {
               hr = S_OK;
               *pbIsNativeMode = false; 
            }
         }
      }
      VariantClear(&var);
	  pDomain->Release();
   }
   return hr;
}

STDMETHODIMP CAccessChecker::CanUseAddSidHistory(BSTR srcDomain, BSTR tgtDomain, long * pbCanUseIt)
{
   DOMAIN_CONTROLLER_INFO  * pSrcDomCtrlInfo = NULL;
   DOMAIN_CONTROLLER_INFO  * pTgtDomCtrlInfo = NULL;
  	DWORD                     rc = 0;         // OS return code
   WKSTA_INFO_100          * pInfo = NULL;
   TRegKey                   sysKey, regComputer;
	DWORD							  rval;	
   BSTR							  bstrSourceMachine = NULL;
	BSTR							  bstrTargetMachine = NULL;

   // initialize the return FieldMask
   * pbCanUseIt = F_WORKS;

   // Load DsGetDcName dynamically
   DSGETDCNAME DsGetDcName;
   HMODULE hPro = LoadLibrary(L"NetApi32.dll");
   DsGetDcName = (DSGETDCNAME)GetProcAddress(hPro, "DsGetDcNameW");

   if (DsGetDcName == NULL)
   {
      return HRESULT_FROM_WIN32(GetLastError());
   }

     rc = DsGetDcName(
      NULL                                  ,// LPCTSTR ComputerName ?
      srcDomain                             ,// LPCTSTR DomainName
      NULL                                  ,// GUID *DomainGuid ?
      NULL                                  ,// LPCTSTR SiteName ?
      DS_PDC_REQUIRED                       ,// ULONG Flags ?
      &pSrcDomCtrlInfo                       // PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
   );
 
   if( rc != NO_ERROR ) goto ret_exit;

   rc = DsGetDcName(
      NULL                                  ,// LPCTSTR ComputerName ?
      tgtDomain                             ,// LPCTSTR DomainName
      NULL                                  ,// GUID *DomainGuid ?
      NULL                                  ,// LPCTSTR SiteName ?
      0                                     ,// ULONG Flags ?
      &pTgtDomCtrlInfo                       // PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
   );

   if( rc != NO_ERROR ) goto ret_exit;

   bstrSourceMachine = ::SysAllocString( pSrcDomCtrlInfo->DomainControllerName );
   bstrTargetMachine = ::SysAllocString( pTgtDomCtrlInfo->DomainControllerName );

	if (GetBkupRstrPriv(bstrSourceMachine))
   {
      rc = regComputer.Connect( HKEY_LOCAL_MACHINE, bstrSourceMachine );
   }
   else
   {
      rc = GetLastError();
   }

   // Check if the target domain is a Win2k native mode domain.
   if ( !rc )
   {
		rc = NetWkstaGetInfo(bstrTargetMachine,100,(LPBYTE*)&pInfo);
		if ( ! rc )
		{
			if ( pInfo->wki100_ver_major < 5 )
			{
					// cannot add Sid history to non Win2k Domains
					*pbCanUseIt |= F_WRONGOS;
			}
         else{
            BOOL isNative = false;
            if(SUCCEEDED(IsNativeMode( _bstr_t(pInfo->wki100_langroup), &isNative))){
               if( isNative == false ) *pbCanUseIt |= F_WRONGOS;
            }
         }
		}
		else
		{
			rc = GetLastError();
		}

      // Check the registry to see if the TcpipClientSupport key is there
		if ( ! rc )
		{
			rc = sysKey.OpenRead(L"System\\CurrentControlSet\\Control\\Lsa",&regComputer);
		}
		if ( ! rc )
		{
			rc = sysKey.ValueGetDWORD(L"TcpipClientSupport",&rval);
			if ( !rc ) 
			{
				if ( rval != 1 )
				{
					*pbCanUseIt |= F_NO_REG_KEY;
				}
			}
         else
         {
            // DWORD value not found
            *pbCanUseIt |= F_NO_REG_KEY;
            rc = 0;
         }
		}
	}

   if ( !rc )
   {
      // Check auditing on the source domain.
      rc = DetectAuditing(bstrSourceMachine);
      if ( rc == -1 )
      {
         rc = 0;
         *pbCanUseIt |= F_NO_AUDITING_SOURCE;
      }
   }
   
   if ( !rc )
   {
      // Check auditing on the target domain.
      rc = DetectAuditing(bstrTargetMachine);
      if ( rc == -1 )
      {
         rc = 0;
         *pbCanUseIt |= F_NO_AUDITING_TARGET;
      }
   }

   if (!rc )
   {
      LOCALGROUP_INFO_0    * pInfo = NULL;
      WCHAR                  groupName[LEN_Account];

      wsprintf(groupName,L"%ls$$$",(WCHAR*)srcDomain);
      rc = NetLocalGroupGetInfo(bstrSourceMachine,groupName,0,(BYTE**)&pInfo);
      if ( rc == NERR_GroupNotFound )
      {
         rc = 0;
         *pbCanUseIt |= F_NO_LOCAL_GROUP;
      }
      else
      {
         NetApiBufferFree(pInfo);
      }
   }


ret_exit:

	if ( pInfo ) NetApiBufferFree(pInfo);
   if ( pSrcDomCtrlInfo ) NetApiBufferFree( pSrcDomCtrlInfo );
   if ( pTgtDomCtrlInfo ) NetApiBufferFree( pTgtDomCtrlInfo );
   if ( bstrSourceMachine ) ::SysFreeString(bstrSourceMachine);
	if ( bstrTargetMachine ) ::SysFreeString(bstrTargetMachine);

   return HRESULT_FROM_WIN32(rc);
}

//------------------------------------------------------------------------------------------
// AddLocalGroup : Given the source domain, and source domain controller names, this 
//					    function creates the local group SOURCEDOMAIN$$$ in the source domain.
//                 This local group must exist in the source domain for the DsAddSidHistory 
//                 API to work.
//             
//------------------------------------------------------------------------------------------

STDMETHODIMP CAccessChecker::AddLocalGroup(BSTR srcDomain, BSTR sourceDC)
{
   DWORD                     rc = 0;
   LOCALGROUP_INFO_1         groupInfo;
   WCHAR                     name[LEN_Account];
   WCHAR                     comment[LEN_Account];
   DWORD                     parmErr;

   swprintf(name,L"%ls$$$",(WCHAR*)srcDomain);
   groupInfo.lgrpi1_name = name;
   wcscpy(comment, (WCHAR*)GET_BSTR(IDS_DOM_LOC_GRP_COMMENT));
   groupInfo.lgrpi1_comment = comment;
   
   rc = NetLocalGroupAdd(sourceDC,1,(LPBYTE)&groupInfo,&parmErr);

   return HRESULT_FROM_WIN32(rc);
}
//------------------------------------------------------------------------------------------
// IsInSameForest : Given the source and the target domains this function tells us if 
//					both the domains are in the same forest. This function enumerates all
//                  the domains in the Forest of the source domain and compares them to
//                  the target domain name. If there is a match then we know we are in same
//                  forest.
//------------------------------------------------------------------------------------------
STDMETHODIMP CAccessChecker::IsInSameForest(BSTR srcDomain, BSTR tgtDomain, BOOL * pbIsSame)
{
	// Initialize the return value
	*pbIsSame = FALSE;

   // Load the ADSI function dynamically
   ADSGETOBJECT            ADsGetObject;
   HMODULE                 hMod = LoadLibrary(L"activeds.dll");
   if ( hMod == NULL )
   {
      return HRESULT_FROM_WIN32(GetLastError());
   }

   ADsGetObject = (ADSGETOBJECT)GetProcAddress(hMod, "ADsGetObject");
   if (!ADsGetObject)
      return HRESULT_FROM_WIN32(GetLastError());

   // we are going to look up the Schema naming context of both domains.
   // if they are the same then these two domains are in same forest.
   IADs                    * pAds = NULL;
   HRESULT                   hr = S_OK;
   WCHAR                     sPath[LEN_Path];
   _variant_t                var;
   _bstr_t                   srcSchema, tgtSchema;

   // Get the schemaNamingContext for the source domain.
   wsprintf(sPath, L"LDAP://%s/rootDSE", (WCHAR*) srcDomain);
   hr = ADsGetObject(sPath, IID_IADs, (void**) &pAds);
   if ( SUCCEEDED(hr) )
      hr = pAds->Get(L"schemaNamingContext", &var);

   if ( SUCCEEDED(hr) )
      srcSchema = var;
   else
      srcSchema = L"";

   if ( pAds )
   {
      pAds->Release();
      pAds = NULL;
   }
   
   if (SUCCEEDED(hr))
   {
     // Now do the same for the target domain.
      wsprintf(sPath, L"LDAP://%s/rootDSE", (WCHAR*) tgtDomain);
      hr = ADsGetObject(sPath, IID_IADs, (void**) &pAds);
      if ( SUCCEEDED(hr) )
         hr = pAds->Get(L"schemaNamingContext", &var);

      if ( SUCCEEDED(hr) )
         tgtSchema = var;
      else
      {
         if ( hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) )
         {
            // for NT 4 domains, we always get this error
            DOMAIN_CONTROLLER_INFO        * pDomCtrl;
            DSGETDCNAME                     DsGetDcName;
            HMODULE                         hPro = LoadLibrary(L"NetApi32.dll");
            DWORD                           rc;
         
            DsGetDcName = (DSGETDCNAME)GetProcAddress(hPro, "DsGetDcNameW");
         
            if ( DsGetDcName )
            {
              rc = DsGetDcName(
               NULL                                  ,// LPCTSTR ComputerName ?
               tgtDomain                             ,// LPCTSTR DomainName
               NULL                                  ,// GUID *DomainGuid ?
               NULL                                  ,// LPCTSTR SiteName ?
               0                                     ,// ULONG Flags ?
               &pDomCtrl                              // PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
               );

               if ( ! rc )
               {
         
                  WKSTA_INFO_100       * pInfo = NULL;
                  WCHAR                  server[100];

         
                  UStrCpy(server,pDomCtrl->DomainControllerName);
                  rc = NetWkstaGetInfo(server,100,(LPBYTE*)&pInfo);
                  if ( ! rc )
                  {
                     if ( pInfo->wki100_ver_major < 5 )
                     {
                        (*pbIsSame) = FALSE;
                        hr = 0;
                     }
                     NetApiBufferFree(pInfo);
                  }  
                  else
                     hr = HRESULT_FROM_WIN32(rc); // the return code from NetWkstaGetInfo may be more descriptive
                  NetApiBufferFree(pDomCtrl);
               }
            }
            if ( hPro )
               FreeLibrary(hPro);   
         }
         tgtSchema = L"";
      }

      if ( pAds )
      {
         pAds->Release();
         pAds = NULL;
      }

      *pbIsSame = (srcSchema == tgtSchema);
   }
   else
   {
      if ( hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) )
      {
         // for NT 4 domains, we always get this error
         DOMAIN_CONTROLLER_INFO        * pDomCtrl;
         DSGETDCNAME                     DsGetDcName;
         HMODULE                         hPro = LoadLibrary(L"NetApi32.dll");
         DWORD                           rc;
         
         DsGetDcName = (DSGETDCNAME)GetProcAddress(hPro, "DsGetDcNameW");
         
         if ( DsGetDcName )
         {
           rc = DsGetDcName(
            NULL                                  ,// LPCTSTR ComputerName ?
            srcDomain                             ,// LPCTSTR DomainName
            NULL                                  ,// GUID *DomainGuid ?
            NULL                                  ,// LPCTSTR SiteName ?
            0                                     ,// ULONG Flags ?
            &pDomCtrl                              // PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
            );

            if ( ! rc )
            {
         
               WKSTA_INFO_100       * pInfo = NULL;
               WCHAR                  server[100];

         
               UStrCpy(server,pDomCtrl->DomainControllerName);
               rc = NetWkstaGetInfo(server,100,(LPBYTE*)&pInfo);
               if ( ! rc )
               {
                  if ( pInfo->wki100_ver_major < 5 )
                  {
                     (*pbIsSame) = FALSE;
                     hr = 0;
                  }
                  NetApiBufferFree(pInfo);
               }  
               else
                  hr = HRESULT_FROM_WIN32(rc); // the return code from NetWkstaGetInfo may be more descriptive
               NetApiBufferFree(pDomCtrl);
            }
         }
         if ( hPro )
            FreeLibrary(hPro);
     }

   }
   if ( hMod )
      FreeLibrary(hMod);
   return hr;
}

STDMETHODIMP 
   CAccessChecker::GetPasswordPolicy(
      BSTR                   domain,                  /*[out]*/ 
      LONG                 * dwPasswordLength         /*[out]*/ 
  )
{
   HRESULT                   hr = S_OK;

   // initialize output parameter
   (*dwPasswordLength) = 0;

   ADSGETOBJECT            ADsGetObject;
   
   HMODULE                 hMod = LoadLibrary(L"activeds.dll");

   if ( hMod == NULL )
   {
      return HRESULT_FROM_WIN32(GetLastError());
   }

   ADsGetObject = (ADSGETOBJECT)GetProcAddress(hMod, "ADsGetObject");
   if (!ADsGetObject)
      return HRESULT_FROM_WIN32(GetLastError());

   IADsDomain     			* pDomain;
   _bstr_t                   sDom( L"WinNT://" );
   
   sDom += domain;

   hr = ADsGetObject(sDom, IID_IADsDomain, (void **) &pDomain);
   if (SUCCEEDED(hr))
   {
      
      //Get the ntMixedDomain attribute
      hr = pDomain->get_MinPasswordLength(dwPasswordLength);
     
      pDomain->Release();
   }
   return hr;
}

STDMETHODIMP CAccessChecker::EnableAuditing(BSTR sDC)
{
   LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
   DWORD                     wszStringLength;
   LSA_UNICODE_STRING        lsaszServer;
   NTSTATUS                  ntsResult;
   LSA_HANDLE                hPolicy;
   long                      rc = 0;

   // Object attributes are reserved, so initalize to zeroes.
   ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
   
   //Initialize an LSA_UNICODE_STRING structure to the server name.
   wszStringLength = wcslen((WCHAR*)sDC);
   lsaszServer.Buffer = (WCHAR*)sDC;
   lsaszServer.Length = (USHORT)wszStringLength * sizeof(WCHAR);
   lsaszServer.MaximumLength=(USHORT)wszStringLength * sizeof(WCHAR);

   // Attempt to open the policy.
   ntsResult = LsaOpenPolicy(
                &lsaszServer,
                &ObjectAttributes,
                POLICY_VIEW_AUDIT_INFORMATION | POLICY_VIEW_LOCAL_INFORMATION | POLICY_SET_AUDIT_REQUIREMENTS , 
                &hPolicy  //recieves the policy handle
                );

   if ( !ntsResult )
   {
      // Ask for audit policy information
      PPOLICY_AUDIT_EVENTS_INFO   info;
      ntsResult = LsaQueryInformationPolicy(hPolicy, PolicyAuditEventsInformation, (PVOID *)&info);
      
      if ( !ntsResult )
      {
         // turn on the audit mode.
         info->AuditingMode = TRUE;
         // turn on the success/failure for the Account management events
         info->EventAuditingOptions[AuditCategoryAccountManagement] = POLICY_AUDIT_EVENT_SUCCESS | POLICY_AUDIT_EVENT_FAILURE;
         ntsResult = LsaSetInformationPolicy(hPolicy, PolicyAuditEventsInformation, (PVOID) info);
         if ( ntsResult ) 
            rc = LsaNtStatusToWinError(ntsResult);
         // be a good boy and cleanup after yourself.
         LsaFreeMemory((PVOID) info);
      }
      else
         rc = LsaNtStatusToWinError(ntsResult);
      
      //Freeing the policy object handle
      ntsResult = LsaClose(hPolicy);
   }
   else
      rc = LsaNtStatusToWinError(ntsResult);
//      long rc = LsaNtStatusToWinError(ntsResult);

   return HRESULT_FROM_WIN32(rc);
}

long CAccessChecker::DetectAuditing(BSTR sDC)
{
   LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
   DWORD                     wszStringLength;
   LSA_UNICODE_STRING        lsaszServer;
   NTSTATUS                  ntsResult;
   LSA_HANDLE                hPolicy;
   long                      rc = 0;

   // Object attributes are reserved, so initalize to zeroes.
   ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
   
   //Initialize an LSA_UNICODE_STRING structure to the server name.
   wszStringLength = wcslen((WCHAR*)sDC);
   lsaszServer.Buffer = (WCHAR*)sDC;
   lsaszServer.Length = (USHORT)wszStringLength * sizeof(WCHAR);
   lsaszServer.MaximumLength=(USHORT)wszStringLength * sizeof(WCHAR);

   // Attempt to open the policy.
   ntsResult = LsaOpenPolicy(
                &lsaszServer,
                &ObjectAttributes,
                POLICY_VIEW_AUDIT_INFORMATION | POLICY_VIEW_LOCAL_INFORMATION,
                &hPolicy  //recieves the policy handle
                );

   if ( !ntsResult )
   {
      // Ask for audit policy information
      PPOLICY_AUDIT_EVENTS_INFO   info;
      ntsResult = LsaQueryInformationPolicy(hPolicy, PolicyAuditEventsInformation, (PVOID *)&info);
      
      if ( !ntsResult )
      {
         // check if the over all auditing is turned on
         if (!info->AuditingMode)
            rc = -1;

         // Check if the account management event auditing is on
         if (info->EventAuditingOptions[AuditCategoryAccountManagement] != (POLICY_AUDIT_EVENT_SUCCESS | POLICY_AUDIT_EVENT_FAILURE))
            rc = -1;
         LsaFreeMemory((PVOID) info);
      }
      else
         rc = LsaNtStatusToWinError(ntsResult);
      
      //Freeing the policy object handle
      ntsResult = LsaClose(hPolicy);
   }
   else
      rc = LsaNtStatusToWinError(ntsResult);
   
   return rc;
}

STDMETHODIMP CAccessChecker::AddRegKey(BSTR srcDc,LONG bReboot)
{
   // This function will add the necessary registry key and then reboot the 
   // PDC for a given domain
   TRegKey                   sysKey, regComputer;
   DOMAIN_CONTROLLER_INFO  * pSrcDomCtrlInfo = NULL;
  	DWORD                     rc = 0;         // OS return code
//   BSTR							  bstrSourceMachine = NULL;
   _bstr_t                   sDC;

   if (GetBkupRstrPriv(srcDc))
   {
      rc = regComputer.Connect( HKEY_LOCAL_MACHINE, (WCHAR*)srcDc );
   }
   else
   {
      rc = GetLastError();
   }
   // Add the TcpipClientSupport DWORD value
	if ( ! rc )
	{
		rc = sysKey.Open(L"System\\CurrentControlSet\\Control\\Lsa",&regComputer);
	}
	
   if ( ! rc )
	{
		rc = sysKey.ValueSetDWORD(L"TcpipClientSupport",1);
	}

   if ( !rc && bReboot)
   {
      // Computer will shutdown and restart in 10 seconds.
      rc = ComputerShutDown((WCHAR*) srcDc, GET_STRING(IDS_RegKeyRebootMessage), 10, TRUE, FALSE);         
   }
   if ( pSrcDomCtrlInfo ) NetApiBufferFree(pSrcDomCtrlInfo);
   return HRESULT_FROM_WIN32(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\dapi.h ===
/*******************************************************************
 *
 * Copyright (c) Microsoft Corp. 1986-1996. All Rights Reserved.
 *
 *
 *    DESCRIPTION:   This header file defines the functions, structures,
 *                   and macros used to access the Microsoft Exchange
 *                   APIs for modifying entries in the Exchange 4.0 DIT.
 *                   These APIs permit a calling process to create, 
 *                   modify, or delete DIT objects by specifying the
 *                   name of a CSV text file containing attributes 
 *                   for objects to import into ( or to modify) 
 *                   the DIT.  See the Directory Access Functions
 *                   section of the Exchange Developer's Kit for 
 *                   more detailed description of this interface.
 *                   
 *                   Calling programs must link with DAPI.LIB.
 *                   
 *                   Error and warning codes are defined in DAPIMSG.H
 *
 *
 *******************************************************************/

/** include files **/
#ifndef _WINDOWS_
#include <windows.h>
#endif

/** local definitions **/

#ifndef  _DAPI_INCLUDED_
#define  _DAPI_INCLUDED_

#ifdef __cplusplus
extern "C"
{
#endif

// Import / Export APIs check for the presence of this signature in 
// the dwDAPISignature field in the import parameter blocks.
// This signature will be incremented each time one of the parameter
// blocks is changed so that header synchronization problems can be 
// detected.
#define  DAPI_SIGNATURE                   0x46414400


// Combinable flags used to control the API functions.

   // The following flags control filtering of DAPI events
   // The default action is DAPI_EVENT_ALL
#define DAPI_EVENT_MASK                   0x00000007  /* bit-field containing event-filtering requested 
                                                         if none of these bits are set, DAPI_EVENT_ALL is assumed */
#define DAPI_EVENT_MIN                    0x00000001  /* No warning or error logging.
                                                         Log start and stop messages */
#define DAPI_EVENT_SOME                   0x00000002  /* Start, Stop, and Error messages will be logged. */
#define DAPI_EVENT_ALL                    0x00000004  /* Start, Stop, Error, and Warning messages
                                                         will be logged. */
                                                         
   // The following flags control schema read and use of the schema
#define DAPI_FORCE_SCHEMA_LOAD            0x00000010  /* Unload previously loaded schema
                                                         and read schema again.
                                                         Default action is to re-use
                                                         previously loaded schema if read
                                                         from the same messaging domain */
#define DAPI_RAW_MODE                     0x00000020  /* Import / Export in "Raw" mode.  Import
                                                         lines are taken literally.  No
                                                         attributes will be inherited, 
                                                         constructed, etc.  Aliases for 
                                                         attribute and class names will
                                                         not be recognized. */
                                                         
#define DAPI_OVERRIDE_CONTAINER           0x00000040  /* Container specified in the parameter block
                                                         overrides the contents of the container column.
                                                         Default behaviour is for the value specified
                                                         in the Obj-Container column to override
                                                         that specified in the parameter block */
                                                 
#define DAPI_IMPORT_NO_ERR_FILE           0x00000080  /* Do not create Error File -- BatchImport only */
#define DAPI_IMPORT_WRITE_THROUGH         0x00400000  /* Commit write operations immediately */

// Flags defined for "Batch" operations only -- ignored by DAPIRead, DAPIWrite
#define DAPI_YES_TO_ALL                   0x00000100  /* Force "yes" response on any
                                                         user-prompt UI 
                                                         (i.e., continue w/o proxy addresses, etc.) */

#define DAPI_SUPPRESS_PROGRESS            0x00000200  /* Suppress progress thermometer on batch operations.
                                                         Default is to display progress */
#define DAPI_SUPPRESS_COMPLETION          0x00000400  /* Suppress completion notification message box on batch operations */
                                                         
#define DAPI_SUPPRESS_ARCHIVES            0x00000800  /* Suppress creation of "archive" copies
                                                         of output files -- BatchImport and BatchExport only*/
                                                         


// Flags defined for BatchExport
#define DAPI_EXPORT_MAILBOX               0x00001000  /* Export Mailbox recipients */
#define DAPI_EXPORT_CUSTOM                0x00002000  /* Export remote address recipients */
#define DAPI_EXPORT_DIST_LIST             0x00004000  /* Export Distribution Lists */
#define DAPI_EXPORT_RECIPIENTS       (DAPI_EXPORT_MAILBOX | DAPI_EXPORT_CUSTOM | DAPI_EXPORT_DIST_LIST)
                                                      /* Export all recipient objects */

#define DAPI_EXPORT_ALL_CLASSES           0x00008000  /* If this flag is set, all objects meeting other restrictions
                                                         (i.e., USN level, container scope, etc.) will be exported,
                                                         regardless of class */

#define DAPI_EXPORT_HIDDEN                0x00010000  /* Include Hidden objects in export.
                                                                      Default is no export if Hide-From-Address-Book */
#define DAPI_EXPORT_SUBTREE               0x00020000  /* Traverse the Directory Information Tree hierarchy,
                                                         exporting objects that meet the export restrictions */
#define DAPI_EXPORT_BASEPOINT_ONLY        0x00040000  /* Export only the requested attributes from
                                                         the named BasePoint object.  All other 
                                                         export restrictions are ignored (class flags, 
                                                         rgpszClasses, pszServerName). 
                                                         This flag implies DAPI_SUPPRESS_PROGRESS
                                                         and DAPI_SUPPRESS_COMPLETION */

// Flags defined only for BatchImport
#define DAPI_OVERRIDE_SYNCH_STATE         0x00080000  /* Override server's synchronization status,
                                                         normally checked on BatchImport.
                                                         NOTE:  This flag should normally NOT be set.
                                                                The normal behaviour is to prevent BatchImport
                                                                operations from possible conflict with directory
                                                                synchronization */


// Flags defined only for DAPIRead                                                         
#define  DAPI_READ_DEFINED_ATTRIBUTES     0x00100000  /* return all attributes that are set
                                                         for the current object. 
                                                         This flag is ignored if pAttributes is specified. */

#define  DAPI_READ_ALL_ATTRIBUTES         0x00200000  /* return all attributes that are defined
                                                         for the class of the current object. 
                                                         This flag is ignored if pAttributes is specified. */


 // The following flags control NT Security management
#define DAPI_RESTRICT_ACCESS              0x01000000  /* Apply NT Security Descriptor to 
                                                         created objects */
#define DAPI_CREATE_NT_ACCOUNT            0x02000000  /* Create NT accounts 
                                                         (valid only in Create/Modify mode) */
#define DAPI_CREATE_RANDOM_PASSWORD       0x04000000  /* Generate random passwords for
                                                         created NT accounts.  Ignored if DAPI_CREATE_NT_ACCOUNT
                                                         is not set */
                                                         
#define DAPI_DELETE_NT_ACCOUNT            0x08000000  /* Delete ASSOC-NT-ACCOUNT when
                                                         deleting mailbox */
// Flags defined only for DAPIWrite
#define DAPI_MODIFY_REPLACE_PROPERTIES    0x00800000  /* Append values to multi-value attributes when modifying */

#define  DAPI_WRITE_UPDATE                0x10000000  /* Modify if object exists, create if it doesn't.
                                                         NOTE:  This is the default mode */
#define  DAPI_WRITE_CREATE                0x20000000  /* Create object -- fail if object exists */
#define  DAPI_WRITE_MODIFY                0x30000000  /* Modify object -- fail if object does not exist */
#define  DAPI_WRITE_DELETE                0x40000000  /* Delete object */
#define  DAPI_WRITE_MODE_MASK             0x70000000



// Callback flags
#define  DAPI_CALLBACK_CHAIN              0x00000001  /* If set in dwFlags field of the ERROR_CALLBACK
                                                         and the CALLBACKPROGRESS structures, the default
                                                         handler will be invoked after calling out to the 
                                                         caller-supplied handler function, unless the user
                                                         function returns FALSE, indicating cancel.
                                                         NOTE:  This flag is not defined for the EXPORT_CALLBACK
                                                                structure.
                                                         NOTE:  This flag should not be set in the dwFlags
                                                                field of the main parameter block */


// default delimiter values used when parsing the import file

#define DAPI_DEFAULT_DELIMA   ','
#define DAPI_DEFAULT_QUOTEA   '"'
#define DAPI_DEFAULT_MV_SEPA  '%'
#define DAPI_DEFAULT_DELIMW   L','
#define DAPI_DEFAULT_QUOTEW   L'"'
#define DAPI_DEFAULT_MV_SEPW  L'%'


#define DAPI_CTRL_FILE_PTRA   '='
#define DAPI_CTRL_FILE_PTRW   L'='
#define DAPI_CTRL_ANR_PREFIXA '='
#define DAPI_CTRL_ANR_PREFIXW L'='
#define DAPI_CTRL_META_CHARA  '~'
#define DAPI_CTRL_META_CHARW  L'~'
#define pszSubstServerA       "~SERVER"
#define pszSubstServerW       L"~SERVER"
#define cchSubstServer        ((sizeof (pszSubstServerA) / sizeof(CHAR)) - 1)
#define pszDeleteKeyA         "~DEL"
#define pszDeleteKeyW         L"~DEL"
#define cchDeleteKey          ((sizeof (pszDeleteKeyA) / sizeof(CHAR)) - 1)

#define DAPI_UNICODE_FILE     ((UINT)-1)

#ifdef UNICODE

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMW
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEW
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPW
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRW
#define DAPI_CTRL_ANR_PREFIX  DAPI_CTRL_ANR_PREFIXW
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARW
#define pszSubstServer        pszSubstServerW
#define pszDeleteKey          pszDeleteKeyW

#else

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMA
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEA
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPA
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRA
#define DAPI_CTRL_ANR_PREFIX  DAPI_CTRL_ANR_PREFIXA
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARA
#define pszSubstServer        pszSubstServerA
#define pszDeleteKey          pszDeleteKeyA

#endif


/*******************************************************************************
* Batch Operation Progress Callback Function Definitions
* Pointers to functions of these types are provided by the caller via the 
* CALLBACKPROGRESS structure in the Batch function parameter block
*               
********************************************************************************
*               
*  procedure :  PDAPI_FInitProgress
*               
*    purpose :  Initialize progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FResetProgress
*               
*    purpose :  Re-initialize progress handler (possibly reset progress bar)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not re-initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FEndProgress
*               
*    purpose :  Terminate progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not terminate progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgress
*               
*    purpose :  Completed processing item.  Called to indicate time to increment
*               progress display.
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgressText
*               
*    purpose :  Replace progress text area with provided text string
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************/
typedef BOOL (PASCAL * PDAPI_FInitProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FEndProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FResetProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgressText)
                          (LPVOID lpvAppDefined, LPTSTR pszText);
            
typedef struct CallBackProgressEntryPoints
{
   DWORD                      dwFlags;
   LPVOID                     lpvAppDefined;
   PDAPI_FInitProgress        pfnInitProgress;
   PDAPI_FUpdateProgress      pfnUpdateProgress;
   PDAPI_FEndProgress         pfnEndProgress;
   PDAPI_FResetProgress       pfnResetProgress;
   PDAPI_FUpdateProgressText  pfnUpdateProgressText;
} CALLBACKPROGRESS, *PCALLBACKPROGRESS;



// Values specified in the ulEvalTag field of the 
//    DAPI_ENTRY and EXPORT_CALLBACK structures
//    
typedef enum _DAPI_EVAL
{
   VALUE_ARRAY = 0,           // Each attribute has an entry in the array
                              //    Text strings and object names exported as text
                              //    Numerical values exported as numbers
                              //    Binary data exported as binary string
   TEXT_VALUE_ARRAY,          // Each attribute has an entry in the array
                              //    All values converted to text representation
   TEXT_LINE                  // first item in the rgEntryValues array
                              //    is a delimited text line
} DAPI_EVAL, *PDAPI_EVAL;

typedef enum _EXP_TYPE_TAG
{
   EXPORT_HEADER = 0,         // export item contains column headers
   EXPORT_ENTRY               // export item contains attribute values
} EXP_TYPE, * PEXP_TYPE;


typedef enum enumDAPI_DATA_TYPE
{
   DAPI_NO_VALUE = 0,
   DAPI_STRING8,
   DAPI_UNICODE,
   DAPI_BINARY,
   DAPI_INT,
   DAPI_BOOL,
} DAPI_DATA_TYPE, * PDAPI_DATA_TYPE;

#ifdef UNICODE
#define DAPI_TEXT DAPI_UNICODE
#else
#define DAPI_TEXT DAPI_STRING8
#endif

typedef union _DAPI_VALUE
{
   LPSTR    pszA;
   LPWSTR   pszW;
#ifdef UNICODE
   LPWSTR   pszValue;
#else
   LPSTR    pszValue;
#endif
   LPBYTE   lpBinary;
   INT      iValue;
   BOOL     bool;
} DAPI_VALUE, * PDAPI_VALUE;



// The ATT_VALUE structure contains a text representation of an attribute value
// A linked list of these structures is used for a multi-valued attribute
typedef struct _ATT_VALUE
{
   DAPI_DATA_TYPE       DapiType;         // How to evaluate DAPI_VALUE union
   DAPI_VALUE           Value;
   UINT                 size;             // size of the value -- 
                                          //    # chars if string type
                                          //    else, # bytes
   struct _ATT_VALUE *  pNextValue;
} ATT_VALUE, * PATT_VALUE;


typedef struct _DAPI_ENTRY
{
   UINT           unAttributes;              // Number of attributes exported
   DAPI_EVAL      ulEvalTag;                 // rgEntryValues is interpreted based on this value
   PATT_VALUE     rgEntryValues;             // if (ulEvalTag == TEXT_LINE)
                                             //    There is a single value, w/ delimited line
                                             // else
                                             //    unAttributes, each w/ 1 or more value in list
} DAPI_ENTRY, * PDAPI_ENTRY;

// Define type for address of application routine 
// for call-back on each exported entry.
// Return value of FALSE indicates that export operation should be cancelled
typedef BOOL (PASCAL DAPI_FNExportEntry) (
               EXP_TYPE    ExportDataType,   // What type of data is being exported
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_ENTRY pExportEntry      // pointer to exported entry data
                                             // NOTE: Data in this structure
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNExportEntry * PDAPI_FNExportEntry;

typedef struct _EXPORT_CALLBACK
{
   DWORD       dwFlags;                      // Flags defined to control callback functionality
                                             // See flag definitions below
   DAPI_EVAL   ulEvalTag;                    // Specifies data format on callback
   LPVOID      lpvAppDefined;                // Application-defined field, passed as parm to callback
   PDAPI_FNExportEntry  pfnExportEntry;      // Pointer to function called to process
                                             // each exported entry

} EXPORT_CALLBACK, * PEXPORT_CALLBACK;



/*******************************************************************************
*  procedure :  pfnErrorCallback
*               
*    purpose :  The following section defines structures for the error callback
*               mechanism of the Batch Import APIs
*               Events will be filtered based on the ControlfFlags set in the 
*               API parameter block
*               
********************************************************************************/

// Define flags used for export callback

// Define the maximum number of substitutions in a single event string
#define DAPI_MAX_SUBST 8


typedef struct _DAPI_EVENTA
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPSTR             rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPSTR             pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPSTR             pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTA * pNextEvent;       // Pointer to next event
} DAPI_EVENTA, *PDAPI_EVENTA;

typedef struct _DAPI_EVENTW
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPWSTR            rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPWSTR            pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPWSTR            pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTW * pNextEvent;       // Pointer to next event
} DAPI_EVENTW, *PDAPI_EVENTW;

#ifdef UNICODE
typedef DAPI_EVENTW  DAPI_EVENT;
typedef PDAPI_EVENTW PDAPI_EVENT;
#else
typedef DAPI_EVENTA  DAPI_EVENT;
typedef PDAPI_EVENTA PDAPI_EVENT;
#endif

// Define type for address of application routine 
// for call-back on each error encountered.
// Return value of FALSE indicates that operation should be cancelled
typedef BOOL (PASCAL DAPI_FNErrorCallback) (
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_EVENT pDapiEvent        // Event information structure
                                             // NOTE: Data in the event record
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNErrorCallback * PDAPI_FNErrorCallback;


typedef struct tagERROR_CALLBACK
{
   DWORD                   dwFlags;          // Flags defined to control callback functionality
                                             // See flag definitions above
   LPVOID                  lpvAppDefined;    // Application-defined field, passed back in callback
   PDAPI_FNErrorCallback   pfnErrorCallback; // Address of function that should be
                                             // called on each error encountered
                                             // If not supplied (NULL), default
                                             // error handler is called, which
                                             // writes the error into the 
                                             // NT Application event log

} ERROR_CALLBACK, * PERROR_CALLBACK;





/*******************************************************************************
*  
*   Batch Directory Import Interface definitions
*               
********************************************************************************/

/*******************************************************************************
*  procedure :  DAPIUninitialize
*               
*    purpose :  Notify DAPI that it is time to terminate background threads
*               and such in preparation for process shutdown
*               
* parameters :  dwFlags		combinable bits which may be set to control function
*               
*    returns :  nothing
*               
*    created :  11/01/95 
*               
*    changes :  
*               
********************************************************************************/
extern void APIENTRY DAPIUninitialize (
                              DWORD    dwFlags // Flags for call
);



/*******************************************************************************
*  procedure :  SchemaPreload
*               
*    purpose :  Called to perform asyncronous schema load.  This entry point
*               spawns a thread that initializes all the attribute and class
*               tables for normal import/export operation.
*               
* parameters :  pSchemaPreloadParms    pointer to SchemaPreloadParameter block
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY SchemaPreloadA (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPSTR    pszDSA   // name of DSA from which to read schema
);

extern void APIENTRY SchemaPreloadW (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPWSTR   pszDSA   // name of DSA from which to read schema
);

#ifdef UNICODE
#define  SchemaPreload  SchemaPreloadW
#else
#define  SchemaPreload  SchemaPreloadA
#endif

typedef struct _BIMPORT_PARMSW
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;                // Windows handle to use when displaying message boxes
   LPWSTR   pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   WCHAR    chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR    chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR    chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR    creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPWSTR   pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPWSTR   pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSW, *PBIMPORT_PARMSW, *LPBIMPORT_PARMSW;

typedef struct _BIMPORT_PARMSA
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPSTR    pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSA, *PBIMPORT_PARMSA, *LPBIMPORT_PARMSA;

#ifdef UNICODE
typedef  BIMPORT_PARMSW    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSW   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSW  LPBIMPORT_PARMS;
#else
typedef  BIMPORT_PARMSA    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSA   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSA  LPBIMPORT_PARMS;
#endif

// The BatchImport function provides single-call BatchImport from the
//    specified import file.  All import parameters are specified in the
//    BIMPORT_PARMS structure pointed to by lpBimportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Import.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD APIENTRY BatchImportW (LPBIMPORT_PARMSW lpBimportParms);
extern DWORD APIENTRY BatchImportA (LPBIMPORT_PARMSA lpBimportParms);

#ifdef UNICODE
#define BatchImport        BatchImportW
#else
#define BatchImport        BatchImportA
#endif

/*******************************************************************************
*  
*   Batch Directory Export Interface definitions
*               
********************************************************************************/

typedef struct _BEXPORT_PARMSW
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPWSTR   pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   WCHAR     chColSep;           // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR     chQuote;            // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR     chMVSep;            // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR     cReserved;          // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes;      // DAPI_ENTRY filled with names of attributes to export
                                       // Optional if pszExportFile specified
                                       // Required if ExportCallback specified
   LPWSTR   pszHomeServer;       // Name of server for server-associated export
   LPWSTR * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSW, *PBEXPORT_PARMSW, *LPBEXPORT_PARMSW;

typedef struct _BEXPORT_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     cReserved;           // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes; // DAPI_ENTRY filled with names of attributes to export
                                        // Optional if pszExportFile specified
                                        // Required if ExportCallback specified
   LPSTR    pszHomeServer;       // Name of server for server-associated export
   LPSTR  * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSA, *PBEXPORT_PARMSA, *LPBEXPORT_PARMSA;


#ifdef UNICODE
typedef  BEXPORT_PARMSW    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSW   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSW  LPBEXPORT_PARMS;
#else
typedef  BEXPORT_PARMSA    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSA   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSA  LPBEXPORT_PARMS;
#endif



// Batch Export entry points

// The BatchExport function provides single-call BatchExport from the
//    specified import file.  All import parameters are specified in the
//    BEXPORT_PARMS structure pointed to by lpBexportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Export.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD   APIENTRY BatchExportW (LPBEXPORT_PARMSW lpBexportParms);
extern DWORD   APIENTRY BatchExportA (LPBEXPORT_PARMSA lpBexportParms);

#ifdef UNICODE
#define BatchExport     BatchExportW
#else
#define BatchExport     BatchExportA
#endif


/*******************************************************************************
*  
*  Single-Object Interface definitions             
*               
********************************************************************************/

typedef struct _DAPI_PARMSW
{
   DWORD        dwDAPISignature;
   DWORD        dwFlags;         // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPWSTR       pszDSAName;      // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR       pszBasePoint;    // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR       pszContainer;    // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPWSTR       pszNTDomain;     // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPWSTR       pszCreateTemplate;// DN of the template object used for default values
   PDAPI_ENTRY  pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSW, *PDAPI_PARMSW, FAR *LPDAPI_PARMSW;

typedef struct _DAPI_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPSTR    pszCreateTemplate;   // DN of the template object used for default values
   PDAPI_ENTRY   pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSA, *PDAPI_PARMSA, FAR *LPDAPI_PARMSA;


#ifdef UNICODE
typedef  DAPI_PARMSW    DAPI_PARMS;
typedef  PDAPI_PARMSW   PDAPI_PARMS;
typedef  LPDAPI_PARMSW  LPDAPI_PARMS;
#else
typedef  DAPI_PARMSA    DAPI_PARMS;
typedef  PDAPI_PARMSA   PDAPI_PARMS;
typedef  LPDAPI_PARMSA  LPDAPI_PARMS;
#endif


typedef  LPVOID   DAPI_HANDLE;
typedef  LPVOID * PDAPI_HANDLE;
typedef  LPVOID FAR * LPDAPI_HANDLE;

#define  DAPI_INVALID_HANDLE  ((DAPI_HANDLE) -1)



// DAPIStart initializes a DAPI session.
//    for use by DAPIRead and DAPIWrite.  The return value is 0 if no errors
//    are encountered.  A pointer to a DAPI_EVENT structure is returned if an 
//    error is encountered.  
//    NOTE:  The DAPI_HANDLE must be returned via a call to DAPIEnd.
//           If a non-NULL value is returned, its memory must be freed by
//           a call to DAPIFreeMemory
extern PDAPI_EVENTW APIENTRY DAPIStartW  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSW     lpDAPIParms);
extern PDAPI_EVENTA APIENTRY DAPIStartA  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSA     lpDAPIParms);

#ifdef UNICODE
#define DAPIStart    DAPIStartW
#else
#define DAPIStart    DAPIStartA
#endif

// DAPIEnd invalidates the DAPI_HANDLE obtained by the call to DAPIStart.
//    NOTE:  There are no separate Unicode / Ansi entry points defined 
extern   void  APIENTRY DAPIEnd (LPDAPI_HANDLE lphDAPISession);


// DAPIRead() Reads indicated attributes from the named Directory Object
// Parameters:  
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        control operation
//    pszObjectName  String containing name of object to read.
//                      If specified as RDN, combined w/ session's
//                      pszBasePoint and pszParentContainer.
//                      If specified w/ prefix of "/cn=", the string 
//                      is concatenated to the session pszBasePoint.
//                      If specified w/ prefix of "/o=", the string
//                      is taken to be a fully-qualified DN.
//    pAttList       Pointer to DAPI_ENTRY structure containing names of
//                      attributes to read.  The session default list is
//                      overridden for the present call only.
//    ppValues       Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the values read from the DIT entry.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
//    ppAttributes   Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the names of attributes read
//                      from the DIT IFF DAPI_ALL_ATTRIBUTES or DAPI_LEGAL_ATTRIBUTES
//                      were set in dwFlags.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
extern PDAPI_EVENTW APIENTRY DAPIReadW   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPWSTR         pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);
extern PDAPI_EVENTA APIENTRY DAPIReadA   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPSTR          pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);

#ifdef UNICODE
#define DAPIRead     DAPIReadW
#else
#define DAPIRead     DAPIReadA
#endif


// DAPIWrite() 
//   Perform the indicated write operation on the named object
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
// Parameters:  
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        Operational control
//    pAttributes   Pointer to DAPI_ENTRY structure containing names of
//                      attributes to write.  The session default list is
//                      used if this parameter is NULL
//    pValues        Pointer to DAPI_ENTRY structure containing the values 
//                      to set on the DIT entry.
//    lpulUSN         Optional:  Address of variable receiving USN of updated
//                      DIT entry.  May be specified as NULL to suppress this
//                      return value.
//    lppszCreatedAccount  Address receiving pointer to name of created NT account
//    lppszPassword  Address receiving pointer to password generated if
//                      NT Account is created. 
extern PDAPI_EVENTW APIENTRY DAPIWriteW (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPWSTR *       lppszCreatedAccount,
                                             LPWSTR *       lppszPassword);
extern PDAPI_EVENTA APIENTRY DAPIWriteA (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPSTR *        lppszCreatedAccount,
                                             LPSTR *        lppszPassword);
#ifdef UNICODE
#define DAPIWrite      DAPIWriteW
#else
#define DAPIWrite      DAPIWriteA
#endif


/*******************************************************************************
*  procedure :  DAPIAllocBuffer
*               
*    purpose :  Allocate buffer, logically linking it to the pvAllocBase
*               The first buffer in logically linked set of allocations must be 
*               freed by call to DAPIFreeMemory
*               
* parameters :  cbSize		dword containing size of allocation request (in bytes)
*               pvAllocBase	base for logical linking of allocated block
*                             May be NULL
*                             If non-NULL, must be a block previously allocated
*                             by DAPIAllocBuffer or returned by DAPI function
*               
*    returns :  ptr to allocated block
*               
*    history :  
*               
********************************************************************************/
extern LPVOID APIENTRY DAPIAllocBuffer (DWORD	cbSize, LPVOID	pvAllocBase);


/*******************************************************************************
*  procedure :  DAPIFreeMemory
*               
*    purpose :  Release memory allocated for structures returned by DAPI calls.
*               
* parameters :  lpVoid  pointer to block to free
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY DAPIFreeMemory (LPVOID   lpVoid);


/* 
 * NetUserList interface definitions
 */
// When getting callbacks from NTExport / NWExport, these indices
// can be used to interpret the value array returned in the callback
// >>>>    NOTE:  These indices are NOT valid for Bexport callback!    <<<<
#define  NET_CLASS         0
#define  NET_COMMON_NAME   1
#define  NET_DISPLAY_NAME  2
#define  NET_HOME_SERVER   3
#define  NET_COMMENT       4     /* NTExport only */

#define  NTEXP_ENTRY_COUNT 5 /* number of parts in NT User export */
#define  NWEXP_ENTRY_COUNT 4 /* number of parts in NetWare user export */



/*******************************************************************************
*  
* NTIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NTEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszDCName;        // Name of Domain Controller from which to get users
                                       // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
   LPWSTR            pszNTDomain;      // Name of Domain from which to read users
                                       // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
} NTEXPORT_PARMSW, *PNTEXPORT_PARMSW, FAR *LPNTEXPORT_PARMSW;

typedef struct _NTEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszDCName;        // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
                                       // Name of Domain from which to read users
   LPSTR             pszNTDomain;      // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
                                       
} NTEXPORT_PARMSA, *PNTEXPORT_PARMSA, FAR *LPNTEXPORT_PARMSA;

#ifdef UNICODE
typedef  NTEXPORT_PARMSW      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSW     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSW    LPNTEXPORT_PARMS;
#else
typedef  NTEXPORT_PARMSA      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSA     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSA    LPNTEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NTExportW (LPNTEXPORT_PARMSW pNTExportParms);
extern   DWORD APIENTRY    NTExportA (LPNTEXPORT_PARMSA pNTExportParms);

#ifdef UNICODE
#define NTExport              NTExportW
#else
#define NTExport              NTExportA
#endif


/*******************************************************************************
*  
* NWIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NWEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszFileServer;    // Name of the file server to connect to
   LPWSTR            pszUserName;      // User Name -- Must have administrator priviliges
   LPWSTR            pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSW, *PNWEXPORT_PARMSW, *LPNWEXPORT_PARMSW;

typedef struct _NWEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszFileServer;    // Name of the file server to connect to
   LPSTR             pszUserName;      // User Name -- Must have administrator priviliges
   LPSTR             pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSA, *PNWEXPORT_PARMSA, *LPNWEXPORT_PARMSA;

#ifdef UNICODE
typedef  NWEXPORT_PARMSW      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSW     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSW    LPNWEXPORT_PARMS;
#else
typedef  NWEXPORT_PARMSA      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSA     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSA    LPNWEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NWExportW (LPNWEXPORT_PARMSW pNWExportParms);
extern   DWORD APIENTRY    NWExportA (LPNWEXPORT_PARMSA pNWExportParms);

#ifdef UNICODE
#define NWExport              NWExportW
#else
#define NWExport              NWExportA
#endif


// Definitions for the DAPIGetSiteInfo call

typedef struct _NAME_INFOA
{
   LPSTR    pszName;                            // Simple object name
   LPSTR    pszDNString;                        // DN of object
   LPSTR    pszDisplayName;                     // Display name of object
} NAME_INFOA, *PNAME_INFOA;

typedef struct _NAME_INFOW
{
   LPWSTR   pszName;                            // Simple object name
   LPWSTR   pszDNString;                        // DN of object
   LPWSTR   pszDisplayName;                     // Display name of object
} NAME_INFOW, *PNAME_INFOW;

typedef struct _PSITE_INFOA
{
   LPSTR       pszCountry;                      // Country code
   NAME_INFOA  objServer;                       // Name information for server
   NAME_INFOA  objSite;                         // Name information for site containing server
   NAME_INFOA  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOA, *PSITE_INFOA;

typedef struct _PSITE_INFOW
{
   LPWSTR      pszCountry;                      // Country code
   NAME_INFOW  objServer;                       // Name information for server
   NAME_INFOW  objSite;                         // Name information for site containing server
   NAME_INFOW  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOW, *PSITE_INFOW;

#ifdef UNICODE
typedef  NAME_INFOW        NAME_INFO;
typedef  PNAME_INFOW       PNAME_INFO;
typedef  SITE_INFOW        SITE_INFO;
typedef  PSITE_INFOW       PSITE_INFO;
#else
typedef  NAME_INFOA        NAME_INFO;
typedef  PNAME_INFOA       PNAME_INFO;
typedef  SITE_INFOA        SITE_INFO;
typedef  PSITE_INFOA       PSITE_INFO;
#endif

extern PDAPI_EVENTA APIENTRY DAPIGetSiteInfoA (
                              DWORD    dwFlags,                // Flags for request
                              LPSTR    pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOA *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return data
);

extern PDAPI_EVENTW APIENTRY DAPIGetSiteInfoW (
                              DWORD    dwFlags,                // Flags for request
                              LPWSTR   pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOW *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return dataname of DSA from which to read schema
);

#ifdef UNICODE
#define  DAPIGetSiteInfo DAPIGetSiteInfoW
#else
#define  DAPIGetSiteInfo DAPIGetSiteInfoA
#endif



#ifdef __cplusplus
}
#endif

#endif   // _DAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\edkcode.h ===
// --edkcode.h------------------------------------------------------------------
//
//  EDK function ec = codes.
// 
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef _EDKCODE_H
#define _EDKCODE_H

#include <winerror.h>

// Every HRESULT is built from a serverity value, a facility
// value and an error code value.

#define FACILITY_EDK    11          // EDK facility value

// Pairs of EDK error codes and the HRESULTs built from them.
// EDK functions always return HRESULTs.  Console applications
// return exit codes via the _nEcFromHr function.

#define EC_EDK_E_NOT_FOUND          0x0001
#define EDK_E_NOT_FOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_NOT_FOUND)

#define EC_EDK_E_SHUTDOWN_SERVICE   0x0002
#define EDK_E_SHUTDOWN_SERVICE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_SHUTDOWN_SERVICE)

#define EC_EDK_E_ALREADY_EXISTS     0x0003
#define EDK_E_ALREADY_EXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_ALREADY_EXISTS)

#define EC_EDK_E_END_OF_FILE        0x0004
#define EDK_E_END_OF_FILE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_END_OF_FILE)

#define EC_EDK_E_AMBIGUOUS          0x0005
#define EDK_E_AMBIGUOUS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_AMBIGUOUS)

#define EC_EDK_E_PARSE              0x0006
#define EDK_E_PARSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_PARSE)

// maximum EDK exit code
#define MAX_EDK_ERROR_CODE          10

// exit codes for approved OLE and Win32 HRESULTs.
#define EC_EDK_E_FAIL               1 + MAX_EDK_ERROR_CODE
#define EC_EDK_E_OUTOFMEMORY        2 + MAX_EDK_ERROR_CODE
#define EC_EDK_E_INVALIDARG         3 + MAX_EDK_ERROR_CODE
#define EC_EDK_E_NOTIMPL            4 + MAX_EDK_ERROR_CODE
#define EC_EDK_E_NOINTERFACE        5 + MAX_EDK_ERROR_CODE
#define EC_EDK_E_ACCESSDENIED		6 + MAX_EDK_ERROR_CODE

// Unknown EDK exit code (HRESULT does not correspond to one of the "valid" EDK HRESULTs above)
#define EC_EDK_E_UNKNOWN            10 + MAX_EDK_ERROR_CODE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\edk2.hpp ===
#ifndef __EDK2_HPP__
#define __EDK2_HPP__
/*
===============================================================================
Module      -  edk.hpp
System      -  EnterpriseAdministrator
Creator     -  Steven Bailey
Created     -  2 Apr 97
Description -  Exchange MAPI and DAPI helper functions
Updates     -
===============================================================================
*/
#include <mapix.h>
#include <dapi.h>


typedef void (STDAPICALLTYPE FREEPADRLIST) (LPADRLIST lpAdrlist);

typedef FREEPADRLIST FAR * LPFREEPADRLIST;

typedef void (STDAPICALLTYPE FREEPROWS) (LPSRowSet lpRows);

typedef FREEPROWS FAR * LPFREEPROWS;

typedef SCODE (STDAPICALLTYPE SCDUPPROPSET)(  int cprop,                           
  LPSPropValue rgprop,LPALLOCATEBUFFER lpAllocateBuffer,LPSPropValue FAR * prgprop);

typedef SCDUPPROPSET FAR * LPSCDUPPROPSET;

typedef HRESULT (STDAPICALLTYPE HRQUERYALLROWS)(LPMAPITABLE lpTable, 
                        LPSPropTagArray lpPropTags,
                        LPSRestriction lpRestriction,
                        LPSSortOrderSet lpSortOrderSet,
                        LONG crowsMax,
                        LPSRowSet FAR *lppRows);

typedef HRQUERYALLROWS FAR * LPHRQUERYALLROWS;

typedef ULONG (STDAPICALLTYPE ULRELEASE)(LPVOID lpunk);

typedef ULRELEASE FAR * LPULRELEASE;


HRESULT 
   HrFindExchangeGlobalAddressList( 
      LPADRBOOK              lpAdrBook,        // in - address book pointer
      ULONG                * lpcbeid,          // out- pointer to count of bytes in entry ID
      LPENTRYID            * lppeid            // out- pointer to entry ID pointer
   );

//--HrCreateDirEntryIdEx-------------------------------------------------------
//  Create a directory entry ID given the address of the object
//  in the directory.
// -----------------------------------------------------------------------------
HRESULT 
   HrCreateDirEntryIdEx(			
	   LPADRBOOK	           lpAdrBook,			// in - address book (directory) to look in
	   LPWSTR                 lpszDN,				// in - object distinguished name
	   ULONG                * lpcbEntryID,		   // out- count of bytes in entry ID
	   LPENTRYID            * lppEntryID);	      // out- pointer to entry ID


// DAPI functions
//--HrEnumContainers--------------------------------------------------------
//  Enumerates the container name(s).
// -----------------------------------------------------------------------------
HRESULT 
   HrEnumContainers(             
      LPWSTR                 lpszServer,               // in - server name
      LPWSTR                 lpszSiteDN,               // in - distinguished name of site
      BOOL                   fSubtree,                 // in - sub-tree?
      LPWSTR               * lppszContainers);         // out- containers

//--HrEnumOrganizations-----------------------------------------------------
//  Enumerates the organization name(s).
// -----------------------------------------------------------------------------
HRESULT 
   HrEnumOrganizations(          
      LPWSTR                 lpszRootDN,               // in - distinguished name of DIT root
      LPWSTR                 lpszServer,               // in - server name
      LPWSTR               * lppszOrganizations);      // out- organizations

//--HrEnumSites-------------------------------------------------------------
//  Enumerates the site name(s).
// -----------------------------------------------------------------------------
HRESULT 
   HrEnumSites(                  
      LPWSTR                 lpszServer,               // in - server name
      LPWSTR                 lpszOrganizationDN,       // in - distinguished name of organization
      LPWSTR               * lppszSites);              // out- sites


typedef PDAPI_EVENTW (APIENTRY *LPDAPISTART)(LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSW     lpDAPIParms);

typedef void  (APIENTRY *LPDAPIEND)(LPDAPI_HANDLE lphDAPISession);

typedef PDAPI_EVENTW (APIENTRY *LPDAPIREAD)(DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPWSTR         pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);
typedef PDAPI_EVENTW (APIENTRY *LPDAPIWRITE)(DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPWSTR *       lppszCreatedAccount,
                                             LPWSTR *       lppszPassword);

typedef void (APIENTRY *LPDAPIFREEMEMORY)(LPVOID   lpVoid);

typedef DWORD (APIENTRY *LPBATCHEXPORT)(LPBEXPORT_PARMSW lpBexportParms);


extern LPDAPISTART                 pDAPIStart;
extern LPDAPIEND                   pDAPIEnd;
extern LPDAPIREAD                  pDAPIRead;
extern LPDAPIWRITE                 pDAPIWrite;
extern LPDAPIFREEMEMORY            pDAPIFreeMemory;
extern LPBATCHEXPORT               pBatchExport;




#endif //__EDK2_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__DF98CEF3_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED_)
#define AFX_DLLDATAX_H__DF98CEF3_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__DF98CEF3_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\enumvols.cpp ===
//#pragma title( "EnumVols.cpp - Volume Enumeration" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  enumvols.hpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Classes used to generate a list of pathnames, given a list of paths and/or 
               machine names.
Updates     -
===============================================================================
*/
#include <stdio.h>

#include "stdafx.h"

#include <lm.h>
#include <assert.h>

#include "Common.hpp"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "EnumVols.hpp"
#include "BkupRstr.hpp"

#define BUF_ENTRY_LENGTH     (3)

extern WCHAR *       // ret -machine-name prefix of pathname if pathname is a UNC path, otherwise returns NULL
   GetMachineName(
      const LPWSTR           pathname        // in -pathname from which to extract machine name
   );


extern TErrorDct err;
extern bool silent;

bool                                   // ret -true if name begins with "\\" has at least 3 total chars, and no other '\'
   IsMachineName(
      const LPWSTR           name      // in -possible machine name to check
   )
{
   assert( name );
   WCHAR                   * c = NULL;          // used to traverse the name (will stay NULL if prefix check fails)
   if ( name[0] == L'\\' &&  name[1] == L'\\' )               // check for "\\" prefix      
   {
         for ( c = name + 2 ; *c && *c != L'\\' ; c++ )     // check rest of string
         ;
   }
   return ( c && *c != L'\\' );      // <=> prefix check worked && we made it to the end of the string without hitting a '\'
}

bool                                   // ret -true if name is of the form \\machine\share
   IsShareName(
      const LPWSTR           name      // in -string to check
   )
{
   assert( name );

   WCHAR                   * c = NULL;          // used to traverse the name (will stay NULL if prefix check fails)
   bool                      skip = true;

   if ( name[0] == L'\\' &&  name[1] == L'\\' )               // check for "\\" prefix      
   {
         for ( c = name + 2 ; *c && (*c != L'\\' || skip) ; c++ )     // check rest of string
         {
            if ( *c == L'\\' )
               skip = false;
         }
   }
   return ( c && *c != L'\\' );   
}

bool 
   IsUNCName(
      const LPWSTR           name    // in - string to check
   )
{
   return ( name[0] == L'\\' && name[1] == L'\\' && name[2]!=0 );
}

bool 
   ContainsWildcard(
      WCHAR const *        string
   )
{
   bool                   wc = false;
   WCHAR          const * curr = string;

   if ( string )
   {
      while ( *curr && ! wc )
      {
         if (  *curr == L'*' 
            || *curr == L'?'
            || *curr == L'#'
            )
         {
            wc = true;
         }
         curr++;
      }
   }
   return wc;
}
   

/************************************************************************************
                           TPathNode Implementation
*************************************************************************************/
   TPathNode::TPathNode(
      const LPWSTR           name              // -in path-name for this node 
   )
{
   assert( name );                                  // name should always be a valid 
   assert( UStrLen(name) <= MAX_PATH );             // string, shorter than MAX_PATH               
   safecopy(path,name);
   iscontainer = true;
   FindServerName();
   LookForWCChars();
}

void 
   TPathNode::Display() const 
{
   wprintf(L"%s\n",path);
   wprintf(L"%s\n",server);
}

void 
   TPathNode::LookForWCChars()
{
   ContainsWC(ContainsWildcard(path)); 
}

void 
   TPathNode::FindServerName()
{
   WCHAR                     volRoot[MAX_PATH];
   WCHAR                     tempName[MAX_PATH];
   UINT                      driveType;
   DWORD                     rc = 0;
   REMOTE_NAME_INFO          info;
   DWORD                     sizeBuffer = (sizeof info);
   WCHAR                   * machine;
   
   if ( IsMachineName(path) )
   {
      safecopy(server,path);
   }
   else
   {
      safecopy(tempName,path);
      if ( path[0] != L'\\' || path[1] != L'\\' )       // get the unc name
      {
         swprintf(volRoot, L"%-3.3s", path);
         driveType = GetDriveType(volRoot);
         switch ( driveType )
         {
            case DRIVE_REMOTE:
               rc = WNetGetUniversalName(volRoot,
                                         REMOTE_NAME_INFO_LEVEL,
                                         (PVOID)&info,
                                         &sizeBuffer);
               switch ( rc )
               {
                  case 0:
                     safecopy(tempName, info.lpUniversalName);
                     swprintf(volRoot,L"%s\\%s",tempName,path+3);
                     safecopy(path,volRoot);
                     break;
                  case ERROR_NOT_CONNECTED:
                     break;
                  default:
                     err.SysMsgWrite(ErrE, rc, DCT_MSG_GET_UNIVERSAL_NAME_FAILED_SD,
                                                path, rc);
               }
               break;
         }
      }
      machine = GetMachineName(path);
      if ( machine )
      {
         safecopy(server,machine);
         delete machine;
      }
      else
      {
         server[0] = 0;
      }
   }
}

DWORD                                      // ret-0=path exists, ERROR_PATH_NOT_FOUND=path does not exist
   TPathNode::VerifyExists()
{
   DWORD                     rc = 0;
   WCHAR                     wname[MAX_PATH];
   int                       len;
   HANDLE                    hFind;
   WIN32_FIND_DATAW          findEntry;              
   SERVER_INFO_100         * servInfo = NULL;
   SHARE_INFO_0            * shareInfo = NULL;

   safecopy(wname,path);
   
   if ( IsMachineName(wname) )
   {
      rc = NetServerGetInfo(wname,100,(LPBYTE *)&servInfo);
      switch ( rc )
      {                   
      case NERR_Success:  
         break;
      case ERROR_BAD_NETPATH:
         rc = ERROR_PATH_NOT_FOUND;
         break;
      default:
         err.SysMsgWrite(ErrW,rc,DCT_MSG_SERVER_GETINFO_FAILED_SD,wname,rc);
         break;
      }
      if ( servInfo )
      {
         NetApiBufferFree(servInfo);
      }
   }
   else if ( IsShareName(wname) )
   {
      int                    ch;
      for ( ch = 2; wname[ch]!= L'\\' && wname[ch] ; ch++ )
         ;
      MCSVERIFY(wname[ch] == L'\\' );
      
      wname[ch] = 0;
      rc = NetShareGetInfo(wname,wname+ch+1,0,(LPBYTE *)&shareInfo);
      wname[ch] = L'\\';
      
      switch ( rc )
      {
      case NERR_NetNameNotFound:
         rc = ERROR_PATH_NOT_FOUND;
         break;
      case ERROR_SUCCESS:
         NetApiBufferFree(shareInfo);
         break;
      default:
         err.SysMsgWrite(ErrW,rc,DCT_MSG_SHARE_GETINFO_FAILED_SD,wname,rc);
         break;
      }
   }
   else
   {
      iscontainer = false;

      if ( wname[len = UStrLen(wname) - 1] == '\\' )  // len is the index of the last character (before NULL)
      {
         wname[len] = '\0';     // remove trailing backslash
         len--;
      }       
                                             // do a 'find' on this file w/o wildcards, in case it is a file
      hFind = FindFirstFileW(wname, &findEntry);
      
      if ( hFind == INVALID_HANDLE_VALUE )
      {                                      // it's not a file, lets see if it's a directory
                                             // do a find with \*.* appended
         validalone = false;
         UStrCpy(wname + len + 1,"\\*.*",DIM(wname) - len);
         hFind = FindFirstFileW(wname,&findEntry);
         if ( hFind == INVALID_HANDLE_VALUE )
         {
            rc = ERROR_PATH_NOT_FOUND;
         }
         iscontainer = true;
         wname[len+1] = 0;    
      }
      else
      {
         validalone = true;
         if ( findEntry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
         {
            iscontainer = true;
         } 
         FindClose(hFind);
      }
   }
   return rc;
}

DWORD                                            // ret- 0=successful, ERROR_PRIVILEGE_NOT_HELD otherwise
   TPathNode::VerifyBackupRestore()
{
   DWORD                     rc = 0;
   
   if ( ! GetBkupRstrPriv(server) )
   {
      rc = ERROR_PRIVILEGE_NOT_HELD;
   }
   
   return rc;
}
  
// GetRootPath finds the root path of a volume.  This is needed so we can call
// GetVolumeInformation to find out things like whether this volume supports ACLs
// This is fairly simplistic, and works by counting the backslashes in the path
DWORD                                        // ret- 0 or OS return code
   GetRootPath(
      WCHAR                * rootpath,       // out- path to root of volume
      WCHAR          const * path            // in - path within some volume
   )
{
   DWORD                     rc = 0;
   DWORD                     i = 0;
   DWORD                     slashcount = 1;
   bool                      unc = false;
   WCHAR                     tempPath[MAX_PATH];
   SHARE_INFO_2            * sInfo;

   if ( path[0] == L'\\' && path[1] == L'\\' )
   {
      slashcount = 4;
      unc = true;
   }
   for (i = 0 ; path[i] && slashcount &&  i < DIM(tempPath) ; i++ )
   {
      tempPath[i] = path[i];
      if ( tempPath[i] == L'\\' )
      {
         slashcount--;
      }
   }
   if ( tempPath[i-1] == L'\\' )
   {
      tempPath[i] = 0;     
   }
   else
   {
      tempPath[i] = L'\\' ;
      tempPath[i+1] = 0;
      i++;
   }
   
   // now rootpath contains either D:\ or \\machine\share\ .
   if ( unc )
   {
      // remove the trailing slash from the sharename
      if ( tempPath[i] == 0 )
      {
         i--;
      }
      if ( tempPath[i] == L'\\' )
      {
         tempPath[i] = 0;
      }
      // find the beginning of the share name
      while ( ( i > 0 ) && tempPath[i] != L'\\' )
         i--;

      if ( i < 3 )
      {
         MCSVERIFY(FALSE);
         rc = ERROR_INVALID_PARAMETER;
      }
      else
      {
         tempPath[i] = 0;
      }
      rc = NetShareGetInfo(tempPath,tempPath+i+1,2,(LPBYTE*)&sInfo);
      if ( ! rc )
      {
         swprintf(rootpath,L"%s\\%c$\\",tempPath,sInfo->shi2_path[0]);
         NetApiBufferFree(sInfo);
      }
   }
   else
   {
      UStrCpy(rootpath,tempPath);
   }
   return rc;
}

DWORD 
   TPathNode::VerifyPersistentAcls()                    // ret- 0=Yes, ERROR_NO_SECURITY_ON_OBJECT or OS error code
{
   DWORD               rc = 0;
   DWORD               maxcomponentlen;               // will be used as args for GetVolumeInformation
   DWORD               flags;
   UINT                errmode;                      
   WCHAR               rootpath[MAX_PATH];                     
   WCHAR               fstype[MAX_PATH];
   
   errmode = SetErrorMode(SEM_FAILCRITICALERRORS);    // set this to prevent message box when
                                                      // called on removable media drives which are empty
   if ( ! IsMachineName(path) )
   {
      rc = GetRootPath(rootpath,path);
      if ( ! rc )
      {
         if ( !GetVolumeInformation(rootpath,NULL,0,NULL,&maxcomponentlen,&flags,fstype,DIM(fstype)) )
         {
   
            rc = GetLastError();
   
            if ( rc != ERROR_NOT_READY ) 
            {
               err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_GET_VOLUME_INFO_FAILED_SD,rootpath,GetLastError());
            }
         }
         else 
         {
            SetErrorMode(errmode);                                // restore error mode to its prior state
            if (!( FS_PERSISTENT_ACLS & flags) )
            {
               rc = ERROR_NO_SECURITY_ON_OBJECT;
            }
         }
      }
   }
   return rc;
}

// This function is used when expanding wildcards in server names.  It replaces server field with the new name,
// and if the path is a UNC, it changes the server component of the path.
void 
   TPathNode::SetServerName(
      UCHAR          const * name          // in - new server name
   )
{
   if ( IsUNCName(path) )
   {
      WCHAR                  newpath[MAX_PATH];
      int                    len = UStrLen(server);

      swprintf(newpath,L"%S%s",name,path+len);

      safecopy(path,newpath);
   }
   safecopy(server,name);
}

/************************************************************************************
                           TPathList Implementation
*************************************************************************************/

   TPathList::TPathList()
{
   numServers = 0;
   numPaths   = 0;
}

   TPathList::~TPathList()
{
   TPathNode               * node;

   for (node = (TPathNode *)Head() ; Count() ; node = (TPathNode *)Head() )
   {
      Remove(node);
      delete node;
   }
}
// enumerate the nodes in the list, and display the name of each - used for debugging purposes
void 
   TPathList::Display() const
{
   TPathNode               * node;
   TNodeListEnum             displayenum;

   err.DbgMsgWrite(0,L"%ld servers, %ld total paths\n", numServers, numPaths);
   for ( node = (TPathNode *)displayenum.OpenFirst(this) ;
         node ;
         node = (TPathNode *)displayenum.Next() 
       )
   {
      node->Display();
   }          
   displayenum.Close();
}

void 
   TPathList::OpenEnum()
{
   tenum.Open(this);
}

// Return the name from the next node in the enumeration
// Returns NULL if no more nodes in the list
// OpenEnum() must be called before calling Next();
WCHAR *
   TPathList::Next()
{                             

   TPathNode               * pn = (TPathNode *)tenum.Next();
   LPWSTR                    result;
   if ( pn ) 
      result =  pn->GetPathName();
   else 
      result = NULL;
   return result;
}

void 
   TPathList::CloseEnum()
{                      
   tenum.Close();
}

      
bool                                               // ret -returns true if path added, false if path too long
   TPathList::AddPath(
      const LPWSTR           path,                  // in -path to add to list
      DWORD                  verifyFlags            // in -indicates which types of verification to perform
   )
{
   TPathNode               * pnode;
   bool                      error = false;
   bool                      messageshown = false;
   DWORD                     rc = 0;
   WCHAR                     fullpath[MAX_PATH];

   if ( UStrLen(path) >= MAX_PATH )
   {
      err.MsgWrite(ErrW,DCT_MSG_PATH_TOO_LONG_SD,path,MAX_PATH);
      messageshown = true;
      error = true;
   }

   _wfullpath(fullpath,path,DIM(fullpath));
   pnode = new TPathNode(fullpath);
   if (!pnode)
      return true;

   if ( ! ContainsWildcard(pnode->GetServerName()) )
   {
      if ( verifyFlags & VERIFY_EXISTS )
      {
         if ( rc = pnode->VerifyExists() )
         {
            error = true;
         }
      }
      if ( !error && ( verifyFlags & VERIFY_BACKUPRESTORE) )
      {
         if ( rc = pnode->VerifyBackupRestore() )
         {
//            WCHAR             * server = pnode->GetServerName();   
         
         }
      }
      if ( !error && (verifyFlags & VERIFY_PERSISTENT_ACLS ) )
      {
         rc = pnode->VerifyPersistentAcls();
         if ( rc == ERROR_NO_SECURITY_ON_OBJECT  )
         {
            err.MsgWrite(ErrW,DCT_MSG_NO_ACLS_S,fullpath);
            error = true;
            messageshown = true;
         }
      }
   }
   if ( ! error )
   {      
      AddPathToList(pnode);
      numPaths++;                                     // increment count of paths
   }
   else if ( !messageshown )
   {
      // need to include an error code here.
      if ( ! rc )
      {
         err.MsgWrite(ErrE,DCT_MSG_PATH_NOT_FOUND_S,fullpath);
      }
      else
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_CANNOT_READ_PATH_SD,fullpath,rc);
      }
	  delete pnode;
   }
   else
	  delete pnode;

   return error;
}

void 
   TPathList::Clear()
{
   TNodeListEnum             tEnum;
   TPathNode               * pNode;
   TPathNode               * pNext;

   for ( pNode = (TPathNode *)tEnum.OpenFirst(this) ; pNode ; pNode = pNext )
   {
      pNext = (TPathNode *)tEnum.Next();
      Remove(pNode);
      delete pNode;
   }
}

void
   TPathList::AddPathToList(
      TPathNode            * pNode           // in - path to add to the list
   )
{
   // set the IsFirstPathFromMachine property
   TNodeListEnum             tEnum;
   TPathNode               * currNode;
   bool                      machineFound = false;
   WCHAR                   * myMachine = GetMachineName(pNode->GetPathName());
   WCHAR                   * currMachine;

   for ( currNode = (TPathNode *)tEnum.OpenFirst(this) 
      ;  currNode && !machineFound 
      ;  currNode = (TPathNode *)tEnum.Next() )
   {
      currMachine = GetMachineName(currNode->GetPathName());
      if ( currMachine && myMachine )
      {  
         if ( !UStrICmp(currMachine,myMachine) )
         {
            machineFound = true;
         }
      }
      else
      {
         if ( !currMachine && ! myMachine )
         {
            machineFound = true;
         }
      }
      
      if ( currMachine )
         delete [] currMachine;
   }
   
   if ( myMachine )
      delete [] myMachine;

   tEnum.Close();
   
   pNode->IsFirstPathFromMachine(!machineFound);

   InsertBottom((TNode *)pNode);
}
   

// AddVolsOnMachine generates a list of volumes on the machine mach, checks for the administrative share 
// for each volume, and adds NTFS shared volumes to the pathlist
 
DWORD 
   TVolumeEnum::Open(
      WCHAR const          * serv,         // in - server to enumerate volumes on
      DWORD                  verifyflgs,    // in - flags indicating what to verify about each volume (i.e. NTFS)
      BOOL                   logmsgs         // in - flag whether to print diagnostic messages
     )
{  
   NET_API_STATUS            res;
   
   if ( isOpen )
      Close();

   if ( serv )
      safecopy(server,serv);
   else
      server[0] = 0;

   resume_handle = 0;
   pbuf = NULL;
   verbose = logmsgs;
   verifyFlags = verifyflgs;

   errmode = SetErrorMode(SEM_FAILCRITICALERRORS);    // set this to prevent message box when
                                                      // called on removable media drives which are empty
   if ( ! bLocalOnly )
   {

      res = NetServerDiskEnum(server,0,&pbuf,MAXSIZE, &numread, &total, &resume_handle);
      if (NERR_Success != res )
      {
         err.SysMsgWrite(ErrW, res, DCT_MSG_DRIVE_ENUM_FAILED_SD,server, res);
         isOpen = FALSE;
      }   
      if ( ! res )  
      {
         drivelist = (WCHAR *) pbuf;                        // NetServerDiskEnum returns an array of
         isOpen = true;                                     // WCHAR[3] elements (of the form <DriveLetter><:><NULL>)
         curr = 0;
      } 
   }
   else
   {
      pbuf = new BYTE[5000];
	  if (!pbuf)
	     return ERROR_NOT_ENOUGH_MEMORY;

      res = GetLogicalDriveStrings(2500,(WCHAR *)pbuf);
      if (! res )
      {
         res = GetLastError();
         err.SysMsgWrite(ErrW, res,DCT_MSG_LOCAL_DRIVE_ENUM_FAILED_D,res);   
      }
      else
      {
         if ( res < 5000 )   
         {
            drivelist = (WCHAR*)pbuf;
            isOpen = true;
            curr = 0;
            res = 0;
         }
         else
         {
            err.MsgWrite(ErrW,DCT_MSG_DRIVE_BUFFER_TOO_SMALL);
         }
      } 
   }
   return res;
}

WCHAR * 
   TVolumeEnum::Next()
{
   WCHAR                   * pValue = NULL;
   WCHAR                     ShareName[MAX_PATH];
   WCHAR                     rootsharename[MAX_PATH];    // this will hold "machinename\C$\"
   NET_API_STATUS            res;
   bool                      found = false;

   assert(isOpen);

   while ( ! found )
   {
      if (  ( !bLocalOnly && curr < BUF_ENTRY_LENGTH * numread ) 
         || ( bLocalOnly && drivelist[curr] ) ) 
      {
         if ( verbose ) 
            err.DbgMsgWrite(0,L"%C\n",drivelist[curr]);

         if ( ! bLocalOnly )
         {
            swprintf(ShareName,L"%c$",drivelist[curr]);                                   
            res = NetShareGetInfo(server, ShareName, 1, &shareptr); // is this really necessary?

            switch ( res )
            {
            case NERR_NetNameNotFound:
               if ( verbose ) 
                  err.DbgMsgWrite(0,L"Not Shared\n");
               break;
            case NERR_Success:
               {
                  if ( verbose ) 
                     err.DbgMsgWrite(0,L"Shared\n");
                  NetApiBufferFree(shareptr);
                  shareptr = NULL;
                                                                     // build the complete share name
                  DWORD               mnamelen = UStrLen(server);                
                  WCHAR               append[5] = L"\\C$\\";                          

                  append[1] = drivelist[curr];                               // change the 'C' to the actual drive letter
                  UStrCpy(rootsharename, server, mnamelen+1);
                  UStrCpy(&rootsharename[mnamelen], append, 5);
                  if ( verbose ) 
                     err.DbgMsgWrite(0,L"Share name: %S\n",rootsharename);  
               }
               break;
            default:
               err.MsgWrite(ErrW,DCT_MSG_ADMIN_SHARES_ERROR_SSD,ShareName,server,res);
               break;
            }
         }
         else
         {
            res = GetDriveType(&drivelist[curr]);
            switch ( res )
            {
            case DRIVE_REMOVABLE:
            case DRIVE_FIXED:
               res = 0;
               break;
            case DRIVE_REMOTE:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_REMOTE_S, &drivelist[curr]);
               break;
            case DRIVE_CDROM:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_CDROM_S, &drivelist[curr]);
               break;
            case DRIVE_RAMDISK:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_RAMDISK_S, &drivelist[curr]);
               break;
            case DRIVE_UNKNOWN:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_UNKNOWN_S, &drivelist[curr]);
               break;
            case DRIVE_NO_ROOT_DIR:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_NO_ROOT_S, &drivelist[curr]);
               break;
            default:
               err.MsgWrite(0,DCT_MSG_SKIPPING_DRIVE_SD, &drivelist[curr],res);
               break;
            }
            UStrCpy(rootsharename,&drivelist[curr]);
            curr++;
         }
         if ( ! res )
         {
            if ( verifyFlags & VERIFY_PERSISTENT_ACLS )
            {
               TPathNode     pnode(rootsharename);
               DWORD rc  = pnode.VerifyPersistentAcls();
               if ( !rc )
               {
                  safecopy(currEntry,rootsharename);
                  pValue = currEntry;
                  found = true;
               }
               else if ( rc == ERROR_NO_SECURITY_ON_OBJECT )
               {
                  err.MsgWrite(0,DCT_MSG_SKIPPING_FAT_VOLUME_S,rootsharename);
               }
               else
               {
                  err.SysMsgWrite(0,rc,DCT_MSG_SKIPPING_PATH_SD,rootsharename,rc);
               }
            }
            else
            {
               safecopy(currEntry,rootsharename);
               pValue = currEntry;
               found = true;
            }
         }
         curr += BUF_ENTRY_LENGTH;
      }
      else
      {
         break; // no more drives left
      }
   }
   
   return pValue;
}

void 
   TVolumeEnum::Close()
{
   if ( pbuf )
   {
      if (! bLocalOnly )
      {
         NetApiBufferFree(pbuf);
      }
      else
      {
         delete [] pbuf;
      }
      pbuf = NULL;
   }
   isOpen = FALSE;
   SetErrorMode(errmode);      // restore error mode to its prior state
}
   
int                                      // ret -0 if successful, nonzero otherwise
   TPathList::AddVolsOnMachine(
      const LPWSTR           mach,       // in - name of server
      bool                   verbose,    // in - flag indicating whether to display stuff or not
      bool                   verify
   )
{
   DWORD                     numread;           // number of volnames read this time
   DWORD                     total;             // total # vols
   DWORD                     resume_handle = 0;
   DWORD                     curr;              // used to iterate through volumes
   LPBYTE                    pbuf;
   WCHAR                   * drivelist;
   WCHAR                     ShareName[10]; // this holds "C$"
   LPBYTE                    shareptr;
   int                       errcode = 0;
   NET_API_STATUS            res;

   pbuf = NULL;
   res = NetServerDiskEnum(mach,0,&pbuf,MAXSIZE, &numread, &total, &resume_handle);
   if (NERR_Success != res )
   {
      err.MsgWrite(ErrW, DCT_MSG_DRIVE_ENUM_FAILED_SD,mach, res);
      errcode = 1;
   }   
   if ( ! errcode )  
   {
      drivelist = (WCHAR *) pbuf;                        // NetServerDiskEnum returns an array of
                                                         // WCHAR[3] elements (of the form <DriveLetter><:><NULL>)
                                                       
      for (curr = 0 ; curr < BUF_ENTRY_LENGTH * numread ; curr += BUF_ENTRY_LENGTH)   // for each drive letter returned
      {
         if ( verbose ) 
            err.DbgMsgWrite(0,L"%c\n",drivelist[curr]);
         swprintf(ShareName,L"%c$",drivelist[curr]);                                   
         res = NetShareGetInfo(mach, ShareName, 1, &shareptr); // is this really necessary
         if ( NERR_NetNameNotFound != res && NERR_Success != res )
         {
             err.MsgWrite(ErrW,DCT_MSG_ADMIN_SHARES_ERROR_SSD,ShareName,mach,res);
         }
    
         if ( NERR_NetNameNotFound == res ) 
         {
            if ( verbose ) 
               err.DbgMsgWrite(0,L"Not Shared\n");
         }
         if ( NERR_Success == res )
         {
            if ( verbose ) 
               err.DbgMsgWrite(0,L"Shared\n");
            NetApiBufferFree(shareptr);
            shareptr = NULL;
                                                               // build the complete share name
            DWORD               mnamelen = UStrLen(mach);                
            WCHAR             * rootsharename = new WCHAR[mnamelen + 5];    // this will hold "machinename\C$\"
            WCHAR             * append = L"\\C$\\";
			if (!rootsharename)
               return 1;

            append[1] = drivelist[curr];                               // change the 'C' to the actual drive letter
            UStrCpy(rootsharename, mach, mnamelen+1);
            UStrCpy(&rootsharename[mnamelen], append, 5);
            if ( verbose ) 
               err.DbgMsgWrite(0,L"Share name: %ls\n",rootsharename);  
                                                                // maxcomponentlen, & flags             
            DWORD               maxcomponentlen;               // will be used as args for GetVolumeInformation
            DWORD               flags;
            UINT                errmode;                      
            errmode = SetErrorMode(SEM_FAILCRITICALERRORS);    // set this to prevent message box when
                                                               // called on removable media drives which are empty
        
            if ( ! GetVolumeInformation(rootsharename,NULL,0,NULL,&maxcomponentlen,&flags,NULL,0) )
            {
               err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_SHARE_GETINFO_FAILED_SD,rootsharename,GetLastError());
               errcode = drivelist[curr];
               errcode = 0;
               continue;
            }
            SetErrorMode(errmode);                                // restore error mode to its prior state
            if ( FS_PERSISTENT_ACLS & flags )
            {
               if ( verbose ) 
                  err.DbgMsgWrite(0,L"Adding filesystem to list\n");   
               AddPath(rootsharename,verify);
            }
            delete rootsharename;
         }      
      }
      NetApiBufferFree(pbuf);
      numServers++;                          // update numServers statistic
      }
   return errcode;
}

// for each string in argv, determine whether it is a machine name or pathname, and use 
// AddPath or AddVolsOnMachine as appropriate

int                                           // ret -returns 0 if successful, nonzero otherwise
   TPathList::BuildPathList(
      TCHAR               ** argv,            // in- list of paths/servers from command-line args
      int                    argn,
      bool                   verbose          // in- flag, if true Display contents of list, along with stats
   )
{
   
   WCHAR                     warg[MAX_PATH]; 
   int                       currentArg;
   int                       errcode = 0;
   if ( ! argv[0] ) 
   {
      err.MsgWrite(ErrE,DCT_MSG_NO_PATHS);
      errcode = 1;
   }
   else
   {
      for ( currentArg = 0 ; ( currentArg < argn ) &&  *argv[currentArg] && !errcode; currentArg++ )
      {
         if ( UStrLen(argv[currentArg]) > MAX_PATH )
         {
            err.MsgWrite(ErrW,DCT_MSG_PATH_TOO_LONG_SD,argv[currentArg],MAX_PATH);
         }
         else 
         { // need to check for quotes -- if we read from the file, we may have something like argv[i] = "Program,
           //                             and argv[i+1] = Files"
            if ( *argv[currentArg] == '"' )
            {  // scan the strings until the matching close quote is found
               argv[currentArg]++;                 // skip the open quote
               TCHAR       * c;
               TCHAR         p[MAX_PATH];
               int           plen = 0;
               int           currlen;

               for ( c = argv[currentArg] ; c && *c != _T('"') ; c++ )
               {
                  if ( ! *c ) // we've reached the end of this string
                  {
                     currlen = UStrLen(argv[currentArg]);
                     UStrCpy(&p[plen],argv[currentArg],currlen + 1); // copy the string, including the NULL
                     plen += currlen;
                     p[plen++] = ' ';                            // add the space which caused these fields to be seperated
                     p[plen] = NULL;
                     currentArg++;
                     if ( currentArg < argn )
                        c = argv[currentArg];
                     else
                     {
                        c = NULL;
                        break;
                     }
                  }
               }
               if ( c ) // we found the quote 
               {
                  // copy p to argv[currentArg]
                  currlen = UStrLen(argv[currentArg]);
                  UStrCpy(&p[plen],argv[currentArg],currlen);
                  // p now contains the full path
                  safecopy(warg,p);
               }
               else   // unclosed quote -- log error and abort
               {
                  err.MsgWrite(ErrE,DCT_MSG_NO_ENDING_QUOTE_S,p);
                  errcode = 2;
               }
            }
            else
            {
               safecopy(warg,argv[currentArg]);
            }
            errcode = AddPath(warg, VERIFY_EXISTS | VERIFY_BACKUPRESTORE );
         }
      }
   }
   return errcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\exchange.cpp ===
#include "stdafx.h"

#include "exchange.hpp"

#include "common.hpp"
#include "err.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"

#include "sidcache.hpp"
#include "sd.hpp"
#include "SecObj.hpp"
#include "MAPIProf.hpp"
#include "exldap.h"

#include "Mcs.h"

extern TErrorDct     err;

#define NOT_PT_ERROR(x) ( PROP_TYPE(x.ulPropTag) != PT_ERROR )

#define LDAP_PortNumber_DN_Part          L"/cn=Protocols/cn=LDAP"
#define ATT_OBJ_CLASS          L"Obj-Class"
#define ATT_DIST_NAME          L"Obj-Dist-Name"
#define ATT_LDAP_PORT          L"Port-Number"
#define LDAP_USE_SITE_VALUES     L"Use-Site-Values"


// Stuff related to dynamic loading of DAPI.DLL

HINSTANCE                    hDapi = NULL;
LPDAPISTART                  pDAPIStart = NULL;
LPDAPIEND                    pDAPIEnd = NULL;
LPDAPIREAD                   pDAPIRead = NULL;
LPDAPIWRITE                  pDAPIWrite = NULL;
LPDAPIFREEMEMORY             pDAPIFreeMemory = NULL;
LPBATCHEXPORT                pBatchExport = NULL;

BOOL LoadDAPI()
{
   BOOL                      success = TRUE;

   if ( ! hDapi )
   {
      success = FALSE;
      hDapi = LoadLibrary(_T("DAPI.DLL"));
      if ( hDapi )
      {
         do { // once 
            pDAPIStart = (LPDAPISTART)GetProcAddress(hDapi,"DAPIStartW@8");
            if ( ! pDAPIStart )
            {
               err.MsgWrite(ErrE,DCT_MSG_DAPI_ENTRY_POINT_NOT_FOUND_S,L"DAPIStart");
               break;
            }
            pDAPIEnd = (LPDAPIEND)GetProcAddress(hDapi,"DAPIEnd@4");
            if ( ! pDAPIEnd )
            {
               err.MsgWrite(ErrE,DCT_MSG_DAPI_ENTRY_POINT_NOT_FOUND_S,L"DAPIEnd");
               break;
            }
            
            pDAPIRead = (LPDAPIREAD)GetProcAddress(hDapi,"DAPIReadW@24");
            if ( ! pDAPIRead )
            {
               err.MsgWrite(ErrE,DCT_MSG_DAPI_ENTRY_POINT_NOT_FOUND_S,L"DAPIRead");
               break;
            }
            
            pDAPIWrite = (LPDAPIWRITE)GetProcAddress(hDapi,"DAPIWriteW@28");
            if ( ! pDAPIWrite )
            {
               err.MsgWrite(ErrE,DCT_MSG_DAPI_ENTRY_POINT_NOT_FOUND_S,L"DAPIWrite");
               break;
            }

            pDAPIFreeMemory = (LPDAPIFREEMEMORY)GetProcAddress(hDapi,"DAPIFreeMemory@4");
            if ( ! pDAPIFreeMemory )
            {
               err.MsgWrite(ErrE,DCT_MSG_DAPI_ENTRY_POINT_NOT_FOUND_S,L"DAPIFreeMemory");
               break;
            }

            pBatchExport = (LPBATCHEXPORT)GetProcAddress(hDapi,"BatchExportA@4");
            if ( ! pBatchExport )
            {
               err.MsgWrite(ErrE,DCT_MSG_DAPI_ENTRY_POINT_NOT_FOUND_S,L"BatchExport");
               break;
            }
            success = TRUE;
         } while (false);
      }
      else
      {
         err.MsgWrite(ErrE,DCT_MSG_DAPI_LOAD_LIBRARY_FAILED);
      }
   }
   if ( ! success )
   {
      ReleaseDAPI();
   }
   return success;
}

void ReleaseDAPI()
{
   if ( hDapi )
   {
      FreeLibrary(hDapi);
      hDapi = NULL;
      pDAPIStart = NULL;
      pDAPIEnd = NULL;
      pDAPIRead = NULL;
      pDAPIWrite = NULL;
      pDAPIFreeMemory = NULL;
      pBatchExport = NULL;
   }
}

TGlobalDirectory::TGlobalDirectory()
{
   m_stat                     = NULL;
   m_bUseDefaultMapiProfile   = FALSE;               // Whether to use MAPI profile listed in Registry.
   m_bPromptForMapiProfile    = TRUE;                // Whether to prompt for MAPI profile.
   m_pszMapiProfile           = NULL;                // MAPI profile to use.

   // MAPI
   m_bMapiInitialized         = FALSE;               // TRUE if initialization was successful.
   m_pMapiSession             = NULL;                // MAPI session handle.

   m_pAdrBook                 = NULL;                // The master AB.

   m_pGlobalList              = NULL;
   m_pGlobalTable             = NULL;
   m_pGlobalPropertyTags      = NULL;
   m_pGlobalRows              = NULL;
   m_pRootRows                = NULL;
   m_pContainer               = NULL;
   m_pContainerTable          = NULL;
}

TGlobalDirectory::~TGlobalDirectory()
{
   delete [] m_pszMapiProfile;

   CloseGlobalList();
   EndMapiSession();
}


LPTSTR   TGlobalDirectory::GetMapiProfile() const
{
   return m_pszMapiProfile;
} 

BOOL  TGlobalDirectory::DoUseDefaultMapiProfile() const
{
   return m_bUseDefaultMapiProfile;
} 

BOOL  TGlobalDirectory::DoPromptForMapiProfile() const
{
   return m_bPromptForMapiProfile;
} 

///////////////////////////////////////////////////////////////////////////////
// Log a MAPI warning or error.
void  
   TGlobalDirectory::LogMapiError(
      int                    iSeverity,     // in - Severity (i.e. ErrW, ErrE, etc)
      LPCTSTR                pszEntryPoint, // in - API that generated the error
      HRESULT                hr             // in - error code
   )
{
   if (hr != 0)
      err.MsgWrite(iSeverity,DCT_MSG_GENERIC_HRESULT_SD, pszEntryPoint, hr);
   else
      err.MsgWrite(iSeverity,DCT_MSG_GENERIC_S, pszEntryPoint);
}

void 
   TGlobalDirectory::LogDapiError(
      int                    iSeverity,      // in - severity of error (i.e. ErrW, ErrE, etc.)
      LPCTSTR                pszUserMessage, // in - message describing the action that failed
      DAPI_EVENT           * pResult         // in - DAPIEvent error structure returned from Exchange
   )
{
   WCHAR                     strMsg[1000];
   DWORD                     dimMsg = DIM(strMsg);
   DWORD                     lenMsg;
   DAPI_EVENT              * pEvt;
   WCHAR                     msg[2000];
   
   if ( !pResult )
      return;
   
   safecopy(msg,pszUserMessage);

   for ( pEvt = pResult ; pEvt ; pEvt = pEvt->pNextEvent )
   {
      strMsg[0] = 0;
      lenMsg = FormatMessageW(
               FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
               pEvt->hinstDAPI,
               pEvt->dwDAPIError,
               0,
               strMsg,
               dimMsg,
               (va_list*)pEvt->rgpszSubst
               );
      UStrCpy(msg+UStrLen(msg),strMsg,DIM(msg)-UStrLen(msg));
   }
   err.MsgWrite(iSeverity,DCT_MSG_GENERIC_S,&*msg);
}

///////////////////////////////////////////////////////////////////////////////
// Start a MAPI session.
// Tries to use the profile specified on the command line.
BOOL  TGlobalDirectory::StartMapiSession()
{
   //ASSERT(m_bMapiInitialized == FALSE);
   MCSASSERT(m_pMapiSession == NULL);
   
   HRESULT  hr;
   if ( !m_bMapiInitialized )
   {
      hr = (*pMAPIInitialize)(NULL);

      if (FAILED(hr)) 
      {
         LogMapiError(ErrE, TEXT("MAPIInitialize"), hr);
         return FALSE;
      }

      m_bMapiInitialized = TRUE;
   }
   FLAGS    fLogonOptions = MAPI_NEW_SESSION | MAPI_NO_MAIL;
   LPTSTR   pszMapiProfile;

   if (DoUseDefaultMapiProfile()) {
      fLogonOptions |= MAPI_USE_DEFAULT;
      pszMapiProfile = NULL;
   }
   else if (DoPromptForMapiProfile()) {
      fLogonOptions |= MAPI_LOGON_UI | MAPI_EXPLICIT_PROFILE;
      pszMapiProfile = NULL;
   }
   else {
      fLogonOptions |= MAPI_EXPLICIT_PROFILE ;
      pszMapiProfile = GetMapiProfile();
   }

   hr = (*pMAPILogonEx)(0, pszMapiProfile, NULL, fLogonOptions | MAPI_UNICODE, &m_pMapiSession);
   if (FAILED(hr)) {
      switch (hr) {
      case MAPI_E_USER_CANCEL:
         break;
      default:
         err.SysMsgWrite(ErrE,hr,DCT_MSG_NO_MAPI_SESSION_D,hr);
         break;
      }
      return FALSE;
   }

   m_bLoggedFailedClose = FALSE;
   return TRUE;
} /* TGlobalDirectory::StartMapiSession() */

///////////////////////////////////////////////////////////////////////////////
// Terminate a MAPI session.
// No-op if there's not one open.
void  TGlobalDirectory::EndMapiSession()
{
   if (m_pMapiSession) {
      HRESULT  hr = m_pMapiSession->Logoff(0, 0, 0);

      if (SUCCEEDED(hr))
         m_pMapiSession = NULL;
      else if (!m_bLoggedFailedClose) {
         err.SysMsgWrite(ErrW,hr,DCT_MSG_MAPI_LOGOFF_FAILED_D,hr);
      }

      // NOTE: If this fails once, it may fail twice.
      // The second failure will come on the dtor.
      // This is on purpose. It's a retry. But we report it only once.
   }

   if (m_bMapiInitialized) 
   {
      (*pMAPIUninitialize)();
      m_bMapiInitialized = FALSE;
   }
} /* TGlobalDirectory::EndMapiSession() */

///////////////////////////////////////////////////////////////////////////////
// Open the Address Book and get an interface to the Global List.
// The Global List contains the Distribution Lists.
BOOL  TGlobalDirectory::OpenGlobalList()
{
   // Open the Address Book.
   if ( ! m_pMapiSession )
      return FALSE;

   HRESULT  hr = m_pMapiSession->OpenAddressBook(0, NULL, AB_NO_DIALOG , &m_pAdrBook);

   if (FAILED(hr)) 
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_NO_ADDRBOOK_D,hr);
      return FALSE;
   }

   // Get the GAL entry ID.
   ULONG       cbEntryId;
   LPENTRYID   pEntryId;

   hr = HrFindExchangeGlobalAddressList(m_pAdrBook, &cbEntryId, &pEntryId);

   if (FAILED(hr)) 
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_FAILED_TO_OPEN_GAL_D,hr);
      return FALSE;
   }

   // Load the GAL from the AB.
   ULONG    ulObjType;
   hr = m_pAdrBook->OpenEntry(cbEntryId, pEntryId, NULL, 0, &ulObjType, (LPUNKNOWN*)&m_pGlobalList);

   (*pMAPIFreeBuffer)(pEntryId);

   if (FAILED(hr)) 
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_RETRIEVE_GAL_FAILED_D,hr);
      return FALSE;
   }

   // Get a list of the contents of the Global List.
   hr = m_pGlobalList->GetContentsTable(0, &m_pGlobalTable);
   
   if (FAILED(hr)) 
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_RETRIEVE_GAL_FAILED_D,hr);
      return FALSE;
   }

   return TRUE;
} /* TEaSyncCommand::OpenGlobalList() */

///////////////////////////////////////////////////////////////////////////////
// Release the interfaces to the Global List and the Address Book.
void  TGlobalDirectory::CloseGlobalList()
{
   if (m_pGlobalTable != NULL) 
   {
      m_pGlobalTable->Release();
      m_pGlobalTable = NULL;
   }

   if (m_pGlobalList != NULL) 
   {
      m_pGlobalList->Release();
      m_pGlobalList = NULL;
   }

   if (m_pAdrBook != NULL) 
   {
      m_pAdrBook->Release();
      m_pAdrBook = NULL;
   }
} /* TGlobalDirectory::CloseGlobalList() */





BOOL 
   TGlobalDirectory::UpdateEntry( 
      LPMAPIPROP               pUserEntry,  // in - interface to mail recipient object
      ULONG                    ulType,      // in - type of object
      SecurityTranslatorArgs * args         // in - translation settings
   )
{
   // Prepare to get the columns that interest us.
   // For DCT, we probably only care about ASSOC_NT_ACCOUNT, and possibly PR_EMS_AB_NT_SECURITY_DESCRIPTOR
   HRESULT           hr;
   BOOL              anychange = FALSE;
   BOOL              verbose = args->LogVerbose();

   MCSASSERT(pUserEntry);
   if ( args->Cache()->IsCancelled() )
   {
      err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
      return FALSE;
   }
   SizedSPropTagArray(5, oPropertiesToGet) =
   {
      5,
      {
         PR_DISPLAY_NAME,
         PR_EMS_AB_ASSOC_NT_ACCOUNT,         // SID
         PR_ENTRYID,
         PR_EMS_AB_NT_SECURITY_DESCRIPTOR,   // SD
         PR_DISPLAY_TYPE
      }
   };
   ULONG    ulPropsReturned = 0;
   LPSPropValue   pUserProperties = NULL;

   hr = pUserEntry->GetProps((SPropTagArray *)&oPropertiesToGet,
                             0, &ulPropsReturned, &pUserProperties);
   
   if (FAILED(hr)) 
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_GET_SECURITY_FOR_RECIP_FAILED_D,hr);
      pUserEntry->Release();
      pUserEntry = NULL;
      return FALSE;
   }

   if (ulPropsReturned != oPropertiesToGet.cValues) 
   {
      err.MsgWrite(ErrE,DCT_MSG_GET_SECURITY_FOR_RECIP_FAILED_D,hr);
      pUserEntry->Release();
      pUserEntry = NULL;
      return FALSE;
   }

   // 1. Translate the    PR_EMS_AB_ASSOC_NT_ACCOUNT property

   WCHAR name[MAX_PATH];
   safecopy(name,pUserProperties[0].Value.lpszW);
   if ( m_stat )
   {
      m_stat->DisplayPath(name);
      m_stat->IncrementExamined(mailbox);
   }
   PISID pSid = (PISID)pUserProperties[1].Value.bin.lpb;
   if (pSid != NULL) 
   {
    
      LPSPropValue         pNewPropValues = NULL;
      LPSPropProblemArray  pProblems      = NULL;

      // check if the sid is one we need to change            
      //TRACE (_T("DisplayName = %s "),pUserProperties[0].Value.lpszW);
      PSID newSid = 0;
      TAcctNode * node;

      if ( IsValidSid(pSid) )
      {
      
         node = args->Cache()->Lookup(pSid); 
         if ( m_stat )
         {
            m_stat->IncrementOwnerExamined();
            if ( verbose )
               err.MsgWrite(0,DCT_MSG_EXAMINED_S,pUserProperties[0].Value.lpszW);
         }
         if ( node == (TAcctNode*)-1  && m_stat )
            m_stat->IncrementOwnerNoTarget();

         if ( node && (node != (TAcctNode *)-1) && node->IsValidOnTgt() )
            newSid = args->Cache()->GetTgtSid(node);
         else
            newSid = NULL;
      }
      else
      {
         newSid = NULL;
      }
      if ( newSid )
      {
         //TRACE (_T("needs to be translated\n"));
         // update the entry, or maybe put it into a list of entries to be updated
         // Allocate a buffer to set the property.
         MCSASSERT ( IsValidSid(newSid) );
         PSID        pMapiSid;
         DWORD       dwSidLength = GetLengthSid(newSid);
   
         hr = ResultFromScode((*pMAPIAllocateBuffer)((sizeof SPropValue) * 1, (void **)&pNewPropValues));
         if (FAILED(hr)) 
         {
            err.SysMsgWrite(ErrE,hr,DCT_MSG_FAILED_TO_ALLOCATE_BUFFER_D,hr);
            goto exit_update_sid;
         }
         // Allocate a buffer for the SID
         hr = ResultFromScode((*pMAPIAllocateBuffer)(dwSidLength, (void **)&pMapiSid));
         if (FAILED(hr)) 
         {
            err.SysMsgWrite(ErrE,hr,DCT_MSG_FAILED_TO_ALLOCATE_BUFFER_D,hr);
            goto exit_update_sid;
         }
         // Copy the SID.
         CopySid(dwSidLength,pMapiSid,newSid);
         // Write the SID
         pNewPropValues[0].ulPropTag = PR_EMS_AB_ASSOC_NT_ACCOUNT;
         pNewPropValues[0].Value.bin.lpb = (UCHAR *)pMapiSid;
         pNewPropValues[0].Value.bin.cb = dwSidLength;
         MCSASSERT (IsValidSid (pMapiSid) );

         if ( m_stat )
         {
            m_stat->IncrementOwnerChange(node,mailbox,NULL);
         }
         anychange = TRUE;
         if ( ! args->NoChange() )
         {
            hr = pUserEntry->SetProps(1, pNewPropValues, &pProblems);

            if (FAILED(hr)) 
            {
               err.SysMsgWrite(ErrE,hr,DCT_MSG_UPDATE_ACCOUNT_FAILED_D, hr);
               pProblems = NULL; // Don't try to free this if SetProps fails.
               goto exit_update_sid;
            }

            // Save changes.
            hr = pUserEntry->SaveChanges(KEEP_OPEN_READWRITE);

            if (FAILED(hr)) 
            {
               err.SysMsgWrite(ErrE,hr,DCT_MSG_SAVE_CHANGES_FAILED_D, hr);
               goto exit_update_sid;
            }
         }
     
         exit_update_sid:
         if (pMapiSid != NULL)
            (*pMAPIFreeBuffer)(pMapiSid);

         if (pProblems != NULL)
            (*pMAPIFreeBuffer)(pProblems);

         if (pNewPropValues != NULL)
            (*pMAPIFreeBuffer)(pNewPropValues);

      }
   }
   // 2.  Translate the PR_EMS_AB_NT_SECURITY_DESCRIPTOR property
   PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)pUserProperties[3].Value.bin.lpb;
   if ( pSD && PR_EMS_AB_NT_SECURITY_DESCRIPTOR == pUserProperties[3].ulPropTag  )
   {
      TMapiSD   tMailbox((SECURITY_DESCRIPTOR *)pSD);
      
      tMailbox.SetName(pUserProperties[0].Value.lpszW);
     
      if ( tMailbox.HasSecurity() )
      {
         TSD               * pSD = tMailbox.GetSecurity();

         bool  changes = tMailbox.ResolveSDInternal(args->Cache(),m_stat,verbose,args->TranslationMode(),mailbox, FALSE);
         
         if ( changes )
         {
            anychange = TRUE;
            // need to write the changes
            LPSPropValue         pNewPropValues = NULL;
            LPSPropProblemArray  pProblems      = NULL;

            // update the entry
            // Allocate a buffer to set the property.
            SECURITY_DESCRIPTOR *        pMapiSD;
            SECURITY_DESCRIPTOR *        pRelSD = (SECURITY_DESCRIPTOR *)pSD->MakeRelSD();
            DWORD                        dwSDLength = GetSecurityDescriptorLength(pRelSD);
         
            if ( ! pRelSD )
            {
               goto exit_update_sd;
            }
            hr = ResultFromScode((*pMAPIAllocateBuffer)((sizeof SPropValue) * 1, (void **)&pNewPropValues));
            if (FAILED(hr)) 
            {
               err.SysMsgWrite(ErrE,hr,DCT_MSG_FAILED_TO_ALLOCATE_BUFFER_D,hr);
               goto exit_update_sd;
            }
            // Allocate a buffer for the SD
            hr = ResultFromScode((*pMAPIAllocateBuffer)(dwSDLength, (void **)&pMapiSD));
            if (FAILED(hr)) 
            {
               err.SysMsgWrite(ErrE,hr,DCT_MSG_FAILED_TO_ALLOCATE_BUFFER_D,hr);
               goto exit_update_sd;
            }

            // Copy the SD.
            memcpy(pMapiSD,pRelSD,dwSDLength );
            // Write the SD
            free(pRelSD);
            pNewPropValues[0].ulPropTag = PR_EMS_AB_NT_SECURITY_DESCRIPTOR;
            pNewPropValues[0].Value.bin.lpb = (UCHAR *)pMapiSD;
            pNewPropValues[0].Value.bin.cb = dwSDLength;
            if ( ! args->NoChange() )
            {
               hr = pUserEntry->SetProps(1, pNewPropValues, &pProblems);

               if (FAILED(hr)) 
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_RECIP_SD_WRITE_FAILED_SD,pUserProperties[0].Value.lpszW,hr);
                  pProblems = NULL; // Don't try to free this if SetProps fails.
                  goto exit_update_sd;
               }

               // Save changes.
               hr = pUserEntry->SaveChanges(KEEP_OPEN_READONLY);

               if (FAILED(hr)) 
               {  
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_RECIP_SD_SAVE_FAILED_SD,pUserProperties[0].Value.lpszW,hr);
                  goto exit_update_sd;
               }
            }
     
            exit_update_sd:
            if (pMapiSD != NULL)
               (*pMAPIFreeBuffer)(pMapiSD);

            if (pProblems != NULL)
               (*pMAPIFreeBuffer)(pProblems);

            if (pNewPropValues != NULL)
               (*pMAPIFreeBuffer)(pNewPropValues);
         }
   
      }
   }
   if ( anychange && m_stat )
   {
      m_stat->IncrementChanged(mailbox);
      if ( args->LogFileDetails() )
         err.MsgWrite(0,DCT_MSG_CHANGED_S,pUserProperties[0].Value.lpszW);
   }
   (*pMAPIFreeBuffer)(pUserProperties);
   pUserProperties = NULL;
  
   return TRUE;
}

BOOL 
   TGlobalDirectory::Scan(
      SecurityTranslatorArgs * args,       // in - translation settings
      WCHAR            const * container   // in - distinguished name or display name of container to process
   )
{
   
   LPABCONT                  pRootEntry        = NULL;  // root of AB
   ULONG                     ulObjectType      = 0;
   HRESULT                   hr;
//   TAccountCache           * cache = args->Cache();

   if ( args->Cache()->IsCancelled() )
   {
      err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
      return FALSE;
   }
   if ( ! m_pAdrBook )
   {
      OpenGlobalList();
   }
   if ( ! m_pAdrBook )
   {
      return FALSE;
   }
  
/*   SizedSPropTagArray(3, rgPropTags) =
   {
      3,
      {
         PR_ENTRYID,
         PR_DISPLAY_NAME,
         PR_DEPTH,
      }
   };
*/
   // Open the root entry.
   hr = m_pAdrBook->OpenEntry(0, NULL, NULL, 0, &ulObjectType, (LPUNKNOWN*)&pRootEntry);
  
   if (FAILED(hr)) 
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_GET_AB_ROOT_FAILED_D,hr);
      return FALSE;
   }
   ScanHierarchy(pRootEntry,args,container);
   return TRUE;
}

BOOL  
   TGlobalDirectory::ScanHierarchy(
      LPABCONT                 pContainer,   // in - interface pointer to address book
      SecurityTranslatorArgs * args,         // in - translation settings
      WCHAR            const * container     // in - distinguished name or display name of container
   )
{
   HRESULT                   hr;
   LPMAPITABLE               pContainerTable = NULL;
   LPSRowSet                 pContainerRows = NULL;
   LPABCONT                  pEntry = NULL;
   ULONG                     ulObjectType = 0;
   BOOL                      foundContainer = FALSE;
   
   MCSASSERT(pContainer);
   
   if ( args->Cache()->IsCancelled() )
   {
      err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
      return FALSE;
   }
   // Get its hierarchical table.
   SizedSPropTagArray(4, rgPropTags) =
   {
      4,
      {
         PR_ENTRYID,
         PR_DISPLAY_NAME_A,    // I tried to get the display name in unicode format, but it did not work.
         PR_OBJECT_TYPE,
         PR_EMS_AB_OBJ_DIST_NAME_A
      }
   };


   hr = pContainer->GetHierarchyTable(CONVENIENT_DEPTH, &pContainerTable);

   if (FAILED(hr)) 
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_GET_HIER_TABLE_FAILED_D,hr);
      return FALSE;
   }

   // Get a list of all rows.
   hr = (*pHrQueryAllRows)(pContainerTable, (LPSPropTagArray)&rgPropTags, NULL, NULL, 0, &pContainerRows);

   if (FAILED(hr)) 
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_GET_TABLE_CONTENTS_FAILED_D,hr);
      pContainerTable->Release();
      return FALSE;
   }

   for (ULONG ulRow = (ULONG)0; ulRow < pContainerRows->cRows; ++ulRow) 
   {
      if ( args->Cache()->IsCancelled() )
      {
         err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
         return FALSE;
      }
      hr = m_pAdrBook->OpenEntry(pContainerRows->aRow[ulRow].lpProps[0].Value.bin.cb,
                              (LPENTRYID)pContainerRows->aRow[ulRow].lpProps[0].Value.bin.lpb,
                              NULL,
                              MAPI_MODIFY,      // or 0 if nochange mode
                              &ulObjectType,
                              (LPUNKNOWN *)&pEntry);

      if (!SUCCEEDED(hr)) 
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_OPEN_CONTAINER_FAILED_SD,pContainerRows->aRow[ulRow].lpProps[1].Value.lpszW,hr);
         return FALSE;
      }
      else
      {

//         LPMAPITABLE pContainerTable = NULL;  // container table
         UCHAR          containerA[LEN_DistName];
         safecopy(containerA,container);
         // look for the specified container
         if ( NOT_PT_ERROR(pContainerRows->aRow[ulRow].lpProps[1] ) 
            && !UStrICmp(containerA,pContainerRows->aRow[ulRow].lpProps[1].Value.lpszA) )
         {  
            foundContainer = TRUE;
            break;
         }
         if ( container && container[0]== '/' )
         {
            // Check the distinguished name 
            LPSPropValue            props;
            ULONG                   ulCount;
            HRESULT                 hr2;

            hr2 = pEntry->GetProps((LPSPropTagArray)&rgPropTags,0,&ulCount,&props);
            if ( SUCCEEDED(hr) )
            {
               if ( ulCount >= 4 && NOT_PT_ERROR(props[3]) )               
               {
                  if ( !UStrICmp(props[3].Value.lpszA,containerA) )
                  {
                     foundContainer = TRUE;
                  }
               }
               (*pMAPIFreeBuffer)(props);
               props = NULL;
            }
            else
            {
               err.SysMsgWrite(ErrE,hr2,DCT_MSG_GET_CONTAINER_INFO_FAILED_D,hr2);
            }
            if ( foundContainer ) 
               break;
         }
         
      }
   }
   // if we found the container, process it's contents
   if ( foundContainer )
   {

      if ( args->LogFileDetails() )
         err.MsgWrite(0,DCT_MSG_EXAMINING_CONTENTS_S,pContainerRows->aRow[ulRow].lpProps[1].Value.lpszW);
      // Get its contents table.                 
      hr = pEntry->GetContentsTable(0, &pContainerTable);

      if (FAILED(hr)) 
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_GET_CONTAINER_INFO_FAILED_D,hr);
         pEntry->Release();
         pEntry = NULL;
         return FALSE;
      }
      // need to scan contents and hierarchy for this item
      m_pContainer = pEntry;
      m_name = pContainerRows->aRow[ulRow].lpProps[1].Value.lpszW;
      ScanContents(pContainerTable,args);
 
   }
   else
   {
      err.MsgWrite(ErrW,DCT_MSG_CONTAINER_NOT_FOUND_S,container);
   }

   (*pFreeProws)(pContainerRows);
   pContainerRows = NULL;
   pContainerTable->Release();
   return TRUE;
}
///////////////////////////////////////////////////////////////////////////////
// Scan the contents of the Container for sids that need to be converted.
BOOL  
   TGlobalDirectory::ScanContents( 
      LPMAPITABLE              pContainerTable, // in - contents table for container
      SecurityTranslatorArgs * args             // in - translation settings
  )
{
   ULONG                     ulDLEntries;
//   WCHAR                     em[500] = L"";

   MCSASSERT  (pContainerTable);
   
   if ( args->Cache()->IsCancelled() )
   {
      err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
      return FALSE;
   }
   HRESULT  hr = pContainerTable->GetRowCount(0, &ulDLEntries);

   if (FAILED(hr)) 
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_COUNT_CONTAINER_FAILED_SD,m_name,hr);
      return FALSE;
   }

   // Determine which column of the table has the Entry ID.
   LPSPropTagArray   pDLPropTags = NULL;

   hr = pContainerTable->QueryColumns(0, &pDLPropTags);

   if (FAILED(hr)) 
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_CONTAINER_CORRUPTED_SD,m_name,hr);
      return FALSE;
   }

   ULONG ulEntryIdColumn;
   BOOL  bFoundEntryId = FALSE;
   for (UINT ulCol = 0; ulCol < pDLPropTags->cValues; ++ulCol) 
   {
      if (pDLPropTags->aulPropTag[ulCol] == PR_ENTRYID) 
      {
         ulEntryIdColumn = ulCol;
         bFoundEntryId = TRUE;
         break;
      }
   }
   (*pMAPIFreeBuffer)(pDLPropTags);
   pDLPropTags = NULL;
   if (!bFoundEntryId)
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_CONTAINER_CORRUPTED_SD,m_name,hr);
      return FALSE;
   }

 
   // Peruse the rows for the SIDs and names.
   LPSRowSet   pDLRows = NULL;
   LPMAPIPROP  pUserEntry      = NULL;
   for (ULONG ulRow = 0; ulRow < ulDLEntries; ++ulRow) 
   {
      if ( args->Cache()->IsCancelled() )
      {
         break;
      }
   
      hr = pContainerTable->SeekRow(BOOKMARK_BEGINNING, ulRow, NULL);

      if (FAILED(hr)) 
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_CANT_FIND_ENTRY_SD,m_name,hr);
         return FALSE;
      }

      hr = pContainerTable->QueryRows(1, TBL_NOADVANCE, &pDLRows);

      if (FAILED(hr)) 
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_CANT_LOAD_ENTRY_SD,m_name,hr);
         return FALSE;
      }

      // Get the current entry.
      ULONG ulEntryType = 0;

      if ( pDLRows  && pDLRows->cRows )
      {
         hr = m_pContainer->OpenEntry(pDLRows->aRow[0].lpProps[ulEntryIdColumn].Value.bin.cb,
                                 (ENTRYID *)pDLRows->aRow[0].lpProps[ulEntryIdColumn].Value.bin.lpb,
                                 NULL,
                                 MAPI_MODIFY,
                                 &ulEntryType,
                                 (LPUNKNOWN*)&pUserEntry);
      }
      (*pFreeProws)(pDLRows);
      pDLRows = NULL;

      if (FAILED(hr)) 
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_RECIP_LOAD_FAILED_SD,m_name,hr);
         return FALSE;
      }
      if ( pUserEntry )
      {
         UpdateEntry(pUserEntry,ulEntryType, args);
         pUserEntry->Release();
         pUserEntry = NULL;
      }
   }
   
   if ( args->Cache()->IsCancelled() )
   {
      err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
      return FALSE;
   }
   
   return TRUE;
} 

BOOL TGlobalDirectory::OpenContainerByRow(long row)
{
   HRESULT hr;
   ULONG       ulObjectType      = 0;
   MCSASSERT( m_pRootRows );
   // TODO:  check that row is in valid range.
   // Load the container that should contain the DL.
   hr = m_pAdrBook->OpenEntry(           m_pRootRows->aRow[row].lpProps[0].Value.bin.cb,
                              (LPENTRYID)m_pRootRows->aRow[row].lpProps[0].Value.bin.lpb,
                              NULL,
                              MAPI_MODIFY,      // or 0 if nochange mode
                              &ulObjectType,
                              (LPUNKNOWN *)&m_pContainer);

   (*pFreeProws)(m_pRootRows);
   m_pRootRows = NULL;

   if (FAILED(hr)) {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_OPEN_CONTAINER_FAILED_SD,L"",hr);
      return FALSE;
   }

   // Look for the DL in its container.
//   LPMAPITABLE pContainerTable = NULL;  // container table

   // Get its contents table.
   hr = m_pContainer->GetContentsTable(0, &m_pContainerTable);

   if (FAILED(hr)) {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_GET_TABLE_CONTENTS_FAILED_D,hr);
      m_pContainer->Release();
      m_pContainer = NULL;
      return FALSE;
   }
   

   return TRUE;
}

#define NDX_SID         3
#define NDX_SD          4

DWORD 
	TGlobalDirectory::GetLDAPPort(
      WCHAR				       * server
	)
{
   DWORD                     port = LDAP_PORT;
//   DWORD                     rc = 0;
   DAPI_ENTRY                attList;
   DAPI_ENTRY              * pValues;
   ATT_VALUE                 atts[3];
   WCHAR                     distName[300];
   PDAPI_EVENT               result = NULL; 
   DAPI_ENTRY              * pAttributes = NULL;

   if ( ! LoadDAPI() )
   {
      err.MsgWrite(ErrW,DCT_MSG_LDAP_PORT_DETECT_FAILED_S,server);
      return port;
   }

   if ( DAPIOpen(server) )
   {
      
      // set up the attribute list
      attList.unAttributes = 3;
      attList.ulEvalTag = VALUE_ARRAY;
      attList.rgEntryValues = atts;

      atts[0].DapiType = DAPI_UNICODE;
      atts[0].Value.pszW = ATT_OBJ_CLASS;
      atts[0].size = UStrLen(atts[0].Value.pszW);
      atts[0].pNextValue = NULL;

      atts[1].DapiType = DAPI_UNICODE;
      atts[1].Value.pszW = ATT_LDAP_PORT;
      atts[1].size = UStrLen(atts[1].Value.pszW);
      atts[1].pNextValue = NULL;

      atts[2].DapiType = DAPI_UNICODE;
      atts[2].Value.pszW = LDAP_USE_SITE_VALUES;
      atts[2].size = UStrLen(atts[2].Value.pszW);
      atts[2].pNextValue = NULL;

      // construct the DN for the attribute
      swprintf(distName,L"/cn=Configuration/cn=Servers/cn=%s%s",server,LDAP_PortNumber_DN_Part);

      result = (*pDAPIRead)(m_dSession,DAPI_RAW_MODE,distName,&attList,
                           &pValues, &pAttributes);
   
   
      if ( ! result )
      {
         if ( pValues && pValues->rgEntryValues[2].Value.iValue == 0 )
         {
            // not using site defaults - rgEntryValues[1] contains the correct value for this server
            if ( pValues && pValues->rgEntryValues[1].DapiType == DAPI_INT )
            {
               port = pValues->rgEntryValues[1].Value.iValue;
            }
         }
         else
         {
            // This server is using the default values for the site - need to look at the site level to find the correct value
            (*pDAPIFreeMemory)(pValues);
            swprintf(distName,L"/cn=Configuration%s",LDAP_PortNumber_DN_Part);
            attList.unAttributes = 2; // don't want to get 'Use-Site-Defaults' this time (we're looking at the Site)
            result = (*pDAPIRead)(m_dSession,DAPI_RAW_MODE,distName,&attList,
                           &pValues, &pAttributes);
            if ( ! result )
            {
               if ( pValues && pValues->rgEntryValues[1].DapiType == DAPI_INT )
               {
                  // Here's the default value for the site
                  port = pValues->rgEntryValues[1].Value.iValue;
               }
            }
            else
            {
               (*pDAPIFreeMemory)(result);
            }
         }
         (*pDAPIFreeMemory)(pValues);
      }
      else
      {
         (*pDAPIFreeMemory)(result);
      }
   }
   else
   {
      err.MsgWrite(ErrW,DCT_MSG_LDAP_PORT_DETECT_FAILED_S,server);
   }
   DAPIClose();

   ReleaseDAPI();
   
   return port;
}

void 
   TGlobalDirectory::GetSiteNameForServer(
      WCHAR          const * server,                  // in - name of exchange server to use
      CLdapEnum            * e,                       // in - LDAP connection to use for query
      WCHAR                * siteName                 // out- distinguished name of exchange site for server
      )
{
   WCHAR                   * atts[6] = { L"distinguishedName", L"rdn",NULL };
   WCHAR                     query[200];
   DWORD                     rc;
   WCHAR                  ** values = NULL;
   siteName[0] = 0;
   
   swprintf(query,L"(&(objectClass=computer)(rdn=%ls))",server);
   rc = e->Open(query,L"",2,100,3,atts);
   // there should be only one server with this name
   if (! rc )
      rc = e->Next(&values);
   if (! rc )
   {
      if ( !UStrICmp(values[1],server) )
      {
         WCHAR       serverPrefix[LEN_Path];
         swprintf(serverPrefix,L"cn=%ls,cn=Servers,cn=Configuration,",values[1]);
         if ( ! UStrICmp(values[0],serverPrefix,UStrLen(serverPrefix)) )
         {
            UStrCpy(siteName,values[0] + UStrLen(serverPrefix));
         }
         else
         {
            err.MsgWrite(ErrE,DCT_MSG_GENERIC_S,values[0]);
         }
      }
      else
      {
         err.MsgWrite(ErrE,DCT_MSG_LDAP_CALL_FAILED_SD,server,ERROR_NOT_FOUND);
      }
      e->FreeData(values);
   }
   else
   {
      err.SysMsgWrite(ErrE,e->m_connection.LdapMapErrorToWin32(rc),DCT_MSG_LDAP_CALL_FAILED_SD,server,rc);
   }

}


BOOL 
   TGlobalDirectory::DoLdapTranslation(
      WCHAR                  * server,
      WCHAR                  * creds,
      WCHAR                  * password,
      SecurityTranslatorArgs * args,
      WCHAR                  * basept,
      WCHAR                  * query
   )
{
   CLdapEnum                 e;
   WCHAR                   * atts[6] = { L"distinguishedName", L"rdn", L"cn", L"Assoc-NT-Account",L"NT-Security-Descriptor",NULL };
   WCHAR                  ** values = NULL;
   ULONG                     port = GetLDAPPort(server);
   ULONG                     pageSize = 100;
   WCHAR                     basepoint[LEN_Path] = L"";

   e.m_connection.SetCredentials(creds,password);

   DWORD                     rc  = e.InitConnection(server,port);
   BOOL                      anychange = FALSE;
   BOOL                      verbose = args->LogVerbose();
   BOOL						 bUseMapFile = args->UsingMapFile();


   if (! rc )
   {
      if ( ! basept )
      {
         GetSiteNameForServer(server,&e,basepoint);
      }
      else
      {
         // use the user-specified basepoint
         safecopy(basepoint,basept);
      }
      if ( query )
      {
         rc = e.Open(query,basepoint,2,pageSize,5,atts);  
      }
      else 
      {
         rc = e.Open(L"(objectClass=*)",basepoint,2,pageSize,5,atts);
      }
      if ( ! rc )
      {
         do 
         {
            rc = e.Next(&values);
            anychange = FALSE;
            if (! rc )
            {
               if ( args->Cache()->IsCancelled() )
               {
                  err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                  return FALSE;
               }
               if ( m_stat )
               {
                  m_stat->DisplayPath(values[0]);
                  m_stat->IncrementExamined(mailbox);
               }

               // update the Assoc-NT-Account, if any
               if ( values[NDX_SID] && *values[NDX_SID] )
               {
                  // convert the SID to a binary value and look it up in the cache
                  BYTE              pSid[500];

                  if ( e.m_connection.StringToBytes(values[NDX_SID],pSid) )
                  {
                     
                     // check if the sid is one we need to change            
                     //TRACE (_T("DisplayName = %s "),pUserProperties[0].Value.lpszW);
                     PSID newSid = 0;
                     TAcctNode * node;

                     if ( IsValidSid(pSid) )
                     {
				        if (!bUseMapFile)
                           node = args->Cache()->Lookup(pSid); 
				        else
                           node = args->Cache()->LookupWODomain(pSid); 
                        if ( m_stat )
                        {
                           m_stat->IncrementOwnerExamined();
                           if ( verbose )
                              err.MsgWrite(0,DCT_MSG_EXAMINED_S,values[0]);
                        }
                        if ( node == (TAcctNode*)-1  && m_stat )
                           m_stat->IncrementOwnerNoTarget();

                        if ( node && (node != (TAcctNode *)-1) && node->IsValidOnTgt() )
						{
	                       if (!bUseMapFile)
                              newSid = args->Cache()->GetTgtSid(node);
	                       else
                              newSid = args->Cache()->GetTgtSidWODomain(node);
						}
                        else
                           newSid = NULL;
                     }
                     else
                     {
                        newSid = NULL;
                     }
                     if ( newSid )
                     {
                        //TRACE (_T("needs to be translated\n"));
                        MCSASSERT ( IsValidSid(newSid) );
                        WCHAR                newSidStr[1000];

                        if ( e.m_connection.BytesToString((BYTE*)newSid,newSidStr,GetLengthSid(newSid)) )
                        {
                           if ( m_stat )
                           {
                              m_stat->IncrementOwnerChange(node,mailbox,NULL);
                           }
                           anychange = TRUE;
                           if ( ! args->NoChange() )
                           {
                              rc = e.m_connection.UpdateSimpleStringValue(values[0],atts[NDX_SID],newSidStr);

                              if ( rc ) 
                              {
                                 err.SysMsgWrite(ErrE,rc,DCT_MSG_UPDATE_ACCOUNT_FAILED_D, rc);
                              }
                           }

                        }
                     }
                  }
                  
               }
               // Update the NT-Security-Descriptor, if any
               if ( values[NDX_SD] && *values[NDX_SD] )
               {
                  // convert the SID to a binary value and look it up in the cache
                  BYTE            * pSD = new BYTE[UStrLen(values[NDX_SD])];
				  if (!pSD)
				     return FALSE;

                  if ( e.m_connection.StringToBytes(values[NDX_SD],pSD) )
                  {
                     TMapiSD   tMailbox((SECURITY_DESCRIPTOR *)pSD);
                     if ( tMailbox.HasSecurity() )
                     {
                        TSD               * pSD2 = tMailbox.GetSecurity();

                        bool  changes = tMailbox.ResolveSDInternal(args->Cache(),m_stat,verbose,args->TranslationMode(),mailbox, bUseMapFile);
         
                        if ( changes )
                        {
                           anychange = TRUE;
                           SECURITY_DESCRIPTOR * pRelSD = (SECURITY_DESCRIPTOR *)pSD2->MakeRelSD();
                           DWORD                 dwSDLength = GetSecurityDescriptorLength(pRelSD);
                           
                           if ( ! args->NoChange() )
                           {     
                              WCHAR * pSDString = new WCHAR[1 + dwSDLength * 2];
							  if (!pSDString)
							  {
                                 delete [] pSD;
							     return FALSE;
							  }
                              if  ( e.m_connection.BytesToString((BYTE*)pRelSD,pSDString,dwSDLength) )
                              {
                                 rc = e.m_connection.UpdateSimpleStringValue(values[0],atts[NDX_SD],pSDString);
                                 if ( rc )
                                 {
                                    err.SysMsgWrite(ErrE,rc,DCT_MSG_RECIP_SD_WRITE_FAILED_SD,values[0],rc);
                                    if ( rc == ERROR_INVALID_PARAMETER )
                                    {
                                       // this error occurs when the security descriptor is too large
                                       // don't abort in this case
                                       rc = 0;
                                    }
                                 }
                  
                              }
                              delete [] pSDString;
                           }
                        }
                     }
                  }
                  delete [] pSD;
               }
               
               if ( anychange && m_stat )
               {
                  m_stat->IncrementChanged(mailbox);
                  if ( args->LogFileDetails() )
                     err.MsgWrite(0,DCT_MSG_CHANGED_S,values[0]);
               }
               e.FreeData(values);
            }

         } while ( ! rc );
      }
      if ( rc && (rc != LDAP_COMPARE_FALSE) && (rc != ERROR_NOT_FOUND) )
      {
         err.SysMsgWrite(ErrE,e.m_connection.LdapMapErrorToWin32(rc),DCT_MSG_LDAP_CALL_FAILED_SD,server,rc);
      }
   }
   else
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_CANNOT_CONNECT_TO_EXCHANGE_SERVER_SSD,server,creds,rc);
   }         
   
   return rc;
}
               
BOOL 
   TGlobalDirectory::DoDAPITranslation(
      WCHAR                  * serv,       // in - Exchange server
      SecurityTranslatorArgs * args        // in - translation options
   )
{
   // enumerate organizations, sites, and containers
   if ( DAPIOpen( serv ) )
   {
      HRESULT                   hr;
      LPWSTR                    pOrganizations = NULL;
      LPWSTR                     pSites = NULL;
      LPWSTR                     pContainers = NULL;
      
      WCHAR                    * server;
      WCHAR                     container[1];

      if ( args->Cache()->IsCancelled() )
      {
         err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
         return FALSE;
      }
      server = new WCHAR[wcslen(serv) + 1];
	  if (!server)
	     return FALSE;
      UStrCpy(server,serv);
      container[0] = 0;
      // enumerate organizations
      m_stat->DisplayPath(GET_STRING(IDS_ScanningExchangeDirectory));
      hr = HrEnumOrganizations(container,server,&pOrganizations);
      if ( SUCCEEDED(hr) )
      {
         for ( ; pOrganizations && *pOrganizations ; pOrganizations+=UStrLen(pOrganizations) + 1 )
         {
            if ( args->Cache()->IsCancelled() )
            {
               err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
               break;
            }
            WCHAR          wOrganizations[300];
            safecopy(wOrganizations,pOrganizations);
            DAPITranslate(wOrganizations,args);
            //enumerate sites
            hr = HrEnumSites(server,pOrganizations,&pSites);
            if ( SUCCEEDED(hr) )
            {
               for ( ; pSites && *pSites ; pSites+=UStrLen(pSites) + 1 )
               {
                  if ( args->Cache()->IsCancelled() )
                  {
                     err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                     break;
                  }
                  WCHAR     wSites[300];
                  safecopy(wSites,pSites);
                  DAPITranslate(wSites,args);
                  //enumerate containers
                  hr = HrEnumContainers(server,pSites,TRUE,&pContainers);
                  if ( SUCCEEDED(hr) )
                  {
                     for ( ; pContainers && *pContainers ; pContainers+=UStrLen(pContainers) + 1 )
                     {
                        if (args->Cache()->IsCancelled() )
                        {
                           err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                           break;
                        }
                        WCHAR       wContainers[300];
                        safecopy(wContainers,pContainers);
                        DAPITranslate(wContainers,args);
                     }
                  }
                  else
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_ENUM_CONTAINERS_FAILED_SD,hr);
                  }
               }
            }
            else
            {
                err.SysMsgWrite(ErrE,hr,DCT_MSG_ENUM_SITES_FAILED_SD,hr);
            }      
         }
      }
      else
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_ENUM_ORGS_FAILED_SD,hr);
      }
      
      DAPIClose();
   }
   m_stat->DisplayPath(L"");
   return TRUE;
}

BOOL 
   TGlobalDirectory::DAPIOpen(
      WCHAR                * server        // in - name of exchange server
   )
{
   PDAPI_EVENT               result;
   BOOL                      bRc;

   WCHAR                   * serv;

   if ( ! LoadDAPI() )
   {
      return FALSE;
   }
   serv = new WCHAR [wcslen(server) + 1];
   if (!serv)
      return FALSE;
   UStrCpy(serv,&*server);
   
   // initialize parms
   m_dParms.dwDAPISignature = DAPI_SIGNATURE;
   m_dParms.dwFlags = DAPI_RAW_MODE | DAPI_EVENT_SOME;
   m_dParms.pszDSAName = serv;        // computer name of directory service agent
   m_dParms.pszBasePoint = NULL;
   m_dParms.pszContainer = NULL;
   m_dParms.pszNTDomain = NULL;
   m_dParms.pszCreateTemplate = NULL;
   m_dParms.pAttributes = NULL;

   result = (*pDAPIStart)(&m_dSession,&m_dParms);
   if ( result )
   {
      // this is an error - need to show a message or something
      LogDapiError(ErrE,L"DAPIStart: ",result);
      (*pDAPIFreeMemory)(result);
      bRc = FALSE;
   }
   else
      bRc = TRUE;
   return bRc;
}

BOOL TGlobalDirectory::DAPIClose()
{
   (*pDAPIEnd)(&m_dSession);
   return TRUE;
}

void StripQuotes(TCHAR * distName)
{
   int                       nChars = UStrLen(distName);
   int                       i,     // input index
                             o;     // output index
   BOOL                      prevQuote = FALSE;

   for ( i = 0,o = 0  ; i < nChars ; i++ )
   {
      if ( distName[i] != _T('"') || prevQuote )
      {
         prevQuote = FALSE;
         distName[o] = distName[i];
         o++;
      }
      else
      {
         // leave the output pointer where it is, so the character will be overwritten
         prevQuote = TRUE;
      }
   }
   distName[o] = 0;
}
         
BOOL TGlobalDirectory::DAPITranslate(WCHAR * dn, SecurityTranslatorArgs * args)
{
   PDAPI_EVENT    result;
   TCHAR        * distName;  // distinguished name of object to read.
   DAPI_ENTRY   * pValues = NULL;
   DAPI_ENTRY   * pAttributes = NULL;
   ATT_VALUE      attributes[8];             // DapiType, Value, size, pNextValue
   WCHAR        * att_names[8];
   bool           verbose = false;

   if ( args->Cache()->IsCancelled() )
   {
      err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
      return FALSE;
   }
   att_names[0] = L"Obj-Class";
   att_names[1] = L"DSA-Signature";
   att_names[2] = L"Directory Name";
   att_names[3] = L"Obj-View-Containers";
   att_names[4] = L"Obj-Dist-Name";
   int sdIndex = 5;
   att_names[sdIndex] = L"NT-Security-Descriptor";
   att_names[6] = L"Organizational-Unit-Name";
   att_names[7] = L"Organization-Name";
   DAPI_ENTRY     attr;

   attr.unAttributes = 8;
   attr.ulEvalTag = VALUE_ARRAY;
   attr.rgEntryValues = attributes;
   for ( int i = 0 ; i < 8 ; i++ )
   {
      attributes[i].DapiType = DAPI_UNICODE;
      attributes[i].Value.pszW = att_names[i];
      attributes[i].size = UStrLen(att_names[i]);
      attributes[i].pNextValue = NULL;
   }
            // we may need DAPI_RESTRICT_ACCESS and/or DAPI_MODIFY_REPLACE_PROPERTIES

   distName = new TCHAR[wcslen(dn) + 1];
   if (!distName)
      return FALSE;
   UStrCpy(distName,(LPCTSTR)dn);
   StripQuotes(distName);
   result = (*pDAPIRead)(m_dSession,DAPI_RAW_MODE,distName,&attr,
                           &pValues, &pAttributes);
   if ( m_stat )
   {
      WCHAR    wpath[MAX_PATH+1];
      safecopy(wpath,&*distName);
      m_stat->DisplayPath(wpath);
      
      m_stat->IncrementExamined(container);
      
      if ( verbose ) 
         err.MsgWrite(0,DCT_MSG_EXAMINED_S,&*dn);
   }
   if ( result )
   {
      // this is an error - need to show a message or something
      LogDapiError(ErrE,L"DAPIRead: ",result);
      (*pDAPIFreeMemory)(result);
   }
   if ( pValues && pValues->rgEntryValues[sdIndex].DapiType == DAPI_BINARY )
   {
      SECURITY_DESCRIPTOR  * pSD = (SECURITY_DESCRIPTOR *)pValues->rgEntryValues[sdIndex].Value.lpBinary;
      TMapiSD                exContainer(pSD); 

      if ( exContainer.HasSecurity() )
      {
         exContainer.SetName(distName);

         bool                changes = exContainer.ResolveSDInternal(args->Cache(),m_stat,false,args->TranslationMode(),container, FALSE);
//         ULONG               usn = 0; 

         if ( changes )
         {
            if  (m_stat)
            {
               m_stat->IncrementChanged(container);
               if ( args->LogFileDetails() )
                  err.MsgWrite(0,DCT_MSG_CHANGED_S,&*dn);
            }

            // record the changes      
            if ( ! args->NoChange() )
            {
               TSD         * tSD = exContainer.GetSecurity();

               pSD = (SECURITY_DESCRIPTOR *)tSD->MakeRelSD();
               pValues->rgEntryValues[sdIndex].Value.lpBinary = (UCHAR *)pSD;
               // make sure the size is still correct.  For NT 3.51 and 4 it
               // should always be, since all the SIDs are the same length, but 
               // we don't want this to break if it gets a different-length SID
               pValues->rgEntryValues[sdIndex].size = GetSecurityDescriptorLength(pSD); 
               
               // Change the directory name to match the distinguished name, otherwise you get
               // object not found error.
               pValues->rgEntryValues[2].Value.pszW = pValues->rgEntryValues[4].Value.pszW;
               // Same problem for the OU-Name for Sites
               if ( pValues->rgEntryValues[6].DapiType != DAPI_NO_VALUE )
               {
                  pValues->rgEntryValues[6].Value.pszW = pValues->rgEntryValues[4].Value.pszW;
               }
               // Same problem for the O-name for organizations
               if ( pValues->rgEntryValues[7].DapiType != DAPI_NO_VALUE )
               {
                  pValues->rgEntryValues[7].Value.pszW = pValues->rgEntryValues[4].Value.pszW;
               }
               result = (*pDAPIWrite)(m_dSession,DAPI_WRITE_MODIFY,&attr,pValues,NULL,NULL,NULL);
               if ( result )
               {
                  LogDapiError(ErrE,L"DAPIWrite: ",result);
                  (*pDAPIFreeMemory)(result);
               }
               free(pSD);
            }

         }
      }
   }
   // cleanup
   if ( pValues )
      (*pDAPIFreeMemory)(pValues);
   if ( pAttributes )
      (*pDAPIFreeMemory)(pAttributes);
   delete [] distName;
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\edk2.cpp ===
/*
===============================================================================
Module      -  edk.cpp
System      -  EnterpriseAdministrator
Creator     -  Steven Bailey
Created     -  2 Apr 97
Description -  Exchange MAPI helper routines.
Updates     -  Christy Boles - added more MAPI helper functions, and some DAPI 
               helper functions.
===============================================================================
*/
#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <mapiguid.h>

#include "edk2.hpp"

#include <edkcode.h>
#include <objbase.h>
#include <mapiutil.h>
#include <emsabtag.h>
#include <_ENTRYID.H>


extern LPMAPIALLOCATEBUFFER         pMAPIAllocateBuffer;
extern LPMAPIFREEBUFFER             pMAPIFreeBuffer;
extern LPMAPIINITIALIZE             pMAPIInitialize;
extern LPMAPIUNINITIALIZE           pMAPIUninitialize;
extern LPMAPILOGONEX                pMAPILogonEx;
extern LPMAPIADMINPROFILES          pMAPIAdminProfiles;
extern LPFREEPADRLIST               pFreePadrlist;
extern LPFREEPROWS                  pFreeProws;      
extern LPSCDUPPROPSET               pScDupPropset;
extern LPHRQUERYALLROWS             pHrQueryAllRows;
extern LPULRELEASE                  pUlRelease;

#define CHAR WCHAR
#define HR_LOG(x) x

// definition of the Exchange address type.
// from edk.h
#define EXCHANGE_ADDRTYPE	L"EX"

#define CbNewFlagList(_cflag) \
	(offsetof(FlagList,ulFlag) + (_cflag)*sizeof(ULONG))

//$--cbStrLen@------------------------------------------------
//  Returns total number of bytes (including NULL) used by 
//  a string.  Useful for string allocations...
// -----------------------------------------------------------
#define cbStrLenA(sz)   ((lstrlenA((sz)) + 1) * sizeof(CHAR))

#if defined(_M_IX86)
#define cbStrLenW(sz)   ((lstrlenW((sz)) + 1) * sizeof(WCHAR))
#else
// lstrlenW can return 0 for UNALIGNED UNICODE strings on non-IX86 platforms
__inline static size_t cbStrLenW(
    IN UNALIGNED const WCHAR *wsz)
{
    size_t cbWsz = 0;

    for(; *wsz; wsz++)
        cbWsz += sizeof( WCHAR);

    return( cbWsz + sizeof( WCHAR));
}
#endif

#ifdef UNICODE
#define cbStrLen    cbStrLenW
#else 
#define cbStrLen    cbStrLenA
#endif


#define ULRELEASE(x) \
{                    \
	(*pUlRelease)((x));  \
	(x) = NULL;      \
}

#define MAPIFREEBUFFER(x) \
{                         \
    (*pMAPIFreeBuffer)((x));  \
	(x) = NULL;           \
}


#define FREEPADRLIST(x) \
{                       \
    (*pFreePadrlist)((x));  \
	(x) = NULL;         \
}

#define FREEPROWS(x)    \
{                       \
    (*pFreeProws)((x));     \
	(x) = NULL;         \
}

// Definitions from ExchInst.c
#define MAX_CSV_LINE_SIZ                2048
#define MAX_WORD                        0xFFFF
#define FILE_PREFIX                     L"EXCH"
#define NEW_LINE                        L"\r\n"

#define EXCHINST_DELIM                  L'\t'
#define EXCHINST_QUOTE                  L'"'
#define EXCHINST_MV_SEP                 L'%'

#define SZ_EXCHINST_DELIM               L"\t"
#define SZ_EXCHINST_QUOTE               L"\""
#define SZ_EXCHINST_MV_SEP              L"%"

#define BEGIN_CSV_LINE(a,b)  lstrcpy(a, b)

#define APPEND_CSV_LINE(a,b)           \
    {                                  \
	lstrcat(a, SZ_EXCHINST_DELIM); \
	lstrcat(a, b);                 \
    }

#define DELETEFILE(_file)                       \
{                                               \
    if((_file) != NULL && (_file)[0] != 0)      \
    {                                           \
	if(! DeleteFile ((_file)))              \
	{                                       \
	    HRESULT _hr = HR_LOG(E_FAIL);       \
	}                                       \
    }                                           \
    (_file)[0] = 0;                             \
}

#define CLOSEHANDLE(h)                                  \
{                                                       \
    if(((h) != NULL) && ((h) != INVALID_HANDLE_VALUE))  \
    {                                                   \
        if(CloseHandle((h)) == FALSE)                   \
        {                                               \
/*            HRESULT _hr = HR_LOG(E_FAIL);             \
*/            HR_LOG(E_FAIL);               \
        }                                               \
        (h) = NULL;                                     \
    }                                                   \
}

//
// Attribute Defines
//

#define OBJ_CLASS                       L"Obj-Class"
#define MODE                            L"Mode"
#define ADDR_SYNTAX                     L"Address-Syntax"
#define ADDR_ENTRY_DT                   L"Address-Entry-Display-Table"
#define ADDR_TYPE                       L"Address-Type"
#define ADMIN_DISPLAY_NAME              L"Admin-Display-Name"
#define DISPLAY_NAME                    L"Display-Name"
#define COMMON_NAME                     L"Common-Name"
#define DELIVERY_MECHANISM              L"Delivery-Mechanism"
#define DELIV_EXT_CONT_TYPES            L"Deliv-Ext-Cont-Types"
#define EXTENSION_DATA                  L"Extension-Data"
#define EXTENSION_NAME                  L"Extension-Name"
#define HELP_FILE_NAME                  L"Help-File-Name"
#define COMPUTER_NAME                   L"Computer-Name"
#define GATEWAY_PROXY                   L"Gateway-Proxy"
#define HOME_SERVER                     L"Home-Server"
#define FILE_VERSION                    L"File-Version"
#define PER_MSG_DDT                     L"Per-Msg-Dialog-Display-Table"
#define PER_RECIP_DDT                   L"Per-Recip-Dialog-Display-Table"
#define PROXY_GENERATOR_DLL             L"Proxy-Generator-DLL"
#define ROUTING_LIST                    L"Routing-List"
#define OBJ_DIST_NAME                   L"Obj-Dist-Name"
#define ORGANIZATION                    L"Organization"
#define ORGANIZATIONAL_UNIT             L"Organizational-Unit"
#define CONTAINER                       L"Container"
#define HELP_DATA16                     L"Help-Data16"
#define HELP_DATA32                     L"Help-Data32"
#define OBJ_ADMIN                       L"Obj-Admins"
#define SITE_ADDRESSING                 L"Site-Addressing"
#define ADMIN_EXTENSION_DLL             L"Admin-Extension-Dll"
#define CAN_PRESERVE_DNS                L"Can-Preserve-DNs"
#define HEURISTICS                      L"Heuristics"
#define CONTAINER_INFO                  L"Container-Info"

//
// Attribute Value Defines
//

#define OBJ_CLASS_GW                    L"Mail-Gateway"
#define OBJ_CLASS_MB                    L"Mailbox-Agent"
#define OBJ_CLASS_SITE                  L"Site-Addressing"
#define OBJ_CLASS_ADDR_TYPE             L"Addr-Type"
#define OBJ_CLASS_ADDR_TEMPLATE         L"Address-Template"
#define OBJ_CLASS_ADMIN_EXTENSION       L"Admin-Extension"
#define OBJ_CLASS_COMPUTER              L"Computer"
#define OBJ_CLASS_CONTAINER             L"Container"

//
// Container Information Defines
//

#define ADDRESS_TEMPLATE_CONTAINER_INFO L"256"

//
// Import Mode Defines
//

#define MODE_CREATE                                             L"Create"
#define MODE_MODIFY                                             L"Modify"
#define MODE_DELETE                                             L"Delete"

#define DELIVERY_MECHANISM_GW                   L"2"
#define DELIVERY_MECHANISM_MB                   L"0"

#define CONTAINER_CONFIGURATION         L"/cn=Configuration"
#define CONTAINER_GW                    L"/cn=Configuration/cn=Connections"
#define CONTAINER_ADDR_TYPE             L"/cn=Configuration/cn=Addressing/cn=Address-Types"
#define CONTAINER_ADDR_TEMPLATE         L"/cn=Configuration/cn=Addressing/cn=Address-Templates"
#define CONTAINER_SERVERS               L"/cn=Configuration/cn=Servers"
#define CONTAINER_SITE_ADDR             L"/cn=Configuration/cn=Site-Addressing"
#define CONTAINER_ADD_INS               L"/cn=Configuration/cn=Add-Ins"

#define ACCOUNT_NAME                    L"Obj-Users"

//
//  Common macros.
//

#define CREATEKEY(hkParent, pszName, hkOut, dwDisposition) \
    RegCreateKeyEx(hkParent, pszName, 0, "", REG_OPTION_NON_VOLATILE, \
	KEY_ALL_ACCESS, NULL, &hkOut, &dwDisposition)

#define SETSZVALUE(hk, pszName, pszValue) \
    RegSetValueEx(hk, pszName, 0, REG_SZ, pszValue, lstrlen(pszValue)+1)

#define SETMULTISZVALUE(hk, pszName, pszValue) \
    RegSetValueEx(hk, pszName, 0, REG_MULTI_SZ, pszValue, \
	CbMultiSz(pszValue)+sizeof(CHAR))

#define FREEHKEY(hk) \
    if(hk != INVALID_HANDLE_VALUE) \
	RegCloseKey(hk);

static CHAR szExport[]          = L"Export";

static CHAR szNull[]            = L"(null)";

static CHAR szNullDisplayName[] = L"No Display Name!";

#define GLOBALFREE(x) { if((x) != NULL) {GlobalFree((void *)(x)); (x) = NULL;} }

//--HrMAPICreateSizedAddressList------------------------------------------------
//  Create a sized address list.
// -----------------------------------------------------------------------------
HRESULT 
   HrMAPICreateSizedAddressList(        
      ULONG                  cEntries,                // in - count of entries in address list
      LPADRLIST            * lppAdrList)              // out- pointer to address list pointer
{
    HRESULT         hr              = NOERROR;
    SCODE           sc              = 0;
    ULONG           cBytes          = 0;

    *lppAdrList = NULL;

    cBytes = CbNewADRLIST(cEntries);

    sc = (*pMAPIAllocateBuffer)(cBytes, (void **)lppAdrList);

    if(FAILED(sc))                           
    {                                                   
        hr = HR_LOG(E_OUTOFMEMORY);                                 
        goto cleanup;
    }                                                   

    // Initialize ADRLIST structure
    ZeroMemory(*lppAdrList, cBytes);

    (*lppAdrList)->cEntries = cEntries;

cleanup:

    return hr;
}

//--HrMAPISetAddressList--------------------------------------------------------
//  Set an address list.
// -----------------------------------------------------------------------------
HRESULT HrMAPISetAddressList(                
    ULONG iEntry,                        // in - index of address list entry
    ULONG cProps,                        // in - count of values in address list
                                         //      entry
    LPSPropValue lpPropValues,           // in - pointer to address list entry
    LPADRLIST lpAdrList)                 // i/o - pointer to address list pointer
{
    HRESULT         hr              = NOERROR;
    SCODE           sc              = 0;
    LPSPropValue    lpNewPropValues = NULL;
//    ULONG           cBytes          = 0;

    if(iEntry >= lpAdrList->cEntries)
    {
        hr = HR_LOG(E_FAIL);
        goto cleanup;
    }

    sc = (*pScDupPropset)(
        cProps,
        lpPropValues,
		(*pMAPIAllocateBuffer),
		&lpNewPropValues);

    if(FAILED(sc))
    {
        hr = HR_LOG(E_FAIL);
        goto cleanup;
    }

    if(lpAdrList->aEntries[iEntry].rgPropVals != NULL)
    {
        MAPIFREEBUFFER(lpAdrList->aEntries[iEntry].rgPropVals);
    }

    lpAdrList->aEntries[iEntry].cValues = cProps;
    lpAdrList->aEntries[iEntry].rgPropVals = lpNewPropValues;

cleanup:

    return hr;
}

HRESULT HrGWResolveAddressW(
    LPABCONT                 lpGalABCont,        // in - pointer to GAL container
    LPCWSTR                  lpszAddress,        // in - pointer to proxy address
    BOOL                   * lpfMapiRecip,       // out- MAPI recipient
    ULONG                  * lpcbEntryID,        // out- count of bytes in entry ID
    LPENTRYID              * lppEntryID)        // out- pointer to entry ID
{
    HRESULT     hr          = NOERROR;
    HRESULT     hrT         = 0;
    SCODE       sc          = 0;
    LPADRLIST   lpAdrList   = NULL;
    LPFlagList  lpFlagList  = NULL;
    SPropValue  prop[2]     = {0};
    ULONG       cbEntryID   = 0;
    LPENTRYID   lpEntryID   = NULL;

    static const SizedSPropTagArray(2, rgPropTags) =
    { 2, 
        {
            PR_ENTRYID,
            PR_SEND_RICH_INFO
        }
    };

    *lpfMapiRecip = FALSE;
    *lpcbEntryID  = 0;
    *lppEntryID   = NULL;

    sc = (*pMAPIAllocateBuffer)( CbNewFlagList(1), (LPVOID*)&lpFlagList);

    if(FAILED(sc))
    {
        hr = HR_LOG(E_OUTOFMEMORY);
        goto cleanup;
    }

    lpFlagList->cFlags    = 1;
    lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

    hr = HrMAPICreateSizedAddressList(1, &lpAdrList);

    if(FAILED(hr))
    {
        hr = HR_LOG(E_FAIL);
        goto cleanup;
    }

    prop[0].ulPropTag = PR_DISPLAY_NAME_W;
    prop[0].Value.lpszW = (LPWSTR)lpszAddress;
    prop[1].ulPropTag = PR_RECIPIENT_TYPE;
    prop[1].Value.ul = MAPI_TO;

    hr = HrMAPISetAddressList(
        0,
        2,
        prop,
        lpAdrList);

    if(FAILED(hr))
    {
        hr = HR_LOG(E_FAIL);
        goto cleanup;
    }

    hrT = lpGalABCont->ResolveNames(
        (LPSPropTagArray)&rgPropTags,
        EMS_AB_ADDRESS_LOOKUP,
        lpAdrList,
        lpFlagList);

    if(lpFlagList->ulFlag[0] != MAPI_RESOLVED)
    {
        if(lpFlagList->ulFlag[0] == MAPI_AMBIGUOUS)
        {
            hrT = MAPI_E_AMBIGUOUS_RECIP;
        }
        else
        {
            hrT = MAPI_E_NOT_FOUND;
        }
    }

    if(FAILED(hrT))
    {
        if(hrT == MAPI_E_NOT_FOUND)
        {
            hr = HR_LOG(EDK_E_NOT_FOUND);
        }
        else
        {
            hr = HR_LOG(E_FAIL);
        };

        goto cleanup;
    }

    cbEntryID = lpAdrList->aEntries[0].rgPropVals[0].Value.bin.cb;
    lpEntryID = (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[0].Value.bin.lpb;

    sc = (*pMAPIAllocateBuffer)( cbEntryID, (LPVOID*)lppEntryID);

    if(FAILED(sc))
    {
        hr = HR_LOG(E_OUTOFMEMORY);
        goto cleanup;
    }

    CopyMemory(*lppEntryID, lpEntryID, cbEntryID);
    *lpcbEntryID  = cbEntryID;
    *lpfMapiRecip = lpAdrList->aEntries[0].rgPropVals[1].Value.b;

cleanup:

    MAPIFREEBUFFER(lpFlagList);

    FREEPADRLIST(lpAdrList);

   return hr;
}


//--HrFindExchangeGlobalAddressList-------------------------------------------------
// Returns the entry ID of the global address list container in the address
// book.
// -----------------------------------------------------------------------------
// CAVEAT: If this function is successful, you must free the buffer returned in lppeid.

HRESULT 
   HrFindExchangeGlobalAddressList( 
    LPADRBOOK                lpAdrBook,        // in - address book pointer
    ULONG                  * lpcbeid,          // out- pointer to count of bytes in entry ID
    LPENTRYID              * lppeid)           // out- pointer to entry ID pointer
{
    HRESULT         hr                  = NOERROR;
    ULONG           ulObjType           = 0;
//    ULONG           i                   = 0;
    LPMAPIPROP      lpRootContainer     = NULL;
    LPMAPIPROP      lpContainer         = NULL;
    LPMAPITABLE     lpContainerTable    = NULL;
    LPSRowSet       lpRows              = NULL;
    ULONG           cbContainerEntryId  = 0;
    LPENTRYID       lpContainerEntryId  = NULL;
    LPSPropValue    lpCurrProp          = NULL;
    SRestriction    SRestrictAnd[2]     = {0};
    SRestriction    SRestrictGAL        = {0};
    SPropValue      SPropID             = {0};
    SPropValue      SPropProvider       = {0};
    BYTE            muid[]              = MUIDEMSAB;

    SizedSPropTagArray(1, rgPropTags) =
    {
        1, 
        {
            PR_ENTRYID,
        }
    };

    *lpcbeid = 0;
    *lppeid  = NULL;

    // Open the root container of the address book
    hr = lpAdrBook->OpenEntry(
        0,
        NULL,
        NULL,
        MAPI_DEFERRED_ERRORS, 
        &ulObjType,
        (LPUNKNOWN FAR *)&lpRootContainer);

    if(FAILED(hr))
    {
        goto cleanup;
    }

    if(ulObjType != MAPI_ABCONT)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the hierarchy table of the root container
    hr = ((LPABCONT)lpRootContainer)->GetHierarchyTable(
        MAPI_DEFERRED_ERRORS|CONVENIENT_DEPTH,
        &lpContainerTable);

    if(FAILED(hr))
    {
        goto cleanup;
    }

    // Restrict the table to the global address list (GAL)
    // ---------------------------------------------------

    // Initialize provider restriction to only Exchange providers

    SRestrictAnd[0].rt                          = RES_PROPERTY;
    SRestrictAnd[0].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[0].res.resProperty.ulPropTag   = PR_AB_PROVIDER_ID;
    SPropProvider.ulPropTag                     = PR_AB_PROVIDER_ID;

    SPropProvider.Value.bin.cb                  = 16;
    SPropProvider.Value.bin.lpb                 = (LPBYTE)muid;
    SRestrictAnd[0].res.resProperty.lpProp      = &SPropProvider;

    // Initialize container ID restriction to only GAL container

    SRestrictAnd[1].rt                          = RES_PROPERTY;
    SRestrictAnd[1].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[1].res.resProperty.ulPropTag   = PR_EMS_AB_CONTAINERID;
    SPropID.ulPropTag                           = PR_EMS_AB_CONTAINERID;
    SPropID.Value.l                             = 0;
    SRestrictAnd[1].res.resProperty.lpProp      = &SPropID;

    // Initialize AND restriction 
    
    SRestrictGAL.rt                             = RES_AND;
    SRestrictGAL.res.resAnd.cRes                = 2;
    SRestrictGAL.res.resAnd.lpRes               = &SRestrictAnd[0];

    // Restrict the table to the GAL - only a single row should remain

    // Get the row corresponding to the GAL

	//
	//  Query all the rows
	//

	hr = (*pHrQueryAllRows)(
	    lpContainerTable,
		(LPSPropTagArray)&rgPropTags,
		&SRestrictGAL,
		NULL,
		0,
		&lpRows);

    if(FAILED(hr) || (lpRows == NULL) || (lpRows->cRows != 1))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the entry ID for the GAL

    lpCurrProp = &(lpRows->aRow[0].lpProps[0]);

    if(lpCurrProp->ulPropTag == PR_ENTRYID)
    {
        cbContainerEntryId = lpCurrProp->Value.bin.cb;
        lpContainerEntryId = (LPENTRYID)lpCurrProp->Value.bin.lpb;
    }
    else
    {
        hr = EDK_E_NOT_FOUND;
        goto cleanup;
    }

    hr = (*pMAPIAllocateBuffer)(cbContainerEntryId, (LPVOID *)lppeid);

    if(FAILED(hr))
    {
        *lpcbeid = 0;
        *lppeid = NULL;
    }
    else
    {
        CopyMemory(
            *lppeid,
            lpContainerEntryId,
            cbContainerEntryId);

        *lpcbeid = cbContainerEntryId;
    }

cleanup:

    if (lpRootContainer)
       lpRootContainer->Release();
    if (lpContainerTable)
       lpContainerTable->Release();
    if (lpContainer)
       lpContainer->Release();

    (*pFreeProws)(lpRows);
    
    if(FAILED(hr))
    {
        (*pMAPIFreeBuffer)(*lppeid);

        *lpcbeid = 0;
        *lppeid = NULL;
    }
    
    return hr;
}


//--HrSearchGAL----------------------------------------------------------------
//  Look for the entry ID by searching for the DN in the global address list.
//
//  RETURNS:	hr == NOERROR           Found
//				hr == EDK_E_NOT_FOUND   DN Not Found
//				hr == (anything else)   Other Error
// -----------------------------------------------------------------------------
static HRESULT HrSearchGAL(				
	LPADRBOOK	             lpAdrBook,			   // in - address book (directory) to look in
	LPWSTR		             lpszDN,	            // in - object distinguished name
	ULONG                  * lpcbEntryID,		   // out- count of bytes in entry ID
	LPENTRYID              * lppEntryID)		   // out- pointer to entry ID
{
    HRESULT         hr                  = NOERROR;
    LPWSTR           lpszAddress         = NULL;
    ULONG           cbGALEntryID        = 0;
    LPENTRYID       lpGALEntryID        = NULL;
    ULONG           ulGALObjectType     = 0;
    LPABCONT        lpGAL               = NULL;
    BOOL            fMapiRecip          = FALSE;


    // Initially zero out the return variables.

    *lpcbEntryID = 0;
    *lppEntryID = NULL;

    // Create an address string consisting of "EX:" followed by the DN.

    hr = (*pMAPIAllocateBuffer)(
        wcslen(EXCHANGE_ADDRTYPE L":") + wcslen(lpszDN) + 1, 
        (void **)&lpszAddress);
    if (FAILED(hr))
        goto cleanup;

    wcscpy(lpszAddress, EXCHANGE_ADDRTYPE L":");
    wcscat(lpszAddress, lpszDN);

    // Open the global address list.

    hr = HrFindExchangeGlobalAddressList(
        lpAdrBook, 
        &cbGALEntryID, 
        &lpGALEntryID);
    if (FAILED(hr))
        goto cleanup;
    
    hr = lpAdrBook->OpenEntry(
        cbGALEntryID, 
        lpGALEntryID, 
        NULL, 
        MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, 
        &ulGALObjectType, 
        (LPUNKNOWN *) &lpGAL);
    if (FAILED(hr))
        goto cleanup;

    // Make sure it's the right object type.

    if (ulGALObjectType != MAPI_ABCONT)
    {
        //hr = HR_LOG(E_FAIL);
        goto cleanup;
    }

    // Resolve the address (returns EDK_E_NOT_FOUND if not found).

    hr = HrGWResolveAddressW(
        lpGAL, 
        lpszAddress, 
        &fMapiRecip, 
        lpcbEntryID, 
        lppEntryID);
    if (FAILED(hr))
        goto cleanup;

cleanup:
    ULRELEASE(lpGAL);
    MAPIFREEBUFFER(lpGALEntryID);
    MAPIFREEBUFFER(lpszAddress);
    return hr;
}



//$--HrCreateDirEntryIdEx-------------------------------------------------------
//  Create a directory entry ID given the address of the object
//  in the directory.
// -----------------------------------------------------------------------------
HRESULT HrCreateDirEntryIdEx(			// RETURNS: HRESULT
	IN	LPADRBOOK	lpAdrBook,			// address book (directory) to look in
	IN	LPWSTR		lpszAddress,		// object distinguished name
	OUT	ULONG *		lpcbEntryID,		// count of bytes in entry ID
	OUT	LPENTRYID * lppEntryID)		    // pointer to entry ID
{
	HRESULT			hr					= NOERROR;
//    ULONG           cbHierarchyEntryID  = 0;
//    LPENTRYID       lpHierarchyEntryID  = NULL;
    ULONG           ulEntryIDType       = 0;

    // Initially zero out the return variables.

    *lpcbEntryID = 0;
    *lppEntryID = NULL;

	// Look for the DN in the global address list.

	hr = HrSearchGAL(
		lpAdrBook, 
		lpszAddress, 
        lpcbEntryID, 
        lppEntryID);
	if (FAILED(hr))
		goto cleanup;

    // If the type was DT_AGENT or DT_ORGANIZATION, then we have to 
    // do a further lookup in the hierarchy table to determine the 
    // DN's real type.

    ulEntryIDType = ((LPDIR_ENTRYID) *lppEntryID)->ulType;

   

cleanup:
   return hr;
}



//$--CbMultiSz------------------------------------------------------------------
//  Count of bytes in a REG_MULTI_SZ string (not including terminating NULL).
// -----------------------------------------------------------------------------
static DWORD CbMultiSz(                 // RETURNS: count of bytes
    IN LPWSTR lpszRegMultiSz)           // REG_MULTI_SZ string
{
//    HRESULT hr   = NOERROR;
    DWORD   cch  = 0;
    DWORD   cb   = 0;
    LPWSTR  lpsz = NULL;

    if(lpszRegMultiSz == NULL)
    {
	goto cleanup;
    }

    lpsz = lpszRegMultiSz;

    while(*lpsz)
    {
	cch = lstrlenW(lpsz);

	cch++;

	cb  += cch * sizeof(WCHAR);

	lpsz += cch;
    }

cleanup:

    return(cb);
}

//$--HrGetRegistryValue---------------------------------------------------------
//  Get a registry value - allocating memory to hold it.
// -----------------------------------------------------------------------------
static HRESULT HrGetRegistryValue(  // RETURNS: return code
    IN  HKEY hk,                    // the key.
    IN  LPWSTR lpszValue,           // value name in key.
    OUT DWORD * lpType,             // where to put type info.
    OUT DWORD * lpcb,               // where to put byte count info.
    OUT LPVOID * lppData)           // where to put the data.
{
    HRESULT hr   = E_FAIL;
    LONG    lRet = 0;

    *lppData = NULL;

    //
    //  Get its size
    //

    lRet = RegQueryValueEx(
	hk,
	lpszValue,
	NULL,
	lpType,
	NULL,
	lpcb);

    if(lRet != ERROR_SUCCESS)
    {
	hr = HR_LOG(HRESULT_FROM_WIN32(lRet));
	goto cleanup;
    }

    //
    //  Allocate memory for it
    //

    *lppData = (LPVOID)GlobalAlloc(GMEM_FIXED, *lpcb);

    if(*lppData == NULL)
    {
	hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError()));
	goto cleanup;
    }

    //
    // Get the current value
    //

    lRet = RegQueryValueEx(hk, lpszValue, NULL, lpType, (UCHAR*)*lppData, lpcb);

    if(lRet != ERROR_SUCCESS)
    {
	hr = HR_LOG(HRESULT_FROM_WIN32(lRet));
	goto cleanup;
    }

    hr = NOERROR;

cleanup:

    if(FAILED(hr))
    {
	if(lppData != NULL)
	{
	    GLOBALFREE(*lppData);
	}
    }

    return hr;
}


//--FCsvGetField---------------------------------------------------------------
// Given a record and a field separator and a field number, this routine 
// will extract the field requested.
//------------------------------------------------------------------------------
static BOOL FCsvGetField(       // RETURNS: TRUE/FALSE
    IN  WORD wLen,              // maximum length of the field to extract
    IN  WORD wFieldNum,         // field number we want from the record
    IN  CHAR cFieldSeparator,  // character to use as a field separator
    IN  CHAR *lpszRecord,      // record to extract the field from
    OUT CHAR *lpszField)       // field we have extracted
{
//    HRESULT hr              = NOERROR;
    BOOL    fRet            = FALSE;
//    CHAR   *lpszBeginField = lpszField;

    while((wFieldNum > 0) && (*lpszRecord != 0))
    {
	// If we found a field separator, increment current field
	if(*lpszRecord == cFieldSeparator)
	{
	    wFieldNum--;
	}
	// If we are at the desired field, copy the current character into it
	else if(wFieldNum == 1 && wLen > 1)
	{
	    *lpszField = *lpszRecord;
	    lpszField++;
	    wLen--;
	}

	lpszRecord++;
    }

    *lpszField = 0;

    // If the requested field # existed, return True,
    // otherwise we ran out of fields - return False

    if(wFieldNum <= 1)
    {
	fRet = TRUE;
    }
    else
    {
	fRet = FALSE;
    }

    return(fRet);
}

//$--FCsvGetRecord--------------------------------------------------------------
// Given a buffer, the buffer's length and a file handle, this
// function fills the buffer with a single line read from the file. 
// The NL & CR are NOT put into the buffer. No unprintable characters are
// placed in the buffer
// -----------------------------------------------------------------------------
BOOL FCsvGetRecord(                 // RETURNS: TRUE/FALSE
    IN  WORD wBufferLen,            // length of the record buffer
    IN  HANDLE hFile,               // file handle to read from
    OUT CHAR *lpszBuffer)          // record we have retrieved
{
//    HRESULT hr          = NOERROR;
    DWORD   dwBytesRead = 0;
    BOOL    fReadData   = FALSE;

    while((ReadFile(hFile, (LPVOID)lpszBuffer, 1, &dwBytesRead, NULL) == TRUE) &&
	  (wBufferLen > 1) && (*lpszBuffer != '\n') && (dwBytesRead > 0))
    {
	fReadData = TRUE;

	// Only store character in buffer if it is printable!

	if((isprint(*lpszBuffer)) || (*lpszBuffer == EXCHINST_DELIM))
	{
	    lpszBuffer++;
	    wBufferLen--;
	}
    }

    // If a given record is too long it is a problem!!!

    if(wBufferLen <= 0)
    {
	fReadData = FALSE;
    }

    *lpszBuffer = 0;

    return(fReadData);
}



//$--HrEDKExportObject----------------------------------------------------------
// This function will export an object from an Exchange server.
// -----------------------------------------------------------------------------
static HRESULT HrEDKExportObject(       // RETURNS: return code
    IN  LPWSTR lpszServer,              // server name
    IN  LPWSTR lpszBasePoint,           // base point
    IN  DWORD dwControlFlags,           // control flags
    IN  LPWSTR *rgpszClasses,           // classes
    IN  LPWSTR lpszObjectAttributes,    // list of attributes to export
    OUT LPWSTR lpszTempName)            // temporary file name
{
    HRESULT       hr                     = E_FAIL;
    ULONG         cErrors                = 0;
    HANDLE        hTempFile              = INVALID_HANDLE_VALUE;
    CHAR          szTempPath[MAX_PATH+1] = {0};
    DWORD         dwNumberOfBytesWritten = 0;
    BEXPORT_PARMS BExportParms           = {0};
    BOOL           fRet                   = FALSE;

    // Get temporary directory path

    if(!GetTempPath(MAX_PATH, szTempPath))
    {
	hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError()));
	goto cleanup;
    }

    // Get temporary file name

    if(!GetTempFileName(szTempPath, FILE_PREFIX, 0, lpszTempName))
    {
	hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError()));
	goto cleanup;
    }

    // Create the temporary file
    hTempFile = CreateFile(lpszTempName,
	GENERIC_WRITE,
	0,
	(LPSECURITY_ATTRIBUTES)NULL,
	CREATE_ALWAYS,
	FILE_ATTRIBUTE_NORMAL,
	(HANDLE)NULL);

    // Check to see if temporary file was created...

    if(hTempFile == INVALID_HANDLE_VALUE)
    {
	hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError()));
	goto cleanup;
    }

    // Write data to the temporary file & close it

    fRet = WriteFile(
	hTempFile,
	lpszObjectAttributes,
	lstrlen(lpszObjectAttributes)*sizeof(CHAR),
	&dwNumberOfBytesWritten,
	NULL);

    if(fRet == FALSE)
    {
	hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError()));
	goto cleanup;
    }


    fRet = WriteFile(
	hTempFile,
	NEW_LINE,
	lstrlen(NEW_LINE)*sizeof(CHAR),
	&dwNumberOfBytesWritten,
	NULL);

    if(fRet == FALSE)
    {
	hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError()));
	goto cleanup;
    }

    CLOSEHANDLE(hTempFile);

    //
    // Batch Export
    //

    BExportParms.dwDAPISignature = DAPI_SIGNATURE;
    BExportParms.dwFlags         = dwControlFlags | 
				   DAPI_MODIFY_REPLACE_PROPERTIES | 
				   DAPI_SUPPRESS_PROGRESS | 
				   DAPI_SUPPRESS_COMPLETION | 
                   DAPI_SUPPRESS_ARCHIVES | 
                   DAPI_IMPORT_NO_ERR_FILE;
    BExportParms.pszExportFile   = lpszTempName;
    BExportParms.pszBasePoint    = lpszBasePoint;
    BExportParms.pszDSAName      = lpszServer;
    BExportParms.rgpszClasses    = rgpszClasses;
    BExportParms.chColSep        = EXCHINST_DELIM;
    BExportParms.chQuote         = EXCHINST_QUOTE;
    BExportParms.chMVSep         = EXCHINST_MV_SEP;

    cErrors = (*pBatchExport)(&BExportParms);

    if(cErrors == 0)
    {
	hr = NOERROR;
    }
    else
    {
	hr = HR_LOG(E_FAIL);
    }
    
cleanup:

    CLOSEHANDLE(hTempFile);

    return hr;
}


//$--HrEDKEnumDNs---------------------------------------------------------------
//  Enumerates the distinguished name(s).
// -----------------------------------------------------------------------------
static HRESULT HrEDKEnumDNs(             // RETURNS: return code
    IN  LPWSTR lpszRootDN,               // distinguished name of DIT root
    IN  LPWSTR lpszServer,               // server name
    IN  DWORD  dwControlFlags,           // control flags
    IN  LPWSTR *rgpszClasses,            // classes
    OUT LPWSTR *lppszDNs)                // distinguished names
{
    HRESULT hr                                   = NOERROR;
    HANDLE  hTempFile                            = INVALID_HANDLE_VALUE;
    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0};
//    CHAR   szAttributeValues[MAX_CSV_LINE_SIZ]  = {0};
//    CHAR   szCurRecord[MAX_CSV_LINE_SIZ]        = {0};
    CHAR   szCurLine[MAX_CSV_LINE_SIZ]          = {0};
    CHAR   szCurField[MAX_PATH+1]               = {0};
    CHAR   szTempName[MAX_PATH+1]               = {0};
    WORD    wAttribField                         = MAX_WORD;
    WORD    wCurrField                           = 0;
    LPWSTR  lpsz                                 = NULL;
    ULONG   ulCurrOffset                         = 0;

    *lppszDNs = NULL;

    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS);
    APPEND_CSV_LINE (szObjectAttributes, OBJ_DIST_NAME);

    hr = HrEDKExportObject(
	lpszServer,
	lpszRootDN,
	dwControlFlags,
	rgpszClasses,
	szObjectAttributes,
	szTempName);

    if(SUCCEEDED(hr))
    {
	// Open the temporary file
	hTempFile = CreateFile(
	    szTempName,
	    GENERIC_READ,
	    0,
	    (LPSECURITY_ATTRIBUTES)NULL,
	    OPEN_EXISTING,
	    FILE_FLAG_DELETE_ON_CLOSE,
	    (HANDLE)NULL);

	if(hTempFile == INVALID_HANDLE_VALUE)
	{
	    hr = HR_LOG(E_FAIL);
	    goto cleanup;
	}

	//
	// The first line contains the list of fields - find which field has
	// the attribute we are looking for.
	//

	FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine);

	for(
	    wCurrField = 1;

	    FCsvGetField(
		MAX_PATH,
		wCurrField,
		EXCHINST_DELIM,
		szCurLine,
		szCurField);

	    wCurrField++)
	{
	    if(wcscmp(szCurField, OBJ_DIST_NAME) == 0) 
	    {
		wAttribField = wCurrField;
		break;
	    }
	}

	// Was the field exported & found above?

	if(wAttribField == MAX_WORD) 
	{
	    hr = HR_LOG(E_FAIL);
	    goto cleanup;
	}

	ulCurrOffset = 0;

	while(FCsvGetRecord (MAX_CSV_LINE_SIZ, hTempFile, szCurLine))
	{
	    FCsvGetField(
		MAX_PATH,
		wAttribField,
		EXCHINST_DELIM,
		szCurLine,
		szCurField);

	    if( *szCurField)
	    {
		if(lpsz == NULL)
		{
		    lpsz = (LPWSTR)GlobalAlloc(
			GMEM_FIXED,
			cbStrLen(szCurField) + sizeof(CHAR));
		}
		else
		{
		    lpsz = (LPWSTR)GlobalReAlloc(
			lpsz,
			GlobalSize(lpsz) + cbStrLen(szCurField),
			GMEM_MOVEABLE);
		}

		if(lpsz == NULL)
		{
		    hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError()));
		    goto cleanup;
		}

		lstrcpy(&lpsz[ulCurrOffset], szCurField);

		ulCurrOffset += cbStrLen(szCurField);

		lpsz[ulCurrOffset] = 0;
	    }
	}
    }
    
    *lppszDNs = lpsz;

cleanup:

    CLOSEHANDLE(hTempFile);

    if(FAILED(hr))
    {
	GLOBALFREE(*lppszDNs);
    }

   return hr;
}

//$--HrEnumOrganizations-----------------------------------------------------
//  Enumerates the organization name(s).
// -----------------------------------------------------------------------------
HRESULT HrEnumOrganizations(          // RETURNS: return code
    IN  LPWSTR lpszRootDN,               // distinguished name of DIT root
    IN  LPWSTR lpszServer,               // server name
    OUT LPWSTR *lppszOrganizations)      // organizations
{
    HRESULT hr              = NOERROR;
    LPWSTR  rgpszClasses[2] = {0};

    rgpszClasses[0] = ORGANIZATION;
    rgpszClasses[1] = NULL;

    hr = HrEDKEnumDNs(
	lpszRootDN,
	lpszServer,
	DAPI_EXPORT_SUBTREE,
	rgpszClasses,
	lppszOrganizations);

   return hr;
}

//$--HrEnumSites-------------------------------------------------------------
//  Enumerates the site name(s).
// -----------------------------------------------------------------------------
HRESULT HrEnumSites(                  // RETURNS: return code
    IN  LPWSTR lpszServer,               // server name
    IN  LPWSTR lpszOrganizationDN,       // distinguished name of organization
    OUT LPWSTR *lppszSites)              // sites
{
    HRESULT hr              = NOERROR;
    LPWSTR  rgpszClasses[2] = {0};

    rgpszClasses[0] = ORGANIZATIONAL_UNIT;
    rgpszClasses[1] = NULL;

    hr = HrEDKEnumDNs(
	lpszOrganizationDN,
	lpszServer,
	0,
	rgpszClasses,
	lppszSites);

   return hr;
}

//$--HrEnumContainers--------------------------------------------------------
//  Enumerates the container name(s).
// -----------------------------------------------------------------------------
HRESULT HrEnumContainers(             // RETURNS: return code
    IN  LPWSTR lpszServer,               // server name
    IN  LPWSTR lpszSiteDN,               // distinguished name of site
    IN  BOOL   fSubtree,                 // sub-tree?
    OUT LPWSTR *lppszContainers)         // containers
{
    HRESULT hr              = NOERROR;
    LPWSTR  rgpszClasses[2] = {0};
    DWORD   dwControlFlags  = 0;

    rgpszClasses[0] = CONTAINER;
    rgpszClasses[1] = NULL;

    if(fSubtree == TRUE)
    {
	dwControlFlags = DAPI_EXPORT_SUBTREE;
    }

    hr = HrEDKEnumDNs(
	lpszSiteDN,
	lpszServer,
	dwControlFlags,
	rgpszClasses,
	lppszContainers);

   return hr;
}

/**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\emsabtag.h ===
/*
** --emsabtag.h---------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
**  Copyright (c) Microsoft Corp. 1986-1996. All rights reserved.
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*
* Flags for ulInterfaceOptions on OpenProperty
*/
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                        4

/*
* Flags for ulFlag on ResolveNames
*/
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/*
* Constructed, but externally visible.
*/
#define PR_EMS_AB_SERVER                     PROP_TAG( PT_TSTRING, 0xFFFE)
#define PR_EMS_AB_SERVER_A                   PROP_TAG( PT_STRING8, 0xFFFE)
#define PR_EMS_AB_SERVER_W                   PROP_TAG( PT_UNICODE, 0xFFFE)
#define PR_EMS_AB_CONTAINERID                PROP_TAG( PT_LONG,    0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID             PROP_TAG( PT_BINARY,  0xFFFC)
#define PR_EMS_AB_IS_MASTER                  PROP_TAG(PT_BOOLEAN,  0xFFFB)
#define PR_EMS_AB_OBJECT_OID                 PROP_TAG(PT_BINARY,   0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH             PROP_TAG(PT_TSTRING,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A           PROP_TAG(PT_STRING8,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W           PROP_TAG(PT_UNICODE,  0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF8

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/*
 * Prop tags defined in the schema.
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY            PROP_TAG( PT_LONG,          0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE        PROP_TAG( PT_BINARY,        0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE           PROP_TAG( PT_LONG,          0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX             PROP_TAG( PT_BINARY,        0x8018)
#define PR_EMS_AB_ADDRESS_TYPE               PROP_TAG( PT_TSTRING,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A             PROP_TAG( PT_STRING8,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W             PROP_TAG( PT_UNICODE,       0x8048)
#define PR_EMS_AB_ADMD                       PROP_TAG( PT_TSTRING,       0x8049)
#define PR_EMS_AB_ADMD_A                     PROP_TAG( PT_STRING8,       0x8049)
#define PR_EMS_AB_ADMD_W                     PROP_TAG( PT_UNICODE,       0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION          PROP_TAG( PT_TSTRING,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A        PROP_TAG( PT_STRING8,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W        PROP_TAG( PT_UNICODE,       0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME         PROP_TAG( PT_TSTRING,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A       PROP_TAG( PT_STRING8,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W       PROP_TAG( PT_UNICODE,       0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL        PROP_TAG( PT_TSTRING,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A      PROP_TAG( PT_STRING8,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W      PROP_TAG( PT_UNICODE,       0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME        PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A      PROP_TAG( PT_STRING8,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W      PROP_TAG( PT_UNICODE,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O      PROP_TAG( PT_OBJECT,        0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T      PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALT_RECIPIENT              PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A            PROP_TAG( PT_STRING8,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W            PROP_TAG( PT_UNICODE,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O            PROP_TAG( PT_OBJECT,        0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T            PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL           PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A         PROP_TAG( PT_MV_STRING8,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W         PROP_TAG( PT_MV_UNICODE,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O         PROP_TAG( PT_OBJECT,        0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T         PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ANCESTOR_ID                PROP_TAG( PT_BINARY,        0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT           PROP_TAG( PT_BINARY,        0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA           PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A         PROP_TAG( PT_MV_STRING8,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W         PROP_TAG( PT_MV_UNICODE,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O         PROP_TAG( PT_OBJECT,        0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T         PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME       PROP_TAG( PT_LONG,          0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL               PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A             PROP_TAG( PT_MV_STRING8,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W             PROP_TAG( PT_MV_UNICODE,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O             PROP_TAG( PT_OBJECT,        0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T             PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST  PROP_TAG( PT_MV_BINARY,     0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN          PROP_TAG( PT_TSTRING,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A        PROP_TAG( PT_STRING8,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W        PROP_TAG( PT_UNICODE,       0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD        PROP_TAG( PT_BINARY,        0x8055)
#define PR_EMS_AB_AUTHORIZED_USER            PROP_TAG( PT_TSTRING,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A          PROP_TAG( PT_STRING8,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W          PROP_TAG( PT_UNICODE,       0x8056)
#define PR_EMS_AB_AUTOREPLY                  PROP_TAG( PT_BOOLEAN,       0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE          PROP_TAG( PT_TSTRING,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A        PROP_TAG( PT_STRING8,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W        PROP_TAG( PT_UNICODE,       0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT          PROP_TAG( PT_TSTRING,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A        PROP_TAG( PT_STRING8,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W        PROP_TAG( PT_UNICODE,       0x803E)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS         PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_A       PROP_TAG( PT_MV_STRING8,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_W       PROP_TAG( PT_MV_UNICODE,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_O       PROP_TAG( PT_OBJECT,        0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_T       PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BUSINESS_CATEGORY          PROP_TAG( PT_MV_TSTRING,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A        PROP_TAG( PT_MV_STRING8,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W        PROP_TAG( PT_MV_UNICODE,    0x8057)
#define PR_EMS_AB_BUSINESS_ROLES             PROP_TAG( PT_BINARY,        0x8023)
#define PR_EMS_AB_CA_CERTIFICATE             PROP_TAG( PT_MV_BINARY,     0x8003)
#define PR_EMS_AB_CAN_CREATE_PF              PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A            PROP_TAG( PT_MV_STRING8,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W            PROP_TAG( PT_MV_UNICODE,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O            PROP_TAG( PT_OBJECT,        0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T            PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL           PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A         PROP_TAG( PT_MV_STRING8,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W         PROP_TAG( PT_MV_UNICODE,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O         PROP_TAG( PT_OBJECT,        0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T         PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL           PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A         PROP_TAG( PT_MV_STRING8,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W         PROP_TAG( PT_MV_UNICODE,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O         PROP_TAG( PT_OBJECT,        0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T         PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL        PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A      PROP_TAG( PT_MV_STRING8,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W      PROP_TAG( PT_MV_UNICODE,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O      PROP_TAG( PT_OBJECT,        0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T      PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF          PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A        PROP_TAG( PT_MV_STRING8,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W        PROP_TAG( PT_MV_UNICODE,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O        PROP_TAG( PT_OBJECT,        0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T        PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL       PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A     PROP_TAG( PT_MV_STRING8,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W     PROP_TAG( PT_MV_UNICODE,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O     PROP_TAG( PT_OBJECT,        0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T     PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL       PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A     PROP_TAG( PT_MV_STRING8,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W     PROP_TAG( PT_MV_UNICODE,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O     PROP_TAG( PT_OBJECT,        0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T     PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL    PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A  PROP_TAG( PT_MV_STRING8,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W  PROP_TAG( PT_MV_UNICODE,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O  PROP_TAG( PT_OBJECT,        0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T  PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS           PROP_TAG( PT_BOOLEAN,       0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG( PT_BINARY,        0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET         PROP_TAG( PT_LONG,          0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR         PROP_TAG( PT_BOOLEAN,       0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET       PROP_TAG( PT_LONG,          0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR       PROP_TAG( PT_BOOLEAN,       0x8064)
#define PR_EMS_AB_COMPUTER_NAME              PROP_TAG( PT_TSTRING,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A            PROP_TAG( PT_STRING8,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W            PROP_TAG( PT_UNICODE,       0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS          PROP_TAG( PT_MV_TSTRING,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A        PROP_TAG( PT_MV_STRING8,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W        PROP_TAG( PT_MV_UNICODE,    0x8066)
#define PR_EMS_AB_CONTAINER_INFO             PROP_TAG( PT_LONG,          0x8067)
#define PR_EMS_AB_COST                       PROP_TAG( PT_LONG,          0x8068)
#define PR_EMS_AB_COUNTRY_NAME               PROP_TAG( PT_TSTRING,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A             PROP_TAG( PT_STRING8,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W             PROP_TAG( PT_UNICODE,       0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR     PROP_TAG( PT_MV_BINARY,     0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH          PROP_TAG( PT_LONG,          0x806A)
#define PR_EMS_AB_DELIV_EITS                 PROP_TAG( PT_MV_BINARY,     0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES       PROP_TAG( PT_MV_BINARY,     0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT       PROP_TAG( PT_BOOLEAN,       0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM         PROP_TAG( PT_LONG,          0x806E)
#define PR_EMS_AB_DESCRIPTION                PROP_TAG( PT_MV_TSTRING,    0x806F)
#define PR_EMS_AB_DESCRIPTION_A              PROP_TAG( PT_MV_STRING8,    0x806F)
#define PR_EMS_AB_DESCRIPTION_W              PROP_TAG( PT_MV_UNICODE,    0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR      PROP_TAG( PT_MV_TSTRING,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A    PROP_TAG( PT_MV_STRING8,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W    PROP_TAG( PT_MV_UNICODE,    0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY         PROP_TAG( PT_TSTRING,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A       PROP_TAG( PT_STRING8,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W       PROP_TAG( PT_UNICODE,       0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE      PROP_TAG( PT_BOOLEAN,       0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE             PROP_TAG( PT_MV_BINARY,     0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP       PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A     PROP_TAG( PT_STRING8,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W     PROP_TAG( PT_UNICODE,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O     PROP_TAG( PT_OBJECT,        0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T     PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_NAME                PROP_TAG( PT_TSTRING,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A              PROP_TAG( PT_STRING8,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W              PROP_TAG( PT_UNICODE,       0x8076)
#define PR_EMS_AB_DSA_SIGNATURE              PROP_TAG( PT_BINARY,        0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY             PROP_TAG( PT_BOOLEAN,       0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD          PROP_TAG( PT_BOOLEAN,       0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE           PROP_TAG( PT_LONG,          0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN           PROP_TAG( PT_BOOLEAN,       0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST    PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A  PROP_TAG( PT_MV_STRING8,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W  PROP_TAG( PT_MV_UNICODE,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O  PROP_TAG( PT_OBJECT,        0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T  PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME          PROP_TAG( PT_SYSTIME,       0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ               PROP_TAG( PT_TSTRING,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A             PROP_TAG( PT_STRING8,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W             PROP_TAG( PT_UNICODE,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN           PROP_TAG( PT_LONG,          0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS       PROP_TAG( PT_LONG,          0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8081)
#define PR_EMS_AB_DXA_FLAGS                  PROP_TAG( PT_LONG,          0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                PROP_TAG( PT_TSTRING,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A              PROP_TAG( PT_STRING8,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W              PROP_TAG( PT_UNICODE,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN            PROP_TAG( PT_LONG,          0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP        PROP_TAG( PT_MV_TSTRING,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A      PROP_TAG( PT_MV_STRING8,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W      PROP_TAG( PT_MV_UNICODE,    0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN            PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A          PROP_TAG( PT_STRING8,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W          PROP_TAG( PT_UNICODE,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O          PROP_TAG( PT_OBJECT,        0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T          PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL          PROP_TAG( PT_LONG,          0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE    PROP_TAG( PT_TSTRING,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A  PROP_TAG( PT_STRING8,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W  PROP_TAG( PT_UNICODE,       0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP       PROP_TAG( PT_MV_TSTRING,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A     PROP_TAG( PT_MV_STRING8,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W     PROP_TAG( PT_MV_UNICODE,    0x808B)
#define PR_EMS_AB_DXA_PASSWORD               PROP_TAG( PT_TSTRING,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A             PROP_TAG( PT_STRING8,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W             PROP_TAG( PT_UNICODE,       0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS  PROP_TAG( PT_LONG,          0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG( PT_BOOLEAN,       0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG( PT_LONG,          0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES    PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A  PROP_TAG( PT_STRING8,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W  PROP_TAG( PT_UNICODE,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O  PROP_TAG( PT_OBJECT,        0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T  PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG( PT_LONG,          0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS  PROP_TAG( PT_LONG,          0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES             PROP_TAG( PT_LONG,          0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP           PROP_TAG( PT_TSTRING,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A         PROP_TAG( PT_STRING8,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W         PROP_TAG( PT_UNICODE,       0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT          PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A        PROP_TAG( PT_STRING8,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W        PROP_TAG( PT_UNICODE,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O        PROP_TAG( PT_OBJECT,        0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T        PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                PROP_TAG( PT_TSTRING,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A              PROP_TAG( PT_STRING8,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W              PROP_TAG( PT_UNICODE,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN            PROP_TAG( PT_LONG,          0x8098)
#define PR_EMS_AB_DXA_REQNAME                PROP_TAG( PT_TSTRING,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_A              PROP_TAG( PT_STRING8,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_W              PROP_TAG( PT_UNICODE,       0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                PROP_TAG( PT_TSTRING,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A              PROP_TAG( PT_STRING8,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W              PROP_TAG( PT_UNICODE,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN            PROP_TAG( PT_LONG,          0x809C)
#define PR_EMS_AB_DXA_TASK                   PROP_TAG( PT_LONG,          0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS       PROP_TAG( PT_LONG,          0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP     PROP_TAG( PT_SYSTIME,       0x809F)
#define PR_EMS_AB_DXA_TYPES                  PROP_TAG( PT_LONG,          0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST  PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG( PT_MV_STRING8,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG( PT_MV_UNICODE,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG( PT_OBJECT,        0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_ENABLED_PROTOCOLS          PROP_TAG( PT_LONG,          0x817F)
#define PR_EMS_AB_ENCAPSULATION_METHOD       PROP_TAG( PT_LONG,          0x80A2)
#define PR_EMS_AB_ENCRYPT                    PROP_TAG( PT_BOOLEAN,       0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA        PROP_TAG( PT_MV_TSTRING,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A      PROP_TAG( PT_MV_STRING8,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W      PROP_TAG( PT_MV_UNICODE,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER     PROP_TAG( PT_MV_TSTRING,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A   PROP_TAG( PT_MV_STRING8,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W   PROP_TAG( PT_MV_UNICODE,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA    PROP_TAG( PT_TSTRING,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A  PROP_TAG( PT_STRING8,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W  PROP_TAG( PT_UNICODE,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER PROP_TAG( PT_TSTRING,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG( PT_STRING8,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG( PT_UNICODE,       0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY         PROP_TAG( PT_BOOLEAN,       0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME            PROP_TAG( PT_SYSTIME,       0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS          PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A        PROP_TAG( PT_MV_STRING8,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W        PROP_TAG( PT_MV_UNICODE,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O        PROP_TAG( PT_OBJECT,        0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T        PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS   PROP_TAG( PT_BOOLEAN,       0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED     PROP_TAG( PT_BOOLEAN,       0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1      PROP_TAG( PT_TSTRING,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A    PROP_TAG( PT_STRING8,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W    PROP_TAG( PT_UNICODE,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10     PROP_TAG( PT_TSTRING,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A   PROP_TAG( PT_STRING8,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W   PROP_TAG( PT_UNICODE,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2      PROP_TAG( PT_TSTRING,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A    PROP_TAG( PT_STRING8,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W    PROP_TAG( PT_UNICODE,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3      PROP_TAG( PT_TSTRING,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A    PROP_TAG( PT_STRING8,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W    PROP_TAG( PT_UNICODE,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4      PROP_TAG( PT_TSTRING,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A    PROP_TAG( PT_STRING8,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W    PROP_TAG( PT_UNICODE,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5      PROP_TAG( PT_TSTRING,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A    PROP_TAG( PT_STRING8,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W    PROP_TAG( PT_UNICODE,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6      PROP_TAG( PT_TSTRING,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A    PROP_TAG( PT_STRING8,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W    PROP_TAG( PT_UNICODE,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7      PROP_TAG( PT_TSTRING,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A    PROP_TAG( PT_STRING8,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W    PROP_TAG( PT_UNICODE,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8      PROP_TAG( PT_TSTRING,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A    PROP_TAG( PT_STRING8,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W    PROP_TAG( PT_UNICODE,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9      PROP_TAG( PT_TSTRING,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A    PROP_TAG( PT_STRING8,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W    PROP_TAG( PT_UNICODE,       0x8035)
#define PR_EMS_AB_EXTENSION_DATA             PROP_TAG( PT_MV_BINARY,     0x80A8)
#define PR_EMS_AB_EXTENSION_NAME             PROP_TAG( PT_MV_TSTRING,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A           PROP_TAG( PT_MV_STRING8,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W           PROP_TAG( PT_MV_UNICODE,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED   PROP_TAG( PT_MV_TSTRING,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A PROP_TAG( PT_MV_STRING8,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W PROP_TAG( PT_MV_UNICODE,    0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER PROP_TAG( PT_MV_BINARY,     0x80AB)
#define PR_EMS_AB_FILE_VERSION               PROP_TAG( PT_BINARY,        0x80AC)
#define PR_EMS_AB_FILTER_LOCAL_ADDRESSES     PROP_TAG( PT_BOOLEAN,       0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME            PROP_TAG( PT_TSTRING,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A          PROP_TAG( PT_STRING8,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W          PROP_TAG( PT_UNICODE,       0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER          PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A        PROP_TAG( PT_STRING8,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W        PROP_TAG( PT_UNICODE,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O        PROP_TAG( PT_OBJECT,        0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T        PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD        PROP_TAG( PT_LONG,          0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED         PROP_TAG( PT_TSTRING,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A       PROP_TAG( PT_STRING8,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W       PROP_TAG( PT_UNICODE,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG        PROP_TAG( PT_TSTRING,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A      PROP_TAG( PT_STRING8,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W      PROP_TAG( PT_UNICODE,       0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY              PROP_TAG( PT_MV_TSTRING,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A            PROP_TAG( PT_MV_STRING8,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W            PROP_TAG( PT_MV_UNICODE,    0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE       PROP_TAG( PT_BINARY,        0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED        PROP_TAG( PT_SYSTIME,       0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS       PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A     PROP_TAG( PT_MV_STRING8,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W     PROP_TAG( PT_MV_UNICODE,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O     PROP_TAG( PT_OBJECT,        0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T     PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS             PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A           PROP_TAG( PT_MV_STRING8,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W           PROP_TAG( PT_MV_UNICODE,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O           PROP_TAG( PT_OBJECT,        0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T           PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HELP_DATA16                PROP_TAG( PT_BINARY,        0x803A)
#define PR_EMS_AB_HELP_DATA32                PROP_TAG( PT_BINARY,        0x8010)
#define PR_EMS_AB_HELP_FILE_NAME             PROP_TAG( PT_TSTRING,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A           PROP_TAG( PT_STRING8,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W           PROP_TAG( PT_UNICODE,       0x803B)
#define PR_EMS_AB_HEURISTICS                 PROP_TAG( PT_LONG,          0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP         PROP_TAG( PT_BOOLEAN,       0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK     PROP_TAG( PT_BOOLEAN,       0x80B9)
#define PR_EMS_AB_HOME_MDB                   PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_A                 PROP_TAG( PT_STRING8,       0x8006)
#define PR_EMS_AB_HOME_MDB_W                 PROP_TAG( PT_UNICODE,       0x8006)
#define PR_EMS_AB_HOME_MDB_O                 PROP_TAG( PT_OBJECT,        0x8006)
#define PR_EMS_AB_HOME_MDB_T                 PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_BL                PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A              PROP_TAG( PT_MV_STRING8,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W              PROP_TAG( PT_MV_UNICODE,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O              PROP_TAG( PT_OBJECT,        0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T              PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MTA                   PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_MTA_A                 PROP_TAG( PT_STRING8,       0x8007)
#define PR_EMS_AB_HOME_MTA_W                 PROP_TAG( PT_UNICODE,       0x8007)
#define PR_EMS_AB_HOME_MTA_O                 PROP_TAG( PT_OBJECT,        0x8007)
#define PR_EMS_AB_HOME_MTA_T                 PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER         PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A       PROP_TAG( PT_STRING8,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W       PROP_TAG( PT_UNICODE,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O       PROP_TAG( PT_OBJECT,        0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T       PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER           PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A         PROP_TAG( PT_STRING8,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W         PROP_TAG( PT_UNICODE,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O         PROP_TAG( PT_OBJECT,        0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T         PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY         PROP_TAG( PT_LONG,          0x80BB)
#define PR_EMS_AB_IMPORTED_FROM              PROP_TAG( PT_TSTRING,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A            PROP_TAG( PT_STRING8,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W            PROP_TAG( PT_UNICODE,       0x8042)
#define PR_EMS_AB_INBOUND_SITES              PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A            PROP_TAG( PT_MV_STRING8,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W            PROP_TAG( PT_MV_UNICODE,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O            PROP_TAG( PT_OBJECT,        0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T            PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE              PROP_TAG( PT_LONG,          0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER  PROP_TAG( PT_MV_TSTRING,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG( PT_MV_STRING8,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG( PT_MV_UNICODE,    0x80BE)
#define PR_EMS_AB_INVOCATION_ID              PROP_TAG( PT_BINARY,        0x80BF)
#define PR_EMS_AB_IS_DELETED                 PROP_TAG( PT_BOOLEAN,       0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL            PROP_TAG( PT_OBJECT,	 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A          PROP_TAG( PT_MV_STRING8,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W          PROP_TAG( PT_MV_UNICODE,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O          PROP_TAG( PT_OBJECT,        0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T          PROP_TAG( PT_MV_TSTRING,    0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED           PROP_TAG( PT_BOOLEAN,       0x80C1)
#define PR_EMS_AB_KCC_STATUS                 PROP_TAG( PT_MV_BINARY,     0x80C2)
#define PR_EMS_AB_KM_SERVER                  PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KM_SERVER_A                PROP_TAG( PT_STRING8,       0x800D)
#define PR_EMS_AB_KM_SERVER_W                PROP_TAG( PT_UNICODE,       0x800D)
#define PR_EMS_AB_KM_SERVER_O                PROP_TAG( PT_OBJECT,        0x800D)
#define PR_EMS_AB_KM_SERVER_T                PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION      PROP_TAG( PT_MV_TSTRING,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A    PROP_TAG( PT_MV_STRING8,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W    PROP_TAG( PT_MV_UNICODE,    0x80C3)
#define PR_EMS_AB_LANGUAGE                   PROP_TAG( PT_LONG,          0x8178)
#define PR_EMS_AB_LDAP_DISPLAY_NAME          PROP_TAG( PT_MV_TSTRING,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8171)
#define PR_EMS_AB_LINE_WRAP                  PROP_TAG( PT_LONG,          0x80C4)
#define PR_EMS_AB_LINK_ID                    PROP_TAG( PT_LONG,          0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD          PROP_TAG( PT_TSTRING,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A        PROP_TAG( PT_STRING8,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W        PROP_TAG( PT_UNICODE,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS  PROP_TAG( PT_TSTRING,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN         PROP_TAG( PT_BOOLEAN,       0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A              PROP_TAG( PT_MV_STRING8,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W              PROP_TAG( PT_MV_UNICODE,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O              PROP_TAG( PT_OBJECT,        0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T              PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOG_FILENAME               PROP_TAG( PT_TSTRING,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A             PROP_TAG( PT_STRING8,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W             PROP_TAG( PT_UNICODE,       0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL      PROP_TAG( PT_LONG,          0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY PROP_TAG( PT_BOOLEAN,       0x80CC)
#define PR_EMS_AB_MANAGER                    PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_A                  PROP_TAG( PT_STRING8,       0x8005)
#define PR_EMS_AB_MANAGER_W                  PROP_TAG( PT_UNICODE,       0x8005)
#define PR_EMS_AB_MANAGER_O                  PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_T                  PROP_TAG( PT_TSTRING,       0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE          PROP_TAG( PT_LONG,          0x80CD)
#define PR_EMS_AB_MAPI_ID                    PROP_TAG( PT_LONG,          0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID          PROP_TAG( PT_BINARY,        0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL       PROP_TAG( PT_LONG,          0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD    PROP_TAG( PT_LONG,          0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT       PROP_TAG( PT_LONG,          0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA          PROP_TAG( PT_LONG,          0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT           PROP_TAG( PT_LONG,          0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS           PROP_TAG( PT_BOOLEAN,       0x80D4)
#define PR_EMS_AB_MEMBER                     PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_A                   PROP_TAG( PT_MV_STRING8,    0x8009)
#define PR_EMS_AB_MEMBER_W                   PROP_TAG( PT_MV_UNICODE,    0x8009)
#define PR_EMS_AB_MEMBER_O                   PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_T                   PROP_TAG( PT_MV_TSTRING,    0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED   PROP_TAG( PT_BOOLEAN,       0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK              PROP_TAG( PT_BOOLEAN,       0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS            PROP_TAG( PT_BOOLEAN,       0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES           PROP_TAG( PT_BOOLEAN,       0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS   PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A PROP_TAG( PT_MV_STRING8,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W PROP_TAG( PT_MV_UNICODE,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O PROP_TAG( PT_OBJECT,        0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS          PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A        PROP_TAG( PT_MV_STRING8,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W        PROP_TAG( PT_MV_UNICODE,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O        PROP_TAG( PT_OBJECT,        0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T        PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES         PROP_TAG( PT_MV_TSTRING,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A       PROP_TAG( PT_MV_STRING8,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W       PROP_TAG( PT_MV_UNICODE,    0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY     PROP_TAG( PT_LONG,          0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS     PROP_TAG( PT_LONG,          0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG( PT_LONG,          0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG( PT_BINARY,        0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG( PT_MV_STRING8,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG( PT_MV_UNICODE,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG( PT_OBJECT,        0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC  PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG( PT_MV_STRING8,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG( PT_MV_UNICODE,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG( PT_OBJECT,        0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG( PT_MV_BINARY,     0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG( PT_LONG,          0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG( PT_LONG,          0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS      PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A    PROP_TAG( PT_MV_STRING8,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W    PROP_TAG( PT_MV_UNICODE,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O    PROP_TAG( PT_OBJECT,        0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T    PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR  PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG( PT_MV_STRING8,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG( PT_MV_UNICODE,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG( PT_OBJECT,        0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY   PROP_TAG( PT_LONG,          0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS   PROP_TAG( PT_LONG,          0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED             PROP_TAG( PT_TSTRING,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A           PROP_TAG( PT_STRING8,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W           PROP_TAG( PT_UNICODE,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG            PROP_TAG( PT_TSTRING,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A          PROP_TAG( PT_STRING8,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W          PROP_TAG( PT_UNICODE,       0x80F0)
#define PR_EMS_AB_N_ADDRESS                  PROP_TAG( PT_BINARY,        0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE             PROP_TAG( PT_LONG,          0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS            PROP_TAG( PT_MV_TSTRING,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A          PROP_TAG( PT_MV_STRING8,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W          PROP_TAG( PT_MV_UNICODE,    0x8170)
#define PR_EMS_AB_NNTP_CHARACTER_SET         PROP_TAG( PT_TSTRING,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_A       PROP_TAG( PT_STRING8,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_W       PROP_TAG( PT_UNICODE,       0x817D)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT        PROP_TAG( PT_TSTRING,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_A      PROP_TAG( PT_STRING8,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_W      PROP_TAG( PT_UNICODE,       0x8176)
#define PR_EMS_AB_NT_MACHINE_NAME            PROP_TAG( PT_TSTRING,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A          PROP_TAG( PT_STRING8,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W          PROP_TAG( PT_UNICODE,       0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR     PROP_TAG( PT_BINARY,        0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES        PROP_TAG( PT_LONG,          0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES    PROP_TAG( PT_LONG,          0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME              PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A            PROP_TAG( PT_STRING8,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W            PROP_TAG( PT_UNICODE,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O            PROP_TAG( PT_OBJECT,        0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T            PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY      PROP_TAG( PT_LONG,          0x80F6)
#define PR_EMS_AB_OBJECT_VERSION             PROP_TAG( PT_LONG,          0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS     PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A   PROP_TAG( PT_MV_STRING8,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W   PROP_TAG( PT_MV_UNICODE,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O   PROP_TAG( PT_OBJECT,        0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T   PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE       PROP_TAG( PT_BINARY,        0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER         PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A       PROP_TAG( PT_STRING8,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W       PROP_TAG( PT_UNICODE,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O       PROP_TAG( PT_OBJECT,        0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T       PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE          PROP_TAG( PT_LONG,          0x80FB)
#define PR_EMS_AB_OID_TYPE                   PROP_TAG( PT_LONG,          0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS            PROP_TAG( PT_BINARY,        0x80FD)
#define PR_EMS_AB_OM_SYNTAX                  PROP_TAG( PT_LONG,          0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR    PROP_TAG( PT_BOOLEAN,       0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL        PROP_TAG( PT_LONG,          0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME          PROP_TAG( PT_MV_TSTRING,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME   PROP_TAG( PT_MV_TSTRING,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A PROP_TAG( PT_MV_STRING8,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W PROP_TAG( PT_MV_UNICODE,    0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE     PROP_TAG( PT_BINARY,        0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8104)
#define PR_EMS_AB_OUTBOUND_SITES             PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A           PROP_TAG( PT_MV_STRING8,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W           PROP_TAG( PT_MV_UNICODE,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O           PROP_TAG( PT_OBJECT,        0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T           PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OWNER                      PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_A                    PROP_TAG( PT_STRING8,       0x800C)
#define PR_EMS_AB_OWNER_W                    PROP_TAG( PT_UNICODE,       0x800C)
#define PR_EMS_AB_OWNER_O                    PROP_TAG( PT_OBJECT,        0x800C)
#define PR_EMS_AB_OWNER_T                    PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_BL                   PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_OWNER_BL_A                 PROP_TAG( PT_STRING8,       0x8024)
#define PR_EMS_AB_OWNER_BL_W                 PROP_TAG( PT_UNICODE,       0x8024)
#define PR_EMS_AB_OWNER_BL_O                 PROP_TAG( PT_OBJECT,        0x8024)
#define PR_EMS_AB_OWNER_BL_T                 PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_P_SELECTOR                 PROP_TAG( PT_BINARY,        0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8109)
#define PR_EMS_AB_PERIOD_REP_SYNC_TIMES      PROP_TAG( PT_BINARY,        0x810A)
#define PR_EMS_AB_PERIOD_REPL_STAGGER        PROP_TAG( PT_LONG,          0x810B)
#define PR_EMS_AB_PF_CONTACTS                PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_A              PROP_TAG( PT_MV_STRING8,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_W              PROP_TAG( PT_MV_UNICODE,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_O              PROP_TAG( PT_OBJECT,        0x8038)
#define PR_EMS_AB_PF_CONTACTS_T              PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_POP_CHARACTER_SET          PROP_TAG( PT_TSTRING,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_A        PROP_TAG( PT_STRING8,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_W        PROP_TAG( PT_UNICODE,       0x8179)
#define PR_EMS_AB_POP_CONTENT_FORMAT         PROP_TAG( PT_TSTRING,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_A       PROP_TAG( PT_STRING8,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_W       PROP_TAG( PT_UNICODE,       0x8177)
#define PR_EMS_AB_POSTAL_ADDRESS             PROP_TAG( PT_MV_BINARY,     0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD  PROP_TAG( PT_MV_LONG,       0x810D)
#define PR_EMS_AB_PRMD                       PROP_TAG( PT_TSTRING,       0x810E)
#define PR_EMS_AB_PRMD_A                     PROP_TAG( PT_STRING8,       0x810E)
#define PR_EMS_AB_PRMD_W                     PROP_TAG( PT_UNICODE,       0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES            PROP_TAG( PT_MV_TSTRING,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A          PROP_TAG( PT_MV_STRING8,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W          PROP_TAG( PT_MV_UNICODE,    0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL        PROP_TAG( PT_TSTRING,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A      PROP_TAG( PT_STRING8,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W      PROP_TAG( PT_UNICODE,       0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES           PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A         PROP_TAG( PT_MV_STRING8,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W         PROP_TAG( PT_MV_UNICODE,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O         PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T         PROP_TAG( PT_MV_TSTRING,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL        PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A      PROP_TAG( PT_MV_STRING8,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W      PROP_TAG( PT_MV_UNICODE,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O      PROP_TAG( PT_OBJECT,        0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T      PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG( PT_BINARY,        0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE   PROP_TAG( PT_LONG,          0x8112)
#define PR_EMS_AB_RANGE_LOWER                PROP_TAG( PT_LONG,          0x8113)
#define PR_EMS_AB_RANGE_UPPER                PROP_TAG( PT_LONG,          0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER        PROP_TAG( PT_TSTRING,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A      PROP_TAG( PT_STRING8,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W      PROP_TAG( PT_UNICODE,       0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER           PROP_TAG( PT_TSTRING,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A         PROP_TAG( PT_STRING8,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W         PROP_TAG( PT_UNICODE,       0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME   PROP_TAG( PT_TSTRING,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A PROP_TAG( PT_STRING8,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W PROP_TAG( PT_UNICODE,       0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME       PROP_TAG( PT_TSTRING,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A     PROP_TAG( PT_STRING8,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W     PROP_TAG( PT_UNICODE,       0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS         PROP_TAG( PT_MV_BINARY,     0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD         PROP_TAG( PT_TSTRING,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A       PROP_TAG( PT_STRING8,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W       PROP_TAG( PT_UNICODE,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS PROP_TAG( PT_TSTRING,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER       PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A     PROP_TAG( PT_STRING8,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W     PROP_TAG( PT_UNICODE,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O     PROP_TAG( PT_OBJECT,        0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T     PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_SITE                PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_A              PROP_TAG( PT_STRING8,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_W              PROP_TAG( PT_UNICODE,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_O              PROP_TAG( PT_OBJECT,        0x811D)
#define PR_EMS_AB_REMOTE_SITE_T              PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE  PROP_TAG( PT_LONG,          0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY    PROP_TAG( PT_LONG,          0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER        PROP_TAG( PT_LONG,          0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR       PROP_TAG( PT_BOOLEAN,       0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER            PROP_TAG( PT_BOOLEAN,       0x8121)
#define PR_EMS_AB_REPORTS                    PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_A                  PROP_TAG( PT_MV_STRING8,    0x800E)
#define PR_EMS_AB_REPORTS_W                  PROP_TAG( PT_MV_UNICODE,    0x800E)
#define PR_EMS_AB_REPORTS_O                  PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_T                  PROP_TAG( PT_MV_TSTRING,    0x800E)
#define PR_EMS_AB_REQ_SEQ                    PROP_TAG( PT_LONG,          0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA      PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A    PROP_TAG( PT_STRING8,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W    PROP_TAG( PT_UNICODE,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O    PROP_TAG( PT_OBJECT,        0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T    PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RID_SERVER                 PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_RID_SERVER_A               PROP_TAG( PT_STRING8,       0x8124)
#define PR_EMS_AB_RID_SERVER_W               PROP_TAG( PT_UNICODE,       0x8124)
#define PR_EMS_AB_RID_SERVER_O               PROP_TAG( PT_OBJECT,        0x8124)
#define PR_EMS_AB_RID_SERVER_T               PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT              PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A            PROP_TAG( PT_MV_STRING8,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W            PROP_TAG( PT_MV_UNICODE,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O            PROP_TAG( PT_OBJECT,        0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T            PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROUTING_LIST               PROP_TAG( PT_MV_TSTRING,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_A             PROP_TAG( PT_MV_STRING8,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_W             PROP_TAG( PT_MV_UNICODE,    0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE        PROP_TAG( PT_LONG,          0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT       PROP_TAG( PT_LONG,          0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE            PROP_TAG( PT_LONG,          0x8129)
#define PR_EMS_AB_RUNS_ON                    PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_RUNS_ON_A                  PROP_TAG( PT_MV_STRING8,    0x812A)
#define PR_EMS_AB_RUNS_ON_W                  PROP_TAG( PT_MV_UNICODE,    0x812A)
#define PR_EMS_AB_RUNS_ON_O                  PROP_TAG( PT_OBJECT,        0x812A)
#define PR_EMS_AB_RUNS_ON_T                  PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_S_SELECTOR                 PROP_TAG( PT_BINARY,        0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x812C)
#define PR_EMS_AB_SCHEMA_FLAGS               PROP_TAG( PT_LONG,          0x8173)
#define PR_EMS_AB_SCHEMA_VERSION             PROP_TAG( PT_MV_LONG,       0x817C)
#define PR_EMS_AB_SEARCH_FLAGS               PROP_TAG( PT_LONG,          0x812D)
#define PR_EMS_AB_SEARCH_GUIDE               PROP_TAG( PT_MV_BINARY,     0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL          PROP_TAG( PT_MV_BINARY,     0x8037)
#define PR_EMS_AB_SEE_ALSO                   PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SEE_ALSO_A                 PROP_TAG( PT_MV_STRING8,    0x812F)
#define PR_EMS_AB_SEE_ALSO_W                 PROP_TAG( PT_MV_UNICODE,    0x812F)
#define PR_EMS_AB_SEE_ALSO_O                 PROP_TAG( PT_OBJECT,        0x812F)
#define PR_EMS_AB_SEE_ALSO_T                 PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SERIAL_NUMBER              PROP_TAG( PT_MV_TSTRING,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A            PROP_TAG( PT_MV_STRING8,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W            PROP_TAG( PT_MV_UNICODE,    0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST       PROP_TAG( PT_LONG,          0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER       PROP_TAG( PT_LONG,          0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND      PROP_TAG( PT_LONG,          0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY      PROP_TAG( PT_LONG,          0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE    PROP_TAG( PT_TSTRING,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A  PROP_TAG( PT_STRING8,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W  PROP_TAG( PT_UNICODE,       0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER   PROP_TAG( PT_LONG,          0x8136)
#define PR_EMS_AB_SITE_AFFINITY              PROP_TAG( PT_MV_TSTRING,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A            PROP_TAG( PT_MV_STRING8,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W            PROP_TAG( PT_MV_UNICODE,    0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID           PROP_TAG( PT_BINARY,        0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER         PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A       PROP_TAG( PT_STRING8,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W       PROP_TAG( PT_UNICODE,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O       PROP_TAG( PT_OBJECT,        0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T       PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE           PROP_TAG( PT_MV_TSTRING,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A         PROP_TAG( PT_MV_STRING8,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W         PROP_TAG( PT_MV_UNICODE,    0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED        PROP_TAG( PT_SYSTIME,       0x8139)
#define PR_EMS_AB_STREET_ADDRESS             PROP_TAG( PT_TSTRING,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x813A)
#define PR_EMS_AB_SUB_REFS                   PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_REFS_A                 PROP_TAG( PT_MV_STRING8,    0x813B)
#define PR_EMS_AB_SUB_REFS_W                 PROP_TAG( PT_MV_UNICODE,    0x813B)
#define PR_EMS_AB_SUB_REFS_O                 PROP_TAG( PT_OBJECT,        0x813B)
#define PR_EMS_AB_SUB_REFS_T                 PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_SITE                   PROP_TAG( PT_TSTRING,       0x817B)
#define PR_EMS_AB_SUB_SITE_A                 PROP_TAG( PT_STRING8,       0x817B)
#define PR_EMS_AB_SUB_SITE_W                 PROP_TAG( PT_UNICODE,       0x817B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH     PROP_TAG( PT_LONG,          0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG( PT_MV_BINARY,     0x813D)
#define PR_EMS_AB_SUPPORTING_STACK           PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A         PROP_TAG( PT_MV_STRING8,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W         PROP_TAG( PT_MV_UNICODE,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O         PROP_TAG( PT_OBJECT,        0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T         PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL        PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A      PROP_TAG( PT_MV_STRING8,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W      PROP_TAG( PT_MV_UNICODE,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O      PROP_TAG( PT_OBJECT,        0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T      PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_T_SELECTOR                 PROP_TAG( PT_BINARY,        0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8141)
#define PR_EMS_AB_TARGET_ADDRESS             PROP_TAG( PT_TSTRING,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x8011)
#define PR_EMS_AB_TARGET_MTAS                PROP_TAG( PT_MV_TSTRING,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_A              PROP_TAG( PT_MV_STRING8,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_W              PROP_TAG( PT_MV_UNICODE,    0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER           PROP_TAG( PT_MV_TSTRING,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A         PROP_TAG( PT_MV_STRING8,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W         PROP_TAG( PT_MV_UNICODE,    0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG( PT_MV_BINARY,     0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD       PROP_TAG( PT_LONG,          0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME         PROP_TAG( PT_LONG,          0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME     PROP_TAG( PT_TSTRING,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A   PROP_TAG( PT_STRING8,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W   PROP_TAG( PT_UNICODE,       0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS           PROP_TAG( PT_LONG,          0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS         PROP_TAG( PT_LONG,          0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL    PROP_TAG( PT_LONG,          0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG( PT_LONG,          0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL    PROP_TAG( PT_LONG,          0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT    PROP_TAG( PT_LONG,          0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED     PROP_TAG( PT_LONG,          0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA   PROP_TAG( PT_BOOLEAN,       0x814E)
#define PR_EMS_AB_TRUST_LEVEL                PROP_TAG( PT_LONG,          0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD     PROP_TAG( PT_LONG,          0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY PROP_TAG( PT_BOOLEAN,       0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL             PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A           PROP_TAG( PT_MV_STRING8,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W           PROP_TAG( PT_MV_UNICODE,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O           PROP_TAG( PT_OBJECT,        0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T           PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_USE_SERVER_VALUES          PROP_TAG( PT_BOOLEAN,       0x817E)
#define PR_EMS_AB_USER_PASSWORD              PROP_TAG( PT_MV_BINARY,     0x8153)
#define PR_EMS_AB_USN_CHANGED                PROP_TAG( PT_LONG,          0x8029)
#define PR_EMS_AB_USN_CREATED                PROP_TAG( PT_LONG,          0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED   PROP_TAG( PT_LONG,          0x8155)
#define PR_EMS_AB_USN_INTERSITE              PROP_TAG( PT_LONG,          0x817A)
#define PR_EMS_AB_USN_LAST_OBJ_REM           PROP_TAG( PT_LONG,          0x8156)
#define PR_EMS_AB_USN_SOURCE                 PROP_TAG( PT_LONG,          0x8157)
#define PR_EMS_AB_WWW_HOME_PAGE              PROP_TAG( PT_TSTRING,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_A            PROP_TAG( PT_STRING8,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_W            PROP_TAG( PT_UNICODE,       0x8175)
#define PR_EMS_AB_X121_ADDRESS               PROP_TAG( PT_MV_TSTRING,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_A             PROP_TAG( PT_MV_STRING8,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_W             PROP_TAG( PT_MV_UNICODE,    0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG( PT_BINARY,        0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG( PT_BINARY,        0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT       PROP_TAG( PT_BINARY,        0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED     PROP_TAG( PT_BOOLEAN,       0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE       PROP_TAG( PT_TSTRING,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A     PROP_TAG( PT_STRING8,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W     PROP_TAG( PT_UNICODE,       0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE       PROP_TAG( PT_BINARY,        0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX       PROP_TAG( PT_LONG,          0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST   PROP_TAG( PT_BINARY,        0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT    PROP_TAG( PT_LONG,          0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL        PROP_TAG( PT_LONG,          0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT        PROP_TAG( PT_LONG,          0x8165)

#endif /* _EMSABTAG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\enumvols.hpp ===
//#pragma title( "EnumVols.hpp - Volume Enumeration" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  enumvols.hpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Classes used to generate a list of pathnames, given a list of paths and/or 
               machine names.
Updates     -
===============================================================================
*/
#ifndef ENUMVOLS_HEADER
#define ENUMVOLS_HEADER 

#define MAXSIZE  30000  

#include <lmcons.h>
#include "EaLen.hpp"

#ifndef TNODEINCLUDED
   #include "Tnode.hpp"
   #define TNODEINCLUDED 
#endif

#define  VERIFY_EXISTS           (0x00000001)
#define  VERIFY_BACKUPRESTORE    (0x00000002)
#define  VERIFY_PERSISTENT_ACLS  (0x00000004)

/*******************************************************************************************
      class TPathNode is a TNode, containing a UNICODE pathname.  A TNode is constructed to
      hold each path in the TPathList list
********************************************************************************************/
   
class TPathNode:public TNode
{
protected:
   bool                      haswc;               // these three fields are set by Verify
   bool                      validalone;
   bool                      iscontainer;
   bool                      isFirstFromServer;   // This field is maintained by TPathList
   WCHAR                     path[MAX_PATH + 1];  // the pathname associated with this node
   WCHAR                     server[UNCLEN+1];    // server name for path
         
public:
                        TPathNode(const LPWSTR name); 
   WCHAR *              GetPathName() const { return ( LPWSTR ) path; } 
   WCHAR *              GetServerName() const { return (LPWSTR) server; }
   void                 SetServerName(UCHAR const * name);
   void                 Display() const;   
   bool                 ContainsWC() { return haswc; } 
   bool                 IsValidAlone() { return validalone; }
   void                 ContainsWC(bool val) { haswc = val; }
   void                 IsValidAlone(bool val) {validalone = val; }  
   void                 IsContainer(bool val) { iscontainer = val; }
   bool                 IsContainer() { return iscontainer; }               
   bool                 IsFirstPathFromMachine() { return isFirstFromServer; }
   void                 IsFirstPathFromMachine(bool val) { isFirstFromServer = val; }
   DWORD                VerifyExists();
   DWORD                VerifyBackupRestore();
   DWORD                VerifyPersistentAcls();
protected:
   void                 LookForWCChars(); // looks for wildcard, and sets value of haswc
   void                 FindServerName(); // looks for the name of the server
};

/*******************************************************************************************
      class TPathList 

         BuildPathList: takes an argument list, and builds a list of paths as follows:
                        for each path in the arglist, the path is added,
                        and for each machine-name, a path is added for the root
                        of each shared, security-enabled volume.
      
********************************************************************************************/


class TPathList : public TNodeList
{
protected:
   DWORD                     numServers;             // Stats: count the number of complete servers added  
   DWORD                     numPaths;               // Stats: the number of paths in the list
   TNodeListEnum             tenum;                  // used to enumerate the paths in the list (OpenEnum, Next, CloseEnum)
 
public:
                        TPathList();
                        ~TPathList();
   int                  BuildPathList(TCHAR **argl, int argn, bool verbose); // takes cmd line args & builds path list

   int                  AddVolsOnMachine(const LPWSTR mach, bool verbose,bool verify = false); // takes a machine-name and adds all shared
                                                                    // security-enabled volumes to the list
   bool                 AddPath(const LPWSTR path,DWORD verifyFlags);         // adds a single path (from args)
                                                             // to the list                  

   void                 Clear(); // Removes all the paths in the list
   void                 Display() const;                    // printfs the pathname for each node
   DWORD                GetNumPaths() const { return numPaths; }
   DWORD                GetNumServers() const { return numServers; }
   void                 OpenEnum();                // To enumerate nodes in the list
   void                 CloseEnum();               // OpenEnum, GetItem for each node, CloseEnum
   LPWSTR               Next();                    // Returns the next pathname in the enumeration
   

protected:
   void                 AddPathToList(TPathNode * newNode); // Helper function

};

// TVolumeEnum enumerates the administrative shares on a server
class TVolumeEnum          
{
private:
   DWORD                     numread;           // number of volnames read this time
   DWORD                     total;             // total # vols
   DWORD                     resume_handle;
   DWORD                     curr;              // used to iterate through volumes
   LPBYTE                    pbuf;
   WCHAR                   * drivelist;
   LPBYTE                    shareptr;
   WCHAR                     currEntry[MAX_PATH];
   BOOL                      isOpen;
   BOOL                      verbose;
   UINT                      errmode;
   WCHAR                     server[32];
   DWORD                     verifyFlags;
   BOOL                      bLocalOnly;
   int                       nLeft;
public:
   TVolumeEnum() { nLeft = 0; bLocalOnly = FALSE; isOpen = FALSE; pbuf = NULL; numread = 0; }
   ~TVolumeEnum() { if ( isOpen ) Close(); }
   DWORD    Open(WCHAR const * server,DWORD verifyFlags,BOOL verbose);
   WCHAR *  Next();
   void     Close();

   void     SetLocalMode(BOOL bLocal) { bLocalOnly = bLocal; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\exldap.cpp ===
#include "stdafx.h"
#include <winldap.h>

#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"

#include "exldap.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CLdapConnection::CLdapConnection()
{ 
   m_exchServer[0] = 0; 
   m_LD = NULL; 
   m_port = LDAP_PORT;
   m_bUseSSL = FALSE;
   
   // try to dynamically load the LDAP DLL
   m_hDll = LoadLibrary(L"wldap32.dll");
   ldap_open = NULL;
   ldap_parse_result = NULL;
   ldap_parse_page_control = NULL;
   ldap_controls_free = NULL;
   ber_bvfree = NULL;
   ldap_first_entry = NULL;
   ldap_next_entry = NULL;
   ldap_value_free = NULL;
   ldap_get_values = NULL;
   ldap_create_page_control = NULL;
   ldap_search_ext_s = NULL;
   ldap_count_entries = NULL;
   ldap_msgfree = NULL;
   ldap_modify_s = NULL;
   LdapGetLastError = NULL;
   ldap_bind_sW = NULL;
   ldap_unbind = NULL;
   ldap_get_option = NULL;
   ldap_set_option = NULL;
   LdapMapErrorToWin32 = NULL;
   ldap_init = NULL;

   if ( m_hDll )
   {
      ldap_open = (LDAP_OPEN *)GetProcAddress(m_hDll,"ldap_openW");
      ldap_parse_result = (LDAP_PARSE_RESULT *)GetProcAddress(m_hDll,"ldap_parse_resultW");
      ldap_parse_page_control = (LDAP_PARSE_PAGE_CONTROL*)GetProcAddress(m_hDll,"ldap_parse_page_controlW");
      ldap_controls_free = (LDAP_CONTROLS_FREE*)GetProcAddress(m_hDll,"ldap_controls_freeW");
      ber_bvfree = (BER_BVFREE*)GetProcAddress(m_hDll,"ber_bvfree");
      ldap_first_entry = (LDAP_FIRST_ENTRY*)GetProcAddress(m_hDll,"ldap_first_entry");
      ldap_next_entry = (LDAP_NEXT_ENTRY*)GetProcAddress(m_hDll,"ldap_next_entry");
      ldap_value_free = (LDAP_VALUE_FREE*)GetProcAddress(m_hDll,"ldap_value_freeW");
      ldap_get_values = (LDAP_GET_VALUES*)GetProcAddress(m_hDll,"ldap_get_valuesW");
      ldap_create_page_control = (LDAP_CREATE_PAGE_CONTROL*)GetProcAddress(m_hDll,"ldap_create_page_controlW");
      ldap_search_ext_s = (LDAP_SEARCH_EXT_S*)GetProcAddress(m_hDll,"ldap_search_ext_sW");
      ldap_count_entries = (LDAP_COUNT_ENTRIES*)GetProcAddress(m_hDll,"ldap_count_entries");
      ldap_msgfree = (LDAP_MSGFREE*)GetProcAddress(m_hDll,"ldap_msgfree");
      ldap_modify_s = (LDAP_MODIFY_S*)GetProcAddress(m_hDll,"ldap_modify_sW");
      LdapGetLastError = (LDAPGETLASTERROR*)GetProcAddress(m_hDll,"LdapGetLastError");
      ldap_bind_sW = (LDAP_BIND*)GetProcAddress(m_hDll,"ldap_bind_sW");
      ldap_unbind = (LDAP_UNBIND*)GetProcAddress(m_hDll,"ldap_unbind");
      ldap_get_option = (LDAP_GET_OPTION*)GetProcAddress(m_hDll,"ldap_get_option");
      ldap_set_option = (LDAP_SET_OPTION*)GetProcAddress(m_hDll,"ldap_set_option");
      LdapMapErrorToWin32 = (LDAPMAPERRORTOWIN32*)GetProcAddress(m_hDll,"LdapMapErrorToWin32");
      ldap_init = (LDAP_INIT *)GetProcAddress(m_hDll,"ldap_initW");
   }
   
}

CLdapConnection::~CLdapConnection()
{
   Close();
   if ( m_hDll )
   {
      FreeLibrary(m_hDll);
      ldap_open = NULL;
      ldap_parse_result = NULL;
      ldap_parse_page_control = NULL;
      ldap_controls_free = NULL;
      ber_bvfree = NULL;
      ldap_first_entry = NULL;
      ldap_next_entry = NULL;
      ldap_value_free = NULL;
      ldap_get_values = NULL;
      ldap_create_page_control = NULL;
      ldap_search_ext_s = NULL;
      ldap_count_entries = NULL;
      ldap_msgfree = NULL;
      ldap_modify_s = NULL;
      LdapGetLastError = NULL;
      ldap_bind_sW = NULL;
      ldap_unbind = NULL;
      LdapMapErrorToWin32 = NULL;
      ldap_init = NULL;
   }
}


 
DWORD  CLdapConnection::Connect(WCHAR const * server, ULONG port = LDAP_PORT)
{
   DWORD                     rc = 0;

   safecopy(m_exchServer,server);

//   m_LD = CLdapConnection::ldap_open(m_exchServer,LDAP_SSL_PORT);
	  //replace ldap_open(servername,..) with ldap_init and set LDAP_OPT_AREC_EXCLUSIVE 
      //flag so that the following ldap calls (i.e. ldap_bind) will not need to 
	  //unnecessarily query for the domain controller
   m_LD = CLdapConnection::ldap_init(m_exchServer,LDAP_SSL_PORT);
   if (! m_LD )
   {
      // try the non-SSL port
//      m_LD = ldap_open(m_exchServer,port);
      m_LD = ldap_init(m_exchServer,port);
   }
   if ( ! m_LD )
   {
      rc = CLdapConnection::LdapGetLastError();
   }
   else
   {
      ULONG                   flags = 0;

	     //set LDAP_OPT_AREC_EXCLUSIVE flag so that the following calls tp
	     //ldap_open will not need to unnecessarily query for the domain controller
      flags = PtrToUlong(LDAP_OPT_ON); 
      ldap_set_option(m_LD, LDAP_OPT_AREC_EXCLUSIVE, &flags);

      // set version to 3
      rc = ldap_get_option(m_LD, LDAP_OPT_VERSION,&flags);

      if ( ! rc )
      {
         flags = LDAP_VERSION3;
    
         
         rc = ldap_set_option(m_LD,LDAP_OPT_VERSION, &flags);
      }

      if (! rc )
      {
         if ( *m_credentials )
         {
            rc = CLdapConnection::ldap_bind_s(m_LD,m_credentials,m_password,LDAP_AUTH_SIMPLE);
            if ( rc )
            {
               rc = CLdapConnection::ldap_bind_s(m_LD,NULL,NULL,LDAP_AUTH_NTLM);
            }
         }
         else
         {
            rc = CLdapConnection::ldap_bind_s(m_LD,NULL,NULL,LDAP_AUTH_NTLM);
         }
      }
      if ( rc )
      {
         rc = CLdapConnection::LdapMapErrorToWin32(rc);
      }
   }
   
   return rc;
}

void   CLdapConnection::Close()
{
   if ( m_LD )
   {
      CLdapConnection::ldap_unbind(m_LD);
      m_LD = NULL;
   }
}

DWORD CLdapConnection::UpdateSimpleStringValue(WCHAR const * dn, WCHAR const * property, WCHAR const * value)
{
   DWORD             rc = ERROR_NOT_FOUND;

   if ( m_LD )
   {
      LDAPMod         * mods[2];
      LDAPMod           mod1;
      WCHAR           * strVals[] = { const_cast<WCHAR*>(value),NULL };
      mods[0] = &mod1;

      mods[0]->mod_op = LDAP_MOD_REPLACE;
      mods[0]->mod_type = const_cast<WCHAR*>(property);
      mods[0]->mod_vals.modv_strvals = strVals;
      mods[1] = NULL;

      rc = CLdapConnection::ldap_modify_s(m_LD,const_cast<WCHAR*>(dn),mods);
      if ( rc )
      {
         rc = CLdapConnection::LdapMapErrorToWin32(rc);
      }
   }

   return rc;
}

// Helper function for SidToString - converts one BYTE of the SID into a string representation
void 
   CLdapConnection::AddByteToString(
      WCHAR               ** string,      // i/o- pointer to current location in string
      BYTE                   value        // in - value (from SID) to add to the string
   )
{
   WCHAR                     hi,
                             lo;
   BYTE                      hiVal, 
                             loVal;

   loVal = value & 0x0F;
   hiVal = value & 0xF0;
   hiVal = hiVal >> 4;

   if  ( hiVal < 10 )
   {
      hi=L'0' + hiVal;
   }
   else
   {
      hi=L'A' + ( hiVal - 10 );
   }

   if ( loVal < 10 )
   {
      lo=L'0' + loVal;
   }
   else
   {
      lo=L'A' + (loVal - 10 );
   }
   swprintf(*string,L"%c%c",hi,lo);

   *string+=2;
}

BYTE                                          // ret- value for the digit, or 0 if value is not a valid hex digit
   CLdapConnection::HexValue(
      WCHAR                  value           // in - character representing a hex digit
   )
{
   BYTE                      val = 0;
   switch ( toupper((char)value) )
   {
   case L'1': val = 1; break;
   case L'2': val = 2; break;
   case L'3': val = 3; break;
   case L'4': val = 4; break;
   case L'5': val = 5; break;
   case L'6': val = 6; break;
   case L'7': val = 7; break;
   case L'8': val = 8; break;
   case L'9': val = 9; break;
   case L'A': val = 0xA; break;
   case L'B': val = 0xB; break;
   case L'C': val = 0xC; break;
   case L'D': val = 0xD; break;
   case L'E': val = 0xE; break;
   case L'F': val = 0xF; break;
   }
   return val;
}


BOOL                                         // ret- 0=success, or ERROR_INSUFFICIENT_BUFFER 
   CLdapConnection::BytesToString(
      BYTE                 * pBytes,         // in - SID to represent as a string
      WCHAR                * sidString,      // out- buffer that will contain the 
      DWORD                  numBytes        // in - number of bytes in the buffer to copy
   )
{
   BOOL                      bSuccess = TRUE;
   WCHAR                   * curr = sidString;

   // add each byte of the SID to the output string
   for ( int i = 0 ; i < (int)numBytes ; i++)
   {  
      AddByteToString(&curr,pBytes[i]);
   }
   return bSuccess;
}

BOOL 
   CLdapConnection::StringToBytes(
      WCHAR          const * pString,     // in - string representing the data
      BYTE                 * pBytes       // out- binary representation of the data
   )
{
   BOOL                      bSuccess = TRUE;
   int                       len = UStrLen(pString) / 2;

   for ( int i = 0 ; i < len ; i++, pString += 2 )
   {
      // each byte is represented by 2 characters
      WCHAR                  str[3];
      BYTE                   hi,lo;

      safecopy(str,pString);
      
      hi = HexValue(str[0]);
      lo = HexValue(str[1]);

      pBytes[i] = ((hi << 4)+lo);
      
   }

   return bSuccess;
}

CLdapEnum::~CLdapEnum()
{
   if ( m_message )
   {
      m_connection.ldap_msgfree(m_message);
      m_message = NULL;
   }
}


DWORD 
   CLdapEnum::Open(
      WCHAR          const * query,          // in - query to execute
      WCHAR          const * basePoint,      // in - basepoint for query
      short                  scope,          // in - scope: 0=base only, 1=one level, 2=recursive
      long                   pageSize,       // in - page size to use for large searches
      int                    numAttributes,  // in - number of attributes to retrieve for each matching item
      WCHAR               ** attrs           // in - array of attribute names to retrieve for each matching item
   )
{
   // open and bind before calling this function
   ULONG                     result;
//   PLDAPSearch               searchBlock = NULL;
   PLDAPControl              serverControls[2];
//   l_timeval                 timeout = { 1000,1000 };
//   ULONG                     totalCount = 0;
   berval                    cookie1 = { 0, NULL };
//   DWORD                     numRead = 0;
 
   if ( m_message )
   {
      m_connection.ldap_msgfree(m_message);
      m_message = NULL;
   }

   LDAP                    * ld = m_connection.GetHandle();

   safecopy(m_query,query);
   safecopy(m_basepoint,basePoint);
   m_scope = scope;
   m_pageSize = pageSize;
   m_nAttributes = numAttributes;
   m_AttrNames = attrs;


   result = m_connection.ldap_create_page_control(ld,
                                     pageSize,
                                     &cookie1,
                                     FALSE, // is critical
                                     &serverControls[0]
                                    );

   serverControls[1] = NULL;

   result = m_connection.ldap_search_ext_s(ld,
                     m_basepoint,
                     m_scope,
                     m_query,
                     m_AttrNames,
                     FALSE,
                     serverControls,
                     NULL,
                     NULL,
                     0,
                     &m_message);
  
   if  ( ! result )
   {
      m_nReturned = m_connection.ldap_count_entries(ld,m_message);
      m_nCurrent = 0;
      m_bOpen = TRUE;
   }

  
   return m_connection.LdapMapErrorToWin32(result);
}

DWORD 
   CLdapEnum::Next(
      PWCHAR              ** ppAttrs        // out- array of values for the next matching item
   )
{
   DWORD                     rc = 0;

   if ( ! m_bOpen )
   {
      rc = ERROR_NOT_FOUND;
   }
   else
   {
      if ( m_nReturned > m_nCurrent )
      {
         // return the next entry from the current page
         return GetNextEntry(ppAttrs);
      }
      else 
      {
         // see if there are more pages of results to get
         rc = GetNextPage();
         if (! rc )
         {
            return GetNextEntry(ppAttrs);
         }
      }


   }
   return rc;
}

void CLdapEnum::FreeData(WCHAR ** values)
{
   for ( int i = 0 ; m_AttrNames[i] ; i++ )
   {
      if ( values[i] )
      {
         delete [] values[i];
         values[i] = NULL;
      }
   }
   delete [] values;
}

DWORD 
   CLdapEnum::GetNextEntry(
      PWCHAR              ** ppAttrs
   )
{
   DWORD                     rc = 0;
   WCHAR                  ** pValues = new PWCHAR[m_nAttributes+1];

   if (!pValues)
      return ERROR_NOT_ENOUGH_MEMORY;

   if ( m_nCurrent == 0 )
   {

      m_currMsg = m_connection.ldap_first_entry(m_connection.GetHandle(),m_message);
   }
   else
   {
      m_currMsg = m_connection.ldap_next_entry(m_connection.GetHandle(),m_currMsg);
      
   }
   if ( m_currMsg )
   {

      int curr;

      for ( curr = 0 ; m_AttrNames[curr] ; curr++ )
      {
         pValues[curr] = NULL;

         WCHAR ** allvals = m_connection.ldap_get_values(m_connection.GetHandle(),m_currMsg,m_AttrNames[curr] );
         if ( allvals )
         {
            pValues[curr] = new WCHAR[UStrLen(allvals[0])+1];

		    if (!(pValues[curr]))
			{
			   for (int j=0; j<curr; j++)
			   {
			      delete pValues[j];
			   }
			   delete pValues;
               return ERROR_NOT_ENOUGH_MEMORY;
			}


            UStrCpy(pValues[curr],allvals[0]);
            m_connection.ldap_value_free(allvals);
            allvals =NULL;
         }
      }
      
   }
   (*ppAttrs) = pValues;
   m_nCurrent++;
   return rc;
}

DWORD 
   CLdapEnum::GetNextPage()
{
   ULONG                     result = 0;
   LDAP                    * ld = m_connection.GetHandle();
   berval                  * currCookie = NULL;
//   berval                  * cookie2 = NULL;
//   WCHAR                   * matched = NULL;
   PLDAPControl            * currControls = NULL;
   ULONG                     retcode = 0;    
//   PLDAPControl            * clientControls = NULL;
//   WCHAR                   * errMsg = NULL;
   PLDAPControl              serverControls[2];
   
 
   
   // Get the server control from the message, and make a new control with the cookie from the server
   result = m_connection.ldap_parse_result(ld,m_message,&retcode,NULL,NULL,NULL,&currControls,FALSE);
   m_connection.ldap_msgfree(m_message);
   m_message = NULL;
   if ( ! result )
   {
      result = m_connection.ldap_parse_page_control(ld,currControls,&m_totalCount,&currCookie);
      // under Exchange 5.5, before SP 2, this will fail with LDAP_CONTROL_NOT_FOUND when there are 
      // no more search results.  With Exchange 5.5 SP 2, this succeeds, and gives us a cookie that will 
      // cause us to start over at the beginning of the search results.

   }
   if ( ! result )
   {
      if ( currCookie->bv_len == 0 && currCookie->bv_val == 0 )
      {
         // under Exchange 5.5, SP 2, this means we're at the end of the results.
         // if we pass in this cookie again, we will start over at the beginning of the search results.
         result = LDAP_CONTROL_NOT_FOUND;
      }
      
      serverControls[0] = NULL;
      serverControls[1] = NULL;
      if ( ! result )
      {
         result = m_connection.ldap_create_page_control(ld,
                                 m_pageSize,
                                 currCookie,
                                 FALSE,
                                 serverControls);
      }
      m_connection.ldap_controls_free(currControls);
      currControls = NULL;
      m_connection.ber_bvfree(currCookie);
      currCookie = NULL;
   }

   // continue the search with the new cookie
   if ( ! result )
   {
      result = m_connection.ldap_search_ext_s(ld,
            m_basepoint,
            m_scope,
            m_query,
            m_AttrNames,
            FALSE,
            serverControls,
            NULL,
            NULL,
            0,
            &m_message);

      if ( result && result != LDAP_CONTROL_NOT_FOUND )
      {
         // LDAP_CONTROL_NOT_FOUND means that we have reached the end of the search results 
         // in Exchange 5.5, before SP 2 (the server doesn't return a page control when there 
         // are no more pages, so we get LDAP_CONTROL_NOT_FOUND when we try to extract the page 
         // control from the search results).
         
      }
   }
   if ( ! result )
   {
      m_nReturned = m_connection.ldap_count_entries(ld,m_message);
      m_nCurrent = 0;

   }
   return m_connection.LdapMapErrorToWin32(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\mapiprof.hpp ===
#ifndef __EXMAPIPROF_HPP__
#define __EXMAPIPROF_HPP__
/*---------------------------------------------------------------------------
  File: ExMAPIProf.hpp   

  Comments: class definitions for mapi address book

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 08-Sep-98 13:49:48

 ---------------------------------------------------------------------------
*/

#include <mapix.h>
#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"


// This class encapsulates creating, configuring, using and deleting a MAPI profile
class TMapiProfile
{
   LPMAPISESSION             m_session;
   BOOL                      m_bMapiInitialized;
   BOOL                      m_bLoggedOn;
   TCHAR                     m_profileName[300];
   
public:
   TMapiProfile() { m_session=NULL; m_bMapiInitialized=FALSE; m_bLoggedOn=FALSE; m_profileName[0]=0;}
   ~TMapiProfile();
   DWORD SetProfile(TCHAR * profileName, BOOL create); // Creates profile and adds Exchange messaging service
   
   DWORD Logon(BOOL bMarkProfileForDeletion = FALSE);
   DWORD Logoff();

   LPMAPISESSION GetMapiSessionInterface() { return m_session; }
protected:
   DWORD Initialize();
   DWORD Uninitialize();
};

BOOL LoadMAPI();
void ReleaseMAPI();

extern LPMAPIALLOCATEBUFFER         pMAPIAllocateBuffer;
extern LPMAPIFREEBUFFER             pMAPIFreeBuffer;
extern LPMAPIINITIALIZE             pMAPIInitialize;
extern LPMAPIUNINITIALIZE           pMAPIUninitialize ;
extern LPMAPILOGONEX                pMAPILogonEx;
extern LPMAPIADMINPROFILES          pMAPIAdminProfiles;
extern LPFREEPADRLIST               pFreePadrlist;
extern LPFREEPROWS                  pFreeProws;
extern LPSCDUPPROPSET               pScDupPropset;
extern LPHRQUERYALLROWS             pHrQueryAllRows; 
extern LPULRELEASE                  pUlRelease;

#endif //__EXMAPIPROF_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\mapiprof.cpp ===
/*---------------------------------------------------------------------------
  File: ExMapiProf.cpp

  Comments: implementation of TMapiProfile and TAddressBook classes

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 09-Sep-98 09:38:21

 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "Common.hpp"
#include "Ustring.hpp"
#include <MapiUtil.h>  // For HrQueryAllRows 
//#include <edkmdb.h>
//#include <proptag.h>
#include <emsabtag.h>
#include <mspab.h>
#include "edk2.hpp"
#include "MAPIProf.hpp"



HWND gHWND = NULL;


HINSTANCE                    hMapi = NULL;

LPMAPIALLOCATEBUFFER         pMAPIAllocateBuffer = NULL;
LPMAPIFREEBUFFER             pMAPIFreeBuffer = NULL;
LPMAPIINITIALIZE             pMAPIInitialize = NULL;
LPMAPIUNINITIALIZE           pMAPIUninitialize = NULL;
LPMAPILOGONEX                pMAPILogonEx = NULL;
LPMAPIADMINPROFILES          pMAPIAdminProfiles = NULL;
LPFREEPADRLIST               pFreePadrlist = NULL;
LPFREEPROWS                  pFreeProws = NULL;
LPSCDUPPROPSET               pScDupPropset = NULL;
LPHRQUERYALLROWS             pHrQueryAllRows = NULL;              
LPULRELEASE                  pUlRelease = NULL;      


BOOL LoadMAPI()
{
   BOOL                      success = TRUE;
   
   if ( ! hMapi )
   {
      hMapi = LoadLibrary(_T("MAPI32.DLL"));
      if ( hMapi )
      {
         do { // once    (only show one error message)
            pMAPIAllocateBuffer=(LPMAPIALLOCATEBUFFER)GetProcAddress(hMapi,"MAPIAllocateBuffer");
            if ( ! pMAPIAllocateBuffer )
            {
               success = FALSE;
               break;
            }
            pMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(hMapi,"MAPIFreeBuffer");
            if ( ! pMAPIFreeBuffer )
            {
               success = FALSE;
               break;
            }
            pMAPIInitialize = (LPMAPIINITIALIZE)GetProcAddress(hMapi,"MAPIInitialize");
            if ( ! pMAPIInitialize )
            {
               success = FALSE;
               break;
            }
            pMAPIUninitialize = (LPMAPIUNINITIALIZE)GetProcAddress(hMapi,"MAPIUninitialize");
            if ( ! pMAPIUninitialize )
            {
               success = FALSE;
               break;
            }
            pMAPILogonEx = (LPMAPILOGONEX)GetProcAddress(hMapi,"MAPILogonEx");
            if ( ! pMAPILogonEx )
            {
               success = FALSE;
               break;
            }
            pMAPIAdminProfiles = (LPMAPIADMINPROFILES)GetProcAddress(hMapi,"MAPIAdminProfiles");
            if ( ! pMAPIAdminProfiles )
            {
               success = FALSE;
               break;
            }
         
            pFreePadrlist = (LPFREEPADRLIST)GetProcAddress(hMapi,"FreePadrlist@4");
            if ( ! pFreePadrlist )
            {
               success = FALSE;
               break;
            }

            pFreeProws = (LPFREEPROWS)GetProcAddress(hMapi,"FreeProws@4");
            if ( ! pFreeProws )
            {
               success = FALSE;
               break;
            }
            pScDupPropset = (LPSCDUPPROPSET)GetProcAddress(hMapi,"ScDupPropset@16");
            if ( ! pScDupPropset )
            {
               success = FALSE;
               break;
            }
            pHrQueryAllRows = (LPHRQUERYALLROWS)GetProcAddress(hMapi,"HrQueryAllRows@24");
            if ( ! pHrQueryAllRows )
            {
               success = FALSE;
               break;
            }
            pUlRelease = (LPULRELEASE)GetProcAddress(hMapi,"UlRelease@4");
            if ( ! pUlRelease )
            {
               success = FALSE;
               break;
            }
         }
         while (FALSE);
      }
      else
      {
         success = FALSE;
      }
      if ( hMapi && !success )
      {
         ReleaseMAPI();
      }
   }
   return (hMapi!=NULL && success);
}

void ReleaseMAPI()
{
   if ( hMapi )
   {
      FreeLibrary(hMapi);
      hMapi = NULL;
      pMAPIAllocateBuffer = NULL;
      pMAPIFreeBuffer = NULL;
      pMAPIInitialize = NULL;
      pMAPIUninitialize = NULL;
      pMAPILogonEx = NULL;
      pMAPIAdminProfiles = NULL;
      pFreePadrlist = NULL;
      pFreeProws = NULL;
      pScDupPropset = NULL;
      pHrQueryAllRows = NULL;              
      pUlRelease = NULL;     
   }
}

DWORD TMapiProfile::Initialize()
{
   DWORD                     rc = 0;
   MAPIINIT_0                MAPIINIT = { 0, MAPI_MULTITHREAD_NOTIFICATIONS}; 


   if ( ! m_bMapiInitialized )
   {
      rc = (*pMAPIInitialize)(&MAPIINIT);
      m_bMapiInitialized = TRUE;      
   }
   return rc;
}

DWORD TMapiProfile::Uninitialize()
{
   if ( m_bMapiInitialized )
   {
      (*pMAPIUninitialize)();
      m_bMapiInitialized = FALSE;
   }
   return 0;
}

DWORD TMapiProfile::Logon(BOOL bMarkForDelete)
{
   //  start a new session
   HRESULT                   hr;
   DWORD                     rc = 0;
   BOOL                      error = FALSE;

   Initialize();

   FLAGS                     fLogonOptions = MAPI_NO_MAIL | MAPI_EXTENDED | MAPI_NEW_SESSION;
   WCHAR                     pszMapiProfile[200] = L"";

   if ( m_profileName )
   {
      safecopy(pszMapiProfile,m_profileName);
      fLogonOptions |= MAPI_EXPLICIT_PROFILE;
   }
   else
   {
      fLogonOptions |= MAPI_USE_DEFAULT;
   }

   hr = (*pMAPILogonEx)(0, (WCHAR *)pszMapiProfile, NULL, fLogonOptions | MAPI_UNICODE, &m_session);
   
   if (FAILED(hr)) 
   {
      error = TRUE;
   }
   
   if ( error )
   {
      rc = (DWORD)hr;
      m_session = NULL; 
   }
   else
   {
      m_bLoggedOn = TRUE;
   }
   return rc;
}

DWORD TMapiProfile::Logoff()
{
   if ( m_session )
   {
//      HRESULT hr = m_session->Logoff(0,0,0);
      m_session->Logoff(0,0,0);
      m_bLoggedOn = FALSE;
      m_session=NULL;
   }
   Uninitialize();

   return 0;
}


DWORD
   TMapiProfile::SetProfile(TCHAR * profile, BOOL create)
{
   DWORD                     rc=0;

   safecopy(m_profileName,profile);
   
   return rc;
}

TMapiProfile::~TMapiProfile()
{
   if ( m_bLoggedOn )
   {
      Logoff();
   }
  Uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\exchange.hpp ===
/*---------------------------------------------------------------------------
  File: Exchange.hpp

  Comments: Mailbox security translation functions.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: ...
  Revised on 2/8/98 6:32:13 PM

 ---------------------------------------------------------------------------
*/



#ifndef __EXCHANGE_HPP__
#define __EXCHANGE_HPP__

#define INITGUID
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IMAPITable
#define USES_IID_IDistList
#define USES_IID_IMAPIProp

#include <winbase.h>
#include <objbase.h>
#include <mapiguid.h>
#include <mapiutil.h>
#include <emsabtag.h>

#include "edk2.hpp"

#include "stargs.hpp"
#include "sidcache.hpp"
#include "Ustring.hpp"
#include "sdstat.hpp"
#include <dapi.h>
#include "exldap.h"

// Maximum numbers of entries to put through MAPI calls:
#define  MAX_COPY_ENTRIES     1024L
#define  MAX_DELETE_ENTRIES   1024L

// Macro causes many retries on operations that may fail at first and succeed after a retry.
#define  RETRIES  100
#ifdef _DEBUG
#define MAKE_MAPI_CALL(hr, c)                                                             \
{                                                                                         \
   int   iMapiRetriesOnMapiCallFailed = 0;                                                \
   do {                                                                                   \
      hr = c;                                                                             \
   } while( (hr == MAPI_E_CALL_FAILED) && (++iMapiRetriesOnMapiCallFailed < RETRIES) );   \
   if (iMapiRetriesOnMapiCallFailed && SUCCEEDED(hr)) {                                   \
      printf("%s succeeded after %d retries.\n", #c, iMapiRetriesOnMapiCallFailed);       \
   }                                                                                      \
}
#else
#define MAKE_MAPI_CALL(hr, c)                                                             \
{                                                                                         \
   int   iMapiRetriesOnMapiCallFailed = 0;                                                \
   do {                                                                                   \
      hr = c;                                                                             \
   } while( (hr == MAPI_E_CALL_FAILED) && (++iMapiRetriesOnMapiCallFailed < RETRIES) );   \
}
#endif

class TGlobalDirectory
{ 

protected:
   BOOL                m_bUseDefaultMapiProfile;        // Whether to use MAPI profile listed in Registry.
   BOOL                m_bPromptForMapiProfile;         // Whether to prompt for MAPI profile.
   LPTSTR              m_pszMapiProfile;                // MAPI profile to use.
   TSDResolveStats   * m_stat;
   
                                             // DAPI
   DAPI_HANDLE    m_dSession;
   DAPI_PARMS     m_dParms;
   
public:
   TGlobalDirectory::TGlobalDirectory();
   TGlobalDirectory::~TGlobalDirectory();
   

protected:
   // MAPI
   BOOL              m_bMapiInitialized;              // TRUE if initialization was successful.
   LPMAPISESSION     m_pMapiSession;         // MAPI session handle.

   LPADRBOOK         m_pAdrBook;             // The master AB.

   LPABCONT          m_pGlobalList;
   LPABCONT          m_pContainer;
   LPMAPITABLE       m_pGlobalTable;
   LPSPropTagArray   m_pGlobalPropertyTags;
   LPSRowSet         m_pGlobalRows;
   LPSRowSet         m_pRootRows;  
   LPMAPITABLE       m_pContainerTable;
   WCHAR           * m_name;              // container name used in error messages   
   void     LogMapiError(int iSeverity, LPCTSTR pszEntryPoint, HRESULT hr);
   void     LogDapiError(int iSeverity, LPCTSTR pszUserMessage, DAPI_EVENT * pResult);
   BOOL     m_bLoggedFailedClose;            // Already logged a failure to close.
   LPTSTR   GetMapiProfile() const;          // The MAPI profile to use; may be default.
   BOOL     DoUseDefaultMapiProfile() const; // Whether to use MAPI profile listed in Registry.
   BOOL     DoPromptForMapiProfile() const;  // Whether to prompt for MAPI profile.
   
public:
   void     SetStats(TSDResolveStats * s ) { m_stat = s; }
   BOOL     StartMapiSession();              // Use MAPI profile switch to start a session.
   void     EndMapiSession();                // Close the MAPI session.
   BOOL     MapiIsOpen() { return (m_pMapiSession != 0 ) ; }
   BOOL     OpenGlobalList();                // Open the address book and the Global List.
   void     CloseGlobalList();               // Release the address book and Global List.
   void     PromptForMapiProfile() { m_bPromptForMapiProfile = TRUE; m_bUseDefaultMapiProfile = FALSE;}
   void     UseDefaultMapiProfile() { m_bUseDefaultMapiProfile = TRUE; m_bPromptForMapiProfile = FALSE; }
   void     SetMapiProfile(LPCTSTR profile) { m_pszMapiProfile = new TCHAR [  UStrLen(profile) + 1 ];
                                             UStrCpy(m_pszMapiProfile,profile);
                                             m_bPromptForMapiProfile = FALSE; m_bUseDefaultMapiProfile = FALSE;}
   
   BOOL     Scan(SecurityTranslatorArgs * args,WCHAR const * container); // uses MAPI to update mailboxes
   BOOL     DoDAPITranslation(WCHAR * server,SecurityTranslatorArgs * args); // uses DAPI to update sites, containers, orgs.
   BOOL     DoLdapTranslation(WCHAR * server,WCHAR * creds, WCHAR * password,SecurityTranslatorArgs * args,WCHAR * basepoint,WCHAR * query = NULL );
   DWORD    GetLDAPPort(WCHAR * server);
   void GetSiteNameForServer(WCHAR const * server,CLdapEnum * e,WCHAR * siteName);
protected:
   // MAPI work routines
   BOOL UpdateEntry( LPMAPIPROP pUserEntry, ULONG ulType, SecurityTranslatorArgs * args);
   BOOL ScanHierarchy( LPABCONT pContainerTable, SecurityTranslatorArgs * args,WCHAR const * container);
   BOOL ScanContents(LPMAPITABLE pContainerTable,SecurityTranslatorArgs * args);
   // DAPI work routines
   BOOL  DAPITranslate(WCHAR * dn,SecurityTranslatorArgs * args);
   BOOL DAPIOpen(WCHAR * server);
   BOOL DAPIClose();
   // not used
   BOOL     OpenContainerByRow(long row);
   BOOL     OpenContainerByName(WCHAR * name, TAccountCache * cache, BOOL nochange);
   //BOOL     ListContainers(CTreeCtrl * tree);
   //BOOL  DoDAPIThing(CTreeCtrl * tree, CString dn);
   
};


BOOL LoadDAPI();
void ReleaseDAPI();



#endif //__EXCHANGE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\ntdsapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    ntdsapi.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for public NTDS APIs other than directory interfaces like LDAP.

Environment:

    User Mode - Win32

Notes:

--*/


#ifndef _NTDSAPI_H_
#define _NTDSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <schedule.h>

#if !defined(_NTDSAPI_)
#define NTDSAPI DECLSPEC_IMPORT
#else
#define NTDSAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Data definitions                                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#ifdef MIDL_PASS
typedef GUID UUID;
typedef void * RPC_AUTH_IDENTITY_HANDLE;
typedef void VOID;
#endif

#define DS_DEFAULT_LOCALE                                           \
           (MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),  \
                     SORT_DEFAULT))

#define DS_DEFAULT_LOCALE_COMPARE_FLAGS    (NORM_IGNORECASE     |   \
                                            NORM_IGNOREKANATYPE |   \
                                            NORM_IGNORENONSPACE |   \
                                            NORM_IGNOREWIDTH)

// When booted to DS mode, this event is signalled when the DS has completed
// its initial sync attempts.  The period of time between system startup and
// this event's state being set is indeterminate from the local service's
// standpoint.  In the meantime the contents of the DS should be considered
// incomplete / out-dated, and the machine will not be advertised as a domain
// controller to off-machine clients.  Other local services that rely on
// information published in the DS should avoid accessing (or at least
// relying on) the contents of the DS until this event is set.
#define DS_SYNCED_EVENT_NAME    "NTDSInitialSyncsCompleted"
#define DS_SYNCED_EVENT_NAME_W L"NTDSInitialSyncsCompleted"

// Permissions bits used in security descriptors in the directory.
#ifndef _DS_CONTROL_BITS_DEFINED_
#define _DS_CONTROL_BITS_DEFINED_
#define ACTRL_DS_OPEN                           0x00000000
#define ACTRL_DS_CREATE_CHILD                   0x00000001
#define ACTRL_DS_DELETE_CHILD                   0x00000002
#define ACTRL_DS_LIST                           0x00000004
#define ACTRL_DS_SELF                           0x00000008
#define ACTRL_DS_READ_PROP                      0x00000010
#define ACTRL_DS_WRITE_PROP                     0x00000020
#define ACTRL_DS_DELETE_TREE                    0x00000040
#define ACTRL_DS_LIST_OBJECT                    0x00000080
#define ACTRL_DS_CONTROL_ACCESS                 0x00000100
#endif
    
typedef enum
{
    // unknown name type
    DS_UNKNOWN_NAME = 0,

    // eg: CN=Spencer Katt,OU=Users,DC=Engineering,DC=Widget,DC=Com
    DS_FQDN_1779_NAME = 1,

    // eg: Engineering\SpencerK
    // Domain-only version includes trailing '\\'.
    DS_NT4_ACCOUNT_NAME = 2,

    // Probably "Spencer Katt" but could be something else.  I.e. The
    // display name is not necessarily the defining RDN.
    DS_DISPLAY_NAME = 3,

    // obsolete - see #define later
    // DS_DOMAIN_SIMPLE_NAME = 4,

    // obsolete - see #define later
    // DS_ENTERPRISE_SIMPLE_NAME = 5,

    // String-ized GUID as returned by IIDFromString().
    // eg: {4fa050f0-f561-11cf-bdd9-00aa003a77b6}
    DS_UNIQUE_ID_NAME = 6,

    // eg: engineering.widget.com/software/spencer katt
    // Domain-only version includes trailing '/'.
    DS_CANONICAL_NAME = 7,

    // eg: spencerk@engineering.widget.com
    DS_USER_PRINCIPAL_NAME = 8,

    // Same as DS_CANONICAL_NAME except that rightmost '/' is
    // replaced with '\n' - even in domain-only case.
    // eg: engineering.widget.com/software\nspencer katt
    DS_CANONICAL_NAME_EX = 9,

    // eg: www/www.widget.com@widget.com - generalized service principal
    // names.
    DS_SERVICE_PRINCIPAL_NAME = 10

} DS_NAME_FORMAT;

// Map old name formats to closest new format so that old code builds
// against new headers w/o errors and still gets (almost) correct result.

#define DS_DOMAIN_SIMPLE_NAME       DS_USER_PRINCIPAL_NAME
#define DS_ENTERPRISE_SIMPLE_NAME   DS_USER_PRINCIPAL_NAME

typedef enum
{
    DS_NAME_NO_FLAGS = 0x0,

    // Perform a syntactical mapping at the client (if possible) without
    // going out on the wire.  Returns DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
    // if a purely syntactical mapping is not possible.
    DS_NAME_FLAG_SYNTACTICAL_ONLY = 0x1,

    // Force a trip to the DC for evaluation, even if this could be
    // locally cracked syntactically.
    DS_NAME_FLAG_EVAL_AT_DC = 0x2

} DS_NAME_FLAGS;

typedef enum
{
    DS_NAME_NO_ERROR = 0,

    // Generic processing error.
    DS_NAME_ERROR_RESOLVING = 1,

    // Couldn't find the name at all - or perhaps caller doesn't have
    // rights to see it.
    DS_NAME_ERROR_NOT_FOUND = 2,

    // Input name mapped to more than one output name.
    DS_NAME_ERROR_NOT_UNIQUE = 3,

    // Input name found, but not the associated output format.
    // Can happen if object doesn't have all the required attributes.
    DS_NAME_ERROR_NO_MAPPING = 4,

    // Unable to resolve entire name, but was able to determine which
    // domain object resides in.  Thus DS_NAME_RESULT_ITEM?.pDomain
    // is valid on return.
    DS_NAME_ERROR_DOMAIN_ONLY = 5,

    // Unable to perform a purely syntactical mapping at the client
    // without going out on the wire.
    DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = 6

} DS_NAME_ERROR;

#define DS_NAME_LEGAL_FLAGS (DS_NAME_FLAG_SYNTACTICAL_ONLY)

typedef enum {

    // "paulle-nec.ntwksta.ms.com"
    DS_SPN_DNS_HOST = 0,

    // "cn=paulle-nec,ou=computers,dc=ntwksta,dc=ms,dc=com"
    DS_SPN_DN_HOST = 1,

    // "paulle-nec"
    DS_SPN_NB_HOST = 2,

    // "ntdev.ms.com"
    DS_SPN_DOMAIN = 3,

    // "ntdev"
    DS_SPN_NB_DOMAIN = 4,

    // "cn=anRpcService,cn=RPC Services,cn=system,dc=ms,dc=com"
    // "cn=aWsService,cn=Winsock Services,cn=system,dc=ms,dc=com"
    // "cn=aService,dc=itg,dc=ms,dc=com"
    // "www.ms.com", "ftp.ms.com", "ldap.ms.com"
    // "products.ms.com"
    DS_SPN_SERVICE = 5

} DS_SPN_NAME_TYPE;

typedef enum {                          // example:
        DS_SPN_ADD_SPN_OP = 0,          // add SPNs
        DS_SPN_REPLACE_SPN_OP = 1,      // set all SPNs
        DS_SPN_DELETE_SPN_OP = 2        // Delete SPNs
} DS_SPN_WRITE_OP;

typedef struct
{
    DWORD                   status;     // DS_NAME_ERROR
#ifdef MIDL_PASS
    [string,unique] CHAR    *pDomain;   // DNS domain
    [string,unique] CHAR    *pName;     // name in requested format
#else
    LPSTR                   pDomain;    // DNS domain
    LPSTR                   pName;      // name in requested format
#endif

} DS_NAME_RESULT_ITEMA, *PDS_NAME_RESULT_ITEMA;

typedef struct
{
    DWORD                   cItems;     // item count
#ifdef MIDL_PASS
    [size_is(cItems)] PDS_NAME_RESULT_ITEMA rItems;
#else
    PDS_NAME_RESULT_ITEMA    rItems;    // item array
#endif

} DS_NAME_RESULTA, *PDS_NAME_RESULTA;

typedef struct
{
    DWORD                   status;     // DS_NAME_ERROR
#ifdef MIDL_PASS
    [string,unique] WCHAR   *pDomain;   // DNS domain
    [string,unique] WCHAR   *pName;     // name in requested format
#else
    LPWSTR                  pDomain;    // DNS domain
    LPWSTR                  pName;      // name in requested format
#endif

} DS_NAME_RESULT_ITEMW, *PDS_NAME_RESULT_ITEMW;

typedef struct
{
    DWORD                   cItems;     // item count
#ifdef MIDL_PASS
    [size_is(cItems)] PDS_NAME_RESULT_ITEMW rItems;
#else
    PDS_NAME_RESULT_ITEMW    rItems;    // item array
#endif

} DS_NAME_RESULTW, *PDS_NAME_RESULTW;

#ifdef UNICODE
#define DS_NAME_RESULT DS_NAME_RESULTW
#define PDS_NAME_RESULT PDS_NAME_RESULTW
#define DS_NAME_RESULT_ITEM DS_NAME_RESULT_ITEMW
#define PDS_NAME_RESULT_ITEM PDS_NAME_RESULT_ITEMW
#else
#define DS_NAME_RESULT DS_NAME_RESULTA
#define PDS_NAME_RESULT PDS_NAME_RESULTA
#define DS_NAME_RESULT_ITEM DS_NAME_RESULT_ITEMA
#define PDS_NAME_RESULT_ITEM PDS_NAME_RESULT_ITEMA
#endif

// Public replication option flags

// ********************
// Replica Sync flags
// ********************

// Perform this operation asynchronously.
// Required when using DS_REPSYNC_ALL_SOURCES
#define DS_REPSYNC_ASYNCHRONOUS_OPERATION 0x00000001

// Writeable replica.  Otherwise, read-only.
#define DS_REPSYNC_WRITEABLE              0x00000002

// This is a periodic sync request as scheduled by the admin.
#define DS_REPSYNC_PERIODIC               0x00000004

// Use inter-site messaging
#define DS_REPSYNC_INTERSITE_MESSAGING    0x00000008

// Sync from all sources.
#define DS_REPSYNC_ALL_SOURCES            0x00000010

// Sync starting from scratch (i.e., at the first USN).
#define DS_REPSYNC_FULL                   0x00000020

// This is a notification of an update that was marked urgent.
#define DS_REPSYNC_URGENT                 0x00000040

// Don't discard this synchronization request, even if a similar
// sync is pending.
#define DS_REPSYNC_NO_DISCARD             0x00000080

// Sync even if link is currently disabled.
#define DS_REPSYNC_FORCE                  0x00000100

// Causes the source DSA to check if a reps-to is present for the local DSA
// (aka the destination). If not, one is added.  This ensures that
// source sends change notifications.
#define DS_REPSYNC_ADD_REFERENCE           0x00000200



// ********************
// Replica Add flags
// ********************

// Perform this operation asynchronously.
#define DS_REPADD_ASYNCHRONOUS_OPERATION 0x00000001

// Create a writeable replica.  Otherwise, read-only.
#define DS_REPADD_WRITEABLE               0x00000002

// Sync the NC from this source when the DSA is started.
#define DS_REPADD_INITIAL                 0x00000004

// Sync the NC from this source periodically, as defined by the
// schedule passed in the preptimesSync argument.
#define DS_REPADD_PERIODIC                0x00000008

// Sync from the source DSA via an Intersite Messaging Service (ISM) transport
// (e.g., SMTP) rather than native DS RPC.
#define DS_REPADD_INTERSITE_MESSAGING     0x00000010

// Don't replicate the NC now -- just save enough state such that we
// know to replicate it later.
#define DS_REPADD_ASYNCHRONOUS_REPLICA     0x00000020

// Disable notification-based synchronization for the NC from this source.
// This is expected to be a temporary state; the similar flag
// DS_REPADD_NEVER_NOTIFY should be used if the disable is to be more permanent.
#define DS_REPADD_DISABLE_NOTIFICATION     0x00000040

// Disable periodic synchronization for the NC from this source
#define DS_REPADD_DISABLE_PERIODIC         0x00000080

// Use compression when replicating.  Saves message size (e.g., network
// bandwidth) at the expense of extra CPU overhead at both the source and
// destination servers.
#define DS_REPADD_USE_COMPRESSION          0x00000100

// Do not request change notifications from this source.  When this flag is
// set, the source will not notify the destination when changes occur.
// Recommended for all intersite replication, which may occur over WAN links.
// This is expected to be a more or less permanent state; the similar flag
// DS_REPADD_DISABLE_NOTIFICATION should be used if notifications are to be
// disabled only temporarily.
#define DS_REPADD_NEVER_NOTIFY             0x00000200




// ********************
// Replica Delete flags
// ********************

// Perform this operation asynchronously.
#define DS_REPDEL_ASYNCHRONOUS_OPERATION 0x00000001

// The replica being deleted is writeable.
#define DS_REPDEL_WRITEABLE               0x00000002

// Replica is a mail-based replica
#define DS_REPDEL_INTERSITE_MESSAGING     0x00000004

// Ignore any error generated by contacting the source to tell it to scratch
// this server from its Reps-To for this NC.
#define DS_REPDEL_IGNORE_ERRORS           0x00000008

// Do not contact the source telling it to scratch this server from its
// Rep-To for this NC.  Otherwise, if the link is RPC-based, the source will
// be contacted.
#define DS_REPDEL_LOCAL_ONLY              0x00000010

// Delete all the objects in the NC
// "No source" is incompatible with (and rejected for) writeable NCs.  This is
// valid only for read-only NCs, and then only if the NC has no source.  This
// can occur when the NC has been partially deleted (in which case the KCC
// periodically calls the delete API with the "no source" flag set).
#define DS_REPDEL_NO_SOURCE               0x00000020

// Allow deletion of read-only replica even if it sources
// other read-only replicas.
#define DS_REPDEL_REF_OK                  0x00000040

// ********************
// Replica Modify flags
// ********************

// Perform this operation asynchronously.
#define DS_REPMOD_ASYNCHRONOUS_OPERATION  0x00000001

// The replica is writeable.
#define DS_REPMOD_WRITEABLE               0x00000002


// ********************
// Replica Modify fields
// ********************

#define DS_REPMOD_UPDATE_FLAGS             0x00000001
#define DS_REPMOD_UPDATE_ADDRESS           0x00000002
#define DS_REPMOD_UPDATE_SCHEDULE          0x00000004
#define DS_REPMOD_UPDATE_RESULT            0x00000008
#define DS_REPMOD_UPDATE_TRANSPORT         0x00000010

// ********************
// Update Refs fields
// ********************

// Perform this operation asynchronously.
#define DS_REPUPD_ASYNCHRONOUS_OPERATION  0x00000001

// The replica being deleted is writeable.
#define DS_REPUPD_WRITEABLE               0x00000002

// Add a reference
#define DS_REPUPD_ADD_REFERENCE           0x00000004

// Remove a reference
#define DS_REPUPD_DELETE_REFERENCE        0x00000008


// ***********************
// Well Known Object Guids
// ***********************

#define GUID_USERS_CONTAINER_A              "a9d1ca15768811d1aded00c04fd8d5cd"
#define GUID_COMPUTRS_CONTAINER_A           "aa312825768811d1aded00c04fd8d5cd"
#define GUID_SYSTEMS_CONTAINER_A            "ab1d30f3768811d1aded00c04fd8d5cd"
#define GUID_DOMAIN_CONTROLLERS_CONTAINER_A "a361b2ffffd211d1aa4b00c04fd7d83a"
#define GUID_INFRASTRUCTURE_CONTAINER_A     "2fbac1870ade11d297c400c04fd8d5cd"
#define GUID_DELETED_OBJECTS_CONTAINER_A    "18e2ea80684f11d2b9aa00c04f79f805"
#define GUID_LOSTANDFOUND_CONTAINER_A       "ab8153b7768811d1aded00c04fd8d5cd"

#define GUID_USERS_CONTAINER_W              L"a9d1ca15768811d1aded00c04fd8d5cd"
#define GUID_COMPUTRS_CONTAINER_W           L"aa312825768811d1aded00c04fd8d5cd"
#define GUID_SYSTEMS_CONTAINER_W            L"ab1d30f3768811d1aded00c04fd8d5cd"
#define GUID_DOMAIN_CONTROLLERS_CONTAINER_W L"a361b2ffffd211d1aa4b00c04fd7d83a"
#define GUID_INFRASTRUCTURE_CONTAINER_W     L"2fbac1870ade11d297c400c04fd8d5cd"
#define GUID_DELETED_OBJECTS_CONTAINER_W    L"18e2ea80684f11d2b9aa00c04f79f805"
#define GUID_LOSTANDFOUND_CONTAINER_W       L"ab8153b7768811d1aded00c04fd8d5cd"

#define GUID_USERS_CONTAINER_BYTE              "\xa9\xd1\xca\x15\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_COMPUTRS_CONTAINER_BYTE           "\xaa\x31\x28\x25\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_SYSTEMS_CONTAINER_BYTE            "\xab\x1d\x30\xf3\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_DOMAIN_CONTROLLERS_CONTAINER_BYTE "\xa3\x61\xb2\xff\xff\xd2\x11\xd1\xaa\x4b\x00\xc0\x4f\xd7\xd8\x3a"
#define GUID_INFRASTRUCTURE_CONTAINER_BYTE     "\x2f\xba\xc1\x87\x0a\xde\x11\xd2\x97\xc4\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_DELETED_OBJECTS_CONTAINER_BYTE    "\x18\xe2\xea\x80\x68\x4f\x11\xd2\xb9\xaa\x00\xc0\x4f\x79\xf8\x05"
#define GUID_LOSTANDFOUND_CONTAINER_BYTE       "\xab\x81\x53\xb7\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Prototypes                                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// DSBind takes two optional input parameters which identify whether the
// caller found a domain controller themselves via DsGetDcName or whether
// a domain controller should be found using default parameters.
// Behavior of the possible combinations are outlined below.
//
// DomainControllerName(value), DnsDomainName(NULL)
//
//      The value for DomainControllerName is assumed to have been
//      obtained via DsGetDcName (i.e. Field with the same name in a
//      DOMAIN_CONTROLLER_INFO struct on return from DsGetDcName call.)
//      The client is bound to the domain controller at this name.
//      
//      Mutual authentication will be performed using an SPN of
//      LDAP/DomainControllerName provided DomainControllerName
//      is not a NETBIOS name or IP address - i.e. it must be a 
//      DNS host name.
//
// DomainControllerName(value), DnsDomainName(value)
//
//      DsBind will connect to the server identified by DomainControllerName.
//
//      Mutual authentication will be performed using an SPN of
//      LDAP/DomainControllerName/DnsDomainName provided neither value
//      is a NETBIOS names or IP address - i.e. they must be
//      valid DNS names.
//
// DomainControllerName(NULL), DnsDomainName(NULL)
//
//      DsBind will attempt to find to a global catalog and fail if one
//      can not be found.  
//
//      Mutual authentication will be performed using an SPN of
//      GC/DnsHostName/ForestName where DnsHostName and ForestName
//      represent the DomainControllerName and DnsForestName fields
//      respectively of the DOMAIN_CONTROLLER_INFO returned by the
//      DsGetDcName call used to find a global catalog.
//
// DomainControllerName(NULL), DnsDomainName(value)
//
//      DsBind will attempt to find a domain controller for the domain
//      identified by DnsDomainName and fail if one can not be found.
//
//      Mutual authentication will be performed using an SPN of
//      LDAP/DnsHostName/DnsDomainName where DnsDomainName is that
//      provided by the caller and DnsHostName is that returned by
//      DsGetDcName for the domain specified - provided DnsDomainName
//      is a valid DNS domain name - i.e. not a NETBIOS domain name.

NTDSAPI
DWORD
WINAPI
DsBindW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    HANDLE          *phDS);

NTDSAPI
DWORD
WINAPI
DsBindA(
    LPCSTR          DomainControllerName,      // in, optional
    LPCSTR          DnsDomainName,             // in, optional
    HANDLE          *phDS);

#ifdef UNICODE
#define DsBind DsBindW
#else
#define DsBind DsBindA
#endif

NTDSAPI
DWORD
WINAPI
DsBindWithCredW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    HANDLE          *phDS);

NTDSAPI
DWORD
WINAPI
DsBindWithCredA(
    LPCSTR          DomainControllerName,      // in, optional
    LPCSTR          DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,      // in, optional
    HANDLE          *phDS);

#ifdef UNICODE
#define DsBindWithCred DsBindWithCredW
#else
#define DsBindWithCred DsBindWithCredA
#endif

//
// DsUnBind
//

NTDSAPI
DWORD
WINAPI
DsUnBindW(
    HANDLE          *phDS);             // in

NTDSAPI
DWORD
WINAPI
DsUnBindA(
    HANDLE          *phDS);             // in

#ifdef UNICODE
#define DsUnBind DsUnBindW
#else
#define DsUnBind DsUnBindA
#endif

//
// DsMakePasswordCredentials
//
// This function constructs a credential structure which is suitable for input
// to the DsBindWithCredentials function, or the ldap_open function (winldap.h)
// The credential must be freed using DsFreeCredential.
//
// None of the input parameters may be present indicating a null, default
// credential.  Otherwise the username must be present.  If the domain or
// password are null, they default to empty strings.  The domain name may be
// null when the username is fully qualified, for example UPN format.
//

NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsW(
    LPWSTR User,
    LPWSTR Domain,
    LPWSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    );

NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsA(
    LPSTR User,
    LPSTR Domain,
    LPSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    );

#ifdef UNICODE
#define DsMakePasswordCredentials DsMakePasswordCredentialsW
#else
#define DsMakePasswordCredentials DsMakePasswordCredentialsA
#endif

NTDSAPI
VOID
WINAPI
DsFreePasswordCredentials(
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity
    );

#define DsFreePasswordCredentialsW DsFreePasswordCredentials
#define DsFreePasswordCredentialsA DsFreePasswordCredentials

//
// DsCrackNames
//

NTDSAPI
DWORD
WINAPI
DsCrackNamesW(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult);         // out

NTDSAPI
DWORD
WINAPI
DsCrackNamesA(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCSTR        *rpNames,           // in
    PDS_NAME_RESULTA    *ppResult);         // out

#ifdef UNICODE
#define DsCrackNames DsCrackNamesW
#else
#define DsCrackNames DsCrackNamesA
#endif

//
// DsFreeNameResult
//

NTDSAPI
void
WINAPI
DsFreeNameResultW(
    DS_NAME_RESULTW *pResult);          // in

NTDSAPI
void
WINAPI
DsFreeNameResultA(
    DS_NAME_RESULTA *pResult);          // in

#ifdef UNICODE
#define DsFreeNameResult DsFreeNameResultW
#else
#define DsFreeNameResult DsFreeNameResultA
#endif

// ==========================================================
// DSMakeSpn -- client call to create SPN for a service to which it wants to
// authenticate.
// This name is then passed to "pszTargetName" of InitializeSecurityContext().
//
// Notes:
// If the service name is a DNS host name, or canonical DNS service name
// e.g. "www.ms.com", i.e., caller resolved with gethostbyname, then instance
// name should be NULL.
// Realm is host name minus first component, unless it is in the exception list
//
// If the service name is NetBIOS machine name, then instance name should be
// NULL
// Form must be <domain>\<machine>
// Realm will be <domain>
//
// If the service name is that of a replicated service, where each replica has
// its own account (e.g., with SRV records) then the caller must supply the
// instance name then realm name is same as ServiceName
//
// If the service name is a DN, then must also supply instance name
// (DN could be name of service object (incl RPC or Winsock), name of machine
// account, name of domain object)
// then realm name is domain part of the DN
//
// If the service name is NetBIOS domain name, then must also supply instance
// name; realm name is domain name
//
// If the service is named by an IP address -- then use referring service name
// as service name
//
//  ServiceClass - e.g. "http", "ftp", "ldap", GUID
//  ServiceName - DNS or DN; assumes we can compute domain from service name
//  InstanceName OPTIONAL- DNS name of host for instance of service
//  InstancePort - port number for instance (0 if default)
//  Referrer OPTIONAL- DNS name of host that gave this referral
//  pcSpnLength - in -- max length IN CHARACTERS of principal name;
//                out -- actual
//                Length includes terminator
//  pszSPN - server principal name
//
// If buffer is not large enough, ERROR_BUFFER_OVERFLOW is returned and the
// needed length is returned in pcSpnLength.
//
//

NTDSAPI
DWORD
WINAPI
DsMakeSpnW(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN LPCWSTR InstanceName,
    IN USHORT InstancePort,
    IN LPCWSTR Referrer,
    IN OUT DWORD *pcSpnLength,
    OUT LPWSTR pszSpn
);

NTDSAPI
DWORD
WINAPI
DsMakeSpnA(
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN LPCSTR InstanceName,
    IN USHORT InstancePort,
    IN LPCSTR Referrer,
    IN OUT DWORD *pcSpnLength,
    OUT LPSTR pszSpn
);

#ifdef UNICODE
#define DsMakeSpn DsMakeSpnW
#else
#define DsMakeSpn DsMakeSpnA
#endif

// ==========================================================
// DsGetSPN -- server's call to gets SPNs for a service name by which it is
// known to clients. N.B.: there may be more than one name by which clients
// know it the SPNs are then passed to DsAddAccountSpn to register them in
// the DS
//
//      IN SpnNameType eType,
//      IN LPCTSTR ServiceClass,
// kind of service -- "http", "ldap", "ftp", etc.
//      IN LPCTSTR ServiceName OPTIONAL,
// name of service -- DN or DNS; not needed for host-based
//      IN USHORT InstancePort,
// port number (0 => default) for instances
//      IN USHORT cInstanceNames,
// count of extra instance names and ports (0=>use gethostbyname)
//      IN LPCTSTR InstanceNames[] OPTIONAL,
// extra instance names (not used for host names)
//      IN USHORT InstancePorts[] OPTIONAL,
// extra instance ports (0 => default)
//      IN OUT PULONG pcSpn,    // count of SPNs
//      IN OUT LPTSTR * prpszSPN[]
// a bunch of SPNs for this service; free with DsFreeSpnArray

NTDSAPI
DWORD
WINAPI
DsGetSpnA(
    IN DS_SPN_NAME_TYPE ServiceType,
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN USHORT InstancePort,
    IN USHORT cInstanceNames,
    IN LPCSTR *pInstanceNames,
    IN const USHORT *pInstancePorts,
    OUT DWORD *pcSpn,
    OUT LPSTR **prpszSpn
    );

NTDSAPI
DWORD
WINAPI
DsGetSpnW(
    IN DS_SPN_NAME_TYPE ServiceType,
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN USHORT InstancePort,
    IN USHORT cInstanceNames,
    IN LPCWSTR *pInstanceNames,
    IN const USHORT *pInstancePorts,
    OUT DWORD *pcSpn,
    OUT LPWSTR **prpszSpn
    );

#ifdef UNICODE
#define DsGetSpn DsGetSpnW
#else
#define DsGetSpn DsGetSpnA
#endif

// ==========================================================
// DsFreeSpnArray() -- Free array returned by DsGetSpn{A,W}

NTDSAPI
void
WINAPI
DsFreeSpnArrayA(
    IN DWORD cSpn,
    IN OUT LPSTR *rpszSpn
    );

NTDSAPI
void
WINAPI
DsFreeSpnArrayW(
    IN DWORD cSpn,
    IN OUT LPWSTR *rpszSpn
    );

#ifdef UNICODE
#define DsFreeSpnArray DsFreeSpnArrayW
#else
#define DsFreeSpnArray DsFreeSpnArrayA
#endif

// ==========================================================
// DsCrackSpn() -- parse an SPN into the ServiceClass,
// ServiceName, and InstanceName (and InstancePort) pieces.
// An SPN is passed in, along with a pointer to the maximum length
// for each piece and a pointer to a buffer where each piece should go.
// On exit, the maximum lengths are updated to the actual length for each piece
// and the buffer contain the appropriate piece. The InstancePort is 0 if not
// present.
//
// DWORD DsCrackSpn(
//      IN LPTSTR pszSPN,               // the SPN to parse
//      IN OUT PUSHORT pcServiceClass,  // input -- max length of ServiceClass;
//                                         output -- actual length
//      OUT LPCTSTR ServiceClass,       // the ServiceClass part of the SPN
//      IN OUT PUSHORT pcServiceName,   // input -- max length of ServiceName;
//                                         output -- actual length
//      OUT LPCTSTR ServiceName,        // the ServiceName part of the SPN
//      IN OUT PUSHORT pcInstance,      // input -- max length of ServiceClass;
//                                         output -- actual length
//      OUT LPCTSTR InstanceName,  // the InstanceName part of the SPN
//      OUT PUSHORT InstancePort          // instance port
//
// Note: lengths are in characters; all string lengths include terminators
// All arguments except pszSpn are optional.
//

NTDSAPI
DWORD
WINAPI
DsCrackSpnA(
    IN LPCSTR pszSpn,
    IN OUT LPDWORD pcServiceClass,
    OUT LPSTR ServiceClass,
    IN OUT LPDWORD pcServiceName,
    OUT LPSTR ServiceName,
    IN OUT LPDWORD pcInstanceName,
    OUT LPSTR InstanceName,
    OUT USHORT *pInstancePort
    );

NTDSAPI
DWORD
WINAPI
DsCrackSpnW(
    IN LPCWSTR pszSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPWSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPWSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pInstancePort
    );

#ifdef UNICODE
#define DsCrackSpn DsCrackSpnW
#else
#define DsCrackSpn DsCrackSpnA
#endif


// ==========================================================
// DsWriteAccountSpn -- set or add SPNs for an account object
// Usually done by service itself, or perhaps by an admin.
//
// This call is RPC'd to the DC where the account object is stored, so it can
// securely enforce policy on what SPNs are allowed on the account. Direct LDAP
// writes to the SPN property are not allowed -- all writes must come through
// this RPC call. (Reads via // LDAP are OK.)
//
// The account object can be a machine accout, or a service (user) account.
//
// If called by the service to register itself, it can most easily get
// the names by calling DsGetSpn with each of the names that
// clients can use to find the service.
//
// IN SpnWriteOp eOp,                   // set, add
// IN LPCTSTR   pszAccount,             // DN of account to which to add SPN
// IN int       cSPN,                   // count of SPNs to add to account
// IN LPCTSTR   rpszSPN[]               // SPNs to add to altSecID property

NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnA(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCSTR pszAccount,
    IN DWORD cSpn,
    IN LPCSTR *rpszSpn
    );

NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnW(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCWSTR pszAccount,
    IN DWORD cSpn,
    IN LPCWSTR *rpszSpn
    );

#ifdef UNICODE
#define DsWriteAccountSpn DsWriteAccountSpnW
#else
#define DsWriteAccountSpn DsWriteAccountSpnA
#endif

/*++

Routine Description:

Constructs a Service Principal Name suitable to identify the desired server.
The service class and part of a dns hostname must be supplied.

This routine is a simplified wrapper to DsMakeSpn.
The ServiceName is made canonical by resolving through DNS.
Guid-based dns names are not supported.

The simplified SPN constructed looks like this:

ServiceClass / ServiceName / ServiceName

The instance name portion (2nd position) is always defaulted.  The port and
referrer fields are not used.

Arguments:

    ServiceClass - Class of service, defined by the service, can be any
        string unique to the service

    ServiceName - dns hostname, fully qualified or not
       Stringized IP address is also resolved if necessary

    pcSpnLength - IN, maximum length of buffer, in chars
                  OUT, space utilized, in chars, including terminator

    pszSpn - Buffer, atleast of length *pcSpnLength

Return Value:

    WINAPI - Win32 error code

--*/

NTDSAPI
DWORD
WINAPI
DsClientMakeSpnForTargetServerW(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN OUT DWORD *pcSpnLength,
    OUT LPWSTR pszSpn
    );

NTDSAPI
DWORD
WINAPI
DsClientMakeSpnForTargetServerA(
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN OUT DWORD *pcSpnLength,
    OUT LPSTR pszSpn
    );

#ifdef UNICODE
#define DsClientMakeSpnForTargetServer DsClientMakeSpnForTargetServerW
#else
#define DsClientMakeSpnForTargetServer DsClientMakeSpnForTargetServerA
#endif

/*++

Routine Description:

Register Service Principal Names for a server application.

This routine does the following:
1. Enumerates a list of server SPNs using DsGetSpn and the provided class
2. Determines the domain of the current user context
3. Determines the DN of the current user context if not supplied
4. Locates a domain controller
5. Binds to the domain controller
6. Uses DsWriteAccountSpn to write the SPNs on the named object DN
7. Unbinds

Construct server SPNs for this service, and write them to the right object.

If the userObjectDn is specified, the SPN is written to that object.

Otherwise the Dn is defaulted, to the user object, then computer.

Now, bind to the DS, and register the name on the object for the
user this service is running as.  So, if we're running as local
system, we'll register it on the computer object itself.  If we're
running as a domain user, we'll add the SPN to the user's object.

Arguments:

    Operation - What should be done with the values: add, replace or delete
    ServiceClass - Unique string identifying service
    UserObjectDN - Optional, dn of object to write SPN to

Return Value:

    WINAPI - Win32 error code

--*/

NTDSAPI
DWORD
WINAPI
DsServerRegisterSpnA(
    IN DS_SPN_WRITE_OP Operation,
    IN LPCSTR ServiceClass,
    IN LPCSTR UserObjectDN
    );

NTDSAPI
DWORD
WINAPI
DsServerRegisterSpnW(
    IN DS_SPN_WRITE_OP Operation,
    IN LPCWSTR ServiceClass,
    IN LPCWSTR UserObjectDN
    );

#ifdef UNICODE
#define DsServerRegisterSpn DsServerRegisterSpnW
#else
#define DsServerRegisterSpn DsServerRegisterSpnA
#endif

// DsReplicaSync.  The server that this call is executing on is called the
// destination.  The destination's naming context will be brought up to date
// with respect to a source system.  The source system is identified by the
// uuid.  The uuid is that of the source system's "NTDS Settings" object.
// The destination system must already be configured such that the source
// system is one of the systems from which it recieves replication data
// ("replication from"). This is usually done automatically by the KCC.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC to synchronize.
//      puuidSourceDRA (SZ)
//          objectGuid of DSA with which to synchronize the replica.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more flags
//   RETURNS: WIN32 STATUS

NTDSAPI
DWORD
WINAPI
DsReplicaSyncA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG Options
    );

NTDSAPI
DWORD
WINAPI
DsReplicaSyncW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG Options
    );

#ifdef UNICODE
#define DsReplicaSync DsReplicaSyncW
#else
#define DsReplicaSync DsReplicaSyncA
#endif

// DsReplicaAdd
//
/*
Description:
   This call is executed on the destination.  It causes the destination to
   add a "replication from" reference to the indicated source system.

The source server is identified by string name, not uuid as with Sync.
The DsaSrcAddress parameter is the transport specific address of the source
DSA, usually its guid-based dns name.  The guid in the guid-based dns name is
the object-guid of that server's ntds-dsa (settings) object.

Arguments:

    pNC (IN) - NC for which to add the replica.  The NC record must exist
        locally as either an object (instantiated or not) or a reference
        phantom (i.e., a phantom with a guid).

    pSourceDsaDN (IN) - DN of the source DSA's ntdsDsa object.  Required if
        ulOptions includes DS_REPADD_ASYNCHRONOUS_REPLICA; ignored otherwise.

    pTransportDN (IN) - DN of the interSiteTransport object representing the
        transport by which to communicate with the source server.  Required if
        ulOptions includes INTERSITE_MESSAGING; ignored otherwise.

    pszSourceDsaAddress (IN) - Transport-specific address of the source DSA.

    pSchedule (IN) - Schedule by which to replicate the NC from this
        source in the future.

    ulOptions (IN) - flags
    RETURNS: WIN32 STATUS
*/

NTDSAPI
DWORD
WINAPI
DsReplicaAddA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR SourceDsaDn,
    IN LPCSTR TransportDn,
    IN LPCSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD Options
    );

NTDSAPI
DWORD
WINAPI
DsReplicaAddW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR SourceDsaDn,
    IN LPCWSTR TransportDn,
    IN LPCWSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD Options
    );

#ifdef UNICODE
#define DsReplicaAdd DsReplicaAddW
#else
#define DsReplicaAdd DsReplicaAddA
#endif

// DsReplicaDel
//
// The server that this call is executing on is the destination.  The call
// causes the destination to remove a "replication from" reference to the
// indicated source server.
// The source server is identified by string name, not uuid as with Sync.
// The DsaSrc parameter is the transport specific address of the source DSA,
// usually its guid-based dns name.  The guid in the guid-based dns name is
// the object-guid of that server's ntds-dsa (settings) object.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC for which to delete a source.
//      pszSourceDRA (SZ)
//          DSA for which to delete the source.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more flags
//   RETURNS: WIN32 STATUS

NTDSAPI
DWORD
WINAPI
DsReplicaDelA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR DsaSrc,
    IN ULONG Options
    );

NTDSAPI
DWORD
WINAPI
DsReplicaDelW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR DsaSrc,
    IN ULONG Options
    );

#ifdef UNICODE
#define DsReplicaDel DsReplicaDelW
#else
#define DsReplicaDel DsReplicaDelA
#endif

// DsReplicaModify
//
//
//  Modify a source for a given naming context
//
//  The value must already exist.
//
//  Either the UUID or the address may be used to identify the current value.
//  If a UUID is specified, the UUID will be used for comparison.  Otherwise,
//  the address will be used for comparison.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC for which the Reps-From should be modified.
//      puuidSourceDRA (UUID *)
//          Invocation-ID of the referenced DRA.  May be NULL if:
//            . ulModifyFields does not include DS_REPMOD_UPDATE_ADDRESS and
//            . pmtxSourceDRA is non-NULL.
//      puuidTransportObj (UUID *)
//          objectGuid of the transport by which replication is to be performed
//          Ignored if ulModifyFields does not include
//          DS_REPMOD_UPDATE_TRANSPORT.
//      pszSourceDRA (SZ)
//          DSA for which the reference should be added or deleted.  Ignored if
//          puuidSourceDRA is non-NULL and ulModifyFields does not include
//          DS_REPMOD_UPDATE_ADDRESS.
//      prtSchedule (REPLTIMES *)
//          Periodic replication schedule for this replica.  Ignored if
//          ulModifyFields does not include DS_REPMOD_UPDATE_SCHEDULE.
//      ulReplicaFlags (ULONG)
//          Flags to set for this replica.  Ignored if ulModifyFields does not
//          include DS_REPMOD_UPDATE_FLAGS.
//      ulModifyFields (ULONG)
//          Fields to update.  One or more of the following bit flags:
//              UPDATE_ADDRESS
//                  Update the MTX_ADDR associated with the referenced server.
//              UPDATE_SCHEDULE
//                  Update the periodic replication schedule associated with
//                  the replica.
//              UPDATE_FLAGS
//                  Update the flags associated with the replica.
//              UPDATE_TRANSPORT
//                  Update the transport associated with the replica.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more of the following:
//              DS_REPMOD_ASYNCHRONOUS_OPERATION
//                  Perform this operation asynchronously.
//   RETURNS: WIN32 STATUS

NTDSAPI
DWORD
WINAPI
DsReplicaModifyA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidSourceDsa,
    IN LPCSTR TransportDn,
    IN LPCSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD ReplicaFlags,
    IN DWORD ModifyFields,
    IN DWORD Options
    );

NTDSAPI
DWORD
WINAPI
DsReplicaModifyW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidSourceDsa,
    IN LPCWSTR TransportDn,
    IN LPCWSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD ReplicaFlags,
    IN DWORD ModifyFields,
    IN DWORD Options
    );

#ifdef UNICODE
#define DsReplicaModify DsReplicaModifyW
#else
#define DsReplicaModify DsReplicaModifyA
#endif

// DsReplicaUpdateRefs
//
// In this case, the RPC is being executed on the "source" of destination-sourc
// replication relationship.  This function tells the source that it no longer
// supplies replication information to the indicated destination system.
// Add or remove a target server from the Reps-To property on the given NC.
// Add/remove a reference given the DSNAME of the corresponding NTDS-DSA
// object.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC for which the Reps-To should be modified.
//      DsaDest (SZ)
//          Network address of DSA for which the reference should be added
//          or deleted.
//      pUuidDsaDest (UUID *)
//          Invocation-ID of DSA for which the reference should be added
//          or deleted.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more of the following:
//              DS_REPUPD_ASYNC_OP
//                  Perform this operation asynchronously.
//              DS_REPUPD_ADD_REFERENCE
//                  Add the given server to the Reps-To property.
//              DS_REPUPD_DEL_REFERENCE
//                  Remove the given server from the Reps-To property.
//          Note that ADD_REF and DEL_REF may be paired to perform
//          "add or update".
//
//   RETURNS: WIN32 STATUS

NTDSAPI
DWORD
WINAPI
DsReplicaUpdateRefsA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR DsaDest,
    IN const UUID *pUuidDsaDest,
    IN ULONG Options
    );

NTDSAPI
DWORD
WINAPI
DsReplicaUpdateRefsW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR DsaDest,
    IN const UUID *pUuidDsaDest,
    IN ULONG Options
    );

#ifdef UNICODE
#define DsReplicaUpdateRefs DsReplicaUpdateRefsW
#else
#define DsReplicaUpdateRefs DsReplicaUpdateRefsA
#endif

// Friends of DsReplicaSyncAll

typedef enum {

	DS_REPSYNCALL_WIN32_ERROR_CONTACTING_SERVER	= 0,
	DS_REPSYNCALL_WIN32_ERROR_REPLICATING		= 1,
	DS_REPSYNCALL_SERVER_UNREACHABLE		= 2

} DS_REPSYNCALL_ERROR;

typedef enum {

	DS_REPSYNCALL_EVENT_ERROR			= 0,
	DS_REPSYNCALL_EVENT_SYNC_STARTED		= 1,
	DS_REPSYNCALL_EVENT_SYNC_COMPLETED		= 2,
	DS_REPSYNCALL_EVENT_FINISHED			= 3

} DS_REPSYNCALL_EVENT;

// Friends of DsReplicaSyncAll

typedef struct {
    LPSTR			pszSrcId;
    LPSTR			pszDstId;
    LPSTR                       pszNC;
    GUID *                      pguidSrc;
    GUID *                      pguidDst;
} DS_REPSYNCALL_SYNCA, * PDS_REPSYNCALL_SYNCA;

typedef struct {
    LPWSTR			pszSrcId;
    LPWSTR			pszDstId;
    LPWSTR                      pszNC;
    GUID *                      pguidSrc;
    GUID *                      pguidDst;
} DS_REPSYNCALL_SYNCW, * PDS_REPSYNCALL_SYNCW;

typedef struct {
    LPSTR			pszSvrId;
    DS_REPSYNCALL_ERROR		error;
    DWORD			dwWin32Err;
    LPSTR			pszSrcId;
} DS_REPSYNCALL_ERRINFOA, * PDS_REPSYNCALL_ERRINFOA;

typedef struct {
    LPWSTR			pszSvrId;
    DS_REPSYNCALL_ERROR		error;
    DWORD			dwWin32Err;
    LPWSTR			pszSrcId;
} DS_REPSYNCALL_ERRINFOW, * PDS_REPSYNCALL_ERRINFOW;

typedef struct {
    DS_REPSYNCALL_EVENT		event;
    DS_REPSYNCALL_ERRINFOA *	pErrInfo;
    DS_REPSYNCALL_SYNCA *	pSync;
} DS_REPSYNCALL_UPDATEA, * PDS_REPSYNCALL_UPDATEA;

typedef struct {
    DS_REPSYNCALL_EVENT		event;
    DS_REPSYNCALL_ERRINFOW *	pErrInfo;
    DS_REPSYNCALL_SYNCW *	pSync;
} DS_REPSYNCALL_UPDATEW, * PDS_REPSYNCALL_UPDATEW;

#ifdef UNICODE
#define DS_REPSYNCALL_SYNC DS_REPSYNCALL_SYNCW
#define DS_REPSYNCALL_ERRINFO DS_REPSYNCALL_ERRINFOW
#define DS_REPSYNCALL_UPDATE DS_REPSYNCALL_UPDATEW
#define PDS_REPSYNCALL_SYNC PDS_REPSYNCALL_SYNCW
#define PDS_REPSYNCALL_ERRINFO PDS_REPSYNCALL_ERRINFOW
#define PDS_REPSYNCALL_UPDATE PDS_REPSYNCALL_UPDATEW
#else
#define DS_REPSYNCALL_SYNC DS_REPSYNCALL_SYNCA
#define DS_REPSYNCALL_ERRINFO DS_REPSYNCALL_ERRINFOA
#define DS_REPSYNCALL_UPDATE DS_REPSYNCALL_UPDATEA
#define PDS_REPSYNCALL_SYNC PDS_REPSYNCALL_SYNCA
#define PDS_REPSYNCALL_ERRINFO PDS_REPSYNCALL_ERRINFOA
#define PDS_REPSYNCALL_UPDATE PDS_REPSYNCALL_UPDATEA
#endif

// **********************
// Replica SyncAll flags
// **********************

// This option has no effect.
#define DS_REPSYNCALL_NO_OPTIONS			0x00000000

// Ordinarily, if a server cannot be contacted, DsReplicaSyncAll tries to
// route around it and replicate from as many servers as possible.  Enabling
// this option will cause DsReplicaSyncAll to generate a fatal error if any
// server cannot be contacted, or if any server is unreachable (due to a
// disconnected or broken topology.)
#define	DS_REPSYNCALL_ABORT_IF_SERVER_UNAVAILABLE	0x00000001

// This option disables transitive replication; syncs will only be performed
// with adjacent servers and no DsBind calls will be made.
#define DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY	0x00000002

// Ordinarily, when DsReplicaSyncAll encounters a non-fatal error, it returns
// the GUID DNS of the relevant server(s).  Enabling this option causes
// DsReplicaSyncAll to return the servers' DNs instead.
#define DS_REPSYNCALL_ID_SERVERS_BY_DN			0x00000004

// This option disables all syncing.  The topology will still be analyzed and
// unavailable / unreachable servers will still be identified.
#define DS_REPSYNCALL_DO_NOT_SYNC			0x00000008

// Ordinarily, DsReplicaSyncAll attempts to bind to all servers before
// generating the topology.  If a server cannot be contacted, DsReplicaSyncAll
// excludes that server from the topology and tries to route around it.  If
// this option is enabled, checking will be bypassed and DsReplicaSyncAll will
// assume all servers are responding.  This will speed operation of
// DsReplicaSyncAll, but if some servers are not responding, some transitive
// replications may be blocked.
#define DS_REPSYNCALL_SKIP_INITIAL_CHECK		0x00000010

// Push mode. Push changes from the home server out to all partners using
// transitive replication.  This reverses the direction of replication, and
// the order of execution of the replication sets from the usual "pulling"
// mode of execution.
#define DS_REPSYNCALL_PUSH_CHANGES_OUTWARD              0x00000020

// Cross site boundaries.  By default, the only servers that are considered are
// those in the same site as the home system.  With this option, all servers in
// the enterprise, across all sites, are eligible.  They must be connected by
// a synchronous (RPC) transport, however.
#define DS_REPSYNCALL_CROSS_SITE_BOUNDARIES             0x00000040

// DsReplicaSyncAll.  Syncs the destination server with all other servers
// in the site.
//
//  PARAMETERS:
//	hDS		(IN) - A DS connection bound to the destination server.
//	pszNameContext	(IN) - The naming context to synchronize
//	ulFlags		(IN) - Bitwise OR of zero or more flags
//	pFnCallBack	(IN, OPTIONAL) - Callback function for message-passing.
//	pCallbackData	(IN, OPTIONAL) - A pointer that will be passed to the
//				first argument of the callback function.
//	pErrors		(OUT, OPTIONAL) - Pointer to a (PDS_REPSYNCALL_ERRINFO *)
//				object that will hold an array of error structures.

NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllA (
    HANDLE				hDS,
    LPCSTR				pszNameContext,
    ULONG				ulFlags,
    BOOL (__stdcall *			pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID				pCallbackData,
    PDS_REPSYNCALL_ERRINFOA **		pErrors
    );

NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllW (
    HANDLE				hDS,
    LPCWSTR				pszNameContext,
    ULONG				ulFlags,
    BOOL (__stdcall *			pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    LPVOID				pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **		pErrors
    );

#ifdef UNICODE
#define DsReplicaSyncAll DsReplicaSyncAllW
#else
#define DsReplicaSyncAll DsReplicaSyncAllA
#endif

NTDSAPI
DWORD
WINAPI
DsRemoveDsServerW(
    HANDLE  hDs,             // in
    LPWSTR  ServerDN,        // in
    LPWSTR  DomainDN,        // in,  optional
    BOOL   *fLastDcInDomain, // out, optional
    BOOL    fCommit          // in
    );

NTDSAPI
DWORD
WINAPI
DsRemoveDsServerA(
    HANDLE  hDs,              // in
    LPSTR   ServerDN,         // in
    LPSTR   DomainDN,         // in,  optional
    BOOL   *fLastDcInDomain,  // out, optional
    BOOL    fCommit           // in
    );

#ifdef UNICODE
#define DsRemoveDsServer DsRemoveDsServerW
#else
#define DsRemoveDsServer DsRemoveDsServerA
#endif

NTDSAPI
DWORD
WINAPI
DsRemoveDsDomainW(
    HANDLE  hDs,               // in
    LPWSTR  DomainDN           // in
    );

NTDSAPI
DWORD
WINAPI
DsRemoveDsDomainA(
    HANDLE  hDs,               // in
    LPSTR   DomainDN           // in
    );

#ifdef UNICODE
#define DsRemoveDsDomain DsRemoveDsDomainW
#else
#define DsRemoveDsDomain DsRemoveDsDomainA
#endif

NTDSAPI
DWORD
WINAPI
DsListSitesA(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTA    *ppSites);      // out

NTDSAPI
DWORD
WINAPI
DsListSitesW(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTW    *ppSites);      // out

#ifdef UNICODE
#define DsListSites DsListSitesW
#else
#define DsListSites DsListSitesA
#endif

NTDSAPI
DWORD
WINAPI
DsListServersInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppServers);    // out

NTDSAPI
DWORD
WINAPI
DsListServersInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppServers);    // out

#ifdef UNICODE
#define DsListServersInSite DsListServersInSiteW
#else
#define DsListServersInSite DsListServersInSiteA
#endif

NTDSAPI
DWORD
WINAPI
DsListDomainsInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppDomains);    // out

NTDSAPI
DWORD
WINAPI
DsListDomainsInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppDomains);    // out

#ifdef UNICODE
#define DsListDomainsInSite DsListDomainsInSiteW
#else
#define DsListDomainsInSite DsListDomainsInSiteA
#endif

NTDSAPI
DWORD
WINAPI
DsListServersForDomainInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              domain,         // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppServers);    // out

NTDSAPI
DWORD
WINAPI
DsListServersForDomainInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             domain,         // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppServers);    // out

#ifdef UNICODE
#define DsListServersForDomainInSite DsListServersForDomainInSiteW
#else
#define DsListServersForDomainInSite DsListServersForDomainInSiteA
#endif

// Define indices for DsListInfoForServer return data.  Check status
// for each field as a given value may not be present.

#define DS_LIST_DSA_OBJECT_FOR_SERVER       0
#define DS_LIST_DNS_HOST_NAME_FOR_SERVER    1
#define DS_LIST_ACCOUNT_OBJECT_FOR_SERVER   2

NTDSAPI
DWORD
WINAPI
DsListInfoForServerA(
    HANDLE              hDs,            // in
    LPCSTR              server,         // in
    PDS_NAME_RESULTA    *ppInfo);       // out

NTDSAPI
DWORD
WINAPI
DsListInfoForServerW(
    HANDLE              hDs,            // in
    LPCWSTR             server,         // in
    PDS_NAME_RESULTW    *ppInfo);       // out

#ifdef UNICODE
#define DsListInfoForServer DsListInfoForServerW
#else
#define DsListInfoForServer DsListInfoForServerA
#endif

// Define indices for DsListRoles return data.  Check status for
// each field as a given value may not be present.

#define DS_ROLE_SCHEMA_OWNER                0
#define DS_ROLE_DOMAIN_OWNER                1
#define DS_ROLE_PDC_OWNER                   2
#define DS_ROLE_RID_OWNER                   3
#define DS_ROLE_INFRASTRUCTURE_OWNER        4

NTDSAPI
DWORD
WINAPI
DsListRolesA(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTA    *ppRoles);      // out

NTDSAPI
DWORD
WINAPI
DsListRolesW(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTW    *ppRoles);      // out

#ifdef UNICODE
#define DsListRoles DsListRolesW
#else
#define DsListRoles DsListRolesA
#endif

// Definitions required for DsMapSchemaGuid routines.

#define DS_SCHEMA_GUID_NOT_FOUND            0
#define DS_SCHEMA_GUID_ATTR                 1
#define DS_SCHEMA_GUID_ATTR_SET             2
#define DS_SCHEMA_GUID_CLASS                3
#define DS_SCHEMA_GUID_CONTROL_RIGHT        4

typedef struct
{
    GUID                    guid;       // mapped GUID
    DWORD                   guidType;   // DS_SCHEMA_GUID_* value
#ifdef MIDL_PASS
    [string,unique] CHAR    *pName;     // might be NULL
#else
    LPSTR                   pName;      // might be NULL
#endif

} DS_SCHEMA_GUID_MAPA, *PDS_SCHEMA_GUID_MAPA;

typedef struct
{
    GUID                    guid;       // mapped GUID
    DWORD                   guidType;   // DS_SCHEMA_GUID_* value
#ifdef MIDL_PASS
    [string,unique] WCHAR   *pName;     // might be NULL
#else
    LPWSTR                  pName;      // might be NULL
#endif

} DS_SCHEMA_GUID_MAPW, *PDS_SCHEMA_GUID_MAPW;

NTDSAPI
DWORD
WINAPI
DsMapSchemaGuidsA(
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPA     **ppGuidMap);   // out

NTDSAPI
VOID
WINAPI
DsFreeSchemaGuidMapA(
    PDS_SCHEMA_GUID_MAPA    pGuidMap);      // in

NTDSAPI
DWORD
WINAPI
DsMapSchemaGuidsW(
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPW     **ppGuidMap);   // out

NTDSAPI
VOID
WINAPI
DsFreeSchemaGuidMapW(
    PDS_SCHEMA_GUID_MAPW    pGuidMap);      // in

#ifdef UNICODE
#define DS_SCHEMA_GUID_MAP DS_SCHEMA_GUID_MAPW
#define PDS_SCHEMA_GUID_MAP PDS_SCHEMA_GUID_MAPW
#define DsMapSchemaGuids DsMapSchemaGuidsW
#define DsFreeSchemaGuidMap DsFreeSchemaGuidMapW
#else
#define DS_SCHEMA_GUID_MAP DS_SCHEMA_GUID_MAPA
#define PDS_SCHEMA_GUID_MAP PDS_SCHEMA_GUID_MAPA
#define DsMapSchemaGuids DsMapSchemaGuidsA
#define DsFreeSchemaGuidMap DsFreeSchemaGuidMapA
#endif

typedef struct
{
#ifdef MIDL_PASS
    [string,unique] CHAR    *NetbiosName;           // might be NULL
    [string,unique] CHAR    *DnsHostName;           // might be NULL
    [string,unique] CHAR    *SiteName;              // might be NULL
    [string,unique] CHAR    *ComputerObjectName;    // might be NULL
    [string,unique] CHAR    *ServerObjectName;      // might be NULL
#else
    LPSTR                   NetbiosName;            // might be NULL
    LPSTR                   DnsHostName;            // might be NULL
    LPSTR                   SiteName;               // might be NULL
    LPSTR                   ComputerObjectName;     // might be NULL
    LPSTR                   ServerObjectName;       // might be NULL
#endif
    BOOL                    fIsPdc;
    BOOL                    fDsEnabled;

} DS_DOMAIN_CONTROLLER_INFO_1A, *PDS_DOMAIN_CONTROLLER_INFO_1A;

typedef struct
{
#ifdef MIDL_PASS
    [string,unique] WCHAR   *NetbiosName;           // might be NULL
    [string,unique] WCHAR   *DnsHostName;           // might be NULL
    [string,unique] WCHAR   *SiteName;              // might be NULL
    [string,unique] WCHAR   *ComputerObjectName;    // might be NULL
    [string,unique] WCHAR   *ServerObjectName;      // might be NULL
#else
    LPWSTR                  NetbiosName;            // might be NULL
    LPWSTR                  DnsHostName;            // might be NULL
    LPWSTR                  SiteName;               // might be NULL
    LPWSTR                  ComputerObjectName;     // might be NULL
    LPWSTR                  ServerObjectName;       // might be NULL
#endif
    BOOL                    fIsPdc;
    BOOL                    fDsEnabled;

} DS_DOMAIN_CONTROLLER_INFO_1W, *PDS_DOMAIN_CONTROLLER_INFO_1W;

typedef struct
{
#ifdef MIDL_PASS
    [string,unique] CHAR    *NetbiosName;           // might be NULL
    [string,unique] CHAR    *DnsHostName;           // might be NULL
    [string,unique] CHAR    *SiteName;              // might be NULL
    [string,unique] CHAR    *SiteObjectName;        // might be NULL
    [string,unique] CHAR    *ComputerObjectName;    // might be NULL
    [string,unique] CHAR    *ServerObjectName;      // might be NULL
    [string,unique] CHAR    *NtdsDsaObjectName;     // might be NULL
#else
    LPSTR                   NetbiosName;            // might be NULL
    LPSTR                   DnsHostName;            // might be NULL
    LPSTR                   SiteName;               // might be NULL
    LPSTR                   SiteObjectName;         // might be NULL
    LPSTR                   ComputerObjectName;     // might be NULL
    LPSTR                   ServerObjectName;       // might be NULL
    LPSTR                   NtdsDsaObjectName;      // might be NULL
#endif
    BOOL                    fIsPdc;
    BOOL                    fDsEnabled;
    BOOL                    fIsGc;

    // Valid iff SiteObjectName non-NULL.
    GUID                    SiteObjectGuid;
    // Valid iff ComputerObjectName non-NULL.
    GUID                    ComputerObjectGuid;
    // Valid iff ServerObjectName non-NULL;
    GUID                    ServerObjectGuid;
    // Valid iff fDsEnabled is TRUE.
    GUID                    NtdsDsaObjectGuid;

} DS_DOMAIN_CONTROLLER_INFO_2A, *PDS_DOMAIN_CONTROLLER_INFO_2A;

typedef struct
{
#ifdef MIDL_PASS
    [string,unique] WCHAR   *NetbiosName;           // might be NULL
    [string,unique] WCHAR   *DnsHostName;           // might be NULL
    [string,unique] WCHAR   *SiteName;              // might be NULL
    [string,unique] WCHAR   *SiteObjectName;        // might be NULL
    [string,unique] WCHAR   *ComputerObjectName;    // might be NULL
    [string,unique] WCHAR   *ServerObjectName;      // might be NULL
    [string,unique] WCHAR   *NtdsDsaObjectName;     // might be NULL
#else
    LPWSTR                  NetbiosName;            // might be NULL
    LPWSTR                  DnsHostName;            // might be NULL
    LPWSTR                  SiteName;               // might be NULL
    LPWSTR                  SiteObjectName;         // might be NULL
    LPWSTR                  ComputerObjectName;     // might be NULL
    LPWSTR                  ServerObjectName;       // might be NULL
    LPWSTR                  NtdsDsaObjectName;      // might be NULL
#endif
    BOOL                    fIsPdc;
    BOOL                    fDsEnabled;
    BOOL                    fIsGc;

    // Valid iff SiteObjectName non-NULL.
    GUID                    SiteObjectGuid;
    // Valid iff ComputerObjectName non-NULL.
    GUID                    ComputerObjectGuid;
    // Valid iff ServerObjectName non-NULL;
    GUID                    ServerObjectGuid;
    // Valid iff fDsEnabled is TRUE.
    GUID                    NtdsDsaObjectGuid;

} DS_DOMAIN_CONTROLLER_INFO_2W, *PDS_DOMAIN_CONTROLLER_INFO_2W;

// The following APIs strictly find domain controller account objects 
// in the DS and return information associated with them.  As such, they
// may return entries which correspond to domain controllers long since
// decommissioned, etc. and there is no guarantee that there exists a 
// physical domain controller at all.  Use DsGetDcName (dsgetdc.h) to find
// live domain controllers for a domain.

NTDSAPI
DWORD
WINAPI
DsGetDomainControllerInfoA(
    HANDLE                          hDs,            // in
    LPCSTR                          DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo);      // out

NTDSAPI
DWORD
WINAPI
DsGetDomainControllerInfoW(
    HANDLE                          hDs,            // in
    LPCWSTR                         DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo);      // out

NTDSAPI
VOID
WINAPI
DsFreeDomainControllerInfoA(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo);        // in

NTDSAPI
VOID
WINAPI
DsFreeDomainControllerInfoW(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo);        // in

#ifdef UNICODE
#define DS_DOMAIN_CONTROLLER_INFO_1 DS_DOMAIN_CONTROLLER_INFO_1W
#define DS_DOMAIN_CONTROLLER_INFO_2 DS_DOMAIN_CONTROLLER_INFO_2W
#define PDS_DOMAIN_CONTROLLER_INFO_1 PDS_DOMAIN_CONTROLLER_INFO_1W
#define PDS_DOMAIN_CONTROLLER_INFO_2 PDS_DOMAIN_CONTROLLER_INFO_2W
#define DsGetDomainControllerInfo DsGetDomainControllerInfoW
#define DsFreeDomainControllerInfo DsFreeDomainControllerInfoW
#else
#define DS_DOMAIN_CONTROLLER_INFO_1 DS_DOMAIN_CONTROLLER_INFO_1A
#define DS_DOMAIN_CONTROLLER_INFO_2 DS_DOMAIN_CONTROLLER_INFO_2A
#define PDS_DOMAIN_CONTROLLER_INFO_1 PDS_DOMAIN_CONTROLLER_INFO_1A
#define PDS_DOMAIN_CONTROLLER_INFO_2 PDS_DOMAIN_CONTROLLER_INFO_2A
#define DsGetDomainControllerInfo DsGetDomainControllerInfoA
#define DsFreeDomainControllerInfo DsFreeDomainControllerInfoA
#endif

// Which task should be run?
typedef enum {
    DS_KCC_TASKID_UPDATE_TOPOLOGY = 0
} DS_KCC_TASKID;

// Don't wait for completion of the task; queue it and return.
#define DS_KCC_FLAG_ASYNC_OP    (1)

NTDSAPI
DWORD
WINAPI
DsReplicaConsistencyCheck(
    HANDLE          hDS,        // in
    DS_KCC_TASKID   TaskID,     // in
    DWORD           dwFlags);   // in


typedef enum _DS_REPL_INFO_TYPE {
    DS_REPL_INFO_NEIGHBORS        = 0,  // returns DS_REPL_NEIGHBORS *
    DS_REPL_INFO_CURSORS_FOR_NC   = 1,  // returns DS_REPL_CURSORS *
    DS_REPL_INFO_METADATA_FOR_OBJ = 2,  // returns DS_REPL_OBJECT_META_DATA *
    // <- insert new DS_REPL_INFO_* types here.
    DS_REPL_INFO_TYPE_MAX
} DS_REPL_INFO_TYPE;

// Bit values for the dwReplicaFlags field of the DS_REPL_NEIGHBOR structure.
#define DS_REPL_NBR_WRITEABLE                       (0x10)
#define DS_REPL_NBR_SYNC_ON_STARTUP                 (0x20)
#define DS_REPL_NBR_DO_SCHEDULED_SYNCS              (0x40)
#define DS_REPL_NBR_USE_ASYNC_INTERSITE_TRANSPORT   (0x80)
#define DS_REPL_NBR_FULL_SYNC_IN_PROGRESS           (0x10000)
#define DS_REPL_NBR_FULL_SYNC_NEXT_PACKET           (0x20000)
#define DS_REPL_NBR_NEVER_SYNCED                    (0x200000)
#define DS_REPL_NBR_IGNORE_CHANGE_NOTIFICATIONS     (0x4000000)
#define DS_REPL_NBR_DISABLE_SCHEDULED_SYNC          (0x8000000)
#define DS_REPL_NBR_COMPRESS_CHANGES                (0x10000000)
#define DS_REPL_NBR_NO_CHANGE_NOTIFICATIONS         (0x20000000)

typedef struct _DS_REPL_NEIGHBORW {
    LPWSTR      pszNamingContext;
    LPWSTR      pszSourceDsaDN;
    LPWSTR      pszSourceDsaAddress;
    LPWSTR      pszAsyncIntersiteTransportDN;
    DWORD       dwReplicaFlags;
    DWORD       dwReserved;         // alignment

    UUID        uuidNamingContextObjGuid;
    UUID        uuidSourceDsaObjGuid;
    UUID        uuidSourceDsaInvocationID;
    UUID        uuidAsyncIntersiteTransportObjGuid;

    USN         usnLastObjChangeSynced;
    USN         usnAttributeFilter;

    FILETIME    ftimeLastSyncSuccess;
    FILETIME    ftimeLastSyncAttempt;

    DWORD       dwLastSyncResult;
    DWORD       cNumConsecutiveSyncFailures;
} DS_REPL_NEIGHBORW;

typedef struct _DS_REPL_NEIGHBORSW {
    DWORD       cNumNeighbors;
    DWORD       dwReserved;             // alignment
#ifdef MIDL_PASS
    [size_is(cNumNeighbors)] DS_REPL_NEIGHBORW rgNeighbor[];
#else
    DS_REPL_NEIGHBORW rgNeighbor[1];
#endif
} DS_REPL_NEIGHBORSW;

typedef struct _DS_REPL_CURSOR {
    UUID        uuidSourceDsaInvocationID;
    USN         usnAttributeFilter;
} DS_REPL_CURSOR;

typedef struct _DS_REPL_CURSORS {
    DWORD       cNumCursors;
    DWORD       dwReserved;             // alignment
#ifdef MIDL_PASS
    [size_is(cNumCursors)] DS_REPL_CURSOR rgCursor[];
#else
    DS_REPL_CURSOR rgCursor[1];
#endif
} DS_REPL_CURSORS;

typedef struct _DS_REPL_ATTR_META_DATA {
    LPWSTR      pszAttributeName;
    DWORD       dwVersion;
    FILETIME    ftimeLastOriginatingChange;
    UUID        uuidLastOriginatingDsaInvocationID;
    USN         usnOriginatingChange;   // in the originating DSA's USN space
    USN         usnLocalChange;         // in the local DSA's USN space
} DS_REPL_ATTR_META_DATA;

typedef struct _DS_REPL_OBJ_META_DATA {
    DWORD       cNumEntries;
    DWORD       dwReserved;             // alignment
#ifdef MIDL_PASS
    [size_is(cNumEntries)] DS_REPL_ATTR_META_DATA rgMetaData[];
#else
    DS_REPL_ATTR_META_DATA rgMetaData[1];
#endif
} DS_REPL_OBJ_META_DATA;

NTDSAPI
DWORD
WINAPI
DsReplicaGetInfoW(
    HANDLE              hDS,                        // in
    DS_REPL_INFO_TYPE   InfoType,                   // in
    LPCWSTR             pszObject,                  // in
    UUID *              puuidForSourceDsaObjGuid,   // in
    VOID **             ppInfo);                    // out

NTDSAPI
void
WINAPI
DsReplicaFreeInfo(
    DS_REPL_INFO_TYPE   InfoType,   // in
    VOID *              pInfo);     // in


#ifdef UNICODE
#define DsReplicaGetInfo    DsReplicaGetInfoW
#define DS_REPL_NEIGHBOR    DS_REPL_NEIGHBORW
#define DS_REPL_NEIGHBORS   DS_REPL_NEIGHBORSW
#else
// No ANSI equivalents currently supported.
#endif

NTDSAPI
DWORD
WINAPI
DsAddSidHistoryW(
    HANDLE                  hDS,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCWSTR                 SrcDomain,              // in - DNS or NetBIOS
    LPCWSTR                 SrcPrincipal,           // in - SAM account name
    LPCWSTR                 SrcDomainController,    // in, optional
    RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,        // in - creds for src domain
    LPCWSTR                 DstDomain,              // in - DNS or NetBIOS
    LPCWSTR                 DstPrincipal);          // in - SAM account name

NTDSAPI
DWORD
WINAPI
DsAddSidHistoryA(
    HANDLE                  hDS,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCSTR                  SrcDomain,              // in - DNS or NetBIOS
    LPCSTR                  SrcPrincipal,           // in - SAM account name
    LPCSTR                  SrcDomainController,    // in, optional
    RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,        // in - creds for src domain
    LPCSTR                  DstDomain,              // in - DNS or NetBIOS
    LPCSTR                  DstPrincipal);          // in - SAM account name

#ifdef UNICODE
#define DsAddSidHistory DsAddSidHistoryW
#else
#define DsAddSidHistory DsAddSidHistoryA
#endif

#ifdef __cplusplus
}
#endif

#endif // _NTDSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\lgtrans.cpp ===
/*---------------------------------------------------------------------------
  File: LGTranslator.cpp

  Comments: Routines to translate membership of local groups.
  Used to update local groups on member servers or in resource domains when 
  members of the groups have been moved during a domain consolidation.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 01/27/99 09:13:18

 ---------------------------------------------------------------------------
*/


#include "StdAfx.h"
#include "Common.hpp"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "Mcs.h"
#include "STArgs.hpp"
#include "SidCache.hpp"
#include "SDStat.hpp"

#include <lmaccess.h> 
#include <lmapibuf.h>

extern TErrorDct err;

// Translates the membership of a local group
DWORD                                           // ret- 0 or error code
   TranslateLocalGroup(
      WCHAR          const   * groupName,         // in - name of group to translate
      WCHAR          const   * serverName,        // in - name of server for local group
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   )
{
   API_RET_TYPE              rc,
                             rcEnum;
   
   // Get the members of the local group
   LOCALGROUP_MEMBERS_INFO_0 * member,
                             * memBuf;
   DWORD                     memRead,
                             memTotal;
//                             memTotal,
//                             resume = 0;
   DWORD_PTR                 resume = 0;
   TAcctNode               * node;
   BOOL						 bUseMapFile = stArgs->UsingMapFile();

   
   // make a list of the group's members 
   do 
   { 
      rcEnum = NetLocalGroupGetMembers( serverName, 
                                     groupName, 
                                     0, 
                                     (LPBYTE *)&memBuf, 
                                     BUFSIZE, 
                                     &memRead, 
                                     &memTotal, 
                                     &resume );
      if ( rcEnum != ERROR_SUCCESS && rcEnum != ERROR_MORE_DATA )
         break;
      for ( member = memBuf;  member < memBuf + memRead;  member++ )
      {
         rc = 0;
         stat->IncrementExamined(groupmember);
		 if (!bUseMapFile)
            node = cache->Lookup(member->lgrmi0_sid);
		 else
            node = cache->LookupWODomain(member->lgrmi0_sid);
         if ( node == (TAcctNode*)-1 )
         {
            node = NULL;     
         }
         if ( node && node->IsValidOnTgt() )
         {
            // Found the account in the cache
            // remove this member from the group and add the target member
            if ( ! stArgs->NoChange() && ( stArgs->TranslationMode() != ADD_SECURITY) )
            {
               rc = NetLocalGroupDelMembers(serverName,groupName,0,(LPBYTE)member,1);
            }
            if ( rc )
            {
               err.SysMsgWrite(ErrE,rc,DCT_MSG_MEMBER_REMOVE_FAILED_SSSD,node->GetAcctName(),groupName,serverName,rc);
               stat->IncrementSkipped(groupmember);
            }
            else
            {
               node->AddAceChange(groupmember); 
               stat->IncrementChanged(groupmember);
               PSID sid = NULL;
	           if (!bUseMapFile)
                  sid = cache->GetTgtSid(node);
	           else
                  sid = cache->GetTgtSidWODomain(node);
               if ( sid )
               {
                  if ( !stArgs->NoChange() && (stArgs->TranslationMode() != REMOVE_SECURITY) )
                  {
                     rc = NetLocalGroupAddMembers(serverName,groupName,0,(LPBYTE)&sid,1);
                  }
                  if ( rc )
                  {
                     err.SysMsgWrite(ErrE,rc,DCT_MSG_MEMBER_ADD_FAILED_SSSD,node->GetAcctName(),groupName,serverName,rc);
                  }
                  free(sid);
               }
            }
         }
      }
      NetApiBufferFree( memBuf );
   } while ( rcEnum == ERROR_MORE_DATA );
   if ( rcEnum != ERROR_SUCCESS )
   {
      err.SysMsgWrite(ErrE,rcEnum,DCT_MSG_GROUP_ENUM_FAILED_SS,groupName,serverName);
   }
   return rc;
}

DWORD  
   TranslateLocalGroups(
      WCHAR            const * serverName,        // in - name of server to translate groups on
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   )
{
   DWORD                       rc = 0;
   LOCALGROUP_INFO_0         * buf,
                             * groupInfo;
   DWORD                       numRead,
//                               numTotal,
//                               resume=0;
                               numTotal;
   DWORD_PTR                   resume=0;
   WCHAR                       currName[LEN_Computer + LEN_Group];

         
   // Get a list of all the local groups
   do 
   {
      rc = NetLocalGroupEnum(serverName,0,(LPBYTE*)&buf,BUFSIZE,&numRead,&numTotal,&resume);
      
      if ( rc != ERROR_SUCCESS && rc != ERROR_MORE_DATA )
         break;
      if ( cache->IsCancelled() )
      {
         err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
         break;
      }
      for ( groupInfo = buf ; groupInfo < buf + numRead ; groupInfo++ )
      {
         swprintf(currName,L"%s\\%s",serverName,groupInfo->lgrpi0_name);
         stat->DisplayPath(currName);
         TranslateLocalGroup(groupInfo->lgrpi0_name,serverName,stArgs,cache,stat);
      }
      NetApiBufferFree(buf);

   } while ( rc == ERROR_MORE_DATA );
   stat->DisplayPath(L"");
   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\exldap.h ===
#ifndef EXLDAP_H
#define EXLDAP_H

#include <winldap.h>

#include "EaLen.hpp"
#include "Common.hpp"
#include "UString.hpp"

typedef WINLDAPAPI LDAP * LDAPAPI LDAP_OPEN( PWCHAR HostName, ULONG PortNumber );
typedef WINLDAPAPI LDAP * LDAPAPI LDAP_INIT( PWCHAR HostName, ULONG PortNumber );
typedef WINLDAPAPI ULONG LDAPAPI LDAPMAPERRORTOWIN32( ULONG LdapError );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_UNBIND( LDAP *ld );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_BIND( LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method );
typedef WINLDAPAPI ULONG LDAPAPI LDAPGETLASTERROR( VOID );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_MODIFY_S( LDAP *ld, PWCHAR dn, LDAPModW *mods[] );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_MSGFREE( LDAPMessage *res );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_COUNT_ENTRIES( LDAP *ld, LDAPMessage *res );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_SEARCH_EXT_S(
        LDAP            *ld,
        PWCHAR          base,
        ULONG           scope,
        PWCHAR          filter,
        PWCHAR          attrs[],
        ULONG           attrsonly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **res
    );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_CREATE_PAGE_CONTROL(
        PLDAP           ExternalHandle,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlW  *Control
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_PARSE_PAGE_CONTROL (
        PLDAP           ExternalHandle,
        PLDAPControlW  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie     // Use ber_bvfree to free
        );
typedef WINLDAPAPI PWCHAR *LDAPAPI LDAP_GET_VALUES(
        LDAP            *ld,
        LDAPMessage     *entry,
        PWCHAR          attr
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_VALUE_FREE( PWCHAR *vals );

typedef WINLDAPAPI LDAPMessage *LDAPAPI LDAP_NEXT_ENTRY( LDAP *ld, LDAPMessage *entry );

typedef WINLDAPAPI LDAPMessage *LDAPAPI LDAP_FIRST_ENTRY( LDAP *ld, LDAPMessage *res );

typedef WINLDAPAPI VOID LDAPAPI BER_BVFREE( struct berval *bv );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_CONTROLS_FREE (
        LDAPControlW **Control
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_PARSE_RESULT (
        LDAP *Connection,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,          // returned by server
        PWCHAR *MatchedDNs OPTIONAL,         // free with ldap_memfree
        PWCHAR *ErrorMessage OPTIONAL,       // free with ldap_memfree
        PWCHAR **Referrals OPTIONAL,         // free with ldap_value_freeW
        PLDAPControlW **ServerControls OPTIONAL,    // free with ldap_free_controlsW
        BOOLEAN Freeit
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_GET_OPTION( LDAP *ld, int option, void *outvalue );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_SET_OPTION( LDAP *ld, int option, void *invalue );

class CLdapConnection
{
   WCHAR                     m_exchServer[LEN_Computer];
   LDAP                    * m_LD;
   ULONG                     m_port;
   HMODULE                   m_hDll;
   BOOL                      m_bUseSSL;
   WCHAR                     m_credentials[300];
   WCHAR                     m_password[100];
public:
   LDAP_PARSE_RESULT        * ldap_parse_result;
   LDAP_PARSE_PAGE_CONTROL  * ldap_parse_page_control;
   LDAP_CONTROLS_FREE       * ldap_controls_free;
   BER_BVFREE               * ber_bvfree;
   LDAP_FIRST_ENTRY         * ldap_first_entry;
   LDAP_NEXT_ENTRY          * ldap_next_entry;
   LDAP_VALUE_FREE          * ldap_value_free;
   LDAP_GET_VALUES          * ldap_get_values;
   LDAP_CREATE_PAGE_CONTROL * ldap_create_page_control;
   LDAP_SEARCH_EXT_S        * ldap_search_ext_s;
   LDAP_COUNT_ENTRIES       * ldap_count_entries;
   LDAP_MSGFREE             * ldap_msgfree;
   LDAP_MODIFY_S            * ldap_modify_s;
   LDAPGETLASTERROR         * LdapGetLastError;
   LDAP_BIND                * ldap_bind_sW;
   LDAP_UNBIND              * ldap_unbind;
   LDAPMAPERRORTOWIN32      * LdapMapErrorToWin32;
   LDAP_OPEN                * ldap_open;
   LDAP_GET_OPTION          * ldap_get_option;
   LDAP_SET_OPTION          * ldap_set_option;
   LDAP_INIT                * ldap_init;

public:
   CLdapConnection();
   ~CLdapConnection();

   void   SetCredentials(WCHAR const * cred,WCHAR const * pwd) { safecopy(m_credentials,cred); safecopy(m_password,pwd); }
   LDAP * GetHandle() { return m_LD; }
   DWORD  Connect(WCHAR const * server,ULONG port);
   DWORD UpdateSimpleStringValue(WCHAR const * dn, WCHAR const * property, WCHAR const * value);
   void   Close();

   BOOL StringToBytes(WCHAR const * pString,BYTE * pBytes);
   BOOL BytesToString(BYTE * pBytes,WCHAR * sidString,DWORD numBytes);
protected:
   // helper functions
   BYTE HexValue(WCHAR value);
   void AddByteToString(WCHAR ** string,BYTE value);
};


class CLdapEnum
{
   BOOL                      m_bOpen;
   ULONG                     m_nReturned;
   ULONG                     m_nCurrent;
   ULONG                     m_totalCount;
   LDAPMessage             * m_message;
   LDAPMessage             * m_currMsg;
   WCHAR                     m_query[1000];
   WCHAR                     m_basepoint[LEN_DistName];
   int                       m_scope;
   long                      m_pageSize;
   int                       m_nAttributes;
   WCHAR                  ** m_AttrNames;
public:
    CLdapConnection           m_connection;
public:
   CLdapEnum() { m_bOpen = FALSE; m_nReturned = 0; m_nCurrent = 0; m_totalCount = 0; m_message = NULL; 
                 m_query[0] = 0; m_basepoint[0] = 0; m_scope = 2; m_pageSize = 100; m_currMsg = NULL;
                 m_nAttributes = 0; m_AttrNames =NULL;}
   ~CLdapEnum();

   DWORD          InitConnection(WCHAR const * server,ULONG port) { return m_connection.Connect(server,port); }
   DWORD          Open(WCHAR const * query,WCHAR const * basePoint,short scope, long pageSize,int numAttributes,
                  WCHAR ** attrs);
   DWORD          Next(PWCHAR ** ppAttrs);
   void           FreeData(PWCHAR* pValues);
protected:

   DWORD          GetNextEntry(PWCHAR ** ppAttrs);
   DWORD          GetNextPage();

};


#endif // EXLDAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\lgtrans.h ===
DWORD                                           // ret- 0 or error code
   TranslateLocalGroup(
      WCHAR          const   * groupName,         // in - name of group to translate
      WCHAR          const   * serverName,        // in - name of server for local group
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   );

DWORD  
   TranslateLocalGroups(
      WCHAR            const * serverName,        // in - name of server to translate groups on
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\procexts.h ===
/*---------------------------------------------------------------------------
  File: ProcessExtensions.h

  Comments: interface for the CProcessExtensions class..

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#if !defined(AFX_PROCESSEXTENSIONS_H__B3C465A0_2E47_11D3_8C8E_0090270D48D1__INCLUDED_)
#define AFX_PROCESSEXTENSIONS_H__B3C465A0_2E47_11D3_8C8E_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ARExt.h"
#include "TNode.hpp"
//#import "\bin\McsVarSetMin.tlb" no_namespace
//#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#include "sdstat.hpp" //include this to get a #import of VarSet.tlb
#include "iads.h"
#include "TARNode.hpp"
#include "ExtSeq.h"

class CProcessExtensions;
struct Options;

#include "usercopy.hpp"

class CProcessExtensions  
{
public:
	CProcessExtensions(IVarSetPtr pVs);
	virtual ~CProcessExtensions();
   HRESULT Process(TAcctReplNode * pAcctNode, _bstr_t sTargetDomain, Options * pOptions,BOOL bPreMigration);
private:
   IVarSetPtr                m_pVs;
   TNodeListSortable         m_listInterface;
protected:
	void PutAccountNodeInVarset(TAcctReplNode * pNode, IADs * pTarget, IVarSet * pVS);
   void UpdateAccountNodeFromVarset(TAcctReplNode * pNode, IADs * pTarget, IVarSet * pVS);
};

class TNodeInterface : public TNode
{
   IExtendAccountMigration * m_pExt;
   long                      m_Sequence;
public:
   TNodeInterface( IExtendAccountMigration * pExt ) { m_pExt = pExt; m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER; }
   ~TNodeInterface() { m_pExt->Release(); }
   IExtendAccountMigration * GetInterface() const { return m_pExt; }
   void SetInterface( const IExtendAccountMigration * pExt ) { m_pExt = const_cast<IExtendAccountMigration *>(pExt); }
   long GetSequence() const { return m_Sequence; }
   void SetSequence(long val) { m_Sequence = val; }
};

typedef HRESULT (CALLBACK * ADSGETOBJECT)(LPWSTR, REFIID, void**);
extern ADSGETOBJECT            ADsGetObject;

#endif // !defined(AFX_PROCESSEXTENSIONS_H__B3C465A0_2E47_11D3_8C8E_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\pwdage.cpp ===
/*---------------------------------------------------------------------------
  File: ComputerPwdAge.cpp

  Comments: Implementation of COM object to retrieve password age for computer 
  accounts (used to detect defunct computer accounts.)

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:19:31

 ---------------------------------------------------------------------------
*/

// ComputerPwdAge.cpp : Implementation of CComputerPwdAge
#include "stdafx.h"
#include "WorkObj.h"
#include "PwdAge.h"
#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "CommaLog.hpp"
#include "EaLen.hpp"

//#import "\bin\McsVarSetMin.tlb" no_namespace
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace, named_guids

#include <lm.h>

/////////////////////////////////////////////////////////////////////////////
// CComputerPwdAge


STDMETHODIMP 
   CComputerPwdAge::SetDomain(
      BSTR                   domain        // in - domain name to examine
   )
{
	HRESULT                   hr = S_OK;
   DWORD                     rc;
   WCHAR                     domctrl[LEN_Computer];

   if ( UStrICmp(m_Domain,domain) )
   {
      m_Domain = domain;

      rc = GetDomainControllerForDomain(domain,domctrl);

      if ( rc )
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
      else
      {
         m_DomainCtrl = domctrl;
      }
   }
   return hr;
}

STDMETHODIMP 
   CComputerPwdAge::GetPwdAge(
      BSTR                   domain,         // in - domain name to examine
      BSTR                   ComputerName,   // in - machine name of computer                               
      DWORD                * pPwdAge         // out- password age in seconds
   )
{
   HRESULT                   hr;
   DWORD                     rc;
   WCHAR                     computerAccountName[LEN_Account];
   DWORD                     pwdage = 0;

   hr = SetDomain(domain);
   if ( SUCCEEDED(hr) )
   {
      swprintf(computerAccountName,L"%s",ComputerName);      
      rc = GetSinglePasswordAgeInternal(m_DomainCtrl,computerAccountName,&pwdage);
      if ( ! rc )
      {
         (*pPwdAge) = pwdage;
      }
      else
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
   }
   return hr;
}

STDMETHODIMP 
   CComputerPwdAge::ExportPasswordAge(
      BSTR                   domain,       // in - domain to export information from
      BSTR                   filename      // in - UNC name of file to write information to
   )
{
	HRESULT                   hr;

   hr = SetDomain(domain);
   if ( SUCCEEDED(hr) )
   {
      hr = ExportPasswordAgeOlderThan(domain,filename,0);
   }
   return hr;
}

STDMETHODIMP 
   CComputerPwdAge::ExportPasswordAgeOlderThan(
      BSTR                   domain,      // in - domain to export information from
      BSTR                   filename,    // in - filename to write information to
      DWORD                  minAge       // in - write only accounts with password age older than minAge
   )
{
	DWORD                     rc = 0;
   HRESULT                   hr; 

   hr = SetDomain(domain);
   
   if ( SUCCEEDED(hr) )
   {
      rc = ExportPasswordAgeInternal(m_DomainCtrl,filename,minAge,TRUE);
      if ( rc )
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
   }
	return hr;
}

STDMETHODIMP 
   CComputerPwdAge::ExportPasswordAgeNewerThan(
      BSTR                   domain,       // in - domain to export information from
      BSTR                   filename,     // in - filename to write information to
      DWORD                  maxAge        // in - write only computer accounts with password age less than maxAge
   )
{                                                	
   DWORD                     rc = 0;
   HRESULT                   hr; 

   hr = SetDomain(domain);
   
   if ( SUCCEEDED(hr) )
   {
      rc = ExportPasswordAgeInternal(m_DomainCtrl,filename,maxAge,FALSE);
      if ( rc )
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
   }
	return hr;

}

DWORD                                      // ret- WIN32 error code
   CComputerPwdAge::GetDomainControllerForDomain(
      WCHAR          const * domain,       // in - name of domain
      WCHAR                * domctrl       // out- domain controller for domain
   )
{
   DWORD                     rc;
   WCHAR                   * result;

   rc = NetGetDCName(NULL,domain,(LPBYTE*)&result);
   if ( ! rc )
   {
      wcscpy(domctrl,result);
      NetApiBufferFree(result);
   }
   return rc;
}

DWORD                                      // ret- WIN32 error code
   CComputerPwdAge::ExportPasswordAgeInternal(
      WCHAR          const * domctrl,      // in - domain controller to query
      WCHAR          const * filename,     // in - filename to write results to  
      DWORD                  minOrMaxAge,  // in - optional min or max age to write 
      BOOL                   bOld          // in - TRUE-Age is min age, copies only old accounts
   )
{
   DWORD                     rc = 0;
   DWORD                     nRead;
   DWORD                     nTotal;
   DWORD                     nResume = 0;
   DWORD                     prefmax = 1000;
   USER_INFO_11            * buf;
   time_t                    pwdage;  // the number of seconds ago that the pwd was last changed
   time_t                    pwdtime; // the time when the pwd was last changed
   time_t                    now;     // the current time
   CommaDelimitedLog         log;
   IIManageDBPtr             pDB;
   WCHAR                     computerName[LEN_Account];

   rc = pDB.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(rc) )
   {
   
      time(&now);
      do 
      {
         rc = NetUserEnum(domctrl,11,FILTER_WORKSTATION_TRUST_ACCOUNT,(LPBYTE*)&buf,prefmax,&nRead,&nTotal,&nResume);
         if ( rc && rc != ERROR_MORE_DATA )
            break;
         for ( UINT i = 0 ; i < nRead ; i++ )
         {
            pwdage = buf[i].usri11_password_age;
            if ( ( pwdage >= (time_t)minOrMaxAge && bOld )  // inactive machines
               ||( pwdage <= (time_t)minOrMaxAge && !bOld ) ) // active machines
            {
               safecopy(computerName,buf[i].usri11_name);
               // strip off the $ from the end of the computer account
               computerName[UStrLen(computerName)-1] = 0; 
//               pDB->raw_SavePasswordAge(m_Domain,SysAllocString(computerName),SysAllocString(buf[i].usri11_comment),pwdage);
               pDB->raw_SavePasswordAge(m_Domain,SysAllocString(computerName),SysAllocString(buf[i].usri11_comment),(long)pwdage);

               pwdtime = now - pwdage;
            }
         }
         NetApiBufferFree(buf);

      } while ( rc == ERROR_MORE_DATA );

   }
   else 
   {
      rc = GetLastError();
   }
   return rc;
}


DWORD                                      // ret- WIN32 error code
   CComputerPwdAge::GetSinglePasswordAgeInternal(
      WCHAR          const * domctrl,      // in - domain controller to query
      WCHAR          const * computer,     // in - name of computer account
      DWORD                * pwdage        // out- password age in seconds
   )
{
   DWORD                     rc = 0;
   USER_INFO_11            * buf;
   
   rc = NetUserGetInfo(domctrl,computer,11,(LPBYTE*)&buf);

   if (! rc )
   {
      (*pwdage) = buf->usri11_password_age;
      NetApiBufferFree(buf);
   }
   return rc;
}


// ComputerPwdAge worknode
// Retrieves the password age (in seconds) for a computer account in a specified domain
// This can be used to identify defunct computer accounts
// 
// VarSet syntax
// Input:
//       ComputerPasswordAge.Domain:   <DomainName>
//       ComputerPasswordAge.Computer: <ComputerName>
// Output:
//       ComputerPasswordAge.Seconds : <number>

STDMETHODIMP 
   CComputerPwdAge::Process(
      IUnknown             * pWorkItem  // in - varset containing settings
   )
{
   HRESULT                    hr = S_OK;
   IVarSetPtr                 pVarSet = pWorkItem;
   _bstr_t                    domain;
   _bstr_t                    computer;
   DWORD                      age;
   
   domain = pVarSet->get(L"ComputerPasswordAge.Domain");
   computer = pVarSet->get(L"ComputerPasswordAge.Computer");
   if ( computer.length() && domain.length() )
   {
      hr = GetPwdAge(domain,computer,&age);
      if ( SUCCEEDED(hr) )
      {
         pVarSet->put(L"ComputerPasswordAge.Seconds",(LONG)age);
      }
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\procexts.cpp ===
/*---------------------------------------------------------------------------
  File: ProcessExtensions.cpp

  Comments: implementation of the CProcessExtensions class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "workobj.h"
#include "TReg.hpp"
#include "ProcExts.h"
#include "ResStr.h"
#include "DCTStat.h"
#include "TxtSid.h"
#include "ARExt_i.c"
//#import "\bin\AdsProp.tlb" no_namespace
#import "AdsProp.tlb" no_namespace

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const _bstr_t                sKeyExtension = L"Software\\Mission Critical Software\\DomainAdmin\\Extensions";
#ifdef OFA
const _bstr_t                sKeyBase      = L"Software\\Mission Critical Software\\OnePointFileAdmin";
#else
const _bstr_t                sKeyBase      = L"Software\\Mission Critical Software\\DomainAdmin";
#endif

extern TErrorDct                    err;

// Sort function for the list of interface pointers
int TExtNodeSortBySequence(TNode const * t1, TNode const * t2)
{
   TNodeInterface    const * p1 = (TNodeInterface const *)t1;
   TNodeInterface    const * p2 = (TNodeInterface const *)t2;

   if ( p1->GetSequence() < p2->GetSequence() )
      return -1;
   else if ( p1->GetSequence() > p2->GetSequence() )
      return 1;
   else 
      return 0;
}
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
// CONSTRUCTOR : The constructor looks up all the registered COM extensions
//               from the registry. For each one it creates a com object and
//               puts it into a list as a IExtendAccountMigration *.
//---------------------------------------------------------------------------
CProcessExtensions::CProcessExtensions(
                                          IVarSetPtr pVs          //in -Pointer to the Varset with main settings.
                                      )
{
   // Store the varset that has the main settings.
   m_pVs = pVs;
   
   _variant_t                myVal;
   myVal = m_pVs->get(GET_BSTR(DCTVS_AREXT_NUMITEM));
   if ( myVal.vt != VT_I4 || myVal.lVal < 0 )
   {   
      // GUI told us to run all the Extensions.
      // Now look through the registry to get all the registered extension object ClassIDs
      // for each one create a object and store the interface pointer in an array.
      TRegKey                   key;
      TCHAR                     sName[300];    // key name
      TCHAR                     sValue[300];   // value name
      DWORD                     valuelen;     // value length
      DWORD                     type;         // value type
      DWORD                     retval = 0;   // Loop sentinel
//      DWORD                     len = 255;
      CLSID                     clsid;
      HRESULT                   hr;
      IExtendAccountMigration * pExtTemp;
      retval = 0;
   
      // Open the Extensions registry key
      DWORD rc = key.Open(sKeyExtension);
      // if no extensions then we can leave now.
      if ( rc != 0 ) return;

      valuelen = sizeof(sValue);
      // Go through all Name-Value pairs and try to create those objects
      // if successful then put it into the list to be processed.
      long ndx = 0;
      while (!retval)
      {
         retval = key.ValueEnum(ndx, sName, sizeof(sName), sValue, &valuelen, &type);
         if ( !retval )
         {
            // each name in here is a Object name for the class ID. we are going to use this to 
            // Create the object and then put the IExtendAccountRepl * in the list member0
            ::CLSIDFromProgID(sName, &clsid);
            hr = ::CoCreateInstance(clsid, NULL, CLSCTX_ALL, IID_IExtendAccountMigration, (void **) &pExtTemp);
            if ( SUCCEEDED(hr) )
            {
               TNodeInterface * pNode = new TNodeInterface(pExtTemp);
               long num;
               hr =  pExtTemp->get_SequenceNumber(&num);
               if ((pNode) && (SUCCEEDED(hr)))
               { 
                  pNode->SetSequence(num);
               }
			   if (pNode)
                  m_listInterface.InsertBottom(pNode);
            }
         }
         if ( retval == ERROR_MORE_DATA )
            retval = 0;
         ndx++;
      }
   }
   else
   {
      WCHAR                     strKey[500];
      _variant_t                var;
      CLSID                     clsid;
      HRESULT                   hr;
      IExtendAccountMigration * pExtTemp;
      for ( int i = 0; i < myVal.lVal; i++ )
      {
         // We need to look at all the extensions that are specified and then build a list of
         // interfaces to it.
   
         wsprintf(strKey, GET_STRING(DCTVS_AREXTENSIONS_D), i);
         var = pVs->get(strKey);
         if ( var.vt == VT_BSTR )
         {
            // if the key is specified and it is a String then create the object and store its Iface,
            ::CLSIDFromProgID((WCHAR*)V_BSTR(&var), &clsid);
            hr = ::CoCreateInstance(clsid, NULL, CLSCTX_ALL, IID_IExtendAccountMigration, (void **) &pExtTemp);
            if ( SUCCEEDED(hr) )
            {
               TNodeInterface * pNode = new TNodeInterface(pExtTemp);
			   if (pNode)
                  m_listInterface.InsertBottom(pNode);
            }
         }
      }
   }
   m_listInterface.Sort(&TExtNodeSortBySequence);
}

//---------------------------------------------------------------------------
// DESTRUCTOR : Clears the list of interfaces.
//---------------------------------------------------------------------------
CProcessExtensions::~CProcessExtensions()
{
   TNodeInterface * pNode;
   TNodeInterface * tempNode;

   pNode = (TNodeInterface *) m_listInterface.Head();
   while ( pNode )
   {
      tempNode = (TNodeInterface *)pNode->Next();
      delete pNode;
      pNode = tempNode;
   }
}

//---------------------------------------------------------------------------
// Process: This function is called by the account replicator for every 
//          object that is copied. This function sets up the parameters and
//          for every registered extension object it calls the Process method
//          on that extension.
//---------------------------------------------------------------------------
HRESULT CProcessExtensions::Process(
                                       TAcctReplNode * pAcctNode,    //in- Account replication node
                                       _bstr_t sTargetDomain,        //in- Name of the target domain
                                       Options * pOptions,           //in- Options as set by the user
                                       BOOL   bPreMigration          //in- Flag, whether to call pre or post task
                                   )
{
   IExtendAccountMigration * pExt;
   TNodeInterface          * pNode = NULL;
   HRESULT                   hr;
   IUnknown                * pSUnk = NULL;
   IUnknown                * pTUnk = NULL;
   IUnknown                * pMain = NULL;
   IUnknown                * pProps = NULL;
   IVarSetPtr                pVar(__uuidof(VarSet));
   IObjPropBuilderPtr        pProp(__uuidof(ObjPropBuilder));
   IADs                    * pSource = NULL;
   IADs                    * pTarget = NULL;
   _variant_t                var;
   IDispatch               * pDisp = NULL;

   // Get the IADs to both source and target accounts.
   hr = ADsGetObject(const_cast<WCHAR *>(pAcctNode->GetSourcePath()), IID_IADs, (void**) &pSource);
   if ( FAILED(hr))
      pSource = NULL;

   hr = ADsGetObject(const_cast<WCHAR *>(pAcctNode->GetTargetPath()), IID_IADs, (void**) &pTarget);
   if ( FAILED(hr))
      pTarget = NULL;

   // Get IUnknown * s to everything... Need to marshal it that way
   if ( pSource != NULL )
      pSource->QueryInterface(IID_IUnknown, (void **) &pSUnk);
   else
      pSUnk = NULL;

   if ( pTarget != NULL )
      pTarget->QueryInterface(IID_IUnknown, (void **) &pTUnk);
   else
      pTUnk = NULL;

   pVar->QueryInterface(IID_IUnknown, (void **) &pProps);
   m_pVs->QueryInterface(IID_IUnknown, (void **) &pMain);

   if ( pOptions->bSameForest )
      m_pVs->put(GET_BSTR(DCTVS_Options_IsIntraforest),GET_BSTR(IDS_YES));
   else
      m_pVs->put(GET_BSTR(DCTVS_Options_IsIntraforest),GET_BSTR(IDS_No));

   m_pVs->put(L"Options.SourceDomainVersion",(long)pOptions->srcDomainVer);
   m_pVs->put(L"Options.TargetDomainVersion",(long)pOptions->tgtDomainVer);
   // AccountNode into the Varset.
   PutAccountNodeInVarset(pAcctNode, pTarget, m_pVs);

   // Put the DB manager into the Varset
   pOptions->pDb->QueryInterface(IID_IDispatch, (void**)&pDisp);
   var.vt = VT_DISPATCH;
   var.pdispVal = pDisp;
   m_pVs->putObject(GET_BSTR(DCTVS_DBManager), var);
   // Call the Process Object method on all registered objects.that we created
   pNode  = (TNodeInterface *) m_listInterface.Head();
   while ( pNode )
   {
      try
      {
         if ( pOptions->pStatus )
         {
            LONG                status = 0;
            HRESULT             hr = pOptions->pStatus->get_Status(&status);
   
            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               break;
         }
         pExt = pNode->GetInterface();
         if ( pOptions->bUndo )
         {
            hr = pExt->ProcessUndo(pSUnk, pTUnk, pMain, &pProps);
         }
         else
         {
            BSTR sName;
            pExt->get_sName(&sName);
            if ( bPreMigration )
			{
               hr = pExt->PreProcessObject(pSUnk, pTUnk, pMain, &pProps);
			   if (hr == ERROR_OBJECT_ALREADY_EXISTS)
			      pAcctNode->SetHr(hr);
			}
            else
			{
			   /* we need to run the DisAcct extension last, so don't run it in this loop 
				  run it in the next loop by itself */
			      //if not DisAcct extension, process this extension 
			   if (wcscmp((WCHAR*)sName, L"Disable Accounts"))
                  hr = pExt->ProcessObject(pSUnk, pTUnk, pMain, &pProps);
			}
         }
      }
      catch (...)
      {
         BSTR sName;
         pExt->get_sName(&sName);
         err.LogOpen(pOptions->logFile,1);
         err.MsgWrite(ErrE, DCT_MSG_Extension_Exception_SS, (WCHAR*) sName, pAcctNode->GetTargetName());
         err.LogClose();
         hr = S_OK;
      }
      pNode = (TNodeInterface *)pNode->Next();
   }

   /* now run the DisAcct extension here to ensure it is run last, if not undo or premigration */
   if ((!pOptions->bUndo) && (!bPreMigration))
   {
      bool bDone = false;
      pNode  = (TNodeInterface *) m_listInterface.Head();
      while ((pNode) && (!bDone))
	  {
         try
		 {
            if ( pOptions->pStatus )
			{
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
   
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                  break;
			}
            pExt = pNode->GetInterface();
            BSTR sName;
            pExt->get_sName(&sName);
			if (!wcscmp((WCHAR*)sName, L"Disable Accounts"))
			{
			   bDone = true;
               hr = pExt->ProcessObject(pSUnk, pTUnk, pMain, &pProps);
			}
         }
         catch (...)
		 {
            BSTR sName;
            pExt->get_sName(&sName);
            err.LogOpen(pOptions->logFile,1);
            err.MsgWrite(ErrE, DCT_MSG_Extension_Exception_SS, (WCHAR*) sName, pAcctNode->GetTargetName());
            err.LogClose();
            hr = S_OK;
		 }
         pNode = (TNodeInterface *)pNode->Next();
	  }//end while not done and more
   }//end if not undo or premigration

   // Now we have the varset with all the settings that the user wants us to set.
   // So we can call the SetPropsFromVarset method in out GetProps object to set these
   // properties.
   hr = pProp->SetPropertiesFromVarset(pAcctNode->GetTargetPath(), /*sTargetDomain,*/ pProps, ADS_ATTR_UPDATE);

   // Update the AccountNode with any changes made by the extensions
   UpdateAccountNodeFromVarset(pAcctNode, pTarget, m_pVs);

   // Cleanup time ... 
   if ( pSUnk ) pSUnk->Release();
   if ( pTUnk ) pTUnk->Release();
   if ( pProps ) pProps->Release();
   if ( pMain ) pMain->Release();
   if ( pSource ) pSource->Release();
   if ( pTarget ) pTarget->Release();

   return hr;
}


//---------------------------------------------------------------------------
// PutAccountNodeInVarset : Transfers all the account node info into the 
//                          varset.
//---------------------------------------------------------------------------
void CProcessExtensions::PutAccountNodeInVarset(
                                                   TAcctReplNode *pNode,   //in -Replicated account node to get info
                                                   IADs * pTarget,         //in -IADs pointer to the target object for the GUID
                                                   IVarSet * pVS          //out-Varset to put the information in
                                               )
{
   _variant_t                var = L"";
   BSTR                      sGUID;
   DWORD                     lVal = 0;
   HRESULT                   hr;
   WCHAR                     strSid[MAX_PATH];
   DWORD                     lenStrSid = DIM(strSid);

   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceName),pNode->GetName());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourcePath),pNode->GetSourcePath());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceProfile),pNode->GetSourceProfile());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceRID),(long)pNode->GetSourceRid());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceSam),pNode->GetSourceSam());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_Status),(long)pNode->GetStatus());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_TargetName),pNode->GetTargetName());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_TargetPath),pNode->GetTargetPath());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_TargetProfile),pNode->GetTargetProfile());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_TargetRID),(long)pNode->GetTargetRid());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_TargetSam),pNode->GetTargetSam());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_Type),pNode->GetType());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_Operations),(long)pNode->operations);
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_ExpDate),pNode->lExpDate);
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_UserFlags), pNode->lFlags);
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceUPN),pNode->GetSourceUPN());
   GetTextualSid(pNode->GetSourceSid(),strSid,&lenStrSid);
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceDomainSid),strSid);

   // Get the GUID
   if ( pTarget )
   {
      hr = pTarget->get_GUID(&sGUID);
      if ( SUCCEEDED(hr) )
      {
         var = sGUID;
         SysFreeString(sGUID);
      }
   }
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_GUID), var);

   // Get the status
   lVal = pNode->GetStatus();
   var.Clear();
   var.vt = VT_UI4;
   var.lVal = lVal;
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_Status), var);
}

//---------------------------------------------------------------------------
// UpdateAccountNodeFromVarset : Updates the account node info with the data in the Transfers all the account node info into the 
//                          varset.
//---------------------------------------------------------------------------
void CProcessExtensions::UpdateAccountNodeFromVarset(
                                                   TAcctReplNode *pNode,   //in -Replicated account node to get info
                                                   IADs * pTarget,         //in -IADs pointer to the target object for the GUID
                                                   IVarSet * pVS          //out-Varset to put the information in
                                               )
{
   _variant_t                var = L"";
   DWORD                     lVal = 0;
   _bstr_t                   text;
   long                      val;

   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourceName));
   pNode->SetName(text);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourcePath));
   pNode->SetSourcePath(text);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourceProfile));
   pNode->SetSourceProfile(text);
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourceRID));
   pNode->SetSourceRid(val);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourceSam));
   pNode->SetSourceSam(text);
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_Status));
   pNode->SetStatus(val);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_TargetName));
   pNode->SetTargetName(text);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_TargetPath));
   pNode->SetTargetPath(text);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_TargetProfile));
   pNode->SetTargetProfile(text);
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_TargetRID));
   pNode->SetTargetRid(val);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_TargetSam));
   pNode->SetTargetSam(text);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_Type));
   pNode->SetType(text);
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_Operations));
   pNode->operations = val;
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_ExpDate));
   pNode->lExpDate = val;
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_UserFlags));
   pNode->lFlags = val;
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourceDomainSid));
   pNode->SetSourceSid(SidFromString((WCHAR*)text));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\pluginfo.h ===
// PlugInInfo.h : Declaration of the CPlugInInfo

#ifndef __PLUGININFO_H_
#define __PLUGININFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPlugInInfo
class ATL_NO_VTABLE CPlugInInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPlugInInfo, &CLSID_PlugInInfo>,
	public IDispatchImpl<IPlugInInfo, &IID_IPlugInInfo, &LIBID_MCSDCTWORKEROBJECTSLib>
{
public:
	CPlugInInfo()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PLUGININFO)
DECLARE_NOT_AGGREGATABLE(CPlugInInfo)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPlugInInfo)
	COM_INTERFACE_ENTRY(IPlugInInfo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IPlugInInfo
public:
	STDMETHOD(EnumeratePlugIns)(/*[out]*/ SAFEARRAY ** pPlugIns);
   STDMETHOD(EnumerateExtensions)(/*[out]*/ SAFEARRAY ** pExtensions);
};

#endif //__PLUGININFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\pluginfo.cpp ===
/*---------------------------------------------------------------------------
  File: PlugInInfo.cpp

  Comments: COM Object to enumerate information about available plug-ins 
  and extensions.  These plug-ins are distributed with the agent to the remote
  machines to perform custom migration tasks.  

  This interface would be used by the dispatcher, and possibly by the GUI, to 
  enumerate the list of available plug-ins.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/ 
   // PlugInInfo.cpp : Implementation of CPlugInInfo
#include "stdafx.h"
#include "WorkObj.h"
#include "PlugInfo.h"
#include "Common.hpp"
#include "UString.hpp"
#include "ErrDct.hpp"
#include "TReg.hpp"
#include "TNode.hpp"
#include "EaLen.hpp"

#include "McsPI.h" 
#include "McsPI_i.c" 
#include "ARExt_i.c" 

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPlugInInfo

// the PlugInNode is used to build a list of available plug-ins
class PlugInNode : public TNode
{
   WCHAR                     name[LEN_Guid];    // CLSID of the plug-in
public:
   PlugInNode(WCHAR const * n) { safecopy(name,n); }
   WCHAR const * GetName() { return name; }
};

// Checks the specified file to see if it implements any COM objects that implement the
// McsDomPlugIn interface -- if so, it appends them to the list of available plug-ins
void 
   AppendPlugInsToList(
      TNodeList            * pList, // in - list of plug-ins
      WCHAR          const * path   // in - file to examine for Plug-In COM objects
  )
{
   HRESULT                   hr = S_OK;
   ITypeLib                * pTlib = NULL;

   hr = LoadTypeLib(path,&pTlib);

   if ( SUCCEEDED(hr) )
   {
      UINT count = pTlib->GetTypeInfoCount();
      for ( UINT i = 0 ; i < count ; i++ )
      {
         ITypeInfo         * pInfo = NULL;
         hr = pTlib->GetTypeInfo(i,&pInfo);

         if ( SUCCEEDED(hr) )
         {
            TYPEATTR        * attr = NULL;

            hr = pInfo->GetTypeAttr(&attr);
            if ( SUCCEEDED(hr) )
            {
               if ( attr->typekind == TKIND_COCLASS )
               {
                  IMcsDomPlugIn        * pPlugIn = NULL;
                  // see if it supports IMcsDomPlugIn
                  hr = CoCreateInstance(attr->guid,NULL,CLSCTX_ALL,IID_IMcsDomPlugIn,(void**)&pPlugIn);
                  if ( SUCCEEDED(hr) )
                  {
                     pPlugIn->Release();   
                     // add the coclass to the list
                     LPOLESTR             strClsid = NULL;

                     hr = StringFromCLSID(attr->guid,&strClsid);
                     if ( SUCCEEDED(hr) ) 
                     {
                        PlugInNode * pNode = new PlugInNode(strClsid);
                        CoTaskMemFree(strClsid);
                        pList->InsertBottom(pNode);
                     }

                  }
               }
               pInfo->ReleaseTypeAttr(attr);   
            }
            pInfo->Release();
         }
      }
      pTlib->Release();
   }
}

SAFEARRAY *                                // ret- SAFEARRAY(BSTR) of filenames
   SafeArrayFromList(
      TNodeList            * pList         // in - list of filenames
   )
{
   SAFEARRAYBOUND            bound[1] = { pList->Count(),0 };
   SAFEARRAY               * pArray = SafeArrayCreate(VT_BSTR,1,bound);
   TNodeListEnum             tEnum;
   PlugInNode              * pNode;
   PlugInNode              * pNext;
   long                      ndx[1] = {0};

   for ( pNode = (PlugInNode *)tEnum.OpenFirst(pList) ; pNode ; pNode = pNext )
   {
      pNext = (PlugInNode *)tEnum.Next();

      SafeArrayPutElement(pArray,ndx,SysAllocString(pNode->GetName()));
      ndx[0]++;
      pList->Remove(pNode);
      delete pNode;
   }
   tEnum.Close();
   
   return pArray;
}

STDMETHODIMP 
   CPlugInInfo::EnumerateExtensions(
      /*[out]*/ SAFEARRAY ** pExtensions     // out- safearray of available account replication extensions
   )
{
   HRESULT                   hr = S_OK;
   DWORD                     rc = 0;
   TRegKey                   key;
   WCHAR                     classid[MAX_PATH];
   TNodeList                 list;
   PlugInNode              * node = NULL;
   long                      ndx = 0;

   // get the extensions registry key
   rc = key.Open(L"Software\\Mission Critical Software\\DomainAdmin\\Extensions",HKEY_LOCAL_MACHINE);
   if (! rc )
   {
      for ( ndx=0, rc = key.SubKeyEnum(ndx,classid,DIM(classid)) 
           ; rc == 0 
           ; ndx++, rc = key.SubKeyEnum(ndx,classid,DIM(classid)) )
      {
         node = new PlugInNode(classid); 
         list.InsertBottom(node);
      }
      if ( rc == ERROR_NO_MORE_ITEMS )
         rc = 0;
   }
   hr = HRESULT_FROM_WIN32(rc);
   
   return hr; 
}

STDMETHODIMP 
   CPlugInInfo::EnumeratePlugIns(
      SAFEARRAY            ** pPlugIns     // out- safearray containing clsids of available migration plug-ins
   )
{
	HRESULT                   hr = S_OK;
   DWORD                     rc;
   TRegKey                   key;
   WCHAR                     directory[MAX_PATH];
   WCHAR                     path[MAX_PATH];
   WCHAR                     dllPath[MAX_PATH];
   TNodeList                 list;
   
   // Get the plug-ins directory from the registry
#ifdef OFA
   rc = key.Open(L"Software\\Mission Critical Software\\OnePointFileAdmin",HKEY_LOCAL_MACHINE);
#else
   rc = key.Open(L"Software\\Mission Critical Software\\DomainAdmin",HKEY_LOCAL_MACHINE);
#endif
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"PlugInDirectory",directory,(sizeof directory));
      if ( ! rc )
      {
         // Enumerate the files there that match the naming convention:
         WIN32_FIND_DATA     fDat;
         HANDLE              hFind;
         
         UStrCpy(path,directory);
         UStrCpy(path + UStrLen(path),L"\\McsPi*.Dll");

         hFind = FindFirstFile(path,&fDat);
         if ( hFind && hFind != INVALID_HANDLE_VALUE )
         {
            BOOL                 bRc = TRUE;
            for ( ; rc == 0 ; bRc = FindNextFile(hFind,&fDat) )
            {
               if ( bRc )
               {
                  UStrCpy(dllPath,directory);
                  UStrCpy(dllPath + UStrLen(dllPath),L"\\");
                  UStrCpy(dllPath + UStrLen(dllPath),fDat.cFileName);
                  // check each one to see if it is a plug-in
                  AppendPlugInsToList(&list,dllPath);
               }
               else
               {
                  rc = GetLastError();
               }
            }

            // create a safearray from the contents of the list
            (*pPlugIns) = SafeArrayFromList(&list);
         }
      }
      else
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
   }
   else
   {
      hr = HRESULT_FROM_WIN32(rc);
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\reboot.h ===
/*---------------------------------------------------------------------------
  File: RebootComputer.h

  Comments: Implementation class definition for COM object to reboot a computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:24:22

 ---------------------------------------------------------------------------
*/

// RebootComputer.h : Declaration of the CRebootComputer

#ifndef __REBOOTCOMPUTER_H_
#define __REBOOTCOMPUTER_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CRebootComputer
class ATL_NO_VTABLE CRebootComputer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRebootComputer, &CLSID_RebootComputer>,
	public IDispatchImpl<IRebootComputer, &IID_IRebootComputer, &LIBID_MCSDCTWORKEROBJECTSLib>
{
   BOOL                      m_bNoChange;
public:
	CRebootComputer()
	{
	   m_bNoChange = FALSE;
   }

DECLARE_REGISTRY_RESOURCEID(IDR_REBOOT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRebootComputer)
	COM_INTERFACE_ENTRY(IRebootComputer)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IWorkNode
public:
   STDMETHOD(Process)(IUnknown *pWorkItem);

// IRebootComputer
public:
	STDMETHOD(get_NoChange)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_NoChange)(/*[in]*/ BOOL newVal);
	STDMETHOD(Reboot)(BSTR Computer, DWORD delay);
};

#endif //__REBOOTCOMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\pwdage.h ===
/*---------------------------------------------------------------------------
  File: ComputerPwdAge.h

  Comments: Definition of COM object to retrieve password age for computer 
  accounts (used to detect defunct accounts).

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:20:20

 ---------------------------------------------------------------------------
*/

// ComputerPwdAge.h : Declaration of the CComputerPwdAge

#ifndef __COMPUTERPWDAGE_H_
#define __COMPUTERPWDAGE_H_

#include "resource.h"       // main symbols
#include <comdef.h>
#include "Err.hpp"

/////////////////////////////////////////////////////////////////////////////
// CComputerPwdAge
class ATL_NO_VTABLE CComputerPwdAge : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CComputerPwdAge, &CLSID_ComputerPwdAge>,
	public IDispatchImpl<IComputerPwdAge, &IID_IComputerPwdAge, &LIBID_MCSDCTWORKEROBJECTSLib>
{
      _bstr_t                m_Domain;
      _bstr_t                m_DomainCtrl;

public:
	CComputerPwdAge()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_COMPPWDAGE)
DECLARE_NOT_AGGREGATABLE(CComputerPwdAge)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComputerPwdAge)
	COM_INTERFACE_ENTRY(IComputerPwdAge)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

   // IWorkNode
public:
 	STDMETHOD(Process)(IUnknown *pWorkItem);

 

// IComputerPwdAge
public:
	STDMETHOD(ExportPasswordAgeNewerThan)(BSTR domain, BSTR filename, DWORD maxAge);
	STDMETHOD(ExportPasswordAgeOlderThan)(BSTR domain, BSTR filename, DWORD minAge);
	STDMETHOD(ExportPasswordAge)(BSTR domain, BSTR filename);
	STDMETHOD(GetPwdAge)(BSTR DomainName,BSTR ComputerName,DWORD * age);
	STDMETHOD(SetDomain)(BSTR domain);

protected:
   DWORD GetDomainControllerForDomain(WCHAR const * domain, WCHAR * domctrl);
   DWORD GetSinglePasswordAgeInternal(WCHAR const * domctrl, WCHAR const * computer, DWORD * pwdage);
   DWORD ExportPasswordAgeInternal(WCHAR const * domctrl, WCHAR const * filename, DWORD minOrMaxAge, BOOL bOlder);
};

#endif //__COMPUTERPWDAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\reboot.cpp ===
/*---------------------------------------------------------------------------
  File: RebootComputer.cpp

  Comments: Implementation of COM object to reboot a remote computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:21:40

 ---------------------------------------------------------------------------
*/

// RebootComputer.cpp : Implementation of CRebootComputer
#include "stdafx.h"
#include "WorkObj.h"
#include "Reboot.h"
#include "UString.hpp"
#include "ResStr.h"

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
/////////////////////////////////////////////////////////////////////////////
// CRebootComputer

#include "RebootU.h"

STDMETHODIMP 
   CRebootComputer::Reboot(
      BSTR                   Computer,       // in - name of computer to reboot
      DWORD                  delay           // in - delay in seconds before rebooting
   )
{
   HRESULT                   hr  = S_OK;
   DWORD                     rc;
   
   rc = ComputerShutDown((WCHAR*)Computer,NULL,delay,TRUE,m_bNoChange);

   if ( rc )
   {
      hr = HRESULT_FROM_WIN32(rc);
   }

   return hr;

}

STDMETHODIMP 
   CRebootComputer::get_NoChange(
      BOOL                 * pVal         // out- flag, whether to actually reboot when reboot is called (or to do dry-run)
   )
{
	(*pVal) = m_bNoChange;
   return S_OK;
}

STDMETHODIMP 
   CRebootComputer::put_NoChange(
      BOOL                   newVal       // in - flag, whether to really reboot, or to do a dry run
   )
{
	m_bNoChange = newVal;
   return S_OK;
}

// RebootComputer WorkNode:  Reboots a remote computer, with an optional delay
// This function is not currently used by the domain migrator product, but provides
// and alternate way for clients to use this COM object
// 
// VarSet Syntax:
//  Input:
//       RebootComputer.Computer: <ComputerName>
//       RebootComputer.Message: <Message> (optional)
//       RebootComputer.Delay: <number-of-seconds> (optional, default=0)
//       RebootComputer.Restart: <Yes|No> (optional, default=Yes)

STDMETHODIMP 
   CRebootComputer::Process(
      IUnknown             * pWorkItem          // in - varset containing settings
   )
{
   HRESULT                    hr = S_OK;
   IVarSetPtr                 pVarSet = pWorkItem;
   DWORD                      delay = 0;
   BOOL                       restart = TRUE;

   _bstr_t                    computer = pVarSet->get(L"RebootComputer.Computer");
   _bstr_t                    message = pVarSet->get(L"RebootComputer.Message");
   _bstr_t                    text = pVarSet->get(L"RebootComputer.Restart");

   if ( !UStrICmp(text,GET_STRING(IDS_No)) )
   {
      restart = FALSE;
   }

   delay = (LONG)pVarSet->get(L"RebootComputer.Delay");

   if ( computer.length() )
   {
      DWORD                   rc = ComputerShutDown((WCHAR*)computer,(WCHAR*)message,delay,restart,FALSE);

      if ( rc )
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
   }
      
   return hr;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\rebootu.cpp ===
/*---------------------------------------------------------------------------
  File: RebootUtils.cpp

  Comments: Utility functions used to reboot a remote computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:22:10

 ---------------------------------------------------------------------------
*/


#include "Stdafx.h"
#include <stdio.h>
#include <winreg.h>
#include <lm.h>
#include <lmwksta.h>
#include <lmapibuf.h>
#include "RebootU.h"
#include "EaLen.hpp"


// ===========================================================================
/*    Function    :  GetPrivilege
   Description    :  This function gives the requested privilege on the requested
                     computer.
*/
// ===========================================================================
BOOL                                       // ret-TRUE if successful.
   GetPrivilege(
      WCHAR          const * sMachineW,    // in -NULL or machine name
      LPCWSTR                pPrivilege    // in -privilege name such as SE_SHUTDOWN_NAME
   )
{
   BOOL                      bRc=FALSE;    // boolean return code.
   HANDLE                    hToken=INVALID_HANDLE_VALUE; // process token.
   DWORD                     rcOs, rcOs2;  // OS return code.
   WCHAR             const * sEpName;      // API EP name if failure.
   WKSTA_INFO_100          * pWkstaInfo;   // Workstation info

   struct
   {
      TOKEN_PRIVILEGES       tkp;          // token privileges.
      LUID_AND_ATTRIBUTES    x[3];         // room for several.
   }                         token;

   sEpName = L"OpenProcessToken";

   rcOs = OpenProcessToken( GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                            &hToken )
         ? 0 : GetLastError();

   if ( !rcOs )
   {
      memset( &token, 0, sizeof token );
      sEpName = L"LookupPrivilegeValue";
      bRc = LookupPrivilegeValue( sMachineW,
                                  pPrivilege,
                                  &token.tkp.Privileges[0].Luid
                                );
      if ( !bRc )
      {
         rcOs = GetLastError();
      }
      else
      {
         token.tkp.PrivilegeCount = 1;
         token.tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
         sEpName = L"AdjustTokenPrivileges";
         AdjustTokenPrivileges( hToken, FALSE, &token.tkp, 0, NULL, 0 );
         rcOs = GetLastError();
      }
   }

   if ( hToken != INVALID_HANDLE_VALUE )
   {
      CloseHandle( hToken );
      hToken = INVALID_HANDLE_VALUE;
   }

   // If we had any error, try NetWkstaGetInfo.
   // If NetWkstaGetInfo fails, then use it's error condition instead.
   if ( rcOs )
   {
      pWkstaInfo = NULL,
      rcOs2 = NetWkstaGetInfo(
            const_cast<WCHAR *>(sMachineW),
            100,
            (BYTE **) &pWkstaInfo );
      if ( pWkstaInfo )
      {
         NetApiBufferFree( pWkstaInfo );
      }
      if ( rcOs2 )
      {
         rcOs = rcOs2;
         sEpName = L"NetWkstaGetInfo";
      }
   }

   if ( !rcOs )
   {
      bRc = TRUE;
   }
   else
   {
     bRc = FALSE;
     SetLastError(rcOs);
   }

   return bRc;
}


// ===========================================================================
/*    Function    :  ComputerShutDown
   Description    :  This function shutsdown/restarts the given computer.

*/
// ===========================================================================

DWORD 
   ComputerShutDown(
      WCHAR          const * pComputerName,        // in - computer to reboot
      WCHAR          const * pMessage,             // in - message to display in NT shutdown dialog
      DWORD                  delay,                // in - delay, in seconds
      DWORD                  bRestart,             // in - flag, whether to reboot or just shutdown
      BOOL                   bNoChange             // in - flag, whether to really do it
   )
{
   BOOL                      bSuccess = FALSE;
   WCHAR                     wcsMsg[LEN_ShutdownMessage];
   WCHAR                     wcsComputerName[LEN_Computer];
   DWORD                     rc = 0;
   WKSTA_INFO_100          * localMachine;
   WKSTA_INFO_100          * targetMachine;

   
   if ( pMessage )
   {
      wcscpy(wcsMsg,pMessage);
   }
   else
   {
      wcsMsg[0] = 0;
   }

   if ( pComputerName && *pComputerName )
   {
      if ( pComputerName[0] != L'\\' )
      {
         wsprintf(wcsComputerName,L"\\\\%s",pComputerName);
      }
      else
      {
         wcscpy(wcsComputerName,pComputerName);
      }
      
      // Get the name of the local machine
      rc = NetWkstaGetInfo(NULL,100,(LPBYTE*)&localMachine);
      if (! rc )
      {
         rc = NetWkstaGetInfo(wcsComputerName,100,(LPBYTE*)&targetMachine);
      }
      if ( ! rc )
      {
         // Get the privileges needed to shutdown a machine
         if ( !_wcsicmp(wcsComputerName + 2, localMachine->wki100_computername)  )
         {
            bSuccess = GetPrivilege(wcsComputerName, (LPCWSTR)SE_SHUTDOWN_NAME);
         }
         else
         {
            bSuccess = GetPrivilege(wcsComputerName, (LPCWSTR)SE_REMOTE_SHUTDOWN_NAME);
         }
         if ( ! bSuccess )
         {
            rc = GetLastError();
         }
      }
   }
   else
   {
         // Computer name not specified - the is the local machine
      wcsComputerName[0] = 0;   
      bSuccess = GetPrivilege(NULL, (LPCWSTR)SE_SHUTDOWN_NAME);
      if ( ! bSuccess )
      {
         rc = GetLastError();
      }
   }
   if ( bSuccess && ! bNoChange )
   {
      bSuccess = InitiateSystemShutdown( wcsComputerName,
                                      wcsMsg,
                                      delay,
                                      TRUE,
                                      bRestart
                                    );
      if ( !bSuccess )
      {
         rc = GetLastError();
      }
   }
   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\regtrans.h ===
#ifndef __REGTRANSLATOR_H__
#define __REGTRANSLATOR_H__
/*---------------------------------------------------------------------------
  File: RegTranslator.h    

  Comments: Functions to translate registry hives, specifically, user profiles

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 05/12/99 11:11:49

 ---------------------------------------------------------------------------
*/
#include "STArgs.hpp"
#include "SidCache.hpp"
#include "SDStat.hpp"
#import  "DBMgr.tlb" no_namespace, named_guids


DWORD 
   TranslateLocalProfiles(
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   );

DWORD 
   TranslateRemoteProfile(
      WCHAR          const * sourceProfilePath,   // in - source profile path
      WCHAR                * targetProfilePath,   // out- new profile path for target account
      WCHAR          const * sourceName,          // in - name of source account
      WCHAR          const * targetName,          // in - name of target account
      WCHAR          const * srcDomain,           // in - source domain
      WCHAR          const * tgtDomain,           // in - target domain      
      IIManageDB           * pDb,				  // in - pointer to DB object
	  long					 lActionID,           // in - action ID of this migration
	  PSID                   sourceSid,           // in - source sid from MoveObj2K
      BOOL                   bWriteChanges        // in - No Change mode.
   );


DWORD 
   TranslateRegistry(
      WCHAR            const * computer,          // in - computername to translate registry on
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   );

HRESULT UpdateMappedDrives(WCHAR * sSourceSam, WCHAR * sSourceDomain, WCHAR * sRegistryKey);

#endif //__REGTRANSLATOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\rebootu.h ===
/*---------------------------------------------------------------------------
  File: RebootUtils.h

  Comments: Utility functions used to reboot a computer

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to