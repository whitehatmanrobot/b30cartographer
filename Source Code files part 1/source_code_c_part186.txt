st
//

// Defined in exclist.h

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

#define DEFMAC(TypeId,TypeName)     TypeId, TypeName,

EXCLISTPROPS g_ExcListProps [] = {
    EXCLUSIONLIST_TYPES     /* , */
    ELT_LAST, NULL
};

#undef DEFMAC


//
// Code
//


BOOL
ElInitialize (
    VOID
    )

/*++

Routine Description:

    ElInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    MYASSERT (!g_ElPool);
    g_ElPool = PmCreateNamedPool (S_EXCLUSIONLIST);
    if (!g_ElPool) {
        return FALSE;
    }

    MYASSERT (!g_ElTypeLists);
    g_ElTypeLists = pAllocateMemory (ELT_LAST * DWSIZEOF (GROWLIST));
    MYASSERT (g_ElTypeLists);
    ZeroMemory (g_ElTypeLists, ELT_LAST * DWSIZEOF (GROWLIST));

    return TRUE;
}


/*++

Routine Description:

    ElTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

VOID
ElTerminateA (
    VOID
    )
{
    ElRemoveAllA ();

    if (g_ElTypeLists) {
        pFreeMemory (g_ElTypeLists);
        g_ElTypeLists = NULL;
    }

    if (g_ElPool) {
        PmDestroyPool (g_ElPool);
        g_ElPool = NULL;
    }
}

VOID
ElTerminateW (
    VOID
    )
{
    ElRemoveAllW ();

    if (g_ElTypeLists) {
        pFreeMemory (g_ElTypeLists);
        g_ElTypeLists = NULL;
    }

    if (g_ElPool) {
        PmDestroyPool (g_ElPool);
        g_ElPool = NULL;
    }
}


/*++

Routine Description:

    ElGetTypeId returns the TypeId of a type given by name

Arguments:

    TypeName - Specifies the name

Return Value:

    One of DWORD enumeration values

--*/

DWORD
ElGetTypeId (
    IN      PCSTR TypeName
    )
{
    UINT u;

    if (TypeName) {
        for (u = 0; g_ExcListProps[u].TypeName; u++) {
            if (StringIMatchA (g_ExcListProps[u].TypeName, TypeName)) {
                return g_ExcListProps[u].TypeId;
            }
        }
    }

    return ELT_LAST;
}


/*++

Routine Description:

    ElGetTypeName returns the type name of a type given by TypeId

Arguments:

    TypeId - Specifies the ID

Return Value:

    A pointer to one of the known type names or NULL if TypeId is unknown

--*/

PCSTR
ElGetTypeName (
    IN      DWORD TypeId
    )
{
    MYASSERT (TypeId < ELT_LAST);
    if (TypeId >= ELT_LAST) {
        return NULL;
    }
    return g_ExcListProps[TypeId].TypeName;
}


/*++

Routine Description:

    ElAdd adds the given object of the given type to the exclusion list. The object
    is first parsed so that the decision if a given string matches this pattern is faster.

Arguments:

    ObjectType - Specifies the object type
    ObjectName - Specifies the object pattern string

Return Value:

    TRUE if the string pattern was successfully parsed and added to the list

--*/

BOOL
ElAddA (
    IN      DWORD ObjectType,
    IN      PCSTR ObjectName
    )
{
    POBSPARSEDPATTERNA pp;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (ObjectName);

    //
    // add each object in its own type list
    //
    pp = ObsCreateParsedPatternExA (NULL, ObjectName, ObjectType == ELT_FILE);
    if (!pp) {
        DEBUGMSGA ((
            DBG_EXCLIST,
            "ElAddA: Bad ObjectName: %s (type %s)",
            ObjectName,
            ElGetTypeName (ObjectType)
            ));
        return FALSE;
    }

    //
    // add the pointer to the list
    //
    GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp, DWSIZEOF (pp));

    DEBUGMSGA ((
        DBG_EXCLIST,
        "ElAddA: Added excluded %s as type %s",
        ObjectName,
        ElGetTypeName (ObjectType)
        ));

    return TRUE;
}


BOOL
ElAddW (
    IN      DWORD ObjectType,
    IN      PCWSTR ObjectName
    )
{
    POBSPARSEDPATTERNW pp;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (ObjectName);

    //
    // add each object in its own type list
    //
    pp = ObsCreateParsedPatternExW (NULL, ObjectName, ObjectType == ELT_FILE);
    if (!pp) {
        DEBUGMSGW ((
            DBG_EXCLIST,
            "ElAddW: Bad ObjectName: %s (type %hs)",
            ObjectName,
            ElGetTypeName (ObjectType)
            ));
        return FALSE;
    }

    //
    // add the pointer to the list
    //
    GlAppend (&g_ElTypeLists[ObjectType], (PBYTE)&pp, DWSIZEOF (pp));

    DEBUGMSGW ((
        DBG_EXCLIST,
        "ElAddW: Added excluded %s as type %hs",
        ObjectName,
        ElGetTypeName (ObjectType)
        ));

    return TRUE;
}


/*++

Routine Description:

    ElRemoveAll removes all object patterns from the exclusion list.

Arguments:

    none

Return Value:

    none

--*/

VOID
ElRemoveAllA (
    VOID
    )
{
    PGROWLIST gl;
    UINT u;
    UINT i;

    if (g_ElTypeLists) {

        for (u = 0; u < ELT_LAST; u++) {
            gl = &g_ElTypeLists[u];

            for (i = GlGetSize (gl); i > 0; i--) {
                ObsDestroyParsedPatternA (*(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1));
                GlDeleteItem (gl, i - 1);
            }

            GlFree (gl);
        }

        ZeroMemory (g_ElTypeLists, ELT_LAST * DWSIZEOF (GROWLIST));
    }
}

VOID
ElRemoveAllW (
    VOID
    )
{
    PGROWLIST gl;
    UINT u;
    UINT i;

    if (g_ElTypeLists) {

        for (u = 0; u < ELT_LAST; u++) {
            gl = &g_ElTypeLists[u];
            for (i = GlGetSize (gl); i > 0; i--) {
                ObsDestroyParsedPatternW (*(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1));
                GlDeleteItem (gl, i - 1);
            }

            GlFree (gl);
        }

        ZeroMemory (g_ElTypeLists, ELT_LAST * DWSIZEOF (GROWLIST));
    }
}


/*++

Routine Description:

    ElIsExcluded decides if the given object string is excluded (if it matches one of the
    patterns added previously).

Arguments:

    ObjectType - Specifies the object type
    Object - Specifies the object string

Return Value:

    TRUE if the string is excluded

--*/

BOOL
ElIsExcludedA (
    IN      DWORD ObjectType,
    IN      PCSTR Object
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNA pp;
    UINT i;
    PSTR node;
    PSTR leaf;
    BOOL b = FALSE;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Object);
    if (!Object) {
        return FALSE;
    }

    //
    // lookup each object in its own type list
    //
    gl = &g_ElTypeLists[ObjectType];

    if (!ObsSplitObjectStringExA (Object, &node, &leaf, g_ElPool, FALSE)) {
        DEBUGMSGA ((DBG_EXCLIST, "ElIsExcludedA: invalid Object: \"%s\"", Object));
        return FALSE;
    }

    for (i = GlGetSize (gl); i > 0; i--) {

        pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

        //
        // if stored pattern doesn't contain a node,
        // that means "any node matches"
        //
        if (pp->NodePattern && !node) {
            continue;
        }
        if (!pp->LeafPattern && leaf || pp->LeafPattern && !leaf) {
            continue;
        }
        if (leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternA (pp->LeafPattern, leaf)) {
                continue;
            }
        }
        if (pp->NodePattern && !TestParsedPatternA (pp->NodePattern, node)) {
            continue;
        }
        //
        // the patterns match!
        //
        b = TRUE;
        break;
    }

    pFreeMemory (node);
    pFreeMemory (leaf);

    return b;
}

BOOL
ElIsExcludedW (
    IN      DWORD ObjectType,
    IN      PCWSTR Object
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNW pp;
    UINT i;
    PWSTR node;
    PWSTR leaf;
    BOOL b = FALSE;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Object);
    if (!Object) {
        return FALSE;
    }

    //
    // lookup each object in its own type list
    //
    gl = &g_ElTypeLists[ObjectType];

    if (!ObsSplitObjectStringExW (Object, &node, &leaf, g_ElPool, FALSE)) {
        DEBUGMSGW ((DBG_EXCLIST, "ElIsExcludedW: invalid Object: \"%s\"", Object));
        return FALSE;
    }

    for (i = GlGetSize (gl); i > 0; i--) {

        pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

        //
        // if stored pattern doesn't contain a node,
        // that means "any node matches"
        //
        if (pp->NodePattern && !node) {
            continue;
        }
        if (!pp->LeafPattern && leaf || pp->LeafPattern && !leaf) {
            continue;
        }
        if (leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternW (pp->LeafPattern, leaf)) {
                continue;
            }
        }
        if (pp->NodePattern && !TestParsedPatternW (pp->NodePattern, node)) {
            continue;
        }
        //
        // the patterns match!
        //
        b = TRUE;
        break;
    }

    pFreeMemory (node);
    pFreeMemory (leaf);

    return b;
}


/*++

Routine Description:

    ElIsExcluded2 decides if the object given by its 2 components is excluded
    (if it matches one of the patterns added previously).

Arguments:

    ObjectType - Specifies the object type
    Node - Specifies the node part of the object
    Leaf - Specifies the leaf part of the object; optional

Return Value:

    TRUE if the string is excluded

--*/

BOOL
ElIsExcluded2A (
    IN      DWORD ObjectType,
    IN      PCSTR Node,             OPTIONAL
    IN      PCSTR Leaf              OPTIONAL
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNA pp;
    UINT i;

    //
    // validate params
    //
    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];

    for (i = GlGetSize (gl); i > 0; i--) {

        pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

        //
        // if stored pattern doesn't contain a node,
        // that means "any node matches"
        //
        if (pp->NodePattern && !Node) {
            continue;
        }
        if (!pp->LeafPattern && Leaf || pp->LeafPattern && !Leaf) {
            continue;
        }
        if (Leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternA (pp->LeafPattern, Leaf)) {
                continue;
            }
        }
        if (pp->NodePattern && !TestParsedPatternA (pp->NodePattern, Node)) {
            continue;
        }
        //
        // the patterns match!
        //
        return TRUE;
    }

    return FALSE;
}

BOOL
ElIsExcluded2W (
    IN      DWORD ObjectType,
    IN      PCWSTR Node,            OPTIONAL
    IN      PCWSTR Leaf             OPTIONAL
    )
{
    PGROWLIST gl;
    POBSPARSEDPATTERNW pp;
    UINT i;

    //
    // validate params
    //
    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];

    for (i = GlGetSize (gl); i > 0; i--) {

        pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

        //
        // if stored pattern doesn't contain a node,
        // that means "any node matches"
        //
        if (pp->NodePattern && !Node) {
            continue;
        }
        if (!pp->LeafPattern && Leaf || pp->LeafPattern && !Leaf) {
            continue;
        }
        if (Leaf) {
            MYASSERT (pp->LeafPattern);
            if (!TestParsedPatternW (pp->LeafPattern, Leaf)) {
                continue;
            }
        }
        if (pp->NodePattern && !TestParsedPatternW (pp->NodePattern, Node)) {
            continue;
        }
        //
        // the patterns match!
        //
        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

    ElIsTreeExcluded2 decides if the object given by its 2 components and representing the
    whole tree beneath it (as a root) is excluded; i.e. if any child of the given object
    is excluded

Arguments:

    ObjectType - Specifies the object type
    Root - Specifies the root of the tree
    LeafPattern - Specifies the leaf pattern to be used for this decision; optional;
                  if NULL, no leaf pattern matching will be attempted

Return Value:

    TRUE if the tree is excluded, given the leaf pattern

--*/

BOOL
ElIsTreeExcluded2A (
    IN      DWORD ObjectType,
    IN      PCSTR Root,
    IN      PCSTR LeafPattern           OPTIONAL
    )
{
    PGROWLIST gl;
    UINT i;
    POBSPARSEDPATTERNA pp;
    PCSTR subTreePattern;
    PPARSEDPATTERNA stpp;
    PPARSEDPATTERNA lpp;
    BOOL b;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Root);
    if (!Root) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    if (GlGetSize (gl) == 0) {
        return FALSE;
    }

    if (LeafPattern) {
        lpp = CreateParsedPatternA (LeafPattern);
        if (!lpp) {
            DEBUGMSGA ((DBG_EXCLIST, "ElIsTreeExcluded2A: invalid LeafPattern: %s", LeafPattern));
            return FALSE;
        }
    } else {
        lpp = NULL;
    }

    //
    // look if Root ends with "\*"
    //
    subTreePattern = FindLastWackA (Root);
    if (!subTreePattern || subTreePattern[1] != '*' || subTreePattern[2] != 0) {
        subTreePattern = JoinPathsInPoolExA ((g_ElPool, Root, "*", NULL));
    } else {
        subTreePattern = Root;
    }

    b = FALSE;

    stpp = CreateParsedPatternA (subTreePattern);
    if (stpp) {

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && LeafPattern || pp->LeafPattern && !LeafPattern) {
                continue;
            }
            if (LeafPattern) {
                MYASSERT (pp->LeafPattern);
                if (!PatternIncludesPatternA (pp->LeafPattern, lpp)) {
                    continue;
                }
            }
            if (!PatternIncludesPatternA (pp->NodePattern, stpp)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        DestroyParsedPatternA (stpp);
    }
    ELSE_DEBUGMSGA ((DBG_EXCLIST, "ElIsTreeExcluded2A: invalid Root: %s", Root));

    if (subTreePattern != Root) {
        pFreeMemory (subTreePattern);
    }
    if (lpp) {
        DestroyParsedPatternA (lpp);
    }

    return b;
}

BOOL
ElIsTreeExcluded2W (
    IN      DWORD ObjectType,
    IN      PCWSTR Root,
    IN      PCWSTR LeafPattern          OPTIONAL
    )
{
    PGROWLIST gl;
    UINT i;
    POBSPARSEDPATTERNW pp;
    PCWSTR subTreePattern;
    PPARSEDPATTERNW stpp;
    PPARSEDPATTERNW lpp;
    BOOL b;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Root);
    if (!Root) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    if (GlGetSize (gl) == 0) {
        return FALSE;
    }

    if (LeafPattern) {
        lpp = CreateParsedPatternW (LeafPattern);
        if (!lpp) {
            DEBUGMSGW ((DBG_EXCLIST, "ElIsTreeExcluded2W: invalid LeafPattern: %s", LeafPattern));
            return FALSE;
        }
    } else {
        lpp = NULL;
    }

    //
    // look if Root ends with "\*"
    //
    subTreePattern = FindLastWackW (Root);
    if (!subTreePattern || subTreePattern[1] != L'*' || subTreePattern[2] != 0) {
        subTreePattern = JoinPathsInPoolExW ((g_ElPool, Root, L"*", NULL));
    } else {
        subTreePattern = Root;
    }

    b = FALSE;

    stpp = CreateParsedPatternW (subTreePattern);
    if (stpp) {

        for (i = GlGetSize (gl); i > 0; i--) {

            pp = *(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1);

            if (!pp->LeafPattern && LeafPattern || pp->LeafPattern && !LeafPattern) {
                continue;
            }
            if (LeafPattern) {
                MYASSERT (pp->LeafPattern);
                if (!PatternIncludesPatternW (pp->LeafPattern, lpp)) {
                    continue;
                }
            }
            if (!PatternIncludesPatternW (pp->NodePattern, stpp)) {
                continue;
            }
            //
            // the patterns match!
            //
            b = TRUE;
            break;
        }

        DestroyParsedPatternW (stpp);
    }
    ELSE_DEBUGMSGW ((DBG_EXCLIST, "ElIsTreeExcluded2W: invalid Root: %s", Root));

    if (subTreePattern != Root) {
        pFreeMemory (subTreePattern);
    }
    if (lpp) {
        DestroyParsedPatternW (lpp);
    }

    return b;
}


/*++

Routine Description:

    ElIsObsPatternExcluded decides if the object given by its parsed pattern is excluded;
    i.e. if any object matching this pattern is excluded

Arguments:

    ObjectType - Specifies the object type
    Pattern - Specifies the parsed pattern to be used for this decision

Return Value:

    TRUE if the object is excluded

--*/

BOOL
ElIsObsPatternExcludedA (
    IN      DWORD ObjectType,
    IN      POBSPARSEDPATTERNA Pattern
    )
{
    PGROWLIST gl;
    UINT i;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Pattern);
    if (!Pattern) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    for (i = GlGetSize (gl); i > 0; i--) {
        if (ObsPatternIncludesPatternA (*(POBSPARSEDPATTERNA*) GlGetItem (gl, i - 1), Pattern)) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
ElIsObsPatternExcludedW (
    IN      DWORD ObjectType,
    IN      POBSPARSEDPATTERNW Pattern
    )
{
    PGROWLIST gl;
    UINT i;

    MYASSERT (ObjectType < ELT_LAST);
    if (ObjectType >= ELT_LAST) {
        return FALSE;
    }

    MYASSERT (Pattern);
    if (!Pattern) {
        return FALSE;
    }

    gl = &g_ElTypeLists[ObjectType];
    for (i = GlGetSize (gl); i > 0; i--) {
        if (ObsPatternIncludesPatternW (*(POBSPARSEDPATTERNW*) GlGetItem (gl, i - 1), Pattern)) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\main.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Main source file of migutil.dll

Author:

    Jim Schmidt (jimschm)   01-Aug-1996

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     23-Sep-1998 Start thread
    marcw       23-Sep-1998 Locale fix
    jimschm     03-Nov-1997 Added TextAlloc routines
    marcw       22-Jul-1997 Added IS<platform> functions.

--*/


#include "pch.h"
#include "utilsp.h"
#include "locale.h"

//#define DEBUG_ALL_FILES

HINSTANCE g_hInst;
HANDLE g_hHeap;

OSVERSIONINFOA g_OsInfo;

#define TEXT_GROWTH_SIZE    65536


//
// OS-dependent flags for MultiByteToWideChar
//

DWORD g_MigutilWCToMBFlags = 0;


//
// g_ShortTermAllocTable is the default table used for resource string
// management.  New strings are allocated from the table.
//
// Allocation tables are very simple ways to store strings loaded in from
// the exe image.  The loaded string is copied into the table and kept
// around until it is explicitly freed.  Multiple attempts at getting the
// same resource string return the same string, inc'ing a use counter.
//
// g_OutOfMemoryTable is the table used to hold out-of-memory text.  It
// is loaded up at init time and is kept in memory for the whole time
// migutil is in use, so out-of-memory messages can always be displayed.
//

PGROWBUFFER g_ShortTermAllocTable;
PGROWBUFFER g_OutOfMemoryTable;

//
// We make sure the message APIs (GetStringResource, ParseMessageID, etc)
// are thread-safe
//

OUR_CRITICAL_SECTION g_MessageCs;

//
// The PoolMem routines must also be thread-safe
//

CRITICAL_SECTION g_PmCs;

//
// MemAlloc critical section
//

CRITICAL_SECTION g_MemAllocCs;

//
// The following pools are used for text management.  g_RegistryApiPool is
// for reg.c, g_PathsPool is for the JoinPaths/DuplicatePath/etc routines,
// and g_TextPool is for AllocText, DupText, etc.
//
PMHANDLE g_RegistryApiPool;
PMHANDLE g_PathsPool;
PMHANDLE g_TextPool;
static BOOL g_UtilsInitialized;

VOID
UtInitialize (
    IN      HANDLE Heap             OPTIONAL
    )
{
    if (g_UtilsInitialized) {
        DEBUGMSG ((DBG_ERROR, "Utilities already initialized"));
        return;
    }

    g_UtilsInitialized = TRUE;

    //
    // Set globals
    //

    if (Heap) {
        g_hHeap = Heap;
    } else {
        g_hHeap = GetProcessHeap();
    }

    if (!g_hInst) {
        g_hInst = GetModuleHandle (NULL);
    }

    //
    // Load in OSVERSION info.
    //
    g_OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    GetVersionExA (&g_OsInfo);

    //
    // Create critical sections
    //

    __try {
        InitializeCriticalSection (&g_MemAllocCs);
        InitializeCriticalSection (&g_PmCs);
        InitializeOurCriticalSection (&g_MessageCs);
    } __except (EXCEPTION_CONTINUE_EXECUTION) {
        // Might raise an out of memory exception, but we don't check for that in this function.
        // Ignored
    }

    //
    // Create text pool, needed for the log
    //

    g_TextPool = PmCreateNamedPool ("Text");
    PmSetMinimumGrowthSize (g_TextPool, TEXT_GROWTH_SIZE);

    //
    // Create the rest of the pools
    //

    g_RegistryApiPool = PmCreateNamedPool ("Registry API");
    g_PathsPool = PmCreateNamedPool ("Paths");

    //
    // Now that MemAlloc will work, initialize allocation tracking
    //

    InitAllocationTracking();

    //
    // Create the short-term alloc table for string resource utils
    //

    g_ShortTermAllocTable = CreateAllocTable();

    //
    // MultiByteToWideChar has desirable flags that only function on NT
    //

    if (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_NT && g_OsInfo.dwMajorVersion > 4) {
        // This flag is only valid for Win2k and above, it will cause conversion to fail on NT4
        g_MigutilWCToMBFlags = WC_NO_BEST_FIT_CHARS;
    } else {
        g_MigutilWCToMBFlags =  0;
    }

    //
    // The "out of memory" message
    //

    g_OutOfMemoryTable = CreateAllocTable();

    g_OutOfMemoryRetry  = GetStringResourceExA (
                                g_OutOfMemoryTable,
                                10001 /* MSG_OUT_OF_MEMORY_RETRY */
                                );

    g_OutOfMemoryString = GetStringResourceExA (
                                g_OutOfMemoryTable,
                                10002 /* MSG_OUT_OF_MEMORY */
                                );

    if (!g_OutOfMemoryString || !g_OutOfMemoryRetry) {
        //
        //DEBUGMSG ((
        //    DBG_WARNING,
        //    "Cannot load out of memory messages; resources 10001 and 10002 do not exist"
        //   ));
    }

    ObsInitialize ();
    ElInitialize ();

    //
    // set the locale to the system locale. Not doing this can cause isspace
    // to AV in certain MBSCHR circumstances.
    //
    setlocale(LC_ALL,"");
    InitLeadByteTable();
}


VOID
UtTerminate (
    VOID
    )
{
    if (!g_UtilsInitialized) {
        DEBUGMSG ((DBG_ERROR, "UtTerminate already called"));
        return;
    }
    g_UtilsInitialized = FALSE;

    //
    // Free utility pools
    //

    ElTerminate ();
    ObsTerminate ();

    if (g_RegistryApiPool) {
        PmDestroyPool (g_RegistryApiPool);
    }

    if (g_PathsPool) {
        PmDestroyPool (g_PathsPool);
    }

    if (g_ShortTermAllocTable) {
        DestroyAllocTable (g_ShortTermAllocTable);
    }

    if (g_OutOfMemoryTable) {
        DestroyAllocTable (g_OutOfMemoryTable);
    }

    if (g_TextPool) {
        PmDestroyPool (g_TextPool);
    }

    //
    // Clean up handles used by critical sections
    //
    FreeAllocationTracking();

    DumpHeapLeaks ();

    PmDumpStatistics ();

    GbDumpStatistics ();

    DumpHeapStats();

    DeleteCriticalSection (&g_MemAllocCs);
    DeleteCriticalSection (&g_PmCs);
    DeleteOurCriticalSection (&g_MessageCs);
}



#define WIDTH(rect) (rect.right - rect.left)
#define HEIGHT(rect) (rect.bottom - rect.top)

void
CenterWindow (
    IN  HWND hwnd,
    IN  HWND Parent
    )
{
    RECT WndRect, ParentRect;
    int x, y;

    if (!Parent) {
        ParentRect.left = 0;
        ParentRect.top  = 0;
        ParentRect.right = GetSystemMetrics (SM_CXFULLSCREEN);
        ParentRect.bottom = GetSystemMetrics (SM_CYFULLSCREEN);
    } else {
        GetWindowRect (Parent, &ParentRect);
    }

    MYASSERT (IsWindow (hwnd));

    GetWindowRect (hwnd, &WndRect);

    x = ParentRect.left + (WIDTH(ParentRect) - WIDTH(WndRect)) / 2;
    y = ParentRect.top + (HEIGHT(ParentRect) - HEIGHT(WndRect)) / 2;

    SetWindowPos (hwnd, NULL, x, y, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}


static INT g_MigUtilWaitCounter = 0;
static HCURSOR g_MigUtilWaitCursor = NULL;

VOID
TurnOnWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOnWaitCursor sets the cursor to IDC_WAIT.  It maintains a use
  counter, so code requring the wait cursor can be nested.

Arguments:

  none

Return Value:

  none

--*/

{
    if (g_MigUtilWaitCounter == 0) {
        g_MigUtilWaitCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
    }

    g_MigUtilWaitCounter++;
}


VOID
TurnOffWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOffWaitCursor decrements the wait cursor counter, and if it
  reaches zero the cursor is restored.

Arguments:

  none

Return Value:

  none

--*/

{
    if (!g_MigUtilWaitCounter) {
        DEBUGMSG ((DBG_WHOOPS, "TurnOffWaitCursor called too many times"));
    } else {
        g_MigUtilWaitCounter--;

        if (!g_MigUtilWaitCounter) {
            SetCursor (g_MigUtilWaitCursor);
        }
    }
}


/*++

Routine Description:

  Win9x does not support TryEnterOurCriticalSection, so we must implement
  our own version because it is quite a useful function.

Arguments:

  pcs - A pointer to an OUR_CRITICAL_SECTION object

Return Value:

  TRUE if the function succeeded, or FALSE if it failed.  See Win32
  SDK docs on critical sections, as these routines are identical to
  the caller.

--*/

BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    // Create initially signaled, auto-reset event
    pcs->EventHandle = CreateEvent (NULL, FALSE, TRUE, NULL);
    if (!pcs->EventHandle) {
        return FALSE;
    }

    return TRUE;
}


VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    if (pcs->EventHandle) {
        CloseHandle (pcs->EventHandle);
        pcs->EventHandle = NULL;
    }

}


BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    // Wait for event to become signaled, then turn it off
    rc = WaitForSingleObject (pcs->EventHandle, INFINITE);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    SetEvent (pcs->EventHandle);
}

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    rc = WaitForSingleObject (pcs->EventHandle, 0);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}




HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    )
{
    DWORD DontCare;

    return CreateThread (NULL, 0, Address, Arg, 0, &DontCare);
}


HANDLE
StartProcessA (
    IN      PCSTR CmdLine
    )
{
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    PSTR copyOfCmdLine;
    BOOL b;

    copyOfCmdLine = DuplicateTextA (CmdLine);

    ZeroMemory (&si, sizeof (si));

    b = CreateProcessA (
            NULL,
            copyOfCmdLine,
            NULL,
            NULL,
            FALSE,
            CREATE_NEW_PROCESS_GROUP,
            NULL,
            NULL,
            &si,
            &pi
            );

    FreeTextA (copyOfCmdLine);

    if (!b) {
        return NULL;
    }

    CloseHandle (pi.hThread);
    return pi.hProcess;
}

HANDLE
StartProcessW (
    IN      PCWSTR CmdLine
    )
{
    STARTUPINFOW si;
    PROCESS_INFORMATION pi;
    PWSTR copyOfCmdLine;
    BOOL b;

    copyOfCmdLine = DuplicateTextW (CmdLine);

    ZeroMemory (&si, sizeof (si));

    b = CreateProcessW (
            NULL,
            copyOfCmdLine,
            NULL,
            NULL,
            FALSE,
            CREATE_NEW_PROCESS_GROUP,
            NULL,
            NULL,
            &si,
            &pi
            );

    FreeTextW (copyOfCmdLine);

    if (!b) {
        return NULL;
    }

    CloseHandle (pi.hThread);
    return pi.hProcess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\growlist.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growlist.c

Abstract:

    Simple buffer management functions that maintenence of a list of binary
    objects.

Author:

    08-Aug-1997   jimschm     Created

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.

--*/

#include "pch.h"

#define INSERT_LAST     0xffffffff

PBYTE
pGlAdd (
    IN OUT  PGROWLIST GrowList,
    IN      UINT InsertBefore,
    IN      PBYTE DataToAdd,            OPTIONAL
    IN      UINT SizeOfData,
    IN      UINT NulBytesToAdd
    )

/*++

Routine Description:

  pGlAdd allocates memory for a binary block by using a pool, and then expands
  an array of pointers, maintaining a quick-access list.

Arguments:

  GrowList - Specifies the list to add the entry to

  InsertBefore - Specifies the index of the array element to insert
                 before, or INSERT_LIST to append.

  DataToAdd - Specifies the binary block of data to add.

  SizeOfData - Specifies the size of data.

  NulBytesToAdd - Specifies the number of nul bytes to add to the buffer

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    PBYTE *Item;
    PBYTE *InsertAt;
    PBYTE Data;
    UINT OldEnd;
    UINT Size;
    UINT TotalSize;

    TotalSize = SizeOfData + NulBytesToAdd;

    MYASSERT (TotalSize || !DataToAdd);

    //
    // Allocate pool if necessary
    //

    if (!GrowList->ListData) {
        GrowList->ListData = PmCreateNamedPool ("GrowList");
        if (!GrowList->ListData) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate pool"));
            return NULL;
        }

        PmDisableTracking (GrowList->ListData);
    }

    //
    // Expand list array
    //

    OldEnd = GrowList->ListArray.End;
    Item = (PBYTE *) GbGrow (&GrowList->ListArray, sizeof (PBYTE));
    if (!Item) {
        DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate array item"));
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToAdd || NulBytesToAdd) {
        Data = PmGetAlignedMemory (GrowList->ListData, TotalSize);
        if (!Data) {
            GrowList->ListArray.End = OldEnd;
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block"));
            return NULL;
        }

        if (DataToAdd) {
            CopyMemory (Data, DataToAdd, SizeOfData);
        }
        if (NulBytesToAdd) {
            ZeroMemory (Data + SizeOfData, NulBytesToAdd);
        }
    } else {
        Data = NULL;
    }

    //
    // Adjust array
    //

    Size = GlGetSize (GrowList);

    if (InsertBefore >= Size) {
        //
        // Append mode
        //

        *Item = Data;

    } else {
        //
        // Insert mode
        //

        InsertAt = (PBYTE *) (GrowList->ListArray.Buf) + InsertBefore;
        MoveMemory (&InsertAt[1], InsertAt, (Size - InsertBefore) * sizeof (PBYTE));
        *InsertAt = Data;
    }

    return Data ? Data : (PBYTE) 1;
}


VOID
GlFree (
    IN  PGROWLIST GrowList
    )

/*++

Routine Description:

  GlFree frees the resources allocated by a GROWLIST.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    GbFree (&GrowList->ListArray);
    if (GrowList->ListData) {
        PmDestroyPool (GrowList->ListData);
    }

    ZeroMemory (GrowList, sizeof (GROWLIST));
}


VOID
GlReset (
    IN OUT  PGROWLIST GrowList
    )

/*++

Routine Description:

  GlReset empties the grow list but does not destroy the index buffer or pool.
  It is used to efficiently reuse a list.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    GrowList->ListArray.End = 0;;
    if (GrowList->ListData) {
        PmEmptyPool (GrowList->ListData);
    }
}


PBYTE
GlGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlGetItem returns a pointer to the block of data for item specified by
  Index.

Arguments:

  GrowList - Specifies the list to access

  Index - Specifies zero-based index of item in list to access

Return Value:

  A pointer to the item's data, or NULL if the Index does not
  represent an actual item.

--*/

{
    PBYTE *ItemPtr;
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    ItemPtr = (PBYTE *) (GrowList->ListArray.Buf);
    MYASSERT(ItemPtr);

    return ItemPtr[Index];
}


UINT
GlGetSize (
    IN      PGROWLIST GrowList
    )

/*++

Routine Description:

  GlGetSize calculates the number of items in the list.

Arguments:

  GrowList - Specifies the list to calculate the size of

Return Value:

  The number of items in the list, or zero if the list is empty.

--*/

{
    return GrowList->ListArray.End / sizeof (PBYTE);
}


PBYTE
RealGlAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend appends a black of data as a new list item.

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGlAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 0);
}


PBYTE
RealGlAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend appends a black of data as a new list item and appends two zero
  bytes (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGlAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 2);
}


PBYTE
RealGlInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend inserts a black of data as a new list item, before the specified
  Index.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index > Size) {
        return NULL;
    }

    return pGlAdd (GrowList, Index, DataToInsert, SizeOfData, 0);
}


PBYTE
RealGlInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend inserts a block of data as a new list item, before the specified
  Index.  Two zero bytes are appended to the block of data (used for string
  termination).

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index > Size) {
        return NULL;
    }

    return pGlAdd (GrowList, Index, DataToInsert, SizeOfData, 2);
}


BOOL
GlDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlDeleteItem removes an item from the list.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

Return Value:

  TRUE if the data block was removed from the list, or FALSE if
  Index is invalid.

--*/

{
    UINT Size;
    PBYTE *DeleteAt;

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    DeleteAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*DeleteAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*DeleteAt));
    }

    Size--;
    if (Size > Index) {
        MoveMemory (DeleteAt, &DeleteAt[1], (Size - Index) * sizeof (PBYTE));
    }

    GrowList->ListArray.End = Size * sizeof (PBYTE);

    return TRUE;
}


BOOL
GlResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlResetItem sets the list pointer of the specified item to NULL, freeing the
  memory associated with the item's data.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to reset.

Return Value:

  TRUE if the data block was freed and the list element was nulled,
  or FALSE if Index is invalid.

--*/

{
    UINT Size;
    PBYTE *ResetAt;

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    ResetAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ResetAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*ResetAt));
    }

    *ResetAt = NULL;

    return TRUE;
}


PBYTE
RealGlSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCBYTE DataToCopy,
    IN      UINT DataSize
    )

/*++

Routine Description:

  GlSetItem replaces the data associated with a list item.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

  DataToCopy - Specifies data to associate with the list item

  DataSize - Specifies the size of Data

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;
    PBYTE *ReplaceAt;
    PBYTE Data;

    MYASSERT (DataSize || !DataToCopy);

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToCopy) {
        Data = PmGetAlignedMemory (GrowList->ListData, DataSize);
        if (!Data) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block (2)"));
            return NULL;
        }

        CopyMemory (Data, DataToCopy, DataSize);
    } else {
        Data = NULL;
    }

    //
    // Update list pointer
    //

    ReplaceAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ReplaceAt) {
        PmReleaseMemory (GrowList->ListData, (PVOID) (*ReplaceAt));
    }
    *ReplaceAt = Data;

    return Data ? Data : (PBYTE) 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\strings.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strings.c

Abstract:

    A number of string utilities useful for any project

Author:

    Jim Schmidt (jimschm)   12-Sept-1996

Revisions:

    ovidiut     12-Jan-2000 Added GetNodePatternMinMaxLevels,PatternIncludesPattern
    ovidiut     14-Sep-1999 Updated for new coding conventions and Win64 compliance
    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     08-Jul-1999 IsPatternMatchEx
    jimschm     07-Jan-1999 GetFileExtensionFromPath fixed again, added
                            GetDotExtensionFromPath
    calinn      23-Sep-1998 GetFileExtensionFromPath bug fix
    calinn      29-Jan-1998 Fixed a bug in EnumNextMultiSz.
    calinn      11-Jan-1998 Added EnumFirstMultiSz and EnumNextMultiSz functions.
    marcw       15-Dec-1997 Added ExpandEnvironmentTextEx functions.
    marcw       14-Nov-1997 SlightJoinText revisions.
    jimschm     21-May-1997 AppendWack revisions
    marcw       24-Mar-1997 StringReplace functions.
    jimschm     14-Mar-1997 New critical section stuff, enhanced message resource
                            routines, C runtime extensions, registry root utils
    jimschm     26-Nov-1996 Added message resource tools.
    mikeco      01-Jul-1997 Add FreeStringResourcePtr Fns
    mikeco      29-Sep-1997 IsLeadByte wrapper for IsDBCSLeadByte


--*/


#include "pch.h"

//
// Includes
//

#include "utilsp.h"

#define DBG_STRINGS     "Strings"

//
// Strings
//

// None

//
// Constants
//

// Error stack size (normally only one or two, so 32 is relatively huge)
#define MAX_STACK           32
#define WACK_REPLACE_CHAR   0x02
#define DWORD_MAX           0xFFFFFFFFu

//
// Macros
//

// None

//
// Types
//

typedef enum {
    BEGIN_PATTERN,
    BEGIN_COMPOUND_PATTERN,
    BEGIN_PATTERN_EXPR,
    SAVE_EXACT_MATCH,
    SAVE_SEGMENT,
    LOOK_FOR_NUMBER,
    LOOK_FOR_INCLUDE,
    LOOK_FOR_EXCLUDE,
    ADVANCE_TO_END_OF_EXPR,
    PARSE_CHAR_EXPR_OR_END,
    SKIP_EXCLUDE_SET,
    CONDENSE_SET,
    PARSE_END_FOUND,
    SKIP_INCLUDE_SET,
    END_PATTERN_EXPR,
    PATTERN_DONE,
    PATTERN_ERROR
} PATTERNSTATE;


typedef struct {
    UINT char1;
    UINT char2;
    UINT result;
} DHLIST, *PDHLIST;

//
// Globals
//

BOOL g_LeadByteArray[256];

CHAR EscapedCharsA[] = "?*\020<>,^";
WCHAR EscapedCharsW[] = L"?*\020<>,^";

DWORD g_dwErrorStack[MAX_STACK];
DWORD g_dwStackPos = 0;
DHLIST g_DHList[] = {{0xB3, 0xDE, 0x8394},
                     {0xB6, 0xDE, 0x834B},
                     {0xB7, 0xDE, 0x834D},
                     {0xB8, 0xDE, 0x834F},
                     {0xB9, 0xDE, 0x8351},
                     {0xBA, 0xDE, 0x8353},
                     {0xBB, 0xDE, 0x8355},
                     {0xBC, 0xDE, 0x8357},
                     {0xBD, 0xDE, 0x8359},
                     {0xBE, 0xDE, 0x835B},
                     {0xBF, 0xDE, 0x835D},
                     {0xC0, 0xDE, 0x835F},
                     {0xC1, 0xDE, 0x8361},
                     {0xC2, 0xDE, 0x8364},
                     {0xC3, 0xDE, 0x8366},
                     {0xC4, 0xDE, 0x8368},
                     {0xCA, 0xDE, 0x836F},
                     {0xCB, 0xDE, 0x8372},
                     {0xCC, 0xDE, 0x8375},
                     {0xCD, 0xDE, 0x8378},
                     {0xCE, 0xDE, 0x837B},
                     {0xCA, 0xDF, 0x8370},
                     {0xCB, 0xDF, 0x8373},
                     {0xCC, 0xDF, 0x8376},
                     {0xCD, 0xDF, 0x8379},
                     {0xCE, 0xDF, 0x837C},
                     {0x00, 0x00, 0x0000}};
extern OUR_CRITICAL_SECTION g_MessageCs;        // in main.c
extern PMHANDLE g_TextPool;                     // in main.c
PGROWBUFFER g_LastAllocTable;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pTestSetA (
    IN      MBCHAR ch,
    IN      PCSTR IncludeSet,               OPTIONAL
    IN      PCSTR ExcludeSet                OPTIONAL
    );

BOOL
pTestSetW (
    IN      WCHAR ch,
    IN      PCWSTR IncludeSet,              OPTIONAL
    IN      PCWSTR ExcludeSet               OPTIONAL
    );

//
// Macro expansion definition
//

// None

//
// Code
//


// This has bugs on JPN systems. We need to terminate the string and then call CharLowerA
// #define OURTOLOWER(l) ((WORD)CharLowerA((PSTR)((WORD)(l))))

MBCHAR
OURTOLOWER (
    MBCHAR ch
    )
{
    CHAR str [3];
    MBCHAR result = 0;

    if (((PBYTE)(&ch))[1]) {
        str [0] = ((PBYTE)(&ch))[1];
        str [1] = ((PBYTE)(&ch))[0];
    } else {
        str [0] = ((PBYTE)(&ch))[0];
        str [1] = 0;
    }
    CharLowerA (str);
    if (str[1]) {
        ((PBYTE)(&result))[0] = str [1];
        ((PBYTE)(&result))[1] = str [0];
    } else {
        ((PBYTE)(&result))[0] = str [0];
    }
    return result;
}

VOID
InitLeadByteTable (
    VOID
    )
{
    INT i;

    g_LeadByteArray[0] = FALSE;

    for (i = 1 ; i < 256 ; i++) {
        g_LeadByteArray[i] = IsDBCSLeadByte ((BYTE) i);
    }
}


/*++

Routine Description:

  StringCopy implements lstrcpyA and a UNICODE version. We don't use the Win32
  api because of speed and because we want to compile lint-free.

Arguments:

  Destination - Receivies the string copy
  Source      - Specifies the string to copy

Return Value:

  The pointer to the Destionation's nul terminator.

--*/

PSTR
StringCopyA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    )
{
    PCSTR current = Source;
    PCSTR end;

    while (*current) {
        *Destination++ = *current++;
    }

    //
    // Make sure DBCS string is properly terminated
    //

    end = current;
    current--;

    while (current >= Source) {

        if (!IsLeadByte (current)) {
            //
            // destEnd is correct
            //
            break;
        }

        current--;
    }

    if (!((end - current) & 1)) {
        Destination--;
    }

    *Destination = 0;
    return Destination;
}


PWSTR
StringCopyW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    )
{
    while (*Source) {
        *Destination++ = *Source++;
    }

    *Destination = 0;
    return Destination;
}


/*++

Routine Description:

  StringCopyByteCount implements lstrcpynA and a UNICODE version. We don't
  use the Win32 api because of speed and because we want to compile lint-free.

Arguments:

  Destination - Receivies the string copy
  Source      - Specifies the string to copy
  Count       - Specifies the maximum number of bytes to copy, including the
                nul terminator. If Count is zero, then not even a nul
                terminator is written.

Return Value:

  None.

--*/

PSTR
StringCopyByteCountA (
    OUT     PSTR Destination,
    IN      PCSTR Source,
    IN      UINT Count
    )
{
    PCSTR end;
    PCSTR current;
    PSTR destEnd;

    destEnd = Destination;

    if (Count >= sizeof (CHAR)) {

        current = Source;

        end = (PCSTR) ((PBYTE) Source + Count - sizeof (CHAR));

        while (*current && current < end) {
            *destEnd++ = *current++;
        }

        //
        // If current has data left, we need to make sure a DBCS string
        // is properly terminated.
        //

        if (*current) {

            end = current;
            current--;

            while (current >= Source) {

                if (!IsLeadByte (current)) {
                    //
                    // destEnd is correct
                    //
                    break;
                }

                current--;
            }

            if (!((end - current) & 1)) {
                destEnd--;
            }
        }

        *destEnd = 0;
    }

    return destEnd;
}


PWSTR
StringCopyByteCountW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source,
    IN      UINT Count
    )
{
    PCWSTR end;

    if (Count < sizeof (WCHAR)) {
        DEBUGMSG_IF ((
            Count != 0,
            DBG_WHOOPS,
            "Buffer passed to StringCopyByteCountW is a fraction of one character"
            ));

        return Destination;
    }

    end = (PCWSTR) ((PBYTE) Source + Count - sizeof (WCHAR));

    while ((Source < end) && (*Source)){
        *Destination++ = *Source++;
    }

    *Destination = 0;
    return Destination;
}


PSTR
StringCopyByteCountABA (
    OUT     PSTR Destination,
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      UINT MaxBytesToCopyIncNul
    )

/*++

Routine Description:

  StringCopyByteCountAB copies a string segment into a destination buffer,
  and limits the copy to a maximum buffer size.  The return string is always
  nul-terminated, unless the buffer is too small to even hold a nul character.

Arguments:

  Destination          - Receives the string starting at Start and ending one
                         character before End.
  Start                - Specifies the start of the string.
  End                  - Specifies the first character not to copy.  If End
                         is equal or less than Start, then Destination is set
                         to an empty string (assuming the buffer can hold at
                         least one character)
  MaxBytesToCopyIncNul - Specifies the size of Destination, in bytes, and
                         including the nul terminator.

Return Value:

  A pointer to the destination nul terminator.

--*/

{
    INT width;

#ifdef DEBUG
    PCSTR check;

    check = Start;
    while (check < End) {
        if (!(*check)) {
            DEBUGMSG ((DBG_WHOOPS, "StringCopyByteCountABA: Nul found between start and end"));
            break;
        }

        check++;
    }
#endif

    width = (INT) ((End - Start + 1) * sizeof (CHAR));

    if (width > sizeof (CHAR)) {
        return StringCopyByteCountA (Destination, Start, min ((UINT) width, MaxBytesToCopyIncNul));
    } else if (MaxBytesToCopyIncNul >= sizeof (CHAR)) {
        *Destination = 0;
    }

    return Destination;
}

PWSTR
StringCopyByteCountABW (
    OUT     PWSTR Destination,
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      UINT MaxBytesToCopyIncNul
    )
{
    INT width;

#ifdef DEBUG
    PCWSTR check;

    check = Start;
    while (check < End) {
        if (!(*check)) {
            DEBUGMSG ((DBG_WHOOPS, "StringCopyByteCountABW: Nul found between start and end"));
            break;
        }

        check++;
    }
#endif

    width = (INT) ((End - Start + 1) * sizeof (WCHAR));

    if (width > sizeof (WCHAR)) {
        return StringCopyByteCountW (Destination, Start, min ((UINT) width, MaxBytesToCopyIncNul));
    } else if (MaxBytesToCopyIncNul >= sizeof (WCHAR)) {
        *Destination = 0;
    }

    return Destination;
}



/*++

Routine Description:

  AllocTextEx allocates a block of memory from the specified pool, or g_TextPool
  if no pool is specified, and is designated specifically for text processing.
  The g_TextPool is initialized when migutil.lib loads up, and there is 64K of
  guaranteed workspace, which will grow as necessary.

Arguments:

  Pool - Specifies the pool to allocate memory from

  CountOfChars - Specifies the number of characters (not bytes) to allocate.  The
                 return pointer is a block of memory that can hold CountOfChars characters,
                 weather they are SBCS, DBCS or UNICODE.

Return Value:

  A pointer to the allocated memory, or NULL if the pool could not be expanded
  to hold the number of specified characters.

--*/

PSTR
RealAllocTextExA (
    IN      PMHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PSTR text;

    if (!Pool) {
        Pool = g_TextPool;
    }

    MYASSERT (Pool);
    MYASSERT (CountOfChars);

    text = PmGetAlignedMemory (Pool, CountOfChars * sizeof (CHAR) * 2);

    if (text) {
        text [0] = 0;
    }

    return text;
}

PWSTR
RealAllocTextExW (
    IN      PMHANDLE Pool,
    IN      UINT CountOfChars
    )
{
    PWSTR text;

    if (!Pool) {
        Pool = g_TextPool;
    }

    MYASSERT (Pool);
    MYASSERT (CountOfChars);

    text = PmGetAlignedMemory (Pool, CountOfChars * sizeof (WCHAR));

    if (text) {
        text [0] = 0;
    }

    return text;
}


/*++

Routine Description:

  FreeText frees the memory allocated by AllocText.  After all strings are freed,
  the block will be emptied but not deallocated.

  It is important NOT to leak memory, because a leak will cause the pool to
  expand, and non-empty pools cause memory fragmentation.

Arguments:

  Text - Specifies the text to free, as returned from AllocText, DuplicateText,
         DuplicateTextEx, etc...

Return Value:

  none

--*/

VOID
FreeTextExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Text          OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PmReleaseMemory (Pool, (PVOID) Text);
    }
}


VOID
FreeTextExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    )
{
    if (Text) {
        if (!Pool) {
            Pool = g_TextPool;
        }

        PmReleaseMemory (Pool, (PVOID) Text);
    }
}



/*++

Routine Description:

  DuplicateTextEx duplicates a text string and allocates additional space a
  caller needs to complete its processing.  Optionally, the caller receives
  a pointer to the nul of the duplicated string (to allow more efficient
  appends).

Arguments:

  Text - Specifies the text to duplicate

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated and expanded string, or NULL if g_TextPool
  could not be expanded to fit the duplicated string and extra characters.

--*/

PSTR
RealDuplicateTextExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    )
{
    PSTR buf;
    PSTR d;
    PCSTR s;

    buf = AllocTextExA (Pool, CharCountA (Text) + ExtraChars + 1);
    if (buf) {
        s = Text;
        d = buf;
        while (*s) {
            if (IsLeadByte (s)) {
                *d++ = *s++;
            }
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}

PWSTR
RealDuplicateTextExW (
    IN      PMHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    )
{
    PWSTR buf;
    PWSTR d;
    PCWSTR s;

    buf = AllocTextExW (Pool, CharCountW (Text) + ExtraChars + 1);
    if (buf) {
        s = Text;
        d = buf;
        while (*s) {
            *d++ = *s++;
        }
        *d = 0;

        if (NulChar) {
            *NulChar = d;
        }
    }

    return buf;
}


/*++

Routine Description:

  JoinText duplicates String1 and appends String2 to it delimited with the optional delimiterstring.

Arguments:

  String1 - Specifies the text to duplciate

  String2 - Specifies the text to append to String1

  DelimiterString - Optionally specifies the string to place between string 1 and string 2.

  ExtraChars - Specifies the number of characters (not bytes) to allocate
               space for.  The characters can be from the SBCS, DBCS or
               UNICODE character sets.

  NulChar - Receives a pointer to the nul at the end of the duplicated
            string.  Use for fast appends.

Return Value:

  A pointer to the duplicated string and extra characters.

--*/

PSTR
RealJoinTextExA (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR CenterString,     OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    )
{
    PSTR buf;
    PSTR end;
    PSTR d;
    PCSTR s;

    buf = DuplicateTextExA (
              Pool,
              String1,
              CharCountA (String2) + ExtraChars + (CenterString ? CharCountA (CenterString) : 0),
              &end
              );

    MYASSERT (buf);

    d = end;

    if (CenterString) {
        s = CenterString;
        while (*s) {
            if (IsLeadByte (s)) {
                *d++ = *s++;
            }
            *d++ = *s++;
        }
    }

    s = String2;
    while (*s) {
        if (IsLeadByte (s)) {
            *d++ = *s++;
        }
        *d++ = *s++;
    }
    *d = 0;

    if (NulChar) {
        *NulChar = d;
    }

    return buf;
}


PWSTR
RealJoinTextExW (
    IN      PMHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    )
{
    PWSTR buf;
    PWSTR end;
    PCWSTR s;
    PWSTR d;

    buf = DuplicateTextExW (
              Pool,
              String1,
              CharCountW (String2) + ExtraChars + (CenterString ? CharCountW(CenterString) : 0),
              &end
              );

    MYASSERT (buf);

    d = end;

    if (CenterString) {
        s = CenterString;
        while (*s) {
            *d++ = *s++;
        }
    }

    s = String2;

    while (*s) {
        *d++ = *s++;
    }
    *d = 0;

    if (NulChar) {
        *NulChar = d;
    }

    return buf;
}


/*++

Routine Description:

  ExpandEnvironmentTextEx takes a block of text containing zero or more environment variables
  (encoded in %'s) and returns the text with the environment variables expanded. The function
  also allows the caller to specify additional environment variables in an array and will use
  these variables before calling GetEnvironmentVariable.

  The returned text is allocated out of the Text pool and should be freed using FreeText().


Arguments:

  InString - The string containing environement variables to be processed.

  ExtraVars - Optional var pointing to an array of environment variables to be used to supersede
              or suppliment the system environment variables. Even entries in the list are the
              names of environment variables, odd entries there values.
              (e.g. {"name1","value1","name2","value2",...}


Return Value:

  An expanded string.

--*/


PWSTR
RealExpandEnvironmentTextExW (
    IN      PCWSTR InString,
    IN      PCWSTR * ExtraVars   OPTIONAL
    )
{

    PWSTR   rString             = NULL;
    PWSTR   newString           = NULL;
    PWSTR   envName             = NULL;
    PWSTR   envValue            = NULL;
    BOOL    inSubstitution      = FALSE;
    BOOL    ignoreNextPercent   = FALSE;
    BOOL    errorOccurred       = FALSE;
    BOOL    foundValue          = FALSE;
    BOOL    freeValue           = FALSE;
    PCWSTR  nextPercent         = NULL;
    PCWSTR  source              = NULL;
    PCWSTR  savedSource         = NULL;
    UINT    maxSize             = 0;
    UINT    curSize             = 0;
    UINT    index               = 0;
    UINT    size                = 0;


    if (!InString) {
        return NULL;
    }

    if (*InString == 0) {
        return DuplicateTextW (InString);
    }


    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize + 3 > maxSize) {

                maxSize += 1024;
                newString = AllocTextW (maxSize);

                if (!newString) {
                    DEBUGMSG((DBG_ERROR,"ExpandEnvironmentTextEx: Memory Error!"));
                    errorOccurred = TRUE;
                    __leave;
                }

                if (rString) {
                    //lint -e(671)
                    CopyMemory (newString, rString, (SIZE_T) ((UINT)curSize * sizeof(WCHAR)));
                    FreeTextW(rString);
                }

                rString = newString;

            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (*source == L'%' && !inSubstitution) {
                if (ignoreNextPercent) {
                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = wcschr(source + 1,L'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextW(nextPercent - source);
                        if (!envName) {
                            errorOccurred = TRUE;
                            __leave;
                        }

                        StringCopyByteCountABW (
                            envName,
                            source + 1,
                            nextPercent,
                            (UINT) ((UBINT)nextPercent - (UBINT)source)
                            );


                        //
                        // Try to find the variable.
                        //
                        foundValue = FALSE;
                        freeValue = FALSE;

                        if (ExtraVars) {

                            //
                            // Search through the list of extra vars passed in by the caller.
                            // Even entries of this list are env var names. Odd entries are env values.
                            // {envname1,envvalue1,envname2,envvalue2,...}
                            //
                            index = 0;
                            while (ExtraVars[index]) {

                                if (StringIMatchW(ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                    foundValue = TRUE;
                                    envValue = (PWSTR) ExtraVars[index + 1];
                                    break;
                                }
                                index +=2;
                            }
                        }

                        if (!foundValue) {
                            //
                            // Still haven't found the environment variable. Use GetEnvironmentString.
                            //
                            //
                            size = GetEnvironmentVariableW(envName,NULL,0);

                            if (!size) {
                                errorOccurred = TRUE;
                                DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                            } else {

                                //
                                // Create a buffer large enough to hold this value and copy it in.
                                //
                                envValue = AllocTextW(size);


                                if ((size - 1) != GetEnvironmentVariableW(envName,envValue,size)) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGW((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                }
                                else {
                                    foundValue = TRUE;
                                }

                                freeValue = TRUE;
                            }
                        }


                        if (foundValue) {
                            //
                            // Ok, we have a valid environment value. Need to copy this data over.
                            // To do this, we update and save the current source into old source, set source = to the envValue,
                            // and set the inSubstitution value so that we don't attempt to expand any percents within
                            // the value.
                            //
                            savedSource     = nextPercent + 1;
                            source          = envValue;
                            inSubstitution  = TRUE;
                        }
                        else {
                            DEBUGMSGW ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                            ignoreNextPercent = TRUE;
                        }

                        //
                        // We are done with the environment name at this time, so clean it up.
                        //
                        FreeTextW(envName);
                        envName = NULL;
                    }
                    ELSE_DEBUGMSGW((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }


            //
            // Copy over the current character.
            //

            rString[curSize++] = *source++; //lint !e613

            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) { //lint !e613
                        rString[curSize] = 0;   //lint !e613
                    }
                    if (freeValue) {
                        FreeTextW(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;   //lint !e613
                }
            }
        }
    }   //lint !e613
    __finally {

        DEBUGMSGW_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : L"NULL"));

        if (envName) {
            FreeTextW(envName);
        }
        if (envValue && freeValue) {
            FreeTextW(envValue);
        }

    }

    return rString;
}


PSTR
RealExpandEnvironmentTextExA (
    IN      PCSTR InString,
    IN      PCSTR * ExtraVars   OPTIONAL
    )
{

    PSTR   rString             = NULL;
    PSTR   newString           = NULL;
    PSTR   envName             = NULL;
    PSTR   envValue            = NULL;
    BOOL   inSubstitution      = FALSE;
    BOOL   ignoreNextPercent   = FALSE;
    BOOL   errorOccurred       = FALSE;
    BOOL   foundValue          = FALSE;
    BOOL   freeValue           = FALSE;
    PCSTR  nextPercent         = NULL;
    PCSTR  source              = NULL;
    PCSTR  savedSource         = NULL;
    UINT   maxSize             = 0;
    UINT   curSize             = 0;
    UINT   index               = 0;
    UINT   size                = 0;


    if (!InString) {
        return NULL;
    }

    if (*InString == 0) {
        return DuplicateTextA (InString);
    }

    //
    // Set source to the start of InString to begin with...
    //
    source = InString;

    __try {

        while (*source) {

            //
            // Reallocate the string if necessary. We assume that most strings
            // are smaller than 1024 chars and that we will therefore only rarely
            // reallocate a string.
            //
            if (curSize + 3 > maxSize) {

                maxSize += 1024;
                newString = AllocTextA (maxSize);

                if (rString) {
                    CopyMemory (newString, rString, curSize * sizeof(CHAR));    //lint !e671
                    FreeTextA(rString);
                }

                rString = newString;
            }


            //
            // if we find a percent sign, and we are not currently expanding
            // an environment variable (or copying an empty set of %'s),
            // then we have probably found an environment variable. Attempt
            // to expand it.
            //
            if (!IsLeadByte(source) && *source == '%' && !inSubstitution) {

                if (ignoreNextPercent) {

                    ignoreNextPercent = FALSE;
                }
                else {

                    ignoreNextPercent = FALSE;
                    nextPercent = _mbschr(source + 1,'%');

                    if (nextPercent == source + 1) {
                        //
                        // We found two consecutive %s in this string. We'll ignore them and simply copy them as
                        // normal text.
                        //
                        ignoreNextPercent = TRUE;
                        DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Empty Environment variable in %s. Ignoring.",InString));

                    }
                    else if (nextPercent) {
                        //
                        // Create a variable to hold the envName.
                        //
                        envName = AllocTextA(nextPercent - source);
                        StringCopyABA (envName, source+1, nextPercent);


                        //
                        // Try to find the variable.
                        //
                        foundValue = FALSE;
                        freeValue = FALSE;

                        if (ExtraVars) {

                            //
                            // Search through the list of extra vars passed in by the caller.
                            // Even entries of this list are env var names. Odd entries are env values.
                            // {envname1,envvalue1,envname2,envvalue2,...}
                            //
                            index = 0;
                            while (ExtraVars[index]) {

                                if (StringIMatchA (ExtraVars[index],envName) && ExtraVars[index + 1]) {

                                    foundValue = TRUE;
                                    envValue = (PSTR) ExtraVars[index + 1];
                                    break;
                                }
                                index +=2;
                            }
                        }

                        if (!foundValue) {
                            //
                            // Still haven't found the environment variable. Use GetEnvironmentString.
                            //
                            //
                            size = GetEnvironmentVariableA(envName,NULL,0);

                            if (!size) {
                                errorOccurred = TRUE;
                                DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: Environment variable %s not found!",envName));
                            }
                            else {

                                //
                                // Create a buffer large enough to hold this value and copy it in.
                                //
                                envValue = AllocTextA(size);
                                freeValue = TRUE;

                                if ((size - 1) != GetEnvironmentVariableA(envName,envValue,size)) {
                                    errorOccurred = TRUE;
                                    DEBUGMSGA((DBG_ERROR,"ExpandEnvironmentTextEx: Error from GetEnvironmentVariable."));
                                }
                                else {
                                    foundValue = TRUE;
                                }
                            }
                        }




                        if (foundValue) {

                            //
                            // Ok, we have a valid environment value. Need to copy this data over.
                            // To do this, we update and save the current source into old source, set source = to the envValue,
                            // and set the inSubstitution value so that we don't attempt to expand any percents within
                            // the value.
                            //
                            savedSource     = nextPercent + 1;
                            source          = envValue;
                            inSubstitution  = TRUE;



                        }
                        else {
                            DEBUGMSGA ((DBG_WARNING, "ExpandEnvironmentTextEx: No Environment variable found for %s.", envName));
                            ignoreNextPercent = TRUE;

                        }

                        //
                        // We are done with the environment name at this time, so clean it up.
                        //
                        FreeTextA(envName);
                        envName = NULL;


                    }
                    ELSE_DEBUGMSGA((DBG_WARNING,"ExpandEnvironmentTextEx: No matching percent found in %s. Ignoring.",InString));
                }
            }



            //
            // Copy over the current character.
            //
            if (IsLeadByte(source)) {  //lint !e613
                rString[curSize++] = *source++; //lint !e613
            }
            rString[curSize++] = *source++; //lint !e613


            if (!*source) {
                if (inSubstitution) {
                    //
                    // The source for the environment variable is fully copied.
                    // restore the old source.
                    //
                    inSubstitution = FALSE;
                    source = savedSource;
                    if (!*source) { //lint !e613
                        rString[curSize] = 0;   //lint !e613
                    }
                    if (freeValue) {
                        FreeTextA(envValue);
                        freeValue = FALSE;
                    }
                    envValue = NULL;
                }
                else {
                    rString[curSize] = 0;   //lint !e613
                }
            }
        }
    }   //lint !e613
    __finally {

        DEBUGMSGA_IF (( errorOccurred, DBG_WARNING, "ExpandEnvironmentText: Some errors occurred while processing %s = %s.", InString, rString ? rString : "NULL"));

        if (envName) {
            FreeTextA(envName);
        }
        if (envValue && freeValue) {
            FreeTextA(envValue);
        }

    }

    return rString;
}



/*++

Routine Description:

  AppendWack adds a backslash to the end of any string, unless the string
  already ends in a backslash.

  AppendDosWack adds a backslash, but only if the path does not already
  end in a backslash or colon.  AppendWack supports DOS naming
  conventions: it does not append a back-slash if the path is empty,
  ends in a colon or if it ends in a back-slash already.

  AppendUncWack supports UNC naming conventions: it does not append a
  backslash if the path is empty or if it ends in a backslash already.

  AppendPathWack supports both DOS and UNC naming conventions, and uses the
  UNC naming convention if the string starts with double-wacks.

Arguments:

  Str - A buffer that holds the path, plus additional space for another
        backslash.

Return Value:

  none

--*/

PSTR
AppendWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str)
        return Str;

    last = Str;

    while (*Str) {
        last = Str;
        Str = _mbsinc (Str);
    }

    if (*last != '\\') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendWackW (
    IN      PWSTR Str
    )
{
    PCWSTR last;

    if (!Str)
        return Str;

    if (*Str) {
        Str = GetEndOfStringW (Str);
        last = Str - 1;
    } else {
        last = Str;
    }

    if (*last != '\\') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendDosWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str || !(*Str))
        return Str;

    do {
        last = Str;
        Str = _mbsinc (Str);
    } while (*Str);

    if (*last != '\\' && *last != ':') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendDosWackW (
    IN      PWSTR Str
    )
{
    PWSTR last;

    if (!Str || !(*Str))
        return Str;

    Str = GetEndOfStringW (Str);
    last = Str - 1;

    if (*last != L'\\' && *last != L':') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendUncWackA (
    IN      PSTR Str
    )
{
    PCSTR last;

    if (!Str || !(*Str))
        return Str;

    do {
        last = Str;
        Str = _mbsinc (Str);
    } while (*Str);

    if (*last != '\\') {
        *Str = '\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PWSTR
AppendUncWackW (
    IN      PWSTR Str
    )
{
    PWSTR last;

    if (!Str || !(*Str))
        return Str;

    Str = GetEndOfStringW (Str);
    last = Str - 1;

    if (*last != L'\\') {
        *Str = L'\\';
        Str++;
        *Str = 0;
    }

    return Str;
}


PSTR
AppendPathWackA (
    IN      PSTR Str
    )
{
    if (!Str) {
        return Str;
    }

    if (Str[0] == '\\' && Str[1] == '\\') {
        return AppendUncWackA (Str);
    }

    return AppendDosWackA (Str);
}


PWSTR
AppendPathWackW (
    IN      PWSTR Str
    )
{
    if (!Str) {
        return Str;
    }

    if (Str[0] == L'\\' && Str[1] == L'\\') {
        return AppendUncWackW (Str);
    }

    return AppendDosWackW (Str);
}


DWORD
pGetStringsTotalSizeA (
    IN      va_list args
    )
{
    DWORD size = 0;
    PCSTR source;

    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        size += ByteCountA (source) + DWSIZEOF(CHAR);
    }

    return size;
}

DWORD
pGetStringsTotalSizeW (
    IN      va_list args
    )
{
    DWORD size = 0;
    PCWSTR source;

    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        size += ByteCountW (source) + DWSIZEOF(WCHAR);
    }

    return size;
}


PSTR
pJoinPathsInBufferA (
    OUT     PSTR Buffer,
    IN      va_list args
    )
{
    PSTR end;
    PSTR endMinusOne;
    PCSTR source;
    PCSTR p;
    INT counter;

    *Buffer = 0;

    counter = 0;
    p = end = Buffer;
    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        if (counter > 0) {
            endMinusOne = _mbsdec2 (p, end);
            if (endMinusOne) {
                if (_mbsnextc (source) == '\\') {
                    if (_mbsnextc (endMinusOne) == '\\') {
                        source++;
                    }
                } else {
                    if (_mbsnextc (endMinusOne) != '\\') {
                        *end = '\\';
                        end++;
                        *end = 0;
                    }
                }
            }
        }
        if (*source) {
            p = end;
            end = StringCatA (end, source);
        }
        counter++;
    }

    return end;
}

PWSTR
pJoinPathsInBufferW (
    OUT     PWSTR Buffer,
    IN      va_list args
    )
{
    PWSTR end;
    PWSTR endMinusOne;
    PCWSTR source;
    PCWSTR p;
    INT counter;

    *Buffer = 0;

    counter = 0;
    p = end = Buffer;
    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        if (counter > 0) {
            endMinusOne = end > p ? end - 1 : NULL;
            if (endMinusOne) {
                if (*source == L'\\') {
                    if (*endMinusOne == L'\\') {
                        source++;
                    }
                } else {
                    if (*endMinusOne != L'\\') {
                        *end = L'\\';
                        end++;
                        *end = 0;
                    }
                }
            }
        }
        if (*source) {
            p = end;
            end = StringCatW (end, source);
        }
        counter++;
    }

    return end;
}


PSTR
_cdecl
RealJoinPathsInPoolExA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    DWORD size;
    PSTR dest;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (size == 0) {
        return NULL;
    }

    dest = (PSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pJoinPathsInBufferA (dest, args);
    va_end (args);

    return dest;
}


PWSTR
_cdecl
RealJoinPathsInPoolExW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    DWORD size;
    PWSTR dest;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (size == 0) {
        return NULL;
    }

    dest = (PWSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);
    va_start (args, Pool);
    pJoinPathsInBufferW (dest, args);
    va_end (args);

    return dest;
}


BOOL
JoinPathsExA (
    IN OUT      PGROWBUFFER Gb,
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (size == 0) {
        return FALSE;
    }

    end = (PSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pJoinPathsInBufferA (end, args);
    va_end (args);

    //
    // adjust Gb->End if resulting path is actually shorter than predicted
    //
    MYASSERT ((PBYTE)end >= Gb->Buf && (PBYTE)(end + 1) <= Gb->Buf + Gb->End);
    Gb->End = (DWORD)((PBYTE)(end + 1) - Gb->Buf);

    return TRUE;
}

BOOL
JoinPathsExW (
    IN OUT      PGROWBUFFER Gb,
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (size == 0) {
        return FALSE;
    }

    end = (PWSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pJoinPathsInBufferW (end, args);
    va_end (args);

    //
    // adjust Gb->End if resulting path is actually shorter than predicted
    //
    MYASSERT ((PBYTE)end >= Gb->Buf && (PBYTE)(end + 1) <= Gb->Buf + Gb->End);
    Gb->End = (DWORD)((PBYTE)(end + 1) - Gb->Buf);

    return TRUE;
}


PSTR
pBuildPathInBufferA (
    OUT     PSTR Buffer,
    IN      va_list args
    )
{
    PCSTR source;
    INT counter;

    *Buffer = 0;

    counter = 0;
    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        if (counter > 0) {
            *Buffer++ = '\\';
            *Buffer = 0;
        }
        Buffer = StringCatA (Buffer, source);
        counter++;
    }

    return Buffer;
}

PWSTR
pBuildPathInBufferW (
    OUT     PWSTR Buffer,
    IN      va_list args
    )
{
    PCWSTR source;
    INT counter;

    *Buffer = 0;

    counter = 0;
    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        if (counter > 0) {
            *Buffer++ = L'\\';
            *Buffer = 0;
        }
        Buffer = StringCatW (Buffer, source);
        counter++;
    }

    return Buffer;
}


DWORD
BuildPathA (
    OUT     PSTR Buffer,            OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    va_start (args, SizeInBytes);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return 0;
    }

    if (!Buffer) {
        return size;
    }

    if (SizeInBytes < size) {
        //
        // buffer too small
        //
        return 0;
    }

    va_start (args, SizeInBytes);
    end = pBuildPathInBufferA (Buffer, args);
    va_end (args);

    MYASSERT (size == (DWORD)((PBYTE)(end + 1) - (PBYTE)Buffer));
    return size;
}

DWORD
BuildPathW (
    OUT     PWSTR Buffer,           OPTIONAL
    IN      DWORD SizeInBytes,      OPTIONAL
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    va_start (args, SizeInBytes);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return 0;
    }

    if (!Buffer) {
        return size;
    }

    if (SizeInBytes < size) {
        //
        // buffer too small
        //
        return 0;
    }

    va_start (args, SizeInBytes);
    end = pBuildPathInBufferW (Buffer, args);
    va_end (args);

    MYASSERT (size == (DWORD)((PBYTE)(end + 1) - (PBYTE)Buffer));
    return size;
}


BOOL
BuildPathExA (
    IN OUT  PGROWBUFFER Gb,
    ...
    )
{
    PSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return FALSE;
    }

    end = (PSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pBuildPathInBufferA (end, args);
    va_end (args);

    MYASSERT ((PBYTE)(end + 1) == Gb->Buf + Gb->End);
    return (size != 0);
}

BOOL
BuildPathExW (
    IN OUT  PGROWBUFFER Gb,
    ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;

    MYASSERT (Gb);
    if (!Gb) {
        return FALSE;
    }

    va_start (args, Gb);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return FALSE;
    }

    end = (PWSTR) GbGrow (Gb, size);
    if (!end) {
        return FALSE;
    }

    va_start (args, Gb);
    end = pBuildPathInBufferW (end, args);
    va_end (args);

    MYASSERT ((PBYTE)(end + 1) == Gb->Buf + Gb->End);
    return (size != 0);
}


PSTR
RealBuildPathInPoolA (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    PSTR dest;
    DWORD size;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeA (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return NULL;
    }

    dest = (PSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pBuildPathInBufferA (dest, args);
    va_end (args);

    return dest;
}

PWSTR
RealBuildPathInPoolW (
    IN      PMHANDLE Pool,        OPTIONAL
    ...
    )
{
    PWSTR dest;
    DWORD size;
    va_list args;

    if (!Pool) {
        Pool = g_PathsPool;
    }

    va_start (args, Pool);
    size = pGetStringsTotalSizeW (args);
    va_end (args);

    if (!size) {
        //
        // no args
        //
        return NULL;
    }

    dest = (PWSTR) PmGetAlignedMemory (Pool, size);
    MYASSERT (dest);

    va_start (args, Pool);
    pBuildPathInBufferW (dest, args);
    va_end (args);

    return dest;
}


PSTR
RealAllocPathStringA (
    IN      DWORD Tchars
    )
{
    PSTR str;

    if (Tchars == 0) {
        Tchars = MAX_MBCHAR_PATH;
    }

    str = (PSTR) PmGetAlignedMemory (g_PathsPool, Tchars);

    str [0] = 0;

    return str;
}


PWSTR
RealAllocPathStringW (
    IN      DWORD Tchars
    )
{
    PWSTR str;

    if (Tchars == 0) {
        Tchars = MAX_WCHAR_PATH;
    }

    str = (PWSTR) PmGetAlignedMemory (g_PathsPool, Tchars * sizeof (WCHAR));

    str [0] = 0;

    return str;
}

VOID
RealSplitPathA (
    IN      PCSTR Path,
    OUT     PSTR *DrivePtr,
    OUT     PSTR *PathPtr,
    OUT     PSTR *FileNamePtr,
    OUT     PSTR *ExtPtr
    )
{
    CHAR drive[_MAX_DRIVE];
    CHAR dir[_MAX_DIR];
    CHAR fileName[_MAX_FNAME];
    CHAR ext[_MAX_EXT];

    _splitpath (Path, drive, dir, fileName, ext);

    if (DrivePtr) {
        *DrivePtr = PmDuplicateStringA (g_PathsPool, drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PmDuplicateStringA (g_PathsPool, dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PmDuplicateStringA (g_PathsPool, fileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PmDuplicateStringA (g_PathsPool, ext);
        MYASSERT (*ExtPtr);
    }
}


VOID
RealSplitPathW (
    IN      PCWSTR Path,
    OUT     PWSTR *DrivePtr,
    OUT     PWSTR *PathPtr,
    OUT     PWSTR *FileNamePtr,
    OUT     PWSTR *ExtPtr
    )
{
    WCHAR drive[_MAX_DRIVE];
    WCHAR dir[_MAX_DIR];
    WCHAR fileName[_MAX_FNAME];
    WCHAR ext[_MAX_EXT];

    _wsplitpath (Path, drive, dir, fileName, ext);

    if (DrivePtr) {
        *DrivePtr = PmDuplicateStringW (g_PathsPool, drive);
        MYASSERT (*DrivePtr);
    }

    if (PathPtr) {
        *PathPtr = PmDuplicateStringW (g_PathsPool, dir);
        MYASSERT (*PathPtr);
    }

    if (FileNamePtr) {
        *FileNamePtr = PmDuplicateStringW (g_PathsPool, fileName);
        MYASSERT (*FileNamePtr);
    }

    if (ExtPtr) {
        *ExtPtr = PmDuplicateStringW (g_PathsPool, ext);
        MYASSERT (*ExtPtr);
    }
}


PSTR
RealDuplicatePathStringA (
    IN      PCSTR Path,
    IN      DWORD ExtraBytes
    )
{
    PSTR str;

    str = PmGetAlignedMemory (
                g_PathsPool,
                SizeOfStringA (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyA (str, Path);

    return str;
}


PWSTR
RealDuplicatePathStringW (
    IN      PCWSTR Path,
    IN      DWORD ExtraBytes
    )
{
    PWSTR str;

    str = PmGetAlignedMemory (
                g_PathsPool,
                SizeOfStringW (Path) + ExtraBytes
                );

    MYASSERT (str);

    StringCopyW (str, Path);

    return str;
}


BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    )
{
    DWORD bufferSize;
    DWORD pathSize;
    PSTR  currPathEnd;

    if (PathEnum == NULL) {
        return FALSE;
    }
    bufferSize = pathSize = GetEnvironmentVariableA ("PATH", NULL, 0);
    bufferSize *= 2;
    if (AdditionalPath != NULL) {
        bufferSize += SizeOfStringA (AdditionalPath);
    }
    if (SysDir != NULL) {
        bufferSize += SizeOfStringA (SysDir);
    }
    if (WinDir != NULL) {
        bufferSize += SizeOfStringA (WinDir);
    }
    PathEnum->BufferPtr = HeapAlloc (g_hHeap, 0, bufferSize);
    if (PathEnum->BufferPtr == NULL) {
        return FALSE;
    }
    PathEnum->BufferPtr [0] = 0;
    if (AdditionalPath != NULL) {
        StringCopyA (PathEnum->BufferPtr, AdditionalPath);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (SysDir != NULL) {
        StringCatA (PathEnum->BufferPtr, SysDir);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (WinDir != NULL) {
        StringCatA (PathEnum->BufferPtr, WinDir);
        StringCatA (PathEnum->BufferPtr, ";");
    }
    if (IncludeEnvPath) {
        currPathEnd = GetEndOfStringA (PathEnum->BufferPtr);
        GetEnvironmentVariableA ("PATH", currPathEnd, pathSize);
    }

    PathEnum->PtrNextPath = PathEnum-> BufferPtr;
    return EnumNextPathA (PathEnum);
}


BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    )
{
    PSTR currPathEnd;

    if (PathEnum->PtrNextPath == NULL) {
        AbortPathEnumA (PathEnum);
        return FALSE;
    }
    PathEnum->PtrCurrPath = PathEnum->PtrNextPath;

    PathEnum->PtrNextPath = _mbschr (PathEnum->PtrNextPath, ';');
    if (PathEnum->PtrNextPath == NULL) {
        return TRUE;
    }
    currPathEnd = PathEnum->PtrNextPath;
    PathEnum->PtrNextPath = _mbsinc (PathEnum->PtrNextPath);
    *currPathEnd = 0;
    if (*(PathEnum->PtrNextPath) == 0) {
        PathEnum->PtrNextPath = NULL;
    }

    if (*(PathEnum->PtrCurrPath) == 0) {
        //
        // We found an empty path segment. Skip it.
        //
        return EnumNextPathA (PathEnum);
    }

    return TRUE;
}


BOOL
AbortPathEnumA (
    IN OUT  PPATH_ENUMA PathEnum
    )
{
    if (PathEnum->BufferPtr != NULL) {
        HeapFree (g_hHeap, 0, PathEnum->BufferPtr);
        PathEnum->BufferPtr = NULL;
    }
    return TRUE;
}


BOOL
EnumFirstPathExW (
    OUT     PPATH_ENUMW PathEnum,
    IN      PCWSTR AdditionalPath,
    IN      PCWSTR WinDir,
    IN      PCWSTR SysDir,
    IN      BOOL IncludeEnvPath
    )
{
    DWORD bufferSize;
    DWORD pathSize;
    PWSTR  currPathEnd;

    if (PathEnum == NULL) {
        return FALSE;
    }
    bufferSize = pathSize = GetEnvironmentVariableW (L"PATH", NULL, 0);
    bufferSize *= 2;
    if (AdditionalPath != NULL) {
        bufferSize += SizeOfStringW (AdditionalPath);
    }
    if (SysDir != NULL) {
        bufferSize += SizeOfStringW (SysDir);
    }
    if (WinDir != NULL) {
        bufferSize += SizeOfStringW (WinDir);
    }
    PathEnum->BufferPtr = HeapAlloc (g_hHeap, 0, bufferSize);
    if (PathEnum->BufferPtr == NULL) {
        return FALSE;
    }
    PathEnum->BufferPtr [0] = 0;
    if (AdditionalPath != NULL) {
        StringCopyW (PathEnum->BufferPtr, AdditionalPath);
        StringCatW (PathEnum->BufferPtr, L";");
    }
    if (SysDir != NULL) {
        StringCatW (PathEnum->BufferPtr, SysDir);
        StringCatW (PathEnum->BufferPtr, L";");
    }
    if (WinDir != NULL) {
        StringCatW (PathEnum->BufferPtr, WinDir);
        StringCatW (PathEnum->BufferPtr, L";");
    }
    if (IncludeEnvPath) {
        currPathEnd = GetEndOfStringW (PathEnum->BufferPtr);
        GetEnvironmentVariableW (L"PATH", currPathEnd, pathSize);
    }

    PathEnum->PtrNextPath = PathEnum-> BufferPtr;
    return EnumNextPathW (PathEnum);
}


BOOL
EnumNextPathW (
    IN OUT  PPATH_ENUMW PathEnum
    )
{
    PWSTR currPathEnd;

    if (PathEnum->PtrNextPath == NULL) {
        AbortPathEnumW (PathEnum);
        return FALSE;
    }
    PathEnum->PtrCurrPath = PathEnum->PtrNextPath;

    PathEnum->PtrNextPath = wcschr (PathEnum->PtrNextPath, L';');
    if (PathEnum->PtrNextPath == NULL) {
        return TRUE;
    }
    currPathEnd = PathEnum->PtrNextPath;
    PathEnum->PtrNextPath ++;
    *currPathEnd = 0;
    if (*(PathEnum->PtrNextPath) == 0) {
        PathEnum->PtrNextPath = NULL;
    }

    if (*(PathEnum->PtrCurrPath) == 0) {
        //
        // We found an empty path segment. Skip it.
        //
        return EnumNextPathW (PathEnum);
    }

    return TRUE;
}


BOOL
AbortPathEnumW (
    IN OUT  PPATH_ENUMW PathEnum
    )
{
    if (PathEnum->BufferPtr != NULL) {
        HeapFree (g_hHeap, 0, PathEnum->BufferPtr);
        PathEnum->BufferPtr = NULL;
    }
    return TRUE;
}


VOID
FreePathStringExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCSTR Path          OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PmReleaseMemory (Pool, (PSTR) Path);
    }
}


VOID
FreePathStringExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    )
{
    if (Path) {
        if (!Pool) {
            Pool = g_PathsPool;
        }

        PmReleaseMemory (Pool, (PWSTR) Path);
    }
}



/*++

Routine Description:

  PushError and PopError push the error code onto a stack or pull the
  last pushed error code off the stack.  PushError uses GetLastError
  and PopError uses SetLastError to modify the last error value.

Arguments:

  none

Return Value:

  none

--*/


VOID
PushNewError (DWORD dwError)
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = dwError;
    g_dwStackPos++;
}

VOID
PushError (VOID)
{
    if (g_dwStackPos == MAX_STACK)
        return;

    g_dwErrorStack[g_dwStackPos] = GetLastError ();
    g_dwStackPos++;
}

DWORD
PopError (VOID)
{
    if (!g_dwStackPos)
        return GetLastError();

    g_dwStackPos--;
    SetLastError (g_dwErrorStack[g_dwStackPos]);

    return g_dwErrorStack[g_dwStackPos];
}



/*++

Routine Description:

  GetHexDigit is a simple base 16 ASCII to int convertor.  The
  convertor is case-insensitive.

Arguments:

  c - Character to convert

Return Value:

  Base 16 value corresponding to character supplied, or -1 if
  the character is not 0-9, A-F or a-f.

--*/

int
GetHexDigit (IN  int c)

{
    if (c >= '0' && c <= '9')
        return (c - '0');

    c = towlower ((wint_t) c);
    if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);

    return -1;
}


/*++

Routine Description:

  _tcsnum is similar to strtoul, except is figures out which base
  the number should be calculated from.  It supports decimal and
  hexadecimal numbers (using the 0x00 notation).  The return
  value is the decoded value, or 0 if a syntax error was found.

Arguments:

  szNum - Pointer to the string holding the number.  This number
          can be either decimal (a series of 0-9 characters), or
          hexadecimal (a series of 0-9, A-F or a-f characters,
          prefixed with 0x or 0X).

Return Value:

  The decoded unsigned long value, or zero if a syntax error was
  found.

--*/

DWORD
_mbsnum (IN PCSTR szNum)

{
    unsigned int d = 0;
    int i;

    if (szNum[0] == '0' && OURTOLOWER (szNum[1]) == 'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + (UINT)i;
            szNum++;
        }
    }

    else  {
        // Get decimal value
        while (*szNum >= '0' && *szNum <= '9')  {
            d = d * 10 + (*szNum - '0');
            szNum++;
        }
    }

    return d;
}


DWORD
_wcsnum (
    IN PCWSTR szNum
    )

{
    unsigned int d = 0;
    int i;

    if (szNum[0] == L'0' && towlower (szNum[1]) == L'x') {
        // Get hex value
        szNum += 2;

        while ((i = GetHexDigit ((int) *szNum)) != -1) {
            d = d * 16 + (UINT)i;
            szNum++;
        }
    }

    else  {
        // Get decimal value
        while (*szNum >= L'0' && *szNum <= L'9')  {
            d = d * 10 + (*szNum - L'0');
            szNum++;
        }
    }

    return d;
}


/*++

Routine Description:

  StringCat is a lstrcat-type routine. It returns the pointer to the end
  of a string instead of the beginning, is faster, and has the proper types
  to keep lint happy.

Arguments:

  Destination - A pointer to a caller-allocated buffer that may point
                anywhere within the string to append to
  Source      - A pointer to a string that is appended to Destination

Return Value:

  A pointer to the NULL terminator within the Destination string.

--*/

PSTR
StringCatA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    )
{
    PCSTR current = Source;
    PCSTR end;

    //
    // Advance Destination to end of string
    //

    Destination = GetEndOfStringA (Destination);

    while (*current) {
        *Destination++ = *current++;    //lint !e613
    }

    //
    // Make sure DBCS string is properly terminated
    //

    end = current;
    current--;

    while (current >= Source) {

        if (!IsLeadByte (current)) {
            //
            // destEnd is correct
            //
            break;
        }

        current--;
    }

    if (!((end - current) & 1)) {
        Destination--;  //lint !e794
    }

    *Destination = 0;   //lint !e794

    return Destination;
}


PWSTR
StringCatW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    )

{
    //
    // Advance Destination to end of string
    //

    Destination = GetEndOfStringW (Destination);

    //
    // Copy string
    //

    while (*Source) {
        *Destination++ = *Source++;
    }

    *Destination = 0;

    return Destination;
}



/*++

Routine Description:

  _tcsistr is a case-insensitive version of _tcsstr.

Arguments:

  szStr    - A pointer to the larger string, which may hold szSubStr
  szSubStr - A pointer to a string that may be enclosed in szStr

Return Value:

  A pointer to the first occurance of szSubStr in szStr, or NULL if
  no match is found.

--*/


PCSTR
_mbsistr (PCSTR mbstrStr, PCSTR mbstrSubStr)

{
    PCSTR mbstrStart, mbstrStrPos, mbstrSubStrPos;
    PCSTR mbstrEnd;

    mbstrEnd = (PSTR) ((LPBYTE) mbstrStr + ByteCountA (mbstrStr) - ByteCountA (mbstrSubStr));

    for (mbstrStart = mbstrStr ; mbstrStart <= mbstrEnd ; mbstrStart = _mbsinc (mbstrStart)) {
        mbstrStrPos = mbstrStart;
        mbstrSubStrPos = mbstrSubStr;

        while (*mbstrSubStrPos &&
               OURTOLOWER ((MBCHAR) _mbsnextc (mbstrSubStrPos)) == OURTOLOWER ((MBCHAR) _mbsnextc (mbstrStrPos)))
        {
            mbstrStrPos = _mbsinc (mbstrStrPos);
            mbstrSubStrPos = _mbsinc (mbstrSubStrPos);
        }

        if (!(*mbstrSubStrPos))
            return mbstrStart;
    }

    return NULL;
}


PCWSTR
_wcsistr (PCWSTR wstrStr, PCWSTR wstrSubStr)

{
    PCWSTR wstrStart, wstrStrPos, wstrSubStrPos;
    PCWSTR wstrEnd;

    wstrEnd = (PWSTR) ((LPBYTE) wstrStr + ByteCountW (wstrStr) - ByteCountW (wstrSubStr));

    for (wstrStart = wstrStr ; wstrStart <= wstrEnd ; wstrStart++) {
        wstrStrPos = wstrStart;
        wstrSubStrPos = wstrSubStr;

        while (*wstrSubStrPos &&
               towlower (*wstrSubStrPos) == towlower (*wstrStrPos))
        {
            wstrStrPos++;
            wstrSubStrPos++;
        }

        if (!(*wstrSubStrPos))
            return wstrStart;
    }

    return NULL;
}

/*++

Routine Description:

  StringCompareAB compares a string against a string between to string
  pointers

Arguments:

  String - Specifies the string to compare

  Start - Specifies the start of the string to compare against

  end - Specifies the end of the string to compare against.  The character
        pointed to by End is not included in the comparision.

Return Value:

  Less than zero: String is numerically less than the string between Start and
                  End

  Zero: String matches the string between Start and End identically

  Greater than zero: String is numerically greater than the string between
                     Start and End

--*/

INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (_mbsnextc (String) != _mbsnextc (Start)) {
            break;
        }

        String = _mbsinc (String);
        Start = _mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return (INT) (_mbsnextc (Start) - _mbsnextc (String));
}

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (*String != *Start) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return *Start - *String;
}


BOOL
StringMatchA (
    IN      PCSTR String1,
    IN      PCSTR String2
    )

/*++

Routine Description:

  StringMatchA is an optimized string compare.  Usually a comparison is used to
  see if two strings are identical, and the numeric releationships aren't
  important. This routine exploits that fact and does a byte-by-byte compare.

Arguments:

  String1 - Specifies the first string to compare
  String2 - Specifies the second string to compare

Return Value:

  TRUE if the strings match identically, FALSE otherwise.

--*/

{
    while (*String1) {
        if (*String1 != *String2) {
            return FALSE;
        }

        String1++;
        String2++;
    }

    if (*String2) {
        return FALSE;
    }

    return TRUE;
}


BOOL
StringMatchABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )

/*++

Routine Description:

  StringMatchABA is an optimized string compare.  Usually a comparison is
  used to see if two strings are identical, and the numeric releationships
  aren't important. This routine exploits that fact and does a byte-by-byte
  compare.

Arguments:

  String - Specifies the first string to compare
  Start  - Specifies the beginning of the second string to compare
  End    - Specifies the end of the second string to compare (points to one
           character beyond the last valid character of the second string)

Return Value:

  TRUE if the strings match identically, FALSE otherwise.  If End is equal
  or less than Start, the return value is always TRUE.

--*/

{
    while (*String && Start < End) {
        if (*String != *Start) {
            return FALSE;
        }

        String++;
        Start++;
    }

    if (Start < End && *Start) {
        return FALSE;
    }

    return TRUE;
}


INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    while (*String && Start < End) {
        if (OURTOLOWER ((INT)(_mbsnextc (String))) != OURTOLOWER ((INT)(_mbsnextc (Start)))) {
            break;
        }

        String = _mbsinc (String);
        Start = _mbsinc (Start);
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return (OURTOLOWER ((INT)(_mbsnextc (Start))) - OURTOLOWER ((INT)(_mbsnextc (String))));
}

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    while (*String && Start < End) {
        if (towlower (*String) != towlower (*Start)) {
            break;
        }

        String++;
        Start++;
    }

    if (Start == End && *String == 0) {
        return 0;
    }

    return towlower (*Start) - towlower (*String);
}



VOID
_setmbchar (
    IN OUT  PSTR Str,
    IN      MBCHAR c
    )

/*++

Routine Description:

  _setmbchar sets the character at the specified string position, shifting
  bytes if necessary to keep the string in tact.

Arguments:

  Str -  String
  c   -  Character to set

Return Value:

  none

--*/

{
    if (c < 256) {
        if (IsLeadByte (Str)) {
            //
            // Delete one byte from the string
            //

            MoveMemory (Str, Str+1, SizeOfStringA (Str+2) + 1);
        }

        *Str = (CHAR) c;
    } else {
        if (!IsLeadByte (Str)) {
            //
            // Insert one byte in the string
            //

            MoveMemory (Str+1, Str, SizeOfStringA (Str));
        }

        *((WORD *) Str) = (WORD) c;
    }
}



/*++

Routine Description:

  GetNextRuleChar extracts the first character in the *p_szRule string,
  and determines the character value, decoding the ~xx~ syntax (which
  specifies any arbitrary value).

  GetNextRuleChar returns a complete character for SBCS and UNICODE, but
  it may return either a lead byte or non-lead byte for MBCS.  To indicate
  a MBCS character, two ~xx~ hex values are needed.

Arguments:

  p_szRule   - A pointer to a pointer; a caller-allocated buffer that
               holds the rule string.
  p_bFromHex - A pointer to a caller-allocated BOOL that receives TRUE
               when the return value was decoded from the <xx> syntax.

Return Value:

  The decoded character; *p_bFromHex identifies if the return value was

  a literal or was a hex-encoded character.

--*/


MBCHAR
GetNextRuleCharA (
    IN OUT  PCSTR *PtrToRule,
    OUT     BOOL *FromHex
    )
{
    MBCHAR ch;
    MBCHAR Value;
    INT i;
    PCSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (_mbsnextc (StartPtr) == '~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule && i < 8 ; i++) {

            ch = _mbsnextc (*PtrToRule);
            *PtrToRule += 1;

            if (ch == '~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            Value *= 16;

            if (ch >= '0' && ch <= '9') {
                Value += ch - '0';
            } else if (ch >= 'a' && ch <= 'f') {
                Value += ch - 'a' + 10;
            } else if (ch >= 'A' && ch <= 'F') {
                Value += ch - 'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGA ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = _mbsinc (StartPtr);
    return _mbsnextc (StartPtr);
}


WCHAR
GetNextRuleCharW (
    IN OUT  PCWSTR *PtrToRule,
    OUT     BOOL *FromHex
    )

{
    WCHAR ch;
    WCHAR Value;
    INT i;
    PCWSTR StartPtr;

    StartPtr = *PtrToRule;

    if (FromHex) {
        *FromHex = FALSE;
    }

    if (*StartPtr == L'~') {

        *PtrToRule += 1;
        Value = 0;
        i = 0;

        for (i = 0 ; **PtrToRule && i < 8 ; i++) {

            ch = **PtrToRule;
            *PtrToRule += 1;

            if (ch == L'~') {
                if (FromHex) {
                    *FromHex = TRUE;
                }

                return Value;
            }

            Value *= 16;

            if (ch >= L'0' && ch <= L'9') {
                Value += ch - L'0';
            } else if (ch >= L'a' && ch <= L'f') {
                Value += ch - L'a' + 10;
            } else if (ch >= L'A' && ch <= L'F') {
                Value += ch - L'A' + 10;
            } else {
                break;
            }

        }

        DEBUGMSGW ((DBG_WHOOPS, "Bad formatting in encoded string %s", StartPtr));
    }

    *PtrToRule = StartPtr + 1;
    return *StartPtr;
}


/*++

Routine Description:

  DecodeRuleChars takes a complete rule string (szRule), possibly
  encoded with hex-specified character values (~xx~).  The output

  string contains unencoded characters.

Arguments:

  szRule    - A caller-allocated buffer, big enough to hold an
              unencoded rule.  szRule can be equal to szEncRule.
  szEncRule - The string holding a possibly encoded string.

Return Value:

  Equal to szRule.

--*/


PSTR
DecodeRuleCharsA (PSTR mbstrRule, PCSTR mbstrEncRule)

{
    MBCHAR c;
    PSTR mbstrOrgRule;

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    do  {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        *mbstrRule = (CHAR) c;
        mbstrRule++;        // MBCS->incomplete char will be finished in next loop iteration
    } while (c);

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsW (PWSTR wstrRule, PCWSTR wstrEncRule)

{
    WCHAR c;
    PWSTR wstrOrgRule;

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    do  {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        *wstrRule = c;
        wstrRule++;
    } while (c);

    return wstrOrgRule;
}


PSTR
DecodeRuleCharsABA (PSTR mbstrRule, PCSTR mbstrEncRule, PCSTR End)

{
    MBCHAR c;
    PSTR mbstrOrgRule;

    mbstrOrgRule = mbstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (mbstrEncRule < End) {
        c = GetNextRuleCharA (&mbstrEncRule, NULL);
        *mbstrRule = (CHAR) c;
        mbstrRule++;        // MBCS->incomplete char will be finished in next loop iteration
    }

    *mbstrRule = 0;

    return mbstrOrgRule;
}


PWSTR
DecodeRuleCharsABW (PWSTR wstrRule, PCWSTR wstrEncRule, PCWSTR End)

{
    WCHAR c;
    PWSTR wstrOrgRule;

    wstrOrgRule = wstrRule;

    //
    // Copy string, converting ~xx~ to a single char
    //

    while (wstrEncRule < End) {
        c = GetNextRuleCharW (&wstrEncRule, NULL);
        *wstrRule = c;
        wstrRule++;
    }

    *wstrRule = 0;

    return wstrOrgRule;
}



/*++

Routine Description:

  EncodeRuleChars takes an unencoded rule string (szRule), and
  converts it to a string possibly encoded with hex-specified
  character values (~xx~).  The output string contains encoded
  characters.

Arguments:

  szEncRule - A caller-allocated buffer, big enough to hold an
              encoded rule.  szEncRule CAN NOT be equal to szRule.
              One way to calculate a max buffer size for szEncRule
              is to use the following code:

                  allocsize = SizeOfString (szRule) * 6;

              In the worst case, each character in szRule will take
              six single-byte characters in szEncRule.  In the normal
              case, szEncRule will only be a few bytes bigger than
              szRule.

  szRule    - The string holding an unencoded string.

Return Value:

  Equal to szEncRule.

--*/

PSTR
EncodeRuleCharsExA (
    PSTR mbstrEncRule,
    PCSTR mbstrRule,
    PCSTR mbstrEncChars     OPTIONAL
    )

{
    PSTR mbstrOrgRule;
    static CHAR mbstrExclusions[] = "[]<>\'*$|:?\";,%";
    MBCHAR c;

    if (!mbstrEncChars) {
        mbstrEncChars = mbstrExclusions;
    }

    mbstrOrgRule = mbstrEncRule;

    while (*mbstrRule)  {
        c = _mbsnextc (mbstrRule);

        if (!_ismbcprint (c) || _mbschr (mbstrEncChars, c)) {

            // Escape unprintable or excluded character
            wsprintfA (mbstrEncRule, "~%X~", c);
            mbstrEncRule = GetEndOfStringA (mbstrEncRule);
            mbstrRule = _mbsinc (mbstrRule);
        }
        else {
            // Copy multibyte character
            if (IsLeadByte (mbstrRule)) {
                *mbstrEncRule = *mbstrRule;
                mbstrEncRule++;
                mbstrRule++;
            }

            *mbstrEncRule = *mbstrRule;
            mbstrEncRule++;
            mbstrRule++;
        }
    }

    *mbstrEncRule = 0;  //lint !e613

    return mbstrOrgRule;
}


PWSTR
EncodeRuleCharsExW (
    PWSTR wstrEncRule,
    PCWSTR wstrRule,
    PCWSTR wstrEncChars    OPTIONAL
    )
{
    PWSTR wstrOrgRule;
    static WCHAR wstrExclusions[] = L"[]<>\'*$|:?\";,%";
    WCHAR c;

    if (!wstrEncChars) {
        wstrEncChars = wstrExclusions;
    }

    wstrOrgRule = wstrEncRule;

    while (c = *wstrRule)   {   //lint !e720
        if (!iswprint (c) || wcschr (wstrEncChars, c)) {
            wsprintfW (wstrEncRule, L"~%X~", c);
            wstrEncRule = GetEndOfStringW (wstrEncRule);
        }
        else {
            *wstrEncRule = *wstrRule;
            wstrEncRule++;
        }

        wstrRule++;
    }

    *wstrEncRule = 0;

    return wstrOrgRule;
}


/*++

Routine Description:

  _tcsisprint is a string version of _istprint.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  Non-zero if szStr is made up only of printable characters.


--*/


int
_mbsisprint (PCSTR mbstrStr)

{
    while (*mbstrStr && _ismbcprint ((MBCHAR) _mbsnextc (mbstrStr))) {
        mbstrStr = _mbsinc (mbstrStr);
    }

    return *mbstrStr == 0;
}


int
_wcsisprint (PCWSTR wstrStr)

{
    while (*wstrStr && iswprint (*wstrStr)) {
        wstrStr++;
    }

    return *wstrStr == 0;
}


/*++

Routine Description:

  SkipSpace returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime isspace to determine what a whitespace character is.

Arguments:

  szStr    - A pointer to the string to examine

Return Value:

  A pointer to the first non-whitespace character in the string,
  or NULL if the string is made up of all whitespace characters
  or the string is empty.


--*/

PCSTR
SkipSpaceA (PCSTR mbstrStr)

{
    while (_ismbcspace ((MBCHAR) _mbsnextc (mbstrStr)))
        mbstrStr = _mbsinc (mbstrStr);

    return mbstrStr;
}


PCWSTR
SkipSpaceW (PCWSTR wstrStr)

{
    while (iswspace (*wstrStr))
        wstrStr++;

    return wstrStr;
}


/*++

Routine Description:

  SkipSpaceR returns a pointer to the next position within a string
  that does not have whitespace characters.  It uses the C
  runtime isspace to determine what a whitespace character is.

  This function is identical to SkipSpace except it works from
  right to left instead of left to right.

Arguments:

  StrBase - A pointer to the first character in the string
  Str     - A pointer to the end of the string, or NULL if the
            end is not known.

Return Value:

  A pointer to the first non-whitespace character in the string,
  as viewed from right to left, or NULL if the string is made up
  of all whitespace characters or the string is empty.


--*/

PCSTR
SkipSpaceRA (
    IN      PCSTR StrBase,
    IN      PCSTR Str           OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringA (StrBase);
    }

    if (*Str == 0) {    //lint !e613
        Str = _mbsdec2 (StrBase, Str);
        if (!Str) {
            return NULL;
        }
    }

    do {

        if (!_ismbcspace((MBCHAR) _mbsnextc(Str))) {
            return Str;
        }

    } while (Str = _mbsdec2(StrBase, Str)); //lint !e720

    return NULL;
}


PCWSTR
SkipSpaceRW (
    IN      PCWSTR StrBase,
    IN      PCWSTR Str          OPTIONAL
    )

{
    if (!Str) {
        Str = GetEndOfStringW (StrBase);
    }

    if (*Str == 0) {
        Str--;
        if (Str < StrBase) {
            return NULL;
        }
    }

    do {
        if (!iswspace(*Str)) {
            return Str;
        }

    } while (Str-- != StrBase);

    return NULL;
}


/*++

Routine Description:

  TruncateTrailingSpace trims the specified string after the
  very last non-space character, or empties the string if it
  contains only space characters.  This routine uses isspace
  to determine what a space is.

Arguments:

  Str - Specifies string to process

Return Value:

  none

--*/

VOID
TruncateTrailingSpaceA (
    IN OUT  PSTR Str
    )
{
    PSTR LastNonSpace;
    PSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!_ismbcspace ((MBCHAR) _mbsnextc (Str))) {
            LastNonSpace = Str;
        }

        Str = _mbsinc (Str);
    }

    if (LastNonSpace) {
        *_mbsinc (LastNonSpace) = 0;
    } else {
        *OrgStr = 0;
    }
}

VOID
TruncateTrailingSpaceW (
    IN OUT  PWSTR Str
    )
{
    PWSTR LastNonSpace;
    PWSTR OrgStr;

    OrgStr = Str;
    LastNonSpace = NULL;

    while (*Str) {
        if (!iswspace (*Str)) {
            LastNonSpace = Str;
        }

        Str++;
    }

    if (LastNonSpace) {
        *(LastNonSpace + 1) = 0;
    } else {
        *OrgStr = 0;
    }
}



/*++

Routine Description:

  IsPatternMatch compares a string against a pattern that may contain
  standard * or ? wildcards.

Arguments:

  wstrPattern  - A pattern possibly containing wildcards
  wstrStr      - The string to compare against the pattern

Return Value:

  TRUE when wstrStr and wstrPattern match when wildcards are expanded.
  FALSE if wstrStr does not match wstrPattern.

--*/

BOOL
IsPatternMatchA (
    IN     PCSTR strPattern,
    IN     PCSTR strStr
    )
{

    MBCHAR chSrc, chPat;

    while (*strStr) {
        chSrc = OURTOLOWER ((MBCHAR) _mbsnextc (strStr));
        chPat = OURTOLOWER ((MBCHAR) _mbsnextc (strPattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (strStr)) == '*') {
                strStr = _mbsinc (strStr);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (strPattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchA (_mbsinc (strPattern), strStr)) {
                return TRUE;
            }

            // Allow any character and continue
            strStr = _mbsinc (strStr);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        strStr = _mbsinc (strStr);
        strPattern = _mbsinc (strPattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (strPattern) == '*') {
        strPattern = _mbsinc (strPattern);
    }
    if (_mbsnextc (strPattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchW (
    IN     PCWSTR wstrPattern,
    IN     PCWSTR wstrStr
    )

{
    WCHAR chSrc, chPat;

    while (*wstrStr) {
        chSrc = towlower (*wstrStr);
        chPat = towlower (*wstrPattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (wstrPattern[1] == L'*')
                wstrPattern++;

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (wstrPattern[1]);
            if (!chPat)
                return TRUE;

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                wstrPattern++;
                if (IsPatternMatchW (wstrPattern, wstrStr))
                    return TRUE;

                // no, that didn't work, stick with star
                wstrPattern--;
            }

            //
            // Allow any character and continue
            //

            wstrStr++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat)
                return FALSE;
        }

        //
        // Advance when pattern character matches string character
        //

        wstrPattern++;
        wstrStr++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *wstrPattern;
    if (chPat && (chPat != L'*' || wstrPattern[1]))
        return FALSE;

    return TRUE;
}

BOOL
IsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    MBCHAR chSrc, chPat;

    while (*Contained) {
        chSrc = OURTOLOWER ((MBCHAR) _mbsnextc (Contained));
        chPat = OURTOLOWER ((MBCHAR) _mbsnextc (Container));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (Container)) == '*') {
                Container = _mbsinc (Container);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (Container))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternContainedA (_mbsinc (Container), Contained)) {
                return TRUE;
            }

            // Allow any character and continue
            Contained = _mbsinc (Contained);
            continue;
        } else if (chPat == '?') {
            if (chSrc == '*') {
                return FALSE;
            }
        } else {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        Contained = _mbsinc (Contained);
        Container = _mbsinc (Container);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (Container) == '*') {
        Container = _mbsinc (Container);
    }
    if (_mbsnextc (Container)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    while (*Contained) {

        if (*Container == L'*') {

            // Skip all asterisks that are grouped together
            while (Container[1] == L'*') {
                Container++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!Container[1]) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternContainedW (Container + 1, Contained)) {
                return TRUE;
            }

            // Allow any character and continue
            Contained++;
            continue;
        } else if (*Container == L'?') {
            if (*Contained == L'*') {
                return FALSE;
            }
        } else {
            if (*Container != *Contained) {
                return FALSE;
            }
        }
        Contained++;
        Container++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (*Container == '*') {
        Container++;
    }
    if (*Container) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchAB compares a string against a pattern that may contain
  standard * or ? wildcards.  It only processes the string up to the
  specified end.

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{

    MBCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = OURTOLOWER ((MBCHAR) _mbsnextc (Start));
        chPat = OURTOLOWER ((MBCHAR) _mbsnextc (Pattern));

        if (chPat == '*') {

            // Skip all asterisks that are grouped together
            while (_mbsnextc (_mbsinc (Start)) == '*') {
                Start = _mbsinc (Start);
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            if (!_mbsnextc (_mbsinc (Pattern))) {
                return TRUE;
            }

            // do recursive check for rest of pattern
            if (IsPatternMatchABA (_mbsinc (Pattern), Start, End)) {
                return TRUE;
            }

            // Allow any character and continue
            Start = _mbsinc (Start);
            continue;
        }
        if (chPat != '?') {
            if (chSrc != chPat) {
                return FALSE;
            }
        }
        Start = _mbsinc (Start);
        Pattern = _mbsinc (Pattern);
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (_mbsnextc (Pattern) == '*') {
        Pattern = _mbsinc (Pattern);
    }

    if (_mbsnextc (Pattern)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsPatternMatchABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )

{
    WCHAR chSrc, chPat;

    while (*Start && Start < End) {
        chSrc = towlower (*Start);
        chPat = towlower (*Pattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (Pattern[1] == L'*') {
                Pattern++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = towlower (Pattern[1]);
            if (!chPat) {
                return TRUE;
            }

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                Pattern++;
                if (IsPatternMatchABW (Pattern, Start, End)) {
                    return TRUE;
                }

                // no, that didn't work, stick with star
                Pattern--;
            }

            //
            // Allow any character and continue
            //

            Start++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat) {
                return FALSE;
            }
        }

        //
        // Advance when pattern character matches string character
        //

        Pattern++;
        Start++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *Pattern;
    if (chPat && (chPat != L'*' || Pattern[1])) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  IsPatternMatchEx compares a string against a pattern that may contain
  any of the following expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR String
    )
{
    PPARSEDPATTERNA Handle;
    BOOL b;

    Handle = CreateParsedPatternA (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternA (Handle, String);

    DestroyParsedPatternA (Handle);

    return b;
}

BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR String
    )
{
    PPARSEDPATTERNW Handle;
    BOOL b;

    Handle = CreateParsedPatternW (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternW (Handle, String);

    DestroyParsedPatternW (Handle);

    return b;
}

/*++

Routine Description:

  IsPatternMatchExAB compares a string against a pattern that may contain
  any of the following expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Pattern  - A pattern possibly containing wildcards
  Start    - The string to compare against the pattern
  End      - Specifies the end of Start

Return Value:

  TRUE when the string between Start and End matches Pattern when wildcards are expanded.
  FALSE if the pattern does not match.

--*/

BOOL
IsPatternMatchExABA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    )
{
    PPARSEDPATTERNA Handle;
    BOOL b;

    Handle = CreateParsedPatternA (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABA (Handle, Start, End);

    DestroyParsedPatternA (Handle);

    return b;
}

BOOL
IsPatternMatchExABW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    )
{
    PPARSEDPATTERNW Handle;
    BOOL b;

    Handle = CreateParsedPatternW (Pattern);
    if (!Handle) {
        return FALSE;
    }

    b = TestParsedPatternABW (Handle, Start, End);

    DestroyParsedPatternW (Handle);

    return b;
}

BOOL
pTestSetsA (
    IN      PCSTR Container,
    IN      PCSTR Contained,
    IN      BOOL ExcludeMode
    )
{
    MBCHAR ch;

    if (ExcludeMode) {
        if (!Contained) {
            return TRUE;
        }
        if (!Container) {
            return FALSE;
        }
    } else {
        if (!Container) {
            return TRUE;
        }
        if (!Contained) {
            return FALSE;
        }
    }

    while (*Contained) {
        ch = _mbsnextc (Contained);
        if (!pTestSetA (ch, Container, NULL)) {
            return FALSE;
        }
        Contained = _mbsinc (Contained);
    }
    return TRUE;
}

BOOL
pTestSetsW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained,
    IN      BOOL ExcludeMode
    )
{
    if (ExcludeMode) {
        if (!Contained) {
            return TRUE;
        }
        if (!Container) {
            return FALSE;
        }
    } else {
        if (!Container) {
            return TRUE;
        }
        if (!Contained) {
            return FALSE;
        }
    }

    while (*Contained) {
        if (!pTestSetW (*Contained, Container, NULL)) {
            return FALSE;
        }
        Contained ++;
    }
    return TRUE;
}

BOOL
pMatchSegmentA (
    IN      PSEGMENTA Source,
    IN      PSEGMENTA Destination
    )
{
    switch (Source->Type) {
    case SEGMENTTYPE_OPTIONAL:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            if (Source->Wildcard.MaxLen) {
                if ((Destination->Wildcard.MaxLen == 0) ||
                    (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen)
                    ) {
                    return FALSE;
                }
            }
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_REQUIRED:
            if (Source->Wildcard.MaxLen) {
                if (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen) {
                    return FALSE;
                }
            }
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetA (
                    _mbsnextc (Destination->Exact.LowerCasePhrase),
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_REQUIRED:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            if (!pTestSetsA (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsA (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetA (
                    _mbsnextc (Destination->Exact.LowerCasePhrase),
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_EXACTMATCH:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            return FALSE;
        case SEGMENTTYPE_EXACTMATCH:
            if (_mbsnextc (Destination->Exact.LowerCasePhrase) != _mbsnextc (Source->Exact.LowerCasePhrase)) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    default:
        return FALSE;
    }
}

BOOL
pMatchSegmentW (
    IN      PSEGMENTW Source,
    IN      PSEGMENTW Destination
    )
{
    switch (Source->Type) {
    case SEGMENTTYPE_OPTIONAL:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            if (Source->Wildcard.MaxLen) {
                if ((Destination->Wildcard.MaxLen == 0) ||
                    (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen)
                    ) {
                    return FALSE;
                }
            }
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_REQUIRED:
            if (Source->Wildcard.MaxLen) {
                if (Source->Wildcard.MaxLen < Destination->Wildcard.MaxLen) {
                    return FALSE;
                }
            }
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetW (
                    *Destination->Exact.LowerCasePhrase,
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_REQUIRED:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            if (!pTestSetsW (
                    Source->Wildcard.IncludeSet,
                    Destination->Wildcard.IncludeSet,
                    FALSE
                    )) {
                return FALSE;
            }
            if (!pTestSetsW (
                    Destination->Wildcard.ExcludeSet,
                    Source->Wildcard.ExcludeSet,
                    TRUE
                    )) {
                return FALSE;
            }
            return TRUE;
        case SEGMENTTYPE_EXACTMATCH:
            if (!pTestSetW (
                    *Destination->Exact.LowerCasePhrase,
                    Source->Wildcard.IncludeSet,
                    Source->Wildcard.ExcludeSet
                    )) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    case SEGMENTTYPE_EXACTMATCH:
        switch (Destination->Type) {
        case SEGMENTTYPE_OPTIONAL:
            return FALSE;
        case SEGMENTTYPE_REQUIRED:
            return FALSE;
        case SEGMENTTYPE_EXACTMATCH:
            if (*Destination->Exact.LowerCasePhrase != *Source->Exact.LowerCasePhrase) {
                return FALSE;
            }
            return TRUE;
        default:
            return FALSE;
        }
        break;
    default:
        return FALSE;
    }
}

BOOL
pIsOneParsedPatternContainedA (
    IN      PPATTERNPROPSA Container,
    IN      UINT StartContainer,
    IN      PPATTERNPROPSA Contained,
    IN      UINT StartContained,
    IN      BOOL SkipDotWithStar
    )
{
    UINT indexContainer = StartContainer;
    UINT indexContained = StartContained;
    PSEGMENTA containerSeg, containedSeg;

    if (StartContainer == Container->SegmentCount) {
        return FALSE;
    }

    while (indexContained < Contained->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        containedSeg = &Contained->Segment [indexContained];

        if (containerSeg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                indexContainer ++;
                if (indexContainer == Container->SegmentCount) {
                    return FALSE;
                }
                continue;
            }
            if (pIsOneParsedPatternContainedA (
                    Container,
                    indexContainer + 1,
                    Contained,
                    indexContained,
                    SkipDotWithStar
                    )) {
                return TRUE;
            }
            indexContained ++;
            continue;
        } else if (containerSeg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                return FALSE;
            }
        } else {
            if (!pMatchSegmentA (containerSeg, containedSeg)) {
                return FALSE;
            }
        }
        indexContainer ++;
        indexContained ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (indexContainer < Container->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        if (containerSeg->Type != SEGMENTTYPE_OPTIONAL) {
            if (SkipDotWithStar) {
                // we allow one dot to be able to match *.* with files without extensions
                if (containerSeg->Type == SEGMENTTYPE_EXACTMATCH) {
                    if (!pTestSetA (
                            _mbsnextc (containerSeg->Exact.LowerCasePhrase),
                            "..",
                            NULL
                            )) {
                        return FALSE;
                    } else {
                        // only one dot allowed
                        SkipDotWithStar = FALSE;
                    }
                } else {
                    return FALSE;
                }
            } else {
                return FALSE;
            }
        }
        indexContainer ++;
    }

    return TRUE;
}

BOOL
pIsOneParsedPatternContainedW (
    IN      PPATTERNPROPSW Container,
    IN      UINT StartContainer,
    IN      PPATTERNPROPSW Contained,
    IN      UINT StartContained,
    IN      BOOL SkipDotWithStar
    )
{
    UINT indexContainer = StartContainer;
    UINT indexContained = StartContained;
    PSEGMENTW containerSeg, containedSeg;

    if (StartContainer == Container->SegmentCount) {
        return FALSE;
    }

    while (indexContained < Contained->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        containedSeg = &Contained->Segment [indexContained];

        if (containerSeg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                indexContainer ++;
                if (indexContainer == Container->SegmentCount) {
                    return FALSE;
                }
                continue;
            }
            if (pIsOneParsedPatternContainedW (
                    Container,
                    indexContainer + 1,
                    Contained,
                    indexContained,
                    SkipDotWithStar
                    )) {
                return TRUE;
            }
            indexContained ++;
            continue;
        } else if (containerSeg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                return FALSE;
            }
        } else {
            if (!pMatchSegmentW (containerSeg, containedSeg)) {
                return FALSE;
            }
        }
        indexContainer ++;
        indexContained ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    while (indexContainer < Container->SegmentCount) {
        containerSeg = &Container->Segment [indexContainer];
        if (containerSeg->Type != SEGMENTTYPE_OPTIONAL) {
            if (SkipDotWithStar) {
                // we allow one dot to be able to match *.* with files without extensions
                if (containerSeg->Type == SEGMENTTYPE_EXACTMATCH) {
                    if (!pTestSetW (
                            *containerSeg->Exact.LowerCasePhrase,
                            L"..",
                            NULL
                            )) {
                        return FALSE;
                    } else {
                        // only one dot allowed
                        SkipDotWithStar = FALSE;
                    }
                } else {
                    return FALSE;
                }
            } else {
                return FALSE;
            }
        }
        indexContainer ++;
    }

    return TRUE;
}

BOOL
IsExplodedParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained,
    IN      BOOL SkipDotWithStar
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Contained->PatternCount ; u1++) {

        b = FALSE;
        for (u2 = 0 ; u2 < Container->PatternCount ; u2++) {

            b = pIsOneParsedPatternContainedA (
                    &Container->Pattern[u2],
                    0,
                    &Contained->Pattern[u1],
                    0,
                    SkipDotWithStar
                    );
            if (b) break;
        }
        if (!b) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
IsExplodedParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained,
    IN      BOOL SkipDotWithStar
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Contained->PatternCount ; u1++) {

        b = FALSE;
        for (u2 = 0 ; u2 < Container->PatternCount ; u2++) {

            b = pIsOneParsedPatternContainedW (
                    &Container->Pattern[u2],
                    0,
                    &Contained->Pattern[u1],
                    0,
                    SkipDotWithStar
                    );
            if (b) break;
        }
        if (!b) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
pDoOneParsedPatternIntersectA (
    IN      PPATTERNPROPSA Pat1,
    IN      UINT StartPat1,
    IN      PPATTERNPROPSA Pat2,
    IN      UINT StartPat2,
    IN      BOOL IgnoreWackAtEnd
    )
{
    UINT indexPat1 = StartPat1;
    UINT indexPat2 = StartPat2;
    PSEGMENTA pat1Seg, pat2Seg;

    while ((indexPat1 < Pat1->SegmentCount) && (indexPat2 < Pat2->SegmentCount)) {
        pat1Seg = &Pat1->Segment [indexPat1];
        pat2Seg = &Pat2->Segment [indexPat2];

        if (pat1Seg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentA (pat1Seg, pat2Seg)) {
                indexPat1 ++;
                continue;
            }
            if (pDoOneParsedPatternIntersectA (
                    Pat1,
                    indexPat1 + 1,
                    Pat2,
                    indexPat2,
                    IgnoreWackAtEnd
                    )) {
                return TRUE;
            }
            indexPat2 ++;
            continue;
        }

        if (pat2Seg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentA (pat2Seg, pat1Seg)) {
                indexPat2 ++;
                continue;
            }
            if (pDoOneParsedPatternIntersectA (
                    Pat1,
                    indexPat1,
                    Pat2,
                    indexPat2 + 1,
                    IgnoreWackAtEnd
                    )) {
                return TRUE;
            }
            indexPat1 ++;
            continue;
        }

        if (pat1Seg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentA (pat1Seg, pat2Seg)) {
                return FALSE;
            }
            indexPat1 ++;
            indexPat2 ++;
            continue;
        }

        if (pat2Seg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentA (pat2Seg, pat1Seg)) {
                return FALSE;
            }
            indexPat1 ++;
            indexPat2 ++;
            continue;
        }

        if (!pMatchSegmentA (pat1Seg, pat2Seg)) {
            return FALSE;
        }
        indexPat1 ++;
        indexPat2 ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    if ((indexPat1 < Pat1->SegmentCount) && IgnoreWackAtEnd) {
        pat1Seg = &Pat1->Segment [indexPat1];
        if ((pat1Seg->Type == SEGMENTTYPE_EXACTMATCH) &&
            (StringMatchA (pat1Seg->Exact.LowerCasePhrase, "\\"))
            ) {
            indexPat1 ++;
        }
    }
    while (indexPat1 < Pat1->SegmentCount) {
        pat1Seg = &Pat1->Segment [indexPat1];
        if (pat1Seg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexPat1 ++;
    }

    if ((indexPat2 < Pat2->SegmentCount) && IgnoreWackAtEnd) {
        pat2Seg = &Pat2->Segment [indexPat2];
        if ((pat2Seg->Type == SEGMENTTYPE_EXACTMATCH) &&
            (StringMatchA (pat2Seg->Exact.LowerCasePhrase, "\\"))
            ) {
            indexPat2 ++;
        }
    }
    while (indexPat2 < Pat2->SegmentCount) {
        pat2Seg = &Pat2->Segment [indexPat2];
        if (pat2Seg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexPat2 ++;
    }

    return TRUE;
}

BOOL
pDoOneParsedPatternIntersectW (
    IN      PPATTERNPROPSW Pat1,
    IN      UINT StartPat1,
    IN      PPATTERNPROPSW Pat2,
    IN      UINT StartPat2,
    IN      BOOL IgnoreWackAtEnd
    )
{
    UINT indexPat1 = StartPat1;
    UINT indexPat2 = StartPat2;
    PSEGMENTW pat1Seg, pat2Seg;

    while ((indexPat1 < Pat1->SegmentCount) && (indexPat2 < Pat2->SegmentCount)) {
        pat1Seg = &Pat1->Segment [indexPat1];
        pat2Seg = &Pat2->Segment [indexPat2];

        if (pat1Seg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentW (pat1Seg, pat2Seg)) {
                indexPat1 ++;
                continue;
            }
            if (pDoOneParsedPatternIntersectW (
                    Pat1,
                    indexPat1 + 1,
                    Pat2,
                    indexPat2,
                    IgnoreWackAtEnd
                    )) {
                return TRUE;
            }
            indexPat2 ++;
            continue;
        }

        if (pat2Seg->Type == SEGMENTTYPE_OPTIONAL) {
            // see if we can match contained segment
            if (!pMatchSegmentW (pat2Seg, pat1Seg)) {
                indexPat2 ++;
                continue;
            }
            if (pDoOneParsedPatternIntersectW (
                    Pat1,
                    indexPat1,
                    Pat2,
                    indexPat2 + 1,
                    IgnoreWackAtEnd
                    )) {
                return TRUE;
            }
            indexPat1 ++;
            continue;
        }

        if (pat1Seg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentW (pat1Seg, pat2Seg)) {
                return FALSE;
            }
            indexPat1 ++;
            indexPat2 ++;
            continue;
        }

        if (pat2Seg->Type == SEGMENTTYPE_REQUIRED) {
            if (!pMatchSegmentW (pat2Seg, pat1Seg)) {
                return FALSE;
            }
            indexPat1 ++;
            indexPat2 ++;
            continue;
        }

        if (!pMatchSegmentW (pat1Seg, pat2Seg)) {
            return FALSE;
        }
        indexPat1 ++;
        indexPat2 ++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    if ((indexPat1 < Pat1->SegmentCount) && IgnoreWackAtEnd) {
        pat1Seg = &Pat1->Segment [indexPat1];
        if ((pat1Seg->Type == SEGMENTTYPE_EXACTMATCH) &&
            (StringMatchW (pat1Seg->Exact.LowerCasePhrase, L"\\"))
            ) {
            indexPat1 ++;
        }
    }
    while (indexPat1 < Pat1->SegmentCount) {
        pat1Seg = &Pat1->Segment [indexPat1];
        if (pat1Seg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexPat1 ++;
    }

    if ((indexPat2 < Pat2->SegmentCount) && IgnoreWackAtEnd) {
        pat2Seg = &Pat2->Segment [indexPat2];
        if ((pat2Seg->Type == SEGMENTTYPE_EXACTMATCH) &&
            (StringMatchW (pat2Seg->Exact.LowerCasePhrase, L"\\"))
            ) {
            indexPat2 ++;
        }
    }
    while (indexPat2 < Pat2->SegmentCount) {
        pat2Seg = &Pat2->Segment [indexPat2];
        if (pat2Seg->Type != SEGMENTTYPE_OPTIONAL) {
            return FALSE;
        }
        indexPat2 ++;
    }

    return TRUE;
}

BOOL
DoExplodedParsedPatternsIntersectExA (
    IN      PPARSEDPATTERNA Pat1,
    IN      PPARSEDPATTERNA Pat2,
    IN      BOOL IgnoreWackAtEnd
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Pat2->PatternCount ; u1++) {

        for (u2 = 0 ; u2 < Pat1->PatternCount ; u2++) {

            b = pDoOneParsedPatternIntersectA (
                    &Pat1->Pattern[u2],
                    0,
                    &Pat2->Pattern[u1],
                    0,
                    IgnoreWackAtEnd
                    );
            if (b) return TRUE;

            b = pDoOneParsedPatternIntersectA (
                    &Pat2->Pattern[u1],
                    0,
                    &Pat1->Pattern[u2],
                    0,
                    IgnoreWackAtEnd
                    );
            if (b) return TRUE;
        }
    }

    return FALSE;
}

BOOL
DoExplodedParsedPatternsIntersectExW (
    IN      PPARSEDPATTERNW Pat1,
    IN      PPARSEDPATTERNW Pat2,
    IN      BOOL IgnoreWackAtEnd
    )
{
    UINT u1, u2;
    BOOL b = FALSE;

    for (u1 = 0 ; u1 < Pat2->PatternCount ; u1++) {

        for (u2 = 0 ; u2 < Pat1->PatternCount ; u2++) {

            b = pDoOneParsedPatternIntersectW (
                    &Pat1->Pattern[u2],
                    0,
                    &Pat2->Pattern[u1],
                    0,
                    IgnoreWackAtEnd
                    );
            if (b) return TRUE;

            b = pDoOneParsedPatternIntersectW (
                    &Pat2->Pattern[u1],
                    0,
                    &Pat1->Pattern[u2],
                    0,
                    IgnoreWackAtEnd
                    );
            if (b) return TRUE;
        }
    }

    return FALSE;
}

PPARSEDPATTERNA
ExplodeParsedPatternExA (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PPARSEDPATTERNA Pattern
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    PPARSEDPATTERNA pattern;
    PPATTERNPROPSA oldProps, newProps;
    PSEGMENTA oldSeg, newSeg;
    UINT i, j, k, newPropsSize, charCountTmp, oldSegIndex, byteIndex;
    BOOL result = TRUE;

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = PmCreateNamedPoolEx ("Parsed Pattern", 512);
    }

    __try {

        pattern = (PPARSEDPATTERNA) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNA));
        ZeroMemory (pattern, sizeof (PARSEDPATTERNA));
        pattern->PatternCount = Pattern->PatternCount;
        pattern->Pool = pool;
        pattern->ExternalPool = externalPool;
        pattern->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                                pool,
                                                pattern->PatternCount * sizeof (PATTERNPROPSA)
                                                );

        for (i=0; i<pattern->PatternCount; i++) {
            oldProps = &Pattern->Pattern[i];
            newProps = &pattern->Pattern[i];
            ZeroMemory (newProps, sizeof (PATTERNPROPSA));
            // now let's walk oldProps to see how many segments we are
            // going to need
            newPropsSize = 0;
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    charCountTmp = CharCountA (oldSeg->Exact.LowerCasePhrase);
                    newPropsSize += (charCountTmp?charCountTmp:1);
                    break;
                case SEGMENTTYPE_REQUIRED:
                    newPropsSize += oldSeg->Wildcard.MaxLen;
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    if (oldSeg->Wildcard.MaxLen) {
                        newPropsSize += oldSeg->Wildcard.MaxLen;
                    } else {
                        newPropsSize ++;
                    }
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
            // now we allocate the required segments
            newProps->SegmentCount = newPropsSize;
            newProps->Segment = (PSEGMENTA) PmGetAlignedMemory (
                                                pool,
                                                newProps->SegmentCount * sizeof (SEGMENTA)
                                                );
            // now let's walk oldProps again and fill newProps segments.
            k = 0;
            newSeg = &newProps->Segment[k];
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                ZeroMemory (newSeg, sizeof (SEGMENTA));
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    oldSegIndex = CharCountA (oldSeg->Exact.LowerCasePhrase);
                    byteIndex = oldSeg->Exact.PhraseBytes;
                    if (!oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCSTR) PmGetAlignedMemory (
                                                                        pool, sizeof(CHAR)
                                                                        );
                            ((PSTR)newSeg->Exact.LowerCasePhrase) [0] = 0;
                            newSeg->Exact.PhraseBytes = 0;
                    } else {
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCSTR) PmGetAlignedMemory (
                                                                        pool, 3 * sizeof(CHAR)
                                                                        );
                            if (IsLeadByte (&oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex])) {
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[1] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[2] = 0;
                                newSeg->Exact.PhraseBytes = 2;
                            } else {
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [oldSeg->Exact.PhraseBytes - byteIndex];
                                byteIndex --;
                                ((PSTR)newSeg->Exact.LowerCasePhrase)[1] = 0;
                                newSeg->Exact.PhraseBytes = 1;
                            }
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    }
                    break;
                case SEGMENTTYPE_REQUIRED:
                    oldSegIndex = oldSeg->Wildcard.MaxLen;
                    while (oldSegIndex) {
                        ZeroMemory (newSeg, sizeof (SEGMENTA));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = 1;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        oldSegIndex --;
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    if (oldSeg->Wildcard.MaxLen) {
                        oldSegIndex = oldSeg->Wildcard.MaxLen;
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Wildcard.MaxLen = 1;
                            if (oldSeg->Wildcard.IncludeSet) {
                                newSeg->Wildcard.IncludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.IncludeSet);
                            }
                            if (oldSeg->Wildcard.ExcludeSet) {
                                newSeg->Wildcard.ExcludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.ExcludeSet);
                            }
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    } else {
                        ZeroMemory (newSeg, sizeof (SEGMENTA));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = oldSeg->Wildcard.MaxLen;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringA (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
        }
    }
    __finally {
        if (!result) {
            PmDestroyPool (pool);
            pattern = NULL;
        }
    }
    return pattern;
}

PPARSEDPATTERNW
ExplodeParsedPatternExW (
    IN      PMHANDLE Pool,      OPTIONAL
    IN      PPARSEDPATTERNW Pattern
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    PPARSEDPATTERNW pattern;
    PPATTERNPROPSW oldProps, newProps;
    PSEGMENTW oldSeg, newSeg;
    UINT i, j, k, newPropsSize, charCountTmp, oldSegIndex;
    BOOL result = TRUE;

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = PmCreateNamedPoolEx ("Parsed Pattern", 512);
    }

    __try {

        pattern = (PPARSEDPATTERNW) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNW));
        ZeroMemory (pattern, sizeof (PARSEDPATTERNW));
        pattern->PatternCount = Pattern->PatternCount;
        pattern->Pool = pool;
        pattern->ExternalPool = externalPool;
        pattern->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                                pool,
                                                pattern->PatternCount * sizeof (PATTERNPROPSW)
                                                );

        for (i=0; i<pattern->PatternCount; i++) {
            oldProps = &Pattern->Pattern[i];
            newProps = &pattern->Pattern[i];
            ZeroMemory (newProps, sizeof (PATTERNPROPSW));
            // now let's walk oldProps to see how many segments we are
            // going to need
            newPropsSize = 0;
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    charCountTmp = CharCountW (oldSeg->Exact.LowerCasePhrase);
                    newPropsSize += (charCountTmp?charCountTmp:1);
                    break;
                case SEGMENTTYPE_REQUIRED:
                    newPropsSize += oldSeg->Wildcard.MaxLen;
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    if (oldSeg->Wildcard.MaxLen) {
                        newPropsSize += oldSeg->Wildcard.MaxLen;
                    } else {
                        newPropsSize ++;
                    }
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
            // now we allocate the required segments
            newProps->SegmentCount = newPropsSize;
            newProps->Segment = (PSEGMENTW) PmGetAlignedMemory (
                                                pool,
                                                newProps->SegmentCount * sizeof (SEGMENTW)
                                                );
            // now let's walk oldProps again and fill newProps segments.
            k = 0;
            newSeg = &newProps->Segment[k];
            for (j=0; j<oldProps->SegmentCount; j++) {
                oldSeg = &oldProps->Segment[j];
                ZeroMemory (newSeg, sizeof (SEGMENTW));
                switch (oldSeg->Type) {
                case SEGMENTTYPE_EXACTMATCH:
                    oldSegIndex = CharCountW (oldSeg->Exact.LowerCasePhrase);
                    if (!oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTA));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCWSTR) PmGetAlignedMemory (
                                                                        pool, sizeof(WCHAR)
                                                                        );
                            ((PWSTR)newSeg->Exact.LowerCasePhrase) [0] = 0;
                            newSeg->Exact.PhraseBytes = 0;
                    } else {
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTW));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Exact.LowerCasePhrase = (PCWSTR) PmGetAlignedMemory (
                                                                        pool, 2 * sizeof(WCHAR)
                                                                        );
                            ((PWSTR)newSeg->Exact.LowerCasePhrase)[0] = oldSeg->Exact.LowerCasePhrase [(oldSeg->Exact.PhraseBytes / sizeof(WCHAR)) - oldSegIndex];
                            ((PWSTR)newSeg->Exact.LowerCasePhrase)[1] = 0;
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    }
                    break;
                case SEGMENTTYPE_REQUIRED:
                    oldSegIndex = oldSeg->Wildcard.MaxLen;
                    while (oldSegIndex) {
                        ZeroMemory (newSeg, sizeof (SEGMENTW));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = 1;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        oldSegIndex --;
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                case SEGMENTTYPE_OPTIONAL:
                    if (oldSeg->Wildcard.MaxLen) {
                        oldSegIndex = oldSeg->Wildcard.MaxLen;
                        while (oldSegIndex) {
                            ZeroMemory (newSeg, sizeof (SEGMENTW));
                            newSeg->Type = oldSeg->Type;
                            newSeg->Wildcard.MaxLen = 1;
                            if (oldSeg->Wildcard.IncludeSet) {
                                newSeg->Wildcard.IncludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.IncludeSet);
                            }
                            if (oldSeg->Wildcard.ExcludeSet) {
                                newSeg->Wildcard.ExcludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.ExcludeSet);
                            }
                            oldSegIndex --;
                            k++;
                            newSeg = &newProps->Segment[k];
                        }
                    } else {
                        ZeroMemory (newSeg, sizeof (SEGMENTW));
                        newSeg->Type = oldSeg->Type;
                        newSeg->Wildcard.MaxLen = oldSeg->Wildcard.MaxLen;
                        if (oldSeg->Wildcard.IncludeSet) {
                            newSeg->Wildcard.IncludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.IncludeSet);
                        }
                        if (oldSeg->Wildcard.ExcludeSet) {
                            newSeg->Wildcard.ExcludeSet = PmDuplicateStringW (pool, oldSeg->Wildcard.ExcludeSet);
                        }
                        k++;
                        newSeg = &newProps->Segment[k];
                    }
                    break;
                default:
                    result = FALSE;
                    __leave;
                }
            }
        }
    }
    __finally {
        if (!result) {
            PmDestroyPool (pool);
            pattern = NULL;
        }
    }
    return pattern;
}

/*++

Routine Description:

  IsPatternContainedEx compares two patterns to see if one of them is
  included in the other. Both patterns may contain any of the following
  expressions:


  *                 - Specifies zero or more characters
  ?                 - Specifies any one character
  *[set]            - Specifies zero or more characters in set
  ?[set]            - Specifies any one character in set
  *[n:set]          - Specifies zero to n characters in set
  ?[n:set]          - Specifies exactly n characters in set
  *[!(set)]         - Specifies zero or more characters not in set
  ?[!(set)]         - Specifies one character not in set
  *[n:!(set)]       - Specifies zero to n characters not in set
  ?[n:!(set)]       - Specifies exactly n characters not in set
  *[set1,!(set2)]   - Specifies zero or more characters in set1 and
                      not in set2.  It is assumed that set1 and set2
                      overlap.
  ?[set1,!(set2)]   - Specifies one character in set1 and not in set2.
  *[n:set1,!(set2)] - Specifies zero to n characters in set1 and not
                      in set 2.
  ?[n:set1,!(set2)] - Specifies exactly n characters in set1 and not
                      in set 2.


  set, set1 and set2 are specified as follows:

  a                 - Specifies a single character
  a-b               - Specifies a character range
  a,b               - Specifies two characters
  a-b,c-d           - Specifies two character ranges
  a,b-c             - Specifies a single character and a character range
  etc...

  Patterns can be joined by surrounding the entire expression in
  greater than/less than braces.

  Because of the syntax characters, the following characters must be
  escaped by preceeding the character with a caret (^):

  ^?    ^[      ^-      ^<      ^!      ^^
  ^*    ^]      ^:      ^>      ^,

  Here are some examples:

  To specify any GUID:
    {?[8:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[4:0-9,a-f]-?[12:0-9,a-f]}

  To specify a 32-bit hexadecimal number:

    <0x*[8:0-9,a-f]><0*[7:0-9,a-f]h><?[1-9]*[7:0-9,a-f]h>

Arguments:

  Container - A container pattern possibly containing wildcards
  Contained - A contained pattern possibly containing wildcards

Return Value:

  TRUE when the second pattern is contained in the first one, FALSE if not.

--*/

BOOL
IsPatternContainedExA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    PPARSEDPATTERNA container = NULL, contained = NULL;
    PPARSEDPATTERNA expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        container = CreateParsedPatternA (Container);
        if (!container) {
            __leave;
        }
        expContainer = ExplodeParsedPatternA (container);
        if (!expContainer) {
            __leave;
        }
        contained = CreateParsedPatternA (Contained);
        if (!contained) {
            __leave;
        }
        expContained = ExplodeParsedPatternA (contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExA (expContainer, expContained, FALSE);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternA (expContained);
        }
        if (contained) {
            DestroyParsedPatternA (contained);
        }
        if (expContainer) {
            DestroyParsedPatternA (expContainer);
        }
        if (container) {
            DestroyParsedPatternA (container);
        }
    }

    return result;
}

BOOL
IsPatternContainedExW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    PPARSEDPATTERNW container = NULL, contained = NULL;
    PPARSEDPATTERNW expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        container = CreateParsedPatternW (Container);
        if (!container) {
            __leave;
        }
        expContainer = ExplodeParsedPatternW (container);
        if (!expContainer) {
            __leave;
        }
        contained = CreateParsedPatternW (Contained);
        if (!contained) {
            __leave;
        }
        expContained = ExplodeParsedPatternW (contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExW (expContainer, expContained, FALSE);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternW (expContained);
        }
        if (contained) {
            DestroyParsedPatternW (contained);
        }
        if (expContainer) {
            DestroyParsedPatternW (expContainer);
        }
        if (container) {
            DestroyParsedPatternW (container);
        }
    }

    return result;
}

BOOL
IsParsedPatternContainedExA (
    IN      PPARSEDPATTERNA Container,
    IN      PPARSEDPATTERNA Contained
    )
{
    PPARSEDPATTERNA expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        expContainer = ExplodeParsedPatternA (Container);
        if (!expContainer) {
            __leave;
        }
        expContained = ExplodeParsedPatternA (Contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExA (expContainer, expContained, FALSE);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternA (expContained);
        }
        if (expContainer) {
            DestroyParsedPatternA (expContainer);
        }
    }

    return result;
}

BOOL
IsParsedPatternContainedExW (
    IN      PPARSEDPATTERNW Container,
    IN      PPARSEDPATTERNW Contained
    )
{
    PPARSEDPATTERNW expContainer = NULL, expContained = NULL;
    BOOL result = FALSE;

    __try {
        expContainer = ExplodeParsedPatternW (Container);
        if (!expContainer) {
            __leave;
        }
        expContained = ExplodeParsedPatternW (Contained);
        if (!expContained) {
            __leave;
        }

        result = IsExplodedParsedPatternContainedExW (expContainer, expContained, FALSE);
    }
    __finally {
        if (expContained) {
            DestroyParsedPatternW (expContained);
        }
        if (expContainer) {
            DestroyParsedPatternW (expContainer);
        }
    }

    return result;
}

/*++

Routine Description:

  pAppendCharToGrowBuffer copies the first character in a caller specified
  string into the specified grow buffer.  This function is used to build up a
  string inside a grow buffer, copying character by character.

Arguments:

  buf       - Specifies the grow buffer to add the character to, receives the
              character in its buffer
  PtrToChar - Specifies a pointer to the character to copy

Return Value:

  None.

--*/

VOID
pAppendCharToGrowBufferA (
    IN OUT  PGROWBUFFER Buf,
    IN      PCSTR PtrToChar
    )
{
    PBYTE p;
    UINT Len;

    if (IsLeadByte (PtrToChar)) {
        Len = 2;
    } else {
        Len = 1;
    }

    p = GbGrow (Buf, Len);
    CopyMemory (p, PtrToChar, (SIZE_T) Len);
}


VOID
pAppendCharToGrowBufferW (
    IN OUT  PGROWBUFFER Buf,
    IN      PCWSTR PtrToChar
    )
{
    PBYTE p;

    p = GbGrow (Buf, sizeof(WCHAR));
    CopyMemory (p, PtrToChar, sizeof(WCHAR));
}

#define BASESTATE_BEGIN             0
#define BASESTATE_END               1
#define BASESTATE_ERROR             2
#define BASESTATE_BEGIN_COMPOUND    3
#define BASESTATE_END_COMPOUND      4
#define BASESTATE_EXAMINE_PATTERN   5
#define BASESTATE_SKIP_PATTERN      6

PCSTR
GetPatternBaseExA (
    IN      PCSTR Pattern,
    IN      BOOL NodePattern
    )
{
    GROWBUFFER resultBuf = INIT_GROWBUFFER;
    UINT state;
    UINT lastWackIdx = 0;
    UINT firstCharIdx = 0;
    BOOL compoundPattern = FALSE;
    MBCHAR ch = 0;
    PSTR result = NULL;

    state = BASESTATE_BEGIN;

    for (;;) {

        switch (state) {

        case BASESTATE_BEGIN:
            if (_mbsnextc (Pattern) == '<') {
                compoundPattern = TRUE;
                state = BASESTATE_BEGIN_COMPOUND;
            } else {
                state = BASESTATE_EXAMINE_PATTERN;
            }
            break;
        case BASESTATE_BEGIN_COMPOUND:
            while (_ismbcspace ((MBCHAR)(_mbsnextc (Pattern)))) {
                Pattern = _mbsinc (Pattern);
            }

            if (*Pattern == 0) {
                state = BASESTATE_END;
                break;
            }

            if (_mbsnextc (Pattern) == '<') {
                pAppendCharToGrowBufferA (&resultBuf, Pattern);
                Pattern = _mbsinc (Pattern);
                state = BASESTATE_EXAMINE_PATTERN;
            } else {
                state = BASESTATE_ERROR;
            }
            break;
        case BASESTATE_END_COMPOUND:
            pAppendCharToGrowBufferA (&resultBuf, Pattern);
            Pattern = _mbsinc (Pattern);
            state = BASESTATE_BEGIN_COMPOUND;
            break;
        case BASESTATE_EXAMINE_PATTERN:
            ch = _mbsnextc (Pattern);
            if (ch == '>' && compoundPattern) {
                state = BASESTATE_END_COMPOUND;
                break;
            }
            if (ch == 0) {
                if (compoundPattern) {
                    state = BASESTATE_ERROR;
                    break;
                }
                state = BASESTATE_END;
                break;
            }
            if ((ch == '*') || (ch == '?')) {
                if (NodePattern) {
                    if (resultBuf.Buf) {
                        ((PSTR)resultBuf.Buf) [lastWackIdx / sizeof (CHAR)] = 0;
                    }
                    resultBuf.End = lastWackIdx;
                } else {
                    if (resultBuf.Buf) {
                        ((PSTR)resultBuf.Buf) [firstCharIdx / sizeof (CHAR)] = 0;
                    }
                    resultBuf.End = firstCharIdx;
                    firstCharIdx = 0;
                }
                state = BASESTATE_SKIP_PATTERN;
                break;
            }
            if (!NodePattern && !firstCharIdx) {
                firstCharIdx = resultBuf.End;
            }
            if (ch == '\\') {
                if (NodePattern) {
                    lastWackIdx = resultBuf.End;
                }
            }
            if (ch == '^') {
                pAppendCharToGrowBufferA (&resultBuf, Pattern);
                Pattern = _mbsinc (Pattern);
            }
            pAppendCharToGrowBufferA (&resultBuf, Pattern);
            Pattern = _mbsinc (Pattern);
            break;
        case BASESTATE_SKIP_PATTERN:
            ch = _mbsnextc (Pattern);
            if (ch == '>' && compoundPattern) {
                state = BASESTATE_END_COMPOUND;
                break;
            }
            if (ch == 0) {
                if (compoundPattern) {
                    state = BASESTATE_ERROR;
                    break;
                }
                state = BASESTATE_END;
                break;
            }
            Pattern = _mbsinc (Pattern);
            break;
        }
        if ((state == BASESTATE_END) || (state == BASESTATE_ERROR)) {
            break;
        }
    }
    if (state == BASESTATE_END) {
        if (resultBuf.End) {
            ((PSTR)resultBuf.Buf) [resultBuf.End / sizeof (CHAR)] = 0;
            result = DuplicatePathStringA ((PCSTR)resultBuf.Buf, 0);
        }
    }
    GbFree (&resultBuf);
    return result;
}

PCWSTR
GetPatternBaseExW (
    IN      PCWSTR Pattern,
    IN      BOOL NodePattern
    )
{
    GROWBUFFER resultBuf = INIT_GROWBUFFER;
    UINT state;
    UINT lastWackIdx = 0;
    UINT firstCharIdx = 0;
    BOOL compoundPattern = FALSE;
    WCHAR ch = 0;
    PWSTR result = NULL;

    state = BASESTATE_BEGIN;

    for (;;) {

        switch (state) {

        case BASESTATE_BEGIN:
            if (*Pattern == L'<') {
                compoundPattern = TRUE;
                state = BASESTATE_BEGIN_COMPOUND;
            } else {
                state = BASESTATE_EXAMINE_PATTERN;
            }
            break;
        case BASESTATE_BEGIN_COMPOUND:
            while (*Pattern == L' ') {
                Pattern ++;
            }

            if (*Pattern == 0) {
                state = BASESTATE_END;
                break;
            }

            if (*Pattern == L'<') {
                pAppendCharToGrowBufferW (&resultBuf, Pattern);
                Pattern ++;
                state = BASESTATE_EXAMINE_PATTERN;
            } else {
                state = BASESTATE_ERROR;
            }
            break;
        case BASESTATE_END_COMPOUND:
            pAppendCharToGrowBufferW (&resultBuf, Pattern);
            Pattern ++;
            state = BASESTATE_BEGIN_COMPOUND;
            break;
        case BASESTATE_EXAMINE_PATTERN:
            ch = *Pattern;
            if (ch == L'>' && compoundPattern) {
                state = BASESTATE_END_COMPOUND;
                break;
            }
            if (ch == 0) {
                if (compoundPattern) {
                    state = BASESTATE_ERROR;
                    break;
                }
                state = BASESTATE_END;
                break;
            }
            if ((ch == L'*') || (ch == L'?')) {
                if (NodePattern) {
                    if (resultBuf.Buf) {
                        ((PWSTR)resultBuf.Buf) [lastWackIdx / sizeof (WCHAR)] = 0;
                    }
                    resultBuf.End = lastWackIdx;
                } else {
                    if (resultBuf.Buf) {
                        ((PWSTR)resultBuf.Buf) [firstCharIdx / sizeof (WCHAR)] = 0;
                    }
                    resultBuf.End = firstCharIdx;
                    firstCharIdx = 0;
                }
                state = BASESTATE_SKIP_PATTERN;
                break;
            }
            if (!NodePattern && !firstCharIdx) {
                firstCharIdx = resultBuf.End;
            }
            if (ch == L'\\') {
                if (NodePattern) {
                    lastWackIdx = resultBuf.End;
                }
            }
            if (ch == L'^') {
                pAppendCharToGrowBufferW (&resultBuf, Pattern);
                Pattern ++;
            }
            pAppendCharToGrowBufferW (&resultBuf, Pattern);
            Pattern ++;
            break;
        case BASESTATE_SKIP_PATTERN:
            ch = *Pattern;
            if (ch == L'>' && compoundPattern) {
                state = BASESTATE_END_COMPOUND;
                break;
            }
            if (ch == 0) {
                if (compoundPattern) {
                    state = BASESTATE_ERROR;
                    break;
                }
                state = BASESTATE_END;
                break;
            }
            Pattern ++;
            break;
        }
        if ((state == BASESTATE_END) || (state == BASESTATE_ERROR)) {
            break;
        }
    }
    if (state == BASESTATE_END) {
        if (resultBuf.End) {
            ((PWSTR)resultBuf.Buf) [resultBuf.End / sizeof (WCHAR)] = 0;
            result = DuplicatePathStringW ((PCWSTR)resultBuf.Buf, 0);
        }
    }
    GbFree (&resultBuf);
    return result;
}


/*++

Routine Description:

  RealCreateParsedPatternEx parses the expanded pattern string into a set of
  structures.  Parsing is considered expensive relative to testing the
  pattern, so callers should avoid calling this function inside loops.  See
  IsPatternMatchEx for a good description of the pattern string syntax.

Arguments:

  Pattern - Specifies the pattern string, which can include the extended
            wildcard syntax.

Return Value:

  A pointer to a parsed pattern structure, which the caller will use like a
  handle, or NULL if a syntax error occurred.

--*/

PPARSEDPATTERNA
RealCreateParsedPatternExA (
    IN      PMHANDLE Pool,  OPTIONAL
    IN      PCSTR Pattern
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    PPARSEDPATTERNA Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = INIT_GROWBUFFER;
    GROWBUFFER SegmentArray = INIT_GROWBUFFER;
    GROWBUFFER PatternArray = INIT_GROWBUFFER;
    GROWBUFFER SetBuf = INIT_GROWBUFFER;
    PPATTERNPROPSA CurrentPattern;
    MBCHAR ch = 0;
    PCSTR LookAhead;
    PCSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTA Segment;
    PSEGMENTA SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = PmCreateNamedPoolEx ("Parsed Pattern", 512);
    }

    Struct = (PPARSEDPATTERNA) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNA));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNA));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (_mbsnextc (Pattern) == '<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (_ismbcspace ((MBCHAR)(_mbsnextc (Pattern)))) {
                Pattern = _mbsinc (Pattern);
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (_mbsnextc (Pattern) == '<') {
                Pattern = _mbsinc (Pattern);
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGA ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSA) GbGrow (&PatternArray, sizeof (PATTERNPROPSA));

                CurrentPattern->Segment = (PSEGMENTA) PmGetAlignedMemory (pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTA);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    (SIZE_T) SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = _mbsnextc (Pattern);
            if (ch == '>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern = _mbsinc (Pattern);
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == '^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern = _mbsinc (Pattern);
                pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
                Pattern = _mbsinc (Pattern);
                break;
            }

            if (ch == '*' || ch == '?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == '*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern = _mbsinc (Pattern);

                if (_mbsnextc (Pattern) == '[') {
                    Pattern = _mbsinc (Pattern);
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, Pattern);
            Pattern = _mbsinc (Pattern);

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferA (&ExactMatchBuf, "");
            Segment.Exact.LowerCasePhrase = PmDuplicateStringA (
                                                pool,
                                                (PCSTR) ExactMatchBuf.Buf
                                                );
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (CHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            CharLowerA ((PSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTA) GbGrow (&SegmentArray, sizeof (SEGMENTA));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTA));
            Segment.Type = SEGMENTTYPE_UNKNOWN;

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= '0' && *LookAhead <= '9') {

                MaxLen = MaxLen * 10 + (*LookAhead - '0');
                LookAhead++;
            }

            if (LookAhead > Pattern && _mbsnextc (LookAhead) == ':') {
                Pattern = _mbsinc (LookAhead);

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            MYASSERT (SetBegin);

            ch = _mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.IncludeSet = PmDuplicateStringA (
                                                        pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    CharLowerA ((PSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == '!') {
                //
                // Case 2: an exclude set
                //

                SetBegin = _mbsinc (SetBegin);
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {   //lint !e613
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            ch = _mbsnextc (SetBegin);
            if (ch == ']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferA (&SetBuf, "");
                    Segment.Wildcard.ExcludeSet = PmDuplicateStringA (
                                                        pool,
                                                        (PCSTR) SetBuf.Buf
                                                        );
                    CharLowerA ((PSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = _mbsinc (SetBegin);
                break;
            }

            if (ch == '!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin = _mbsinc (SetBegin);

                if (_mbsnextc (SetBegin) != '(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin = _mbsinc (SetBegin);

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {   //lint !e613
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (_mbsnextc (SetBegin) == '^') {
                SetBegin = _mbsinc (SetBegin);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = _mbsinc (SetBegin);

            if (_mbsnextc (LookAhead) == '-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = _mbsinc (LookAhead);
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (_mbsnextc (SetBegin) == '^') {
                    SetBegin = _mbsinc (SetBegin);
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferA (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferA (&SetBuf, SetBegin);
            }

            SetBegin = _mbsinc (SetBegin);
            ch = _mbsnextc (SetBegin);

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == ')') {

                    SetBegin = _mbsinc (SetBegin);
                    ch = _mbsnextc (SetBegin);

                } else if (ch != ',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (_mbsnextc (SetBegin) != '(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = _mbsinc (SetBegin);

            while (*SetBegin) {
                if (_mbsnextc (SetBegin) == '^') {

                    SetBegin = _mbsinc (SetBegin);

                } else if (_mbsnextc (SetBegin) == ')') {

                    break;

                }

                if (IsLeadByte (SetBegin)) {
                    SetBegin += 2;
                } else {
                    SetBegin += 1;
                }
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin = _mbsinc (SetBegin);

            //
            // Now we are either at a comma or a close brace
            //

            ch = _mbsnextc (SetBegin);
            State = ReturnState;

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            } else if (ch != ']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            ch = 0;

            while (*SetBegin) { //lint !e613
                ch = _mbsnextc (SetBegin);
                if (ch == '^') {

                    SetBegin = _mbsinc (SetBegin);

                } else if (ch == ',' || ch == ']') {

                    break;

                }

                SetBegin = _mbsinc (SetBegin);
            }

            MYASSERT (*SetBegin);   //lint !e794

            if (ch == ',') {
                SetBegin = _mbsinc (SetBegin);
            }

            State = ReturnState;
            break;
        }   //lint !e787

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    GbFree (&ExactMatchBuf);
    GbFree (&SetBuf);
    GbFree (&SegmentArray);

    if (State == PATTERN_ERROR) {
        GbFree (&PatternArray);
        if (!externalPool) {
            PmDestroyPool (Pool);
        }
        return NULL;
    }

    if (PatternArray.End == 0) {
        //build an empty parsed pattern
        GbFree (&PatternArray);
        Struct->PatternCount = 1;
        Struct->Pool = pool;
        Struct->ExternalPool = externalPool;
        Struct->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                                pool,
                                                sizeof (PATTERNPROPSA)
                                                );
        Struct->Pattern[0].SegmentCount = 1;
        Struct->Pattern[0].Segment = (PSEGMENTA) PmGetAlignedMemory (
                                                    pool,
                                                    sizeof (SEGMENTA)
                                                    );
        Struct->Pattern[0].Segment[0].Type = SEGMENTTYPE_EXACTMATCH;
        Struct->Pattern[0].Segment[0].Exact.LowerCasePhrase = PmDuplicateStringA (pool, "");
        Struct->Pattern[0].Segment[0].Exact.PhraseBytes = 0;

        return Struct;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSA) PmGetAlignedMemory (
                                            pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, (SIZE_T) PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSA);
    Struct->Pool = pool;
    Struct->ExternalPool = externalPool;

    GbFree (&PatternArray);

    return Struct;
}


PPARSEDPATTERNW
RealCreateParsedPatternExW (
    IN      PMHANDLE Pool,  OPTIONAL
    IN      PCWSTR Pattern
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    PPARSEDPATTERNW Struct;
    PATTERNSTATE State;
    BOOL CompoundPattern = FALSE;
    GROWBUFFER ExactMatchBuf = INIT_GROWBUFFER;
    GROWBUFFER SegmentArray = INIT_GROWBUFFER;
    GROWBUFFER PatternArray = INIT_GROWBUFFER;
    GROWBUFFER SetBuf = INIT_GROWBUFFER;
    PPATTERNPROPSW CurrentPattern;
    WCHAR ch = 0;
    PCWSTR LookAhead;
    PCWSTR SetBegin = NULL;
    PATTERNSTATE ReturnState = 0;
    SEGMENTW Segment;
    PSEGMENTW SegmentElement;
    UINT MaxLen;

    Segment.Type = SEGMENTTYPE_UNKNOWN;

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = PmCreateNamedPoolEx ("Parsed Pattern", 512);
    }

    Struct = (PPARSEDPATTERNW) PmGetAlignedMemory (pool, sizeof (PARSEDPATTERNW));

    ZeroMemory (Struct, sizeof (PARSEDPATTERNW));

    State = BEGIN_PATTERN;

    for (;;) {

        switch (State) {

        case BEGIN_PATTERN:
            //
            // Here we test for either a compound pattern (one that
            // is a brace-separated list), or a simple pattern (one
            // that does not have a brace).
            //

            if (*Pattern == L'<') {
                CompoundPattern = TRUE;
                State = BEGIN_COMPOUND_PATTERN;
            } else if (*Pattern) {
                State = BEGIN_PATTERN_EXPR;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case BEGIN_COMPOUND_PATTERN:
            //
            // We are looking for the start of a compound pattern.
            // Space is allowed inbetween the patterns, but not
            // at the start.
            //

            while (iswspace (*Pattern)) {
                Pattern++;
            }

            if (*Pattern == 0) {
                State = PATTERN_DONE;
                break;
            }

            if (*Pattern == L'<') {
                Pattern++;
                State = BEGIN_PATTERN_EXPR;
            } else {
                DEBUGMSGW ((DBG_ERROR, "Syntax error in pattern: %s", Pattern));
                State = PATTERN_ERROR;
            }

            break;

        case BEGIN_PATTERN_EXPR:
            //
            // We are now ready to condense the expression.
            //

            State = PARSE_CHAR_EXPR_OR_END;
            ExactMatchBuf.End = 0;
            SegmentArray.End = 0;
            break;

        case PARSE_END_FOUND:

            State = END_PATTERN_EXPR;

            if (ExactMatchBuf.End) {
                ReturnState = State;
                State = SAVE_EXACT_MATCH;
            }

            break;

        case END_PATTERN_EXPR:

            //
            // Copy the segment array into the pool, reference the copy
            // in the pattern array
            //

            if (SegmentArray.End) {
                CurrentPattern = (PPATTERNPROPSW) GbGrow (&PatternArray, sizeof (PATTERNPROPSW));

                CurrentPattern->Segment = (PSEGMENTW) PmGetAlignedMemory (pool, SegmentArray.End);
                CurrentPattern->SegmentCount = SegmentArray.End / sizeof (SEGMENTW);

                CopyMemory (
                    CurrentPattern->Segment,
                    SegmentArray.Buf,
                    (SIZE_T) SegmentArray.End
                    );
            }

            if (CompoundPattern && *Pattern) {
                State = BEGIN_COMPOUND_PATTERN;
            } else {
                State = PATTERN_DONE;
            }

            break;

        case PARSE_CHAR_EXPR_OR_END:
            //
            // We now accept the following:
            //
            // 1. The end of the string or end of a compound pattern
            // 2. An escaped character
            // 3. The start of an expression
            // 4. A non-syntax character
            //

            ch = *Pattern;
            if (ch == L'>' && CompoundPattern) {

                //
                // Case 1, we found the end of a compound pattern
                //

                Pattern++;
                State = PARSE_END_FOUND;
                break;

            }

            if (*Pattern == 0) {

                //
                // Case 1, we found the end of the pattern
                //

                if (CompoundPattern) {
                    State = PATTERN_ERROR;
                } else {
                    State = PARSE_END_FOUND;
                }

                break;
            }

            if (ch == L'^') {
                //
                // Case 2, we found an escaped character, so transfer
                // it to the buffer.
                //

                MYASSERT (
                    Segment.Type == SEGMENTTYPE_UNKNOWN ||
                    Segment.Type == SEGMENTTYPE_EXACTMATCH
                    );

                Segment.Type = SEGMENTTYPE_EXACTMATCH;

                Pattern++;
                pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
                Pattern++;
                break;
            }

            if (ch == L'*' || ch == L'?') {
                //
                // Case 3, we found an expression.  Save the wildcard type
                // and parse the optional args.
                //

                if (ExactMatchBuf.End) {
                    State = SAVE_EXACT_MATCH;
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    break;
                }

                ZeroMemory (&Segment, sizeof (Segment));

                if (ch == L'*') {
                    Segment.Type = SEGMENTTYPE_OPTIONAL;
                } else {
                    Segment.Type = SEGMENTTYPE_REQUIRED;
                    Segment.Wildcard.MaxLen = 1;
                }

                Pattern++;

                if (*Pattern == L'[') {
                    Pattern++;
                    State = LOOK_FOR_NUMBER;
                } else {
                    ReturnState = PARSE_CHAR_EXPR_OR_END;
                    State = SAVE_SEGMENT;
                }

                break;
            }

            //
            // Case 4, we don't know about this character, so just copy it
            // and continue parsing.
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, Pattern);
            Pattern++;

            break;

        case SAVE_EXACT_MATCH:

            //
            // Put the string in ExactMatchBuf into a segment struct
            //

            pAppendCharToGrowBufferW (&ExactMatchBuf, L"");
            Segment.Exact.LowerCasePhrase = PmDuplicateStringW (
                                                pool,
                                                (PCWSTR) ExactMatchBuf.Buf
                                                );  //lint !e64
            Segment.Exact.PhraseBytes = ExactMatchBuf.End - sizeof (WCHAR);

            MYASSERT (Segment.Exact.LowerCasePhrase);
            CharLowerW ((PWSTR) Segment.Exact.LowerCasePhrase);

            Segment.Type = SEGMENTTYPE_EXACTMATCH;
            ExactMatchBuf.End = 0;

            // FALL THROUGH!!
        case SAVE_SEGMENT:

            //
            // Put the segment element into the segment array
            //

            SegmentElement = (PSEGMENTW) GbGrow (&SegmentArray, sizeof (SEGMENTW));
            CopyMemory (SegmentElement, &Segment, sizeof (SEGMENTW));
            Segment.Type = SEGMENTTYPE_UNKNOWN;

            State = ReturnState;
            break;

        case LOOK_FOR_NUMBER:
            //
            // Here we are inside a bracket, and there is an optional
            // numeric arg, which must be followed by a colon.  Test
            // that here.
            //

            LookAhead = Pattern;
            MaxLen = 0;

            while (*LookAhead >= L'0' && *LookAhead <= L'9') {

                MaxLen = MaxLen * 10 + (*LookAhead - L'0');
                LookAhead++;
            }

            if (LookAhead > Pattern && *LookAhead == L':') {
                Pattern = LookAhead + 1;

                //
                // Check for special case syntax error: ?[0:]
                //

                if (Segment.Type == SEGMENTTYPE_EXACTMATCH && !MaxLen) {
                    State = PATTERN_ERROR;
                    break;
                }

                Segment.Wildcard.MaxLen = MaxLen;
            }

            SetBegin = Pattern;
            State = LOOK_FOR_INCLUDE;

            SetBuf.End = 0;

            break;

        case LOOK_FOR_INCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  Now we look for all the include sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. An exclude set that needs to be skipped
            // 3. A valid include set
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.IncludeSet = PmDuplicateStringW (
                                                        pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );  //lint !e64
                    CharLowerW ((PWSTR) Segment.Wildcard.IncludeSet);
                } else {
                    Segment.Wildcard.IncludeSet = NULL;
                }

                SetBuf.End = 0;

                State = LOOK_FOR_EXCLUDE;
                SetBegin = Pattern;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: an exclude set
                //

                SetBegin++;
                State = SKIP_EXCLUDE_SET;
                ReturnState = LOOK_FOR_INCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: a valid include set.
            //

            State = CONDENSE_SET;
            ReturnState = LOOK_FOR_INCLUDE;
            break;

        case LOOK_FOR_EXCLUDE:
            //
            // Here we are inside a bracket, past an optional numeric
            // arg.  All include sets are in the condensing buffer.
            // Now we look for all the exclude sets, which are
            // optional.  We have the following possibilities:
            //
            // 1. End of set
            // 2. A valid exclude set
            // 3. An include set that needs to be skipped
            // 4. Error
            //
            // We look at SetBegin, and not Pattern.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = *SetBegin;
            if (ch == L']') {
                //
                // Case 1: end of set; we're done with this expr
                //

                if (SetBuf.End) {
                    pAppendCharToGrowBufferW (&SetBuf, L"");
                    Segment.Wildcard.ExcludeSet = PmDuplicateStringW (
                                                        pool,
                                                        (PCWSTR) SetBuf.Buf
                                                        );  //lint !e64
                    CharLowerW ((PWSTR) Segment.Wildcard.ExcludeSet);
                } else {
                    Segment.Wildcard.ExcludeSet = NULL;
                }

                SetBuf.End = 0;
                State = SAVE_SEGMENT;
                ReturnState = PARSE_CHAR_EXPR_OR_END;
                Pattern = SetBegin + 1;
                break;
            }

            if (ch == L'!') {
                //
                // Case 2: a valid exclude set; save it
                //

                SetBegin++; //lint !e613

                if (*SetBegin != L'(') {
                    State = PATTERN_ERROR;
                    break;
                }

                SetBegin++;

                State = CONDENSE_SET;
                ReturnState = LOOK_FOR_EXCLUDE;
                break;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            //
            // Case 3: an include set that needs to be skipped.
            //

            State = SKIP_INCLUDE_SET;
            ReturnState = LOOK_FOR_EXCLUDE;
            break;

        case CONDENSE_SET:
            //
            // Here SetBegin points to a set range, and it is our
            // job to copy the range into the set buffer, and
            // return back to the previous state.
            //

            //
            // Copy the character at SetBegin
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            if (*SetBegin == L'^') {
                SetBegin++;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }
            }
            pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            //
            // Check if this is a range or not
            //

            LookAhead = SetBegin + 1;

            if (*LookAhead == L'-') {

                //
                // Range, copy the character after the dash
                //

                SetBegin = LookAhead + 1;
                if (*SetBegin == 0) {
                    State = PATTERN_ERROR;
                    break;
                }

                if (*SetBegin == L'^') {
                    SetBegin++;
                    if (*SetBegin == 0) {
                        State = PATTERN_ERROR;
                        break;
                    }
                }
                pAppendCharToGrowBufferW (&SetBuf, SetBegin);

            } else {

                //
                // A single character, copy the character again
                //

                pAppendCharToGrowBufferW (&SetBuf, SetBegin);
            }

            SetBegin++;
            ch = *SetBegin;

            //
            // If this is an exclude set, we must have a closing paren
            // or a comma
            //

            State = ReturnState;

            if (ReturnState == LOOK_FOR_EXCLUDE) {

                if (ch == L')') {

                    SetBegin++;
                    ch = *SetBegin;

                } else if (ch != L',') {
                    State = PATTERN_ERROR;
                } else {
                    //
                    // Continue condensing the next part of this exclude set
                    //

                    State = CONDENSE_SET;
                }
            }

            //
            // We either need a comma or a close brace
            //

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_EXCLUDE_SET:
            //
            // Skip over the parenthesis group, assuming it is syntatically
            // correct, and return to the previous state.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            if (*SetBegin != L'(') {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            while (*SetBegin) {
                if (*SetBegin == L'^') {

                    SetBegin++;

                } else if (*SetBegin == L')') {

                    break;

                }

                SetBegin++;
            }

            if (*SetBegin == 0) {
                State = PATTERN_ERROR;
                break;
            }

            SetBegin++;

            //
            // Now we are either at a comma or a close brace
            //

            ch = *SetBegin;
            State = ReturnState;

            if (ch == L',') {
                SetBegin++;
            } else if (ch != L']') {
                State = PATTERN_ERROR;
            }

            break;

        case SKIP_INCLUDE_SET:
            //
            // Skip to the next comma or closing brace.  We know it is
            // syntatically correct by now.
            //

            if (!SetBegin) {
                State = PATTERN_ERROR;
                break;
            }

            ch = 0;

            while (*SetBegin) {
                ch = *SetBegin;
                if (ch == L'^') {

                    SetBegin++; //lint !e613

                } else if (ch == L',' || ch == L']') {

                    break;

                }

                SetBegin++;
            }

            MYASSERT (*SetBegin);

            if (ch == L',') {
                SetBegin++;
            }

            State = ReturnState;
            break;
        }   //lint !e787

        if (State == PATTERN_DONE || State == PATTERN_ERROR) {
            break;
        }
    }

    GbFree (&ExactMatchBuf);
    GbFree (&SetBuf);
    GbFree (&SegmentArray);

    if (State == PATTERN_ERROR) {
        GbFree (&PatternArray);
        if (!externalPool) {
            PmDestroyPool (pool);
        }
        return NULL;
    }

    if (PatternArray.End == 0) {
        //build an empty parsed pattern
        GbFree (&PatternArray);
        Struct->PatternCount = 1;
        Struct->Pool = pool;
        Struct->ExternalPool = externalPool;
        Struct->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                                pool,
                                                sizeof (PATTERNPROPSW)
                                                );
        Struct->Pattern[0].SegmentCount = 1;
        Struct->Pattern[0].Segment = (PSEGMENTW) PmGetAlignedMemory (
                                                    pool,
                                                    sizeof (SEGMENTW)
                                                    );
        Struct->Pattern[0].Segment[0].Type = SEGMENTTYPE_EXACTMATCH;
        Struct->Pattern[0].Segment[0].Exact.LowerCasePhrase = PmDuplicateStringW (pool, L"");
        Struct->Pattern[0].Segment[0].Exact.PhraseBytes = 0;

        return Struct;
    }

    //
    // Copy the fully parsed pattern array into the return struct
    //

    Struct->Pattern = (PPATTERNPROPSW) PmGetAlignedMemory (
                                            pool,
                                            PatternArray.End
                                            );


    CopyMemory (Struct->Pattern, PatternArray.Buf, (SIZE_T) PatternArray.End);
    Struct->PatternCount = PatternArray.End / sizeof (PATTERNPROPSW);
    Struct->Pool = pool;
    Struct->ExternalPool = externalPool;

    GbFree (&PatternArray);

    return Struct;
}

BOOL
WildCharsPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    UINT i,j;

    if (!ParsedPattern) {
        return FALSE;
    }
    for (i=0; i<ParsedPattern->PatternCount; i++) {
        if (ParsedPattern->Pattern[i].SegmentCount < 1) {
            return TRUE;
        }
        for (j=0; j<ParsedPattern->Pattern[i].SegmentCount; j++) {
            if ((ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_OPTIONAL) ||
                (ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_REQUIRED)
                ) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
WildCharsPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    UINT i,j;

    if (!ParsedPattern) {
        return FALSE;
    }
    for (i=0; i<ParsedPattern->PatternCount; i++) {
        if (ParsedPattern->Pattern[i].SegmentCount < 1) {
            return TRUE;
        }
        for (j=0; j<ParsedPattern->Pattern[i].SegmentCount; j++) {
            if ((ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_OPTIONAL) ||
                (ParsedPattern->Pattern[i].Segment[j].Type == SEGMENTTYPE_REQUIRED)
                ) {
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL
ParsedPatternTrimLastCharA (
    IN OUT  PPARSEDPATTERNA ParsedPattern
    )
{
    if (!ParsedPatternHasRootA (ParsedPattern)) {
        return FALSE;
    }
    ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes -= DWSIZEOF (CHAR);
    *(PSTR)((PBYTE)ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase +
            ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes) = 0;
    return TRUE;
}

BOOL
ParsedPatternTrimLastCharW (
    IN OUT  PPARSEDPATTERNW ParsedPattern
    )
{
    if (!ParsedPatternHasRootW (ParsedPattern)) {
        return FALSE;
    }
    ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes -= DWSIZEOF (WCHAR);
    *(PWSTR)((PBYTE)ParsedPattern->Pattern->Segment[0].Exact.LowerCasePhrase +
             ParsedPattern->Pattern->Segment[0].Exact.PhraseBytes) = 0;
    return TRUE;
}


VOID
UBINTtoHexA (
    IN      UBINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "0x%08X%08X", (DWORD)(Number >> 32), (DWORD)Number);
#else
    sprintf (String, "0x00000000%08X", Number);
#endif
}

VOID
UBINTtoHexW (
    IN      UBINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"0x%08X%08X", (DWORD)(Number >> 32), (DWORD)Number);
#else
    swprintf (String, L"0x00000000%08X", Number);
#endif
}

VOID
UBINTtoDecA (
    IN      UBINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "%I64u", Number);
#else
    sprintf (String, "%lu", Number);
#endif
}

VOID
UBINTtoDecW (
    IN      UBINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"%I64u", Number);
#else
    swprintf (String, L"%lu", Number);
#endif
}

VOID
BINTtoDecA (
    IN      BINT Number,
    OUT     PSTR String
    )
{
#ifdef IA64
    sprintf (String, "%I64d", Number);
#else
    sprintf (String, "%ld", Number);
#endif
}

VOID
BINTtoDecW (
    IN      BINT Number,
    OUT     PWSTR String
    )
{
#ifdef IA64
    swprintf (String, L"%I64d", Number);
#else
    swprintf (String, L"%ld", Number);
#endif
}

VOID
PrintPattern (
    IN      PCSTR PatStr,
    IN      PPARSEDPATTERNA Struct
    )

/*++

Routine Description:

  PrintPattern is used for debugging the pattern parsing and testing
  functions.

Arguments:

  PatStr - Specifies the original pattern string (which is printed as a
           heading)
  Struct - Specifies the parsed pattern struct

Return Value:

  None.

--*/

{
    CHAR poolStr [sizeof (UBINT) * 2 + 2 + 1];
    UINT u, v;

    printf ("Pattern: %s\n\n", PatStr);

    if (!Struct) {
        printf ("Invalid Pattern\n\n");
        return;
    }

    printf ("PatternCount: %u\n", Struct->PatternCount);
    UBINTtoHexA ((UBINT)Struct->Pool, poolStr);
    printf ("Pool: %s\n", poolStr);

    for (u = 0 ; u < Struct->PatternCount ; u++) {

        printf ("  Segment Count: %u\n", Struct->Pattern[u].SegmentCount);

        for (v = 0 ; v < Struct->Pattern->SegmentCount ; v++) {
            printf ("    Type: ");

            switch (Struct->Pattern[u].Segment[v].Type) {

            case SEGMENTTYPE_EXACTMATCH:
                printf ("SEGMENTTYPE_EXACTMATCH\n");
                printf ("      String: %s\n", Struct->Pattern[u].Segment[v].Exact.LowerCasePhrase);
                printf ("      Bytes: %u\n", Struct->Pattern[u].Segment[v].Exact.PhraseBytes);
                break;

            case SEGMENTTYPE_OPTIONAL:
                printf ("SEGMENTTYPE_OPTIONAL\n");
                printf ("      MaxLen: %u\n", Struct->Pattern[u].Segment[v].Wildcard.MaxLen);
                printf ("      IncludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.IncludeSet);
                printf ("      ExcludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.ExcludeSet);
                break;

            case SEGMENTTYPE_REQUIRED:
                printf ("SEGMENTTYPE_REQUIRED\n");
                printf ("      MaxLen: %u\n", Struct->Pattern[u].Segment[v].Wildcard.MaxLen);
                printf ("      IncludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.IncludeSet);
                printf ("      ExcludeSet: %s\n", Struct->Pattern[u].Segment[v].Wildcard.ExcludeSet);
                break;
            }   //lint !e744
        }

    }

    printf ("\n");
}



/*++

Routine Description:

  TestParsedPattern finds the end of the string to test and calls
  TestParsedPatternAB.

Arguments:

  ParsedPattern - Specifies the parsed pattern structure as returned by
                  CreateParsedPattern
  StringToTest  - Specifies the string to test against the pattern

Return Value:

  TRUE if the string fits the pattern, FALSE if it does not

--*/

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    )
{
    PCSTR EndPlusOne = GetEndOfStringA (StringToTest);

    return TestParsedPatternABA (ParsedPattern, StringToTest, EndPlusOne);
}


BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    )
{
    PCWSTR EndPlusOne = GetEndOfStringW (StringToTest);

    return TestParsedPatternABW (ParsedPattern, StringToTest, EndPlusOne);
}


/*++

Routine Description:

  pTestSet tests a character against an include and exclude set. The sets are
  formatted in pairs of characters, where the first character in the pair is
  the low range, and the second character in the pair is the high range.  The
  specified character will automatically be lower-cased, and all whitespace
  characters are tested against the space character (ascii 32).

Arguments:

  ch         - Specifies the character to test.  This character is converted
               to lower case before the test.
  IncludeSet - Specifies the set of characters that ch must be a member of.
               If NULL is specified, then the include set is all characters.
  ExcludeSet - Specifies the range of characters that ch cannot be a member
               of.  If NULL is specified, then no characters are excluded.

Return Value:

  TRUE if ch is in the include set and not in the exclude set; FALSE
  otherwise.

--*/

BOOL
pTestSetA (
    IN      MBCHAR ch,
    IN      PCSTR IncludeSet,               OPTIONAL
    IN      PCSTR ExcludeSet                OPTIONAL
    )
{
    MBCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (_ismbcspace ((MBCHAR)ch)) {
        if (ch != ' ') {
            if (pTestSetA (' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = OURTOLOWER (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = _mbsnextc (IncludeSet);
            IncludeSet = _mbsinc (IncludeSet);
            HighChar = _mbsnextc (IncludeSet);
            IncludeSet = _mbsinc (IncludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = _mbsnextc (ExcludeSet);
            ExcludeSet = _mbsinc (ExcludeSet);
            HighChar = _mbsnextc (ExcludeSet);
            ExcludeSet = _mbsinc (ExcludeSet);

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}


BOOL
pTestSetW (
    IN      WCHAR ch,
    IN      PCWSTR IncludeSet,              OPTIONAL
    IN      PCWSTR ExcludeSet               OPTIONAL
    )
{
    WCHAR LowChar, HighChar;
    BOOL b = TRUE;

    if (iswspace (ch)) {
        if (ch != L' ') {
            if (pTestSetW (L' ', IncludeSet, ExcludeSet)) {
                return TRUE;
            }
        }
    } else {
        ch = towlower (ch);
    }

    if (IncludeSet) {

        b = FALSE;

        while (*IncludeSet) {

            LowChar = *IncludeSet++;
            HighChar = *IncludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = TRUE;
                break;
            }
        }
    }

    if (b && ExcludeSet) {

        while (*ExcludeSet) {

            LowChar = *ExcludeSet++;
            HighChar = *ExcludeSet++;

            if (ch >= LowChar && ch <= HighChar) {
                b = FALSE;
                break;
            }
        }
    }

    return b;
}



/*++

Routine Description:

  pTestOnePatternAB tests a string against a parsed pattern. It loops through
  each segment in the pattern, and calls itself recursively in certain
  circumstances.

Arguments:

  Pattern      - Specifies the parsed pattern, as returned from
                 CreateParsedPattern
  StartSeg     - Specifies the segment within Pattern to start testing.  This
                 is used for recursion and outside callers should pass in 0.
  StringToTest - Specifies the string to test against Pattern.  In recursion,
                 this member will be a pointer to the start of the sub string
                 to test.
  EndPlusOne   - Specifies one character beyond the end of the string.  This
                 typically points to the nul terminator.

Return Value:

  TRUE if the string between StringToTest and EndPlusOne fits Pattern. FALSE
  otherwise.

--*/

BOOL
pTestOnePatternABA (
    IN      PPATTERNPROPSA Pattern,
    IN      UINT StartSeg,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTA Segment;
    MBCHAR ch1, ch2;
    PCSTR q;
    PCSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (UINT)((PBYTE) EndPlusOne - (PBYTE) StringToTest);

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase;

            TempEnd = (PCSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 0;

            while (q < TempEnd) {

                ch1 = _mbsnextc (StringToTest);
                ch2 = _mbsnextc (q);

                ch1 = OURTOLOWER (ch1);

                if (ch1 != ch2) {
                    if (ch2 == ' ') {
                        if (!_ismbcspace ((MBCHAR)ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q = _mbsinc (q);
                StringToTest = _mbsinc (StringToTest);
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetA (
                            _mbsnextc (StringToTest),
                            Segment->Wildcard.IncludeSet,
                            Segment->Wildcard.ExcludeSet
                            )) {
                        return FALSE;
                    }

                    Chars--;
                    StringToTest = _mbsinc (StringToTest);
                }
            } else {
                while (StringToTest < EndPlusOne && Chars > 0) {
                    Chars--;
                    StringToTest = _mbsinc (StringToTest);
                }
            }

            if (Chars) {
                return FALSE;
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetA (
                                _mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = _mbsinc (TempEnd);
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetA (
                                _mbsnextc (TempEnd),
                                Segment->Wildcard.IncludeSet,
                                Segment->Wildcard.ExcludeSet
                                )) {
                            break;
                        }

                        TempEnd = _mbsinc (TempEnd);
                    }
                }

            } else if (Chars) {

                while (TempEnd < EndPlusOne && Chars > 0) {
                    TempEnd = _mbsinc (TempEnd);
                    Chars--;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABA (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest = _mbsinc (StringToTest);

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }   //lint !e744
    }

    return TRUE;
}


BOOL
pTestOnePatternABW (
    IN      PPATTERNPROPSW Pattern,
    IN      UINT StartSeg,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    PSEGMENTW Segment;
    WCHAR ch1, ch2;
    PCWSTR q;
    PCWSTR TempEnd;
    UINT BytesLeft;
    UINT Chars;

    for (u = StartSeg ; u < Pattern->SegmentCount ; u++) {

        Segment = &Pattern->Segment[u];

        switch (Segment->Type) {

        case SEGMENTTYPE_EXACTMATCH:
            //
            // Check if the exact match is long enough, or if
            // the remaining string must match
            //

            BytesLeft = (UINT)((PBYTE) EndPlusOne - (PBYTE) StringToTest);

            if (u + 1 == Pattern->SegmentCount) {
                if (BytesLeft != Segment->Exact.PhraseBytes) {
                    return FALSE;
                }
            } else if (BytesLeft < Segment->Exact.PhraseBytes) {
                return FALSE;
            }

            //
            // Compare the strings
            //

            q = Segment->Exact.LowerCasePhrase; //lint !e64

            TempEnd = (PCWSTR) ((PBYTE) q + Segment->Exact.PhraseBytes);

            ch1 = 0;
            ch2 = 0;

            while (q < TempEnd) {

                ch1 = towlower (*StringToTest);
                ch2 = *q;

                if (ch1 != ch2) {
                    if (ch2 == L' ') {
                        if (!iswspace (ch1)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                q++;
                StringToTest++;
            }

            if (ch1 != ch2) {
                return FALSE;
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_REQUIRED:
            MYASSERT (Segment->Wildcard.MaxLen > 0);

            //
            // Verify there are the correct number of characters
            // in the specified char set
            //

            Chars = Segment->Wildcard.MaxLen;
            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {
                while (StringToTest < EndPlusOne && Chars > 0) {

                    if (!pTestSetW (
                            *StringToTest,
                            Segment->Wildcard.IncludeSet,   //lint !e64
                            Segment->Wildcard.ExcludeSet
                            )) {    //lint !e64
                        return FALSE;
                    }

                    Chars--;
                    StringToTest++;
                }

                if (Chars) {
                    return FALSE;
                }

            } else {
                StringToTest += Chars;

                if (StringToTest > EndPlusOne) {
                    return FALSE;
                }
            }

            if (u + 1 == Pattern->SegmentCount) {
                if (*StringToTest) {
                    return FALSE;
                }
            }

            //
            // Continue onto next segment
            //

            break;

        case SEGMENTTYPE_OPTIONAL:

            if (Segment->Wildcard.MaxLen == 0) {
                //
                // Last segment is "anything"
                //

                if (u + 1 == Pattern->SegmentCount &&
                    !Segment->Wildcard.IncludeSet &&
                    !Segment->Wildcard.ExcludeSet
                    ) {
                    return TRUE;
                }
            }

            //
            // Find end of optional text
            //

            TempEnd = StringToTest;
            Chars = Segment->Wildcard.MaxLen;

            if (Segment->Wildcard.IncludeSet || Segment->Wildcard.ExcludeSet) {

                if (Chars) {
                    while (TempEnd < EndPlusOne && Chars > 0) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,   //lint !e64
                                Segment->Wildcard.ExcludeSet
                                )) {    //lint !e64
                            break;
                        }

                        TempEnd++;
                        Chars--;
                    }

                } else {

                    while (TempEnd < EndPlusOne) {

                        if (!pTestSetW (
                                *TempEnd,
                                Segment->Wildcard.IncludeSet,   //lint !e64
                                Segment->Wildcard.ExcludeSet
                                )) {    //lint !e64
                            break;
                        }

                        TempEnd++;
                    }
                }

            } else if (Chars) {

                TempEnd += Chars;
                if (TempEnd > EndPlusOne) {
                    TempEnd = EndPlusOne;
                }

            } else {
                TempEnd = EndPlusOne;
            }

            //
            // If this is the last segment, then match only when
            // the remaining text fits
            //

            if (u + 1 == Pattern->SegmentCount) {
                return TempEnd >= EndPlusOne;
            }

            //
            // Because other segments exist, we must check recursively
            //

            do {
                if (pTestOnePatternABW (Pattern, u + 1, StringToTest, EndPlusOne)) {
                    return TRUE;
                }

                StringToTest++;

            } while (StringToTest <= TempEnd);

            //
            // No match
            //

            return FALSE;
        }   //lint !e744
    }

    return TRUE;
}



/*++

Routine Description:

  TestParsedPattternAB loops through all the patterns in ParsedPattern,
  testing the specified string against each. The loop stops at the first
  match.

Arguments:

  ParsedPattern - Specifies the parsed pattern, as returned from
                  CreateParsedPattern
  StringToTest  - Specifies the start of the string to test.
  EndPlusOne    - Specifies a pointer to the first character after the end of
                  the string.  This often points to the nul at the end of the
                  string.  A nul must not exist in between StringToTest and
                  EndPlusOne; a nul can only be at *EndPlusOne.  A nul is not
                  required.

Return Value:

  TRUE if the string specified between StringToTest and EndPlusOne matches
  Pattern.  FALSE otherwise.

--*/

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    if (!ParsedPattern) {
        return FALSE;
    }

    if (!StringToTest) {
        return FALSE;
    }

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABA (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}


BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    )
{
    UINT u;
    BOOL b = FALSE;

    if (!ParsedPattern) {
        return FALSE;
    }

    if (!StringToTest) {
        return FALSE;
    }

    for (u = 0 ; u < ParsedPattern->PatternCount ; u++) {

        b = pTestOnePatternABW (
                &ParsedPattern->Pattern[u],
                0,
                StringToTest,
                EndPlusOne
                );

        if (b) {
            break;
        }
    }

    return b;
}



/*++

Routine Description:

  DestroyParsedPattern cleans up a pattern allocated from CreateParsedPattern.

Arguments:

  ParsedPattern - Specifies the value returned from CreateParsedPattern.

Return Value:

  None.

--*/

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    if (ParsedPattern && (!ParsedPattern->ExternalPool)) {
        PmEmptyPool (ParsedPattern->Pool);
        PmDestroyPool (ParsedPattern->Pool);
    }
}


VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    if (ParsedPattern && (!ParsedPattern->ExternalPool)) {
        PmEmptyPool (ParsedPattern->Pool);
        PmDestroyPool (ParsedPattern->Pool);
    }
}


/*++

Routine Description:

  DecodeParsedPattern decodes all exact-matches sub-strings of the given pattern.

Arguments:

  ParsedPattern - Specifies the parsed pattern.

Return Value:

  None.

--*/

VOID
DecodeParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    )
{
    UINT u;
    UINT v;
    PSTR phrase;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {
        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            if (ParsedPattern->Pattern[u].Segment[v].Type == SEGMENTTYPE_EXACTMATCH) {
                phrase = (PSTR)ParsedPattern->Pattern[u].Segment[v].Exact.LowerCasePhrase;
                DecodeRuleCharsA (phrase, phrase);
                ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes = ByteCountA (phrase);
            }
        }
    }
}


VOID
DecodeParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    )
{
    UINT u;
    UINT v;
    PWSTR phrase;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {
        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            if (ParsedPattern->Pattern[u].Segment[v].Type == SEGMENTTYPE_EXACTMATCH) {
                phrase = (PWSTR)ParsedPattern->Pattern[u].Segment[v].Exact.LowerCasePhrase;
                DecodeRuleCharsW (phrase, phrase);
                ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes = ByteCountW (phrase);
            }
        }
    }
}


/*++

Routine Description:

  GetParsedPatternMinMaxSize returns the minimum and the maximum size (in bytes)
  of a string that would match the given parsed pattern.

Arguments:

  ParsedPattern - Specifies the parsed pattern
  MinSize - Receives the minimum size of a string that would match the pattern
  MaxSize - Receives the maximum size of a string that would match the pattern

Return Value:

  None.

--*/

VOID
GetParsedPatternMinMaxSizeA (
    IN      PPARSEDPATTERNA ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    )
{
    UINT u;
    UINT v;
    DWORD pmin;
    DWORD pmax;
    DWORD smin;
    DWORD smax;

    *MinSize = *MaxSize = 0;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {

        pmin = pmax = 0;

        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            switch (ParsedPattern->Pattern[u].Segment[v].Type) {
            case SEGMENTTYPE_EXACTMATCH:
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes;
                break;
            case SEGMENTTYPE_OPTIONAL:
                smin = 0;
                if (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen) {
                    smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (CHAR);
                } else {
                    smax = DWORD_MAX;
                }
                break;
            case SEGMENTTYPE_REQUIRED:
                MYASSERT (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen > 0);
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (CHAR);
                break;
            default:
                MYASSERT (FALSE);   //lint !e506
                smin = smax = 0;
            }
            pmin += smin;
            if (pmax < DWORD_MAX) {
                if (smax < DWORD_MAX) {
                    pmax += smax;
                } else {
                    pmax = DWORD_MAX;
                }
            }
        }

        if (pmin < *MinSize) {
            *MinSize = pmin;
        }
        if (pmax > *MaxSize) {
            *MaxSize = pmax;
        }
    }
}

VOID
GetParsedPatternMinMaxSizeW (
    IN      PPARSEDPATTERNW ParsedPattern,
    OUT     PDWORD MinSize,
    OUT     PDWORD MaxSize
    )
{
    UINT u;
    UINT v;
    DWORD pmin;
    DWORD pmax;
    DWORD smin;
    DWORD smax;

    *MinSize = *MaxSize = 0;

    for (u = 0; u < ParsedPattern->PatternCount; u++) {

        pmin = pmax = 0;

        for (v = 0; v < ParsedPattern->Pattern[u].SegmentCount; v++) {
            switch (ParsedPattern->Pattern[u].Segment[v].Type) {
            case SEGMENTTYPE_EXACTMATCH:
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Exact.PhraseBytes;
                break;
            case SEGMENTTYPE_OPTIONAL:
                smin = 0;
                if (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen) {
                    smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (WCHAR);
                } else {
                    smax = DWORD_MAX;
                }
                break;
            case SEGMENTTYPE_REQUIRED:
                MYASSERT (ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen > 0);
                smin = smax = ParsedPattern->Pattern[u].Segment[v].Wildcard.MaxLen * DWSIZEOF (WCHAR);
                break;
            default:
                MYASSERT (FALSE);   //lint !e506
                smin = smax = 0;
            }
            pmin += smin;
            if (pmax < DWORD_MAX) {
                if (smax < DWORD_MAX) {
                    pmax += smax;
                } else {
                    pmax = DWORD_MAX;
                }
            }
        }

        if (pmin < *MinSize) {
            *MinSize = pmin;
        }
        if (pmax > *MaxSize) {
            *MaxSize = pmax;
        }
    }
}


/*++

Routine Description:

    PatternIncludesPattern decides if a given pattern includes another pattern,
    meaning that any string that would match the second will match the first.

Arguments:

    IncludingPattern - Specifies the first parsed pattern
    IncludedPattern - Specifies the second parsed pattern

Return Value:

    TRUE if the first pattern includes the second

--*/

BOOL
PatternIncludesPatternA (
    IN      PPARSEDPATTERNA IncludingPattern,
    IN      PPARSEDPATTERNA IncludedPattern
    )
{
    PPATTERNPROPSA pp1;
    PPATTERNPROPSA pp2;
    PSEGMENTA ps1;
    PSEGMENTA ps2;
    DWORD min1;
    DWORD max1;
    DWORD min2;
    DWORD max2;

    //
    // only deal with simple patterns for now (PatternCount == 1)
    //
    if (IncludingPattern->PatternCount > 1 || IncludedPattern->PatternCount > 1) {
        DEBUGMSGA ((DBG_ERROR, "PatternIncludesPatternA: multiple patterns not supported yet"));
        return FALSE;
    }

    //
    // test the usual cases first, quickly
    //
    pp1 = IncludingPattern->Pattern;
    MYASSERT (pp1);
    if (pp1->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalA (pp1->Segment)) {
        return TRUE;
    }

    pp2 = IncludedPattern->Pattern;
    MYASSERT (pp2);
    if (pp2->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalA (pp2->Segment)) {
        return FALSE;
    }

    if (pp1->SegmentCount == 1) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (pp2->SegmentCount == 1) {
                ps2 = pp2->Segment;
                if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                    return ps1->Exact.PhraseBytes == ps2->Exact.PhraseBytes &&
                           StringMatchA (ps1->Exact.LowerCasePhrase, ps2->Exact.LowerCasePhrase);
                }
            }
        }
    } else if (pp1->SegmentCount == 2) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (ParsedPatternSegmentIsPureOptionalA (pp1->Segment + 1)) {
                if (pp2->SegmentCount == 1) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                               StringMatchByteCountA (
                                    ps1->Exact.LowerCasePhrase,
                                    ps2->Exact.LowerCasePhrase,
                                    ps1->Exact.PhraseBytes
                                    );
                    }
                } else if (pp2->SegmentCount == 2) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        if (ParsedPatternSegmentIsPureOptionalA (pp2->Segment + 1)) {
                            return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                                   StringMatchByteCountA (
                                        ps1->Exact.LowerCasePhrase,
                                        ps2->Exact.LowerCasePhrase,
                                        ps1->Exact.PhraseBytes
                                        );
                        }
                    }
                }
            }
        }
    }

    GetParsedPatternMinMaxSizeA (IncludingPattern, &min1, &max1);
    GetParsedPatternMinMaxSizeA (IncludedPattern, &min2, &max2);
    if (min2 < min1 || max2 > max1) {
        return FALSE;
    }

    //
    // NTRAID#NTBUG9-153305-2000/08/01-jimschm Not implemented yet
    //
    return FALSE;
}

BOOL
PatternIncludesPatternW (
    IN      PPARSEDPATTERNW IncludingPattern,
    IN      PPARSEDPATTERNW IncludedPattern
    )
{
    PPATTERNPROPSW pp1;
    PPATTERNPROPSW pp2;
    PSEGMENTW ps1;
    PSEGMENTW ps2;
    DWORD min1;
    DWORD max1;
    DWORD min2;
    DWORD max2;

    //
    // only deal with simple patterns for now (PatternCount == 1)
    //
    if (IncludingPattern->PatternCount > 1 || IncludedPattern->PatternCount > 1) {
        DEBUGMSGW ((DBG_ERROR, "PatternIncludesPatternW: multiple patterns not supported yet"));
        return FALSE;
    }

    //
    // test the usual cases first, quickly
    //
    pp1 = IncludingPattern->Pattern;
    MYASSERT (pp1);
    if (pp1->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalW (pp1->Segment)) {
        return TRUE;
    }

    pp2 = IncludedPattern->Pattern;
    MYASSERT (pp2);
    if (pp2->SegmentCount == 1 && ParsedPatternSegmentIsPureOptionalW (pp2->Segment)) {
        return FALSE;
    }

    if (pp1->SegmentCount == 1) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (pp2->SegmentCount == 1) {
                ps2 = pp2->Segment;
                if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                    return ps1->Exact.PhraseBytes == ps2->Exact.PhraseBytes &&
                           StringMatchW (ps1->Exact.LowerCasePhrase, ps2->Exact.LowerCasePhrase);   //lint !e64
                }
            }
        }
    } else if (pp1->SegmentCount == 2) {
        ps1 = pp1->Segment;
        if (ps1->Type == SEGMENTTYPE_EXACTMATCH) {
            if (ParsedPatternSegmentIsPureOptionalW (pp1->Segment + 1)) {
                if (pp2->SegmentCount == 1) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                               StringMatchByteCountW (
                                    ps1->Exact.LowerCasePhrase,
                                    ps2->Exact.LowerCasePhrase,
                                    ps1->Exact.PhraseBytes
                                    );  //lint !e64
                    }
                } else if (pp2->SegmentCount == 2) {
                    ps2 = pp2->Segment;
                    if (ps2->Type == SEGMENTTYPE_EXACTMATCH) {
                        if (ParsedPatternSegmentIsPureOptionalW (pp2->Segment + 1)) {
                            return ps1->Exact.PhraseBytes <= ps2->Exact.PhraseBytes &&
                                   StringMatchByteCountW (
                                        ps1->Exact.LowerCasePhrase,
                                        ps2->Exact.LowerCasePhrase,
                                        ps1->Exact.PhraseBytes
                                        );  //lint !e64
                        }
                    }
                }
            }
        }
    }

    GetParsedPatternMinMaxSizeW (IncludingPattern, &min1, &max1);
    GetParsedPatternMinMaxSizeW (IncludedPattern, &min2, &max2);
    if (min2 < min1 || max2 > max1) {
        return FALSE;
    }

    //
    // NTRAID#NTBUG9-153305-2000/08/01-jimschm  not implemented yet
    //
    return FALSE;
}


VOID
_copymbchar (
    OUT     PSTR sz1,
    IN      PCSTR sz2
    )

/*++

Routine Description:

  _copymbchar transfers the character at sz2 to sz1, which may be one or
  two bytes long.

Arguments:

  sz1       - The destination string
  sz2       - The source string

Return Value:

  none

--*/


{
    if (IsLeadByte (sz2)) {
        sz1[1] = sz2[1];
    }

    *sz1 = *sz2;
}


/*++

Routine Description:

  _tcsctrim removes character c from the end of str if it exists.  It removes
  only one character at the most.

Arguments:

  str       - A pointer to the string that may have character c at the end
  c         - The character that may be at the end of the string

Return Value:

  TRUE if character c was at the end of the string, or FALSE if it was not.

--*/

BOOL
_mbsctrim (
    OUT     PSTR str,
    IN      MBCHAR c
    )
{
    PSTR end;

    end = GetEndOfStringA (str);
    end = _mbsdec2 (str, end);
    if (end && _mbsnextc (end) == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}


BOOL
_wcsctrim (
    OUT     PWSTR str,
    IN      WCHAR c
    )
{
    PWSTR end;

    end = GetEndOfStringW (str);
    end == str ? end = NULL : end--;
    if (end && *end == c) {
        *end = 0;
        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  The FreeStringResourceEx functions are used to free a recently used
  string that is not being passed back to the caller.  In almost all
  cases, this string is at the end of our array of pointers, so we can
  efficiently search sequentially in reverse order.  If the pointer is
  not the last element of the array, it is first swapped with the real
  last element of the array so the array size is reduced.

Arguments:

  AllocTable - The GROWBUFFER table that holds the list of previously
               allocated strings (return values of ParseMessageEx or
               GetResourceStringEx).
  String     - A pointer to the string that is in AllocTable

Return Value:

  none

--*/

VOID
FreeStringResourceExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR String
    )
{
    PCSTR *ptr, *end, *start;

    if (!String) {
        return;
    }

    //
    // Locate string (search sequentially in reverse order)
    //

    if (AllocTable->End < sizeof (PCSTR)) {
        DEBUGMSG ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address table empty", String, String));
        return;
    }

    start = (PCSTR *) AllocTable->Buf;
    end = (PCSTR *) (AllocTable->Buf + AllocTable->End - sizeof (PCSTR));

    ptr = end;
    while (ptr >= start) {
        if (*ptr == String) {
            break;
        }
        ptr--;
    }

    //
    // String not found case
    //

    if (ptr < start) {
        DEBUGMSG ((DBG_ERROR, "FreeStringResourceA: Attempt to free address %x (%s); address not found in table", String, String));
        return;
    }

    //
    // Free LocalAlloc'd memory
    //

    LocalFree ((HLOCAL) String);

    //
    // If this element is not the end, copy real end to the ptr
    //

    if (ptr < end) {
        *ptr = *end;
    }

    //
    // Shrink buffer size
    //

    AllocTable->End -= sizeof (PCSTR);
}


VOID
FreeStringResourcePtrExA (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExA(AllocTable, *String);
        *String = NULL;
    }
}


VOID
FreeStringResourceExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR String
    )
{
    FreeStringResourceExA (AllocTable, (PCSTR) String);
}


VOID
FreeStringResourcePtrExW (
    IN      PGROWBUFFER AllocTable,
    IN OUT  PCWSTR * String
    )
{
    if (NULL != *String) {
        FreeStringResourceExW(AllocTable, *String);
        *String = NULL;
    }
}



/*++

Routine Description:

  The pAddStringResource function is used to track pointers allocated
  by FormatMessage.  They are added to an array (maintained in a GROWBUFFER
  structure).  This table of pointers is used by FreeStringResource or
  StringResourceFree.

Arguments:

  String   - A pointer to a LocalAlloc'd string (the return value of
             FormatMessage).  This string is added to a table of allocated
             strings.

Return Value:

  none

--*/

VOID
pAddStringResource (
    IN      PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PCSTR *ptr;

    ptr = (PCSTR *) GbGrow (GrowBuf, sizeof (PCSTR));
    if (ptr) {
        *ptr = String;
    }
    ELSE_DEBUGMSG ((DBG_ERROR, "pAddStringResource: GrowBuffer failure caused memory leak"));
}


/*++

Routine Description:

  pFreeAllStringResourcesEx frees all strings currently listed in AllocTable.
  This function allows the caller to wait until all processing is done
  to clean up string resources that may have been allocated.

Arguments:

  none

Return Value:

  none

--*/

VOID
pFreeAllStringResourcesEx (
    IN      PGROWBUFFER AllocTable
    )
{
    PCSTR *ptr, *start, *end;

    if (AllocTable->End) {
        start = (PCSTR *) AllocTable->Buf;
        end = (PCSTR *) (AllocTable->Buf + AllocTable->End);

        for (ptr = start ; ptr < end ; ptr++) {
            LocalFree ((HLOCAL) (*ptr));
        }
    }

    GbFree (AllocTable);
}



/*++

Routine Description:

  CreateAllocTable creates a GROWBUFFER structure that can be used with
  ParseMessageEx, GetStringResourceEx, FreeStringResourceEx and
  pFreeAllStringResourcesEx.  Call this function to recieve a private
  allocation table to pass to these functions.  Call DestroyAllocTable
  to clean up.

Arguments:

  none

Return Value:

  A pointer to a GROWBUFFER structure, or NULL if a memory allocation failed.

--*/

PGROWBUFFER
RealCreateAllocTable (
    VOID
    )
{
    PGROWBUFFER allocTable;
    GROWBUFFER tempForInit = INIT_GROWBUFFER;

    allocTable = (PGROWBUFFER) MemAlloc (g_hHeap, 0, sizeof (GROWBUFFER));
    CopyMemory (allocTable, &tempForInit, sizeof (GROWBUFFER));

    return allocTable;
}


/*++

Routine Description:

  DestroyAllocTable cleans up all memory associated with an AllocTable.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure allocated by CreateAllocTable

Return Value:

  none

--*/

VOID
DestroyAllocTable (
    OUT     PGROWBUFFER AllocTable
    )
{
    MYASSERT (AllocTable);
    pFreeAllStringResourcesEx (AllocTable);
    MemFree (g_hHeap, 0, AllocTable);
}


/*++

Routine Description:

  BeginMessageProcessing enters a guarded section of code that plans to use the
  ParseMessage and GetStringResource functions, but needs cleanup at the end
  of processing.

  EndMessageProcessing destroys all memory allocated within the message processing
  block, and leaves the guarded section.

Arguments:

  none

Return Value:

  BeginMessageProcessing returns FALSE if an out-of-memory condition occurrs.

--*/


BOOL
BeginMessageProcessing (
    VOID
    )
{
    if (!TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to enter BeginMessageProcessing while another"
                              "thread is processing messages as well."));
        EnterOurCriticalSection (&g_MessageCs);
    }

    g_LastAllocTable = g_ShortTermAllocTable;
    g_ShortTermAllocTable = CreateAllocTable();

    MYASSERT (g_ShortTermAllocTable);

    return TRUE;
}


VOID
EndMessageProcessing (
    VOID
    )
{
    if (TryEnterOurCriticalSection (&g_MessageCs)) {
        DEBUGMSG ((DBG_ERROR, "Thread attempting to end message processing when it hasn't been started"));
        LeaveOurCriticalSection (&g_MessageCs);
        return;
    }

    DestroyAllocTable (g_ShortTermAllocTable);
    g_ShortTermAllocTable = g_LastAllocTable;
    LeaveOurCriticalSection (&g_MessageCs);
}


/*++

Routine Description:

  ParseMessage is used to obtain a string from the executable's message table
  and parse it with FormatMessage.  An array of arguments can be passed by
  the caller.  FormatMessage will replace %1 with the first element of the
  array, %2 with the second element, and so on.  The array does not need to
  be terminated, and if a message string uses %n, element n must be non-NULL.

Arguments:

  Template  - A string indicating which message to extract, or a WORD value
              cast as a string.  (ParseMessageID does this cast via a macro.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  Pointer to the string allocated.  Call StringResourceFree to free all
  allocated strings (a one-time cleanup for all strings).  The pointer may
  be NULL if the resource does not exist or is empty.

--*/

PCSTR
ParseMessageExA (
    IN      PGROWBUFFER AllocTable,
    IN      PCSTR Template,
    IN      PCSTR ArgArray[]
    )
{
    PSTR MsgBuf;
    DWORD rc;

    if (SHIFTRIGHT16 ((UBINT)Template)) {
        //
        // From string
        //
        rc = FormatMessageA (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_STRING,
                (LPVOID) Template,
                0,
                0,
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    } else {
        //
        // From resource
        //
        rc = FormatMessageA (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)((UBINT)Template),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    }

    if (rc > 0) {
        pAddStringResource (AllocTable, MsgBuf);
        return MsgBuf;
    }

    return NULL;
}


PCWSTR
ParseMessageExW (
    IN      PGROWBUFFER AllocTable,
    IN      PCWSTR Template,
    IN      PCWSTR ArgArray[]
    )
{
    PWSTR MsgBuf;
    DWORD rc;

    if (SHIFTRIGHT16 ((UBINT)Template)) {
        //
        // From string
        //
        rc = FormatMessageW (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_STRING,
                (LPVOID) Template,
                0,
                0,
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    } else {
        //
        // From resource
        //
        rc = FormatMessageW (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (DWORD)(UBINT)Template,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) &MsgBuf,
                0,
                (va_list *) ArgArray
                );
    }

    if (rc > 0) {
        pAddStringResource (AllocTable, (PCSTR) MsgBuf);
        return MsgBuf;
    }

    return NULL;
}



/*++

Routine Description:

  GetStringResourceEx is an argument-less wrapper of ParseMessageEx.  It allows
  the caller to specify a message ID and recieve a pointer to the string if
  it exists, and a table to track FormatMessage's allocations.

Arguments:

  AllocTable - A pointer to a GROWBUFFER structure that is used to maintain
               the handles of allocated strings
  ID         - The ID of the message resource to retrieve

Return Value:

  Pointer to the string allocated.  The return pointer may
  be NULL if the resource does not exist or is empty.

  Call FreeStringResource or DestroyAllocTable to clean up AllocTable.


--*/

PCSTR
GetStringResourceExA (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExA (AllocTable, (PSTR) (WORD) ID, NULL);
}

PCWSTR
GetStringResourceExW (
    IN OUT  PGROWBUFFER AllocTable,
    IN      UINT ID
    )
{
    return ParseMessageExW (AllocTable, (PWSTR) (WORD) ID, NULL);
}



/*++

Routine Description:

  ParseMessageInWnd is used to exchange a string in a window with one from
  the executable's message table.  It is provided for dialog box initialization,
  where a field in the dialog box requires dynamic data.  The dialog box
  resource should contain a control with its window text set to the message
  string.  Upon processing WM_INITDIALOG, the code should call ParseMessageInWnd,
  supplying the necessary ArgArray, so the dialog box is initialized with
  a dynamic message.

Arguments:

  hwnd      - The handle of a window whose title contains the message string ID
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  none

--*/

VOID
ParseMessageInWndA (
    IN      HWND Hwnd,
    IN      PCSTR ArgArray[]
    )
{
    CHAR buffer[512];
    PCSTR parsedMsg;

    GetWindowTextA (Hwnd, buffer, 512);
    parsedMsg = ParseMessageA (buffer, ArgArray);
    if (parsedMsg) {
        SetWindowTextA (Hwnd, parsedMsg);
        FreeStringResourceA (parsedMsg);
    }
}


VOID
ParseMessageInWndW (
    IN      HWND hwnd,
    IN      PCWSTR ArgArray[]
    )
{
    WCHAR buffer[512];
    PCWSTR parsedMsg;

    GetWindowTextW (hwnd, buffer, 512);
    parsedMsg = ParseMessageW (buffer, ArgArray);
    if (parsedMsg) {
        SetWindowTextW (hwnd, parsedMsg);
        FreeStringResourceW (parsedMsg);
    }
}



/*++

Routine Description:

  ResourceMessageBox is used to display a message based on a message resource
  ID.

Arguments:

  HwndOwner - The handle of the owner of the message box to be displayed
  ID        - The identifier of the message resource
  Flags     - MessageBox flags (MB_OK, etc.)
  ArgArray  - Optional array of string pointers, where the meaning depends on
              the message string.  A reference in the message string to %n
              requires element n of ArgArray to be a valid string pointer.

Return Value:

  The return value of MessageBox (MB_YES, etc.)

--*/

INT
ResourceMessageBoxA (
    IN      HWND HwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCSTR ArgArray[]
    )
{
    PCSTR message;
    PCSTR title;
    int rc;

    message = ParseMessageA ((PSTR)(UBINT)ID, ArgArray);
    if (!message)
        return -1;

    title = GetStringResourceA (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxA (HwndOwner, message, title, Flags);

    FreeStringResourceA (message);
    if (title) {
        FreeStringResourceA (title);
    }

    return rc;
}


INT
ResourceMessageBoxW (
    IN      HWND HwndOwner,
    IN      UINT ID,
    IN      UINT Flags,
    IN      PCWSTR ArgArray[]
    )
{
    PCWSTR message;
    PCWSTR title;
    int rc;

    message = ParseMessageW ((PWSTR)(UBINT)ID, ArgArray);
    if (!message)
        return -1;

    title = GetStringResourceW (MSG_MESSAGEBOX_TITLE);

    rc = MessageBoxW (HwndOwner, message, title, Flags);

    FreeStringResourceW (message);
    if (title) {
        FreeStringResourceW (title);
    }

    return rc;
}


BOOL
StringReplaceA (
    IN      PSTR Buffer,
    IN      DWORD MaxSize,
    IN      PSTR ReplaceStartPos,
    IN      PSTR ReplaceEndPos,
    IN      PCSTR NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PSTR        movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);  //lint !e613
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (DWORD)((UBINT)ReplaceEndPos - (UBINT)ReplaceStartPos);
    newSubStringLength  = ByteCountA(NewString);
    currentStringLength = SizeOfStringA(Buffer) + 1;
    offset = (LONG)newSubStringLength - (LONG)oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if ((LONG)currentStringLength + offset > (LONG)MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    } else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 (UBINT)movePosition >= (UBINT)ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        } else {

            //
            // left or no shift.
            //
            for(movePosition = ReplaceStartPos + newSubStringLength;    //lint !e613
                movePosition < Buffer + currentStringLength;
                movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        CopyMemory (ReplaceStartPos, NewString, newSubStringLength);    //lint !e668

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}



BOOL
StringReplaceW (
    IN      PWSTR Buffer,
    IN      DWORD MaxSize,
    IN      PWSTR ReplaceStartPos,
    IN      PWSTR ReplaceEndPos,
    IN      PCWSTR NewString
    )
{
    BOOL        rf = FALSE;
    DWORD       oldSubStringLength;
    DWORD       newSubStringLength;
    DWORD       currentStringLength;
    LONG        offset;
    PWSTR       movePosition;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos   && ReplaceEndPos >= ReplaceStartPos);  //lint !e613
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (DWORD)((UBINT)ReplaceEndPos - (UBINT)ReplaceStartPos);
    newSubStringLength  = CharCountW(NewString);
    currentStringLength = CharCountW(Buffer) + 1;
    offset = (LONG)newSubStringLength - (LONG)oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if ((LONG)currentStringLength + offset > (LONG)MaxSize) {
        DEBUGMSG((DBG_WARNING,"ERROR: Buffer to small to perform string replacement."));
        rf = FALSE;
    } else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (newSubStringLength > oldSubStringLength) {

            //
            // right shift.
            //
            for (movePosition = Buffer + currentStringLength;
                 (UBINT)movePosition >= (UBINT)ReplaceStartPos + oldSubStringLength;
                 movePosition--) {

                *(movePosition + offset) = *movePosition;
            }
        } else {

            //
            // left or no shift.
            //
            for (movePosition = ReplaceStartPos + newSubStringLength;    //lint !e613
                 movePosition < Buffer + currentStringLength;
                 movePosition++) {

                *movePosition = *(movePosition - offset);
            }

        }

        //
        // Now, copy in the string.
        //
        wcsncpy(ReplaceStartPos,NewString,newSubStringLength);

        //
        // String replacement completed successfully.
        //
        rf = TRUE;


    }

    return rf;

}

/*++

Routine Description:

  AddInfSectionToHashTable enumerates the specified section and adds each
  item to the string table.  An optional callback allows data to be associated
  with each item.

Arguments:

  Table          - Specifies the table that receives new entries
  InfFile        - Specifies an open INF handle of the file to read
  Section        - Specifies the INF section name to enumerate
  Field          - Specifies which field to extract text from.  If the field
                   exists, it is added to the string table.
  Callback       - Specifies optional callback to be called before adding to
                   the string table.  The callback supplies additional data.
  CallbackParam  - Data passed to the callback

Return Value:

  TRUE if the INF file was processed successfullly, or FALSE if an error
  occurred.

--*/


BOOL
AddInfSectionToHashTableA (
    IN OUT  HASHTABLE Table,
    IN      HINF InfFile,
    IN      PCSTR Section,
    IN      DWORD Field,
    IN      ADDINFSECTION_PROCA Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    LONG rc;
    HASHTABLE ht;
    DWORD reqSize;
    DWORD currentSize = 0;
    PSTR newBuffer, buffer = NULL;
    PVOID data;
    UINT dataSize;
    BOOL b = FALSE;

    //
    // On NT, Setup API is compiled with UNICODE, so the string table
    // functions are UNICODE only.
    //

    if (ISNT()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineA (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldA (&ic, Field, NULL, 0, &reqSize)) {
                continue;
            }

            if (reqSize > currentSize) {
                reqSize = ((reqSize / 1024) + 1) * 1024;
                if (buffer) {
                    newBuffer = (PSTR) MemReAlloc (g_hHeap, 0, buffer, reqSize);
                } else {
                    newBuffer = (PSTR) MemAlloc (g_hHeap, 0, reqSize);
                }

                if (!newBuffer) {
                    goto cleanup;
                }

                buffer = newBuffer;
                currentSize = reqSize;
            }

            if (!SetupGetStringFieldA (&ic, Field, buffer, currentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToHashTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            data = NULL;
            dataSize = 0;

            if (Callback) {
                rc = Callback (buffer, &data, &dataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            ht = HtAddStringExA (
                        Table,
                        buffer,
                        data,
                        CASE_INSENSITIVE
                        );

            if (!ht) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (buffer) {
        PushError();
        MemFree (g_hHeap, 0, buffer);
        PopError();
    }
    return b;
}


BOOL
AddInfSectionToHashTableW (
    IN OUT  HASHTABLE Table,
    IN      HINF InfFile,
    IN      PCWSTR Section,
    IN      DWORD Field,
    IN      ADDINFSECTION_PROCW Callback,
    IN      PVOID CallbackData
    )
{
    INFCONTEXT ic;
    HASHTABLE ht;
    LONG rc;
    DWORD reqSize;
    DWORD currentSize = 0;
    PWSTR newBuffer, buffer = NULL;
    PVOID data;
    UINT dataSize;
    BOOL b = FALSE;

    //
    // On Win9x, Setup API is compiled with ANSI, so the string table
    // functions are ANSI only.
    //

    if (ISWIN9X()) {
        SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (SetupFindFirstLineW (InfFile, Section, NULL, &ic)) {
        do {
            if (!SetupGetStringFieldW (&ic, Field, NULL, 0, &reqSize)) {
                continue;
            }

            if (reqSize > currentSize) {
                reqSize = ((reqSize / 1024) + 1) * 1024;
                if (buffer) {
                    newBuffer = (PWSTR) MemReAlloc (g_hHeap, 0, buffer, reqSize);
                } else {
                    newBuffer = (PWSTR) MemAlloc (g_hHeap, 0, reqSize);
                }

                if (!newBuffer) {
                    goto cleanup;
                }

                buffer = newBuffer;
                currentSize = reqSize;
            }

            if (!SetupGetStringFieldW (&ic, Field, buffer, currentSize, NULL)) {
                DEBUGMSG ((DBG_ERROR, "AddInfSectionToHashTable: SetupGetStringField failed unexpectedly"));
                continue;
            }

            data = NULL;
            dataSize = 0;

            if (Callback) {
                rc = Callback (buffer, &data, &dataSize, CallbackData);
                if (rc == CALLBACK_STOP) {
                    goto cleanup;
                }
                if (rc == CALLBACK_SKIP) {
                    continue;
                }
            }

            ht = HtAddStringExW (
                        Table,
                        buffer,
                        data,
                        CASE_INSENSITIVE
                        );

            if (!ht) {
                goto cleanup;
            }

        } while (SetupFindNextLine (&ic, &ic));
    }

    b = TRUE;

cleanup:
    if (buffer) {
        PushError();
        MemFree (g_hHeap, 0, buffer);
        PopError();
    }
    return b;
}


/*++

Routine Description:

  Finds the last wack in the path and returns a pointer to the next
  character.  If no wack is found, returns a pointer to the full
  string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file name in the path.

--*/

PCSTR
GetFileNameFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;

    p = _mbsrchr (PathSpec, '\\');
    if (p) {
        p = _mbsinc (p);
    } else {
        p = PathSpec;
    }

    return p;
}

PCWSTR
GetFileNameFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;

    p = wcsrchr (PathSpec, L'\\');
    if (p) {
        p++;
    } else {
        p = PathSpec;
    }

    return p;
}


/*++

Routine Description:

  Finds the last wack in the path and then the last point from the remaining path
  returning a pointer to the next character. If no point is found, returns a null pointer.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, excluding the dot, or NULL if no extension exists.

--*/

PCSTR
GetFileExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p + 1;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = _mbsinc (p);
    }

    return ReturnPtr;
}


PCWSTR
GetFileExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p + 1;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  GetDotExtensionFromPath finds the last wack in the path and then the last dot from
  the remaining path, returning a pointer to the dot. If no dot is found, returns the
  end of the string.

Arguments:

  PathSpec  - Specifies the path that has a file at the end of it

Return Value:

  A pointer to the file extension, including the dot, or the end of the string if
  no extension exists.

--*/

PCSTR
GetDotExtensionFromPathA (
    IN      PCSTR PathSpec
    )

{
    PCSTR p;
    PCSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == '.') {
            ReturnPtr = p;
        } else if (*p == '\\') {
            ReturnPtr = NULL;
        }

        p = _mbsinc (p);
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


PCWSTR
GetDotExtensionFromPathW (
    IN      PCWSTR PathSpec
    )

{
    PCWSTR p;
    PCWSTR ReturnPtr = NULL;

    p = PathSpec;

    while (*p) {
        if (*p == L'.') {
            ReturnPtr = p;
        } else if (*p == L'\\') {
            ReturnPtr = NULL;
        }

        p++;
    }

    if (!ReturnPtr) {
        return p;
    }

    return ReturnPtr;
}


/*++

Routine Description:

  CountInstancesOfChar returns the number of occurances Char
  is found in String.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT count;

    count = 0;
    while (*String) {
        if (_mbsnextc (String) == Char) {
            count++;
        }

        String = _mbsinc (String);
    }

    return count;
}


UINT
CountInstancesOfCharW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT count;

    count = 0;
    while (*String) {
        if (*String == Char) {
            count++;
        }

        String++;
    }

    return count;
}


/*++

Routine Description:

  CountInstancesOfCharI returns the number of occurances Char
  is found in String.  The comparison is case-insenetive.

Arguments:

  String - Specifies the text that may or may not contain
           search text

  Char - Specifies the char to count

Return Value:

  The number of times Char appears in String.

--*/

UINT
CountInstancesOfCharIA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    UINT count;

    Char = (MBCHAR)OURTOLOWER ((INT)Char);

    count = 0;
    while (*String) {
        if ((MBCHAR) OURTOLOWER ((INT)_mbsnextc (String)) == Char) {
            count++;
        }

        String = _mbsinc (String);
    }

    return count;
}


UINT
CountInstancesOfCharIW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    UINT count;

    Char = towlower (Char);

    count = 0;
    while (*String) {
        if (towlower (*String) == Char) {
            count++;
        }

        String++;
    }

    return count;
}


/*++

Routine Description:

  Searches the string counting the number of occurances of
  SearchString exist in SourceString.

Arguments:

  SourceString - Specifies the text that may or may not contain
                 search text

  SearchString - Specifies the text phrase to count

Return Value:

  The number of times SearchString appears in SourceString.

--*/

UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    )
{
    PCSTR p;
    UINT count;
    UINT searchBytes;

    count = 0;
    p = SourceString;
    searchBytes = ByteCountA (SearchString);

    while (p = _mbsistr (p, SearchString)) {    //lint !e720
        count++;
        p += searchBytes;
    }

    return count;
}


UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    )
{
    PCWSTR p;
    UINT count;
    UINT SearchChars;

    count = 0;
    p = SourceString;
    SearchChars = CharCountW (SearchString);

    while (p = _wcsistr (p, SearchString)) {    //lint !e720
        count++;
        p += SearchChars;
    }

    return count;
}


/*++

Routine Description:

  Searches and replaces all occurances of SearchString with
  ReplaceString.

Arguments:

  SourceString - String that contiains zero or more instances
                 of the search text

  SearchString - String to search for.  Cannot be zero-length or NULL.

  ReplaceString - String to replace.  Can be zero-length but cannot
                  be NULL.

Return Value:

  A pointer to the pool-allocated string, or NULL if no instances
  of SearchString were found in SourceString.  Free the non-NULL
  pointer with FreePathString.

--*/

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    )
{
    PSTR newString;
    PBYTE p, q;
    PBYTE dest;
    UINT count;
    UINT size;
    UINT searchBytes;
    UINT replaceBytes;
    UINT untouchedBytes;

    //
    // count occurances within the string
    //

    count = CountInstancesOfSubStringA (
                SourceString,
                SearchString
                );

    if (!count) {
        return NULL;
    }

    searchBytes = ByteCountA (SearchString);
    replaceBytes = ByteCountA (ReplaceString);
    MYASSERT (searchBytes);

    size = SizeOfStringA (SourceString) -
           count * searchBytes +
           count * replaceBytes;

    newString = (PSTR) PmGetAlignedMemory (g_PathsPool, size);
    if (!newString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    dest = (PBYTE) newString;

    while (q = (PBYTE) _mbsistr ((PCSTR) p, SearchString)) {    //lint !e720

        untouchedBytes = (DWORD)(q - p);

        if (untouchedBytes) {
            CopyMemory (dest, p, (SIZE_T) untouchedBytes);
            dest += untouchedBytes;
        }

        if (replaceBytes) {
            CopyMemory (dest, (PBYTE) ReplaceString, (SIZE_T) replaceBytes);
            dest += replaceBytes;
        }

        p = q + searchBytes;
    }

    StringCopyA ((PSTR) dest, (PSTR) p);

    return newString;
}


PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    )
{
    PWSTR newString;
    PBYTE p, q;
    PBYTE dest;
    UINT count;
    UINT size;
    UINT searchBytes;
    UINT replaceBytes;
    UINT untouchedBytes;

    //
    // count occurances within the string
    //

    count = CountInstancesOfSubStringW (
                SourceString,
                SearchString
                );

    if (!count) {
        return NULL;
    }

    searchBytes = ByteCountW (SearchString);
    replaceBytes = ByteCountW (ReplaceString);
    MYASSERT (searchBytes);

    size = SizeOfStringW (SourceString) -
           count * searchBytes +
           count * replaceBytes;

    newString = (PWSTR) PmGetAlignedMemory (g_PathsPool, size);
    if (!newString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    dest = (PBYTE) newString;

    while (q = (PBYTE) _wcsistr ((PCWSTR) p, SearchString)) {   //lint !e720

        untouchedBytes = (DWORD)(q - p);

        if (untouchedBytes) {
            CopyMemory (dest, p, (SIZE_T) untouchedBytes);
            dest += untouchedBytes;
        }

        if (replaceBytes) {
            CopyMemory (dest, (PBYTE) ReplaceString, (SIZE_T) replaceBytes);
            dest += replaceBytes;
        }

        p = q + searchBytes;
    }

    StringCopyW ((PWSTR) dest, (PWSTR) p);

    return newString;
}


PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     PUINT NumArgs
    )

/*++

Routine Description:

  CommandLineToArgvA implements an ANSI version of the Win32 function
  CommandLineToArgvW.

Arguments:

  CmdLine   - A pointer to the complete command line, including the
              module name.  This is the same string returned by
              GetCommandLineA().

  NumArgs   - Receives the number of arguments allocated, identical to
              main's argc parameter.  That is, NumArgs is equal to
              the number of command line arguments plus one for the
              command itself.

Return Value:

  A pointer to an array of string pointers, one per argument.  The
  command line arguments are placed in separate nul-terminated strings.
  The caller must free the memory using a single call to GlobalFree or
  LocalFree.

--*/

{
    PCSTR start, end;
    BOOL QuoteMode;
    MBCHAR ch = 0;
    UINT Pass;
    UINT ArgStrSize;
    UINT Args;
    PSTR ArgStrEnd = NULL;     // filled in on pass one, used on pass two
    PSTR *ArgPtrArray = NULL;  // filled in on pass one, used on pass two

    //
    // count args on first pass, then allocate memory and create arg string
    //

    ArgStrSize = 0;
    Pass = 0;
    do {
        // Init loop
        Pass++;
        Args = 0;
        start = CmdLine;

        // Skip leading space
        while (_ismbcspace (*start)) {
            start++;
        }

        while (*start) {
            // Look for quote mode
            if (*start == '\"') {
                QuoteMode = TRUE;
                start++;
            } else {
                QuoteMode = FALSE;
            }

            // Find end of arg
            end = start;
            while (*end) {
                ch = _mbsnextc (end);
                if (QuoteMode) {
                    if (ch == '\"') {
                        break;
                    }
                } else {
                    if (_ismbcspace ((MBCHAR)ch)) {
                        break;
                    }
                }

                end = _mbsinc (end);
            }

            // If Pass 1, add string size
            if (Pass == 1) {
                ArgStrSize += (UINT)((UBINT)end - (UBINT)start) + 1;
            }

            // If Pass 2, copy strings to buffer
            else {
                MYASSERT (ArgStrEnd);
                MYASSERT (ArgPtrArray);

                ArgPtrArray[Args] = ArgStrEnd;  //lint !e613
                StringCopyABA (ArgStrEnd, start, end);
                ArgStrEnd = GetEndOfStringA (ArgStrEnd);    //lint !e668
                ArgStrEnd++;    //lint !e613
            }

            // Set start to next arg
            Args++;

            if (QuoteMode && ch == '\"') {
                end = _mbsinc (end);
            }

            start = end;
            while (_ismbcspace (*start)) {
                start++;
            }
        }

        // If Pass 1, allocate strings
        if (Pass == 1) {
            if (Args) {
                ArgPtrArray = (PSTR *) GlobalAlloc (
                                            GPTR,
                                            (UINT)(sizeof (PSTR) * Args + ArgStrSize)
                                            );
                if (!ArgPtrArray) {
                    return NULL;
                }

                ArgStrEnd = (PSTR) (&ArgPtrArray[Args]);
            } else {
                return NULL;
            }
        }
    } while (Pass < 2);

    *NumArgs = Args;
    return ArgPtrArray;
}


BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringA (MultiSzEnum->CurrentString) + 1;  //lint !e613
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}


BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    )
{
    if (!MultiSzEnum->CurrentString || !(*MultiSzEnum->CurrentString)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = GetEndOfStringW (MultiSzEnum->CurrentString) + 1;
    return (MultiSzEnum->CurrentString [0] != 0);
}

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    )
{
    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }
    MultiSzEnum->Buffer  = MultiSzStr;
    MultiSzEnum->CurrentString = MultiSzStr;
    return TRUE;
}

BOOL
IsStrInMultiSzA (
    IN      PCSTR String,
    IN      PCSTR MultiSz
    )
{
    BOOL result = FALSE;
    MULTISZ_ENUMA multiSzEnum;

    if (EnumFirstMultiSzA (&multiSzEnum, MultiSz)) {
        do {
            if (StringIMatchA (String, multiSzEnum.CurrentString)) {
                result = TRUE;
                break;
            }
        } while (EnumNextMultiSzA (&multiSzEnum));
    }
    return result;
}

BOOL
IsStrInMultiSzW (
    IN      PCWSTR String,
    IN      PCWSTR MultiSz
    )
{
    BOOL result = FALSE;
    MULTISZ_ENUMW multiSzEnum;

    if (EnumFirstMultiSzW (&multiSzEnum, MultiSz)) {
        do {
            if (StringIMatchW (String, multiSzEnum.CurrentString)) {
                result = TRUE;
                break;
            }
        } while (EnumNextMultiSzW (&multiSzEnum));
    }
    return result;
}

PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      MBCHAR SearchChar
    )
{
    PCSTR ptr = CurrPtr;

    for (;;) {
        ptr = _mbsdec2 (StartStr, ptr);

        if (!ptr) {
            return NULL;
        }
        if (_mbsnextc (ptr) == SearchChar) {
            return (PSTR) ptr;
        }
    }
}


PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    )
{
    PCWSTR ptr = CurrPtr;

    while (ptr > StartStr) {
        ptr--;

        if (*ptr == SearchChar) {
            return (PWSTR) ptr;
        }
    }

    return NULL;
}


VOID
ToggleWacksA (
    IN      PSTR Line,
    IN      BOOL Operation
    )
{
    CHAR curChar;
    CHAR newChar;
    PSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : '\\';
    newChar = Operation ? '\\' : WACK_REPLACE_CHAR;

    do {

        p = _mbschr (p, curChar);

        if (p) {

            *p = newChar;
            p = _mbsinc (p);
        }

    } while (p);
}


VOID
ToggleWacksW (
    IN      PWSTR Line,
    IN      BOOL Operation
    )
{
    WCHAR curChar;
    WCHAR newChar;
    PWSTR p = Line;


    curChar = Operation ? WACK_REPLACE_CHAR : L'\\';
    newChar = Operation ? L'\\' : WACK_REPLACE_CHAR;

    do {

        p = wcschr (p, curChar);

        if (p) {

            *p = newChar;
            p++;
        }

    } while (p);
}


PSTR
pGoBackA (
    IN      PSTR LastChar,
    IN      PSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar = _mbsdec2 (FirstChar, LastChar);
    while (NumWacks && (LastChar >= FirstChar)) {
        if (_mbsnextc (LastChar) == '\\') {
            NumWacks --;
        }
        LastChar = _mbsdec2 (FirstChar, LastChar);
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}


PWSTR
pGoBackW (
    IN      PWSTR LastChar,
    IN      PWSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar --;
    while (NumWacks && (LastChar >= FirstChar)) {
        if (*LastChar == L'\\') {
            NumWacks --;
        }
        LastChar --;
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}


UINT
pCountDotsA (
    IN      PCSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (_mbsnextc (PathSeg) != '.') {
            return 0;
        }
        numDots ++;
        PathSeg = _mbsinc (PathSeg);
    }
    return numDots;
}


UINT
pCountDotsW (
    IN      PCWSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (*PathSeg != L'.') {
            return 0;
        }
        numDots ++;
        PathSeg ++;
    }
    return numDots;
}

PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    )
{
    CHAR pathSeg [MAX_MBCHAR_PATH];
    PCSTR wackPtr;
    UINT dotNr;
    PSTR newPath = DuplicatePathStringA (FileSpec, 0);
    PSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = _mbschr (FileSpec, '\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr = _mbsinc (wackPtr);
                if (!wackPtr) {
                    FreePathStringA (newPath);
                    return NULL;
                }
                if (_mbsnextc (wackPtr) == '\\') {
                    // this one starts with a double wack
                    wackPtr = _mbsinc (wackPtr);
                    if (!wackPtr) {
                        FreePathStringA (newPath);
                        return NULL;
                    }
                    wackPtr = _mbschr (wackPtr, '\\');
                } else {
                    wackPtr = _mbschr (wackPtr, '\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {

                StringCopyByteCountABA (
                    pathSeg,
                    FileSpec,
                    wackPtr,
                    MAX_MBCHAR_PATH
                    );

                FileSpec = _mbsinc (wackPtr);
            } else {
                StringCopyByteCountABA (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MAX_MBCHAR_PATH);
            }
        } else {
            StringCopyByteCountABA (pathSeg, FileSpec, GetEndOfStringA (FileSpec), MAX_MBCHAR_PATH);
        }

        if (*pathSeg) {
            dotNr = pCountDotsA (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackA (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGA ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringA (newPath);
                    return NULL;
                }
            } else {

                StringCopyA (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringA (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = '\\';
                    //we increment this because we know that \ is a single byte character.
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR pathSeg [MEMDB_MAX];
    PCWSTR wackPtr;
    UINT dotNr;
    PWSTR newPath = DuplicatePathStringW (FileSpec, 0);
    PWSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;

    do {
        wackPtr = wcschr (FileSpec, L'\\');

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr ++;
                if (*wackPtr == L'\\') {
                    // this one starts with a double wack
                    wackPtr ++;
                    wackPtr = wcschr (wackPtr, L'\\');
                } else {
                    wackPtr = wcschr (wackPtr, L'\\');
                }
            }
            firstPass = FALSE;
            if (wackPtr) {

                StringCopyByteCountABW (
                    pathSeg,
                    FileSpec,
                    wackPtr,
                    (UINT) sizeof (pathSeg)
                    );

                FileSpec = wackPtr + 1;
            } else {
                StringCopyByteCountABW (pathSeg, FileSpec, GetEndOfStringW (FileSpec), (UINT) sizeof (pathSeg));
            }
        } else {
            StringCopyByteCountABW (pathSeg, FileSpec, GetEndOfStringW (FileSpec), (UINT) sizeof (pathSeg));
        }

        if (*pathSeg) {
            dotNr = pCountDotsW (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBackW (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    DEBUGMSGW ((DBG_WARNING, "Broken path detected:%s", FileSpec));
                    FreePathStringW (newPath);
                    return NULL;
                }
            } else {

                StringCopyW (newPathPtr, pathSeg);
                newPathPtr = GetEndOfStringW (newPathPtr);
                if (wackPtr) {
                    *newPathPtr = L'\\';
                    newPathPtr ++;
                }
            }
        }
    } while (wackPtr);

    *newPathPtr = 0;

    return newPath;
}

UINT
pBuildFromDHList (
    IN      UINT ch1,
    IN      UINT ch2
    )
{
    PDHLIST p;
    UINT result = 0;

    p = g_DHList;
    while (p->char1) {
        if ((p->char1 == ch1) && (p->char2 == ch2)) {
            result = p->result;
            break;
        }
        p++;
    }
    return result;
}


VOID
_mbssetchar (
    OUT     PSTR Dest,
    IN      UINT Char
    )
{
    if (Char >= 256) {
        *(Dest+1) = *((PBYTE)(&Char));
        *(Dest) = *((PBYTE)(&Char) + 1);
    }
    else {
        *Dest = (CHAR) Char;
    }
}


/*++

Routine Description:

    FindLastWack finds the position of the last \ in the given string or NULL if none found

Arguments:

    Str - Specifies the string

Return Value:

    Pointer to the last occurence of a \ in the string or NULL

--*/

PCSTR
FindLastWackA (
    IN      PCSTR Str
    )
{
    PCSTR lastWack = NULL;

    if (Str) {
        while ((Str = _mbschr (Str, '\\')) != NULL) {
            lastWack = Str;
            Str++;
        }
    }

    return lastWack;
}


PCWSTR
FindLastWackW (
    IN      PCWSTR Str
    )
{
    PCWSTR lastWack = NULL;

    if (Str) {
        while ((Str = wcschr (Str, L'\\')) != NULL) {
            lastWack = Str;
            Str++;
        }
    }

    return lastWack;
}


/*++

Routine Description:

    GetNodePatternMinMaxLevels treats the given string pattern as a path with \ as separator
    and computes the min and max levels of the given node; the root has level 1; if a * is
    followed by \ it is treated as a single level (e.g. *\ only enumerates roots)

Arguments:

    NodePattern - Specifies the node as a string pattern
    FormattedNodePattern - Receives the formatted string, eliminating duplicate * and the last \;
                    may be the same as NodePattern
    MinLevel - Receives the minimum level of a node having this pattern
    MaxLevel - Receives the maximum level of a node having this pattern; may be NODE_LEVEL_MAX

Return Value:

    TRUE if NodePattern is a valid pattern and the function succeeded, FALSE otherwise

--*/

#define NODESTATE_BEGIN     0
#define NODESTATE_UNC       1
#define NODESTATE_BEGINSEG  2
#define NODESTATE_INSEG     3
#define NODESTATE_ESCAPED   4
#define NODESTATE_STAR      5
#define NODESTATE_STARONLY  6
#define NODESTATE_INEXPAT   7
#define NODESTATE_QMARK     8

BOOL
GetNodePatternMinMaxLevelsA (
    IN          PCSTR NodePattern,
    OUT         PSTR FormattedNode,     OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    )
{
    PCSTR nodePattern = NodePattern;
    MBCHAR currCh = 0;
    DWORD minLevel = 0;
    DWORD maxLevel = 0;
    DWORD state = NODESTATE_BEGIN;
    BOOL advance;
    BOOL copyChar;

    if (!NodePattern || *NodePattern == 0) {
        return FALSE;
    }

    while (*nodePattern) {
        advance = TRUE;
        copyChar = TRUE;
        currCh = _mbsnextc (nodePattern);
        switch (state) {
        case NODESTATE_BEGIN:
            switch (currCh) {
            case '\\':
                state = NODESTATE_UNC;
                break;
            case '*':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '?':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_ESCAPED;
                break;
            default:
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_UNC:
            minLevel ++;
            if (maxLevel != NODE_LEVEL_MAX) {
                maxLevel ++;
            }
            switch (currCh) {
            case '\\':
                state = NODESTATE_BEGINSEG;
                break;
            case '*':
                state = NODESTATE_BEGINSEG;
                advance = FALSE;
                break;
            case '?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_BEGINSEG:
            switch (currCh) {
            case '\\':
                DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: two wacks in a row: %s", NodePattern));
                return FALSE;
            case '*':
                minLevel --;
                state = NODESTATE_STARONLY;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case '?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_STARONLY:
            state = NODESTATE_INSEG;
            switch (currCh) {
            case '*':
                copyChar = FALSE;
                break;
            case '[':
                state = NODESTATE_INEXPAT;
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            default:
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                advance = FALSE;
            }
            break;
        case NODESTATE_INEXPAT:
            // NTRAID#NTBUG9-153307-2000/08/01-jimschm  Min/max parsing needs to be more extensive
            // so we can allow ] in the excluded or included list
            // The syntax checking needs to be quite extensive
            switch (currCh) {
            case ']':
                state = NODESTATE_INSEG;
                break;
            default:
                break;
            }
            break;
        case NODESTATE_STAR:
            switch (currCh) {
            case '*':
                state = NODESTATE_STAR;
                copyChar = FALSE;
                break;
            case '[':
                state = NODESTATE_INEXPAT;
                break;
            default:
                state = NODESTATE_INSEG;
                advance = FALSE;
            }
            break;
        case NODESTATE_QMARK:
            switch (currCh) {
            case '[':
                state = NODESTATE_INEXPAT;
                break;
            default:
                state = NODESTATE_INSEG;
                advance = FALSE;
            }
            break;
        case NODESTATE_INSEG:
            switch (currCh) {
            case '\\':
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                state = NODESTATE_BEGINSEG;
                break;
            case '*':
                state = NODESTATE_STAR;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case '?':
                state = NODESTATE_QMARK;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            case '^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_ESCAPED:
            if (!_mbschr (EscapedCharsA, currCh)) {
                DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: illegal escaped character: %s", NodePattern));
                return FALSE;
            }
            state = NODESTATE_INSEG;
            break;
        default:
            DEBUGMSGA ((DBG_STRINGS, "GetNodeMinMaxLevelsA: unknown state while processing: %s", NodePattern));
            return FALSE;
        }
        if (advance) {
            if (copyChar && FormattedNode) {
                if (IsLeadByte (nodePattern)) {
                    *FormattedNode = *nodePattern;
                    FormattedNode ++;
                    nodePattern ++;
                }
                *FormattedNode = *nodePattern;
                FormattedNode ++;
                nodePattern ++;
            } else {
                nodePattern = _mbsinc (nodePattern);
            }
        }
    }
    if (MinLevel) {
        *MinLevel = minLevel;
    }
    if (MaxLevel) {
        *MaxLevel = maxLevel;
    }
    if (FormattedNode) {
        *FormattedNode = 0;
    }
    return TRUE;
}

BOOL
GetNodePatternMinMaxLevelsW (
    IN          PCWSTR NodePattern,
    OUT         PWSTR FormattedNode,    OPTIONAL
    OUT         PDWORD MinLevel,        OPTIONAL
    OUT         PDWORD MaxLevel         OPTIONAL
    )
{
    PCWSTR nodePattern = NodePattern;
    DWORD minLevel = 0;
    DWORD maxLevel = 0;
    DWORD state = NODESTATE_BEGIN;
    BOOL advance;
    BOOL copyChar;

    if (!NodePattern || *NodePattern == 0) {
        return FALSE;
    }

    while (*nodePattern) {
        advance = TRUE;
        copyChar = TRUE;
        switch (state) {
        case NODESTATE_BEGIN:
            switch (*nodePattern) {
            case L'\\':
                state = NODESTATE_UNC;
                break;
            case L'*':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'?':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_ESCAPED;
                break;
            default:
                minLevel ++;
                maxLevel ++;
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_UNC:
            minLevel ++;
            if (maxLevel != NODE_LEVEL_MAX) {
                maxLevel ++;
            }
            switch (*nodePattern) {
            case L'\\':
                state = NODESTATE_BEGINSEG;
                break;
            case L'*':
                state = NODESTATE_BEGINSEG;
                advance = FALSE;
                break;
            case L'?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_BEGINSEG:
            switch (*nodePattern) {
            case L'\\':
                DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: two wacks in a row: %s", NodePattern));
                return FALSE;
            case L'*':
                minLevel --;
                state = NODESTATE_STARONLY;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case L'?':
                state = NODESTATE_INSEG;
                advance = FALSE;
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_STARONLY:
            state = NODESTATE_INSEG;
            switch (*nodePattern) {
            case L'*':
                copyChar = FALSE;
                break;
            case L'[':
                state = NODESTATE_INEXPAT;
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            default:
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                advance = FALSE;
            }
            break;
        case NODESTATE_INEXPAT:
            // NTRAID#NTBUG9-153307-2000/08/01-jimschm  Min/max parsing needs to be more extensive
            // so we can allow ] in the excluded or included list
            // The syntax checking needs to be quite extensive
            switch (*nodePattern) {
            case L']':
                state = NODESTATE_INSEG;
                break;
            default:
                break;
            }
            break;
        case NODESTATE_STAR:
            switch (*nodePattern) {
            case L'*':
                state = NODESTATE_STAR;
                copyChar = FALSE;
                break;
            case L'[':
                state = NODESTATE_INEXPAT;
                break;
            default:
                state = NODESTATE_INSEG;
                advance = FALSE;
            }
            break;
        case NODESTATE_QMARK:
            switch (*nodePattern) {
            case L'[':
                state = NODESTATE_INEXPAT;
                break;
            default:
                state = NODESTATE_INSEG;
                advance = FALSE;
            }
            break;
        case NODESTATE_INSEG:
            switch (*nodePattern) {
            case L'\\':
                minLevel ++;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                state = NODESTATE_BEGINSEG;
                break;
            case L'*':
                state = NODESTATE_STAR;
                maxLevel = NODE_LEVEL_MAX;
                break;
            case L'?':
                state = NODESTATE_QMARK;
                if (maxLevel != NODE_LEVEL_MAX) {
                    maxLevel ++;
                }
                break;
            case L'^':
                state = NODESTATE_ESCAPED;
                break;
            default:
                state = NODESTATE_INSEG;
                break;
            }
            break;
        case NODESTATE_ESCAPED:
            if (!wcschr (EscapedCharsW, *nodePattern)) {
                DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: illegal escaped character: %s", NodePattern));
                return FALSE;
            }
            state = NODESTATE_INSEG;
            break;
        default:
            DEBUGMSGW ((DBG_STRINGS, "GetNodeMinMaxLevelsA: unknown state while processing: %s", NodePattern));
            return FALSE;
        }
        if (advance) {
            if (copyChar && FormattedNode) {
                *FormattedNode = *nodePattern;
                FormattedNode ++;
                nodePattern ++;
            } else {
                nodePattern ++;
            }
        }
    }
    if (MinLevel) {
        *MinLevel = minLevel;
    }
    if (MaxLevel) {
        *MaxLevel = maxLevel;
    }
    if (FormattedNode) {
        *FormattedNode = 0;
    }
    return TRUE;
}

#if 0
//
// PORTBUG Uses memdb max. #if 0'd out for now.
//
PCSTR
ConvertSBtoDB (
    IN      PCSTR RootPath,
    IN      PCSTR FullPath,
    IN      PCSTR Limit
    )
{
    CHAR result[MEMDB_MAX];
    PCSTR p,p1,q;
    PSTR s;
    UINT ch;
    UINT ch1;
    BOOL dhCase = FALSE;

    ZeroMemory (result, MAX_PATH);
    p = FullPath;
    q = RootPath;
    s = result;

    while (*p && (((DWORD)s - (DWORD)result) < MEMDB_MAX)) {
        if (q && *q) {
            _mbssetchar (s, _mbsnextc(p));
            q = _mbsinc (q);
        } else if (Limit && (p >= Limit)) {
            _mbssetchar (s, _mbsnextc(p));
        } else {
            ch = _mbsnextc (p);

            //
            // It is very important not to make the conversion for characters below A1. Otherwise
            // all english letters will be converted to large letters.
            //
            if (ch >= 0xA1 && ch <= 0xDF) {
                // this is a candidate for conversion
                // we need to see if there is a special Dakutenn/Handakuten conversion
                dhCase = FALSE;
                p1 = _mbsinc (p);
                if (p1) {
                    ch1 = _mbsnextc (p1);
                    ch1 = pBuildFromDHList (ch, ch1);
                    if (ch1) {
                        p = _mbsinc (p);
                        _mbssetchar (s, ch1);
                        dhCase = TRUE;
                    }
                }
                if (!dhCase) {
                    _mbssetchar (s, _mbbtombc (ch));
                }
            } else {
                _mbssetchar (s, ch);
            }
        }
        p = _mbsinc (p);
        s = _mbsinc (s);
    }
    result [MAX_PATH - 1] = 0;
    return (DuplicatePathString (result, 0));
}

#endif

ULONGLONG
StringToUint64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    )
{
    ULONGLONG n;

    n = 0;
    while (*String >= '0' && *String <= '9') {
        n = n * 10 + *String - '0';
        String++;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


ULONGLONG
StringToUint64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    )
{
    ULONGLONG n;

    n = 0;
    while (*String >= L'0' && *String <= L'9') {
        n = n * 10 + *String - L'0';
        String++;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


LONGLONG
StringToInt64A (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    )
{
    LONGLONG n;
    BOOL negate = FALSE;

    if (*String == '-') {
        negate = TRUE;
        String++;
    } else if (*String == '+') {
        String++;
    }

    n = 0;
    while (*String >= '0' && *String <= '9') {
        n = n * 10 + *String - '0';
        String++;
    }

    if (negate) {
        n = -n;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


LONGLONG
StringToInt64W (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    )
{
    LONGLONG n;
    BOOL negate = FALSE;

    if (*String == L'-') {
        negate = TRUE;
        String++;
    } else if (*String == L'+') {
        String++;
    }

    n = 0;
    while (*String >= L'0' && *String <= L'9') {
        n = n * 10 + *String - L'0';
        String++;
    }

    if (negate) {
        n = -n;
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return n;
}


BOOL
TestBuffer (
    IN      PCBYTE SrcBuff,
    IN      PCBYTE DestBuff,
    IN      UINT Size
    )
{
    while (Size) {
        if (*SrcBuff != *DestBuff) {
            return FALSE;
        }
        SrcBuff ++;
        DestBuff ++;
        Size --;
    }

    return TRUE;
}

PCSTR
IsValidUncPathA (
    IN      PCSTR Path
    )
{
    BOOL needNonWack = FALSE;
    BOOL wackRequired = TRUE;
    INT wacks = 0;

    while (*Path) {

        if (_mbsnextc (Path) == '\\') {

            if (needNonWack) {
                break;
            }

            wacks++;
            if (wacks != 1) {
                needNonWack = TRUE;
                wackRequired = FALSE;
            }

            Path++;

        } else {
            //
            // Note: it would be nice to validate the non-wack characters against the
            //       legal unc charset
            //

            if (needNonWack) {
                if (wacks == 3) {
                    //
                    // Found \\x\x syntax; it's a UNC path
                    //

                    do {
                        Path = _mbsinc (Path);
                    } while (*Path && (_mbsnextc (Path) != '\\'));

                    MYASSERT (*Path == 0 || *Path == '\\');
                    return Path;
                }

                needNonWack = FALSE;
            }

            if (wackRequired) {
                break;
            }

            Path = _mbsinc (Path);
        }
    }

    return NULL;
}


BOOL
IsValidFileSpecA (
    IN      PCSTR FileSpec
    )
{
    CHARTYPE ch;
    BOOL result = TRUE;

    for (;;) {
        ch = (CHARTYPE) _mbsnextc (FileSpec);
        if (ch == '*') {
            //
            // Really can't say what the validity is!
            //

            break;
        }

        if (!isalpha (ch) && (ch != '?')) {
            result = FALSE;
            break;
        }

        ch = (CHARTYPE) _mbsnextc (FileSpec + 1);
        if (ch == '*') {
            break;
        }

        if ((ch != ':') && (ch != '?')) {
            result = FALSE;
            break;
        }

        ch = (CHARTYPE) _mbsnextc (FileSpec + 2);

        if (ch == 0) {
            // this is something like "d:", it's valid
            break;
        }

        if (ch == '*') {
            break;
        }

        if ((ch != '\\') && (ch != '?')) {
            result = FALSE;
            break;
        }

        break;
    }

    if (!result) {
        result = (IsValidUncPathA (FileSpec) != NULL);
    }

    return result;
}

PCWSTR
IsValidUncPathW (
    IN      PCWSTR Path
    )
{
    BOOL needNonWack = FALSE;
    BOOL wackRequired = TRUE;
    INT wacks = 0;

    while (*Path) {

        if (Path [0] == L'\\') {

            if (needNonWack) {
                break;
            }

            wacks++;
            if (wacks != 1) {
                needNonWack = TRUE;
                wackRequired = FALSE;
            }

            Path++;

        } else {
            //
            // Note: it would be nice to validate the non-wack characters against the
            //       legal unc charset
            //

            if (needNonWack) {
                if (wacks == 3) {
                    //
                    // Found \\x\x syntax; it's a UNC path
                    //

                    do {
                        Path ++;
                    } while (*Path && (*Path != L'\\'));

                    MYASSERT (*Path == 0 || *Path == L'\\');
                    return Path;
                }

                needNonWack = FALSE;
            }

            if (wackRequired) {
                break;
            }

            Path ++;
        }
    }

    return NULL;
}


BOOL
IsValidFileSpecW (
    IN      PCWSTR FileSpec
    )
{
    BOOL result = TRUE;

    for (;;) {
        if (FileSpec [0] == L'*') {
            //
            // Really can't say what the validity is!
            //

            break;
        }

        if (!iswalpha (FileSpec [0]) && (FileSpec [0] != L'?')) {
            result = FALSE;
            break;
        }

        if (FileSpec [1] == L'*') {
            break;
        }

        if ((FileSpec [1] != L':') && (FileSpec [1] != L'?')) {
            result = FALSE;
            break;
        }

        if (FileSpec [2] == 0) {
            // this is something like "d:", it's valid
            break;
        }

        if (FileSpec [2] == L'*') {
            break;
        }

        if ((FileSpec [2] != L'\\') && (FileSpec [2] != L'?')) {
            result = FALSE;
            break;
        }

        break;
    }

    if (!result) {
        result = (IsValidUncPathW (FileSpec) != NULL);
    }

    return result;
}

BOOL
IsEmptyStrA (
    IN      PCSTR String
    )
{
    if (String) {
        String = SkipSpaceA (String);
        if (String) {
            if (*String) {
                return FALSE;
            }
        }
    }
    return TRUE;
}

BOOL
IsEmptyStrW (
    IN      PCWSTR String
    )
{
    if (String) {
        String = SkipSpaceW (String);
        if (String) {
            if (*String) {
                return FALSE;
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\hash.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    jimschm     23-Nov-1999  Removed setup api compatibility, fixed enum
                             to be insertion order
    ovidiut     14-Oct-1999  New coding conventions + Win64 compliance.
    marcw        2-Sep-1999  Moved over from Win9xUpg project.

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_HASH    "HashTable"

//
// Strings
//

#define S_HASHTABLE "HashTable"

//
// Constants
//

#define BUCKETS                 1009
#define HASHTABLE_SIGNATURE     0x122398ff

//
// Macros
//

#ifdef DEBUG
    #define ASSERT_TABLE_IS_VALID(table)        MYASSERT(pTableIsValid(table))
#else
    #define ASSERT_TABLE_IS_VALID(table)
#endif

//
// Types
//

typedef struct _tagBUCKETITEM {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    INT Locked;
    WORD StringSize;
    // string follows StringSize
    // optional data follows string
} BUCKETITEM, *PBUCKETITEM;

typedef struct {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    INT Locked;
    PVOID String;
    // optional data follows struct
} BUCKETITEM_EXTERN_STR, *PBUCKETITEM_EXTERN_STR;

typedef struct {
    DWORD Signature;
    BOOL Unicode;
    BOOL ExternalStrings;
    BOOL CaseSensitive;
    PMHANDLE Pool;
    PBUCKETITEM *Bucket;
    PBUCKETITEM FirstLink;
    PBUCKETITEM LastLink;
    PBUCKETITEM DelayedDelete;
    UINT ExtraDataSize;
    UINT MinimumStringBytes;
    UINT MaximumStringBytes;
    UINT Buckets;
} HASHTABLESTRUCT, *PHASHTABLESTRUCT;


//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



#ifdef DEBUG

BOOL
pTableIsValid (
    IN      HASHTABLE Table
    )
{
    BOOL b = TRUE;

    if (!Table) {
        return FALSE;
    }

    __try {
        if (((PHASHTABLESTRUCT) Table)->Signature != HASHTABLE_SIGNATURE) {
            b = FALSE;
        }
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#endif


/*++

Routine Description:

  pComputeHashValue adds all the character values of the string, shifting to
  maintain order.

Arguments:

  String - Specifies the string to compute the hash value for

Return Value:

  The hash value, within the range of 0 to BUCKETS - 1.

--*/

UINT
pComputeHashValueA (
    IN      PCSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputeHashValueW (
    IN      PCWSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueA (
    IN      PCSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCSTR end;

    end = (PCSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueW (
    IN      PCWSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCWSTR end;

    end = (PCWSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


HASHTABLE
RealHtAllocExAW (
    IN      BOOL CaseSensitive,
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT Buckets
    )

/*++

Routine Description:

  AllocateHashTableEx creates a hash table.  If ExtraDataSize is non-zero,
  each hash table entry gets an allocation of ExtraDataSize added to it.

Arguments:

  CaseSensitive - Specifies TRUE if the hash table is case-sensitive, FALSE
                  if all strings should be stored and compared in lower-case
                  only

  Unicode - Specifies TRUE to allocate a UNICODE hash table, or FALSE to
            allocate an ANSI table.  None of the routines in this file do any
            sort of UNICODE/ANSI converstion.

  ExternalStrings - Specifies TRUE if the strings belong to memory maintained
                    by the caller

  ExtraDataSize - Specifies the size of binary data associated with the
                  table item, or 0 for none.

Return Value:

  A handle to the string table.

--*/

{
    PHASHTABLESTRUCT hashTable;
    PMHANDLE pool;

    if (!Buckets) {
        Buckets = BUCKETS;
    }

    pool = PmCreateNamedPool (S_HASHTABLE);
    MYASSERT (pool);

    PmDisableTracking (pool);

    hashTable = (PHASHTABLESTRUCT) PmGetAlignedMemory (
                                        pool,
                                        sizeof (HASHTABLESTRUCT) + (sizeof (PBUCKETITEM) * Buckets)
                                        );
    MYASSERT (hashTable);

    hashTable->Signature = HASHTABLE_SIGNATURE;
    hashTable->CaseSensitive = CaseSensitive;
    hashTable->Unicode = Unicode;
    hashTable->ExternalStrings = ExternalStrings;
    hashTable->Pool = pool;
    hashTable->Bucket = (PBUCKETITEM *) ((PBYTE) hashTable + sizeof (HASHTABLESTRUCT));
    hashTable->FirstLink = NULL;
    hashTable->LastLink = NULL;
    hashTable->ExtraDataSize = ExtraDataSize;
    hashTable->MinimumStringBytes = (UINT) -1;
    hashTable->MaximumStringBytes = 0;
    hashTable->Buckets = Buckets;

    //
    // Zero out all of the bucket structures.
    //
    ZeroMemory (hashTable->Bucket, sizeof (PBUCKETITEM) * Buckets);

    return (HASHTABLE) hashTable;
}


VOID
HtFree (
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  HtFree releases all resources associated with a string table.

Arguments:

  None.

Return Value:

  None.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    if (table) {
        ASSERT_TABLE_IS_VALID (HashTable);
        PmEmptyPool (table->Pool);
        PmDestroyPool (table->Pool);
    }
}


PBUCKETITEM
pHtFindStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue,
    OUT     PBUCKETITEM *PrevBucketItem
    )

/*++

Routine Description:

  pHtFindString implements the hash table lookup routine.  It returns the
  pointer to the bucket item or NULL if the item was not found.

Arguments:

  HashTable        - Specifies the handle to the hash table
  String           - Specifies the string to find.  If this string is
                     case-insensitive but has already been lowercased, then make
                     sure to pass TRUE in the AlreadyLowercase argument.
  ExtraDataBuffer  - A buffer that receives the bytes stored as extra data with
                     the found item; caller must size this according to the
                     extra data size specified to HtAllocExAW
  AlreadyLowercase - Specifies TRUE if String is already lower case
  OutHashValue     - Receives the hash value.  This is non optional for
                     efficiency.
  PrevBucketItem    - Receives the previous bucket item

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    *PrevBucketItem = NULL;

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextA (String);
        (void) CharLowerA (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueA (String, table->Buckets);

    item = table->Bucket[hashValue];

    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        *PrevBucketItem = item;
        item = item->Next;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue,
    OUT     PBUCKETITEM *PrevBucketItem
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCWSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    *PrevBucketItem = NULL;

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextW (String);
        (void) CharLowerW (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueW (String, table->Buckets);

    item = table->Bucket[hashValue];
    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        *PrevBucketItem = item;
        item = item->Next;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue
    )

/*++

Routine Description:

  pHtFindPrefix implements a hash table lookup routine that tests each hash
  table entry, character-by-character, until a match is found, or until the
  hash table maximum is reached.  It returns the pointer to the bucket item or
  NULL if the item was not found.

Arguments:

  HashTable        - Specifies the handle to the hash table
  String           - Specifies the string to find.  If this string is
                     case-insensitive but has already been lowercased, then make
                     sure to pass TRUE in the AlreadyLowercase argument.
  BufferEnd        - Specifies the end of the string buffer, which may be longer
                     than all entries in the hash table, or it may be shorter.
  ExtraDataBuffer  - A buffer that receives the bytes stored as extra data with
                     the found item; caller must size this according to the
                     extra data size specified to HtAllocExAW
  AlreadyLowercase - Specifies TRUE if String is in lower-case, FALSE otherwise.
  OutHashValue     - Receives the hash value.  This is non optional for
                     efficiency.  If pHtFindPrefix does not find a match,
                     this value will be set to zero.

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCSTR p1, p2;
    PCSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    UINT currentBytes;
    PCSTR shortestEnd;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {

        dupStr = AllocTextA (maxBytes / sizeof (CHAR));
        if (!dupStr) {
            return NULL;
        }

        StringCopyByteCountA (dupStr, String, maxBytes + sizeof (CHAR));
        CharLowerA (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd = _mbsinc (shortestEnd);
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueA (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (CHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd = _mbsdec2 (String, BufferEnd);
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCWSTR p1, p2;
    PCWSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    PCWSTR shortestEnd;
    UINT currentBytes;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {

        dupStr = AllocTextW (maxBytes / sizeof (WCHAR));
        if (!dupStr) {
            return NULL;
        }

        StringCopyByteCountW (dupStr, String, maxBytes + sizeof (WCHAR));
        CharLowerW (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCWSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCWSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd++;
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueW (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (WCHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCWSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd--;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL AlreadyLowercase
    )

/*++

Routine Description:

  HtAddStringEx adds a string to the hash table, and copies ExtraData to the
  new hash table entry.  If String is already in the hash table, the ExtraData
  is updated.

Arguments:

  HashTable        - Specifies the handle to the hash table, as returned from
                     AllocateHashTable.
  String           - Specifies the string to add to the table
  ExtraData        - Specifies the source binary data to be copied to the hash
                     table entry
  AlreadyLowercase - Specifies TRUE String is in all lowercase

Return Value:

  Returns the pointer to the bucket item allocated or update.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;
    PBUCKETITEM dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextA (String);
        CharLowerA (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringA (HashTable, String, NULL, TRUE, &hashValue, &dontCare);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringA (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Locked = 0;

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Locked = 0;

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (CHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetExtraData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    return rc;
}


HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PWSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;
    PBUCKETITEM dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextW (String);
        CharLowerW (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringW (HashTable, String, NULL, TRUE, &hashValue, &dontCare);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringW (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Locked = 0;

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PmGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Locked = 0;

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (WCHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetExtraData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    return rc;
}


VOID
pRemoveHashItem (
    IN      PHASHTABLESTRUCT Table,
    IN      UINT BucketNum,
    IN      PBUCKETITEM PrevItem,
    IN      PBUCKETITEM ItemToDelete
    )
{
    if (!PrevItem) {
        MYASSERT (Table->Bucket[BucketNum] == ItemToDelete);
        Table->Bucket[BucketNum] = ItemToDelete->Next;
    } else {
        PrevItem->Next = ItemToDelete->Next;
    }

    if (ItemToDelete->PrevLink) {
        ItemToDelete->PrevLink->NextLink = ItemToDelete->NextLink;
    } else {
        Table->FirstLink = ItemToDelete->Next;
    }

    if (ItemToDelete->NextLink) {
        ItemToDelete->NextLink->PrevLink = ItemToDelete->PrevLink;
    } else {
        Table->LastLink = ItemToDelete->PrevLink;
    }

    if (ItemToDelete->Locked) {
        ItemToDelete->Next = Table->DelayedDelete;
        Table->DelayedDelete = ItemToDelete;
    } else {
        PmReleaseMemory (Table->Pool, ItemToDelete);
    }
}


BOOL
HtRemoveItem (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Item
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;
    PCSTR ansiStr;
    PCWSTR unicodeStr;

    if (!Item) {
        return FALSE;
    }

    //
    // Find prev bucket item
    //

    if (table->Unicode) {
        unicodeStr = HtGetStringFromItemW (Item);
        MYASSERT (unicodeStr);

        thisItem = pHtFindStringW (
                        HashTable,
                        unicodeStr,
                        NULL,
                        TRUE,
                        &bucketNumber,
                        &prevItem
                        );

    } else {
        ansiStr = HtGetStringFromItemA (Item);
        MYASSERT (ansiStr);

        thisItem = pHtFindStringA (
                        HashTable,
                        ansiStr,
                        NULL,
                        TRUE,
                        &bucketNumber,
                        &prevItem
                        );

    }

    MYASSERT (Item == thisItem);

    if (Item != thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}


BOOL
HtRemoveStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR AnsiString
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot delete UNICODE table with ANSI api"));
        return FALSE;
    }

    thisItem = pHtFindStringA (
                    HashTable,
                    AnsiString,
                    NULL,
                    FALSE,
                    &bucketNumber,
                    &prevItem
                    );

    if (!thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}



BOOL
HtRemoveStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR UnicodeString
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot delete ANSI table with UNICODE api"));
        return FALSE;
    }

    thisItem = pHtFindStringW (
                    HashTable,
                    UnicodeString,
                    NULL,
                    FALSE,
                    &bucketNumber,
                    &prevItem
                    );

    if (!thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}



/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable        - Specifies the hash table handle, as returned by
                     AllocateHashTable.
  String           - Specifies the string to find
  ExtraDataBuffer  - Receives the extra data associated with the found item
  AlreadyLowercase - Specifies TRUE if the String is in lowercase

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;
    PBUCKETITEM dontCare2;

    return (HASHITEM) pHtFindStringA (
                            HashTable,
                            String,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare,
                            &dontCare2
                            );
}


HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;
    PBUCKETITEM dontCare2;

    return (HASHITEM) pHtFindStringW (
                            HashTable,
                            String,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare,
                            &dontCare2
                            );
}


/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable        - Specifies the hash table handle, as returned by
                     AllocateHashTable.
  String           - Specifies the string to find
  BufferEnd        - Specifies the end of the buffer for String
  ExtraDataBuffer  - Receives the extra data associated with the found item
  AlreadyLowercase - Specifies TRUE if String is in all lowercase

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixA (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare
                            );
}


HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixW (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare
                            );
}


BOOL
HtGetExtraData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    )

/*++

Routine Description:

  HtGetExtraData gets the extra data associated with a bucket item.
  The caller must supply the ID as returned from HtFindStringEx or
  HtAddStringEx.  This routine is useful when ExtraData is large, and
  the normal find routine would be slow because of the CopyMemory code path.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Receives the extra data pointer (it does NOT copy the data to
              the buffer).

Return Value:

  TRUE if ExtraData was set, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externStrItem;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!Index) {
        return FALSE;
    }

    if (table->ExternalStrings) {

        externStrItem = (PBUCKETITEM_EXTERN_STR) Index;
        *ExtraData = (PCVOID) ((PBYTE) externStrItem + sizeof (PBUCKETITEM_EXTERN_STR));

    } else {

        item = (PBUCKETITEM) Index;
        *ExtraData = (PCVOID) ((PBYTE) item + sizeof (BUCKETITEM) + item->StringSize);

    }

    return TRUE;
}


BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraDataBuffer
    )

/*++

Routine Description:

  HtCopyStringData gets the extra data associated with a bucket item
  and copies it to the caller's buffer.

Arguments:

  HashTable       - Specifies the handle to the hash table
  Index           - Specifies the offset as returned from HtFindStringEx or
                    HtAddStringEx
  ExtraDataBuffer - Receives the extra data

Return Value:

  TRUE if ExtraDataBuffer was copied, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetExtraData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) ExtraDataBuffer,
        (PBYTE) storedDataPtr,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    )

/*++

Routine Description:

  HtSetStringData copies new extra data to the specified hash table entry.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Specifies the extra data

Return Value:

  TRUE if the item was updated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetExtraData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) storedDataPtr,
        (PBYTE) ExtraData,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  EnumFirstHashTableString begins an enumeration of the hash table structure.
  The return order is random.  Also, do not modify the hash table while an
  enumeration is active.

Arguments:

  EnumPtr   - Receives the string, extra data and offset for the first item
              in the hash table.
  HashTable - Specifies the handle of the hash table to enumerate.

Return Value:

  TRUE if an item was enumerated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum UNICODE table with ANSI wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringA (EnumPtr);
}


BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum ANSI table with UNICODE wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringW (EnumPtr);
}


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    )

/*++

Routine Description:

  EnumNextHashTableString continues an enumeration started by
  EnumFirstHashTableString.  Call the routine until it returns FALSE.

Arguments:

  EnumPtr - Specifies the structure of an active enumeration.  Receives
            updated string, extra data and offset members.

Return Value:

  TRUE if another item was enumerated, FALSE if no items remain.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        item->Locked += 1;
        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetExtraData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        item->Locked += 1;
        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCWSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetExtraData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


VOID
AbortHashTableEnumA (
    IN      PHASHTABLE_ENUMA EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM nextItem;
    PBUCKETITEM prevItem;

    if (!EnumPtr->Internal) {
        return;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (EnumPtr->Index) {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
    }

    //
    // Evaluate delayed delete items; remove those that are no longer locked
    //

    if (table->DelayedDelete) {
        item = table->DelayedDelete;
        prevItem = NULL;

        while (item) {

            nextItem = item->Next;

            if (!item->Locked) {
                PmReleaseMemory (table->Pool, item);
            } else {
                if (prevItem) {
                    prevItem->Next = item;
                } else {
                    table->DelayedDelete = item;
                }

                prevItem = item;
            }

            item = nextItem;
        }

        if (prevItem) {
            prevItem->Next = NULL;
        } else {
            table->DelayedDelete = NULL;
        }
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));
}


VOID
AbortHashTableEnumW (
    IN      PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM prevItem;
    PBUCKETITEM nextItem;

    if (!EnumPtr->Internal) {
        return;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (EnumPtr->Index) {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
    }

    //
    // Evaluate delayed delete items; remove those that are no longer locked
    //

    if (table->DelayedDelete) {
        item = table->DelayedDelete;
        prevItem = NULL;

        while (item) {

            nextItem = item->Next;

            if (!item->Locked) {
                PmReleaseMemory (table->Pool, item);
            } else {
                if (prevItem) {
                    prevItem->Next = item;
                } else {
                    table->DelayedDelete = item;
                }

                prevItem = item;
            }

            item = nextItem;
        }

        if (prevItem) {
            prevItem->Next = NULL;
        } else {
            table->DelayedDelete = NULL;
        }
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));
}


BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  EnumHashTableWithCallback implements a setupapi-style enumerator.  The
  callback routine is called for each item in the string table, and if the
  callback routine returns FALSE, the enumeration ends.

Arguments:

  HashTable - Specifies the handle to the table to enumerate
  Proc      - Specifies the callback procedure address
  lParam    - Specifies a value to pass to the callback, and is intended only
              for use by the caller.

Return Value:

  Always TRUE.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMA e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringA (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                AbortHashTableEnumA (&e);
                break;
            }
        } while (EnumNextHashTableStringA (&e));
    }

    return TRUE;
}


BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMW e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringW (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                AbortHashTableEnumW (&e);
                break;
            }
        } while (EnumNextHashTableStringW (&e));
    }

    return TRUE;
}


PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}


PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCWSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\poolmem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    poolmem.c

Abstract:

    poolmem provides a managed allocation scheme in which large blocks of memory are
    allocated (pools) and then divided up by request into low overhead memory chunks
    upon request. poolmem provides for easy creation/clean-up of memory, freeing the
    developer for more important tasks.

Author:

    Marc R. Whitten (marcw) 13-Feb-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     28-Sep-1998 Debug message fixes

--*/

#include "pch.h"

#ifdef UNICODE
#error UNICODE not allowed
#endif


//
// Includes
//

#include "utilsp.h"

#define DBG_POOLMEM "Poolmem"

//
// Strings
//

// None

//
// Constants
//

//
// Tree Memory Allocation structure.
//

#ifdef DEBUG
#define VALIDDOGTAG 0x021371
#define FREEDOGTAG  0x031073
#endif


#define MAX_POOL_NAME       32

//
// Macros
//

// None

//
// Types
//

typedef struct _PMBLOCK PMBLOCK, *PPMBLOCK;

struct _PMBLOCK {
    UINT_PTR Index;         // Tracks into RawMemory.
    SIZE_T Size;            // the size in bytes of RawMemory.
    PPMBLOCK NextBlock;     // A pointer to the next block in the pool chain.
    PPMBLOCK PrevBlock;     // A pointer to the prev block in the pool chain.
    DWORD UseCount;         // The number of allocations currently referring
                            // to this block.
    PBYTE RawMemory;        // The actual bytes of allocable memory in this block.
};
typedef struct _ALLOCATION ALLOCATION, * PALLOCATION;
struct _ALLOCATION {
#ifdef DEBUG
    DWORD DogTag;           // A signature to ensure validity.
    SIZE_T Size;
    PALLOCATION Next;       // The next allocation in the list.
    PALLOCATION Prev;       // The previous allocation in the list.
#endif

    PPMBLOCK ParentBlock;   // A reference to the block from which this allocation
                            // was created.

};

typedef enum {
    FREE_NOT_CALLED,
    FREE_CALLED,
    WHO_CARES
} FREESTATE;


typedef struct _POOLHEADER {
    PPMBLOCK PoolHead;                  // The active memory block in this pool.
    SIZE_T MinimumBlockSize;            // minimum size to allocate when a new block is needed.

#ifdef DEBUG
    CHAR Name[MAX_POOL_NAME];
    SIZE_T TotalAllocationRequestBytes;
    SIZE_T CurrentAllocationSize;
    SIZE_T MaxAllocationSize;
    SIZE_T CurrentlyAllocatedMemory;
    SIZE_T MaximumAllocatedMemory;
    UINT NumAllocationRequests;
    UINT NumFreeRequests;
    UINT NumBlockFrees;
    UINT NumBlockClears;
    UINT NumBlockAllocations;

    PALLOCATION AllocationList;         // A linked list of all of the allocations active in the
                                        // pool.
    FREESTATE FreeCalled;               // A state variable indicating that PoolMemReleaseMemory()
                                        // has been called at least once on this pool.
#endif

} POOLHEADER, *PPOOLHEADER;

//
// Globals
//

#ifdef DEBUG
DWORD g_PmDisplayed;
DWORD g_PmNotDisplayed;

UINT g_PoolCurrPools = 0;
SIZE_T g_PoolCurrTotalAlloc = 0;
SIZE_T g_PoolCurrActiveAlloc = 0;
SIZE_T g_PoolCurrUsedAlloc = 0;
UINT g_PoolMaxPools = 0;
SIZE_T g_PoolMaxTotalAlloc = 0;
SIZE_T g_PoolMaxActiveAlloc = 0;
SIZE_T g_PoolMaxUsedAlloc = 0;
#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



BOOL
pPmAddMemory (
    IN  PMHANDLE Handle,
    IN  SIZE_T Size
    )
/*++

Routine Description:

    pPmAddMemory is the function responsible for actually growing the size of
    the pool by adding a new block of memory. This function is used by
    PmCreatePool and PmGetMemory.

    when called, this function attempts to allocate at least poolHeader ->
    MinimumBlockSize bytes of memory. If the requested size is actually larger
    than the minimum, the requested size is allocated instead. This is consistent
    with PoolMem's main purpose: An efficient allocator for larger numbers of small
    objects. If PoolMem is being used to allocate very large objects, the benefits
    are lost and poolmem becomes a very inefficient allocator.

Arguments:

    Handle - A Handle to a Pool of Memory.

    Size - Size to allocate.


Return Value:

    returns TRUE if memory was successfully added, FALSE otherwise.

--*/
{
    PBYTE allocedMemory;
    PPMBLOCK newBlock;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;
    SIZE_T sizeNeeded;

    MYASSERT(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(PMBLOCK) > poolHeader->MinimumBlockSize) {
        sizeNeeded = Size + sizeof(PMBLOCK);
    }
    else {
        sizeNeeded = poolHeader->MinimumBlockSize;
    }
    MYASSERT (g_TrackFile);
    allocedMemory = MemAlloc(g_hHeap,0,sizeNeeded);

    if (allocedMemory) {

#ifdef DEBUG
        g_PoolCurrTotalAlloc += sizeNeeded;
        if (g_PoolMaxTotalAlloc < g_PoolCurrTotalAlloc) {
            g_PoolMaxTotalAlloc = g_PoolCurrTotalAlloc;
        }
        g_PoolCurrActiveAlloc += (sizeNeeded - sizeof(PMBLOCK));
        if (g_PoolMaxActiveAlloc < g_PoolCurrActiveAlloc) {
            g_PoolMaxActiveAlloc = g_PoolCurrActiveAlloc;
        }
#endif

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock = (PPMBLOCK) allocedMemory;
        newBlock->Size = sizeNeeded - sizeof(PMBLOCK);
        newBlock->RawMemory = allocedMemory + sizeof(PMBLOCK);
        newBlock->Index = 0;
        newBlock->UseCount = 0;

        //
        // Link the block into the list.
        //
        if (poolHeader->PoolHead) {
            poolHeader->PoolHead->PrevBlock = newBlock;
        }
        newBlock->NextBlock = poolHeader->PoolHead;
        newBlock->PrevBlock = NULL;
        poolHeader->PoolHead = newBlock;

#ifdef DEBUG

        //
        // Keep track of pool statistics.
        //
        poolHeader->CurrentlyAllocatedMemory  += sizeNeeded;
        poolHeader->MaximumAllocatedMemory =
            max(poolHeader->MaximumAllocatedMemory,poolHeader->CurrentlyAllocatedMemory);

        poolHeader->NumBlockAllocations++;

#endif

    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;

}


PMHANDLE
RealPmCreatePoolEx (
    IN      DWORD BlockSize     OPTIONAL
    )
/*++

Routine Description:

    Initializes a new memory pool and returns a handle to it.

Arguments:

    None.

Return Value:

    If the function completes succssessfully, it returns a valid PMHANDLE, otherwise,
    it returns NULL.

--*/

{
    BOOL ableToAddMemory;
    PPOOLHEADER header = NULL;

    EnterCriticalSection (&g_PmCs);

    __try {

        //
        // Allocate the header of this pool.
        //
        header = MemAlloc(g_hHeap,0,sizeof(POOLHEADER));

#ifdef DEBUG
        g_PoolCurrTotalAlloc += sizeof(POOLHEADER);
        if (g_PoolMaxTotalAlloc < g_PoolCurrTotalAlloc) {
            g_PoolMaxTotalAlloc = g_PoolCurrTotalAlloc;
        }
#endif

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header->MinimumBlockSize = BlockSize?BlockSize:POOLMEMORYBLOCKSIZE;
        header->PoolHead = NULL;

#ifdef DEBUG

        //
        // Statistics for the debug version.
        //
        header->TotalAllocationRequestBytes = 0;
        header->CurrentAllocationSize = 0;
        header->MaxAllocationSize = 0;
        header->CurrentlyAllocatedMemory = 0;
        header->MaximumAllocatedMemory = 0;
        header->NumAllocationRequests = 0;
        header->NumFreeRequests = 0;
        header->NumBlockFrees = 0;
        header->NumBlockClears = 0;
        header->NumBlockAllocations = 0;
        header->Name[0] = 0;

#endif

        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = pPmAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            MemFree(g_hHeap,0,header);

#ifdef DEBUG
            g_PoolCurrTotalAlloc -= sizeof(POOLHEADER);
#endif

            header = NULL;
            DEBUGMSG((DBG_ERROR,"PoolMem: Unable to initialize memory pool."));
        }

#ifdef DEBUG

        //
        // These are 'cookie' variables that hold tracking information when dogtag checking
        // is enabled.
        //
        g_PmNotDisplayed =  12;
        g_PmDisplayed =     24;

        if (ableToAddMemory) {
            header->AllocationList = NULL;  //lint !e613
            header->FreeCalled = FREE_NOT_CALLED;   //lint !e613
        }
#endif

    } __finally {

        LeaveCriticalSection (&g_PmCs);
    }

#ifdef DEBUG
    if (header) {
        g_PoolCurrPools ++;
        if (g_PoolMaxPools < g_PoolCurrPools) {
            g_PoolMaxPools = g_PoolCurrPools;
        }
    }
#endif

    return (PMHANDLE) header;

}

VOID
pDeregisterPoolAllocations (
    PPOOLHEADER PoolHeader
    )
{

#ifdef DEBUG
    PALLOCATION p,cur;

    if (PoolHeader->FreeCalled == WHO_CARES) {
        return;
    }

    p = PoolHeader->AllocationList;

    while (p) {

        cur = p;
        p = p->Next;

        g_PoolCurrUsedAlloc -= cur->Size;

        DebugUnregisterAllocation(POOLMEM_POINTER,cur);

    }

    PoolHeader->AllocationList = NULL;
#endif
}


VOID
PmEmptyPool (
    IN PMHANDLE Handle
    )

/*++

Routine Description:

    PmEmptyPool resets the index pointer of the index block back
    to zero, so the next allocation will come from the already allocated
    active block.

    Calling this function invalidates all pointers previously allocated from
    the active block.

Arguments:

    Handle - Specifies the pool to reset

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    if (!Handle) {
        return;
    }

    EnterCriticalSection (&g_PmCs);

    __try {

        poolHeader->PoolHead->UseCount = 0;
        poolHeader->PoolHead->Index = 0;

#ifdef DEBUG
        poolHeader->NumBlockClears++;
#endif

#ifdef DEBUG

        pDeregisterPoolAllocations(poolHeader);

#endif


    } __finally {

        LeaveCriticalSection (&g_PmCs);
    }

}



VOID
PmSetMinimumGrowthSize (
    IN PMHANDLE Handle,
    IN SIZE_T Size
    )
/*++

Routine Description:

    Sets the minimum growth size for a memory pool. This value is used when new blocks
    are actually added to the pool. The PoolMem allocator will attempt to allocate at
    least this minimum size.

Arguments:

    Handle - A valid PMHANDLE.
    Size   - The minimum size in bytes to grow the pool by on each allocation.

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(Handle != NULL);

    poolHeader->MinimumBlockSize = max(Size,0);
}


VOID
PmDestroyPool (
    PMHANDLE Handle
    )
/*++

Routine Description:

    PmDestroyPool completely cleans up the memory pool identified by Handle. It
    simply walks the list of memory blocks associated with the memory pool, freeing each of them.

Arguments:

    Handle - A valid PMHANDLE.

Return Value:

    None.

--*/
{
    PPMBLOCK nextBlock;
    PPMBLOCK blockToFree;
    PPOOLHEADER poolHeader;


    if (!Handle) {
        return;
    }

    poolHeader = (PPOOLHEADER) Handle;

#ifdef DEBUG

    if (poolHeader->NumAllocationRequests) {
        CHAR FloatWorkaround[32];

        _gcvt (
            ((DOUBLE) (poolHeader->TotalAllocationRequestBytes)) / poolHeader->NumAllocationRequests,
            8,
            FloatWorkaround
            );

        //
        // Spew the statistics of this pool to the debug log.
        //
        DEBUGMSG ((
            DBG_POOLMEM,
            "Pool Statistics for %s\n"
                "\n"
                "Requested Size in Bytes\n"
                "  Average: %s\n"
                "  Maximum: %u\n"
                "\n"
                "Pool Size in Bytes\n"
                "  Current: %u\n"
                "  Maximum: %u\n"
                "\n"
                "Allocation Requests\n"
                "  Caller Requests: %u\n"
                "  Block Allocations: %u\n"
                "\n"
                "Free Requests\n"
                "  Caller Requests: %u\n"
                "  Block Frees: %u\n"
                "  Block Clears: %u",
            poolHeader->Name[0] ? poolHeader->Name : "[Unnamed Pool]",
            FloatWorkaround,
            poolHeader->MaxAllocationSize,
            poolHeader->CurrentlyAllocatedMemory,
            poolHeader->MaximumAllocatedMemory,
            poolHeader->NumAllocationRequests,
            poolHeader->NumBlockAllocations,
            poolHeader->NumFreeRequests,
            poolHeader->NumBlockFrees,
            poolHeader->NumBlockClears
            ));

    } else if (poolHeader->Name[0]) {

        DEBUGMSG ((
            DBG_POOLMEM,
            "Pool %s was allocated but was never used",
            poolHeader->Name
            ));
    }

#endif

    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader-> PoolHead;

    while (blockToFree != NULL) {

        nextBlock = blockToFree->NextBlock;

#ifdef DEBUG
        g_PoolCurrTotalAlloc -= (blockToFree->Size + sizeof(PMBLOCK));
        g_PoolCurrActiveAlloc -= blockToFree->Size;
#endif

        MemFree(g_hHeap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //

#ifdef DEBUG
    g_PoolCurrTotalAlloc -= sizeof (POOLHEADER);
    g_PoolCurrPools --;
#endif

    MemFree(g_hHeap,0,poolHeader);

}

PVOID
RealPmGetMemory (
    IN PMHANDLE Handle,
    IN SIZE_T Size,
    IN DWORD AlignSize
    )

/*++

Routine Description:

    RealPmGetMemory is the worker routine that processes all requests to retrieve memory
    from a pool. Other calls eventually decay into a call to this common routine. This routine
    attempts to service the request out of the current memory block, or, if it cannot, out of
    a newly allocated block.

Arguments:

    Handle - A valid PMHANDLE.
    Size   - Contains the size in bytes that the caller needs from the pool.
    AlignSize - Provides an alignment value. The returned memory will be aligned on <alignsize> byte
        boundaries.

Return Value:

    The allocated memory, or, NULL if no memory could be allocated.

--*/
{
    BOOL haveEnoughMemory = TRUE;
    PVOID rMemory = NULL;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;
    PPMBLOCK currentBlock;
    PALLOCATION allocation;
    SIZE_T sizeNeeded;
    UINT_PTR padLength;

    MYASSERT(poolHeader != NULL);
    MYASSERT(Size);

    EnterCriticalSection (&g_PmCs);

    __try {

        //
        // Assume that the current block of memory will be sufficient.
        //
        currentBlock = poolHeader->PoolHead;

#ifdef DEBUG


        //
        // Update stats.
        //
        poolHeader->CurrentAllocationSize += Size;
        poolHeader->MaxAllocationSize = max(poolHeader->MaxAllocationSize,poolHeader->CurrentAllocationSize);
        poolHeader->NumAllocationRequests++;
        poolHeader->TotalAllocationRequestBytes += Size;

#endif

        //
        // Determine if more memory is needed, attempt to add if needed. Note that the size
        // must include the size of an ALLOCATION struct in addition to the size required
        // by the callee. Note the references to AlignSize in the test below. This is to ensure
        // that there is enough memory to allocate after taking into acount data alignment.
        //
        sizeNeeded = Size + sizeof(ALLOCATION);

        if (currentBlock->Size - currentBlock->Index < sizeNeeded + AlignSize) {

            haveEnoughMemory = pPmAddMemory(poolHeader,sizeNeeded + AlignSize);

            //
            // Make sure that the currentBlock is correctly set
            //
            currentBlock = poolHeader->PoolHead;
        }

        //
        // If there is enough memory available, return it.
        //
        if (haveEnoughMemory) {
            if (AlignSize) {

                padLength = (UINT_PTR) currentBlock + sizeof(PMBLOCK)
                    + currentBlock->Index + sizeof(ALLOCATION);
                currentBlock->Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

            }

            //
            // Save a reference to this block in the memorys ALLOCATION structure.
            // This will be used to decrease the use count on a block when releasing
            // memory.
            //
            allocation = (PALLOCATION) &(currentBlock->RawMemory[currentBlock->Index]);
            allocation->ParentBlock = currentBlock;


#ifdef DEBUG
            //
            // Track this memory.
            //
            allocation->DogTag = VALIDDOGTAG;
            allocation->Size = Size;
            allocation->Next = poolHeader->AllocationList;
            allocation->Prev = NULL;

            if (poolHeader->AllocationList) {
                poolHeader->AllocationList->Prev = allocation;
            }

            poolHeader->AllocationList = allocation;

            if (poolHeader->FreeCalled != WHO_CARES) {

                g_PoolCurrUsedAlloc += Size;
                if (g_PoolMaxUsedAlloc < g_PoolCurrUsedAlloc) {
                    g_PoolMaxUsedAlloc = g_PoolCurrUsedAlloc;
                }

                DebugRegisterAllocationEx (
                    POOLMEM_POINTER,
                    allocation,
                    g_TrackFile,
                    g_TrackLine,
                    g_TrackAlloc
                    );

            }
#endif

            //
            //  Ok, get a reference to the actual memory to return to the user.
            //
            rMemory = (PVOID)
                &(currentBlock->RawMemory[currentBlock->Index + sizeof(ALLOCATION)]);

            //
            // Update memory block data fields.
            //
            currentBlock->Index += sizeNeeded;
            currentBlock->UseCount++;
        }
        else {
            DEBUGMSG((DBG_ERROR,
                "GetPoolMemory Failed. Size: %u",Size));
        }

    } __finally {

        LeaveCriticalSection (&g_PmCs);
    }

    return rMemory;
}

VOID
PmReleaseMemory (
    IN PMHANDLE Handle,
    IN PCVOID Memory
    )
/*++

Routine Description:

    PmReleaseMemory notifies the Pool that a piece of memory is no longer needed.
    if all memory within a non-active block (i.e. not the first block) is released,
    that block will be freed. If all memory is released within an active block, that blocks
    stats are simply cleared, effectively reclaiming its space.

Arguments:

    Handle - A Handle to a Pool of Memory.
    Memory - Contains the address of the memory that is no longer needed.

Return Value:

    None.

--*/
{
    PALLOCATION allocation;
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL && Memory != NULL);

    EnterCriticalSection (&g_PmCs);

    __try {

        //
        // Get a reference to the ALLOCATION struct that precedes the actual memory.
        //
        allocation = (PALLOCATION) Memory - 1;

#ifdef DEBUG

        //
        // Update stats.
        //
        poolHeader->NumFreeRequests++;  //lint !e613
        poolHeader->CurrentAllocationSize -= allocation->Size;

#endif




#ifdef DEBUG

        if (poolHeader->FreeCalled == FREE_NOT_CALLED) {    //lint !e613
            poolHeader->FreeCalled = FREE_CALLED;   //lint !e613
        }

        //
        // Check the dog tag on the allocation to provide sanity checking on the memory passed in.
        //
        if (allocation->DogTag != VALIDDOGTAG) {
            if (allocation->DogTag == FREEDOGTAG) {
                DEBUGMSG((
                    DBG_WHOOPS,
                    "Poolmem Error! This dogtag has already been freed! Pool: %s",
                    poolHeader->Name
                    ));

            } else {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "Poolmem Error! Unknown value found in allocation dogtag.  Pool: %s",
                    poolHeader->Name
                    ));

                MYASSERT (FALSE);   //lint !e506
            }

            __leave;

        } else {
            allocation->DogTag = FREEDOGTAG;
        }

        if (allocation->Next) {
            allocation->Next->Prev = allocation->Prev;
        }

        if (poolHeader->AllocationList == allocation) { //lint !e613
            poolHeader->AllocationList = allocation->Next;  //lint !e613
        } else {

            allocation->Prev->Next = allocation->Next;
        }

        if (poolHeader->FreeCalled != WHO_CARES) {  //lint !e613

            g_PoolCurrUsedAlloc -= allocation->Size;

            DebugUnregisterAllocation(POOLMEM_POINTER,allocation);
        }
#endif

        //
        // Check to make sure this memory has not previously been freed.
        //
        if (allocation->ParentBlock == NULL) {
            DEBUGMSG((
                DBG_WHOOPS,
                "PoolMem Error! previously freed memory passed to PoolMemReleaseMemory.  Pool: %s",
                poolHeader->Name
                ));
            __leave;
        }

        //
        // Update the use count on this allocations parent block.
        //
        allocation->ParentBlock->UseCount--;




        if (allocation->ParentBlock->UseCount == 0) {

            //
            // This was the last allocation still referring to the parent block.
            //

            if (allocation->ParentBlock != poolHeader->PoolHead) {  //lint !e613
                //
                // Since the parent block isn't the active block, simply delete it.
                //

#ifdef DEBUG

                //
                // Adjust stats.
                //
                poolHeader->NumBlockFrees++;    //lint !e613
                poolHeader->CurrentlyAllocatedMemory -=
                    allocation->ParentBlock->Size + sizeof(PMBLOCK);    //lint !e613


#endif

                if (allocation->ParentBlock->NextBlock) {
                    allocation->ParentBlock->NextBlock->PrevBlock =
                        allocation->ParentBlock->PrevBlock;
                }
                allocation->ParentBlock->PrevBlock->NextBlock =
                    allocation->ParentBlock->NextBlock;

#ifdef DEBUG
                g_PoolCurrTotalAlloc -= (allocation->ParentBlock->Size + sizeof(PMBLOCK));
                g_PoolCurrActiveAlloc -= allocation->ParentBlock->Size;
#endif

                MemFree(g_hHeap,0,allocation->ParentBlock);


            }
            else {
                //
                // Since this is the active block, reset it.
                //
                allocation->ParentBlock->Index = 0;
                allocation->ParentBlock = NULL;

#ifdef DEBUG
                poolHeader->NumBlockClears++;   //lint !e613
#endif

            }
        }
        else {
            allocation->ParentBlock = NULL;

        }

    } __finally {

        LeaveCriticalSection (&g_PmCs);
    }

}


#ifdef DEBUG

PMHANDLE
RealPmCreateNamedPoolEx (
    IN      PCSTR Name,
    IN      DWORD BlockSize     OPTIONAL
    )
{
    PMHANDLE pool;
    PPOOLHEADER poolHeader;

    pool = RealPmCreatePoolEx (BlockSize);
    if (pool) {
        poolHeader = (PPOOLHEADER) pool;
        StringCopyByteCountA (poolHeader->Name, Name, MAX_POOL_NAME);
        MYASSERT (!poolHeader->TotalAllocationRequestBytes);
    }

    return pool;
}

#endif



PSTR
PmDuplicateMultiSzA (
    IN PMHANDLE Handle,
    IN PCSTR MultiSzToCopy
    )
{
    PSTR rString = (PSTR)MultiSzToCopy;
    SIZE_T size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (rString [0] != 0) {
        rString = GetEndOfStringA (rString) + 1;    //lint !e613
    }
    size = (rString - MultiSzToCopy + 1) * sizeof(CHAR);
    rString = PmGetAlignedMemory(Handle, size);
    memcpy (rString, MultiSzToCopy, size);

    return rString;
}

PWSTR
PmDuplicateMultiSzW (
    IN PMHANDLE Handle,
    IN PCWSTR MultiSzToCopy
    )
{
    PWSTR rString = (PWSTR)MultiSzToCopy;
    SIZE_T size;
    if (MultiSzToCopy == NULL) {
        return NULL;
    }
    while (rString [0] != 0) {
        rString = GetEndOfStringW (rString) + 1;
    }
    size = (rString - MultiSzToCopy + 1) * sizeof(WCHAR);
    rString = PmGetAlignedMemory(Handle, size);
    memcpy (rString, MultiSzToCopy, size);

    return rString;
}



#ifdef DEBUG

VOID
PmDisableTracking (
    IN PMHANDLE Handle
    )

/*++

Routine Description:

    PmDisableTracking suppresses the debug output caused by a pool
    that has a mix of freed and non-freed blocks.

Arguments:

    Handle - A Handle to a Pool of Memory.

Return Value:

    None.

--*/
{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    MYASSERT(poolHeader != NULL);
    poolHeader->FreeCalled = WHO_CARES;
}

VOID
PmDumpStatistics (
    VOID
    )
{
    DEBUGMSG ((
        DBG_STATS,
        "Pools usage:\nPeak   : Pools:%-3d Total:%-8d Usable:%-8d Used:%-8d\nCurrent: Pools:%-3d Total:%-8d Usable:%-8d Leak:%-8d",
        g_PoolMaxPools,
        g_PoolMaxTotalAlloc,
        g_PoolMaxActiveAlloc,
        g_PoolMaxUsedAlloc,
        g_PoolCurrPools,
        g_PoolCurrTotalAlloc,
        g_PoolCurrActiveAlloc,
        g_PoolCurrUsedAlloc
        ));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\objstr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    objstr.c

Abstract:

    Implements a set of APIs to handle the string representation of nodes/leafs of a tree

Author:

    03-Jan-2000 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

/*
                                   +-------+
                                   | root1 |                            Level 1
                                   +-------+
                                      / \
                                    /     \
                          +---------+     (-------)
                          |  node1  |    (  leaf1  )                    Level 2
                          +---------+     (-------)
                          /  |   \  \__________
                        /    |     \           \
               +-------+ +-------+  (-------)   (-------)
               | node2 | | node3 | (  leaf2  ) (  leaf3  )              Level 3
               +-------+ +-------+  (-------)   (-------)
                  / \
                /     \
          +-------+  (-------)
          | node4 | (  leaf4  )                                         Level 4
          +-------+  (-------)
             / \
           /     \
    (-------)   (-------)
   (  leaf5  ) (  leaf6  )                                              Level 5
    (-------)   (-------)


    The string representation of some tree elements above:

    root1
    root1 <leaf1>
    root1\node1
    root1\node1 <leaf2>
    root1\node1 <leaf3>

*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_OBJSTR      "ObjStr"

//
// Strings
//

#define S_OBJSTR        "ObjStr"

//
// Constants
//

#define OBJSTR_NODE_BEGINA          '\025'
#define OBJSTR_NODE_BEGINW          L'\025'

#define OBJSTR_NODE_TERMA           '\\'
#define OBJSTR_NODE_TERMW           L'\\'

#define OBJSTR_NODE_LEAF_SEPA       '\020'
#define OBJSTR_NODE_LEAF_SEPW       L'\020'

#define OBJSTR_LEAF_BEGINA          '\005'
#define OBJSTR_LEAF_BEGINW          L'\005'

//
// Macros
//

#define pObjStrAllocateMemory(Size)   PmGetMemory (g_ObjStrPool, Size)

#define pObjStrFreeMemory(Buffer)     if (/*lint --e(774)*/Buffer) PmReleaseMemory (g_ObjStrPool, Buffer)

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_ObjStrPool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
ObsInitialize (
    VOID
    )

/*++

Routine Description:

    ObsInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_ObjStrPool = PmCreateNamedPool (S_OBJSTR);
    return g_ObjStrPool != NULL;
}


VOID
ObsTerminate (
    VOID
    )

/*++

Routine Description:

    ObsTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    if (g_ObjStrPool) {
        PmDestroyPool (g_ObjStrPool);
        g_ObjStrPool = NULL;
    }
}


/*++

Routine Description:

    pExtractStringAB is a private function that creates a new string in the given pool,
    using a source string and a limit to copy up to.

Arguments:

    Start - Specifies the source string
    End - Specifies the point to copy up to (excluding it), within the same string
    Pool - Specifies the pool to use for allocation

Return Value:

    A pointer to the newly created string

--*/

PSTR
pExtractStringABA (
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      PMHANDLE Pool
    )
{
    PSTR p;

    p = PmGetMemory (Pool, (DWORD)(End - Start + 1) * DWSIZEOF (CHAR));
    StringCopyABA (p, Start, End);
    return p;
}


PWSTR
pExtractStringABW (
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      PMHANDLE Pool
    )
{
    PWSTR p;

    p = PmGetMemory (Pool, (DWORD)(End - Start + 1) * DWSIZEOF (WCHAR));
    StringCopyABW (p, Start, End);
    return p;
}


/*++

Routine Description:

    ObsFree frees the given object from the private pool

Arguments:

    EncodedObject - Specifies the source string
    End - Specifies the point to copy up to (excluding it), within the same string
    Pool - Specifies the pool to use for allocation

Return Value:

    A pointer to the newly created string

--*/

VOID
ObsFreeA (
    IN      PCSTR EncodedObject
    )
{
    pObjStrFreeMemory ((PVOID)EncodedObject);
}


VOID
ObsFreeW (
    IN      PCWSTR EncodedObject
    )
{
    pObjStrFreeMemory ((PVOID)EncodedObject);
}

BOOL
ObsEncodeStringExA (
    PSTR Destination,
    PCSTR Source,
    PCSTR CharsToEncode
    )
{
    MBCHAR ch;

    if (!CharsToEncode) {
        CharsToEncode = EscapedCharsA;
    }

    while (*Source) {
        ch = _mbsnextc (Source);
        if (_mbschr (CharsToEncode, ch)) {
            *Destination = '^';
            Destination ++;
        }
        // now copy the multibyte character
        if (IsLeadByte (Source)) {
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
        *Destination = *Source;
        Destination ++;
        Source ++;
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsEncodeStringExW (
    PWSTR Destination,
    PCWSTR Source,
    PCWSTR CharsToEncode
    )
{
    if (!CharsToEncode) {
        CharsToEncode = EscapedCharsW;
    }

    while (*Source) {
        if (wcschr (CharsToEncode, *Source)) {
            *Destination = L'^';
            Destination ++;
        }
        *Destination = *Source;
        Destination ++;
        Source ++;
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsDecodeStringA (
    PSTR Destination,
    PCSTR Source
    )
{
    BOOL escaping = FALSE;

    while (*Source) {
        if ((_mbsnextc (Source) == '^') && (!escaping)) {
            escaping = TRUE;
            Source ++;
        } else {
            escaping = FALSE;
            // now copy the multibyte character
            if (IsLeadByte (Source)) {
                *Destination = *Source;
                Destination ++;
                Source ++;
            }
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
    }
    *Destination = 0;
    return TRUE;
}

BOOL
ObsDecodeStringW (
    PWSTR Destination,
    PCWSTR Source
    )
{
    BOOL escaping = FALSE;

    while (*Source) {
        if ((*Source == L'^') && (!escaping)) {
            escaping = TRUE;
            Source ++;
        } else {
            escaping = FALSE;
            *Destination = *Source;
            Destination ++;
            Source ++;
        }
    }
    *Destination = 0;
    return TRUE;
}


PCSTR
ObsFindNonEncodedCharInEncodedStringA (
    IN      PCSTR String,
    IN      MBCHAR Char
    )
{
    MBCHAR ch;

    while (*String) {
        ch = _mbsnextc (String);

        if (ch == '^') {
            String++;
        } else if (ch == Char) {
            return String;
        }

        String = _mbsinc (String);
    }

    return NULL;
}


PCWSTR
ObsFindNonEncodedCharInEncodedStringW (
    IN      PCWSTR String,
    IN      WCHAR Char
    )
{
    WCHAR ch;

    while (*String) {
        ch = *String;

        if (ch == L'^') {
            String++;
        } else if (ch == Char) {
            return String;
        }

        String++;
    }

    return NULL;
}


/*++

Routine Description:

    ObsSplitObjectStringEx splits the given encoded object into components: node and
    leaf. Strings are allocated from the given pool

Arguments:

    EncodedObject - Specifies the source object string
    DecodedNode - Receives the decoded node part; optional
    DecodedLeaf - Receives the decoded leaf part; optional
    Pool - Specifies the pool to use for allocation; optional; if not specified,
           the module pool will be used and ObsFree needs to be called for them
           to be freed

Return Value:

    TRUE if the source object has a legal format and it has been split into components

--*/

BOOL
RealObsSplitObjectStringExA (
    IN      PCSTR EncodedObject,
    OUT     PCSTR* DecodedNode,         OPTIONAL
    OUT     PCSTR* DecodedLeaf,         OPTIONAL
    IN      PMHANDLE Pool,              OPTIONAL
    IN      BOOL DecodeStrings
    )
{
    PCSTR currStr = EncodedObject;
    PCSTR end;
    PCSTR oneBack;
    PCSTR next;
    MBCHAR ch;
    BOOL middle = FALSE;

    MYASSERT (EncodedObject);
    if (!EncodedObject) {
        return FALSE;
    }

    if (!Pool) {
        Pool = g_ObjStrPool;
    }

    if (DecodedNode) {
        *DecodedNode = NULL;
    }
    if (DecodedLeaf) {
        *DecodedLeaf = NULL;
    }

    for (;;) {

        ch = _mbsnextc (currStr);

        if (!middle && ch == OBJSTR_NODE_BEGINA) {

            //
            // Find the end of node
            //

            currStr++;
            end = ObsFindNonEncodedCharInEncodedStringA (currStr, OBJSTR_NODE_LEAF_SEPA);

            next = end;
            MYASSERT (next);
            if (*next) {
                next++;
            }

            if (end > currStr) {
                oneBack = _mbsdec (currStr, end);
                if (_mbsnextc (oneBack) == '\\') {
                    end = oneBack;
                }
            }

            if (DecodedNode) {
                //
                // Extract the string into a pool
                //

                *DecodedNode = pExtractStringABA (currStr, end, Pool);

                //
                // Decode if necessary
                //

                if (DecodeStrings) {
                    ObsDecodeStringA ((PSTR)(*DecodedNode), *DecodedNode);
                }
            }

            //
            // Continue on to leaf portion
            //

            currStr = next;
            middle = TRUE;

        } else if (ch == OBJSTR_LEAF_BEGINA) {

            //
            // Find the end of leaf
            //

            currStr++;
            end = GetEndOfStringA (currStr);

            if (DecodedLeaf) {
                //
                // Extract the string into a pool
                //

                *DecodedLeaf = pExtractStringABA (currStr, end, Pool);

                //
                // Decode if necessary
                //

                if (DecodeStrings) {
                    ObsDecodeStringA ((PSTR)(*DecodedLeaf), *DecodedLeaf);
                }
            }

            //
            // Done
            //

            break;

        } else if (ch == 0 && middle) {

            //
            // Either no leaf or empty string
            //

            break;

        } else if (!middle && ch == OBJSTR_NODE_LEAF_SEPA) {

            middle = TRUE;
            currStr++;

        } else {
            //
            // Syntax error
            //

            DEBUGMSGA ((DBG_ERROR, "%s is an invalid string encoding", EncodedObject));

            if (DecodedNode && *DecodedNode) {
                ObsFreeA (*DecodedNode);
                *DecodedNode = NULL;
            }

            if (DecodedLeaf && *DecodedLeaf) {
                ObsFreeA (*DecodedLeaf);
                *DecodedLeaf = NULL;
            }

            return FALSE;
        }
    }

    return TRUE;
}


BOOL
RealObsSplitObjectStringExW (
    IN      PCWSTR EncodedObject,
    OUT     PCWSTR* DecodedNode,         OPTIONAL
    OUT     PCWSTR* DecodedLeaf,         OPTIONAL
    IN      PMHANDLE Pool,               OPTIONAL
    IN      BOOL DecodeStrings
    )
{
    PCWSTR currStr = EncodedObject;
    PCWSTR end;
    PCWSTR oneBack;
    PCWSTR next;
    WCHAR ch;
    BOOL middle = FALSE;

    MYASSERT (EncodedObject);
    if (!EncodedObject) {
        return FALSE;
    }

    if (!Pool) {
        Pool = g_ObjStrPool;
    }

    if (DecodedNode) {
        *DecodedNode = NULL;
    }
    if (DecodedLeaf) {
        *DecodedLeaf = NULL;
    }

    for (;;) {

        ch = *currStr;

        if (!middle && ch == OBJSTR_NODE_BEGINA) {

            //
            // Find the end of node
            //

            currStr++;
            end = ObsFindNonEncodedCharInEncodedStringW (currStr, OBJSTR_NODE_LEAF_SEPA);

            next = end;
            MYASSERT (next);
            if (*next) {
                next++;
            }

            if (end > currStr) {
                oneBack = end - 1;
                if (*oneBack == L'\\') {
                    end = oneBack;
                }
            }

            if (DecodedNode) {
                //
                // Extract the string into a pool
                //

                *DecodedNode = pExtractStringABW (currStr, end, Pool);

                //
                // Decode if necessary
                //

                if (DecodeStrings) {
                    ObsDecodeStringW ((PWSTR)(*DecodedNode), *DecodedNode);
                }
            }

            //
            // Continue on to leaf portion
            //

            currStr = next;
            middle = TRUE;

        } else if (ch == OBJSTR_LEAF_BEGINA) {

            //
            // Find the end of leaf
            //

            currStr++;
            end = GetEndOfStringW (currStr);

            if (DecodedLeaf) {
                //
                // Extract the string into a pool
                //

                *DecodedLeaf = pExtractStringABW (currStr, end, Pool);

                //
                // Decode if necessary
                //

                if (DecodeStrings) {
                    ObsDecodeStringW ((PWSTR)(*DecodedLeaf), *DecodedLeaf);
                }
            }

            //
            // Done
            //

            break;

        } else if (ch == 0 && middle) {

            //
            // Either no leaf or empty string
            //

            break;

        } else if (!middle && ch == OBJSTR_NODE_LEAF_SEPW) {

            middle = TRUE;
            currStr++;

        } else {
            //
            // Syntax error
            //

            DEBUGMSGW ((DBG_ERROR, "%s is an invalid string encoding", EncodedObject));

            if (DecodedNode && *DecodedNode) {
                ObsFreeW (*DecodedNode);
                *DecodedNode = NULL;
            }

            if (DecodedLeaf && *DecodedLeaf) {
                ObsFreeW (*DecodedLeaf);
                *DecodedLeaf = NULL;
            }

            return FALSE;
        }
    }

    return TRUE;
}


BOOL
ObsHasNodeA (
    IN      PCSTR EncodedObject
    )
{
    return *EncodedObject == OBJSTR_NODE_BEGINA;
}


BOOL
ObsHasNodeW (
    IN      PCWSTR EncodedObject
    )
{
    return *EncodedObject == OBJSTR_NODE_BEGINW;
}


PCSTR
ObsGetLeafPortionOfEncodedStringA (
    IN      PCSTR EncodedObject
    )
{
    return ObsFindNonEncodedCharInEncodedStringA (EncodedObject, OBJSTR_LEAF_BEGINA);
}


PCWSTR
ObsGetLeafPortionOfEncodedStringW (
    IN      PCWSTR EncodedObject
    )
{
    return ObsFindNonEncodedCharInEncodedStringW (EncodedObject, OBJSTR_LEAF_BEGINW);
}


PCSTR
ObsGetNodeLeafDividerA (
    IN      PCSTR EncodedObject
    )
{
    return ObsFindNonEncodedCharInEncodedStringA (EncodedObject, OBJSTR_NODE_LEAF_SEPA);
}


PCWSTR
ObsGetNodeLeafDividerW (
    IN      PCWSTR EncodedObject
    )
{
    return ObsFindNonEncodedCharInEncodedStringW (EncodedObject, OBJSTR_NODE_LEAF_SEPW);
}


/*++

Routine Description:

    ObsBuildEncodedObjectStringEx builds an encoded object from components: node and
    leaf. The string is allocated from the module's pool

Arguments:

    DecodedNode - Specifies the decoded node part
    DecodedLeaf - Specifies the decoded leaf part; optional
    EncodeObject - Specifies TRUE if the resulting object needs to be encoded using
                   encoding rules
    Partial - Specifies TRUE if the node/leaf separator should not be added.  In this
              case, DecodedLeaf must be NULL.

Return Value:

    Pointer to the newly created object string

--*/

PSTR
RealObsBuildEncodedObjectStringExA (
    IN      PCSTR DecodedNode,      OPTIONAL
    IN      PCSTR DecodedLeaf,      OPTIONAL
    IN      BOOL EncodeObject
    )
{
    PSTR result;
    PSTR p;
    UINT size;

    //
    // at most, one byte char will be expanded to 2 bytes (2 times)
    //
    if (EncodeObject) {

        //
        // Compute the result size
        //

        size = DWSIZEOF(OBJSTR_NODE_LEAF_SEPA);

        if (DecodedNode) {
            size += DWSIZEOF(OBJSTR_NODE_BEGINA);
            size += ByteCountA (DecodedNode) * 2;
            size += DWSIZEOF(OBJSTR_NODE_TERMA);
        }

        if (DecodedLeaf) {
            size += DWSIZEOF(OBJSTR_LEAF_BEGINA);
            size += ByteCountA (DecodedLeaf) * 2;
        }

        size += DWSIZEOF(CHAR);

        //
        // Build encoded string
        //

        result = (PSTR) pObjStrAllocateMemory (size);
        p = result;

        if (DecodedNode) {
            *p++ = OBJSTR_NODE_BEGINA;

            ObsEncodeStringA (p, DecodedNode);
            p = GetEndOfStringA (p);

            if (p == (result + 1) || _mbsnextc (_mbsdec (result, p)) != OBJSTR_NODE_TERMA) {
                *p++ = OBJSTR_NODE_TERMA;
            }
        }

        *p++ = OBJSTR_NODE_LEAF_SEPA;

        if (DecodedLeaf) {
            *p++ = OBJSTR_LEAF_BEGINA;
            ObsEncodeStringA (p, DecodedLeaf);
        } else {
            *p = 0;
        }
    } else {

        //
        // Compute the result size
        //

        size = DWSIZEOF(OBJSTR_NODE_LEAF_SEPA);

        if (DecodedNode) {
            size += DWSIZEOF(OBJSTR_NODE_BEGINA);
            size += ByteCountA (DecodedNode);
            size += DWSIZEOF(OBJSTR_NODE_TERMA);
        }

        if (DecodedLeaf) {
            size += DWSIZEOF(OBJSTR_LEAF_BEGINA);
            size += ByteCountA (DecodedLeaf);
        }

        size += DWSIZEOF(CHAR);

        //
        // Build non-encoded string
        //

        result = (PSTR) pObjStrAllocateMemory (size);
        p = result;

        if (DecodedNode) {
            *p++ = OBJSTR_NODE_BEGINA;
            *p = 0;

            p = StringCatA (p, DecodedNode);

            if (p == (result + 1) || _mbsnextc (_mbsdec (result, p)) != OBJSTR_NODE_TERMA) {
                *p++ = OBJSTR_NODE_TERMA;
            }
        }

        *p++ = OBJSTR_NODE_LEAF_SEPA;

        if (DecodedLeaf) {
            *p++ = OBJSTR_LEAF_BEGINA;
            StringCopyA (p, DecodedLeaf);
        } else {
            *p = 0;
        }
    }

    return result;
}


PWSTR
RealObsBuildEncodedObjectStringExW (
    IN      PCWSTR DecodedNode,
    IN      PCWSTR DecodedLeaf,     OPTIONAL
    IN      BOOL EncodeObject
    )
{
    PWSTR result;
    PWSTR p;
    UINT size;

    //
    // at most, one byte char will be expanded to 2 bytes (2 times)
    //
    if (EncodeObject) {

        //
        // Compute the result size
        //

        size = DWSIZEOF(OBJSTR_NODE_LEAF_SEPW);

        if (DecodedNode) {
            size += DWSIZEOF(OBJSTR_NODE_BEGINW);
            size += ByteCountW (DecodedNode) * 2;
            size += DWSIZEOF(OBJSTR_NODE_TERMW);
        }

        if (DecodedLeaf) {
            size += DWSIZEOF(OBJSTR_LEAF_BEGINW);
            size += ByteCountW (DecodedLeaf) * 2;
        }

        size += DWSIZEOF(WCHAR);

        //
        // Build encoded string
        //

        result = (PWSTR) pObjStrAllocateMemory (size);
        p = result;

        if (DecodedNode) {
            *p++ = OBJSTR_NODE_BEGINW;

            ObsEncodeStringW (p, DecodedNode);
            p = GetEndOfStringW (p);

            if (p == (result + 1) || *(p - 1) != OBJSTR_NODE_TERMW) {
                *p++ = OBJSTR_NODE_TERMW;
            }
        }

        *p++ = OBJSTR_NODE_LEAF_SEPW;

        if (DecodedLeaf) {
            *p++ = OBJSTR_LEAF_BEGINW;
            ObsEncodeStringW (p, DecodedLeaf);
        } else {
            *p = 0;
        }
    } else {

        //
        // Compute the result size
        //

        size = DWSIZEOF(OBJSTR_NODE_LEAF_SEPW);

        if (DecodedNode) {
            size += DWSIZEOF(OBJSTR_NODE_BEGINW);
            size += ByteCountW (DecodedNode);
            size += DWSIZEOF(OBJSTR_NODE_TERMW);
        }

        if (DecodedLeaf) {
            size += DWSIZEOF(OBJSTR_LEAF_BEGINW);
            size += ByteCountW (DecodedLeaf);
        }

        size += DWSIZEOF(WCHAR);

        //
        // Build non-encoded string
        //

        result = (PWSTR) pObjStrAllocateMemory (size);
        p = result;

        if (DecodedNode) {
            *p++ = OBJSTR_NODE_BEGINW;
            *p = 0;

            p = StringCatW (p, DecodedNode);

            if (p == (result + 1) || *(p - 1) != OBJSTR_NODE_TERMW) {
                *p++ = OBJSTR_NODE_TERMW;
            }
        }

        *p++ = OBJSTR_NODE_LEAF_SEPW;

        if (DecodedLeaf) {
            *p++ = OBJSTR_LEAF_BEGINW;
            StringCopyW (p, DecodedLeaf);
        } else {
            *p = 0;
        }
    }

    return result;
}


/*++

Routine Description:

    RealObsCreateParsedPatternEx parses the given object into an internal format for quick
    pattern matching

Arguments:

    EncodedObject - Specifies the source object string

Return Value:

    A pointer to the newly created structure or NULL if the object was invalid

--*/

POBSPARSEDPATTERNA
RealObsCreateParsedPatternExA (
    IN      PMHANDLE Pool,              OPTIONAL
    IN      PCSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    POBSPARSEDPATTERNA ospp;
    PSTR decodedNode;
    PSTR decodedLeaf;
    PCSTR p;
    PCSTR root;
    PSTR encodedStr;
    PSTR decodedStr;

    MYASSERT (EncodedObject);

    if (!ObsSplitObjectStringExA (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return NULL;
    }

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = g_ObjStrPool;
    }

    ospp = PmGetMemory (pool, DWSIZEOF(OBSPARSEDPATTERNA));
    ZeroMemory (ospp, DWSIZEOF(OBSPARSEDPATTERNA));
    ospp->MaxSubLevel = NODE_LEVEL_MAX;
    ospp->Pool = pool;

    MYASSERT (decodedNode);
    if (*decodedNode) {
        if (!GetNodePatternMinMaxLevelsA (decodedNode, decodedNode, &ospp->MinNodeLevel, &ospp->MaxNodeLevel)) {
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            PmReleaseMemory (pool, ospp);
            return NULL;
        }
    } else {
        ospp->MinNodeLevel = 1;
        ospp->MaxNodeLevel = NODE_LEVEL_MAX;
    }

    MYASSERT (ospp->MinNodeLevel > 0 && ospp->MaxNodeLevel >= ospp->MinNodeLevel);
    if (ospp->MaxNodeLevel != NODE_LEVEL_MAX) {
        ospp->MaxSubLevel = ospp->MaxNodeLevel - ospp->MinNodeLevel;
    }

    if (*decodedNode) {
        ospp->NodePattern = CreateParsedPatternExA (Pool, decodedNode);
        if (!ospp->NodePattern) {
            DEBUGMSGA ((
                DBG_OBJSTR,
                "ObsCreateParsedPatternExA: Bad EncodedObject: %s",
                EncodedObject
                ));
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            PmReleaseMemory (pool, ospp);
            return NULL;
        }
        if (ospp->NodePattern->PatternCount > 1) {
            DEBUGMSGA ((
                DBG_OBJSTR,
                "ObsCreateParsedPatternExA: Bad EncodedObject (multiple patterns specified): %s",
                EncodedObject
                ));
            DestroyParsedPatternA (ospp->NodePattern);
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            PmReleaseMemory (pool, ospp);
            return NULL;
        }

        root = ParsedPatternGetRootA (ospp->NodePattern);
        if (root) {
            //
            // extract the real root part
            //
            if (ParsedPatternIsExactMatchA (ospp->NodePattern)) {
                ospp->Flags |= OBSPF_EXACTNODE;
                // the ExactRoot needs to be case sensitive, we rely on root to give
                // us the size but we extract it from decodedNode
                ospp->ExactRootBytes = ByteCountA (root);
                ospp->ExactRoot = PmGetMemory (pool, ospp->ExactRootBytes + sizeof (CHAR));
                CopyMemory (ospp->ExactRoot, decodedNode, ospp->ExactRootBytes);
                ospp->ExactRoot [ospp->ExactRootBytes / sizeof (CHAR)] = 0;
                ospp->MaxSubLevel = 0;
            } else {
                p = FindLastWackA (root);
                if (p) {
                    //
                    // exact root specified
                    // if the last wack is actually the last character or is followed by star(s),
                    // optimize the matching by setting some flags
                    //
                    if (*(p + 1) == 0) {
                        if (ParsedPatternIsRootPlusStarA (ospp->NodePattern)) {
                            ospp->Flags |= OBSPF_NODEISROOTPLUSSTAR;
                        }
                    }
                    if (MakePrimaryRootEndWithWack && p == _mbschr (root, '\\')) {
                        //
                        // include it in the string
                        //
                        p++;
                    }
                    // the ExactRoot needs to be case sensitive, we rely on root to give
                    // us the size but we extract it from decodedNode
                    ospp->ExactRootBytes = (DWORD)((PBYTE)p - (PBYTE)root);
                    decodedStr = AllocPathStringA (ospp->ExactRootBytes / sizeof (CHAR) + 1);
					encodedStr = AllocPathStringA (2 * ospp->ExactRootBytes / sizeof (CHAR) + 1);
                    CopyMemory (decodedStr, root, ospp->ExactRootBytes);
					decodedStr [ospp->ExactRootBytes / sizeof (CHAR)] = 0;
                    ObsEncodeStringA (encodedStr, decodedStr);
					ospp->ExactRootBytes = SizeOfStringA (encodedStr) - sizeof (CHAR);
                    ospp->ExactRoot = PmGetMemory (pool, ospp->ExactRootBytes + sizeof (CHAR));
                    CopyMemory (ospp->ExactRoot, decodedNode, ospp->ExactRootBytes);
                    FreePathStringA (encodedStr);
                    FreePathStringA (decodedStr);
                    ospp->ExactRoot [ospp->ExactRootBytes / sizeof (CHAR)] = 0;

				}
            }
        } else if (ParsedPatternIsOptionalA (ospp->NodePattern)) {
            ospp->Flags |= OBSPF_OPTIONALNODE;
        }
    }

    if (decodedLeaf) {
        if (*decodedLeaf) {
            ospp->LeafPattern = CreateParsedPatternExA (Pool, decodedLeaf);
            if (!ospp->LeafPattern) {
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExA: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                DestroyParsedPatternA (ospp->NodePattern);
                PmReleaseMemory (pool, ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                PmReleaseMemory (pool, ospp);
                return NULL;
            }
            if (ospp->LeafPattern->PatternCount > 1) {
                DEBUGMSGA ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExA: Bad EncodedObject (multiple patterns specified): %s",
                    EncodedObject
                    ));
                DestroyParsedPatternA (ospp->NodePattern);
                DestroyParsedPatternA (ospp->LeafPattern);
                PmReleaseMemory (pool, ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                PmReleaseMemory (pool, ospp);
                return NULL;
            }

            if (ParsedPatternIsOptionalA (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_OPTIONALLEAF;
            } else if (ParsedPatternIsExactMatchA (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_EXACTLEAF;
            }

        } else {
            //
            // accept empty string for leaf
            //
            ospp->LeafPattern = CreateParsedPatternExA (Pool, decodedLeaf);
            ospp->Flags |= OBSPF_EXACTLEAF;
        }
        ospp->Leaf = PmDuplicateStringA (pool, decodedLeaf);
    } else {
        ospp->Flags |= OBSPF_NOLEAF;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);
    return ospp;
}


POBSPARSEDPATTERNW
RealObsCreateParsedPatternExW (
    IN      PMHANDLE Pool,              OPTIONAL
    IN      PCWSTR EncodedObject,
    IN      BOOL MakePrimaryRootEndWithWack
    )
{
    PMHANDLE pool;
    BOOL externalPool = FALSE;
    POBSPARSEDPATTERNW ospp;
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    PCWSTR p;
    PCWSTR root;
    PWSTR encodedStr;
    PWSTR decodedStr;

    MYASSERT (EncodedObject);

    if (!ObsSplitObjectStringExW (EncodedObject, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return NULL;
    }

    if (Pool) {
        externalPool = TRUE;
        pool = Pool;
    } else {
        pool = g_ObjStrPool;
    }

    ospp = PmGetMemory (pool, DWSIZEOF(OBSPARSEDPATTERNA));
    ZeroMemory (ospp, DWSIZEOF(OBSPARSEDPATTERNW));
    ospp->MaxSubLevel = NODE_LEVEL_MAX;
    ospp->Pool = pool;

    MYASSERT (decodedNode);
    if (*decodedNode) {
        if (!GetNodePatternMinMaxLevelsW (decodedNode, decodedNode, &ospp->MinNodeLevel, &ospp->MaxNodeLevel)) {
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            pObjStrFreeMemory (ospp);
            return NULL;
        }
    } else {
        ospp->MinNodeLevel = 1;
        ospp->MaxNodeLevel = NODE_LEVEL_MAX;
    }

    MYASSERT (ospp->MinNodeLevel > 0 && ospp->MaxNodeLevel >= ospp->MinNodeLevel);
    if (ospp->MaxNodeLevel != NODE_LEVEL_MAX) {
        ospp->MaxSubLevel = ospp->MaxNodeLevel - ospp->MinNodeLevel;
    }

    if (*decodedNode) {
        ospp->NodePattern = CreateParsedPatternExW (Pool, decodedNode);
        if (!ospp->NodePattern) {
            DEBUGMSGW ((
                DBG_OBJSTR,
                "ObsCreateParsedPatternExW: Bad EncodedObject: %s",
                EncodedObject
                ));
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            PmReleaseMemory (pool, ospp);
            return NULL;
        }
        if (ospp->NodePattern->PatternCount > 1) {
            DEBUGMSGW ((
                DBG_OBJSTR,
                "ObsCreateParsedPatternExW: Bad EncodedObject (multiple patterns specified): %s",
                EncodedObject
                ));
            DestroyParsedPatternW (ospp->NodePattern);
            pObjStrFreeMemory (decodedNode);
            pObjStrFreeMemory (decodedLeaf);
            PmReleaseMemory (pool, ospp);
            return NULL;
        }

        root = ParsedPatternGetRootW (ospp->NodePattern);
        if (root) {
            //
            // extract the real root part
            //
            if (ParsedPatternIsExactMatchW (ospp->NodePattern)) {
                ospp->Flags |= OBSPF_EXACTNODE;
                // the ExactRoot needs to be case sensitive, we rely on root to give
                // us the size but we extract it from decodedNode
                ospp->ExactRootBytes = ByteCountW (root);
                ospp->ExactRoot = PmGetMemory (pool, ospp->ExactRootBytes + sizeof (WCHAR));
                CopyMemory (ospp->ExactRoot, decodedNode, ospp->ExactRootBytes);
                ospp->ExactRoot [ospp->ExactRootBytes / sizeof (WCHAR)] = 0;
                ospp->MaxSubLevel = 0;
            } else {
                p = FindLastWackW (root);
                if (p) {
                    //
                    // exact root specified
                    // if the last wack is actually the last character or is followed by star(s),
                    // optimize the matching by setting some flags
                    //
                    if (*(p + 1) == 0) {
                        if (ParsedPatternIsRootPlusStarW (ospp->NodePattern)) {
                            ospp->Flags |= OBSPF_NODEISROOTPLUSSTAR;
                        }
                    }
                    if (MakePrimaryRootEndWithWack && p == wcschr (root, L'\\')) {
                        //
                        // include it in the string
                        //
                        p++;
                    }
                    // the ExactRoot needs to be case sensitive, we rely on root to give
                    // us the size but we extract it from decodedNode
                    ospp->ExactRootBytes = (DWORD)((PBYTE)p - (PBYTE)root);
                    decodedStr = AllocPathStringW (ospp->ExactRootBytes / sizeof (WCHAR) + 1);
					encodedStr = AllocPathStringW (2 * ospp->ExactRootBytes / sizeof (WCHAR) + 1);
                    CopyMemory (decodedStr, root, ospp->ExactRootBytes);
                    decodedStr [ospp->ExactRootBytes / sizeof (WCHAR)] = 0;
                    ObsEncodeStringW (encodedStr, decodedStr);
					ospp->ExactRootBytes = SizeOfStringW (encodedStr) - sizeof (WCHAR);
                    ospp->ExactRoot = PmGetMemory (pool, ospp->ExactRootBytes + sizeof (WCHAR));
                    CopyMemory (ospp->ExactRoot, decodedNode, ospp->ExactRootBytes);
                    FreePathStringW (encodedStr);
                    FreePathStringW (decodedStr);
                    ospp->ExactRoot [ospp->ExactRootBytes / sizeof (WCHAR)] = 0;
                }
            }
        } else if (ParsedPatternIsOptionalW (ospp->NodePattern)) {
            ospp->Flags |= OBSPF_OPTIONALNODE;
        }
    }

    if (decodedLeaf) {
        if (*decodedLeaf) {
            ospp->LeafPattern = CreateParsedPatternExW (Pool, decodedLeaf);
            if (!ospp->LeafPattern) {
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExW: Bad EncodedObject: %s",
                    EncodedObject
                    ));
                DestroyParsedPatternW (ospp->NodePattern);
                PmReleaseMemory (pool, ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                PmReleaseMemory (pool, ospp);
                return NULL;
            }
            if (ospp->LeafPattern->PatternCount > 1) {
                DEBUGMSGW ((
                    DBG_OBJSTR,
                    "ObsCreateParsedPatternExW: Bad EncodedObject (multiple patterns specified): %s",
                    EncodedObject
                    ));
                DestroyParsedPatternW (ospp->NodePattern);
                DestroyParsedPatternW (ospp->LeafPattern);
                PmReleaseMemory (pool, ospp->ExactRoot);
                pObjStrFreeMemory (decodedNode);
                pObjStrFreeMemory (decodedLeaf);
                PmReleaseMemory (pool, ospp);
                return NULL;
            }

            if (ParsedPatternIsOptionalW (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_OPTIONALLEAF;
            } else if (ParsedPatternIsExactMatchW (ospp->LeafPattern)) {
                ospp->Flags |= OBSPF_EXACTLEAF;
            }

        } else {
            //
            // accept empty string for leaf
            //
            ospp->LeafPattern = CreateParsedPatternExW (Pool, decodedLeaf);
            ospp->Flags |= OBSPF_EXACTLEAF;
        }
        ospp->Leaf = PmDuplicateStringW (pool, decodedLeaf);
    } else {
        ospp->Flags |= OBSPF_NOLEAF;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);
    return ospp;
}


/*++

Routine Description:

    ObsDestroyParsedPattern destroys the given structure, freeing resources

Arguments:

    ParsedPattern - Specifies the parsed pattern structure

Return Value:

    none

--*/

VOID
ObsDestroyParsedPatternA (
    IN      POBSPARSEDPATTERNA ParsedPattern
    )
{
    if (ParsedPattern) {
        if (ParsedPattern->NodePattern) {
            DestroyParsedPatternA (ParsedPattern->NodePattern);
        }
        if (ParsedPattern->LeafPattern) {
            DestroyParsedPatternA (ParsedPattern->LeafPattern);
        }
        if (ParsedPattern->Leaf) {
            PmReleaseMemory (ParsedPattern->Pool, ParsedPattern->Leaf);
        }
        if (ParsedPattern->ExactRoot) {
            PmReleaseMemory (ParsedPattern->Pool, ParsedPattern->ExactRoot);
        }
        PmReleaseMemory (ParsedPattern->Pool, ParsedPattern);
    }
}


VOID
ObsDestroyParsedPatternW (
    IN      POBSPARSEDPATTERNW ParsedPattern
    )
{
    if (ParsedPattern) {
        if (ParsedPattern->NodePattern) {
            DestroyParsedPatternW (ParsedPattern->NodePattern);
        }
        if (ParsedPattern->LeafPattern) {
            DestroyParsedPatternW (ParsedPattern->LeafPattern);
        }
        if (ParsedPattern->Leaf) {
            PmReleaseMemory (ParsedPattern->Pool, ParsedPattern->Leaf);
        }
        if (ParsedPattern->ExactRoot) {
            PmReleaseMemory (ParsedPattern->Pool, ParsedPattern->ExactRoot);
        }
        PmReleaseMemory (ParsedPattern->Pool, ParsedPattern);
    }
}


/*++

Routine Description:

    ObsParsedPatternMatch tests the given object against a parsed pattern

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    EncodedObject - Specifies the object string to test against the pattern

Return Value:

    TRUE if the string matches the pattern

--*/

BOOL
ObsParsedPatternMatchA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR EncodedObject
    )
{
    PSTR decodedNode;
    PSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExA (EncodedObject, &decodedNode, &decodedLeaf, NULL, TRUE)) {
        return FALSE;
    }

    b = ObsParsedPatternMatchExA (ParsedPattern, decodedNode, decodedLeaf);

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}

BOOL
ObsParsedPatternMatchW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR EncodedObject
    )
{
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExW (EncodedObject, &decodedNode, &decodedLeaf, NULL, TRUE)) {
        return FALSE;
    }

    b = ObsParsedPatternMatchExW (ParsedPattern, decodedNode, decodedLeaf);

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}


/*++

Routine Description:

    ObsParsedPatternMatchEx tests the given object, given by its components,
    against a parsed pattern

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    Node - Specifies the node part of the object string to test against the pattern
    Leaf - Specifies the leaf part of the object string to test against the pattern

Return Value:

    TRUE if the string components match the pattern

--*/

BOOL
ObsParsedPatternMatchExA (
    IN      POBSPARSEDPATTERNA ParsedPattern,
    IN      PCSTR Node,
    IN      PCSTR Leaf                          OPTIONAL
    )
{
    MYASSERT (Node && ParsedPattern->NodePattern);
    if (!(Node && ParsedPattern->NodePattern)) {
       return FALSE;
    }

    if (((ParsedPattern->Flags & OBSPF_NOLEAF) && Leaf) ||
        ((ParsedPattern->Flags & OBSPF_EXACTLEAF) && !Leaf)
        ) {
        return FALSE;
    }

    if (!TestParsedPatternA (ParsedPattern->NodePattern, Node)) {
        return FALSE;
    }

    return !Leaf || TestParsedPatternA (ParsedPattern->LeafPattern, Leaf);
}

BOOL
ObsParsedPatternMatchExW (
    IN      POBSPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR Node,                        OPTIONAL
    IN      PCWSTR Leaf                         OPTIONAL
    )
{
    MYASSERT (Node && ParsedPattern->NodePattern);
    if (!(Node && ParsedPattern->NodePattern)) {
       return FALSE;
    }

    if (((ParsedPattern->Flags & OBSPF_NOLEAF) && Leaf) ||
        ((ParsedPattern->Flags & OBSPF_EXACTLEAF) && !Leaf)
        ) {
        return FALSE;
    }

    if (!TestParsedPatternW (ParsedPattern->NodePattern, Node)) {
        return FALSE;
    }

    return !Leaf || TestParsedPatternW (ParsedPattern->LeafPattern, Leaf);
}


/*++

Routine Description:

    ObsPatternMatch tests an object string against a pattern object string

Arguments:

    ParsedPattern - Specifies the parsed pattern structure
    Node - Specifies the node part of the object string to test against the pattern
    Leaf - Specifies the leaf part of the object string to test against the pattern

Return Value:

    TRUE if the string components match the pattern

--*/

BOOL
ObsPatternMatchA (
    IN      PCSTR ObjectPattern,
    IN      PCSTR ObjectStr
    )
{
    PSTR opNode;
    PSTR opLeaf;
    PSTR osNode;
    PSTR osLeaf;
    CHAR dummy[] = "";
    BOOL b = FALSE;

    if (ObsSplitObjectStringExA (ObjectPattern, &opNode, &opLeaf, NULL, FALSE)) {
        if (ObsSplitObjectStringExA (ObjectStr, &osNode, &osLeaf, NULL, TRUE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternMatchExABA (opNode, osNode, GetEndOfStringA (osNode));
                } else {
                    b = IsPatternMatchExABA (opNode, dummy, GetEndOfStringA (dummy));
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternMatchExABA (opLeaf, osLeaf, GetEndOfStringA (osLeaf));
                    } else {
                        b = IsPatternMatchExABA (opLeaf, dummy, GetEndOfStringA (dummy));
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsPatternMatchA: bad ObjectStr: %s", ObjectStr));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsPatternMatchA: bad ObjectPattern: %s", ObjectPattern));

    return b;
}

BOOL
ObsPatternMatchW (
    IN      PCWSTR ObjectPattern,
    IN      PCWSTR ObjectStr
    )
{
    PWSTR opNode;
    PWSTR opLeaf;
    PWSTR osNode;
    PWSTR osLeaf;
    WCHAR dummy[] = L"";
    BOOL b = FALSE;

    if (ObsSplitObjectStringExW (ObjectPattern, &opNode, &opLeaf, NULL, FALSE)) {
        if (ObsSplitObjectStringExW (ObjectStr, &osNode, &osLeaf, NULL, TRUE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternMatchExABW (opNode, osNode, GetEndOfStringW (osNode));
                } else {
                    b = IsPatternMatchExABW (opNode, dummy, GetEndOfStringW (dummy));
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternMatchExABW (opLeaf, osLeaf, GetEndOfStringW (osLeaf));
                    } else {
                        b = IsPatternMatchExABW (opLeaf, dummy, GetEndOfStringW (dummy));
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsPatternMatchW: bad ObjectStr: %s", ObjectStr));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsPatternMatchW: bad ObjectPattern: %s", ObjectPattern));

    return b;
}

/*++

Routine Description:

    ObsIsPatternContained compares two patterns to see if one of them is
    included in the other. Both patterns may contain any of the following
    expressions:

Arguments:

    Container - Specifies the container pattern
    Contained - Specifies the contained pattern

Return Value:

    TRUE if Contained is contained in Container

--*/

BOOL
ObsIsPatternContainedA (
    IN      PCSTR Container,
    IN      PCSTR Contained
    )
{
    PSTR opNode;
    PSTR opLeaf;
    PSTR osNode;
    PSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExA (Container, &opNode, &opLeaf, NULL, FALSE)) {

        if (ObsSplitObjectStringExA (Contained, &osNode, &osLeaf, NULL, FALSE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternContainedExA (opNode, osNode);
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternContainedExA (opLeaf, osLeaf);
                    } else {
                        b = TRUE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsIsPatternContainedA: bad Contained string: %s", Contained));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGA ((DBG_OBJSTR, "ObsIsPatternContainedA: bad Container string: %s", Container));

    return b;
}

BOOL
ObsIsPatternContainedW (
    IN      PCWSTR Container,
    IN      PCWSTR Contained
    )
{
    PWSTR opNode;
    PWSTR opLeaf;
    PWSTR osNode;
    PWSTR osLeaf;
    BOOL b = FALSE;

    if (ObsSplitObjectStringExW (Container, &opNode, &opLeaf, NULL, FALSE)) {

        if (ObsSplitObjectStringExW (Contained, &osNode, &osLeaf, NULL, FALSE)) {

            if (opNode) {
                if (osNode) {
                    b = IsPatternContainedExW (opNode, osNode);
                } else {
                    b = FALSE;
                }
            } else {
                if (osNode) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }
            }

            if (b) {
                if (opLeaf) {
                    if (osLeaf) {
                        b = IsPatternContainedExW (opLeaf, osLeaf);
                    } else {
                        b = TRUE;
                    }
                } else {
                    if (osLeaf) {
                        b = FALSE;
                    } else {
                        b = TRUE;
                    }
                }
            }

            pObjStrFreeMemory (osNode);
            pObjStrFreeMemory (osLeaf);
        }
        ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsIsPatternContainedW: bad Contained string: %s", Contained));

        pObjStrFreeMemory (opNode);
        pObjStrFreeMemory (opLeaf);
    }
    ELSE_DEBUGMSGW ((DBG_OBJSTR, "ObsIsPatternContainedW: bad Container string: %s", Container));

    return b;
}


/*++

Routine Description:

    ObsGetPatternLevels gets the minimum and maximum levels of a string that would
    match the given pattern.

Arguments:

    ObjectPattern - Specifies the pattern
    MinLevel - Receives the minimum possible level; the root has level 1
    MaxLevel - Receives the maximum possible level; the root has level 1

Return Value:

    TRUE if the pattern was correct and computing was done; FALSE otherwise

--*/

BOOL
ObsGetPatternLevelsA (
    IN      PCSTR ObjectPattern,
    OUT     PDWORD MinLevel,        OPTIONAL
    OUT     PDWORD MaxLevel         OPTIONAL
    )
{
    PSTR decodedNode;
    PSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExA (ObjectPattern, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    if (decodedNode) {
        b = GetNodePatternMinMaxLevelsA (decodedNode, decodedNode, MinLevel, MaxLevel);
    } else {
        b = FALSE;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}

BOOL
ObsGetPatternLevelsW (
    IN      PCWSTR ObjectPattern,
    OUT     PDWORD MinLevel,
    OUT     PDWORD MaxLevel
    )
{
    PWSTR decodedNode;
    PWSTR decodedLeaf;
    BOOL b;

    if (!ObsSplitObjectStringExW (ObjectPattern, &decodedNode, &decodedLeaf, NULL, FALSE)) {
        return FALSE;
    }

    if (decodedNode) {
        b = GetNodePatternMinMaxLevelsW (decodedNode, decodedNode, MinLevel, MaxLevel);
    } else {
        b = FALSE;
    }

    pObjStrFreeMemory (decodedNode);
    pObjStrFreeMemory (decodedLeaf);

    return b;
}


/*++

Routine Description:

    ObsPatternIncludesPattern decides if a given pattern includes another pattern,
    meaning that any string that would match the second will match the first.

Arguments:

    IncludingPattern - Specifies the first parsed pattern
    IncludedPattern - Specifies the second parsed pattern

Return Value:

    TRUE if the first pattern includes the second

--*/

BOOL
ObsPatternIncludesPatternA (
    IN      POBSPARSEDPATTERNA IncludingPattern,
    IN      POBSPARSEDPATTERNA IncludedPattern
    )
{
    MYASSERT (IncludingPattern->NodePattern && IncludedPattern->NodePattern);
    if (!(IncludingPattern->NodePattern && IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->MinNodeLevel > IncludedPattern->MinNodeLevel ||
        IncludingPattern->MaxNodeLevel < IncludedPattern->MaxNodeLevel
        ) {
        return FALSE;
    }

    if (!PatternIncludesPatternA (IncludingPattern->NodePattern, IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->LeafPattern) {
        if (!IncludedPattern->LeafPattern) {
            return FALSE;
        }
        if (!PatternIncludesPatternA (IncludingPattern->LeafPattern, IncludedPattern->LeafPattern)) {
            return FALSE;
        }
    } else {
        if (IncludedPattern->LeafPattern) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
ObsPatternIncludesPatternW (
    IN      POBSPARSEDPATTERNW IncludingPattern,
    IN      POBSPARSEDPATTERNW IncludedPattern
    )
{
    MYASSERT (IncludingPattern->NodePattern && IncludedPattern->NodePattern);
    if (!(IncludingPattern->NodePattern && IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->MinNodeLevel > IncludedPattern->MinNodeLevel ||
        IncludingPattern->MaxNodeLevel < IncludedPattern->MaxNodeLevel
        ) {
        return FALSE;
    }

    if (!PatternIncludesPatternW (IncludingPattern->NodePattern, IncludedPattern->NodePattern)) {
        return FALSE;
    }

    if (IncludingPattern->LeafPattern) {
        if (!IncludedPattern->LeafPattern) {
            return FALSE;
        }
        if (!PatternIncludesPatternW (IncludingPattern->LeafPattern, IncludedPattern->LeafPattern)) {
            return FALSE;
        }
    } else {
        if (IncludedPattern->LeafPattern) {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\unicode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    unicode.c

Abstract:

    Simplified Unicode-Ansi conversion functions.

    Externally exposed routines:
      In-Place Conversion:
        KnownSizeDbcsToUnicodeN
        KnownSizeUnicodeToDbcsN
        KnownSizeWtoA
        KnownSizeAtoW

      In-Place Conversion without nul checks:
        DirectDbcsToUnicodeN
        DirectUnicodeToDbcsN
        DirectAtoW
        DirectWtoA

      Length/pool options:
        DbcsToUnicodeN
        UnicodeToDbcsN
        DbcsToUnicode
        UnicodeToDbcs
        FreeConvertedPoolStr

      Simplified type conversions:
        ConvertWtoA
        ConvertAtoW
        FreeConvertedStr

      TCHAR routines that can be compiled both ways:
        CreateDbcs
        CreateUnicode
        DestroyDbcs
        DestroyUnicode

Author:

    Jim Schmidt (jimschm)   04-Aug-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.

    jimschm     15-Feb-1999 Eliminated MikeCo's routines, since they are
                            broken on FE
    jimschm     23-Sep-1998 Added in-place routines

--*/

#include "pch.h"
#include <locale.h>
#include "utilsp.h"

extern PMHANDLE g_TextPool;
extern DWORD g_MigutilWCToMBFlags;

WORD g_GlobalCodePage = CP_ACP;

typedef VOID(WINAPI SETACP)(WORD CodePage);
typedef SETACP * PSETACP;

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    )
{
    PSETACP SetACP;
    HANDLE Lib;

    g_GlobalCodePage = CodePage;


    if (ISNT()) {
        Lib = LoadLibrary (TEXT("kernel32.dll"));
        if (Lib) {
            SetACP = (PSETACP) GetProcAddress (Lib, "SetCPGlobal");
            if (SetACP) {
                SetACP (CodePage);
            }

            FreeLibrary (Lib);
        }
    }

    SetThreadLocale (Locale);
    setlocale(LC_ALL,"");
    InitLeadByteTable ();
}

WORD
SetConversionCodePage (
    IN      WORD CodePage
    )
{
    WORD oldCodePage = g_GlobalCodePage;
    g_GlobalCodePage = CodePage;
    return oldCodePage;
}

VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    )
{
    if (CodePage) {
        if (g_GlobalCodePage == CP_ACP) {
            *CodePage = (WORD) GetACP();
        } else {
            *CodePage = g_GlobalCodePage;
        }
    }

    if (Locale) {
        *Locale = GetThreadLocale();
    }
}


PCSTR
RealUnicodeToDbcsN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS.

Arguments:

  Pool  - Specifies the pool where memory is allocated from.  If not specified,
          g_TextPool is used instead.

  StrIn - Specifies the inbound UNICODE string

  Chars - Specifies the number of characters, excluding the nul, to
          convert.

Return Value:

  A pointer to the ANSI string, or NULL if an error occurred.

--*/

{
    PSTR DbcsStr;
    DWORD Size;
    DWORD rc;

    if (!Pool) {
        Pool = g_TextPool;
    }

    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountW (StrIn);
    }

    Size = (Chars + 1) * 3; // maximum for UTF8 encoding

    DbcsStr = (PSTR) PmGetAlignedMemory (Pool, Size);
    if (!DbcsStr) {
        DEBUGMSG ((DBG_ERROR, "UnicodeToDbcsN could not allocate string"));
        return NULL;
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     (g_GlobalCodePage == CP_UTF8)?0:g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) Chars,           // wc input count
                     DbcsStr,
                     (INT) Size,
                     NULL,
                     NULL
                     );

    // Report error returns from WideCharToMultiByte
    if (!rc && Chars) {
        PushError();
        PmReleaseMemory (Pool, DbcsStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "UnicodeToDbcsN error caused memory to be released in pool; may cause harmless PoolMem warnings."
            ));

        return NULL;
    }

    if (g_GlobalCodePage == CP_UTF8) {
        DbcsStr [rc] = 0;
    } else {
        *CharCountToPointerA (DbcsStr, Chars) = 0;
    }

    return DbcsStr;
}


PCWSTR
RealDbcsToUnicodeN (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  Converts a DBCS string to UNICODE.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string to be converted

  Chars     - Specifies the number of multibyte characters, excluding the nul,
              to convert.  If -1, all of StrIn will be converted.

Return Value:

  A pointer to the converted UNICODE string, or NULL if an error ocurred.

--*/

{
    PWSTR UnicodeStr;
    DWORD UnicodeStrBufLenBytes;
    DWORD WcharsConverted;
    DWORD StrInBytesToConvert;

    //
    // Find number of multi-byte characters to convert. Punt on case where
    // caller asks for more chars than available.
    //
    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountA (StrIn);
    }

    //
    // Count bytes to convert from the input string (excludes delimiter)
    //
    StrInBytesToConvert = (DWORD)(CharCountToPointerA(StrIn, Chars) - StrIn);

    //
    // Get output buffer size, in bytes, including delimiter
    //
    UnicodeStrBufLenBytes = (Chars + 1) * sizeof (WCHAR);

    if (!Pool) {
        Pool = g_TextPool;
    }

    //
    // Get buffer
    //
    UnicodeStr = (PWSTR) PmGetAlignedMemory (Pool, UnicodeStrBufLenBytes);
    if (!UnicodeStr) {
        DEBUGMSG ((DBG_ERROR, "DbcsToUnicodeN could not allocate string"));
        return NULL;
    }

    //
    // Convert
    //
    WcharsConverted = (DWORD) MultiByteToWideChar (
                                 g_GlobalCodePage,
                                 0,
                                 StrIn,
                                 (INT) StrInBytesToConvert,
                                 UnicodeStr,
                                 (INT) UnicodeStrBufLenBytes
                                 );

    //
    // Check for conversion error (>0 chars in, 0 chars out)
    //
    if (0 == WcharsConverted && 0 != Chars) {
        PushError();
        PmReleaseMemory (Pool, UnicodeStr);
        PopError();

        DEBUGMSG ((
            DBG_WARNING,
            "DbcsToUnicodeN error caused memory to be released in pool; may cause harmless	 warnings."
            ));

        return NULL;
    }

    //
    // Write delimiter on the output string
    //
    UnicodeStr[WcharsConverted] = 0;

    return UnicodeStr;
}


VOID
FreeConvertedPoolStr (
    IN      PMHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    )

/*++

Routine Description:

  Frees the memory allocated by UnicodeToDbcsN or DbcsToUnicodeN.

Arguments:

  Pool      - Specifies pool to allocate UNICODE string from.  If not specified,
              g_TextPool is used.

  StrIn     - Specifies string that was returned by UnicodeToDebcsN or
              DbcsToUnicodeN.

Return Value:

  none

--*/

{
    if (!StrIn) {
        return;
    }

    if (!Pool) {
        Pool = g_TextPool;
    }

    PmReleaseMemory (Pool, (PVOID) StrIn);
}


PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  KnownSizeUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Chars  - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Chars) {
        Chars = CharCountW (StrIn);
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) Chars,               // wc input count
                     StrOut,
                     (INT) Chars * 2,
                     NULL,
                     NULL
                     );

    DEBUGMSG_IF ((
        !rc && Chars,
        DBG_WARNING,
        "KnownSizeUnicodeToDbcsN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Chars
    )

/*++

Routine Description:

  KnownSizeDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Chars  - Specifies the character count of StrIn (not the byte count), or
           INVALID_CHAR_COUNT for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;
    DWORD StrInBytesToConvert;

    if (INVALID_CHAR_COUNT == Chars) {
        StrInBytesToConvert = ByteCountA (StrIn);
    } else {
        StrInBytesToConvert = (DWORD)(CharCountToPointerA (StrIn, Chars) - StrIn);
    }

    rc = (DWORD) MultiByteToWideChar (
                     g_GlobalCodePage,
                     0, // MB_ERR_INVALID_CHARS,
                     StrIn,
                     (INT) StrInBytesToConvert,
                     StrOut,
                     (INT) StrInBytesToConvert * 2
                     );

    DEBUGMSG_IF ((
        !rc && Chars,
        DBG_WARNING,
        "KnownSizeDbcsToUnicodeN failed."
        ));

    StrOut[rc] = 0;

    return StrOut;
}


PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectUnicodeToDbcsN converts a UNICODE string to DBCS.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the
  string.

Arguments:

  StrOut - Receives the DBCS result.
  StrIn  - Specifies the UNICODE string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountW (StrIn);
    }

    rc = (DWORD) WideCharToMultiByte (
                     g_GlobalCodePage,
                     g_MigutilWCToMBFlags,
                     StrIn,
                     (INT) (Bytes / sizeof (WCHAR)),
                     StrOut,
                     (INT) Bytes,
                     NULL,
                     NULL
                     );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectUnicodeToDbcsN failed."
        ));

    return StrOut + rc;
}


PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    )

/*++

Routine Description:

  DirectDbcsToUnicodeN converts a DBCS string to UNICODE.  The caller
  manages the outbound buffer.  This function does not check for nuls
  in StrIn when Bytes is non-zero, and it does not terminate the string.

Arguments:

  StrOut - Receives the UNICODE result.
  StrIn  - Specifies the DBCS string to convert.
  Bytes  - Specifies the byte count of StrIn, or INVALID_CHAR_COUNT
           for the complete string.

Return Value:

  Returns StrOut.

--*/

{
    DWORD rc;

    if (INVALID_CHAR_COUNT == Bytes) {
        Bytes = ByteCountA (StrIn);
    }

    rc = (DWORD) MultiByteToWideChar (
                     g_GlobalCodePage,
                     0, // MB_ERR_INVALID_CHARS,
                     StrIn,
                     (INT) Bytes,
                     StrOut,
                     (INT) Bytes * 2
                     );

    DEBUGMSG_IF ((
        !rc && Bytes,
        DBG_WARNING,
        "DirectDbcsToUnicodeN failed."
        ));

    return StrOut + rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\strmap.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strmap.c

Abstract:

    Strmap (formally pathmap) is a fast hueristic-based program that
    searches strings and attempts to replace substrings when there
    are matching substrings in the mapping database.

Author:

    Marc R. Whitten (marcw) 20-Mar-1997

Revision History:

    Jim Schmidt (jimschm)   05-Jun-2000     Added multi table capability

    Jim Schmidt (jimschm)   08-May-2000     Improved replacement routines and
                                            added consistent filtering and
                                            extra data option

    Jim Schmidt (jimschm)   18-Aug-1998     Redesigned to fix two bugs, made
                                            A & W versions

--*/

//
// Includes
//

#include "pch.h"

//
// Strings
//

// None

//
// Constants
//

#define CHARNODE_SINGLE_BYTE            0x0000
#define CHARNODE_DOUBLE_BYTE            0x0001
#define CHARNODE_REQUIRE_WACK_OR_NUL    0x0002

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


PMAPSTRUCT
CreateStringMappingEx (
    IN      BOOL UsesFilters,
    IN      BOOL UsesExtraData
    )

/*++

Routine Description:

  CreateStringMapping allocates a string mapping data structure and
  initializes it. Callers can enable filter callbacks, extra data support, or
  both. The mapping structure contains either CHARNODE elements, or
  CHARNODEEX elements, depending on the UsesFilters or UsesExtraData flag.

Arguments:

  UsesFilters   - Specifies TRUE to enable filter callbacks. If enabled,
                  those who add string pairs must specify the filter callback
                  (each search/replace pair has its own callback)
  UsesExtraData - Specifies TRUE to associate extra data with the string
                  mapping pair.

Return Value:

  A handle to the string mapping structure, or NULL if a structure could not
  be created.

--*/

{
    PMHANDLE Pool;
    PMAPSTRUCT Map;

    Pool = PmCreateNamedPool ("String Mapping");
    MYASSERT (Pool);

    Map = (PMAPSTRUCT) PmGetAlignedMemory (Pool, sizeof (MAPSTRUCT));
    MYASSERT (Map);

    ZeroMemory (Map, sizeof (MAPSTRUCT));
    Map->Pool = Pool;

    Map->UsesExNode = UsesFilters|UsesExtraData;
    Map->UsesFilter = UsesFilters;
    Map->UsesExtraData = UsesExtraData;

    return Map;
}

VOID
DestroyStringMapping (
    IN      PMAPSTRUCT Map
    )
{
    if (Map) {
        PmEmptyPool (Map->Pool);
        PmDestroyPool (Map->Pool);
        // Map is no longer valid
    }
}

PCHARNODE
pFindCharNode (
    IN      PMAPSTRUCT Map,
    IN      PCHARNODE PrevNode,     OPTIONAL
    IN      WORD Char
    )
{
    PCHARNODE Node;

    if (!PrevNode) {
        Node = Map->FirstLevelRoot;
    } else {
        Node = PrevNode->NextLevel;
    }

    while (Node) {
        if (Node->Char == Char) {
            return Node;
        }
        Node = Node->NextPeer;
    }

    return NULL;
}

PCHARNODE
pAddCharNode (
    IN      PMAPSTRUCT Map,
    IN      PCHARNODE PrevNode,     OPTIONAL
    IN      WORD Char,
    IN      WORD Flags
    )
{
    PCHARNODE Node;
    PCHARNODEEX exNode;

    if (Map->UsesExNode) {
        exNode = PmGetAlignedMemory (Map->Pool, sizeof (CHARNODEEX));
        Node = (PCHARNODE) exNode;
        MYASSERT (Node);
        ZeroMemory (exNode, sizeof (CHARNODEEX));
    } else {
        Node = PmGetAlignedMemory (Map->Pool, sizeof (CHARNODE));
        MYASSERT (Node);
        ZeroMemory (Node, sizeof (CHARNODE));
    }

    Node->Char = Char;
    Node->Flags = Flags;

    if (PrevNode) {
        Node->NextPeer = PrevNode->NextLevel;
        PrevNode->NextLevel = Node;
    } else {
        Node->NextPeer = Map->FirstLevelRoot;
        Map->FirstLevelRoot = Node;
    }

    return Node;
}


VOID
AddStringMappingPairExA (
    IN OUT  PMAPSTRUCT Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    )

/*++

Routine Description:

  AddStringMappingPairEx adds a search and replace string pair to the linked
  list data structures. If the same search string is already in the
  structures, then the replace string and optional extra data is updated.

Arguments:

  Map       - Specifies the string mapping
  Old       - Specifies the search string
  New       - Specifies the replace string
  Filter    - Specifies the callback filter. This is only supported if the
              map was created with filter support enabled.
  ExtraData - Specifies arbitrary data to assign to the search/replace pair.
              This is only valid if the map was created with extra data
              enabled.
  Flags     - Specifies optional flag STRMAP_REQUIRE_WACK_OR_NUL

Return Value:

  None.

--*/

{
    PSTR OldCopy;
    PSTR NewCopy;
    PCSTR p;
    WORD w;
    PCHARNODE Prev;
    PCHARNODE Node;
    PCHARNODEEX exNode;
    WORD nodeFlags = 0;

    if (Flags & STRMAP_REQUIRE_WACK_OR_NUL) {
        nodeFlags = CHARNODE_REQUIRE_WACK_OR_NUL;
    }

    MYASSERT (Map);
    MYASSERT (Old);
    MYASSERT (New);
    MYASSERT (*Old);

    //
    // Duplicate strings
    //

    OldCopy = PmDuplicateStringA (Map->Pool, Old);
    NewCopy = PmDuplicateStringA (Map->Pool, New);

    //
    // Make OldCopy all lowercase
    //

    CharLowerA (OldCopy);

    //
    // Add the letters that are not in the mapping
    //

    for (Prev = NULL, p = OldCopy ; *p ; p = _mbsinc (p)) {
        w = (WORD) _mbsnextc (p);
        Node = pFindCharNode (Map, Prev, w);
        if (!Node) {
            break;
        }
        Prev = Node;
    }

    for ( ; *p ; p = _mbsinc (p)) {
        w = (WORD) _mbsnextc (p);

        nodeFlags |= (WORD) (IsLeadByte (p) ? CHARNODE_DOUBLE_BYTE : CHARNODE_SINGLE_BYTE);
        Prev = pAddCharNode (Map, Prev, w, nodeFlags);
    }

    if (Prev) {
        StringCopyA (OldCopy, Old);
        Prev->OriginalStr = (PVOID) OldCopy;
        Prev->ReplacementStr = (PVOID) NewCopy;
        Prev->ReplacementBytes = ByteCountA (NewCopy);

        exNode = (PCHARNODEEX) Prev;

        if (Map->UsesExtraData) {
            exNode->ExtraData = ExtraData;
        }

        if (Map->UsesFilter) {
            exNode->Filter = Filter;
        }
    }
}


VOID
AddStringMappingPairExW (
    IN OUT  PMAPSTRUCT Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    )

/*++

Routine Description:

  AddStringMappingPairEx adds a search and replace string pair to the linked
  list data structures. If the same search string is already in the
  structures, then the replace string and optional extra data is updated.

Arguments:

  Map       - Specifies the string mapping
  Old       - Specifies the search string
  New       - Specifies the replace string
  Filter    - Specifies the callback filter. This is only supported if the
              map was created with filter support enabled.
  ExtraData - Specifies arbitrary data to assign to the search/replace pair.
              This is only valid if the map was created with extra data
              enabled.
  Flags     - Specifies optional flag STRMAP_REQUIRE_WACK_OR_NUL

Return Value:

  None.

--*/

{
    PWSTR OldCopy;
    PWSTR NewCopy;
    PCWSTR p;
    WORD w;
    PCHARNODE Prev;
    PCHARNODE Node;
    PCHARNODEEX exNode;
    WORD nodeFlags = 0;

    if (Flags & STRMAP_REQUIRE_WACK_OR_NUL) {
        nodeFlags = CHARNODE_REQUIRE_WACK_OR_NUL;
    }

    MYASSERT (Map);
    MYASSERT (Old);
    MYASSERT (New);
    MYASSERT (*Old);

    //
    // Duplicate strings
    //

    OldCopy = PmDuplicateStringW (Map->Pool, Old);
    NewCopy = PmDuplicateStringW (Map->Pool, New);

    //
    // Make OldCopy all lowercase
    //

    CharLowerW (OldCopy);

    //
    // Add the letters that are not in the mapping
    //

    Prev = NULL;
    p = OldCopy;
    while (w = *p) {        // intentional assignment optimization

        Node = pFindCharNode (Map, Prev, w);
        if (!Node) {
            break;
        }
        Prev = Node;

        p++;
    }

    while (w = *p) {        // intentional assignment optimization

        Prev = pAddCharNode (Map, Prev, w, nodeFlags);
        p++;
    }

    if (Prev) {
        StringCopyW (OldCopy, Old);
        Prev->OriginalStr = OldCopy;
        Prev->ReplacementStr = (PVOID) NewCopy;
        Prev->ReplacementBytes = ByteCountW (NewCopy);

        exNode = (PCHARNODEEX) Prev;

        if (Map->UsesExtraData) {
            exNode->ExtraData = ExtraData;
        }

        if (Map->UsesFilter) {
            exNode->Filter = Filter;
        }
    }
}


PCSTR
pFindReplacementStringInOneMapA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    PCHARNODE BestMatch;
    PCHARNODE Node;
    WORD Char;
    PCSTR OrgSource;
    PCSTR SavedSource;
    PCSTR lastReplChar;
    PCSTR newString = NULL;
    INT newStringSizeInBytes = 0;
    PCHARNODEEX exNode;
    BOOL replacementFound;

    *SourceBytesPtr = 0;

    Node = NULL;
    BestMatch = NULL;

    OrgSource = Source;

    while (*Source) {

        Char = (WORD) _mbsnextc (Source);

        Node = pFindCharNode (Map, Node, Char);

        if (Node) {
            //
            // Advance string pointer
            //

            SavedSource = Source;
            if (Node->Flags & CHARNODE_DOUBLE_BYTE) {
                Source += 2;
            } else {
                Source++;
            }

            if (((PBYTE) Source - (PBYTE) OrgSource) > MaxSourceBytes) {
                break;
            }

            //
            // If replacement string is available, keep it
            // until a longer match comes along
            //

            replacementFound = (Node->ReplacementStr != NULL);

            if (replacementFound && (RequireWackOrNul || (Node->Flags & CHARNODE_REQUIRE_WACK_OR_NUL))) {

                // we are in the "require wack or null" land. We are pretty much
                // dealing with paths here
                if (*Source) {
                    if (_mbsnextc (Source) != '\\') {
                        // The character after the sub-string to replace is not a wack.
                        // Let's see, maybe the last character of the sub-string to
                        // replace was a wack (it's got to be the same character from
                        // SavedSource since they matched so far. Also, Char is the
                        // character that SavedSource is pointing to so we are using that.
                        if (Char != '\\') {
                            replacementFound = FALSE;
                        } else {
                            // If we got here, it means we have some sort of replacement
                            // where the sub-string to replace ends in a wack. The problem
                            // now is that the replacement string might not end up in a wack.
                            // If it doesn't we might break some path.
                            // Let's check to see if the last character from the replacement
                            // string has a wack. If it doesn't we are going to move back
                            // Source to where SavedSource points (esentially moving back
                            // a wack)
                            lastReplChar = _mbsdec2 (
                                                (PCSTR)Node->ReplacementStr,
                                                (PCSTR)((PBYTE)Node->ReplacementStr + Node->ReplacementBytes)
                                                );
                            if (lastReplChar && (_mbsnextc (lastReplChar) != '\\')) {
                                Source = SavedSource;
                            }
                        }
                    } else {
                        // The character after the sub-string to replace is a wack.
                        // Let's check for a possible problem here. If the sub-string
                        // to replace does not end with a wack and the replacement
                        // sub-string DOES end in a wack we are going to generate
                        // a string that has double wack.
                        lastReplChar = _mbsdec2 (
                                            (PCSTR)Node->ReplacementStr,
                                            (PCSTR)((PBYTE)Node->ReplacementStr + Node->ReplacementBytes)
                                            );
                        if (lastReplChar && (_mbsnextc (lastReplChar) == '\\')) {
                            Source = _mbsinc (Source);
                        }
                    }
                }
            }

            if (replacementFound) {

                newString = (PCSTR) Node->ReplacementStr;
                newStringSizeInBytes = Node->ReplacementBytes;

                if (Map->UsesFilter) {
                    //
                    // Call rename filter to allow denial of match
                    //

                    exNode = (PCHARNODEEX) Node;

                    if (exNode->Filter) {
                        Data->Ansi.BeginningOfMatch = OrgSource;
                        Data->Ansi.OldSubString = (PCSTR) Node->OriginalStr;
                        Data->Ansi.NewSubString = newString;
                        Data->Ansi.NewSubStringSizeInBytes = newStringSizeInBytes;

                        if (!exNode->Filter (Data)) {
                            replacementFound = FALSE;
                        } else {
                            newString = Data->Ansi.NewSubString;
                            newStringSizeInBytes = Data->Ansi.NewSubStringSizeInBytes;
                        }
                    }
                }

                if (replacementFound) {
                    BestMatch = Node;
                    *SourceBytesPtr = (HALF_PTR) ((PBYTE) Source - (PBYTE) OrgSource);
                }
            }

        } else {
            //
            // No Node ends the search
            //

            break;
        }

    }

    if (BestMatch) {
        //
        // Return replacement data to caller
        //

        if (ExtraDataValue) {

            if (Map->UsesExtraData) {
                exNode = (PCHARNODEEX) BestMatch;
                *ExtraDataValue = exNode->ExtraData;
            } else {
                *ExtraDataValue = 0;
            }
        }

        *ReplacementBytesPtr = newStringSizeInBytes;
        return newString;
    }

    return NULL;
}


PCSTR
pFindReplacementStringA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    UINT u;
    PCSTR result;

    for (u = 0 ; u < MapArrayCount ; u++) {

        if (!MapArray[u]) {
            continue;
        }

        result = pFindReplacementStringInOneMapA (
                        MapArray[u],
                        Source,
                        MaxSourceBytes,
                        SourceBytesPtr,
                        ReplacementBytesPtr,
                        Data,
                        ExtraDataValue,
                        RequireWackOrNul
                        );

        if (result) {
            return result;
        }
    }

    return NULL;
}


PCWSTR
pFindReplacementStringInOneMapW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    PCHARNODE BestMatch;
    PCHARNODE Node;
    PCWSTR OrgSource;
    PCWSTR SavedSource;
    PCWSTR lastReplChar;
    PCWSTR newString = NULL;
    INT newStringSizeInBytes;
    BOOL replacementFound;
    PCHARNODEEX exNode;

    *SourceBytesPtr = 0;

    Node = NULL;
    BestMatch = NULL;

    OrgSource = Source;

    while (*Source) {

        Node = pFindCharNode (Map, Node, *Source);

        if (Node) {
            //
            // Advance string pointer
            //

            SavedSource = Source;
            Source++;

            if (((PBYTE) Source - (PBYTE) OrgSource) > MaxSourceBytes) {
                break;
            }

            //
            // If replacement string is available, keep it
            // until a longer match comes along
            //

            replacementFound = (Node->ReplacementStr != NULL);

            if (replacementFound && (RequireWackOrNul || (Node->Flags & CHARNODE_REQUIRE_WACK_OR_NUL))) {

                // we are in the "require wack or null" land. We are pretty much
                // dealing with paths here
                if (*Source) {
                    if (*Source != L'\\') {
                        // The character after the sub-string to replace is not a wack.
                        // Let's see, maybe the last character of the sub-string to
                        // replace was a wack (it's got to be the same character from
                        // SavedSource since they matched so far.
                        if (*SavedSource != L'\\') {
                            replacementFound = FALSE;
                        } else {
                            // If we got here, it means we have some sort of replacement
                            // where the sub-string to replace ends in a wack. The problem
                            // now is that the replacement string might not end up in a wack.
                            // If it doesn't we might break some path.
                            // Let's check to see if the last character from the replacement
                            // string has a wack. If it doesn't we are going to move back
                            // Source to where SavedSource points (esentially moving back
                            // a wack)
                            lastReplChar = _wcsdec2 (
                                                (PCWSTR)Node->ReplacementStr,
                                                (PCWSTR)((PBYTE)Node->ReplacementStr + Node->ReplacementBytes)
                                                );
                            if (lastReplChar && (*lastReplChar != L'\\')) {
                                Source = SavedSource;
                            }
                        }
                    } else {
                        // The character after the sub-string to replace is a wack.
                        // Let's check for a possible problem here. If the sub-string
                        // to replace does not end with a wack and the replacement
                        // sub-string DOES end in a wack we are going to generate
                        // a string that has double wack.
                        lastReplChar = _wcsdec2 (
                                            (PCWSTR)Node->ReplacementStr,
                                            (PCWSTR)((PBYTE)Node->ReplacementStr + Node->ReplacementBytes)
                                            );
                        if (lastReplChar && (*lastReplChar == L'\\')) {
                            Source ++;
                        }
                    }
                }
            }

            if (replacementFound) {

                newString = (PCWSTR) Node->ReplacementStr;
                newStringSizeInBytes = Node->ReplacementBytes;

                if (Map->UsesFilter) {
                    //
                    // Call rename filter to allow denial of match
                    //

                    exNode = (PCHARNODEEX) Node;

                    if (exNode->Filter) {
                        Data->Unicode.BeginningOfMatch = OrgSource;
                        Data->Unicode.OldSubString = (PCWSTR) Node->OriginalStr;
                        Data->Unicode.NewSubString = newString;
                        Data->Unicode.NewSubStringSizeInBytes = newStringSizeInBytes;

                        if (!exNode->Filter (Data)) {
                            replacementFound = FALSE;
                        } else {
                            newString = Data->Unicode.NewSubString;
                            newStringSizeInBytes = Data->Unicode.NewSubStringSizeInBytes;
                        }
                    }
                }

                if (replacementFound) {
                    BestMatch = Node;
                    *SourceBytesPtr = (HALF_PTR) ((PBYTE) Source - (PBYTE) OrgSource);
                }
            }

        } else {
            //
            // No Node ends the search
            //

            break;
        }

    }

    if (BestMatch) {

        //
        // Return replacement data to caller
        //

        if (ExtraDataValue) {

            if (Map->UsesExtraData) {
                exNode = (PCHARNODEEX) BestMatch;
                *ExtraDataValue = exNode->ExtraData;
            } else {
                *ExtraDataValue = 0;
            }
        }

        *ReplacementBytesPtr = newStringSizeInBytes;
        return newString;
    }

    return NULL;
}


PCWSTR
pFindReplacementStringW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PREG_REPLACE_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    UINT u;
    PCWSTR result;

    for (u = 0 ; u < MapArrayCount ; u++) {

        if (!MapArray[u]) {
            continue;
        }

        result = pFindReplacementStringInOneMapW (
                        MapArray[u],
                        Source,
                        MaxSourceBytes,
                        SourceBytesPtr,
                        ReplacementBytesPtr,
                        Data,
                        ExtraDataValue,
                        RequireWackOrNul
                        );

        if (result) {
            return result;
        }
    }

    return NULL;
}


BOOL
MappingMultiTableSearchAndReplaceExA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    )

/*++

Routine Description:

  MappingSearchAndReplaceEx performs a search/replace operation based on the
  specified string mapping. The replace can be in-place or to another buffer.

Arguments:

  MapArray          - Specifies an array of string mapping tables that holds
                      zero or more search/replace pairs
  MapArrayCount     - Specifies the number of mapping tables in MapArray
  SrcBuffer         - Specifies the source string that might contain one or
                      more search strings
  Buffer            - Specifies the outbound buffer. This arg can be the same
                      as SrcBuffer.
  InboundBytes      - Specifies the number of bytes in SrcBuffer to process,
                      or 0 to process a nul-terminated string in SrcBuffer.
                      If InboundBytes is specified, it must point to the nul
                      terminator of SrcBuffer.
  OutbountBytesPtr  - Receives the number of bytes that Buffer contains,
                      excluding the nul terminator.
  MaxSizeInBytes    - Specifies the size of Buffer, in bytes.
  Flags             - Specifies flags that control the search/replace:
                            STRMAP_COMPLETE_MATCH_ONLY
                            STRMAP_FIRST_CHAR_MUST_MATCH
                            STRMAP_RETURN_AFTER_FIRST_REPLACE
                            STRMAP_REQUIRE_WACK_OR_NUL
  ExtraDataValue    - Receives the extra data associated with the first search/
                      replace pair.
  EndOfString       - Receives a pointer to the end of the replace string, or
                      the nul pointer when the entire string is processed. The
                      pointer is within the string contained in Buffer.

--*/

{
    UINT sizeOfTempBuf;
    INT inboundSize;
    PCSTR lowerCaseSrc;
    PCSTR orgSrc;
    PCSTR lowerSrcPos;
    PCSTR orgSrcPos;
    INT orgSrcBytesLeft;
    PSTR destPos;
    PCSTR lowerSrcEnd;
    INT searchStringBytes;
    INT replaceStringBytes;
    INT destBytesLeft;
    REG_REPLACE_DATA filterData;
    PCSTR replaceString;
    BOOL result = FALSE;
    INT i;
    PCSTR endPtr;

    //
    // Empty string case
    //

    if (*SrcBuffer == 0 || MaxSizeInBytes <= sizeof (CHAR)) {
        if (MaxSizeInBytes >= sizeof (CHAR)) {
            *Buffer = 0;
        }

        if (OutboundBytesPtr) {
            *OutboundBytesPtr = 0;
        }

        return FALSE;
    }

    //
    // If caller did not specify inbound size, compute it now
    //

    if (!InboundBytes) {
        InboundBytes = ByteCountA (SrcBuffer);
    } else {
        i = 0;
        while (i < InboundBytes) {
            if (IsLeadByte (&SrcBuffer[i])) {
                MYASSERT (SrcBuffer[i + 1]);
                i += 2;
            } else {
                i++;
            }
        }

        if (i > InboundBytes) {
            InboundBytes--;
        }
    }

    inboundSize = InboundBytes + sizeof (CHAR);

    //
    // Allocate a buffer big enough for the lower-cased input string,
    // plus (optionally) a copy of the entire destination buffer. Then
    // copy the data to the buffer.
    //

    sizeOfTempBuf = inboundSize;

    if (SrcBuffer == Buffer) {
        sizeOfTempBuf += MaxSizeInBytes;
    }

    lowerCaseSrc = AllocTextA (sizeOfTempBuf);

    CopyMemory ((PSTR) lowerCaseSrc, SrcBuffer, InboundBytes);
    *((PSTR) ((PBYTE) lowerCaseSrc + InboundBytes)) = 0;

    CharLowerBuffA ((PSTR) lowerCaseSrc, InboundBytes / sizeof (CHAR));

    if (SrcBuffer == Buffer && !(Flags & STRMAP_COMPLETE_MATCH_ONLY)) {
        orgSrc = (PCSTR) ((PBYTE) lowerCaseSrc + inboundSize);

        //
        // If we are processing entire inbound string, then just copy the
        // whole string.  Otherwise, copy the entire destination buffer, so we
        // don't lose data beyond the partial inbound string.
        //

        if (*((PCSTR) ((PBYTE) SrcBuffer + InboundBytes))) {
            CopyMemory ((PSTR) orgSrc, SrcBuffer, MaxSizeInBytes);
        } else {
            CopyMemory ((PSTR) orgSrc, SrcBuffer, inboundSize);
        }

    } else {
        orgSrc = SrcBuffer;
    }

    //
    // Walk the lower cased string, looking for strings to replace
    //

    orgSrcPos = orgSrc;

    lowerSrcPos = lowerCaseSrc;
    lowerSrcEnd = (PCSTR) ((PBYTE) lowerSrcPos + InboundBytes);

    destPos = Buffer;
    destBytesLeft = MaxSizeInBytes - sizeof (CHAR);

    filterData.UnicodeData = FALSE;
    filterData.Ansi.OriginalString = orgSrc;
    filterData.Ansi.CurrentString = Buffer;

    endPtr = NULL;

    while (lowerSrcPos < lowerSrcEnd) {

        replaceString = pFindReplacementStringA (
                            MapArray,
                            MapArrayCount,
                            lowerSrcPos,
                            (HALF_PTR) ((PBYTE) lowerSrcEnd - (PBYTE) lowerSrcPos),
                            &searchStringBytes,
                            &replaceStringBytes,
                            &filterData,
                            ExtraDataValue,
                            (Flags & STRMAP_REQUIRE_WACK_OR_NUL) != 0
                            );

        if (replaceString) {

            //
            // Implement complete match flag
            //

            if (Flags & STRMAP_COMPLETE_MATCH_ONLY) {
                if (InboundBytes != searchStringBytes) {
                    break;
                }
            }

            result = TRUE;

            //
            // Verify replacement string isn't growing string too much. If it
            // is, truncate the replacement string.
            //

            if (destBytesLeft < replaceStringBytes) {

                //
                // Respect logical dbcs characters
                //

                replaceStringBytes = 0;
                i = 0;

                while (i < destBytesLeft) {
                    MYASSERT (replaceString[i]);

                    if (IsLeadByte (&replaceString[i])) {
                        MYASSERT (replaceString[i + 1]);
                        i += 2;
                    } else {
                        i++;
                    }
                }

                if (i > destBytesLeft) {
                    destBytesLeft--;
                }

                replaceStringBytes = destBytesLeft;

            } else {
                destBytesLeft -= replaceStringBytes;
            }

            //
            // Transfer the memory
            //

            CopyMemory (destPos, replaceString, replaceStringBytes);

            destPos = (PSTR) ((PBYTE) destPos + replaceStringBytes);

            if (searchStringBytes) {
                lowerSrcPos = (PCSTR) ((PBYTE) lowerSrcPos + searchStringBytes);
                orgSrcPos = (PCSTR) ((PBYTE) orgSrcPos + searchStringBytes);
            } else {
                //
                // Copy single-byte character
                //

                if (destBytesLeft < sizeof (CHAR)) {
                    break;
                }

                *destPos++ = *orgSrcPos++;
                destBytesLeft -= sizeof (CHAR);
                lowerSrcPos++;
            }

            //
            // Implement single match flag
            //

            if (Flags & STRMAP_RETURN_AFTER_FIRST_REPLACE) {
                endPtr = destPos;
                break;
            }

        } else if (Flags & (STRMAP_FIRST_CHAR_MUST_MATCH|STRMAP_COMPLETE_MATCH_ONLY)) {
            //
            // This string does not match any search strings
            //

            break;

        } else {
            //
            // This character does not match, so copy it to the destination and
            // try the next string.
            //

            if (IsLeadByte (orgSrcPos)) {

                //
                // Copy double-byte character
                //

                if (destBytesLeft < sizeof (CHAR) * 2) {
                    break;
                }

                MYASSERT (sizeof (CHAR) * 2 == sizeof (WORD));

                *((PWORD) destPos)++ = *((PWORD) orgSrcPos)++;
                destBytesLeft -= sizeof (WORD);
                lowerSrcPos = (PCSTR) ((PBYTE) lowerSrcPos + sizeof (WORD));

            } else {

                //
                // Copy single-byte character
                //

                if (destBytesLeft < sizeof (CHAR)) {
                    break;
                }

                *destPos++ = *orgSrcPos++;
                destBytesLeft -= sizeof (CHAR);
                lowerSrcPos++;
            }
        }
    }

    //
    // Copy any remaining part of the original source to the
    // destination, unless destPos == Buffer == SrcBuffer
    //

    if (destPos != SrcBuffer) {

        if (*orgSrcPos) {
            orgSrcBytesLeft = ByteCountA (orgSrcPos);
            orgSrcBytesLeft = min (orgSrcBytesLeft, destBytesLeft);

            CopyMemory (destPos, orgSrcPos, orgSrcBytesLeft);
            destPos = (PSTR) ((PBYTE) destPos + orgSrcBytesLeft);
        }

        MYASSERT ((PBYTE) (destPos + 1) <= ((PBYTE) Buffer + MaxSizeInBytes));
        *destPos = 0;

        if (!endPtr) {
            endPtr = destPos;
        }

    } else {

        MYASSERT (SrcBuffer == Buffer);
        if (EndOfString || OutboundBytesPtr) {
            endPtr = GetEndOfStringA (destPos);
        }
    }

    if (EndOfString) {
        MYASSERT (endPtr);
        *EndOfString = endPtr;
    }

    if (OutboundBytesPtr) {
        MYASSERT (endPtr);
        if (*endPtr) {
            endPtr = GetEndOfStringA (endPtr);
        }

        *OutboundBytesPtr = (HALF_PTR) ((PBYTE) endPtr - (PBYTE) Buffer);
    }

    FreeTextA (lowerCaseSrc);

    return result;
}


BOOL
MappingMultiTableSearchAndReplaceExW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    )
{
    UINT sizeOfTempBuf;
    INT inboundSize;
    PCWSTR lowerCaseSrc;
    PCWSTR orgSrc;
    PCWSTR lowerSrcPos;
    PCWSTR orgSrcPos;
    INT orgSrcBytesLeft;
    PWSTR destPos;
    PCWSTR lowerSrcEnd;
    INT searchStringBytes;
    INT replaceStringBytes;
    INT destBytesLeft;
    REG_REPLACE_DATA filterData;
    PCWSTR replaceString;
    BOOL result = FALSE;
    PCWSTR endPtr;

    //
    // Empty string case
    //

    if (*SrcBuffer == 0 || MaxSizeInBytes <= sizeof (CHAR)) {
        if (MaxSizeInBytes >= sizeof (CHAR)) {
            *Buffer = 0;
        }

        if (OutboundBytesPtr) {
            *OutboundBytesPtr = 0;
        }

        return FALSE;
    }

    //
    // If caller did not specify inbound size, compute it now
    //

    if (!InboundBytes) {
        InboundBytes = ByteCountW (SrcBuffer);
    } else {
        InboundBytes = (InboundBytes / sizeof (WCHAR)) * sizeof (WCHAR);
    }


    inboundSize = InboundBytes + sizeof (WCHAR);

    //
    // Allocate a buffer big enough for the lower-cased input string,
    // plus (optionally) a copy of the entire destination buffer. Then
    // copy the data to the buffer.
    //

    sizeOfTempBuf = inboundSize;

    if (SrcBuffer == Buffer) {
        sizeOfTempBuf += MaxSizeInBytes;
    }

    lowerCaseSrc = AllocTextW (sizeOfTempBuf);

    CopyMemory ((PWSTR) lowerCaseSrc, SrcBuffer, InboundBytes);
    *((PWSTR) ((PBYTE) lowerCaseSrc + InboundBytes)) = 0;

    CharLowerBuffW ((PWSTR) lowerCaseSrc, InboundBytes / sizeof (WCHAR));

    if (SrcBuffer == Buffer && !(Flags & STRMAP_COMPLETE_MATCH_ONLY)) {
        orgSrc = (PCWSTR) ((PBYTE) lowerCaseSrc + inboundSize);

        //
        // If we are processing entire inbound string, then just copy the
        // whole string.  Otherwise, copy the entire destination buffer, so we
        // don't lose data beyond the partial inbound string.
        //

        if (*((PCWSTR) ((PBYTE) SrcBuffer + InboundBytes))) {
            CopyMemory ((PWSTR) orgSrc, SrcBuffer, MaxSizeInBytes);
        } else {
            CopyMemory ((PWSTR) orgSrc, SrcBuffer, inboundSize);
        }

    } else {
        orgSrc = SrcBuffer;
    }

    //
    // Walk the lower cased string, looking for strings to replace
    //

    orgSrcPos = orgSrc;

    lowerSrcPos = lowerCaseSrc;
    lowerSrcEnd = (PCWSTR) ((PBYTE) lowerSrcPos + InboundBytes);

    destPos = Buffer;
    destBytesLeft = MaxSizeInBytes - sizeof (WCHAR);

    filterData.UnicodeData = TRUE;
    filterData.Unicode.OriginalString = orgSrc;
    filterData.Unicode.CurrentString = Buffer;

    endPtr = NULL;

    while (lowerSrcPos < lowerSrcEnd) {

        replaceString = pFindReplacementStringW (
                            MapArray,
                            MapArrayCount,
                            lowerSrcPos,
                            (HALF_PTR) ((PBYTE) lowerSrcEnd - (PBYTE) lowerSrcPos),
                            &searchStringBytes,
                            &replaceStringBytes,
                            &filterData,
                            ExtraDataValue,
                            (Flags & STRMAP_REQUIRE_WACK_OR_NUL) != 0
                            );

        if (replaceString) {

            //
            // Implement complete match flag
            //

            if (Flags & STRMAP_COMPLETE_MATCH_ONLY) {
                if (InboundBytes != searchStringBytes) {
                    break;
                }
            }

            result = TRUE;

            //
            // Verify replacement string isn't growing string too much. If it
            // is, truncate the replacement string.
            //

            if (destBytesLeft < replaceStringBytes) {
                replaceStringBytes = destBytesLeft;
            } else {
                destBytesLeft -= replaceStringBytes;
            }

            //
            // Transfer the memory
            //

            CopyMemory (destPos, replaceString, replaceStringBytes);

            destPos = (PWSTR) ((PBYTE) destPos + replaceStringBytes);

            if (searchStringBytes) {
                lowerSrcPos = (PCWSTR) ((PBYTE) lowerSrcPos + searchStringBytes);
                orgSrcPos = (PCWSTR) ((PBYTE) orgSrcPos + searchStringBytes);
            } else {
                if (destBytesLeft < sizeof (WCHAR)) {
                    break;
                }

                *destPos++ = *orgSrcPos++;
                destBytesLeft -= sizeof (WCHAR);
                lowerSrcPos++;
            }

            //
            // Implement single match flag
            //

            if (Flags & STRMAP_RETURN_AFTER_FIRST_REPLACE) {
                endPtr = destPos;
                break;
            }

        } else if (Flags & (STRMAP_FIRST_CHAR_MUST_MATCH|STRMAP_COMPLETE_MATCH_ONLY)) {
            //
            // This string does not match any search strings
            //

            break;

        } else {
            //
            // This character does not match, so copy it to the destination and
            // try the next string.
            //

            if (destBytesLeft < sizeof (WCHAR)) {
                break;
            }

            *destPos++ = *orgSrcPos++;
            destBytesLeft -= sizeof (WCHAR);
            lowerSrcPos++;
        }

    }

    //
    // Copy any remaining part of the original source to the
    // destination, unless destPos == Buffer == SrcBuffer
    //

    if (destPos != SrcBuffer) {

        if (*orgSrcPos) {
            orgSrcBytesLeft = ByteCountW (orgSrcPos);
            orgSrcBytesLeft = min (orgSrcBytesLeft, destBytesLeft);

            CopyMemory (destPos, orgSrcPos, orgSrcBytesLeft);
            destPos = (PWSTR) ((PBYTE) destPos + orgSrcBytesLeft);
        }

        MYASSERT ((PBYTE) (destPos + 1) <= ((PBYTE) Buffer + MaxSizeInBytes));
        *destPos = 0;

        if (!endPtr) {
            endPtr = destPos;
        }

    } else {

        MYASSERT (SrcBuffer == Buffer);
        if (EndOfString || OutboundBytesPtr) {
            endPtr = GetEndOfStringW (destPos);
        }
    }

    if (EndOfString) {
        MYASSERT (endPtr);
        *EndOfString = endPtr;
    }

    if (OutboundBytesPtr) {
        MYASSERT (endPtr);
        if (*endPtr) {
            endPtr = GetEndOfStringW (endPtr);
        }

        *OutboundBytesPtr = (HALF_PTR) ((PBYTE) endPtr - (PBYTE) Buffer);
    }

    FreeTextW (lowerCaseSrc);

    return result;
}


BOOL
MappingSearchAndReplaceExA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    )
{
    return MappingMultiTableSearchAndReplaceExA (
                &Map,
                1,
                SrcBuffer,
                Buffer,
                InboundBytes,
                OutboundBytesPtr,
                MaxSizeInBytes,
                Flags,
                ExtraDataValue,
                EndOfString
                );
}

BOOL
MappingSearchAndReplaceExW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    )
{
    return MappingMultiTableSearchAndReplaceExW (
                &Map,
                1,
                SrcBuffer,
                Buffer,
                InboundBytes,
                OutboundBytesPtr,
                MaxSizeInBytes,
                Flags,
                ExtraDataValue,
                EndOfString
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\utilsp.h ===
#ifndef MSG_MESSAGEBOX_TITLE
#define MSG_MESSAGEBOX_TITLE        10000
#endif

//lint -save -e757

extern PCSTR g_OutOfMemoryString;
extern PCSTR g_OutOfMemoryRetry;

extern PMHANDLE g_RegistryApiPool;
extern PMHANDLE g_PathsPool;
extern CRITICAL_SECTION g_PmCs;
extern CRITICAL_SECTION g_MemAllocCs;

VOID
InitLeadByteTable (
    VOID
    );


//lint -restore
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\bintree.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    bintree.c

Abstract:

    Routines that manage the binary trees in the memdb database

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

--*/


#include "pch.h"

// PORTBUG: Make sure to pick up latest fixes in win9xupg project

//
// Includes
//

#include "memdbp.h"
#include "bintree.h"

//
// Strings
//

// None

//
// Constants
//

#define NODESTRUCT_SIZE_MAIN    (4*sizeof(UINT) + sizeof(WORD))
#define BINTREE_SIZE_MAIN    sizeof(UINT)
#define LISTELEM_SIZE_MAIN    (3*sizeof(UINT))

#ifdef DEBUG

    #define NODESTRUCT_HEADER_SIZE  (sizeof(DWORD)+sizeof(BOOL))
    #define NODESTRUCT_SIZE         ((WORD)(NODESTRUCT_SIZE_MAIN + (g_UseDebugStructs ? NODESTRUCT_HEADER_SIZE : 0)))

    #define BINTREE_HEADER_SIZE  (sizeof(DWORD)+2*sizeof(INT)+sizeof(BOOL))
    #define BINTREE_SIZE         ((WORD)(BINTREE_SIZE_MAIN + (g_UseDebugStructs ? BINTREE_HEADER_SIZE : 0)))

    #define LISTELEM_HEADER_SIZE  sizeof(DWORD)
    #define LISTELEM_SIZE         ((WORD)(LISTELEM_SIZE_MAIN + (g_UseDebugStructs ? LISTELEM_HEADER_SIZE : 0)))

#else

    #define NODESTRUCT_SIZE         ((WORD)NODESTRUCT_SIZE_MAIN)
    #define BINTREE_SIZE         ((WORD)BINTREE_SIZE_MAIN)
    #define LISTELEM_SIZE         ((WORD)LISTELEM_SIZE_MAIN)

#endif


//
// Macros
//

#define MAX(a,b) (a>b ? a : b)
#define ABS(x) (x<0 ? -x : x)

#ifdef DEBUG

//
// if BINTREECHECKTREEBALANCE is true, every addition or deletion
// or rotation checks to make sure tree is balanced and
// correct.  this of course take a lot of time.
//
#define BINTREECHECKTREEBALANCE    FALSE

#define INITTREENODES(tree) { if (g_UseDebugStructs) { tree->NodeAlloc=0; } }
#define INCTREENODES(tree) { if (g_UseDebugStructs) { tree->NodeAlloc++; } }
#define DECTREENODES(tree) { if (g_UseDebugStructs) { tree->NodeAlloc--; } }
#define TESTTREENODES(tree) { if (g_UseDebugStructs) { MYASSERT(tree->NodeAlloc==0); } }
#define INITTREEELEMS(tree) { if (g_UseDebugStructs) { tree->ElemAlloc=0; } }
#define INCTREEELEMS(tree) { if (g_UseDebugStructs) { tree->ElemAlloc++; } }
#define DECTREEELEMS(tree) { if (g_UseDebugStructs) { tree->ElemAlloc--; } }
#define TESTTREEELEMS(tree) { if (g_UseDebugStructs) { MYASSERT(tree->ElemAlloc==0); } }

#else

#define BINTREECHECKTREEBALANCE

#define INITTREENODES(tree)
#define INCTREENODES(tree)
#define DECTREENODES(tree)
#define TESTTREENODES(tree)
#define INITTREEELEMS(tree)
#define INCTREEELEMS(tree)
#define DECTREEELEMS(tree)
#define TESTTREEELEMS(tree)

#endif

#if defined(DEBUG)
#if BINTREECHECKTREEBALANCE

#define TESTNODETREE(node) MYASSERT(pBinTreeCheckBalance(node));
#define TESTTREE(tree) MYASSERT(pBinTreeCheck(tree));

#else

#define TESTNODETREE(node)
#define TESTTREE(tree)

#endif

#else

#define TESTNODETREE(node)
#define TESTTREE(tree)

#endif

//
// Types
//

typedef struct {

#ifdef DEBUG
    DWORD Signature;
    BOOL Deleted;
#endif

    union {
        struct {        //for normal nodes
            UINT Data;              //offset of data structure
            UINT Left;              //offset of left child
            UINT Right;             //offset of right child
            UINT Parent;            //offset of parent
        };//lint !e657
        struct {        //for the InsertionOrdered list header node (tree->Root points to this)
            UINT Root;              //offset of actual root of tree
            UINT Head;              //head of insertion ordered list
            UINT Tail;              //tail of insertion ordered list
        };//lint !e657
        UINT NextDeleted;           //offset of next deleted node
    };


    struct {
        WORD InsertionOrdered : 1;  //flag, 1 if insertion-ordered (only really needed
                                    //by enumeration methods, because to save space
                                    //there is no tree pointer in the NODESTRUCT, but
                                    //we need a way for enumeration methods to know if
                                    //node->Data is the offset of the data or the
                                    //offset of a LISTELEM (which it is when we are in
                                    //insertion-ordered mode)).
        WORD InsertionHead : 1;     //flag, 1 if this node is the head of insertion
                                    //ordered tree.
        WORD LeftDepth : 7;         //depths of subtrees.  these can be 7 bits because
        WORD RightDepth : 7;        //if depth got up to near 128, the approximate
                                    //number of nodes would be 1e35.
    };//lint !e657
} NODESTRUCT, *PNODESTRUCT;

//
// normally, the BINTREE structure simply has the offset
// of the root node of the tree in its Root member.  but
// when we are in insertion-ordered mode, we have an extra
// node whose offset is stored in the BINTREE->Root.  this
// Header Node points to the head of the insertion-ordered
// linked list, the tail of the list, and the actual root
// of the binary tree.
//

typedef struct {

#ifdef DEBUG

    DWORD Signature;
    INT NodeAlloc;          // counter for number of nodes allocated
    INT ElemAlloc;          // counter for number of elems allocated
    BOOL Deleted;           // flag which is TRUE if tree is deleted

#endif

    union {
        UINT Root;          // offset of top level NODESTRUCT
        UINT NextDeleted;   // offset of next deleted tree
    };

} BINTREE, *PBINTREE;

//
// if we are in insertion-ordered mode, that means every
// enumeration will be in the order that we added the
// data.  to do this, we use a linked list with the binary
// tree.  the data member of the NODESTRUCT holds the
// offset of the LISTELEM structure, and the data member
// of the LISTELEM structure holds the offset of the data.
// To enumerate, we just walk the linked list in order.
//

typedef struct {

#ifdef DEBUG
    DWORD Signature;
#endif

    union {
        struct {
            UINT Next;      // offset of next element in list
            UINT Data;      // offset of data structure this element is for
            UINT Node;      // offset of NODESTRUCT this listelem corresponds to
        };//lint !e657
        UINT NextDeleted;
    };

} LISTELEM, *PLISTELEM;

//
// Globals
//

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

PNODESTRUCT
pBinTreeFindNode (
    IN      PBINTREE Tree,
    IN      PCWSTR String
    );

PNODESTRUCT
pBinTreeEnumFirst (
    IN      PBINTREE Tree
    );

PNODESTRUCT
pBinTreeEnumNext (
    IN OUT  PNODESTRUCT CurrentNode
    );

PNODESTRUCT
pBinTreeAllocNode (
    OUT     PUINT Offset
    );

PBINTREE
pBinTreeAllocTree (
    OUT     PUINT Offset
    );

PLISTELEM
pBinTreeAllocListElem (
    OUT     PUINT Offset
    );

VOID
pBinTreeFreeNode (
    PNODESTRUCT Node
    );

VOID
pBinTreeFreeTree (
    PBINTREE Tree
    );

VOID
pBinTreeFreeListElem (
    PLISTELEM Elem
    );

VOID
pBinTreeDestroy (
    PNODESTRUCT Node,
    PBINTREE Tree
    );

//
// This starts at node and moves up tree balancing.
// The function stops moving up when it finds a node
// which has no change in depth values and/or no balancing
// to be done.  Otherwise, it goes all the way to top.
// Carry TreeOffset through for rotate functions
//
VOID
pBinTreeBalanceUpward (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );

//
// After pBinTreeNodeBalance, parent of node could have incorrect
// depth values and might need rebalancing.
// Carry TreeOffset through for rotate functions.
// Assumes children of 'node' are balanced.
// Returns true if node rebalanced or if depth values changed.
//
BOOL
pBinTreeNodeBalance (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );

//
// After using the following rotate functions, the parents of node
// could have incorrect depth values, and could need rebalancing.
// We do not have double-rotate functions because that is taken
// care of inside these.  Need TreeOffset just in case node is top node
//
VOID
pBinTreeRotateRight (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );

VOID
pBinTreeRotateLeft (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    );


#ifdef DEBUG

INT
pBinTreeCheckBalance (
    IN      PNODESTRUCT Node
    );

INT
pBinTreeCheck (
    IN      PBINTREE Tree
    );

#endif

//
// Macro expansion definition
//

// None

//
// Code
//

//
// If we are in debug mode, these conversions
// are implemented as functions, so we can
// check for errors.  If we are not in debug
// mode, the conversions are simple macros.
//
#ifdef DEBUG

UINT
GetNodeOffset (
    IN      PNODESTRUCT Node
    )
{
    if (!Node) {
        return INVALID_OFFSET;
    }

    if (!g_UseDebugStructs) {
        return PTR_TO_OFFSET(Node) + NODESTRUCT_HEADER_SIZE;
    }

    MYASSERT (Node->Signature == NODESTRUCT_SIGNATURE);

    return PTR_TO_OFFSET(Node);
}


UINT
GetTreeOffset (
    PBINTREE Tree
    )
{

    if (!Tree) {
        return INVALID_OFFSET;
    }

    if (!g_UseDebugStructs) {
        return PTR_TO_OFFSET(Tree) + BINTREE_HEADER_SIZE;
    }

    MYASSERT (Tree->Signature == BINTREE_SIGNATURE);

    return PTR_TO_OFFSET(Tree);
}


UINT
GetListElemOffset (
    PLISTELEM Elem
    )
{
    if (!Elem) {
        return INVALID_OFFSET;
    }

    if (!g_UseDebugStructs) {
        return PTR_TO_OFFSET(Elem) + LISTELEM_HEADER_SIZE;
    }

    MYASSERT (Elem->Signature == LISTELEM_SIGNATURE);

    return PTR_TO_OFFSET(Elem);
}


PNODESTRUCT
GetNodeStruct (
    UINT Offset
    )
{
    PNODESTRUCT node;

    if (Offset == INVALID_OFFSET) {
        return NULL;
    }

    if (!g_UseDebugStructs) {
        return (PNODESTRUCT) OFFSET_TO_PTR(Offset - NODESTRUCT_HEADER_SIZE);
    }

    node = (PNODESTRUCT) OFFSET_TO_PTR(Offset);

    MYASSERT (node->Signature == NODESTRUCT_SIGNATURE);

    return node;
}


PBINTREE
GetBinTree (
    UINT Offset
    )
{
    PBINTREE tree;

    if (Offset == INVALID_OFFSET) {
        return NULL;
    }

    if (!g_UseDebugStructs) {
        return (PBINTREE) OFFSET_TO_PTR(Offset - BINTREE_HEADER_SIZE);
    }

    tree = (PBINTREE) OFFSET_TO_PTR(Offset);

    MYASSERT (tree->Signature == BINTREE_SIGNATURE);

    return tree;
}


PLISTELEM
GetListElem (
    UINT Offset
    )
{
    PLISTELEM elem;

    if (Offset == INVALID_OFFSET) {
        return NULL;
    }

    if (!g_UseDebugStructs) {
        return (PLISTELEM) OFFSET_TO_PTR(Offset - LISTELEM_HEADER_SIZE);
    }

    elem = (PLISTELEM) OFFSET_TO_PTR(Offset);

    MYASSERT (elem->Signature == LISTELEM_SIGNATURE);

    return elem;
}

#else

#define GetNodeOffset(Node)         ((Node) ?                   \
                                        PTR_TO_OFFSET(Node) :   \
                                        INVALID_OFFSET)

#define GetTreeOffset(Tree)         ((Tree) ?                   \
                                        PTR_TO_OFFSET(Tree) :   \
                                        INVALID_OFFSET)

#define GetListElemOffset(Elem)     ((Elem) ?                   \
                                        PTR_TO_OFFSET(Elem) :   \
                                        INVALID_OFFSET)

#define GetNodeStruct(Offset)       (((Offset) == INVALID_OFFSET) ?         \
                                        NULL :                              \
                                        (PNODESTRUCT) OFFSET_TO_PTR(Offset))

#define GetBinTree(Offset)          (((Offset) == INVALID_OFFSET) ?         \
                                        NULL :                              \
                                        (PBINTREE) OFFSET_TO_PTR(Offset))

#define GetListElem(Offset)         (((Offset) == INVALID_OFFSET) ?         \
                                        NULL :                              \
                                        (PLISTELEM)OFFSET_TO_PTR(Offset))


#endif


//
// GetNodeData - takes a node and gets the data
//      structure offset
//
// GetNodeDataStr - takes a node and gets the
//      pascal-style string in the data structure offset
//

#define GetNodeData(Node)       ((Node)->InsertionOrdered ?                 \
                                        GetListElem((Node)->Data)->Data :   \
                                        (Node)->Data)

#define GetNodeDataStr(Node)    (GetDataStr(GetNodeData(Node)))


PNODESTRUCT
GetTreeRoot (
    IN      PBINTREE Tree
    )
{
    PNODESTRUCT cur;

    if (!Tree || Tree->Root == INVALID_OFFSET) {
        return NULL;
    }

    cur = GetNodeStruct (Tree->Root);

    if (cur->InsertionHead) {
        return GetNodeStruct (cur->Root);
    } else {
        return cur;
    }
}


VOID
pSetTreeRoot (
    IN      PBINTREE Tree,
    IN      UINT Offset
    )
{
    PNODESTRUCT cur;

    if (!Tree) {
        return;
    }

    cur = GetNodeStruct(Tree->Root);

    if (cur && cur->InsertionHead) {
        cur->Root = Offset;
    } else {
        Tree->Root = Offset;
    }
}

#define IsTreeInsertionOrdered(Tree)    ((Tree) ?                                               \
                                            ((Tree)->Root==INVALID_OFFSET ?                     \
                                                FALSE :                                         \
                                                GetNodeStruct((Tree)->Root)->InsertionHead) :   \
                                            FALSE)







UINT
BinTreeNew (
    VOID
    )

/*++

Routine Description:

  BinTreeNew creates a new binary tree data structure. This is done when a new
  node is created via a set operation of some sort. Additional items are added
  to the binary tree via BinTreeAddNode.

Arguments:

  None.

Return Value:

  The offset to the new tree.

Comments:

  This function assumes that it cannot fail,  because if a low-level memory
  routine fails, the process will die.

  The database heap might be moved by the allocation request, and could
  invalidate pointers. The caller must use care not to use pointers until
  after this routine returns, or it must re-convert offsets into new pointers.

--*/

{
    UINT treeOffset;
    PBINTREE tree;

    tree = pBinTreeAllocTree (&treeOffset);
    if (!tree) {
        return INVALID_OFFSET;
    }

    tree->Root = INVALID_OFFSET;

    INITTREENODES(tree);
    INITTREEELEMS(tree);

    return treeOffset;
}


BOOL
BinTreeAddNode (
    IN      UINT TreeOffset,
    IN      UINT Data
    )

/*++

Routine Description:

  BinTreeAddNode adds a new item to an existing binary tree.

Arguments:

  TreeOffset - Indicates the root of the binary tree, as returned by
               BinTreeNew.
  Data       - Specifies the offset of the data structure containing the
               node to insert. The string address is computed from Data via
               GetDataStr.

Return Value:

  TRUE if the insertion operation succeeded, FALSE if the item is already in
  the tree.

--*/

{
    UINT nodeOffset;
    UINT elemOffset;
    UINT parentOffset;
    PNODESTRUCT node;
    PNODESTRUCT cur;
    PNODESTRUCT parent;
    PBINTREE tree;
    PLISTELEM elem;
    INT cmp;
    PCWSTR dataStr;

    if (TreeOffset == INVALID_OFFSET) {
        return FALSE;
    }

    //
    // Keep track of initial database pointer.  If it changes, we need
    // to readjust our pointers.
    //

    tree = GetBinTree (TreeOffset);

    if (!GetTreeRoot (tree)) {

        //
        // No root case -- add this item as the root
        //

        node = pBinTreeAllocNode (&nodeOffset);
        if (!node) {
            return FALSE;
        }

        PTR_WAS_INVALIDATED(tree);

        tree = GetBinTree (TreeOffset);
        INCTREENODES (tree);

        pSetTreeRoot (tree, nodeOffset);

        node->Parent = INVALID_OFFSET;
        parentOffset = INVALID_OFFSET;
        parent = NULL;

    } else {

        //
        // Existing root case -- try to find the item, then if it does
        // not exist, add it.
        //

        cur = GetTreeRoot (tree);
        dataStr = GetDataStr (Data);

        do {
            cmp = StringPasICompare (dataStr, GetNodeDataStr (cur));

            if (!cmp) {
                //
                // Node is already in tree
                //
                return FALSE;
            }

            //
            // Go to left or right node, depending on search result
            //

            parentOffset = GetNodeOffset (cur);

            if (cmp < 0) {
                cur = GetNodeStruct(cur->Left);
            } else {
                cur = GetNodeStruct(cur->Right);
            }

        } while (cur);

        //
        // Node is not in the tree.  Add it now.
        //

        node = pBinTreeAllocNode(&nodeOffset);
        if (!node) {
            return FALSE;
        }

        PTR_WAS_INVALIDATED(cur);
        PTR_WAS_INVALIDATED(tree);

        tree = GetBinTree (TreeOffset);
        INCTREENODES (tree);

        node->Parent = parentOffset;
        parent = GetNodeStruct (parentOffset);

        if (cmp < 0) {
            parent->Left = nodeOffset;
        } else {
            parent->Right = nodeOffset;
        }
    }

    //
    // Verify the code above restored the tree pointer if
    // an allocation occurred.
    //

    MYASSERT (tree == GetBinTree (TreeOffset));

    //
    // Initialize the new node
    //

    node->Left          = INVALID_OFFSET;
    node->Right         = INVALID_OFFSET;
    node->LeftDepth     = 0;
    node->RightDepth    = 0;
    node->InsertionHead = 0;

    if (!IsTreeInsertionOrdered (tree)) {
        //
        // We are in sorted-order mode
        //

        node->Data = Data;
        node->InsertionOrdered = 0;

    } else {
        //
        // We are in insertion-ordered mode
        //

        elem = pBinTreeAllocListElem (&elemOffset);
        if (!elem) {
            return FALSE;
        }

        PTR_WAS_INVALIDATED(parent);
        PTR_WAS_INVALIDATED(tree);
        PTR_WAS_INVALIDATED(node);

        parent = GetNodeStruct (parentOffset);
        tree = GetBinTree (TreeOffset);
        node = GetNodeStruct (nodeOffset);

        INCTREEELEMS(tree);

        node->InsertionOrdered = 1;
        node->Data = elemOffset;                // NODESTRUCT.Data is offset of list element
        elem->Data = Data;                      // LISTELEM holds offset of data
        elem->Node = nodeOffset;                // LISTELEM points back to nodestruct
        elem->Next = INVALID_OFFSET;            // elem will be put at end of list

        //now use node to point to list header
        node = GetNodeStruct (tree->Root);
        MYASSERT (node->InsertionHead);

        if (node->Head == INVALID_OFFSET) {     // if this is true, the list is empty
            node->Head = elemOffset;            // put elemOffset at beginning of the list
        } else {                                // otherwise, put the new element at end of list
            MYASSERT (node->Tail != INVALID_OFFSET);
            GetListElem (node->Tail)->Next = elemOffset;
        }

        node->Tail = elemOffset;                // new element is tail of list
    }

    pBinTreeBalanceUpward (parent, TreeOffset);

    TESTTREE (GetBinTree (TreeOffset));

    return TRUE;
}


UINT
BinTreeDeleteNode (
    IN      UINT TreeOffset,
    IN      PCWSTR Str,
    OUT     PBOOL LastNode              OPTIONAL
    )

/*++

Routine Description:

  BinTreeDeleteNode removes a string from a binary tree.

Arguments:

  TreeOffset - Specifies the binary tree to remove the string from
  Str        - Specifies the string to remove
  LastNode   - Receives TRUE if the binary tree became empty as a result of
               the delete, FALSE otherwise

Return Value:

  The data offset of the string that was deleted

--*/

{
    PNODESTRUCT deleteNode;
    PNODESTRUCT parent;
    PNODESTRUCT replace;
    UINT data;
    UINT replaceOffset;
    UINT deleteNodeOffset;
    PNODESTRUCT startBalance;
    PNODESTRUCT startBalance2 = NULL;
    PBINTREE tree;
    UINT elemOffset;
    PLISTELEM elem;
    PLISTELEM cur;
    PNODESTRUCT header;

    //
    // after we delete a node, we have to start from somewhere and
    // move up the tree, fixing the balance of nodes.  startBalance
    // is a pointer to the nodestruct to start at.  in more complicated
    // deletions, like when the deleted node has two children, and the
    // replacement node is way down the tree, there are two places to
    // start rebalancing from.
    //

    if (TreeOffset == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    tree = GetBinTree (TreeOffset);

    deleteNode = pBinTreeFindNode (tree, Str);
    if (deleteNode == NULL) {
        return INVALID_OFFSET;
    }

    if (LastNode) {
        *LastNode = FALSE;
    }

    deleteNodeOffset = GetNodeOffset (deleteNode);
    parent = GetNodeStruct (deleteNode->Parent);

    data = GetNodeData (deleteNode);

    if (deleteNode->Right == INVALID_OFFSET && deleteNode->Left == INVALID_OFFSET) {

        //
        // deleteNode has no children
        //

        if (parent == NULL) {

            if (LastNode) {
                *LastNode = TRUE;
            }

            pSetTreeRoot(tree, INVALID_OFFSET);

        } else {

            if (parent->Left == deleteNodeOffset) {
                parent->Left=INVALID_OFFSET;
            } else {
                parent->Right=INVALID_OFFSET;
            }

        }

        startBalance = parent;

    } else {
        //
        // deleteNode has one or two children
        //

        if (deleteNode->Right == INVALID_OFFSET || deleteNode->Left == INVALID_OFFSET) {

            //
            // deleteNode has one child
            //

            if (deleteNode->Right == INVALID_OFFSET) {
                replace = GetNodeStruct (deleteNode->Left);
            } else {
                replace = GetNodeStruct (deleteNode->Right);
            }

            replaceOffset = GetNodeOffset (replace);

            //
            // deleteNode->Parent has new child, so check balance
            //

            startBalance = parent;

        } else {

            //
            // deleteNode has two children: find replacement on deeper side
            //

            if (deleteNode->LeftDepth > deleteNode->RightDepth) {

                //
                // find replacement node on left
                //

                replace = GetNodeStruct (deleteNode->Left);

                if (replace->Right == INVALID_OFFSET) {
                    //
                    // node's left child has no right child, so replace is node->Left
                    //
                    replace->Right = deleteNode->Right;  //hook up node's right child to replace

                    GetNodeStruct (replace->Right)->Parent = deleteNode->Left;

                    replaceOffset = GetNodeOffset (replace);

                } else {
                    //
                    // deleteNode's left child has right child, so find the rightmost child
                    //

                    do {
                        //
                        // move right as far as possible
                        //
                        replace = GetNodeStruct (replace->Right);

                    } while (replace->Right != INVALID_OFFSET);

                    //
                    // child of replace->Parent changed, so balance
                    //

                    startBalance2 = GetNodeStruct (replace->Parent);

                    //
                    // replace's parent's right child is replace's left
                    //

                    startBalance2->Right = replace->Left;

                    if (replace->Left != INVALID_OFFSET) {
                        //
                        // hook up left children to replace->Parent
                        //
                        GetNodeStruct(replace->Left)->Parent = replace->Parent;
                    }

                    replaceOffset = GetNodeOffset (replace);

                    //
                    // hook up children of deleteNode to replace
                    //

                    replace->Left = deleteNode->Left;
                    GetNodeStruct (replace->Left)->Parent = replaceOffset;

                    replace->Right = deleteNode->Right;
                    GetNodeStruct (replace->Right)->Parent = replaceOffset;
                }

            } else {
                //
                // find replacement node on right
                //

                replace = GetNodeStruct (deleteNode->Right);

                if (replace->Left == INVALID_OFFSET) {
                    //
                    // deleteNode's right child has no left child, so replace is deleteNode->Right
                    //

                    replace->Left = deleteNode->Left;  // hook up node's left child to replace

                    GetNodeStruct (replace->Left)->Parent = deleteNode->Right;

                    replaceOffset = GetNodeOffset (replace);

                } else {
                    //
                    // deleteNode's right child has left child, so find the leftmost child
                    //

                    do {

                        replace = GetNodeStruct (replace->Left);

                    } while (replace->Left != INVALID_OFFSET);

                    //
                    // child of replace->Parent changed, so balance
                    //
                    startBalance2 = GetNodeStruct (replace->Parent);

                    //
                    // replace's parent's left child is replace's right
                    //
                    startBalance2->Left = replace->Right;

                    if (replace->Right != INVALID_OFFSET) {
                        //
                        // hook up right children to replace->Parent
                        //
                        GetNodeStruct (replace->Right)->Parent = replace->Parent;
                    }

                    replaceOffset = GetNodeOffset (replace);

                    //
                    // hook up children of deleteNode to replace
                    //
                    replace->Right = deleteNode->Right;
                    GetNodeStruct (replace->Right)->Parent = replaceOffset;

                    replace->Left = deleteNode->Left;
                    GetNodeStruct (replace->Left)->Parent = replaceOffset;
                }
            }

            //
            // in all cases of deleted node having two children,
            // the place to start (second) balancing is the node
            // that replaces the deleted node, because it will
            // always have at least one new child.
            //
            startBalance = replace;
        }

        //
        // this is offset
        //

        replace->Parent = deleteNode->Parent;

        if (parent == NULL) {
            //
            // deleting top-level node
            //
            pSetTreeRoot (tree, replaceOffset);

        } else {
            if (parent->Left == deleteNodeOffset) {
                parent->Left = replaceOffset;
            } else {
                parent->Right = replaceOffset;
            }
        }
    }

    if (startBalance2) {
        //
        // startBalance2 is lower one
        //
        pBinTreeBalanceUpward (startBalance2, TreeOffset);
    }

    pBinTreeBalanceUpward (startBalance, TreeOffset);

    if (deleteNode->InsertionOrdered) {
        //
        // We are in insertion-ordered mode
        //

        //
        // get offset of LISTELEM for this NODESTRUCT
        //
        elemOffset = deleteNode->Data;
        elem = GetListElem (elemOffset);

        header = GetNodeStruct (tree->Root);   //get the header of list

        if (header->Head == elemOffset) {
            //
            // if elem was first in list
            //

            header->Head = elem->Next;

            if (elem->Next == INVALID_OFFSET) {     // if elem was last in list
                header->Tail = INVALID_OFFSET;
            }

        } else {
            //
            // elem was not first in list
            //

            cur = GetListElem (header->Head);

            while (cur->Next != elemOffset) {
                MYASSERT (cur->Next != INVALID_OFFSET);
                cur = GetListElem (cur->Next);
            }

            //
            // now cur is the element before elem, so pull elem out of list
            //

            cur->Next = elem->Next;
            if (elem->Next == INVALID_OFFSET) {           // if elem was last in list
                header->Tail = GetListElemOffset(cur);    // set end pointer to new last element
            }
        }

        pBinTreeFreeListElem (elem);
        DECTREEELEMS(tree);
    }

    pBinTreeFreeNode (deleteNode);
    DECTREENODES(tree);

    TESTTREE(tree);

    return data;
}


PNODESTRUCT
pBinTreeFindNode (
    IN      PBINTREE Tree,
    IN      PCWSTR Str
    )
{
    PNODESTRUCT cur;
    INT cmp;

    if (!Tree) {
        return NULL;
    }

    cur = GetTreeRoot (Tree);

    while (cur) {

        cmp = StringPasICompare (Str, GetNodeDataStr (cur));

        if (!cmp) {
            break;
        }

        if (cmp < 0) {
            cur = GetNodeStruct (cur->Left);
        } else {
            cur = GetNodeStruct (cur->Right);
        }
    }

    return cur;
}


UINT
BinTreeFindNode (
    IN      UINT TreeOffset,
    IN      PCWSTR Str
    )

/*++

Routine Description:

  BinTreeFindNode searches a binary tree for a string and returns the offset
  to the item data.

Arguments:

  TreeOffset - Specifies the binary tree to search
  Str        - Specifies the string to find

Return Value:

  The offset to the node data, or INVALID_OFFSET if string is not found.

--*/

{
    PNODESTRUCT node;
    PBINTREE tree;

    tree = GetBinTree (TreeOffset);
    node = pBinTreeFindNode (tree, Str);

    if (!node) {
        return INVALID_OFFSET;
    }

    return GetNodeData(node);
}


VOID
pBinTreeDestroy (
    IN      PNODESTRUCT Node,       OPTIONAL
    IN      PBINTREE Tree           OPTIONAL
    )

/*++

Routine Description:

  pBinTreeDestroy destroys a binary tree. This routine is recursive.

Arguments:

  Node - Specifies the node to deallocate.  All child nodes are also
         deallocated.
  Tree - Specifies the tree that Node belongs to

Return Value:

  None.

--*/

{
    if (!Node || !Tree) {
        return;
    }

    pBinTreeDestroy (GetNodeStruct (Node->Left), Tree);
    pBinTreeDestroy (GetNodeStruct (Node->Right), Tree);

    if (Node->InsertionOrdered) {
        pBinTreeFreeListElem (GetListElem (Node->Data));
        DECTREEELEMS(Tree);
    }

    pBinTreeFreeNode (Node);
    DECTREENODES(Tree);
}


VOID
BinTreeDestroy (
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeDestroy deallocates all nodes in a binary tree.

Arguments:

  TreeOffset - Specifies the binary tree to free

Return Value:

  None.

--*/

{
    PBINTREE tree;
    PNODESTRUCT root;
    PNODESTRUCT header;

    if (TreeOffset==INVALID_OFFSET) {
        return;
    }

    tree = GetBinTree (TreeOffset);
    root = GetNodeStruct (tree->Root);

    if (root && root->InsertionHead) {
        header = root;
        root = GetNodeStruct (root->Root);
    } else {
        header = NULL;
    }

    pBinTreeDestroy (root, tree);

    if (header) {
        pBinTreeFreeNode(header);
        DECTREENODES(tree);
    }

    TESTTREENODES(tree);
    TESTTREEELEMS(tree);

    pBinTreeFreeTree(tree);
}


PNODESTRUCT
pBinTreeEnumFirst (
    IN      PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeEnumFirst returns the first node in the specified tree.

Arguments:

  Tree - Specifies the tree to begin enumerating

Return Value:

  A pointer to the first node struct, or NULL if no items exist in Tree, or
  if Tree is NULL.

--*/

{
    PNODESTRUCT cur;

    cur = GetTreeRoot (Tree);

    if (cur) {

        while (cur->Left != INVALID_OFFSET) {
            cur = GetNodeStruct (cur->Left);
        }

    }

    return cur;
}


PNODESTRUCT
pBinTreeEnumNext (
    IN      PNODESTRUCT CurrentNode
    )

/*++

Routine Description:

  pBinTreeEnumNext continues an enumeration of a binary tree. It walks the
  tree in sorted order.

Arguments:

  CurrentNode - Specifies the previous node returned by pBinTreeEnumFirst or
                pBinTreeEnumNext.

Return Value:

  Returns the next node in the tree, or NULL if no more items are left to
  enumerate.

--*/

{
    PNODESTRUCT cur;
    PNODESTRUCT parent;

    if (!CurrentNode) {
        return NULL;
    }

    cur = CurrentNode;

    if (cur->Right != INVALID_OFFSET) {

        cur = GetNodeStruct (cur->Right);

        while (cur->Left != INVALID_OFFSET) {
            cur = GetNodeStruct (cur->Left);
        }

        return cur;
    }

    //
    // otherwise, cur has no right child, so we have to
    // move upwards until we find a parent to the right
    // (or we reach top of tree, meaning we are done)
    //

    for (;;) {
        parent = GetNodeStruct (cur->Parent);

        //
        // if has no parent or parent is to right
        //

        if (!parent || parent->Left == GetNodeOffset (cur)) {
            break;
        }

        cur = parent;
    }

    return parent;
}


PLISTELEM
pBinTreeInsertionEnumFirst (
    PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeInsertionEnumFirst begins an enumeration of the nodes inside an
  insertion-ordered tree.  If the tree is not insertion ordered, no items are
  enumerated.  If insertion order was enabled after items had been previously
  added, this enumeration will not return those initial items.

Arguments:

  Tree - Specifies the tree to begin enumeration of

Return Value:

  A pointer to the linked list element, or NULL if no insertion-ordered nodes
  exist in Tree, or NULL if Tree is NULL.

--*/

{
    PNODESTRUCT header;

    if (!Tree) {
        return NULL;
    }

    header = GetNodeStruct (Tree->Root);

    return header ? GetListElem (header->Head) : NULL;
}


PLISTELEM
pBinTreeInsertionEnumNext (
    IN      PLISTELEM Elem
    )

/*++

Routine Description:

  pBinTreeInsertionEnumNext continues an enumeration of the insertion-ordered
  nodes in a binary tree.

Arguments:

  Elem - Specifies the previously enumerated list element

Return Value:

  A pointer to the next element, or NULL if no more elements exist, or if
  Elem is NULL.

--*/

{
    if (!Elem) {
        return NULL;
    }

    return GetListElem (Elem->Next);
}


UINT
BinTreeEnumFirst (
    IN      UINT TreeOffset,
    OUT     PUINT Enum
    )

/*++

Routine Description:

  BinTreeEnumFirst begins an enumeration of the data offsets stored in a
  binary tree. The enumeration is sorted order or insertion order, depending
  on the insertion order setting within the tree.

Arguments:

  TreeOffset - Specifies the binary tree to begin enumeration of.
  Enum       - Receives the offset to the binary tree node.

Return Value:

  The offset to the data associated with the first node, or INVALID_OFFSET if
  the tree is empty.

--*/

{
    PBINTREE tree;
    PNODESTRUCT node;
    PLISTELEM elem;

    MYASSERT (Enum);

    if (TreeOffset == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    tree = GetBinTree (TreeOffset);

    if (IsTreeInsertionOrdered (tree)) {
        //
        // tree is insertion-ordered, so get first element in
        // linked list.  enumerator is NODESTRUCT for this elem
        //

        elem = pBinTreeInsertionEnumFirst (tree);

        if (!elem) {

            if (Enum) {
                *Enum = INVALID_OFFSET;
            }

            return INVALID_OFFSET;

        } else {

            if (Enum) {
                *Enum = elem->Node;
            }

            return elem->Data;
        }

    } else {

        //
        // tree is not insertion-ordered, so get leftmost node.
        // enumerator is the offset of this node.
        //

        node = pBinTreeEnumFirst (tree);

        if (Enum) {
            *Enum = GetNodeOffset (node);
        }

        return !node ? INVALID_OFFSET : node->Data;
    }
}


UINT
BinTreeEnumNext (
    IN OUT  PUINT Enum
    )

/*++

Routine Description:

  BinTreeEnumNext continues an enumeration started by BinTreeEnumFirst.

Arguments:

  Enum - Specifies the previous node offset, receivies the enumerated node
         offset.

Return Value:

  The offset to the data associated with the next node, or INVALID_OFFSET if
  no more nodes exist in the tree.

--*/

{
    PNODESTRUCT node;
    PLISTELEM elem;

    MYASSERT (Enum);

    if (*Enum == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    node = GetNodeStruct (*Enum);

    if (node->InsertionOrdered) {
        //
        // tree is insertion-ordered,
        // so get next node in list.
        //

        elem = pBinTreeInsertionEnumNext (GetListElem (node->Data));

        if (!elem) {
            *Enum = INVALID_OFFSET;
            return INVALID_OFFSET;
        } else {
            *Enum = elem->Node;
            return elem->Data;
        }

    } else {
        //
        // tree is not insertion-ordered,
        // so get next node in tree.
        //
        node = pBinTreeEnumNext (node);

        *Enum = GetNodeOffset (node);
        return !node ? INVALID_OFFSET : node->Data;
    }
}



PNODESTRUCT
pBinTreeAllocNode (
    OUT     PUINT Offset
    )

/*++

Routine Description:

  pBinTreeAllocNode allocates a node in the current global database, and
  returns the offset and pointer to that node.

  Allocations can alter the location of the database, and subsequently
  invalidate the caller's pointers into the database.

Arguments:

  Offset - Receivies the offset to the newly created node.

Return Value:

  A pointer to the newly created node.

--*/

{
    PNODESTRUCT node;
    UINT tempOffset;

    MYASSERT (g_CurrentDatabase);

    if (g_CurrentDatabase->FirstBinTreeNodeDeleted == INVALID_OFFSET) {

        tempOffset = DatabaseAllocBlock (NODESTRUCT_SIZE);
        if (tempOffset == INVALID_OFFSET) {
            return NULL;
        }

        *Offset = tempOffset;

#ifdef DEBUG
        if (g_UseDebugStructs) {
            node = (PNODESTRUCT) OFFSET_TO_PTR(*Offset);
            node->Signature = NODESTRUCT_SIGNATURE;
        } else {
            node = (PNODESTRUCT) OFFSET_TO_PTR(*Offset - NODESTRUCT_HEADER_SIZE);
        }
#else
        node = (PNODESTRUCT) OFFSET_TO_PTR(*Offset);
#endif

    } else {
        *Offset = g_CurrentDatabase->FirstBinTreeNodeDeleted;
        node = GetNodeStruct(*Offset);
        g_CurrentDatabase->FirstBinTreeNodeDeleted = node->NextDeleted;
    }

#ifdef DEBUG
    if (g_UseDebugStructs) {
        node->Deleted = FALSE;
    }
#endif

    return node;
}


VOID
pBinTreeFreeNode (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeFreeNode puts an allocated node on the deleted list.  It does not
  adjust any other linkage.

Arguments:

  Node - Specifies the node to put on the deleted list.

Return Value:

  None.

--*/

{
    MYASSERT(Node);

#ifdef DEBUG
    if (g_UseDebugStructs) {
        MYASSERT(Node->Signature == NODESTRUCT_SIGNATURE);
        Node->Deleted = TRUE;
    }
#endif

    MYASSERT(g_CurrentDatabase);

    Node->NextDeleted = g_CurrentDatabase->FirstBinTreeNodeDeleted;
    g_CurrentDatabase->FirstBinTreeNodeDeleted = GetNodeOffset(Node);
}


PBINTREE
pBinTreeAllocTree (
    OUT     PUINT Offset
    )

/*++

Routine Description:

  pBinTreeAllocTree creates a binary tree data structure. If a structure
  is available in the detele list, then it is used.  Otherwise, the
  database grows.

  Allocations can alter the location of the database, and subsequently
  invalidate the caller's pointers into the database.

Arguments:

  Offset - Receivies the offset to the binary tree.

Return Value:

  A pointer to the new binary tree structure.

--*/

{
    PBINTREE tree;
    UINT tempOffset;

    MYASSERT(g_CurrentDatabase);

    if (g_CurrentDatabase->FirstBinTreeDeleted == INVALID_OFFSET) {

        tempOffset = DatabaseAllocBlock (BINTREE_SIZE);
        if (tempOffset == INVALID_OFFSET) {
            return NULL;
        }

        *Offset = tempOffset;

#ifdef DEBUG
        if (g_UseDebugStructs) {
            tree = (PBINTREE) OFFSET_TO_PTR(*Offset);
            tree->Signature = BINTREE_SIGNATURE;
        } else {
            tree = (PBINTREE) OFFSET_TO_PTR(*Offset - BINTREE_HEADER_SIZE);
        }
#else
        tree = (PBINTREE)OFFSET_TO_PTR(*Offset);
#endif

    } else {
        *Offset = g_CurrentDatabase->FirstBinTreeDeleted;
        tree = GetBinTree (*Offset);
        g_CurrentDatabase->FirstBinTreeDeleted = tree->NextDeleted;
    }

#ifdef DEBUG
    if (g_UseDebugStructs) {
        tree->Deleted = FALSE;
    }
#endif

    return tree;
}


VOID
pBinTreeFreeTree (
    IN      PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeFreeTree frees a binary tree structure.  It does not free the nodes
  within the structure.

Arguments:

  Tree - Specifies the binary tree structure to put on the deleted list.

Return Value:

  None.

--*/

{
    MYASSERT (Tree);
    MYASSERT (g_CurrentDatabase);

#ifdef DEBUG
    if (g_UseDebugStructs) {
        Tree->Deleted = TRUE;
        MYASSERT (Tree->Signature == BINTREE_SIGNATURE);
    }
#endif

    Tree->NextDeleted = g_CurrentDatabase->FirstBinTreeDeleted;
    g_CurrentDatabase->FirstBinTreeDeleted = GetTreeOffset (Tree);
}


PLISTELEM
pBinTreeAllocListElem (
    OUT     PUINT Offset
    )

/*++

Routine Description:

  pBinTreeAllocListElem allocates a list element. If an element is available
  in the deleted list, it is used.  Otherwise, a new element is allocated
  from the database.

  Allocations can alter the location of the database, and subsequently
  invalidate the caller's pointers into the database.

Arguments:

  Offset - Receives the offset of the newly allocated element

Return Value:

  A pointer to the allocated list element

--*/

{
    PLISTELEM elem;
    UINT tempOffset;

    MYASSERT (g_CurrentDatabase);

    if (g_CurrentDatabase->FirstBinTreeListElemDeleted == INVALID_OFFSET) {

        tempOffset = DatabaseAllocBlock (LISTELEM_SIZE);
        if (tempOffset == INVALID_OFFSET) {
            return NULL;
        }

        *Offset = tempOffset;

#ifdef DEBUG

        if (g_UseDebugStructs) {
            elem = (PLISTELEM) OFFSET_TO_PTR(*Offset);
            elem->Signature = LISTELEM_SIGNATURE;
        } else {
            elem = (PLISTELEM) OFFSET_TO_PTR(*Offset - LISTELEM_HEADER_SIZE);
        }

#else
        elem = (PLISTELEM) OFFSET_TO_PTR(*Offset);
#endif

    } else {
        *Offset = g_CurrentDatabase->FirstBinTreeListElemDeleted;
        elem = GetListElem (*Offset);
        g_CurrentDatabase->FirstBinTreeListElemDeleted = elem->NextDeleted;
    }

    return elem;
}


VOID
pBinTreeFreeListElem (
    IN      PLISTELEM Elem
    )

/*++

Routine Description:

  pBinTreeFreeListElem puts an allocated list element on the deleted element
  list, so it will be reused in a future allocation.

Arguments:

  Elem - Specifies the element to put on the deleted list.

Return Value:

  None.

--*/

{
    MYASSERT(Elem);
    MYASSERT(g_CurrentDatabase);

#ifdef DEBUG
    if (g_UseDebugStructs) {
        MYASSERT(Elem->Signature == LISTELEM_SIGNATURE);
    }
#endif

    Elem->NextDeleted = g_CurrentDatabase->FirstBinTreeListElemDeleted;
    g_CurrentDatabase->FirstBinTreeListElemDeleted = GetListElemOffset(Elem);
}


VOID
pBinTreeBalanceUpward (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeBalanceUpward makes sure that the specified node is balanced. If it
  is not balanced, the nodes are rotated as necessary, and balancing
  continues up the tree.

Arguments:

  Node - Specifies the node to balance

  TreeOffset - Specifies the offset of the binary tree containing Node

Return Value:

  None.

--*/

{
    PNODESTRUCT cur;
    PNODESTRUCT next;

    cur = Node;

    //
    // Move up tree.  stop if:
    //      a) hit top of tree
    //      b) pBinTreeNodeBalance returns FALSE (nothing changed)
    //

    while (cur) {
        //
        // need to grab cur's parent before balancing
        // cur because cur might change place in tree
        //

        next = GetNodeStruct (cur->Parent);

        if (!pBinTreeNodeBalance (cur, TreeOffset)) {
            return;
        }

        cur = next;
    }
}


BOOL
pBinTreeNodeBalance (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeNodeBalance checks the balance of the specified node, and if
  necessary, performs a rotation to balance the node. If a rotation was
  performed, the parent might become imbalanced.

Arguments:

  Node       - Specifies the node to balance
  TreeOffset - Specifies the offset to the binary tree that contains Node

Return Value:

  TRUE if a rotation was performed, FALSE if Node is already balanced

--*/

{
    UINT left;
    UINT right;
    PNODESTRUCT leftNode;
    PNODESTRUCT rightNode;

    if (!Node) {
        return FALSE;
    }

    leftNode  = GetNodeStruct (Node->Left);
    rightNode = GetNodeStruct (Node->Right);

    if (!rightNode) {
        right = 0;
    } else {
        right = MAX (rightNode->RightDepth, rightNode->LeftDepth) + 1;
    }

    if (!leftNode) {
        left = 0;
    } else {
        left = MAX (leftNode->RightDepth, leftNode->LeftDepth) + 1;
    }

    if (right == Node->RightDepth && left == Node->LeftDepth) {
        //
        // if node values have not changed, node is balanced
        //
        TESTNODETREE(Node);
        return FALSE;
    }

    MYASSERT (right < 126);
    MYASSERT (left < 126);

    Node->RightDepth = (WORD) right;
    Node->LeftDepth  = (WORD) left;

    if (Node->RightDepth > (Node->LeftDepth + 1)) {
        //
        // right heavy
        //

        pBinTreeRotateLeft (Node, TreeOffset);

    } else if (Node->LeftDepth > (Node->RightDepth + 1)) {
        //
        // left heavy
        //

        pBinTreeRotateRight (Node, TreeOffset);
    }

    return TRUE;
}


VOID
pBinTreeRotateLeft (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeRotateLeft performs a left rotation on Node, moving one node
  from the right side to the left side, in order to balance the node.

Arguments:

  Node       - Specifies the node to rotate left
  TreeOffset - Specifies the offset of the binary tree containing Node

Return Value:

  None.

--*/

{
    PNODESTRUCT newRoot;
    PNODESTRUCT parent;
    PNODESTRUCT right;
    UINT nodeOffset;
    UINT newRootOffset;

    if (!Node) {
        return;
    }

    MYASSERT (Node->Right != INVALID_OFFSET);

    nodeOffset = GetNodeOffset (Node);
    parent     = GetNodeStruct (Node->Parent);

    right = GetNodeStruct (Node->Right);

    //
    // make sure right side is heavier on outside
    //

    if (right->LeftDepth > right->RightDepth) {
        pBinTreeRotateRight (right, TreeOffset);
        PTR_WAS_INVALIDATED(right);
    }

    newRootOffset = Node->Right;
    newRoot = GetNodeStruct (newRootOffset);

    Node->Right = newRoot->Left;
    if (newRoot->Left != INVALID_OFFSET) {
        GetNodeStruct (newRoot->Left)->Parent = nodeOffset;
    }

    newRoot->Parent = Node->Parent;
    if (Node->Parent == INVALID_OFFSET) {
        pSetTreeRoot (GetBinTree (TreeOffset), newRootOffset);
    } else {
        if (parent->Left == nodeOffset) {
            parent->Left = newRootOffset;
        } else {
            parent->Right = newRootOffset;
        }
    }

    newRoot->Left = nodeOffset;
    Node->Parent = newRootOffset;

    pBinTreeNodeBalance (Node, TreeOffset);
    pBinTreeNodeBalance (newRoot, TreeOffset);
}


VOID
pBinTreeRotateRight (
    IN      PNODESTRUCT Node,
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  pBinTreeRotateRight performs a right rotation on Node, moving one node from
  the left side to the right side, in order to balance the node.

Arguments:

  Node       - Specifies the node to rotate left
  TreeOffset - Specifies the offset of the binary tree containing Node

Return Value:

  None.

--*/

{
    PNODESTRUCT newRoot;
    PNODESTRUCT parent;
    PNODESTRUCT left;
    UINT nodeOffset;
    UINT newRootOffset;

    if (!Node) {
        return;
    }

    MYASSERT (Node->Left != INVALID_OFFSET);

    nodeOffset = GetNodeOffset (Node);
    parent = GetNodeStruct (Node->Parent);

    left = GetNodeStruct (Node->Left);

    //
    // make sure left side is heavier on outside
    //

    if (left->RightDepth > left->LeftDepth) {
        pBinTreeRotateLeft (left, TreeOffset);
        PTR_WAS_INVALIDATED (left);
    }

    newRootOffset = Node->Left;
    newRoot = GetNodeStruct (newRootOffset);
    Node->Left = newRoot->Right;

    if (newRoot->Right != INVALID_OFFSET) {
        GetNodeStruct (newRoot->Right)->Parent = nodeOffset;
    }

    newRoot->Parent = Node->Parent;

    if (Node->Parent == INVALID_OFFSET) {
        pSetTreeRoot (GetBinTree (TreeOffset), newRootOffset);
    } else {
        if (parent->Left == nodeOffset) {
            parent->Left = newRootOffset;
        } else {
            parent->Right = newRootOffset;
        }
    }

    newRoot->Right = nodeOffset;
    Node->Parent = newRootOffset;

    pBinTreeNodeBalance (Node, TreeOffset);
    pBinTreeNodeBalance (newRoot, TreeOffset);

}


BOOL
BinTreeSetInsertionOrdered (
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeSetInsertionOrdered transforms a binary tree into an
  insertion-ordered link list.

Arguments:

  TreeOffset - Specifies the binary tree to make insertion-ordered

Return Value:

  TRUE if the tree was changed, FALSE if TreeOffset is not valid.

--*/

{
    PBINTREE tree;
    PNODESTRUCT node;
    PNODESTRUCT root;
    PNODESTRUCT header;
    PLISTELEM elem;
    PLISTELEM prevElem;
    UINT headerOffset;
    UINT offset;
    UINT nodeOffset;
    PBYTE buf;

    MYASSERT (g_CurrentDatabase);

    if (TreeOffset == INVALID_OFFSET) {
        return FALSE;
    }

    //
    // This is to test if allocations move buffer
    //
    buf = g_CurrentDatabase->Buf;

    tree = GetBinTree (TreeOffset);
    root = GetNodeStruct (tree->Root);

    if (root && root->InsertionHead) {
        return TRUE;
    }

    header = pBinTreeAllocNode (&headerOffset);
    if (!header) {
        return FALSE;
    }

    if (buf != g_CurrentDatabase->Buf) {
        PTR_WAS_INVALIDATED(tree);
        PTR_WAS_INVALIDATED(root);

        tree = GetBinTree (TreeOffset);
        root = GetNodeStruct (tree->Root);
        buf = g_CurrentDatabase->Buf;
    }

    INCTREENODES(tree);

    header->InsertionOrdered = TRUE;
    header->InsertionHead = TRUE;
    header->Data = tree->Root;
    header->Head = INVALID_OFFSET;
    header->Tail = INVALID_OFFSET;
    header->Parent = INVALID_OFFSET;
    tree->Root = headerOffset;

    if (root) {
        //
        // There is at least one node in tree, so create LISTELEMs
        //

        node = pBinTreeEnumFirst (tree);

        do {
            nodeOffset = GetNodeOffset (node);

            elem = pBinTreeAllocListElem (&offset);
            if (!elem) {
                return FALSE;
            }

            if (buf != g_CurrentDatabase->Buf) {
                PTR_WAS_INVALIDATED(tree);
                PTR_WAS_INVALIDATED(root);
                PTR_WAS_INVALIDATED(header);
                PTR_WAS_INVALIDATED(node);

                tree = GetBinTree (TreeOffset);
                header = GetNodeStruct (headerOffset);
                node = GetNodeStruct (nodeOffset);

                buf = g_CurrentDatabase->Buf;
            }

            INCTREEELEMS(tree);

            //
            // Update header element pointers
            //
            if (header->Head == INVALID_OFFSET) {
                header->Head = offset;
            }

            if (header->Tail != INVALID_OFFSET) {
                prevElem = GetListElem (header->Tail);
                prevElem->Next = offset;
            }

            header->Tail = offset;

            //
            // Set new LISTELEM members, and corresponding node members
            //

            elem->Data = node->Data;
            elem->Node = nodeOffset;
            elem->Next = INVALID_OFFSET;
            node->Data = offset;

            node->InsertionOrdered = 1;

            node = pBinTreeEnumNext (node);

        } while (node);
    }

    return TRUE;
}


UINT
pBinTreeSize (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeSize computes the number of nodes indicated by Node and all of its
  children.

Arguments:

  Node - Specifies the node to find the size of.

Return Value:

  The number of nodes represented by Node and its children.

--*/

{
    if (!Node) {
        return 0;
    }

    return (pBinTreeSize (GetNodeStruct (Node->Left)) ? 1 : 0) +
           (pBinTreeSize (GetNodeStruct (Node->Right)) ? 1 : 0) + 1;
}


UINT
BinTreeSize (
    IN      UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeSize returns the total number of nodes in the specified binary tree

Arguments:

  TreeOffset - Specifies the offset to the binary tree

Return Value:

  The number of nodes in the binary tree

--*/

{
    PBINTREE tree;

    if (TreeOffset == INVALID_OFFSET) {
        return 0;
    }

    tree = GetBinTree (TreeOffset);

    return pBinTreeSize (GetTreeRoot (tree));
}

#ifdef DEBUG


INT
pBinTreeMaxDepth (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeMaxDepth returns the number of nodes in the longest path. This
  function is used to find out how deep the tree is.

  This routine is recursive.

Arguments:

  Node - Specifies the node to compute the depth of.

Return Value:

  The number of nodes in the deepest path.

--*/

{
    INT leftDepth, rightDepth;

    if (Node == NULL) {
        return 0;
    }

    leftDepth = pBinTreeMaxDepth (GetNodeStruct (Node->Left));
    rightDepth = pBinTreeMaxDepth (GetNodeStruct (Node->Right));

    return MAX (leftDepth, rightDepth) + 1;
}


INT
BinTreeMaxDepth (
    UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeMaxDepth returns the total depth of the specified tree

Arguments:

  TreeOffset - Specifies the tree to compute the depth of

Return Value:

  The depth of the tree (in levels)

--*/

{
    PBINTREE tree;

    if (TreeOffset == INVALID_OFFSET) {
        return 0;
    }

    tree = GetBinTree (TreeOffset);

    return pBinTreeMaxDepth (GetTreeRoot (tree));
}


BOOL
pBinTreeCheckBalanceOfNode (
    IN      PNODESTRUCT Node,
    OUT     PINT Depth
    )

/*++

Routine Description:

  pBinTreeCheckBalanceOfNode verifies Node is balanced, and all of its
  children are also balanced.

  This function is recursive.

Arguments:

  Node - Specifies the node to check
  Depth - Receives the depth of the node

Return Value:

  TRUE if the node is balanced, FALSE otherwise

--*/

{
    INT lDepth = 0;
    INT rDepth = 0;
    BOOL flag = TRUE;

    if (!Node) {
        if (Depth) {
            *Depth = 0;
        }

        return TRUE;
    }

    flag = flag && pBinTreeCheckBalanceOfNode (GetNodeStruct (Node->Left), &lDepth);
    MYASSERT (flag);

    flag = flag && pBinTreeCheckBalanceOfNode (GetNodeStruct (Node->Right), &rDepth);
    MYASSERT (flag);

    flag = flag && ((INT) Node->LeftDepth == lDepth);
    MYASSERT (flag);

    flag = flag && ((INT) Node->RightDepth == rDepth);
    MYASSERT (flag);

    if (Depth != NULL) {
        *Depth = MAX (lDepth, rDepth) + 1;
    }

    flag = flag && (ABS ((lDepth - rDepth)) <= 1);
    MYASSERT (flag);

    return flag;
}


BOOL
pBinTreeCheckBalance (
    IN      PNODESTRUCT Node
    )

/*++

Routine Description:

  pBinTreeCheckBalance checks the balance of Node

Arguments:

  Node - Specifies the node to check the balance of

Return Value:

  TRUE if Node is balanced, FALSE otherwise.

--*/

{
    return pBinTreeCheckBalanceOfNode (Node, NULL);
}


BOOL
pBinTreeCheck (
    IN      PBINTREE Tree
    )

/*++

Routine Description:

  pBinTreeCheck checks if the binary tree is sorted and linked properly.  It
  enumerates the binary tree structure and compares the strings for proper
  order. If the tree is sorted properly, then the balance is checked.

Arguments:

  Tree - Specifies the tree to check

Return Value:

  TRUE if the binary tree is correct, FALSE otherwise.

--*/

{
    BOOL flag;
    PNODESTRUCT cur;
    PNODESTRUCT prev;

    prev = pBinTreeEnumFirst (Tree);

    if (Tree) {

        cur = pBinTreeEnumNext (prev);

        while (cur) {

            flag = (StringPasICompare (GetNodeDataStr(prev), GetNodeDataStr(cur)) < 0);
            MYASSERT(flag);

            if (!flag) {
                return FALSE;
            }

            prev = cur;
            cur = pBinTreeEnumNext (prev);
        }
    }

    return pBinTreeCheckBalance (GetTreeRoot (Tree));
}


BOOL
BinTreeCheck (
    UINT TreeOffset
    )

/*++

Routine Description:

  BinTreeCheck makes sure the specified binary tree is sorted and balanced
  properly

Arguments:

  TreeOffset - Specifies the offset of the tree to check

Return Value:

  TRUE if the tree is sorted properly, FALSE otherwise.

--*/

{
    PBINTREE tree;

    tree = GetBinTree (TreeOffset);

    return pBinTreeCheck (tree);
}





#include <stdio.h>
#include <math.h>

void indent (
    IN      UINT size)
{
    UINT i;
    for (i = 0; i < size; i++)
        wprintf (L" ");
}

INT turn (
    IN      UINT num,
    IN      UINT sel,
    IN      UINT width
    )
{
    UINT temp = num;

    MYASSERT (width > sel);

    if ((temp >> (width-sel-1)) & 1)
        return 1;
    else
        return -1;
}

#define SCREENWIDTH     64

void BinTreePrint(UINT TreeOffset)
{
    PNODESTRUCT cur;
    UINT i,j;
    UINT level=0;
    UINT numnodes,spacing;
    BOOL printed;
    PBINTREE tree;
    PWSTR str;
    UINT strsize,stringlen;
    tree = GetBinTree(TreeOffset);

    if (!GetTreeRoot(tree)) return;

    while (level<31)
    {
        printed=FALSE;

        if (level == 0) {
            numnodes = 1;
        } else {
            numnodes = (UINT)pow ((double)2, (double)level);
        }

        spacing=SCREENWIDTH / numnodes;

        for (i=0;i<numnodes;i++)
        {
            cur = GetTreeRoot(tree);
            j=0;
            while (j<level && cur!=NULL)
            {
                if (turn(i,j,level)<0)
                    cur = GetNodeStruct(cur->Left);
                else
                    cur = GetNodeStruct(cur->Right);
                j++;
            }

            if (cur==NULL) {
                indent(spacing);
            } else {
                str=GetNodeDataStr(cur);
                strsize=StringPasCharCount(str);
                StringPasConvertFrom(str);
                printed=TRUE;
                if (cur->LeftDepth==0 && cur->RightDepth==0) {
                    stringlen=strsize+1;
                    indent((spacing-stringlen)/2);
                    wprintf(L"%s ",str);
                } else {
                    stringlen=strsize+2;
                    indent((spacing-stringlen)/2);
                    wprintf(L"%s%1d%1d",str,cur->LeftDepth,cur->RightDepth);
                }
                indent(spacing-((spacing-stringlen)/2)-stringlen);
                StringPasConvertTo(str);
            }
        }

        wprintf(L"\n");
        if (!printed)
            break;
        level++;
    }
}



UINT BinTreeGetSizeOfStruct(DWORD Signature)
{
    switch (Signature)
    {
    case NODESTRUCT_SIGNATURE:
        return NODESTRUCT_SIZE;
    case BINTREE_SIGNATURE:
        return BINTREE_SIZE;
    case LISTELEM_SIGNATURE:
        return LISTELEM_SIZE;
    default:
        return 0;
    }
}


BOOL pBinTreeFindTreeInDatabase(UINT TreeOffset)
{
    PBINTREE Tree;

    if (!g_UseDebugStructs) {
        return TRUE;
    }
    if (TreeOffset==INVALID_OFFSET)
        return FALSE;

    Tree=GetBinTree(TreeOffset);

    if (Tree->Deleted) {
        return TRUE;
    }

    if (!GetTreeRoot(Tree)) {
        DEBUGMSG ((
            DBG_ERROR,
            "MemDbCheckDatabase: Binary tree at offset 0x%08lX is Empty!",
            TreeOffset
            ));
        return FALSE;
    }

    return BinTreeFindStructInDatabase(NODESTRUCT_SIGNATURE, GetNodeOffset(GetTreeRoot(Tree)));
}

BOOL pBinTreeFindNodeInDatabase(UINT NodeOffset)
{
    UINT Index;
    PNODESTRUCT Node;

    if (!g_UseDebugStructs) {
        return TRUE;
    }
    if (NodeOffset == INVALID_OFFSET)
        return FALSE;

    Node=GetNodeStruct(NodeOffset);
    if (Node->Deleted || Node->InsertionHead) {
        return TRUE;
    }

    Index = GetNodeData(Node);

    if (Index==INVALID_OFFSET) {

        DEBUGMSG ((
            DBG_ERROR,
            "MemDbCheckDatabase: Data of Node at offset 0x%8lX is Invalid!",
            NodeOffset
            ));
        return FALSE;
    }

    return FindKeyStructInDatabase(KeyIndexToOffset(Index));
}


BOOL BinTreeFindStructInDatabase(DWORD Sig, UINT Offset)
{
    switch (Sig)
    {
    case NODESTRUCT_SIGNATURE:
        return (pBinTreeFindNodeInDatabase(Offset));
    case BINTREE_SIGNATURE:
        return (pBinTreeFindTreeInDatabase(Offset));
    case LISTELEM_SIGNATURE:
        return TRUE;
    default:
        DEBUGMSG ((
            DBG_ERROR,
            "MemDbCheckDatabase: Invalid BinTree Struct!"
            ));
        printf("Invalid BinTree struct!\n");
    }
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\hash.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Hashing routines used to speed lookup of memdb keys.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    Jim Schmidt (jimschm) 21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"

#define DBG_MEMDB       "MemDb"



//
// #defines
//

#define HASH_BUCKETS    7001//4099
#define HASH_BLOCK_SIZE (HASH_BUCKETS * sizeof (BUCKETSTRUCT))
#define HASHBUFPTR(offset) ((PBUCKETSTRUCT) (pHashTable->Buf + offset))






typedef struct _tagHASHSTRUCT {
    UINT Offset;
    UINT NextItem;
} BUCKETSTRUCT, *PBUCKETSTRUCT;

typedef struct {
    PBUCKETSTRUCT BucketPtr;
    PBUCKETSTRUCT PrevBucketPtr;
    UINT Bucket;
    UINT LastOffset;
} HASHENUM, *PHASHENUM;


BOOL
EnumFirstHashEntry (
    IN      PMEMDBHASH pHashTable,
    OUT     PHASHENUM HashEnum
    );

BOOL
EnumNextHashEntry (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PHASHENUM HashEnum
    );


//
// Local privates
//

VOID
pResetHashBlock (
    IN      PMEMDBHASH pHashTable
    );


//
// Implementation
//

PMEMDBHASH
CreateHashBlock (
    VOID
    )
{
    PMEMDBHASH pHashTable;
    pHashTable = (PMEMDBHASH) MemAlloc (g_hHeap, 0, sizeof(MEMDBHASH));
    if (!pHashTable) {
        DEBUGMSG ((DBG_ERROR, "Could not allocate hash table!\n"));
        return NULL;
    }
    pHashTable->Size = HASH_BLOCK_SIZE * 2;

    pHashTable->Buf = (PBYTE) MemAlloc (g_hHeap, 0, pHashTable->Size);
    if (!pHashTable->Buf) {
        DEBUGMSG ((DBG_ERROR, "Could not allocate hash buffer!\n"));
        MemFree (g_hHeap, 0, pHashTable);
        return NULL;
    }
    pResetHashBlock(pHashTable);

    return pHashTable;
}


VOID
pResetHashBlock (
    IN      PMEMDBHASH pHashTable
    )
{
    PBUCKETSTRUCT BucketPtr;
    INT i;

    pHashTable->End = HASH_BLOCK_SIZE;
    pHashTable->FreeHead = INVALID_OFFSET;

    BucketPtr = (PBUCKETSTRUCT) pHashTable->Buf;
    for (i = 0 ; i < HASH_BUCKETS ; i++) {
        BucketPtr->Offset = INVALID_OFFSET;
        BucketPtr->NextItem = INVALID_OFFSET;
        BucketPtr++;
    }
}


VOID
FreeHashBlock (
    IN      PMEMDBHASH pHashTable
    )
{
    if (pHashTable->Buf) {
        MemFree (g_hHeap, 0, pHashTable->Buf);
    }

    MemFree (g_hHeap, 0, pHashTable);
}


BOOL
EnumFirstHashEntry (
    IN      PMEMDBHASH pHashTable,
    OUT     PHASHENUM EnumPtr
    )
{
    ZeroMemory (EnumPtr, sizeof (HASHENUM));

    return EnumNextHashEntry (pHashTable, EnumPtr);
}


BOOL
EnumNextHashEntry (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PHASHENUM EnumPtr
    )
{
    for (;;) {
        if (EnumPtr->Bucket == HASH_BUCKETS) {
            //
            // The completion case
            //

            return FALSE;
        }

        if (!EnumPtr->BucketPtr) {
            //
            // This case occurs when we are begining to enumerate a bucket
            //

            EnumPtr->BucketPtr = (PBUCKETSTRUCT) pHashTable->Buf + EnumPtr->Bucket;
            if (EnumPtr->BucketPtr->Offset == INVALID_OFFSET) {
                EnumPtr->BucketPtr = NULL;
                EnumPtr->Bucket += 1;
                continue;
            }

            //
            // Return this first item in the bucket
            //

            EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
            return TRUE;
        }

        //
        // This case occurs when we are continuing enumeration of a bucket
        //

        if (EnumPtr->BucketPtr->Offset == INVALID_OFFSET) {
            //
            // Current bucket item (and also the last bucket item) may have
            // been deleted -- check that now
            //

            if (!EnumPtr->PrevBucketPtr) {
                //
                // Last item has been deleted; continue to next bucket
                //

                EnumPtr->BucketPtr = NULL;
                EnumPtr->Bucket += 1;
                continue;
            }

            //
            // Previous bucket item is valid; use it.
            //

            EnumPtr->BucketPtr = EnumPtr->PrevBucketPtr;

        } else {
            //
            // Current bucket item may have been deleted, but another item was
            // moved to its place -- check that now
            //

            if (EnumPtr->BucketPtr->Offset != EnumPtr->LastOffset) {
                EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
                return TRUE;
            }
        }

        //
        // We now know that the current bucket item was not changed, so it
        // becomes our previous item and we move on to the next item (if
        // one exists)
        //

        if (EnumPtr->BucketPtr->NextItem == INVALID_OFFSET) {
            //
            // End of bucket reached
            //

            EnumPtr->BucketPtr = NULL;
            EnumPtr->Bucket += 1;
            continue;
        }

        EnumPtr->PrevBucketPtr = EnumPtr->BucketPtr;
        EnumPtr->BucketPtr = HASHBUFPTR (EnumPtr->BucketPtr->NextItem);


        EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
        MYASSERT(EnumPtr->LastOffset != INVALID_OFFSET);
        break;
    }

    return TRUE;
}



BOOL
WriteHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    )
{
    *(((PUINT)*Buf)++) = pHashTable->End;
    *(((PUINT)*Buf)++) = pHashTable->FreeHead;

    CopyMemory(*Buf, pHashTable->Buf, pHashTable->End);
    *Buf += pHashTable->End;

    return TRUE;
}


BOOL
ReadHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    )
{
    pHashTable->End = *(((PUINT)*Buf)++);
    pHashTable->FreeHead = *(((PUINT)*Buf)++);

    if (pHashTable->End > pHashTable->Size) {
        //
        // if the hash table in the file will not fit in the buffer
        // already allocated, free current buffer and allocate new one.
        //
        MemFree (g_hHeap, 0, pHashTable->Buf);
        pHashTable->Size = pHashTable->End;
        pHashTable->Buf = (PBYTE) MemAlloc (g_hHeap, 0, pHashTable->Size);
    }

    CopyMemory(pHashTable->Buf, *Buf, pHashTable->End);
    *Buf += pHashTable->End;
    return TRUE;
}

UINT GetHashTableBlockSize (
    IN      PMEMDBHASH pHashTable
    )
{
    return 2*sizeof(UINT) + pHashTable->End;
}


UINT
pCalculateHashVal (
    IN      PCWSTR String
    )
{
    UINT Hash = 0;

    while (*String) {
        Hash = (Hash << 5) | (Hash >> 29);
        Hash += towlower (*String);
        String++;
    }

    Hash %= HASH_BUCKETS;

    return Hash;
}

UINT
pAllocBucket (
    IN      PMEMDBHASH pHashTable
    )
{
    UINT rBucketOffset;
    PBYTE TempBuf;
    PBUCKETSTRUCT BucketPtr;

    if (pHashTable->FreeHead != INVALID_OFFSET) {
        rBucketOffset = pHashTable->FreeHead;
        BucketPtr = HASHBUFPTR (rBucketOffset);
        pHashTable->FreeHead = BucketPtr->NextItem;

        MYASSERT (rBucketOffset < pHashTable->End);
    } else {

        if (pHashTable->End + sizeof (BUCKETSTRUCT) > pHashTable->Size) {
            pHashTable->Size += HASH_BLOCK_SIZE;
            TempBuf = MemReAlloc (g_hHeap, 0, pHashTable->Buf, pHashTable->Size);
            DEBUGMSG ((DBG_NAUSEA, "Realloc'd memdb hash table"));

            if (!TempBuf) {
                DEBUGMSG ((DBG_ERROR, "Out of memory!"));
                pHashTable->Size -= HASH_BLOCK_SIZE;
                return INVALID_OFFSET;
            }

            pHashTable->Buf = TempBuf;
        }

        rBucketOffset = pHashTable->End;
        pHashTable->End += sizeof (BUCKETSTRUCT);

        BucketPtr = HASHBUFPTR (rBucketOffset);
    }

    BucketPtr->Offset = INVALID_OFFSET;
    BucketPtr->NextItem = INVALID_OFFSET;

    return rBucketOffset;
}


BOOL
AddHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString,
    IN      UINT Offset
    )
{
    UINT Bucket;
    PBUCKETSTRUCT BucketPtr, PrevBucketPtr;
    UINT BucketOffset;
    UINT NewOffset;
    UINT PrevBucketOffset;

    Bucket = pCalculateHashVal (FullString);
    BucketPtr = (PBUCKETSTRUCT) pHashTable->Buf + Bucket;

    //
    // See if root bucket item has been used or not
    //

    if (BucketPtr->Offset != INVALID_OFFSET) {
        //
        // Yes - add to end of the chain
        //

        BucketOffset = Bucket * sizeof (BUCKETSTRUCT);
        do {
            BucketPtr = HASHBUFPTR (BucketOffset);
            PrevBucketOffset = BucketOffset;
            BucketOffset = BucketPtr->NextItem;
        } while (BucketOffset != INVALID_OFFSET);


        //
        // Add to the chain
        //

        NewOffset = pAllocBucket(pHashTable);
        PrevBucketPtr = HASHBUFPTR (PrevBucketOffset);
        PrevBucketPtr->NextItem = NewOffset;

        if (NewOffset == INVALID_OFFSET) {
            return FALSE;
        }

        BucketPtr = HASHBUFPTR (NewOffset);
        MYASSERT (BucketPtr->NextItem == INVALID_OFFSET);
    }

    BucketPtr->Offset = Offset;

#ifdef DEBUG
    {
        UINT HashOffset;

        HashOffset = FindStringInHashTable (pHashTable, FullString);
        MYASSERT (HashOffset != INVALID_OFFSET);
        DEBUGMSG_IF ((HashOffset != Offset, DBG_MEMDB, "Duplicate in hash table: %s", FullString));
    }
#endif

    return TRUE;
}


PBUCKETSTRUCT
pFindBucketItemInHashTable (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString,
    OUT     PBUCKETSTRUCT *PrevBucketPtr,       OPTIONAL
    OUT     PUINT HashOffsetPtr                 OPTIONAL
    )
{
    UINT Bucket;
    UINT BucketOffset;
    PBUCKETSTRUCT BucketPtr = NULL;
    WCHAR TempStr[MEMDB_MAX];

    Bucket = pCalculateHashVal (FullString);
    BucketOffset = Bucket * sizeof (BUCKETSTRUCT);

#ifdef DEBUG
    {
        //
        // Circular link check
        //

        UINT Prev, Next;
        UINT Turtle, Rabbit;
        BOOL Even = FALSE;

        Rabbit = BucketOffset;
        Turtle = Rabbit;
        while (Rabbit != INVALID_OFFSET) {
            // Make rabbit point to next item in chain
            Prev = Rabbit;
            BucketPtr = HASHBUFPTR (Rabbit);
            Rabbit = BucketPtr->NextItem;

            // We should always be ahead of the turtle
            if (Rabbit == Turtle) {
                BucketPtr = HASHBUFPTR (Rabbit);
                Next = BucketPtr->NextItem;
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "Circular link detected in memdb hash table!  Turtle=%u, Rabbit=%u, Next=%u, Prev=%u",
                    Turtle,
                    Rabbit,
                    Next,
                    Prev
                    ));

                return NULL;
            }

            // Make turtle point to next item in chain (1 of every 2 passes)
            if (Even) {
                BucketPtr = HASHBUFPTR (Turtle);
                Turtle = BucketPtr->NextItem;
            }

            Even = !Even;
        }
    }
#endif

    BucketPtr = HASHBUFPTR (BucketOffset);

    if (PrevBucketPtr) {
        *PrevBucketPtr = BucketPtr;
    }

    //
    // If root bucket is not empty, scan bucket for FullString
    //

    if (BucketPtr->Offset != INVALID_OFFSET) {
        do  {

            BucketPtr = HASHBUFPTR (BucketOffset);
            //
            // Build string using offset
            //

            PrivateBuildKeyFromIndex (
                0,
                BucketPtr->Offset,
                TempStr,
                NULL,
                NULL,
                NULL
                );

            //
            // Do compare and return if match is found
            //

            if (StringIMatchW (FullString, TempStr)) {
                if (HashOffsetPtr) {
                    *HashOffsetPtr = BucketOffset;
                }
                return BucketPtr;
            }


            if (PrevBucketPtr) {
                *PrevBucketPtr = BucketPtr;
            }

            BucketOffset = BucketPtr->NextItem;

        } while (BucketOffset != INVALID_OFFSET);
    }

    return NULL;
}


UINT
FindStringInHashTable (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    )
{
    PBUCKETSTRUCT BucketPtr;

    BucketPtr = pFindBucketItemInHashTable (pHashTable, FullString, NULL, NULL);
    if (BucketPtr) {
        return BucketPtr->Offset;
    }

    return INVALID_OFFSET;
}


BOOL
RemoveHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    )
{
    PBUCKETSTRUCT BucketPtr;
    PBUCKETSTRUCT PrevBucketPtr;
    UINT NextOffset;
    PBUCKETSTRUCT NextBucketPtr;
    UINT BucketOffset;

    BucketPtr = pFindBucketItemInHashTable (pHashTable, FullString, &PrevBucketPtr, &BucketOffset);
    if (!BucketPtr) {
        return FALSE;
    }

    if (PrevBucketPtr != BucketPtr) {
        //
        // If not at the first level (prev != current), give the block
        // to free space.
        //

        PrevBucketPtr->NextItem = BucketPtr->NextItem;
        BucketPtr->NextItem = pHashTable->FreeHead;
        BucketPtr->Offset = INVALID_OFFSET;
        pHashTable->FreeHead = BucketOffset;

    } else {

        //
        // Invalidate next item pointer if at the first level
        //

        if (BucketPtr->NextItem != INVALID_OFFSET) {
            //
            // Copy next item to root array
            //

            NextOffset = BucketPtr->NextItem;
            NextBucketPtr = HASHBUFPTR (NextOffset);
            CopyMemory (BucketPtr, NextBucketPtr, sizeof (BUCKETSTRUCT));

            //
            // Donate next item to free space
            //

            NextBucketPtr->NextItem = pHashTable->FreeHead;
            NextBucketPtr->Offset = INVALID_OFFSET;
            pHashTable->FreeHead = NextOffset;


        } else {
            //
            // Delete of last item in bucket -- invalidate the root array item
            //

            BucketPtr->NextItem = INVALID_OFFSET;
            BucketPtr->Offset = INVALID_OFFSET;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\database.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    database.c

Abstract:

    Routines that manage the memdb database memory

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    calinn     12-Jan-2000  prepare for 5.1 release

--*/

//
// Includes
//

#include "pch.h"
#include "memdbp.h"

#define DBG_MEMDB       "MemDb"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

#define MAX_MEMDB_SIZE      0x80000000  //02 GB
#define INIT_BLOCK_SIZE     0x00010000  //64 KB

//
// Types
//

typedef struct {
    HANDLE hFile;
    HANDLE hMap;
    CHAR FileName[MAX_PATH];
    PDATABASE Database;
} DATABASECONTROL, *PDATABASECONTROL;

//
// Globals
//

BOOL g_DatabaseInitialized = FALSE;
DATABASECONTROL g_PermanentDatabaseControl;
DATABASECONTROL g_TemporaryDatabaseControl;
PDATABASE g_CurrentDatabase = NULL;
BYTE g_CurrentDatabaseIndex = DB_NOTHING;
PSTR g_CurrentDatabasePath = NULL;

#ifdef DEBUG

BOOL g_UseDebugStructs = TRUE;

#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
SelectDatabase (
    IN      BYTE DatabaseIndex
    )
{
    switch (DatabaseIndex) {
    case DB_PERMANENT:
        g_CurrentDatabase = g_PermanentDatabaseControl.Database;
        g_CurrentDatabaseIndex = DB_PERMANENT;
        break;
    case DB_TEMPORARY:
        g_CurrentDatabase = g_TemporaryDatabaseControl.Database;
        g_CurrentDatabaseIndex = DB_TEMPORARY;
        break;
    default:
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (g_CurrentDatabase == NULL) {
        SetLastError (ERROR_OPEN_FAILED);
        return FALSE;
    }

    return TRUE;
}

BOOL
pMapDatabaseFile (
    PDATABASECONTROL DatabaseControl
    )
{
    MYASSERT(DatabaseControl);

    DatabaseControl->Database = (PDATABASE) MapFileFromHandle (DatabaseControl->hFile, &DatabaseControl->hMap);

    return DatabaseControl->Database != NULL;
}

BOOL
pUnmapDatabaseFile (
    PDATABASECONTROL DatabaseControl
    )
{
    MYASSERT(DatabaseControl);

    UnmapFileFromHandle (
        (PBYTE)DatabaseControl->Database,
        DatabaseControl->hMap
        );

    DatabaseControl->hMap = NULL;
    DatabaseControl->Database = NULL;

    return TRUE;
}

BOOL
pGetTempFileName (
    IN OUT  PSTR FileName,
    IN      BOOL TryCurrent
    )
{
    PCHAR a, b;
    CHAR Extension[6];
    UINT Number = 0;

    a = (PCHAR) GetFileNameFromPathA (FileName);
    b = (PCHAR) GetDotExtensionFromPathA (FileName);

    if (!a) {
        a = (PCHAR) GetEndOfStringA (FileName);
    } else if (b && a<b && TryCurrent) {
        //
        // if we have a filename and we want to try the current file...
        //
        if (!DoesFileExistA (FileName)) {
            return TRUE;
        }
    }

    if (b) {
        StringCopyA (Extension, b);
        *b = 0;
    } else {
        b = (PCHAR) GetEndOfStringA (FileName);
        Extension [0] = 0;
    }

    if (a >= b) {       //lint !e613
        a = b;
        *(a++) = 'T';   //lint !e613
    } else {
        a++;            //lint !e613
    }

    if (a+7 == b) {
        b = a;
        while (*b) {
            if (*b < '0' || *b > '9') {
                break;
            }
            b++;
        }

        if (!(*b)) {
            Number = (UINT)atoi(a);
            Number++;
        }
    }

    do {
        if (Number > 9999999) {
            return FALSE;
        }

        wsprintfA (a, "%07lu", Number);
        StringCatA (a, Extension);
        Number++;
        if (!DoesFileExistA (FileName)) {
            return TRUE;
        }
    } while (TRUE);

    return TRUE;
}

BOOL
SizeDatabaseBuffer (
    IN      BYTE DatabaseIndex,
    IN      UINT NewSize
    )
/*++
Routine Description:

    SizeDatabaseBuffer will resize the file that backs up the existent allocated
    memory and will remap the file.

Arguments:

    DatabaseIndex - specifies which database we are talking about
    NewSize - specifies the new size of the buffer

Return Value:

    TRUE if the function succeeded, FALSE if not.

--*/

{
    DWORD bytes;
    BOOL resetCurrentDatabase = FALSE;
    PDATABASECONTROL databaseControl;

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        databaseControl = &g_PermanentDatabaseControl;
        break;
    case DB_TEMPORARY:
        databaseControl = &g_TemporaryDatabaseControl;
        break;
    default:
        return FALSE;
    }
    resetCurrentDatabase = (databaseControl->Database == g_CurrentDatabase);

    MYASSERT(databaseControl->hFile);

    if (databaseControl->Database) {
        //
        // if we already have a database, unmap current file from memory.
        //
        if (!pUnmapDatabaseFile (databaseControl)) {
            return FALSE;
        }
    }

    if (SetFilePointer(
            databaseControl->hFile,
            0,
            NULL,
            FILE_BEGIN
            ) == INVALID_SET_FILE_POINTER) {
        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot set file pointer"));
        return FALSE;
    }

    if (NewSize) {
        //
        // if size argument is not 0, fix file size indicator at beginning
        //
        if (!WriteFile (databaseControl->hFile, (PBYTE) &NewSize, sizeof (UINT), &bytes, NULL)) {
            return FALSE;
        }
    } else {
        //
        // if size argument is 0, that means look at first UINT in file
        // which is database->allocsize, and size the file to that size
        //
        if (!ReadFile (databaseControl->hFile, (PBYTE) &NewSize, sizeof (UINT), &bytes, NULL)) {
            return FALSE;
        }
    }

    // in the next call, we know that NewSize cannot exceed MAX_MEMDB_SIZE
    // which is 2GB (so casting an unsigned to a signed is safe).
    if (!SetSizeOfFile (databaseControl->hFile, (LONGLONG)NewSize)) {
        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot set size of file"));
        return FALSE;
    }

    //
    // now map file into memory, so everything can use ->Buf for access.
    //
    if (!pMapDatabaseFile(databaseControl)) {
        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot map database file to memory"));
        return FALSE;
    }

    MYASSERT(databaseControl->Database->AllocSize == NewSize);

    if (resetCurrentDatabase) {
        SelectDatabase (DatabaseIndex);
    }

    return TRUE;
}

UINT
DatabaseAllocBlock (
    UINT Size
    )

/*++
Routine Description:

    DatabaseAllocBlock allocates a block of memory in the single
    heap of size Size, expanding it if necessary.
    This function may move the database buffer.  Pointers
    into the database might not be valid afterwards.

Arguments:

    Size - size of block to allocate

Return Value:

    An offset to block that was allocated

--*/

{
    UINT blockSize;
    UINT offset;

    MYASSERT (g_CurrentDatabase);

    if (Size + g_CurrentDatabase->End + sizeof(DATABASE) > g_CurrentDatabase->AllocSize) {

        if (g_CurrentDatabase->AllocSize >= MAX_MEMDB_SIZE) {

            DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot allocate any more database memory (1)"));
            return INVALID_OFFSET;
        }

        blockSize = INIT_BLOCK_SIZE * (1 + (g_CurrentDatabase->AllocSize / (INIT_BLOCK_SIZE*8)));

        if (g_CurrentDatabase->AllocSize + blockSize > MAX_MEMDB_SIZE) {

            blockSize = MAX_MEMDB_SIZE - g_CurrentDatabase->AllocSize;
            
            if (blockSize < Size) {
                DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot allocate any more database memory (2)"));
                return INVALID_OFFSET;
            }
        }

        if (blockSize < Size) {
            // we want even more
            blockSize = INIT_BLOCK_SIZE * (1 + (Size / INIT_BLOCK_SIZE));
        }

        if (!SizeDatabaseBuffer (g_CurrentDatabaseIndex, g_CurrentDatabase->AllocSize + blockSize)) {

            DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot allocate any more database memory (2)"));
            return INVALID_OFFSET;
        }
    }

    offset = g_CurrentDatabase->End;
    g_CurrentDatabase->End += Size;

    return offset;
}

BOOL
pInitializeDatabase (
    IN      BYTE DatabaseIndex
    )
{
    PDATABASECONTROL databaseControl;

    MYASSERT (g_CurrentDatabasePath);

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        databaseControl = &g_PermanentDatabaseControl;
        StringCopyA (databaseControl->FileName, g_CurrentDatabasePath);
        StringCopyA (AppendWackA (databaseControl->FileName), "p0000000.db");
        break;
    case DB_TEMPORARY:
        databaseControl = &g_TemporaryDatabaseControl;
        StringCopyA (databaseControl->FileName, g_CurrentDatabasePath);
        StringCopyA (AppendWackA (databaseControl->FileName), "t0000000.db");
        break;
    default:
        return FALSE;
    }
    if (!pGetTempFileName (databaseControl->FileName, TRUE)) {
        DEBUGMSG ((
            DBG_ERROR,
            "MemDb Databases: Can't get temporary file name for %s",
            databaseControl->FileName
            ));
        return FALSE;
    }

    databaseControl->hMap = NULL;
    databaseControl->Database = NULL;
    databaseControl->hFile = BfCreateFileA (databaseControl->FileName);

    if (!databaseControl->hFile) {

        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot open database file"));
        return FALSE;

    }

    if ((!SizeDatabaseBuffer (DatabaseIndex, INIT_BLOCK_SIZE)) ||
        (databaseControl->Database == NULL)
        ) {

        DEBUGMSG ((DBG_ERROR, "MemDb Databases: Cannot initialize database"));
        CloseHandle (databaseControl->hFile);
        DeleteFileA (databaseControl->FileName);
        return FALSE;

    }

    databaseControl->Database->End = 0;
    databaseControl->Database->FirstLevelTree = INVALID_OFFSET;
    databaseControl->Database->FirstKeyDeleted = INVALID_OFFSET;
    databaseControl->Database->FirstBinTreeDeleted = INVALID_OFFSET;
    databaseControl->Database->FirstBinTreeNodeDeleted = INVALID_OFFSET;
    databaseControl->Database->FirstBinTreeListElemDeleted = INVALID_OFFSET;

    databaseControl->Database->HashTable = CreateHashBlock();
    MYASSERT (databaseControl->Database->HashTable);

    ZeroMemory (&databaseControl->Database->OffsetBuffer, sizeof (GROWBUFFER));
    databaseControl->Database->OffsetBufferFirstDeletedIndex = INVALID_OFFSET;

    return TRUE;
}

BOOL
pDestroyDatabase (
    IN      BYTE DatabaseIndex
    )
{
    PDATABASECONTROL databaseControl;

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        databaseControl = &g_PermanentDatabaseControl;
        break;
    case DB_TEMPORARY:
        databaseControl = &g_TemporaryDatabaseControl;
        break;
    default:
        return FALSE;
    }

    //
    // Free all resources for the database
    //
    if (databaseControl->Database) {

        FreeHashBlock (databaseControl->Database->HashTable);
        GbFree (&databaseControl->Database->OffsetBuffer);
    }

    pUnmapDatabaseFile (databaseControl);

    if (databaseControl->hFile) {
        CloseHandle (databaseControl->hFile);
        databaseControl->hFile = NULL;
    }

    DeleteFileA (databaseControl->FileName);

    ZeroMemory (databaseControl, sizeof (DATABASECONTROL));

    switch (DatabaseIndex) {
    case DB_PERMANENT:
        if (g_PermanentDatabaseControl.Database) {
            g_CurrentDatabase = g_TemporaryDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_TEMPORARY;
        } else {
            g_CurrentDatabase = NULL;
            g_CurrentDatabaseIndex = DB_NOTHING;
        }
        break;
    case DB_TEMPORARY:
        if (g_PermanentDatabaseControl.Database) {
            g_CurrentDatabase = g_PermanentDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_PERMANENT;
        } else {
            g_CurrentDatabase = NULL;
            g_CurrentDatabaseIndex = DB_NOTHING;
        }
        break;
    default:
        return FALSE;
    }

    return g_CurrentDatabase != NULL;
}

BOOL
pDatabasesInitialize (
    IN      PCSTR DatabasePath  OPTIONAL
    )
{
    DWORD databasePathSize = 0;

    g_CurrentDatabase = NULL;
    g_CurrentDatabaseIndex = DB_NOTHING;

    if (DatabasePath) {
        g_CurrentDatabasePath = DuplicatePathStringA (DatabasePath, 0);
    } else {
        databasePathSize = GetCurrentDirectoryA (0, NULL);
        if (databasePathSize == 0) {
            return FALSE;
        }
        g_CurrentDatabasePath = AllocPathStringA (databasePathSize + 1);
        databasePathSize = GetCurrentDirectoryA (databasePathSize, g_CurrentDatabasePath);
        if (databasePathSize == 0) {
            FreePathStringA (g_CurrentDatabasePath);
            g_CurrentDatabasePath = NULL;
            return FALSE;
        }
    }

    //
    // Empty the database memory block
    //
    ZeroMemory (&g_PermanentDatabaseControl, sizeof (DATABASECONTROL));
    if (!pInitializeDatabase (DB_PERMANENT)) {
        return FALSE;
    }
    ZeroMemory (&g_TemporaryDatabaseControl, sizeof (DATABASECONTROL));
    if (!pInitializeDatabase (DB_TEMPORARY)) {
        pDestroyDatabase (DB_PERMANENT);
        return FALSE;
    }

    g_DatabaseInitialized = TRUE;

    return SelectDatabase (DB_PERMANENT);
}

BOOL
DatabasesInitializeA (
    IN      PCSTR DatabasePath  OPTIONAL
    )
{
    return pDatabasesInitialize (DatabasePath);
}

BOOL
DatabasesInitializeW (
    IN      PCWSTR DatabasePath  OPTIONAL
    )
{
    PCSTR databasePath = NULL;
    BOOL result = FALSE;

    if (DatabasePath) {
        databasePath = ConvertWtoA (DatabasePath);
    }
    result = pDatabasesInitialize (databasePath);
    if (databasePath) {
        FreeConvertedStr (databasePath);
        databasePath = NULL;
    }
    return result;
}

VOID
DatabasesTerminate (
    IN      BOOL EraseDatabasePath
    )
{
    if (g_DatabaseInitialized) {

        //
        // Free all database blocks
        //

        pDestroyDatabase (DB_TEMPORARY);
        pDestroyDatabase (DB_PERMANENT);

        g_CurrentDatabase = NULL;
        g_CurrentDatabaseIndex = DB_NOTHING;
    }
    if (g_CurrentDatabasePath) {
        if (EraseDatabasePath) {
            if (!FiRemoveAllFilesInTreeA (g_CurrentDatabasePath)) {
                DEBUGMSG ((
                    DBG_ERROR,
                    "Can't remove all files in temporary directory %s",
                    g_CurrentDatabasePath
                    ));
            }
        }
        FreePathStringA (g_CurrentDatabasePath);
        g_CurrentDatabasePath = NULL;
    }
    ELSE_DEBUGMSG ((DBG_MEMDB, "DatabaseTerminate: no database path was set"));
}

PCSTR
DatabasesGetBasePath (
    VOID
    )
{
    return g_CurrentDatabasePath;
}

PCWSTR
SelectHiveW (
    IN      PCWSTR FullKeyStr
    )
{
    PCWSTR result = FullKeyStr;

    if (FullKeyStr) {

        switch (FullKeyStr[0]) {
        case L'~':
            g_CurrentDatabase = g_TemporaryDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_TEMPORARY;
            result ++;
            break;
        default:
            g_CurrentDatabase = g_PermanentDatabaseControl.Database;
            g_CurrentDatabaseIndex = DB_PERMANENT;
        }
    }

    if (!g_CurrentDatabase) {
        SetLastError (ERROR_OPEN_FAILED);
        return NULL;
    }

    return result;
}

BYTE
GetCurrentDatabaseIndex (
    VOID
    )
{
    return g_CurrentDatabaseIndex;
}


#ifdef DEBUG
#include "bintree.h"

UINT g_DatabaseCheckLevel = 0;

BOOL
CheckDatabase (
    IN      UINT Level
    )
{
    UINT offset,currOffset;
    BOOL deleted;
    PKEYSTRUCT keyStruct, newStruct;
    PDWORD signature;
    UINT blockSize;

    MYASSERT (g_CurrentDatabase);

    if (Level >= MEMDB_CHECKLEVEL1) {

        // first let's walk the deleted structures making sure that the signature is good
        offset = g_CurrentDatabase->FirstKeyDeleted;

        while (offset != INVALID_OFFSET) {

            keyStruct = GetKeyStructFromOffset (offset);
            MYASSERT (keyStruct);

            if (keyStruct->Signature != KEYSTRUCT_SIGNATURE) {
                DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", offset));
                return FALSE;
            }
            offset = keyStruct->NextDeleted;
        }
    }

    if (Level >= MEMDB_CHECKLEVEL2) {

        // now let's look in the offset array and examine all keystructs pointed from there
        offset = 0;
        while (offset < g_CurrentDatabase->OffsetBuffer.End) {

            // now let's look if offset is deleted or not
            deleted = FALSE;
            currOffset = g_CurrentDatabase->OffsetBufferFirstDeletedIndex;
            while (currOffset != INVALID_OFFSET) {
                if (currOffset == offset) {
                    deleted = TRUE;
                    break;
                }
                currOffset = *(PUINT)(g_CurrentDatabase->OffsetBuffer.Buf + currOffset);
            }

            if (!deleted) {

                keyStruct = GetKeyStruct (GET_INDEX (offset));
                if (!keyStruct) {
                    DEBUGMSG ((DBG_ERROR, "Invalid offset found: 0x%8X!", GET_INDEX (offset)));
                    return FALSE;
                }
                if (keyStruct->Signature != KEYSTRUCT_SIGNATURE) {
                    DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", GET_INDEX(offset)));
                    return FALSE;
                }
                if (keyStruct->DataStructIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->DataStructIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->DataStructIndex));
                        return FALSE;
                    }
                }
                if (keyStruct->NextLevelTree != INVALID_OFFSET) {
                    if (!BinTreeCheck (keyStruct->NextLevelTree)) {
                        DEBUGMSG ((DBG_ERROR, "Invalid Binary tree found at offset: 0x%8X", keyStruct->NextLevelTree));
                        return FALSE;
                    }
                }
                if (keyStruct->PrevLevelIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->PrevLevelIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->PrevLevelIndex));
                        return FALSE;
                    }
                }
            }
            offset += SIZEOF (UINT);
        }
    }

    if (Level >= MEMDB_CHECKLEVEL3) {

        // now let's walk the actual database buffer looking for all valid structures stored here
        offset = 0;

        while (offset < g_CurrentDatabase->End) {

            signature = (PDWORD)OFFSET_TO_PTR (offset);

            switch (*signature) {
            case KEYSTRUCT_SIGNATURE:
                if (!FindKeyStructInDatabase (offset)) {
                    DEBUGMSG ((DBG_ERROR, "Could not find KeyStruct (Offset 0x%lX) in database or deleted list!", offset));
                    return FALSE;
                }
                keyStruct = GetKeyStructFromOffset (offset);
                if (keyStruct->DataStructIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->DataStructIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->DataStructIndex));
                        return FALSE;
                    }
                }
                if (keyStruct->NextLevelTree != INVALID_OFFSET) {
                    if (!BinTreeCheck (keyStruct->NextLevelTree)) {
                        DEBUGMSG ((DBG_ERROR, "Invalid Binary tree found at offset: 0x%8X", keyStruct->NextLevelTree));
                        return FALSE;
                    }
                }
                if (keyStruct->PrevLevelIndex != INVALID_OFFSET) {
                    newStruct = GetKeyStruct (keyStruct->PrevLevelIndex);
                    if (newStruct->Signature != KEYSTRUCT_SIGNATURE) {
                        DEBUGMSG ((DBG_ERROR, "Invalid KEYSTRUCT signature found at offset: 0x%8X", keyStruct->PrevLevelIndex));
                        return FALSE;
                    }
                }
                blockSize = keyStruct->Size;
                break;
            case NODESTRUCT_SIGNATURE:
            case BINTREE_SIGNATURE:
            case LISTELEM_SIGNATURE:
                if (!BinTreeFindStructInDatabase (*signature, offset)) {
                    DEBUGMSG ((DBG_ERROR, "Could not find BinTree struct (Offset 0x%lX) in database or deleted list!", offset));
                    return FALSE;
                }
                blockSize = BinTreeGetSizeOfStruct(*signature);
                break;
            default:
                DEBUGMSG ((DBG_ERROR, "Invalid structure found in database buffer!"));
                return FALSE;
            }

            if (blockSize==0) {
                DEBUGMSG ((DBG_ERROR, "Invalid block size found in database buffer!"));
                return FALSE;
            }

            offset += blockSize;
        }
    }
    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\main\wnd.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wnd.c

Abstract:

    Utilities for window management

Author:

    Jim Schmidt (jimschm)   01-Feb-2000

Revision History:


--*/

//
// Includes
//

#include "pch.h"


#define DBG_WND         "Wnd"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCSTR WindowTitle;
    DWORD ProcessId;
    HWND Match;
} FINDWINDOW_STRUCTA, *PFINDWINDOW_STRUCTA;

typedef struct {
    PCWSTR WindowTitle;
    DWORD ProcessId;
    HWND Match;
} FINDWINDOW_STRUCTW, *PFINDWINDOW_STRUCTW;

//
// Globals
//

static INT g_CursorRefCount = 0;
static HCURSOR g_OldCursor = NULL;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
CALLBACK
pEnumWndProcA (
    HWND hwnd,
    LPARAM lParam
    )

/*++

Routine Description:

  A callback that is called for every top level window on the system. It is
  used with pFindParentWindow to locate a specific window.

Arguments:

  hwnd      - Specifies the handle of the current enumerated window
  lParam    - Specifies a pointer to a FINDWINDOW_STRUCTA variable that
              holds WindowTitle and ProcessId, and receives the
              handle if a match is found.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    CHAR title[MAX_MBCHAR_PATH];
    DWORD processId;
    PFINDWINDOW_STRUCTA p;
    BOOL match = FALSE;

    p = (PFINDWINDOW_STRUCTA) lParam;

    if (!GetWindowThreadProcessId (hwnd, &processId)) {
        DEBUGMSG ((DBG_WND, "Enumerated hwnd no longer valid"));
        return TRUE;
    }

    if (processId == p->ProcessId) {
        match = TRUE;
    }

    if (p->WindowTitle) {

        GetWindowTextA (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Testing window: %s, ID=%08Xh against %s, %08Xh",
            title,
            processId,
            p->WindowTitle,
            p->ProcessId
            ));

        match = match && StringMatchA (title, p->WindowTitle);
    }
    ELSE_DEBUGMSGA ((
        DBG_NAUSEA,
        "Testing window: Process ID=%08Xh against %08Xh",
        processId,
        p->ProcessId
        ));


    if (match) {
        p->Match = hwnd;

#ifdef DEBUG
        //
        // Get the window title for the following debug message
        //

        GetWindowTextA (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Window found: %s, ID=%u",
            title,
            processId
            ));
#endif

        return FALSE;           // stop enum

    }

    return TRUE;        // continue enum
}


BOOL
CALLBACK
pEnumWndProcW (
    HWND hwnd,
    LPARAM lParam
    )

{
    WCHAR title[MAX_MBCHAR_PATH];
    DWORD processId;
    PFINDWINDOW_STRUCTW p;
    BOOL match = FALSE;

    p = (PFINDWINDOW_STRUCTW) lParam;

    if (!GetWindowThreadProcessId (hwnd, &processId)) {
        DEBUGMSG ((DBG_WND, "Enumerated hwnd no longer valid"));
        return TRUE;
    }

    if (processId == p->ProcessId) {
        match = TRUE;
    }

    if (p->WindowTitle) {

        GetWindowTextW (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGW ((
            DBG_NAUSEA,
            "Testing window: %s, ID=%08Xh against %s, %08Xh",
            title,
            processId,
            p->WindowTitle,
            p->ProcessId
            ));

        match = match && StringMatchW (title, p->WindowTitle);
    }
    ELSE_DEBUGMSGW ((
        DBG_NAUSEA,
        "Testing window: Process ID=%08Xh against %08Xh",
        processId,
        p->ProcessId
        ));


    if (match) {
        p->Match = hwnd;

#ifdef DEBUG
        //
        // Get the window title for the following debug message
        //

        GetWindowTextW (hwnd, title, ARRAYSIZE(title));

        DEBUGMSGA ((
            DBG_NAUSEA,
            "Window found: %s, ID=%u",
            title,
            processId
            ));
#endif

        return FALSE;           // stop enum

    }

    return TRUE;        // continue enum
}


HWND
WndFindWindowInProcessA (
    IN      DWORD ProcessId,
    IN      PCSTR WindowTitle          OPTIONAL
    )

/*++

Routine Description:

  Finds a window by enumerating all top-level windows, and checking the
  process id. The first one to match the optionally supplied title is used.

Arguments:

  ProcessId     - Specifies the ID of the process who owns the window.  If
                  zero is specified, NULL is returned.
  WindowTitle   - Specifies the name of the window to find.

Return Value:

  The handle to the matching window, or NULL if no window has the
  specified title and process ID.

--*/

{
    FINDWINDOW_STRUCTA findWndStruct;

    //
    // If no process ID, we cannot have a match
    //

    if (!ProcessId) {
        DEBUGMSG ((DBG_WND, "ProcessId == 0"));
        return NULL;
    }

    ZeroMemory (&findWndStruct, sizeof (findWndStruct));

    findWndStruct.WindowTitle = WindowTitle;
    findWndStruct.ProcessId   = ProcessId;

    EnumWindows (pEnumWndProcA, (LPARAM) &findWndStruct);

    return findWndStruct.Match;
}


HWND
WndFindWindowInProcessW (
    IN      DWORD ProcessId,
    IN      PCWSTR WindowTitle         OPTIONAL
    )
{
    FINDWINDOW_STRUCTW findWndStruct;

    //
    // If no process ID, we cannot have a match
    //

    if (!ProcessId) {
        DEBUGMSG ((DBG_WND, "ProcessId == 0"));
        return NULL;
    }

    ZeroMemory (&findWndStruct, sizeof (findWndStruct));

    findWndStruct.WindowTitle = WindowTitle;
    findWndStruct.ProcessId   = ProcessId;

    EnumWindows (pEnumWndProcW, (LPARAM) &findWndStruct);

    return findWndStruct.Match;
}


#define WIDTH(rect) (rect.right - rect.left)
#define HEIGHT(rect) (rect.bottom - rect.top)

VOID
WndCenterWindow (
    IN      HWND hwnd,
    IN      HWND Parent         OPTIONAL
    )
{
    RECT WndRect, ParentRect;
    int x, y;

    if (!Parent) {
        ParentRect.left = 0;
        ParentRect.top  = 0;
        ParentRect.right = GetSystemMetrics (SM_CXFULLSCREEN);
        ParentRect.bottom = GetSystemMetrics (SM_CYFULLSCREEN);
    } else {
        GetWindowRect (Parent, &ParentRect);
    }

    MYASSERT (IsWindow (hwnd));

    GetWindowRect (hwnd, &WndRect);

    x = ParentRect.left + (WIDTH(ParentRect) - WIDTH(WndRect)) / 2;
    y = ParentRect.top + (HEIGHT(ParentRect) - HEIGHT(WndRect)) / 2;

    SetWindowPos (hwnd, NULL, x, y, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}


VOID
WndTurnOnWaitCursor (
    VOID
    )

/*++

Routine Description:

  WndTurnOnWaitCursor sets the cursor to IDC_WAIT.  It maintains a use
  counter, so code requring the wait cursor can be nested.

Arguments:

  none

Return Value:

  none

--*/

{
    if (g_CursorRefCount == 0) {
        g_OldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
    }

    g_CursorRefCount++;
}


VOID
WndTurnOffWaitCursor (
    VOID
    )

/*++

Routine Description:

  WndTurnOffWaitCursor decrements the wait cursor counter, and if it reaches
  zero the cursor is restored.

Arguments:

  none

Return Value:

  none

--*/

{
    if (!g_CursorRefCount) {
        DEBUGMSG ((DBG_WHOOPS, "TurnOffWaitCursor called too many times"));
    } else {
        g_CursorRefCount--;

        if (!g_CursorRefCount) {
            SetCursor (g_OldCursor);
        }
    }
}


VOID
WndSetWizardButtonsA (
    IN      HWND PageHandle,
    IN      DWORD EnableButtons,
    IN      DWORD DisableButtons,
    IN      PCSTR AlternateFinishText       OPTIONAL
    )
{
    DWORD flags = 0;
    HWND wizardHandle;

    wizardHandle = GetParent (PageHandle);

    if (EnableButtons & FINISH_BUTTON) {

        MYASSERT (!(EnableButtons & CANCEL_BUTTON));
        MYASSERT (!(EnableButtons & NEXT_BUTTON));
        MYASSERT (!(DisableButtons & CANCEL_BUTTON));
        MYASSERT (!(DisableButtons & NEXT_BUTTON));
        MYASSERT (!(DisableButtons & FINISH_BUTTON));

        EnableButtons &= ~(CANCEL_BUTTON|NEXT_BUTTON);
        DisableButtons &= ~(CANCEL_BUTTON|NEXT_BUTTON);

        flags |= PSWIZB_FINISH;
    }

    if (DisableButtons & FINISH_BUTTON) {

        MYASSERT (!(EnableButtons & CANCEL_BUTTON));
        MYASSERT (!(EnableButtons & NEXT_BUTTON));
        MYASSERT (!(DisableButtons & CANCEL_BUTTON));
        MYASSERT (!(DisableButtons & NEXT_BUTTON));

        EnableButtons &= ~(CANCEL_BUTTON|NEXT_BUTTON);
        DisableButtons &= ~(CANCEL_BUTTON|NEXT_BUTTON);

        flags |= PSWIZB_DISABLEDFINISH;
    }

    if (EnableButtons & NEXT_BUTTON) {
        MYASSERT (!(DisableButtons & NEXT_BUTTON));
        flags |= PSWIZB_NEXT;
    }

    if (EnableButtons & BACK_BUTTON) {
        MYASSERT (!(DisableButtons & BACK_BUTTON));
        flags |= PSWIZB_BACK;
    }

    if (DisableButtons & NEXT_BUTTON) {
        flags &= ~PSWIZB_NEXT;
    }

    if (DisableButtons & BACK_BUTTON) {
        flags &= ~PSWIZB_BACK;
    }

    PropSheet_SetWizButtons (wizardHandle, flags);

    if (EnableButtons & CANCEL_BUTTON) {
        EnableWindow (GetDlgItem (wizardHandle, IDCANCEL), TRUE);
    }

    if (DisableButtons & CANCEL_BUTTON) {
        EnableWindow (GetDlgItem (wizardHandle, IDCANCEL), FALSE);
    }

    if (AlternateFinishText) {
        if (flags & PSWIZB_FINISH) {
            SendMessage (
                wizardHandle,
                PSM_SETFINISHTEXT,
                0,
                (LPARAM) AlternateFinishText
                );
        }
    }

}


VOID
WndSetWizardButtonsW (
    IN      HWND PageHandle,
    IN      DWORD EnableButtons,
    IN      DWORD DisableButtons,
    IN      PCWSTR AlternateFinishText      OPTIONAL
    )
{
    PCSTR ansiText;

    if (AlternateFinishText) {
        ansiText = ConvertWtoA (AlternateFinishText);
        WndSetWizardButtonsA (PageHandle, EnableButtons, DisableButtons, ansiText);
        FreeConvertedStr (ansiText);
    } else {
        WndSetWizardButtonsA (PageHandle, EnableButtons, DisableButtons, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\keydata.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    keydata.c

Abstract:

    Routines that manage data for the memdb key structures.

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:


--*/

#include "pch.h"
#include "memdbp.h"






//
// KeyStruct Data Functions
//


BOOL
KeyStructSetValue (
    IN      UINT KeyIndex,
    IN      UINT Value
    )

/*++

Routine Description:

  sets the value for a key

Arguments:

  KeyIndex - index of key
  Value - value to put in key

Return Value:

  TRUE if successful

--*/

{
    PKEYSTRUCT KeyStruct;

    KeyStruct = GetKeyStruct(KeyIndex);
    MYASSERT(KeyStruct);

    KeyStruct->Value = Value;

    KeyStruct->DataFlags |= DATAFLAG_VALUE;

    return TRUE;
}

BOOL
KeyStructSetFlags (
    IN      UINT KeyIndex,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  sets the flags for a key

Arguments:

  KeyIndex      - index of key
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PKEYSTRUCT KeyStruct;

    KeyStruct = GetKeyStruct(KeyIndex);
    MYASSERT(KeyStruct);

    if (KeyStruct->DataFlags & DATAFLAG_FLAGS) {
        if (ReplaceFlags) {
            KeyStruct->Flags = SetFlags;
        } else {
            KeyStruct->Flags &= ~ClearFlags;
            KeyStruct->Flags |= SetFlags;
        }
    } else {
        KeyStruct->Flags = SetFlags;
        KeyStruct->DataFlags |= DATAFLAG_FLAGS;
    }
    return TRUE;
}

// LINT - in the next function keystruct is thought to be possibly NULL.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e794

UINT g_TotalData = 0;

UINT
pAllocateNewDataStruct (
    IN      UINT DataSize,
    IN      UINT AltDataSize
    )

/*++

Routine Description:

  pAllocateNewDataStruct allocates a block of memory in the single
  heap, for holding a data structure.

Arguments:

  DataSize       - Size of the binary data that needs to be stored here

Return Value:

  An Index to the new structure.

--*/

{
    UINT size;
    PKEYSTRUCT keyStruct = NULL;
    UINT offset;
    UINT prevDel;
    UINT result;

    MYASSERT (g_CurrentDatabase);

    size = DataSize + KEYSTRUCT_SIZE;

    //
    // Look for free block
    //
    prevDel = INVALID_OFFSET;
    offset = g_CurrentDatabase->FirstKeyDeleted;

    while (offset != INVALID_OFFSET) {
        keyStruct = GetKeyStructFromOffset (offset);
        MYASSERT (keyStruct);
        if ((keyStruct->Size >= size) && (keyStruct->Size < (size + ALLOC_TOLERANCE))) {
            break;
        }

        prevDel = offset;
        offset = keyStruct->NextDeleted;
    }

    if (offset == INVALID_OFFSET) {
        //
        // We could not find one so we need to allocate a new block
        //
        g_TotalData ++;

        offset = DatabaseAllocBlock (size + AltDataSize);
        if (offset == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

#ifdef DEBUG
        //
        // if we are in debug mode, and we are using debug structs, set
        // pointer normally and set Signature DWORD.  if we are not using
        // debug structs, then set pointer to 4 bytes below actual offset,
        // so all members are shifted down.
        //
        if (g_UseDebugStructs) {
            keyStruct = (PKEYSTRUCT)OFFSET_TO_PTR (offset);
            keyStruct->Signature = KEYSTRUCT_SIGNATURE;
        } else {
            keyStruct = (PKEYSTRUCT)OFFSET_TO_PTR (offset - KEYSTRUCT_HEADER_SIZE);
        }
#else
        keyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(offset);
#endif

        keyStruct->Size = size + AltDataSize;
    } else {
        //
        // Delink free block if recovering free space
        //
        if (prevDel != INVALID_OFFSET) {
            GetKeyStructFromOffset (prevDel)->NextDeleted = keyStruct->NextDeleted;
        } else {
            g_CurrentDatabase->FirstKeyDeleted = keyStruct->NextDeleted;
        }
#ifdef DEBUG
        keyStruct->KeyFlags &= ~KSF_DELETED;
#endif
    }

    //
    // Init new block
    //
    keyStruct->DataSize = DataSize;
    keyStruct->DataStructIndex = INVALID_OFFSET;
    keyStruct->NextLevelTree = INVALID_OFFSET;
    keyStruct->PrevLevelIndex = INVALID_OFFSET;
    keyStruct->Flags = 0;
    keyStruct->KeyFlags = KSF_DATABLOCK;
    keyStruct->DataFlags = 0;

    result = AddKeyOffsetToBuffer (offset);

    return result;
}
//lint -restore

UINT
KeyStructAddBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  KeyStructAddBinaryData adds a certain type of binary data to a key
  if it doesn't exist yet. If it does, the function fails.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data
  Data      - pointer to the data
  DataSize  - size of data

Return Value:

  A valid data handle if successfull, INVALID_OFFSET otherwise.

--*/

{
    PKEYSTRUCT prevStruct,dataStruct,nextStruct,keyStruct;
    UINT dataIndex, prevIndex;
    BOOL found = FALSE;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;
    prevIndex = KeyIndex;
    prevStruct = keyStruct;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        prevIndex = dataIndex;
        prevStruct = dataStruct;
        dataIndex = dataStruct->DataStructIndex;
    }

    if (found) {
        return INVALID_OFFSET;
    }

    dataIndex = pAllocateNewDataStruct (DataSize, 0);

    if (dataIndex == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);
    prevStruct = GetKeyStruct (prevIndex);
    MYASSERT (prevStruct);

    dataStruct = GetKeyStruct (dataIndex);
    MYASSERT (dataStruct);

    keyStruct->DataFlags |= Type;
    dataStruct->DataFlags |= Type;
    dataStruct->DataFlags |= Instance;
    CopyMemory (dataStruct->Data, Data, DataSize);

    dataStruct->DataStructIndex = prevStruct->DataStructIndex;
    dataStruct->PrevLevelIndex = prevIndex;
    prevStruct->DataStructIndex = dataIndex;

    if (dataStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
        MYASSERT (nextStruct);
        nextStruct->PrevLevelIndex = dataIndex;
    }

    return dataIndex;
}

// LINT - in the next function keystruct is thought to be possibly NULL.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e771
UINT
KeyStructGrowBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  KeyStructGrowBinaryData appends a certain type of binary data to a key
  if it does exist. If it doesn't, the new data is added.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data
  Data      - pointer to the data
  DataSize  - size of data

Return Value:

  A valid data handle if successfull, INVALID_OFFSET otherwise.

--*/

{
    PKEYSTRUCT prevStruct;
    PKEYSTRUCT dataStruct;
    PKEYSTRUCT keyStruct;
    PKEYSTRUCT nextStruct;
    PKEYSTRUCT newStruct;
    UINT dataIndex;
    UINT newIndex;
    UINT prevIndex;
    BOOL found = FALSE;

    MYASSERT (g_CurrentDatabase);

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;
    prevStruct = keyStruct;
    prevIndex = KeyIndex;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        prevStruct = dataStruct;
        prevIndex = dataIndex;
        dataIndex = dataStruct->DataStructIndex;
    }

    if ((dataIndex == INVALID_OFFSET) || (!found)) {
        return KeyStructAddBinaryData (KeyIndex, Type, Instance, Data, DataSize);
    }

    if (dataStruct->Size >= KEYSTRUCT_SIZE + DataSize + dataStruct->DataSize) {

        CopyMemory (dataStruct->Data + dataStruct->DataSize, Data, DataSize);
        dataStruct->DataSize += DataSize;
        return dataIndex;

    } else {

        newIndex = pAllocateNewDataStruct (DataSize + dataStruct->DataSize, min (dataStruct->DataSize, 65536));

        if (newIndex == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

        // now we need to reget all keystructs used so far because the database
        // might have moved
        keyStruct = GetKeyStruct (KeyIndex);
        MYASSERT (keyStruct);
        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);
        prevStruct = GetKeyStruct (prevIndex);
        MYASSERT (prevStruct);

        newStruct = GetKeyStruct (newIndex);
        MYASSERT (newStruct);

        newStruct->DataSize = dataStruct->DataSize + DataSize;
        newStruct->DataFlags = dataStruct->DataFlags;
        newStruct->DataStructIndex = dataStruct->DataStructIndex;
        newStruct->PrevLevelIndex = dataStruct->PrevLevelIndex;
        CopyMemory (newStruct->Data, dataStruct->Data, dataStruct->DataSize);
        CopyMemory (newStruct->Data + dataStruct->DataSize, Data, DataSize);

        prevStruct->DataStructIndex = newIndex;

        if (newStruct->DataStructIndex != INVALID_OFFSET) {
            nextStruct = GetKeyStruct (newStruct->DataStructIndex);
            MYASSERT (nextStruct);
            nextStruct->PrevLevelIndex = newIndex;
        }

        // now simply remove the block
        //
        // Donate block to free space
        //

        dataStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
        g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (dataIndex);
#ifdef DEBUG
        dataStruct->KeyFlags |= KSF_DELETED;
#endif
        // let's empty the keystruct (for better compression)
        ZeroMemory (dataStruct->Data, dataStruct->Size - KEYSTRUCT_SIZE);

        RemoveKeyOffsetFromBuffer (dataIndex);

        return newIndex;
    }
}
//lint -restore

UINT
KeyStructGrowBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  KeyStructGrowBinaryDataByIndex appends a certain type of binary data to
  an existing structure identified by OldIndex. The old structure is
  deleted and a new one is allocated holding both old and new data.

Arguments:

  OldIndex  - index of data
  Data      - pointer to the data
  DataSize  - size of data

Return Value:

  A valid data index if successfull, INVALID_OFFSET otherwise.

--*/

{
    UINT newIndex;
    PKEYSTRUCT oldStruct, newStruct, prevStruct, nextStruct;

    MYASSERT (g_CurrentDatabase);

    oldStruct = GetKeyStruct (OldIndex);
    MYASSERT (oldStruct);

    if (oldStruct->Size >= KEYSTRUCT_SIZE + DataSize + oldStruct->DataSize) {

        CopyMemory (oldStruct->Data + oldStruct->DataSize, Data, DataSize);
        oldStruct->DataSize += DataSize;
        return OldIndex;

    } else {

        newIndex = pAllocateNewDataStruct (DataSize + oldStruct->DataSize, min (oldStruct->DataSize, 65536));

        if (newIndex == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

        // now we need to reget all keystructs used so far because the database
        // might have moved
        oldStruct = GetKeyStruct (OldIndex);
        MYASSERT (oldStruct);

        newStruct = GetKeyStruct (newIndex);
        MYASSERT (newStruct);

        newStruct->DataStructIndex = oldStruct->DataStructIndex;
        newStruct->PrevLevelIndex = oldStruct->PrevLevelIndex;
        newStruct->DataFlags = oldStruct->DataFlags;
        CopyMemory (newStruct->Data, oldStruct->Data, oldStruct->DataSize);
        CopyMemory (newStruct->Data + oldStruct->DataSize, Data, DataSize);

        prevStruct = GetKeyStruct (newStruct->PrevLevelIndex);
        MYASSERT (prevStruct);
        prevStruct->DataStructIndex = newIndex;

        if (newStruct->DataStructIndex != INVALID_OFFSET) {
            nextStruct = GetKeyStruct (newStruct->DataStructIndex);
            MYASSERT (nextStruct);
            nextStruct->PrevLevelIndex = newIndex;
        }

        // now simply remove the block
        //
        // Donate block to free space
        //

        oldStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
        g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (OldIndex);
#ifdef DEBUG
        oldStruct->KeyFlags |= KSF_DELETED;
#endif
        // let's empty the keystruct (for better compression)
        ZeroMemory (oldStruct->Data, oldStruct->Size - KEYSTRUCT_SIZE);

        RemoveKeyOffsetFromBuffer (OldIndex);

        return newIndex;
    }
}

// LINT - in the next function prevstruct is thought to be possibly not initialized.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e771
BOOL
KeyStructDeleteBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  KeyStructDeleteBinaryData deletes a certain type of binary data from a key
  if it exists. If it doesn't, the function will simply return success.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data

Return Value:

  TRUE if successfull, FALSE if not.

--*/

{
    PKEYSTRUCT prevStruct, nextStruct, dataStruct, keyStruct;
    UINT dataIndex, prevIndex;
    BOOL found = FALSE;
    UINT typeInstances = 0;

    MYASSERT (g_CurrentDatabase);

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (!(keyStruct->DataFlags & Type)) {
        // no such type of data, exiting
        return TRUE;
    }

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;
    prevIndex = KeyIndex;
    prevStruct = keyStruct;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if ((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) {
            typeInstances ++;
            if ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance) {
                found = TRUE;
                //
                // now let's see if we have more instances of this binary type
                //
                if (dataStruct->DataStructIndex != INVALID_OFFSET) {
                    nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
                    if ((nextStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) {
                        typeInstances ++;
                    }
                }
                break;
            } else if ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance) {
                break;
            }
        } else if ((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) {
            break;
        }
        prevIndex = dataIndex;
        prevStruct = dataStruct;
        dataIndex = dataStruct->DataStructIndex;
    }

    if ((dataIndex == INVALID_OFFSET) || (!found)) {
        return TRUE;
    }

    // remove the linkage
    prevStruct->DataStructIndex = dataStruct->DataStructIndex;

    if (dataStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
        MYASSERT (nextStruct);
        nextStruct->PrevLevelIndex = prevIndex;
    }

    // now simply remove the block
    //
    // Donate block to free space
    //

    dataStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
    g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (dataIndex);
#ifdef DEBUG
    dataStruct->KeyFlags |= KSF_DELETED;
#endif
    // let's empty the keystruct (for better compression)
    ZeroMemory (dataStruct->Data, dataStruct->Size - KEYSTRUCT_SIZE);

    RemoveKeyOffsetFromBuffer (dataIndex);

    //
    // finally, fix the keystruct if this was the only instance of this type
    //
    MYASSERT (typeInstances >= 1);
    if (typeInstances == 1) {
        keyStruct->DataFlags &= ~Type;
    }

    return TRUE;
}
//lint -restore

BOOL
KeyStructDeleteBinaryDataByIndex (
    IN      UINT DataIndex
    )

/*++

Routine Description:

  KeyStructDeleteBinaryDataByIndex deletes a certain type of binary data from a key.

Arguments:

  DataIndex  - index of data

Return Value:

  TRUE if successfull, FALSE if not.

--*/

{
    PKEYSTRUCT prevStruct, nextStruct, dataStruct, keyStruct;
    BYTE type = 0;
    UINT typeInstances = 0;

    MYASSERT (g_CurrentDatabase);

    dataStruct = GetKeyStruct (DataIndex);
    MYASSERT (dataStruct);
    type = dataStruct->DataFlags & DATAFLAG_BINARYMASK;
    typeInstances ++;

    prevStruct = GetKeyStruct (dataStruct->PrevLevelIndex);
    MYASSERT (prevStruct);
    if ((prevStruct->DataFlags & DATAFLAG_BINARYMASK) == type) {
        typeInstances ++;
    }
    prevStruct->DataStructIndex = dataStruct->DataStructIndex;

    if (dataStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (dataStruct->DataStructIndex);
        MYASSERT (nextStruct);
        if ((nextStruct->DataFlags & DATAFLAG_BINARYMASK) == type) {
            typeInstances ++;
        }
        nextStruct->PrevLevelIndex = dataStruct->PrevLevelIndex;
    }

    // now simply remove the block
    //
    // Donate block to free space
    //

    dataStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
    g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (DataIndex);
#ifdef DEBUG
    dataStruct->KeyFlags |= KSF_DELETED;
#endif
    // let's empty the keystruct (for better compression)
    ZeroMemory (dataStruct->Data, dataStruct->Size - KEYSTRUCT_SIZE);

    RemoveKeyOffsetFromBuffer (DataIndex);

    //
    // finally, fix the keystruct if this was the only instance of this type
    //
    MYASSERT (typeInstances >= 1);
    if (typeInstances == 1) {
        // first we need to find the key starting with the current database struct
        keyStruct = dataStruct;
        while (keyStruct->KeyFlags & KSF_DATABLOCK) {
            // still a datablock
            if (keyStruct->PrevLevelIndex == INVALID_OFFSET) {
                // something is wrong, the first level is a datablock??
                break;
            }
            keyStruct = GetKeyStruct (keyStruct->PrevLevelIndex);
            MYASSERT (keyStruct);
        }
        if (!(keyStruct->KeyFlags & KSF_DATABLOCK)) {
            keyStruct->DataFlags &= ~type;
        }
    }

    return TRUE;
}

UINT
KeyStructReplaceBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )
{
    UINT newIndex;
    PKEYSTRUCT oldStruct, newStruct, prevStruct, nextStruct;

    MYASSERT (g_CurrentDatabase);

    // NTRAID#NTBUG9-153308-2000/08/01-jimschm Optimize this by keeping the current structure is big enough.

    newIndex = pAllocateNewDataStruct (DataSize, 0);

    if (newIndex == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    oldStruct = GetKeyStruct (OldIndex);
    MYASSERT (oldStruct);

    newStruct = GetKeyStruct (newIndex);
    MYASSERT (newStruct);

    newStruct->DataStructIndex = oldStruct->DataStructIndex;
    newStruct->PrevLevelIndex = oldStruct->PrevLevelIndex;
    newStruct->DataFlags = oldStruct->DataFlags;
    CopyMemory (newStruct->Data, Data, DataSize);

    prevStruct = GetKeyStruct (newStruct->PrevLevelIndex);
    MYASSERT (prevStruct);
    prevStruct->DataStructIndex = newIndex;

    if (newStruct->DataStructIndex != INVALID_OFFSET) {
        nextStruct = GetKeyStruct (newStruct->DataStructIndex);
        MYASSERT (nextStruct);
        nextStruct->PrevLevelIndex = newIndex;
    }

    // now simply remove the block
    //
    // Donate block to free space
    //

    oldStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
    g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset (OldIndex);
#ifdef DEBUG
    oldStruct->KeyFlags |= KSF_DELETED;
#endif
    // let's empty the keystruct (for better compression)
    ZeroMemory (oldStruct->Data, oldStruct->Size - KEYSTRUCT_SIZE);

    RemoveKeyOffsetFromBuffer (OldIndex);

    return newIndex;
}

// LINT - in the next function prevstruct is thought to be possibly not initialized.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e771
PBYTE
KeyStructGetBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize,
    OUT     PUINT DataIndex     //OPTIONAL
    )
{
    PKEYSTRUCT dataStruct,keyStruct;
    UINT dataIndex;
    BOOL found = FALSE;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (!(keyStruct->DataFlags & Type)) {
        return NULL;
    }

    // check to see if the data is already there
    dataIndex = keyStruct->DataStructIndex;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        dataIndex = dataStruct->DataStructIndex;
    }

    if ((dataIndex == INVALID_OFFSET) || (!found)) {
        return NULL;
    }

    if (DataSize) {
        *DataSize = dataStruct->DataSize;
    }

    if (DataIndex) {
        *DataIndex = dataIndex;
    }

    return dataStruct->Data;
}
//lint -restore

PBYTE
KeyStructGetBinaryDataByIndex (
    IN      UINT DataIndex,
    OUT     PUINT DataSize
    )
{
    PKEYSTRUCT dataStruct;

    dataStruct = GetKeyStruct (DataIndex);
    MYASSERT (dataStruct);

    if (DataSize) {
        *DataSize = dataStruct->DataSize;
    }

    return dataStruct->Data;
}

UINT
KeyStructGetDataIndex (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  KeyStructGetDataIndex looks for a certain type of data and returns it's index
  if it exists. If it doesn't, the function will simply return INVALID_OFFSET.

Arguments:

  KeyIndex  - index of key
  Type      - type of data
  Instance  - instance of data

Return Value:

  A data index if successfull, INVALID_OFFSET if not.

--*/

{
    PKEYSTRUCT keyStruct, dataStruct;
    UINT dataIndex;
    BOOL found = FALSE;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (!(keyStruct->DataFlags & Type)) {
        return INVALID_OFFSET;
    }

    // check to see if we have the data there
    dataIndex = keyStruct->DataStructIndex;

    while (dataIndex != INVALID_OFFSET) {

        dataStruct = GetKeyStruct (dataIndex);
        MYASSERT (dataStruct);

        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK)== Type) &&
            ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) == Instance)
            ) {
            found = TRUE;
            break;
        }
        if (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) > Type) ||
            (((dataStruct->DataFlags & DATAFLAG_BINARYMASK) == Type) &&
             ((dataStruct->DataFlags & DATAFLAG_INSTANCEMASK) > Instance)
             )
            ) {
            break;
        }
        dataIndex = dataStruct->DataStructIndex;
    }
    if (!found) {
        return INVALID_OFFSET;
    }
    return dataIndex;
}

DATAHANDLE
KeyStructAddLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BOOL toBeAdded = TRUE;
    UINT result = INVALID_OFFSET;
    PUINT linkArray;
    UINT linkSize;

    if (!AllowDuplicates) {
        //
        // check to see if we already have this linkage added
        //
        linkArray = (PUINT)KeyStructGetBinaryData (KeyIndex, Type, Instance, &linkSize, &result);

        if (linkArray) {

            while (linkSize >= SIZEOF (UINT)) {

                if (*linkArray == Linkage) {
                    toBeAdded = FALSE;
                    break;
                }

                linkArray ++;
                linkSize -= SIZEOF (UINT);
            }
        }
    }

    if (toBeAdded) {
        if (result != INVALID_OFFSET) {
            result = KeyStructGrowBinaryDataByIndex (result, (PBYTE)(&Linkage), SIZEOF (UINT));
        } else {
            result = KeyStructGrowBinaryData (KeyIndex, Type, Instance, (PBYTE)(&Linkage), SIZEOF (UINT));
        }
    }

    return result;
}

DATAHANDLE
KeyStructAddLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BOOL toBeAdded = TRUE;
    UINT result = INVALID_OFFSET;
    PUINT linkArray;
    UINT linkSize;

    if (!AllowDuplicates) {
        //
        // check to see if we already have this linkage added
        //
        linkArray = (PUINT)KeyStructGetBinaryDataByIndex (DataIndex, &linkSize);

        if (linkArray) {

            while (linkSize >= SIZEOF (UINT)) {

                if (*linkArray == Linkage) {
                    toBeAdded = FALSE;
                    break;
                }

                linkArray ++;
                linkSize -= SIZEOF (UINT);
            }
        }
    }

    if (toBeAdded) {
        result = KeyStructGrowBinaryDataByIndex (DataIndex, (PBYTE)(&Linkage), SIZEOF (UINT));
    } else {
        result = DataIndex;
    }

    return result;
}

BOOL
KeyStructDeleteLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BOOL checking = TRUE;
    BOOL result = FALSE;
    PUINT srcArray, destArray, newArray;
    UINT srcSize, newSize;
    UINT dataIndex;

    srcArray = (PUINT)KeyStructGetBinaryData (KeyIndex, Type, Instance, &srcSize, &dataIndex);

    if (srcArray) {
        newArray = MemDbGetMemory (srcSize);

        if (newArray) {

            destArray = newArray;
            newSize = 0;

            while (srcSize >= SIZEOF (UINT)) {
                if ((*srcArray == Linkage) &&
                    (checking)
                    ) {
                    if (FirstOnly) {
                        checking = FALSE;
                    }
                } else {
                    *destArray = *srcArray;
                    newSize += SIZEOF (UINT);
                    destArray ++;
                }
                srcArray ++;
                srcSize -= SIZEOF (UINT);
            }

            if (newSize) {
                result = (KeyStructReplaceBinaryDataByIndex (dataIndex, (PBYTE)newArray, newSize) != INVALID_OFFSET);
            } else {
                result = KeyStructDeleteBinaryDataByIndex (dataIndex);
            }

            MemDbReleaseMemory (newArray);
        }
    }

    return result;
}

BOOL
KeyStructDeleteLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BOOL checking = TRUE;
    BOOL result = FALSE;
    PUINT srcArray, destArray, newArray;
    UINT srcSize, newSize;

    srcArray = (PUINT)KeyStructGetBinaryDataByIndex (DataIndex, &srcSize);

    if (srcArray) {
        newArray = MemDbGetMemory (srcSize);

        if (newArray) {

            destArray = newArray;
            newSize = 0;

            while (srcSize >= SIZEOF (UINT)) {
                if ((*srcArray == Linkage) &&
                    (checking)
                    ) {
                    if (FirstOnly) {
                        checking = FALSE;
                    }
                } else {
                    *destArray = *srcArray;
                    newSize += SIZEOF (UINT);
                    destArray ++;
                }
                srcArray ++;
                srcSize -= SIZEOF (UINT);
            }

            if (newSize) {
                result = (KeyStructReplaceBinaryDataByIndex (DataIndex, (PBYTE)newArray, newSize) != INVALID_OFFSET);
            } else {
                result = KeyStructDeleteBinaryDataByIndex (DataIndex);
            }

            MemDbReleaseMemory (newArray);
        }
    }

    return result;
}

BOOL
KeyStructTestLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    )
{
    BOOL result = FALSE;
    PUINT srcArray;
    UINT srcSize = 0;

    srcArray = (PUINT)KeyStructGetBinaryData (KeyIndex, Type, Instance, &srcSize, NULL);

    while (srcSize >= SIZEOF (KEYHANDLE)) {
        if (*srcArray == Linkage) {
            result = TRUE;
            break;
        }
        srcSize -= SIZEOF (KEYHANDLE);
        srcArray++;
    }
    return result;
}

BOOL
KeyStructTestLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage
    )
{
    BOOL result = FALSE;
    PUINT srcArray;
    UINT srcSize;

    srcArray = (PUINT)KeyStructGetBinaryDataByIndex (DataIndex, &srcSize);

    while (srcSize >= SIZEOF (UINT)) {
        if (*srcArray == Linkage) {
            result = TRUE;
            break;
        }
        srcSize -= SIZEOF (UINT);
        srcArray++;
    }
    return result;
}

BOOL
KeyStructGetValue (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Value
    )
{
    if (!Value) {
        return TRUE;
    }

    if (!(KeyStruct->DataFlags & DATAFLAG_VALUE)) {
        //
        // there is no value, but we still set output to
        // zero and return TRUE
        //
        *Value = 0;
        return TRUE;
    }
    *Value = KeyStruct->Value;

    return TRUE;
}

BOOL
KeyStructGetFlags (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Flags
    )
{
    if (!Flags) {
        return TRUE;
    }
    if (!(KeyStruct->DataFlags & DATAFLAG_FLAGS)) {
        //
        // there are no flags, but we still set output to
        // zero and return TRUE
        //
        *Flags = 0;
        return TRUE;
    }
    *Flags = KeyStruct->Flags;

    return TRUE;
}



VOID
KeyStructFreeAllData (
    PKEYSTRUCT KeyStruct
    )

/*++

Routine Description:

  KeyStructFreeDataBlock frees a data block and resets the
  the KSF data flags, if the key struct has a data block allocated.

--*/

{
    // NTRAID#NTBUG9-153308-2000/08/01-jimschm Reimplement free routine
    //KeyStructFreeData (KeyStruct);
    KeyStruct->Value = 0;
    KeyStruct->Flags = 0;
    KeyStruct->DataFlags &= ~DATAFLAG_VALUE;
    KeyStruct->DataFlags &= ~DATAFLAG_FLAGS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\bintree.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    bintree.h

Abstract:

    Routines that manage the binary trees in the memdb database

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999


--*/


//
// all string arguments for BinTree functions must
// be Pascal-style strings (use StringPas...() functions
// defined in pastring.c).
//




//
// returns offset of binary tree
// OffsetOfString is the offset in bytes in the data structure
// of the string used to order the different nodes
//
UINT BinTreeNew();

//
// returns INVALID_OFFSET if node already exists,
// or offset of NODESTRUCT if add went okay
//
BOOL BinTreeAddNode(UINT TreeOffset, UINT data);

//
// removes node and returns offset of data
//
UINT BinTreeDeleteNode(UINT TreeOffset, PCWSTR str, PBOOL LastNode);

//
// returns pointer to data
//
UINT BinTreeFindNode(UINT TreeOffset, PCWSTR str);

//
// destroys and deallocates tree (but not data contained inside)
//
void BinTreeDestroy(UINT TreeOffset);

//
// enumerate first node in tree.  this takes the offset of
// the BINTREE struct and a pointer to a UINT which will
// hold data for BinTreeEnumNext.
//
UINT BinTreeEnumFirst(UINT TreeOffset, PUINT pEnum);

//
// pEnum is the enumerator filled by BinTreeEnumFirst
//
UINT BinTreeEnumNext(PUINT pEnum);

//
// turns the binary tree to insertion order - can only be
// done if the binary tree contains 0 or 1 nodes.  return
// TRUE if conversion is successful, or if binary tree is
// already in Insertion-Ordered mode.
//
BOOL BinTreeSetInsertionOrdered(UINT TreeOffset);



//
// number of nodes in tree
//
UINT BinTreeSize(UINT TreeOffset);



#ifdef DEBUG

//
// maximum depth of tree
//
int BinTreeMaxDepth(UINT TreeOffset);

//
// displays tree.  strsize is length of strings to display
//
void BinTreePrint(UINT TreeOffset);

//
// checks to make sure tree is valid and good
//
BOOL BinTreeCheck(UINT TreeOffset);

#else

#define BinTreePrint(a)
#define BinTreeCheck(a)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\keystruct.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    keystruct.c

Abstract:

    Routines that manage the memdb key structures.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     13-Aug-1999  major restructuring
    jimschm     30-Dec-1998  Hacked in AVL balancing
    jimschm     23-Sep-1998  Proxy nodes, so MemDbMoveTree can replace end nodes too
    jimschm     29-May-1998  Ability to replace center nodes in key strings
    jimschm     21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"
#include "bintree.h"

// LINT - in the next function keystruct is thought to be possibly NULL.
// If we examine the code we'll see that this is not a possibility so...
//lint -save -e794

UINT g_TotalKeys = 0;

UINT
pAllocKeyStruct (
    IN     PCWSTR KeyName,
    IN     UINT PrevLevelIndex
    )
/*++

Routine Description:

  pAllocKeyStruct allocates a block of memory in the single
  heap, expanding it if necessary.

  The KeyName must not already be in the tree, and
  PrevLevelIndex must point to a valid UINT Index
  variable.

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  KeyName - The string identifying the key.  It cannot
            contain backslashes.  The new struct will
            be initialized and this name will be copied
            into the struct.

  PrevLevelIndex - Specifies the previous level root Index

Return Value:

  An Index to the new structure.

--*/

{
    UINT size;
    PKEYSTRUCT KeyStruct = NULL;
    UINT Offset;
    UINT PrevDel;
    UINT TreeOffset;
    UINT Index;

    MYASSERT (g_CurrentDatabase);

    size = SizeOfStringW (KeyName) + KEYSTRUCT_SIZE;

    //
    // Look for free block
    //

    PrevDel = INVALID_OFFSET;
    Offset = g_CurrentDatabase->FirstKeyDeleted;

    while (Offset != INVALID_OFFSET) {
        KeyStruct = GetKeyStructFromOffset(Offset);
        MYASSERT(KeyStruct);
        if (KeyStruct->Size >= size && KeyStruct->Size < (size + ALLOC_TOLERANCE)) {
            break;
        }

        PrevDel = Offset;
        Offset = KeyStruct->NextDeleted;
    }

    if (Offset == INVALID_OFFSET) {
        //
        // Alloc new block if no free space
        //

        g_TotalKeys ++;

        Offset = DatabaseAllocBlock (size);
        if (Offset == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

#ifdef DEBUG
        //
        // if we are in debug mode, and we are using debug structs, set
        // pointer normally and set Signature DWORD.  if we are not using
        // debug structs, then set pointer to 4 bytes below actual offset,
        // so all members are shifted down.
        //
        if (g_UseDebugStructs) {
            KeyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(Offset);
            KeyStruct->Signature = KEYSTRUCT_SIGNATURE;
        } else {
            KeyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(Offset - KEYSTRUCT_HEADER_SIZE);
        }
#else
        KeyStruct = (PKEYSTRUCT)OFFSET_TO_PTR(Offset);
#endif

        KeyStruct->Size = size;
    } else {
        //
        // Delink free block if recovering free space
        //

        if (PrevDel != INVALID_OFFSET) {
            GetKeyStructFromOffset(PrevDel)->NextDeleted = KeyStruct->NextDeleted;
        } else {
            g_CurrentDatabase->FirstKeyDeleted = KeyStruct->NextDeleted;
        }
#ifdef DEBUG
        KeyStruct->KeyFlags &= ~KSF_DELETED;
#endif
    }

    //
    // Init new block
    //
    KeyStruct->DataStructIndex = INVALID_OFFSET;
    KeyStruct->NextLevelTree = INVALID_OFFSET;
    KeyStruct->PrevLevelIndex = PrevLevelIndex;
    KeyStruct->Value = 0;
    KeyStruct->KeyFlags = 0;
    KeyStruct->DataFlags = 0;
    StringPasCopyConvertTo (KeyStruct->KeyName, KeyName);

    Index = AddKeyOffsetToBuffer(Offset);

    //
    // Put it in the tree
    //
    TreeOffset = (KeyStruct->PrevLevelIndex == INVALID_OFFSET) ?
                    g_CurrentDatabase->FirstLevelTree :
                    GetKeyStruct(KeyStruct->PrevLevelIndex)->NextLevelTree;
    if (TreeOffset == INVALID_OFFSET) {
        TreeOffset = BinTreeNew();
        if (TreeOffset == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }


        if (PrevLevelIndex == INVALID_OFFSET) {
            g_CurrentDatabase->FirstLevelTree = TreeOffset;
        } else {
            GetKeyStruct(PrevLevelIndex)->NextLevelTree = TreeOffset;
        }
    }
    if (!BinTreeAddNode(TreeOffset, Index)) {
        return INVALID_OFFSET;
    }

    return Index;
}
//lint -restore

UINT
pNewKey (
    IN  PCWSTR KeyStr,
    IN  BOOL Endpoint
    )

/*++

Routine Description:

  NewKey allocates a key struct off our heap, and links it into the binary
  tree.  KeyStr must be a full key path, and any part of the path that does
  not exist will be created.  KeyStr must not already exist (though parts
  of it can exist).

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  KeyStr - The full path to the value, separated by backslashes.
           Each string between backslashes will cause a key
           struct to be allocated and linked.  Some of the
           structs may already have been allocated.

  Endpoint - Specifies TRUE if new node is an endpoint, or FALSE if
             it is not.

Return Value:

  An Index to the last node of the new structure, or
  INVALID_OFFSET if the key could not be allocated.

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    UINT Index, ThisLevelTree;
    PKEYSTRUCT KeyStruct;
    UINT PrevLevelIndex;
    BOOL NewNodeCreated = FALSE;

    MYASSERT (g_CurrentDatabase);

    StringCopyW (Path, KeyStr);
    End = Path;
    ThisLevelTree = g_CurrentDatabase->FirstLevelTree;
    PrevLevelIndex = INVALID_OFFSET;

    do  {
        // Split string at backslash
        Start = End;
        p = wcschr (End, L'\\');
        if (p) {
            End = p + 1;
            *p = 0;
        }
        else
            End = NULL;

        // Look in tree for key
        if (!NewNodeCreated) {
            Index = FindKeyStructInTree (ThisLevelTree, Start, FALSE);
        } else {
            Index = INVALID_OFFSET;
        }

        if (Index == INVALID_OFFSET) {
            // Add a new key if it was not found
            Index = pAllocKeyStruct (Start, PrevLevelIndex);
            if (Index == INVALID_OFFSET) {
                return INVALID_OFFSET;
            }


            NewNodeCreated = TRUE;
        }

        // Continue to next level
        KeyStruct = GetKeyStruct (Index);
        PrevLevelIndex = Index;
        ThisLevelTree = KeyStruct->NextLevelTree;
    } while (End);

    if (Endpoint) {
        if (!(KeyStruct->KeyFlags & KSF_ENDPOINT)) {
            NewNodeCreated = TRUE;
        }

        KeyStruct->KeyFlags |= KSF_ENDPOINT;

        if (NewNodeCreated) {
            (void)AddHashTableEntry (g_CurrentDatabase->HashTable, KeyStr, Index);
        }
    }
    return Index;
}

UINT
NewKey (
    IN  PCWSTR KeyStr
    )
/*++

Routine Description:

  creates a new key that is an endpoint.

Arguments:

  KeyStr - The string identifying the key.

Return Value:

  An Index to the new structure.

--*/
{
    return pNewKey (KeyStr, TRUE);
}

UINT
NewEmptyKey (
    IN  PCWSTR KeyStr
    )
/*++

Routine Description:

  creates an empty new key that is NOT an endpoint.

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  KeyStr - The string identifying the key.

Return Value:

  An Index to the new structure.

--*/
{
    return pNewKey (KeyStr, TRUE);
}






VOID
pRemoveKeyFromTree (
    IN      PKEYSTRUCT pKey
    )
{
    BOOL LastNode;
    PUINT pTreeOffset;

    MYASSERT(pKey);
    MYASSERT (g_CurrentDatabase);

    if (pKey->PrevLevelIndex==INVALID_OFFSET) {
        pTreeOffset = &g_CurrentDatabase->FirstLevelTree;
    } else {
        pTreeOffset = &GetKeyStruct(pKey->PrevLevelIndex)->NextLevelTree;
    }

    MYASSERT(*pTreeOffset!=INVALID_OFFSET);
    BinTreeDeleteNode (*pTreeOffset, pKey->KeyName, &LastNode);
    if (LastNode) {
        BinTreeDestroy(*pTreeOffset);
        *pTreeOffset = INVALID_OFFSET;
    }
}


VOID
pDeallocKeyStruct (
    IN      UINT Index,
    IN      BOOL ClearFlag,
    IN      BOOL DelinkFlag,
    IN      BOOL FreeIndexFlag
    )

/*++

Routine Description:

  pDeallocKeyStruct first deletes all structures pointed to by
  NextLevelTree.  After all items are deleted from the next
  level, pDeallocKeyStruct optionally delinks the struct from
  the binary tree.  Before exiting, the struct is given to the
  deleted block chain.

Arguments:

  Index       - An index in g_CurrentDatabase->OffsetBuffer
  ClearFlag   - Specifies TRUE if the key struct's children are to
                be deleted, or FALSE if the current key struct should
                simply be cleaned up but left allocated.
  DelinkFlag  - A flag indicating TRUE to delink the struct from
                the binary tree it is in, or FALSE if the struct is
                only to be added to the deleted block chain.
  FreeIndexFlag - This argument is only used if ClearFlag is true.
                It is FALSE if we do not want to free the index in
                g_CurrentDatabase->OffsetBuffer (i.e., we are moving the key and we do
                not want to deallocate the space in the buffer), or
                TRUE if we are just deleting the key, so we no longer
                need the g_CurrentDatabase->OffsetBuffer space at Index.

Return Value:

  none

--*/

{
    PKEYSTRUCT KeyStruct;
    UINT KeyIndex, TreeEnum;
    WCHAR TempStr[MEMDB_MAX];
    PUINT linkageList;
    UINT linkageSize;
    BYTE instance;
    BYTE oldDbIndex;

    MYASSERT (g_CurrentDatabase);

    KeyStruct = GetKeyStruct (Index);

    if (FreeIndexFlag && (KeyStruct->DataFlags & DATAFLAG_DOUBLELINK)) {
        //
        // we have some double linkage here. Let's go to the other
        // key and remove the linkage that points to this one
        //

        for (instance = 0; instance <= DATAFLAG_INSTANCEMASK; instance ++) {

            // First, retrieve the linkage list
            linkageSize = 0;
            linkageList = (PUINT) KeyStructGetBinaryData (
                                        Index,
                                        DATAFLAG_DOUBLELINK,
                                        instance,
                                        &linkageSize,
                                        NULL
                                        );
            if (linkageList) {

                oldDbIndex = g_CurrentDatabaseIndex;

                while (linkageSize) {

                    SelectDatabase (GET_DATABASE (*linkageList));

                    KeyStructDeleteLinkage (
                        GET_INDEX (*linkageList),
                        DATAFLAG_DOUBLELINK,
                        instance,
                        GET_EXTERNAL_INDEX (Index),
                        FALSE
                        );

                    linkageSize -= SIZEOF (UINT);
                    linkageList ++;

                    if (linkageSize < SIZEOF (UINT)) {
                        break;
                    }
                }

                SelectDatabase (oldDbIndex);
            }
        }
    }

    if (KeyStruct->KeyFlags & KSF_ENDPOINT) {
        //
        // Remove endpoints from hash table and free key data
        //
        if (PrivateBuildKeyFromIndex (0, Index, TempStr, NULL, NULL, NULL)) {
            RemoveHashTableEntry (g_CurrentDatabase->HashTable, TempStr);
        }

        KeyStructFreeAllData (KeyStruct);
        KeyStruct->KeyFlags &= ~KSF_ENDPOINT;
    }

    if (ClearFlag) {
        //
        // Call recursively if there are sublevels to this key
        //
        if (KeyStruct->NextLevelTree != INVALID_OFFSET) {

            KeyIndex = GetFirstIndex(KeyStruct->NextLevelTree, &TreeEnum);

            while (KeyIndex != INVALID_OFFSET) {
                pDeallocKeyStruct (KeyIndex, TRUE, FALSE, FreeIndexFlag);
                KeyIndex = GetNextIndex (&TreeEnum);
            }

            BinTreeDestroy(KeyStruct->NextLevelTree);
        }

        //
        // Remove the item from its binary tree
        //
        if (DelinkFlag) {
            pRemoveKeyFromTree(KeyStruct);
        }

        //
        // Donate block to free space unless caller does not
        // want child structs freed.
        //

        KeyStruct->NextDeleted = g_CurrentDatabase->FirstKeyDeleted;
        g_CurrentDatabase->FirstKeyDeleted = KeyIndexToOffset(Index);
#ifdef DEBUG
        KeyStruct->KeyFlags |= KSF_DELETED;
#endif

        // let's empty the keystruct (for better compression)
        ZeroMemory (KeyStruct->KeyName, KeyStruct->Size - KEYSTRUCT_SIZE);

        if (FreeIndexFlag) {
            RemoveKeyOffsetFromBuffer(Index);
        }
    }
}

BOOL
PrivateDeleteKeyByIndex (
    IN      UINT Index
    )

/*++

Routine Description:

  PrivateDeleteKeyByIndex will completely destroy the key struct
  that Index points to (along with all sub-levels. Furthermore,
  it goes back recursively and removes the parent structures as well
  if they no longer have a child (the current one was the only one).

Arguments:

  Index     - Index of the key structure.

Return Value:

  TRUE if successfull, FALSE otherwise

--*/

{
    PKEYSTRUCT keyStruct;
    UINT prevLevelIndex;
    BOOL result = TRUE;

    keyStruct = GetKeyStruct (Index);

    prevLevelIndex = keyStruct->PrevLevelIndex;

    pDeallocKeyStruct (Index, TRUE, TRUE, TRUE);

    if (prevLevelIndex != INVALID_OFFSET) {

        keyStruct = GetKeyStruct (prevLevelIndex);

        if (keyStruct->NextLevelTree != INVALID_OFFSET) {

            result = PrivateDeleteKeyByIndex (prevLevelIndex);
        }
    }

    return result;
}

BOOL
DeleteKey (
    IN      PCWSTR KeyStr,
    IN      UINT TreeOffset,
    IN      BOOL MustMatch
    )

/*++

Routine Description:

  DeleteKey takes a key path and puts the key struct in the deleted
  block chain.  Any sub-levels are deleted as well.

Arguments:

  KeyStr     - The full path to the value, separated by backslashes.
  TreeOffset    - A pointer to the level's binary tree root variable.
  MustMatch  - A flag indicating if the delete only applies to
               end points or if any matching struct is to be deleted.
               TRUE indicates only endpoints can be deleted.

Return Value:

  none

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    UINT Index, NextIndex, TreeEnum=INVALID_OFFSET;
    PKEYSTRUCT KeyStruct;

    StringCopyW (Path, KeyStr);
    End = Path;

    //
    // Split string at backslash
    //

    Start = End;
    p = wcschr (End, L'\\');
    if (p) {
        End = p + 1;
        *p = 0;

    } else {
        End = NULL;
    }

    //
    // Look at this level for the very first key
    //

    Index = FindKeyStructUsingTreeOffset (TreeOffset, &TreeEnum, Start);

    //
    // If this is the last level, delete the matching keys
    // (may need to be endpoints if MustMatch is TRUE)
    //

    if (!End) {
        while (Index != INVALID_OFFSET) {
            KeyStruct = GetKeyStruct (Index);
            NextIndex = FindKeyStructUsingTreeOffset (TreeOffset, &TreeEnum, Start);

            //
            // If must match and lower levels exist, don't delete, just turn
            // off the endpoint flag
            //

            if (MustMatch && KeyStruct->NextLevelTree != INVALID_OFFSET) {
                // Call to clean up, not to delink or recurse
                pDeallocKeyStruct (Index, FALSE, FALSE, FALSE);
            }

            //
            // Else delete the struct if an endpoint or don't care about
            // endpoints
            //

            else if (!MustMatch || (KeyStruct->KeyFlags & KSF_ENDPOINT)) {
                // Call to free the entire key struct and all children
                pDeallocKeyStruct (Index, TRUE, TRUE, TRUE);
            }

            Index = NextIndex;
        }
    }

    //
    // Otherwise recursively examine next level for each match
    //

    else {
        while (Index != INVALID_OFFSET) {
            //
            // Delete all matching subkeys
            //

            NextIndex = FindKeyStructUsingTreeOffset (TreeOffset, &TreeEnum, Start);
            KeyStruct = GetKeyStruct (Index);
            DeleteKey (End, KeyStruct->NextLevelTree, MustMatch);

            //
            // If this is not an endpoint and has no children, delete it
            //

            if (KeyStruct->NextLevelTree == INVALID_OFFSET &&
                !(KeyStruct->KeyFlags & KSF_ENDPOINT)
                ) {
                // Call to free the entire key struct
                pDeallocKeyStruct (Index, TRUE, TRUE, TRUE);
            }

            //
            // Continue looking in this level for another match
            //

            Index = NextIndex;
        }
    }

    return TRUE;
}




VOID
pRemoveHashEntriesForNode (
    IN      PCWSTR Root,
    IN      UINT Index
    )

/*++

Routine Description:

  pRemoveHashEntriesFromNode removes all hash table entries from all children
  of the specified node.  This function is called recursively.

Arguments:

  Root   - Specifies the root string that corresponds with Index.  This must
           also contain the temporary hive root.
  Index - Specifies the Index of the node to process.  The node and all of
           its children will be removed from the hash table.

Return Value:

  None.

--*/

{
    UINT ChildIndex, TreeEnum;
    PKEYSTRUCT KeyStruct;
    WCHAR ChildRoot[MEMDB_MAX];
    PWSTR End;

    MYASSERT (g_CurrentDatabase);

    //
    // Remove hash entry if this root is an endpoint
    //

    KeyStruct = GetKeyStruct (Index);

    if (KeyStruct->KeyFlags & KSF_ENDPOINT) {
        RemoveHashTableEntry (g_CurrentDatabase->HashTable, Root);

#ifdef DEBUG
        {
            UINT HashIndex;

            HashIndex = FindStringInHashTable (g_CurrentDatabase->HashTable, Root);
            if (HashIndex != INVALID_OFFSET) {
                DEBUGMSG ((DBG_WARNING, "Memdb move duplicate: %s", Root));
            }
        }
#endif
    }

    //
    // Recurse for all children, removing hash entries for all endpoints found
    //

    StringCopyW (ChildRoot, Root);
    End = GetEndOfStringW (ChildRoot);
    *End = L'\\';
    End++;
    *End = 0;

    ChildIndex = GetFirstIndex(KeyStruct->NextLevelTree, &TreeEnum);

    while (ChildIndex != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (ChildIndex);
        StringPasCopyConvertFrom (End, KeyStruct->KeyName);
        pRemoveHashEntriesForNode (ChildRoot, ChildIndex);

        ChildIndex = GetNextIndex(&TreeEnum);
    }
}


VOID
pAddHashEntriesForNode (
    IN      PCWSTR Root,
    IN      UINT Index,
    IN      BOOL AddRoot
    )

/*++

Routine Description:

  pAddHashEntriesForNode adds hash table entries for the specified root and
  all of its children.

Arguments:

  Root    - Specifies the root string that corresponds to Index.  This string
            must also include the temporary hive root.
  Index  - Specifies the node Index to begin processing.  The node and all
            of its children are added to the hash table.
  AddRoot - Specifies TRUE if the root should be added to the hash table,
            FALSE otherwise.


Return Value:

  None.

--*/

{
    UINT ChildIndex, TreeEnum;
    PKEYSTRUCT KeyStruct;
    WCHAR ChildRoot[MEMDB_MAX];
    PWSTR End;
    UINT HashIndex;

    MYASSERT (g_CurrentDatabase);

    //
    // Add hash entry if this root is an endpoint
    //

    KeyStruct = GetKeyStruct (Index);

    if (AddRoot && KeyStruct->KeyFlags & KSF_ENDPOINT) {

        HashIndex = FindStringInHashTable (g_CurrentDatabase->HashTable, Root);

        if (HashIndex != Index) {

#ifdef DEBUG
            if (HashIndex != INVALID_OFFSET) {
                DEBUGMSG ((DBG_WARNING, "Memdb duplicate: %s", Root));
            }
#endif

            AddHashTableEntry (g_CurrentDatabase->HashTable, Root, Index);
        }
    }

    //
    // Recurse for all children, adding hash entries for all endpoints found
    //

    StringCopyW (ChildRoot, Root);
    End = GetEndOfStringW (ChildRoot);
    *End = L'\\';
    End++;
    *End = 0;

    ChildIndex = GetFirstIndex(KeyStruct->NextLevelTree, &TreeEnum);

    while (ChildIndex != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct(ChildIndex);
        StringPasCopyConvertFrom (End, KeyStruct->KeyName);
        pAddHashEntriesForNode(ChildRoot, ChildIndex, TRUE);

        ChildIndex = GetNextIndex(&TreeEnum);
    }
}

#ifdef DEBUG
//
// in non-DEBUG mode, GetKeyStructFromOffset
// and GetKeyStruct are implemented as macros
//

PKEYSTRUCT
GetKeyStructFromOffset (
    IN UINT Offset
    )
/*++

Routine Description:

  GetKeyStruct returns a pointer given an Offset.  The debug version
  checks the signature and validity of each Index.  It is assumed that
  Offset is always valid.

Arguments:

  Offset - Specifies the Offset to the node

Return Value:

  The pointer to the node.

--*/
{
    PKEYSTRUCT KeyStruct;

    MYASSERT (g_CurrentDatabase);

    if (Offset == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Invalid root accessed in GetKeyStruct at offset %u", Offset));
        return NULL;
    }
    if (!g_CurrentDatabase) {
        DEBUGMSG ((DBG_ERROR, "Attempt to access non-existent buffer at %u", Offset));
        return NULL;
    }
    if (Offset > g_CurrentDatabase->End) {
        DEBUGMSG ((DBG_ERROR, "Access beyond length of buffer in GetKeyStruct (offset %u)", Offset));
        return NULL;
    }

    if (!g_UseDebugStructs) {
        KeyStruct = (PKEYSTRUCT) OFFSET_TO_PTR (Offset - KEYSTRUCT_HEADER_SIZE);
        return KeyStruct;
    }

    KeyStruct = (PKEYSTRUCT) OFFSET_TO_PTR (Offset);
    if (KeyStruct->Signature != KEYSTRUCT_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Signature does not match in GetKeyStruct at offset %u!", Offset));
        return NULL;
    }

    return KeyStruct;
}


PKEYSTRUCT
GetKeyStruct (
    IN UINT Index
    )
/*++

Routine Description:

  GetKeyStruct returns a pointer given an Index.  The debug version
  checks the signature and validity of each Index.  It is assumed that Index
  is always valid.

Arguments:

  Index - Specifies the Index to the node

Return Value:

  The pointer to the node.

--*/
{
    UINT Offset;
    if (Index == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Invalid root accessed in GetKeyStruct at index %u", Index));
        return NULL;
    }

    Offset = KeyIndexToOffset(Index);
    if (Offset == INVALID_OFFSET) {
        return NULL;
    }
    return GetKeyStructFromOffset(Offset);
}


#endif











BOOL
PrivateBuildKeyFromIndex (
    IN      UINT StartLevel,               // zero-based
    IN      UINT TailIndex,
    OUT     PWSTR Buffer,                   OPTIONAL
    OUT     PUINT ValPtr,                   OPTIONAL
    OUT     PUINT UserFlagsPtr,             OPTIONAL
    OUT     PUINT Chars                     OPTIONAL
    )

/*++

Routine Description:

  PrivateBuildKeyFromIndex generates the key string given an Index.  The
  caller can specify the start level to skip root nodes.  It is assumed that
  TailIndex is always valid.

Arguments:

  StartLevel   - Specifies the zero-based level to begin building the key
                 string.  This is used to skip the root portion of the key
                 string.
  TailIndex    - Specifies the Index to the last level of the key string.
  Buffer       - Receives the key string, must be able to hold MEMDB_MAX
                 characters.
  ValPtr       - Receives the key's value
  UserFlagsPtr - Receives the user flags
  Chars        - Receives the number of characters in Buffer

Return Value:

  TRUE if the key was build properly, FALSE otherwise.

--*/

{
    static UINT Indices[MEMDB_MAX];
    PKEYSTRUCT KeyStruct;
    UINT CurrentIndex;
    UINT IndexEnd;
    UINT IndexStart;
    register PWSTR p;

    //
    // Build string
    //

    IndexEnd = MEMDB_MAX;
    IndexStart = MEMDB_MAX;

    CurrentIndex = TailIndex;
    while (CurrentIndex != INVALID_OFFSET) {
        //
        // Record offset
        //
        IndexStart--;
        Indices[IndexStart] = CurrentIndex;

        //
        // Dec for start level and go to parent
        //
        KeyStruct = GetKeyStruct (CurrentIndex);
        if (!KeyStruct) {
            return FALSE;
        }
        CurrentIndex = KeyStruct->PrevLevelIndex;
    }

    //
    // Filter for "string is not long enough"
    //
    IndexStart += StartLevel;
    if (IndexStart >= IndexEnd) {
        return FALSE;
    }

    //
    // Transfer node's value and flags to caller's variables
    //

    if (ValPtr) {
        KeyStructGetValue (GetKeyStruct(TailIndex), ValPtr);
    }
    if (UserFlagsPtr) {
        KeyStructGetFlags (GetKeyStruct(TailIndex), UserFlagsPtr);
    }

    //
    // Copy each piece of the string to Buffer and calculate character count
    //
    if (Buffer) {
        p = Buffer;
        for (CurrentIndex = IndexStart ; CurrentIndex < IndexEnd ; CurrentIndex++) {
            KeyStruct = GetKeyStruct (Indices[CurrentIndex]);
            CopyMemory(p, KeyStruct->KeyName + 1, *KeyStruct->KeyName * sizeof(WCHAR));
            p += *KeyStruct->KeyName;
            *p++ = L'\\';
        }
        p--;
        *p = 0;

        if (Chars) {
            *Chars = (UINT)(((UBINT)p - (UBINT)Buffer) / sizeof (WCHAR));
        }

    } else if (Chars) {
        *Chars = 0;

        for (CurrentIndex = IndexStart ; CurrentIndex < IndexEnd ; CurrentIndex++) {
            KeyStruct = GetKeyStruct (Indices[CurrentIndex]);
            *Chars += StringPasCharCount(KeyStruct->KeyName) + 1;
        }

        *Chars -= 1;
    }

    return TRUE;
}



BOOL
KeyStructSetInsertionOrdered (
    IN      PKEYSTRUCT pKey
    )

/*++
Routine Description:

  KeyStructSetInsertionOrdered sets the enumeration order of the children
  of Key to be in the order they were inserted.

  This function may move the database buffer.  Pointers
  into the database might not be valid afterwards.

Arguments:

  Key - key to make insertion ordered

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    return BinTreeSetInsertionOrdered(pKey->NextLevelTree);
}





UINT
GetFirstIndex (
    IN      UINT TreeOffset,
    OUT     PUINT pTreeEnum
    )

/*++

Routine Description:

  GetFirstIndex walks down the left side of the binary tree
  pointed to by TreeOffset, and returns the left-most node.

Arguments:

  TreeOffset    - An offset to the root of the tree
  TreeEnum      - a pointer to a UINT which will hold enumeration
                  information for future calls of GetNextIndex

Return Value:

  An Index to the leftmost structure, or INVALID_OFFSET if the
  root was invalid.

--*/


{
    return BinTreeEnumFirst(TreeOffset, pTreeEnum);
}


UINT
GetNextIndex (
    IN OUT      PUINT pTreeEnum
    )

/*++

Routine Description:

  GetNextIndex traverses the binary tree in order.

Arguments:

  TreeEnum   - Enumerator filled by GetFirstIndex which
               will be changed by this function

Return Value:

  An Index to the next structure, or INVALID_OFFSET if the
  end is reached.

--*/

{
    return BinTreeEnumNext(pTreeEnum);
}



UINT KeyStructGetChildCount (
    IN      PKEYSTRUCT pKey
    )
{
    if (!pKey) {
        return 0;
    }
    return BinTreeSize(pKey->NextLevelTree);
}



UINT
FindKeyStructInTree (
    IN UINT TreeOffset,
    IN PWSTR KeyName,
    IN BOOL IsPascalString
    )

/*++

Routine Description:

  FindKeyStructInTree takes a key name and looks for the
  Index in the tree specified by TreeOffset.  The key
  name must not contain backslashes.

Arguments:

  TreeOffset - An offset to the root of the level

  KeyName - The name of the key to find in the binary tree
        (not the full key path; just the name of this level).

  IsPascalString - TRUE if string is in pascal format (char
        count is first WCHAR, no null terminator) otherwise FALSE

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    UINT Index;
    if (!IsPascalString) {
        StringPasConvertTo(KeyName);
    }
    Index = BinTreeFindNode(TreeOffset, KeyName);
    if (!IsPascalString) {
        StringPasConvertFrom(KeyName);
    }
    return Index;
}












#ifdef DEBUG

BOOL
CheckLevel(UINT TreeOffset,
            UINT PrevLevelIndex
            )
{
    PKEYSTRUCT pKey;
    UINT KeyIndex, TreeEnum;
    WCHAR key[MEMDB_MAX];

    if (TreeOffset==INVALID_OFFSET) {
        return TRUE;
    }
    BinTreeCheck(TreeOffset);

#if MEMDB_VERBOSE
    if (PrevLevelIndex!=INVALID_OFFSET) {
        wprintf(L"children of %.*s:\n",*GetKeyStruct(PrevLevelIndex)->KeyName,GetKeyStruct(PrevLevelIndex)->KeyName+1);
    } else {
        printf("top level children:\n");
    }

    BinTreePrint(TreeOffset);
#endif

    if ((KeyIndex=BinTreeEnumFirst(TreeOffset,&TreeEnum))!=INVALID_OFFSET) {
        do {
            pKey=GetKeyStruct(KeyIndex);

            if (pKey->PrevLevelIndex!=PrevLevelIndex) {
                wprintf(L"MemDbCheckDatabase: PrevLevelIndex of Keystruct %s incorrect!", StringPasCopyConvertFrom (key, pKey->KeyName));
            }

            if (!CheckLevel(pKey->NextLevelTree, KeyIndex)) {
                wprintf(L"Child tree of %s bad!\n", StringPasCopyConvertFrom (key, pKey->KeyName));
            }

        } while ((KeyIndex=BinTreeEnumNext(&TreeEnum))!=INVALID_OFFSET);
    } else {
        printf("MemDbCheckDatabase: non-null binary tree has no children!");
        return FALSE;
    }
    return TRUE;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\keyfind.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    keyfind.c

Abstract:

    Routines that manage finding the memdb key structures.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     13-Aug-1999  split from keystruct.c


--*/

#include "pch.h"
#include "memdbp.h"


UINT
FindKeyStruct (
    PCWSTR Key
    )
/*++

Routine Description:

  FindKeyStruct takes a wack-delimited key string, and returns the Index
  of the keystruct.  this is different than FindKey() because that only
  finds endpoints, so it is fast, because it can use the hash table.
  this recurses down the memdb database levels to the specified keystruct.

Arguments:

  Key                - String holding full path of key to be found

Return Value:

  Index of key, or INVALID_OFFSET if function failed

--*/
{
    UINT TreeOffset, Index=INVALID_OFFSET;
    PWSTR p, q;
    WCHAR Temp[MEMDB_MAX];

    MYASSERT (g_CurrentDatabase);

    if (*Key==0) {
        return INVALID_OFFSET;
    }
    StringCopyW (Temp, Key);
    q = Temp;

    do {
        if (Index == INVALID_OFFSET) {
            TreeOffset = g_CurrentDatabase->FirstLevelTree;
        } else {
            TreeOffset = GetKeyStruct(Index)->NextLevelTree;
        }

        if (TreeOffset == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

        p = wcschr (q, L'\\');
        if (p) {
            *p = 0;
        }

        Index = FindKeyStructInTree (TreeOffset, q, FALSE);

        if (Index == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }

        if (p) {
            q = p + 1;
        }

    } while (p);

    return Index;
}


UINT
FindKey (
    IN  PCWSTR FullKeyPath
    )

/*++

Routine Description:

  FindKey locates a complete key string and returns
  the Index to the KEYSTRUCT, or INVALID_OFFSET if
  the key path does not exist.  The FullKeyPath
  must supply the complete path to the KEYSTRUCT.

Arguments:

  FullKeyPath - A backslash-delimited key path to a value

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    MYASSERT (g_CurrentDatabase);

    return FindStringInHashTable (g_CurrentDatabase->HashTable, FullKeyPath);
}

UINT
FindKeyStructUsingTreeOffset (
    IN      UINT TreeOffset,
    IN OUT  PUINT pTreeEnum,
    IN      PCWSTR KeyStr
    )

/*++

Routine Description:

  FindKeyStructUsingTreeOffset takes a key pattern and looks
  for the Index in the tree specified by TreeOffset.  The key
  name must not contain backslashes, but can contain wildcards.

Arguments:

  TreeOffset - An offset to the tree

  pTreeEnum - The previous value from FindKeyStructUsingTreeOffset
               (for enumeration) or INVALID_OFFSET for the first
               call.

  KeyStr - The name of the key to find in the binary tree

Return Value:

  An Index to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;
    UINT KeyIndex;
    SIZE_T len1, len2;

    MYASSERT(pTreeEnum!=NULL);

    if (*pTreeEnum == INVALID_OFFSET) {
        KeyIndex = GetFirstIndex(TreeOffset, pTreeEnum);
    } else {
        KeyIndex = GetNextIndex(pTreeEnum);
    }

    //
    // Examine key as a pattern, then go to next node
    //
    while (KeyIndex != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct(KeyIndex);

        len1 = CharCountW (KeyStr);
        len2 = *KeyStruct->KeyName;
        if ((len1 == len2) &&
            (StringIMatchCharCountW (KeyStr, KeyStruct->KeyName + 1, len1))
            ) {
            return KeyIndex;
        }
        //
        // No match yet - go to next node
        //
        KeyIndex = GetNextIndex(pTreeEnum);
    }

    return INVALID_OFFSET;
}

#ifdef DEBUG
BOOL FindKeyStructInDatabase(UINT KeyOffset)
{
    PKEYSTRUCT pKey;

    MYASSERT (g_CurrentDatabase);

    pKey = GetKeyStructFromOffset(KeyOffset);

    if (pKey->KeyFlags & KSF_DELETED) {
        return TRUE;
    }

    while (pKey->PrevLevelIndex!=INVALID_OFFSET) {
        pKey=GetKeyStruct(pKey->PrevLevelIndex);
    }

    return (FindKeyStructInTree(g_CurrentDatabase->FirstLevelTree, pKey->KeyName, TRUE)!=INVALID_OFFSET);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\memdbex.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbex.c

Abstract:

    Extensions to use the memdb tree like a relational database

Author:

    Jim Schmidt (jimschm) 2-Dec-1996

Revision History:

    mvander     13-Aug-1999 many changes
    jimschm     23-Sep-1998 Expanded user flags to 24 bits (from
                            12 bits), removed AnsiFromUnicode
    jimschm     21-Oct-1997 Cleaned up a little
    marcw       09-Apr-1997 Added MemDbGetOffset* functions.
    jimschm     17-Jan-1997 All string params can be NULL now
    jimschm     18-Dec-1996 Added GetEndpointValue functions

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\memdb.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdb.c

Abstract:

    A memory-based database for managing all kinds of data relationships.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    jimschm     05-Oct-1999  Documentation
    mvander     13-Aug-1999  many changes
    jimschm     23-Sep-1998  Expanded user flags to 24 bits (from 12 bits)
    calinn      12-Dec-1997  Extended MemDbMakePrintableKey and MemDbMakeNonPrintableKey
    jimschm     03-Dec-1997  Added multi-thread synchronization
    jimschm     22-Oct-1997  Split into multiple source files,
                             added multiple memory block capability
    jimschm     16-Sep-1997  Hashing: delete fix
    jimschm     29-Jul-1997  Hashing, user flags added
    jimschm     07-Mar-1997  Signature changes
    jimschm     03-Mar-1997  PrivateBuildKeyFromOffset changes
    jimschm     18-Dec-1996  Fixed deltree bug

--*/

#include "pch.h"

// PORTBUG: Make sure to pick up latest fixes in win9xupg project

//
// Includes
//

#include "memdbp.h"
#include "bintree.h"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

CRITICAL_SECTION g_MemDbCs;
PMHANDLE g_MemDbPool = NULL;
static INT g_Initialized;

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

/*++

Routine Description:

  MemDbInitializeEx creates data structures for an initial database.  Calling
  this routine is required.

Arguments:

  None.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

BOOL
MemDbInitializeExA (
    IN      PCSTR DatabasePath  OPTIONAL
    )
{
    BOOL result = TRUE;

    MYASSERT (g_Initialized >= 0);
    g_Initialized++;

    if (g_Initialized == 1) {

        g_MemDbPool = PmCreateNamedPool ("MemDb");

        if (g_MemDbPool == NULL) {
            return FALSE;
        }

        __try {
            InitializeCriticalSection (&g_MemDbCs);
        } __except (EXCEPTION_CONTINUE_EXECUTION) {
            // Might raise an out of memory exception, but we don't check for that in this function.
            // Ignores
        }


        //
        // If we fail, we don't automatically call MemDbTerminate, because
        // there is an option to MemDbTerminate which we don't know.
        //

        if (!DatabasesInitializeA (DatabasePath)) {
            return FALSE;
        }

        result = FileEnumInitialize ();
    }

    return result;
}

BOOL
MemDbInitializeExW (
    IN      PCWSTR DatabasePath  OPTIONAL
    )
{
    BOOL result = TRUE;

    MYASSERT (g_Initialized >= 0);

    g_Initialized++;

    if (g_Initialized == 1) {

        g_MemDbPool = PmCreateNamedPool ("MemDb");

        if (g_MemDbPool == NULL) {
            return FALSE;
        }

        __try {
            InitializeCriticalSection (&g_MemDbCs);
        } __except (EXCEPTION_CONTINUE_EXECUTION) {
            // Might raise an out of memory exception, but we don't check for that in this function.
            // Ignores
        }

        //
        // If we fail, we don't automatically call MemDbTerminate, because
        // there is an option to MemDbTerminate which we don't know.
        //

        if (!DatabasesInitializeW (DatabasePath)) {
            return FALSE;
        }

        result = FileEnumInitialize ();
    }

    return result;
}

VOID
MemDbTerminateEx (
    IN      BOOL EraseDatabasePath
    )

/*++

Routine Description:

  MemDbTerminateEx frees all resources associated with MemDb
  and, optionally, removes the database directory.
  This routine should be called at process termination.

Arguments:

  None.

Return Value:

  None.

--*/

{
    MYASSERT (g_Initialized > 0);

    g_Initialized--;

    if (!g_Initialized) {

        if (g_MemDbPool) {
            PmDestroyPool (g_MemDbPool);
            g_MemDbPool = NULL;
        }

        DatabasesTerminate (EraseDatabasePath);

        DeleteCriticalSection (&g_MemDbCs);

        FileEnumTerminate ();

    } else if (g_Initialized < 0) {
        //
        // Since we call ourselves, protect callers from over-termination
        //

        g_Initialized = 0;
    }
}

PVOID
MemDbGetMemory (
    IN      UINT Size
    )
{
    MYASSERT (g_MemDbPool);
    return PmGetMemory (g_MemDbPool, Size);
}

VOID
MemDbReleaseMemory (
    IN      PCVOID Memory
    )
{
    if (Memory) {
        MYASSERT (g_MemDbPool);
        PmReleaseMemory (g_MemDbPool, Memory);
    }
}


KEYHANDLE
MemDbAddKeyA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbAddKey creates a memdb key that has no values, flags or any
  other data.  This is used to reduce the size of the database.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created key or NULL if
  not successful.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = 0;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbAddKeyW (keyNameW);
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbAddKeyW (
    IN      PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbAddKey creates a memdb key that has no values, flags or any
  other data.  This is used to reduce the size of the database.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created key or NULL if not successful.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {

        //
        // first make sure there is no key
        // with this name.
        //
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            SetLastError (ERROR_ALREADY_EXISTS);
            __leave;
        }

        keyIndex = NewEmptyKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            result = GET_EXTERNAL_INDEX (keyIndex);
            SetLastError (ERROR_SUCCESS);
        }
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbSetKeyA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbSetKey creates a memdb key that has no values, flags or any other data.
  This is used to reduce the size of the database. If the key exists it will
  return the handle of the existing key.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created or existent key or NULL if some error
  occurs.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = 0;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbSetKeyW (keyNameW);
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbSetKeyW (
    IN      PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbSetKey creates a memdb key that has no values, flags or any other data.
  This is used to reduce the size of the database. If the key exists it will
  return the handle of the existing key.

Arguments:

  KeyName - Specifies the key to create.

Return Value:

  Returns the HANDLE to the newly created or existent key or NULL if some error
  occurs.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {

        //
        // first make sure there is no key
        // with this name.
        //
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            SetLastError (ERROR_ALREADY_EXISTS);
            result = GET_EXTERNAL_INDEX (keyIndex);;
            __leave;
        }

        keyIndex = NewEmptyKey (subKey);

        if (keyIndex != INVALID_OFFSET) {
            result = GET_EXTERNAL_INDEX (keyIndex);;
            SetLastError (ERROR_SUCCESS);
        }
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteKeyA (
    IN      PCSTR KeyStr
    )

/*++

Routine Description:

  MemDbDeleteKey deletes a specific string from the database (along with all
  data associated with it)

Arguments:

  KeyStr - Specifies the key string to delete (i.e., foo\bar\cat)

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyStr);
    if (p) {
        result = MemDbDeleteKeyW (p);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteKeyW (
    IN      PCWSTR KeyStr
    )

/*++

Routine Description:

  MemDbDeleteKey deletes a specific string from the database (along with all
  data associated with it)

Arguments:

  KeyStr - Specifies the key string to delete (i.e., foo\bar\cat)

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    subKey = SelectHiveW (KeyStr);
    if (subKey) {
        result = DeleteKey (subKey, g_CurrentDatabase->FirstLevelTree, TRUE);

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
    }

    LeaveCriticalSection (&g_MemDbCs);

    return result;
}

BOOL
MemDbDeleteKeyByHandle (
    IN      KEYHANDLE KeyHandle
    )

/*++

Routine Description:

  MemDbDeleteKeyByHandle deletes a specific key from the database
  identified by the key handle. It also removes all data associated
  with it.

Arguments:

  KeyHandle - Key Handle identifying the key

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    dbIndex = GET_DATABASE (KeyHandle);
    if (SelectDatabase (dbIndex)) {

        result = PrivateDeleteKeyByIndex (GET_INDEX (KeyHandle));

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
    }

    LeaveCriticalSection (&g_MemDbCs);

    return result;
}

BOOL
MemDbDeleteTreeA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbDeleteTree removes an entire tree branch from the database, including
  all data associated. The specified key string does not need to be
  an endpoint (i.e., specifying foo\bar will cause deletion of foo\bar\cat).

Arguments:

  KeyName - Specifies the key string to delete. This string cannot be empty.

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbDeleteTreeW (p);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteTreeW (
    IN  PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbDeleteTree removes an entire tree branch from the database, including
  all data associated. The specified key string does not need to be
  an endpoint (i.e., specifying foo\bar will cause deletion of foo\bar\cat).

Arguments:

  KeyName - Specifies the key string to delete. This string cannot be empty.

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    subKey = SelectHiveW (KeyName);
    if (subKey) {
        result = DeleteKey (subKey, g_CurrentDatabase->FirstLevelTree, FALSE);

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
    }

    LeaveCriticalSection (&g_MemDbCs);

    return result;
}

PCSTR
MemDbGetKeyFromHandleA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    )

/*++

Routine Description:

  MemDbGetKeyFromHandle will create a key string given the key handle.
  It will allocate memory from memdb's private pool to store the result.
  Caller is responsible for calling MemDbReleaseMemory on the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

Return Value:

  A valid string (using memory allocated from memdb's private pool) if
  successful, NULL otherwise.

--*/

{
    PSTR result = NULL;
    WCHAR wideBuffer[MEMDB_MAX];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    PKEYSTRUCT keyStruct;
    PSTR p;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return NULL;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        if (StartLevel == MEMDB_LAST_LEVEL) {
            //
            // Special case -- get the last level string
            //

            keyStruct = GetKeyStruct (GET_INDEX (KeyHandle));
            if (!keyStruct) {
                __leave;
            }

            result = MemDbGetMemory (keyStruct->KeyName[0] * 2 + 1);
            p = DirectUnicodeToDbcsN (
                    result,
                    keyStruct->KeyName + 1,
                    keyStruct->KeyName[0] * sizeof (WCHAR)
                    );
            *p = 0;

            __leave;
        }

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            result = MemDbGetMemory (chars*2+1);
            KnownSizeWtoA (result, wideBuffer);
            __leave;
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

PCWSTR
MemDbGetKeyFromHandleW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel
    )

/*++

Routine Description:

  MemDbGetKeyFromHandle will create a key string given the key handle.
  It will allocate memory from memdb's private pool to store the result.
  Caller is responsible for calling MemDbReleaseMemory on the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

Return Value:

  A valid string (using memory allocated from memdb's private pool) if
  successful, NULL otherwise.

--*/

{
    PWSTR result = NULL;
    WCHAR wideBuffer[MEMDB_MAX];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    PKEYSTRUCT keyStruct;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return NULL;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        if (StartLevel == MEMDB_LAST_LEVEL) {
            //
            // Special case -- get the last level string
            //

            keyStruct = GetKeyStruct (GET_INDEX (KeyHandle));
            if (!keyStruct) {
                __leave;
            }

            chars = keyStruct->KeyName[0];
            result = MemDbGetMemory ((chars + 1) * sizeof (WCHAR));
            CopyMemory (result, keyStruct->KeyName + 1, chars * sizeof (WCHAR));
            result[chars] = 0;

            __leave;
        }

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            if (chars) {
                result = MemDbGetMemory ((chars + 1) * sizeof (WCHAR));
                StringCopyW (result, wideBuffer);
                __leave;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetKeyFromHandleExA (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN OUT  PGROWBUFFER Buffer      OPTIONAL
    )

/*++

Routine Description:

  MemDbGetKeyFromHandleEx will create a key string given the key handle.
  It will use caller's grow buffer to store the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

  Buffer     - Specifies an intialized grow buffer that may contain data.
               Receives the key string, appended to data in the buffer (if
               any)

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    WCHAR wideBuffer[MEMDB_MAX];
    CHAR ansiBuffer[MEMDB_MAX*2];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            if (chars) {
                KnownSizeWtoA (ansiBuffer, wideBuffer);
                if (Buffer) {
                    (void)GbCopyStringA (Buffer, ansiBuffer);
                }
                result = TRUE;
                __leave;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetKeyFromHandleExW (
    IN      KEYHANDLE KeyHandle,
    IN      UINT StartLevel,
    IN      PGROWBUFFER Buffer      OPTIONAL
    )

/*++

Routine Description:

  MemDbGetKeyFromHandleEx will create a key string given the key handle.
  It will use caller's grow buffer to store the result.

  This function also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if a key handle points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar.

Arguments:

  KeyHandle  - Specifies the key handle that identifies the key.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

  Buffer     - Specifies an intialized grow buffer that may contain data.
               Receives the key string, appended to data in the buffer (if
               any)

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    WCHAR wideBuffer[MEMDB_MAX];
    PWSTR bufferIndex = wideBuffer;
    BYTE dbIndex;
    UINT chars;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        switch (dbIndex) {

        case DB_PERMANENT:
            break;

        case DB_TEMPORARY:

            if (StartLevel == 0) {
                bufferIndex [0] = L'~';
                bufferIndex++;
            } else {
                StartLevel --;
            }
            break;

        default:
            __leave;

        }

        if (PrivateBuildKeyFromIndex (
                StartLevel,
                GET_INDEX (KeyHandle),
                bufferIndex,
                NULL,
                NULL,
                &chars
                )) {

            if (chars) {
                if (Buffer) {
                    (void)GbCopyStringW (Buffer, wideBuffer);
                }
                result = TRUE;
                __leave;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbGetHandleFromKeyA (
    IN      PCSTR KeyName
    )

/*++

Routine Description:

  MemDbGetHandleFromKey will return the key handle associated with KeyName,
  if it's already added in memdb.

Arguments:

  KeyName - Specifies the key to search.

Return Value:

  Returns the key handle of the requested key or NULL if the key is not present.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = 0;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbGetHandleFromKeyW (keyNameW);
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbGetHandleFromKeyW (
    IN      PCWSTR KeyName
    )

/*++

Routine Description:

  MemDbGetHandleFromKey will return the key handle associated with KeyName,
  if it's already added in memdb.

Arguments:

  KeyName - Specifies the key to search.

Return Value:

  Returns the key handle of the requested key or NULL if the key is not present.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        //
        // first make sure there is a key
        // with this name.
        //
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (keyIndex);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbSetValueAndFlagsExA (
    IN      PCSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  MemDbSetValueAndFlagsEx creates the key if it doesn't exist and then
  it sets it's value and it's flags based on the arguments.

Arguments:

  KeyName       - Specifies the key string (i.e., foo\bar\cat)
  AlterValue    - Specifies if the existing value is to be altered
  Value         - Specifies the 32-bit value associated with KeyName (only needed if AlterValue is TRUE)
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  the key handle for the existent or newly added key if successful, NULL
  otherwise.

--*/

{
    PCWSTR keyNameW;
    KEYHANDLE result = 0;

    keyNameW = ConvertAtoW (KeyName);

    if (keyNameW) {
        result = MemDbSetValueAndFlagsExW (
                    keyNameW,
                    AlterValue,
                    Value,
                    ReplaceFlags,
                    SetFlags,
                    ClearFlags
                    );
        FreeConvertedStr (keyNameW);
    }

    return result;
}

KEYHANDLE
MemDbSetValueAndFlagsExW (
    IN      PCWSTR KeyName,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  MemDbSetValueAndFlagsEx creates the key if it doesn't exist and then
  it sets it's value and it's flags based on the arguments.

Arguments:

  KeyName       - Specifies the key string (i.e., foo\bar\cat)
  AlterValue    - Specifies if the existing value is to be altered
  Value         - Specifies the 32-bit value associated with KeyName (only needed if AlterValue is TRUE)
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  the key handle for the existent or newly added key if successful, NULL
  otherwise.

--*/

{
    PCWSTR subKey;
    KEYHANDLE result = 0;
    UINT keyIndex;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        if (AlterValue) {
            if (!KeyStructSetValue (keyIndex, Value)) {
                __leave;
            }
        }

        if ((ReplaceFlags && SetFlags) ||
            (!ReplaceFlags && (SetFlags || ClearFlags))
            ) {

            if (!KeyStructSetFlags (keyIndex, ReplaceFlags, SetFlags, ClearFlags)) {
                __leave;
            }
        }

        MYASSERT (keyIndex != INVALID_OFFSET);
        result = GET_EXTERNAL_INDEX (keyIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbSetValueAndFlagsByHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BOOL AlterValue,
    IN      UINT Value,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    )

/*++

Routine Description:

  MemDbSetValueAndFlagsEx modifies value and/or flags for an existing key
  identified by KeyHandle.

Arguments:

  KeyHandle     - Identifies an existing key
  AlterValue    - Specifies if the existing value is to be altered
  Value         - Specifies the 32-bit value associated with KeyName (only needed if AlterValue is TRUE)
  ReplaceFlags  - Specifies if the existing flags are to be replaced. If TRUE then we only
                  consider SetFlags as the replacing flags, ClearFlags will be ignored
  SetFlags      - Specifies the bit flags that need to be set (if ReplaceFlags is FALSE) or the
                  replacement flags (if ReplaceFlags is TRUE).
  ClearFlags    - Specifies the bit flags that should be cleared (ignored if ReplaceFlags is TRUE).

Return Value:

  the key handle for the existent or newly added key if successful, NULL
  otherwise.

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        if (AlterValue) {
            if (!KeyStructSetValue (GET_INDEX (KeyHandle), Value)) {
                __leave;
            }
        }

        if ((ReplaceFlags && SetFlags) ||
            (!ReplaceFlags && (SetFlags || ClearFlags))
            ) {

            if (!KeyStructSetFlags (GET_INDEX (KeyHandle), ReplaceFlags, SetFlags, ClearFlags)) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetValueAndFlagsA (
    IN      PCSTR KeyName,
    OUT     PUINT Value,       OPTIONAL
    OUT     PUINT Flags        OPTIONAL
    )

/*++

Routine Description:

  MemDbGetValueAndFlagsA is the external entry point for querying the database
  for a value and flags.

Arguments:

  KeyName       - Specifies the key to query (i.e., foo\bar\cat)
  Value         - Recieves the value associated with Key, if Key exists.
  Flags         - Receives the flags associated with Key, if Key exists.

Return Value:

  TRUE if Key exists in the database, FALSE otherwise.

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetValueAndFlagsW (p, Value, Flags);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbGetValueAndFlagsW (
    IN  PCWSTR KeyName,
    OUT PUINT Value,           OPTIONAL
    OUT PUINT Flags            OPTIONAL
    )

/*++

Routine Description:

  MemDbGetValueAndFlagsW is the external entry point for querying the database
  for a value and flags.

Arguments:

  KeyName       - Specifies the key to query (i.e., foo\bar\cat)
  Value         - Recieves the value associated with Key, if Key exists.
  Flags         - Receives the flags associated with Key, if Key exists.

Return Value:

  TRUE if Key exists in the database, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = TRUE;

        result = result && KeyStructGetValue (GetKeyStruct (keyIndex), Value);
        result = result && KeyStructGetFlags (GetKeyStruct (keyIndex), Flags);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbGetValueAndFlagsByHandle (
    IN  KEYHANDLE KeyHandle,
    OUT PUINT Value,           OPTIONAL
    OUT PUINT Flags            OPTIONAL
    )

/*++

Routine Description:

  MemDbGetValueAndFlagsByHandle is the external entry point for querying the database
  for a value and flags based on a key handle.

Arguments:

  KeyHandle     - Specifies the key handle to query
  Value         - Recieves the value associated with Key, if KeyHandle exists.
  Flags         - Receives the flags associated with Key, if KeyHandle exists.

Return Value:

  TRUE if KeyHandle exists in the database, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    PKEYSTRUCT keyStruct;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {

        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        keyStruct = GetKeyStruct (GET_INDEX (KeyHandle));
        if (!keyStruct) {
            __leave;
        }

        result = TRUE;

        result = result && KeyStructGetValue (keyStruct, Value);
        result = result && KeyStructGetFlags (keyStruct, Flags);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbAddData is the a general purpose routine for adding binary data for a key.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    PCWSTR p;
    DATAHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbAddDataW (p, Type, Instance, Data, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}

DATAHANDLE
MemDbAddDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbAddData is the a general purpose routine for adding binary data for a key.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        dataIndex = KeyStructAddBinaryData (keyIndex, Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbAddData is the a general purpose routine for adding binary data for a key.

Arguments:

  KeyHandle     - Specifies the key using the key handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructAddBinaryData (GET_INDEX (KeyHandle), Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGetDataHandleA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p;
    DATAHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetDataHandleW (p, Type, Instance);
        FreeConvertedStr (p);
    }

    return result;
}


DATAHANDLE
MemDbGetDataHandleW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        dataIndex = KeyStructGetDataIndex (keyIndex, Type, Instance);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbSetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetData is the a general purpose routine for setting binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is replaced

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    PCWSTR p;
    DATAHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbSetDataW (p, Type, Instance, Data, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


DATAHANDLE
MemDbSetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetData is the a general purpose routine for setting binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is replaced, if it doesn't, it is created.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data   handle if function was successful, NULL otherwise.

--*/

{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        KeyStructDeleteBinaryData (keyIndex, Type, Instance);
        dataIndex = KeyStructAddBinaryData (keyIndex, Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbSetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetData is the a general purpose routine for replacing an existing binary data.

Arguments:

  DataHandle    - Specifies an existing data handle
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!DataHandle) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructReplaceBinaryDataByIndex (GET_INDEX (DataHandle), Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }
        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbSetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbSetDataByKeyHandle is the a general purpose routine for setting binary data for a key.
  If this type of data already exists, it is replaced, if it doesn't, it is created.

Arguments:

  KeyHandle     - Specifies the key using the key handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        KeyStructDeleteBinaryData (GET_INDEX (KeyHandle), Type, Instance);
        dataIndex = KeyStructAddBinaryData (GET_INDEX (KeyHandle), Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowData is the a general purpose routine for growing binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is growed by appending the new data, if not, it is created by adding the new data

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    PCWSTR p;
    DATAHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGrowDataW (p, Type, Instance, Data, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowData is the a general purpose routine for growing binary data for a key.
  If the key does not exist, it is created. If this type of data already exists, it
  is growed by appending the new data, if not, it is created by adding the new data

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        dataIndex = KeyStructGrowBinaryData (keyIndex, Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowDataByDataHandle is the a general purpose routine for growing binary data for a key.

Arguments:

  DataHandle    - Specifies the existing binary data handle
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructGrowBinaryDataByIndex (GET_INDEX (DataHandle), Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


DATAHANDLE
MemDbGrowDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  MemDbGrowDataByDataHandle is the a general purpose routine for growing binary
  data for a key. If the data is not present it is added, if it's present, the
  new data is appended.

Arguments:

  KeyHandle     - Specifies the key we want by it's handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Data          - Specifies the address of the data to be added.
  DataSize      - Specifies the size of the data.

Return Value:

  A valid data handle if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if (!KeyHandle) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructGrowBinaryData (GET_INDEX (KeyHandle), Type, Instance, Data, DataSize);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


PBYTE
MemDbGetDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return NULL. The
  function will allocate memory from memdb's private pool. Caller is responsible
  for releasing the memory.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.  Caller must
  free non-NULL return values by calling MemDbReleaseMemory.

--*/

{
    PCWSTR p;
    PBYTE result = NULL;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetDataW (p, Type, Instance, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


PBYTE
MemDbGetDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize          OPTIONAL
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return NULL. The
  function will allocate memory from memdb's private pool. Caller is responsible
  for releasing the memory.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.  Caller must
  free non-NULL return values by calling MemDbReleaseMemory.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    PBYTE tempResult = NULL;
    PBYTE result = NULL;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return NULL;
    }

    if (Instance > 3) {
        return NULL;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        tempResult = KeyStructGetBinaryData (keyIndex, Type, Instance, &localSize, NULL);

        if (tempResult) {
            result = MemDbGetMemory (localSize);

            if (result) {
                CopyMemory (result, tempResult, localSize);

                if (DataSize) {
                    *DataSize = localSize;
                }
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


PBYTE
MemDbGetDataByDataHandle (
    IN      DATAHANDLE DataHandle,
    OUT     PUINT DataSize                  OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByDataHandle is the a general purpose routine for retrieving
  existing binary data for a key.

Arguments:

  DataHandle    - Specifies the data that's needed identified by the data handle
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE result = NULL;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        tempResult = KeyStructGetBinaryDataByIndex (GET_INDEX (DataHandle), &localSize);

        if (tempResult) {
            result = MemDbGetMemory (localSize);

            if (result) {
                CopyMemory (result, tempResult, localSize);

                if (DataSize) {
                    *DataSize = localSize;
                }
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


PBYTE
MemDbGetDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize                      OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByKeyHandle is the a general purpose routine for retrieving existing binary data for a key.

Arguments:

  KeyHandle     - Specifies the key by it's hey handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  DataSize      - Receives the size of the data.

Return Value:

  A valid memory address if function was successful, NULL otherwise.  Caller must
  free non-NULL return values by calling MemDbReleaseMemory.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE result = NULL;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return NULL;
    }

    if (Instance > 3) {
        return NULL;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        tempResult = KeyStructGetBinaryData (GET_INDEX (KeyHandle), Type, Instance, &localSize, NULL);

        if (tempResult) {
            result = MemDbGetMemory (localSize);

            if (result) {
                CopyMemory (result, tempResult, localSize);

                if (DataSize) {
                    *DataSize = localSize;
                }
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbGetDataExA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PGROWBUFFER Buffer,         OPTIONAL
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataEx is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return FALSE. The
  function will use the caller supplied growbuffer to store the data.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetDataExW (p, Type, Instance, Buffer, DataSize);
        FreeConvertedStr (p);
    }

    return result;
}


BOOL
MemDbGetDataExW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PGROWBUFFER Buffer,         OPTIONAL
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for retrieving existing binary
  data for a key. if the key or binary data do not exist, will return FALSE. The
  function will use the caller supplied growbuffer to store the data.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    PBYTE tempResult = NULL;
    PBYTE destResult = NULL;
    BOOL result = FALSE;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        tempResult = KeyStructGetBinaryData (keyIndex, Type, Instance, &localSize, NULL);

        if (tempResult) {

            if (Buffer) {

                destResult = GbGrow (Buffer, localSize);

                if (destResult) {

                    CopyMemory (destResult, tempResult, localSize);
                    result = TRUE;

                }
            } else {
                result = TRUE;
            }

            if (result && DataSize) {
                *DataSize = localSize;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbGetDataByDataHandleEx (
    IN      DATAHANDLE DataHandle,
    OUT     PGROWBUFFER Buffer,         OPTIONAL
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByDataHandleEx is the a general purpose routine for retrieving
  existing binary data for a key. The function will use the caller supplied
  growbuffer to store the data.

Arguments:

  DataHandle    - Specifies the data that's needed identified by the data handle
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE destResult = NULL;
    BOOL result = FALSE;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        tempResult = KeyStructGetBinaryDataByIndex (GET_INDEX (DataHandle), &localSize);

        if (tempResult) {

            if (Buffer) {

                destResult = GbGrow (Buffer, localSize);

                if (destResult) {

                    CopyMemory (destResult, tempResult, localSize);
                    result = TRUE;

                }
            } else {
                result = TRUE;
            }

            if (result && DataSize) {
                *DataSize = localSize;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbGetDataByKeyHandleEx (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PGROWBUFFER Buffer,         OPTIONAL
    OUT     PUINT DataSize              OPTIONAL
    )

/*++

Routine Description:

  MemDbGetDataByKeyHandle is the a general purpose routine for retrieving
  existing binary data for a key. The function will use the caller supplied
  growbuffer to store the data.

Arguments:

  KeyHandle     - Specifies the key by it's hey handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)
  Buffer        - Specifies a grow buffer that may contain data.  Receives the
                  stored data (appended to existing data).
  DataSize      - Receives the size of the data.

Return Value:

  TRUE if binary data exists for the key, and was successfully stored in
  Buffer, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    PBYTE tempResult = NULL;
    PBYTE destResult = NULL;
    BOOL result = FALSE;
    UINT localSize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        tempResult = KeyStructGetBinaryData (GET_INDEX (KeyHandle), Type, Instance, &localSize, NULL);

        if (tempResult) {

            if (Buffer) {

                destResult = GbGrow (Buffer, localSize);

                if (destResult) {

                    CopyMemory (destResult, tempResult, localSize);
                    result = TRUE;

                }
            } else {
                result = TRUE;
            }

            if (result && DataSize) {
                *DataSize = localSize;
            }
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}


BOOL
MemDbDeleteDataA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  MemDbGetData is the a general purpose routine for removing existing data for a
  key. If the data does not exist the function will return TRUE anyway.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)

Return Value:

  TRUE if function was successful, FALSE otherwise.

--*/

{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbDeleteDataW (p, Type, Instance);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteDataW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  MemDbDeleteData is the a general purpose routine for removing existing binary
  data for a key. If the data does not exist the function will return TRUE
  anyway.

Arguments:

  KeyName       - Specifies the key string to add (i.e., foo\bar\cat)
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)

Return Value:

  TRUE if function was successful, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_UNORDERED) &&
        (Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = KeyStructDeleteBinaryData (keyIndex, Type, Instance);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteDataByDataHandle (
    IN      DATAHANDLE DataHandle
    )

/*++

Routine Description:

  MemDbGetDataByDataHandleEx is the a general purpose routine for removing
  existing binary data for a key.

Arguments:

  DataHandle    - Specifies the data that's needed identified by the data handle

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructDeleteBinaryDataByIndex (GET_INDEX (DataHandle));
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteDataByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance
    )

/*++

Routine Description:

  MemDbGetDataByDataHandleEx is the a general purpose routine for removing
  existing binary data for a key.

Arguments:

  KeyHandle     - Specifies the key by it's hey handle
  Type          - Specifies data type (DATAFLAG_UNORDERED, DATAFLAG_SINGLELINK or DATAFLAG_DOUBLELINK)
  Instance      - Specifies data instance (0-3)

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructDeleteBinaryData (GET_INDEX (KeyHandle), Type, Instance);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    PCWSTR p;
    DATAHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbAddLinkageValueW (p, Type, Instance, Linkage, AllowDuplicates);
        FreeConvertedStr (p);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    UINT keyIndex;
    UINT dataIndex;
    PCWSTR subKey;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {

            keyIndex = NewKey (subKey);
            if (keyIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        dataIndex = KeyStructAddLinkage (keyIndex, Type, Instance, Linkage, AllowDuplicates);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructAddLinkageByIndex (GET_INDEX (DataHandle), Linkage, AllowDuplicates);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

DATAHANDLE
MemDbAddLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    )
{
    BYTE dbIndex;
    UINT dataIndex;
    DATAHANDLE result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        dataIndex = KeyStructAddLinkage (GET_INDEX (KeyHandle), Type, Instance, Linkage, AllowDuplicates);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        result = GET_EXTERNAL_INDEX (dataIndex);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbDeleteLinkageValueW (p, Type, Instance, Linkage, FirstOnly);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = KeyStructDeleteLinkage (keyIndex, Type, Instance, Linkage, FirstOnly);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructDeleteLinkageByIndex (GET_INDEX (DataHandle), Linkage, FirstOnly);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructDeleteLinkage (GET_INDEX (KeyHandle), Type, Instance, Linkage, FirstOnly);
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageValueA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage
    )
{
    PCWSTR p;
    BOOL result = FALSE;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbTestLinkageValueW (p, Type, Instance, Linkage);
        FreeConvertedStr (p);
    }

    return result;
}

BOOL
MemDbTestLinkageValueW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    )
{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        result = KeyStructTestLinkage (keyIndex, Type, Instance, Linkage);
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageValueByDataHandle (
    IN      DATAHANDLE DataHandle,
    IN      KEYHANDLE Linkage
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (DataHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructTestLinkageByIndex (GET_INDEX (DataHandle), Linkage);
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageValueByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    )
{
    BYTE dbIndex;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        result = KeyStructTestLinkage (GET_INDEX (KeyHandle), Type, Instance, Linkage);
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbAddLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p1 = NULL;
    PCWSTR p2 = NULL;
    BOOL result = FALSE;

    p1 = ConvertAtoW (KeyName1);
    p2 = ConvertAtoW (KeyName2);
    if (p1 && p2) {
        result = MemDbAddLinkageW (p1, p2, Type, Instance);
    }
    if (p1) {
        FreeConvertedStr (p1);
    }
    if (p2) {
        FreeConvertedStr (p2);
    }

    return result;
}

BOOL
MemDbAddLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    UINT dataIndex;
    PCWSTR subKey1;
    PCWSTR subKey2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        keyIndex1 = FindKey (subKey1);

        if (keyIndex1 == INVALID_OFFSET) {

            keyIndex1 = NewKey (subKey1);
            if (keyIndex1 == INVALID_OFFSET) {
                __leave;
            }
        }

        subKey2 = SelectHiveW (KeyName2);
        if (!subKey2) {
            __leave;
        }

        keyIndex2 = FindKey (subKey2);

        if (keyIndex2 == INVALID_OFFSET) {

            keyIndex2 = NewKey (subKey2);
            if (keyIndex2 == INVALID_OFFSET) {
                __leave;
            }
        }

        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        MYASSERT (keyIndex2 != INVALID_OFFSET);
        dataIndex = KeyStructAddLinkage (keyIndex1, Type, Instance, GET_EXTERNAL_INDEX (keyIndex2), FALSE);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        if (Type == DATAFLAG_DOUBLELINK) {

            subKey2 = SelectHiveW (KeyName2);
            if (!subKey2) {
                __leave;
            }

            MYASSERT (keyIndex1 != INVALID_OFFSET);
            dataIndex = KeyStructAddLinkage (keyIndex2, Type, Instance, GET_EXTERNAL_INDEX (keyIndex1), FALSE);

            if (dataIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbAddLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    UINT dataIndex;
    BYTE dbIndex1;
    BYTE dbIndex2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex1 = GET_DATABASE (KeyHandle1);
        if (!SelectDatabase (dbIndex1)) {
            __leave;
        }

        keyIndex1 = GET_INDEX (KeyHandle1);

        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        dbIndex2 = GET_DATABASE (KeyHandle2);
        if (!SelectDatabase (dbIndex2)) {
            __leave;
        }

        keyIndex2 = GET_INDEX (KeyHandle2);
        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        SelectDatabase (dbIndex1);
        dataIndex = KeyStructAddLinkage (keyIndex1, Type, Instance, KeyHandle2, FALSE);

        if (dataIndex == INVALID_OFFSET) {
            __leave;
        }

        if (Type == DATAFLAG_DOUBLELINK) {

            SelectDatabase (dbIndex2);
            dataIndex = KeyStructAddLinkage (keyIndex2, Type, Instance, KeyHandle1, FALSE);

            if (dataIndex == INVALID_OFFSET) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p1 = NULL;
    PCWSTR p2 = NULL;
    BOOL result = FALSE;

    p1 = ConvertAtoW (KeyName1);
    p2 = ConvertAtoW (KeyName2);
    if (p1 && p2) {
        result = MemDbDeleteLinkageW (p1, p2, Type, Instance);
    }
    if (p1) {
        FreeConvertedStr (p1);
    }
    if (p2) {
        FreeConvertedStr (p2);
    }

    return result;
}

BOOL
MemDbDeleteLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    PCWSTR subKey1;
    PCWSTR subKey2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        keyIndex1 = FindKey (subKey1);

        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        subKey2 = SelectHiveW (KeyName2);
        if (!subKey2) {
            __leave;
        }

        keyIndex2 = FindKey (subKey2);

        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        MYASSERT (keyIndex2 != INVALID_OFFSET);
        result = KeyStructDeleteLinkage (keyIndex1, Type, Instance, GET_EXTERNAL_INDEX (keyIndex2), FALSE);

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            subKey2 = SelectHiveW (KeyName2);
            if (!subKey2) {
                __leave;
            }

            MYASSERT (keyIndex1 != INVALID_OFFSET);
            result = KeyStructDeleteLinkage (keyIndex2, Type, Instance, GET_EXTERNAL_INDEX (keyIndex1), FALSE);
        }
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbDeleteLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    BYTE dbIndex1;
    BYTE dbIndex2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex1 = GET_DATABASE (KeyHandle1);
        if (!SelectDatabase (dbIndex1)) {
            __leave;
        }

        keyIndex1 = GET_INDEX (KeyHandle1);
        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        dbIndex2 = GET_DATABASE (KeyHandle2);
        if (!SelectDatabase (dbIndex2)) {
            __leave;
        }

        keyIndex2 = GET_INDEX (KeyHandle2);
        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        SelectDatabase (dbIndex1);

        result = KeyStructDeleteLinkage (keyIndex1, Type, Instance, KeyHandle2, FALSE);

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            SelectDatabase (dbIndex2);

            result = KeyStructDeleteLinkage (keyIndex2, Type, Instance, KeyHandle1, FALSE);
        }
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageA (
    IN      PCSTR KeyName1,
    IN      PCSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    PCWSTR p1 = NULL;
    PCWSTR p2 = NULL;
    BOOL result = FALSE;

    p1 = ConvertAtoW (KeyName1);
    p2 = ConvertAtoW (KeyName2);
    if (p1 && p2) {
        result = MemDbTestLinkageW (p1, p2, Type, Instance);
    }
    if (p1) {
        FreeConvertedStr (p1);
    }
    if (p2) {
        FreeConvertedStr (p2);
    }

    return result;
}

BOOL
MemDbTestLinkageW (
    IN      PCWSTR KeyName1,
    IN      PCWSTR KeyName2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    PCWSTR subKey1;
    PCWSTR subKey2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        keyIndex1 = FindKey (subKey1);

        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        subKey2 = SelectHiveW (KeyName2);
        if (!subKey2) {
            __leave;
        }

        keyIndex2 = FindKey (subKey2);

        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        subKey1 = SelectHiveW (KeyName1);
        if (!subKey1) {
            __leave;
        }

        MYASSERT (keyIndex2 != INVALID_OFFSET);
        result = KeyStructTestLinkage (keyIndex1, Type, Instance, GET_EXTERNAL_INDEX (keyIndex2));

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            subKey2 = SelectHiveW (KeyName2);
            if (!subKey2) {
                __leave;
            }

            MYASSERT (keyIndex1 != INVALID_OFFSET);
            result = KeyStructTestLinkage (keyIndex2, Type, Instance, GET_EXTERNAL_INDEX (keyIndex1));
        }
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
MemDbTestLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle1,
    IN      KEYHANDLE KeyHandle2,
    IN      BYTE Type,
    IN      BYTE Instance
    )
{
    UINT keyIndex1;
    UINT keyIndex2;
    BYTE dbIndex1;
    BYTE dbIndex2;
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return FALSE;
    }

    if (Instance > 3) {
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex1 = GET_DATABASE (KeyHandle1);
        if (!SelectDatabase (dbIndex1)) {
            __leave;
        }

        keyIndex1 = GET_INDEX (KeyHandle1);
        if (keyIndex1 == INVALID_OFFSET) {
            __leave;
        }

        dbIndex2 = GET_DATABASE (KeyHandle2);
        if (!SelectDatabase (dbIndex2)) {
            __leave;
        }

        keyIndex2 = GET_INDEX (KeyHandle2);
        if (keyIndex2 == INVALID_OFFSET) {
            __leave;
        }

        SelectDatabase (dbIndex1);

        result = KeyStructTestLinkage (keyIndex1, Type, Instance, KeyHandle2);

        if (result && (Type == DATAFLAG_DOUBLELINK)) {

            SelectDatabase (dbIndex2);

            result = KeyStructTestLinkage (keyIndex2, Type, Instance, KeyHandle1);
        }
    }
    __finally {

        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbGetLinkageA (
    IN      PCSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    )
{
    PCWSTR p = NULL;
    KEYHANDLE result = 0;

    p = ConvertAtoW (KeyName);
    if (p) {
        result = MemDbGetLinkageW (p, Type, Instance, LinkageIndex);
        FreeConvertedStr (p);
    }

    return result;
}

KEYHANDLE
MemDbGetLinkageW (
    IN      PCWSTR KeyName,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    )
{
    UINT keyIndex;
    PCWSTR subKey;
    KEYHANDLE result = 0;
    PUINT linkArray;
    UINT linkArraySize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (KeyName);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKey (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        linkArraySize = 0;

        linkArray = (PUINT)KeyStructGetBinaryData (keyIndex, Type, Instance, &linkArraySize, NULL);

        linkArraySize = linkArraySize / SIZEOF(UINT);

        if (linkArraySize <= LinkageIndex) {
            __leave;
        }

        result = linkArray [LinkageIndex];
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

KEYHANDLE
MemDbGetLinkageByKeyHandle (
    IN      KEYHANDLE KeyHandle,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT LinkageIndex
    )
{
    UINT keyIndex;
    BYTE dbIndex;
    KEYHANDLE result = 0;
    PUINT linkArray;
    UINT linkArraySize;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    if ((Type != DATAFLAG_SINGLELINK) &&
        (Type != DATAFLAG_DOUBLELINK)
        ) {
        return result;
    }

    if (Instance > 3) {
        return result;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        keyIndex = GET_INDEX (KeyHandle);
        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        linkArray = (PUINT)KeyStructGetBinaryData (keyIndex, Type, Instance, &linkArraySize, NULL);

        linkArraySize = linkArraySize / SIZEOF(UINT);

        if (linkArraySize <= LinkageIndex) {
            __leave;
        }

        result = linkArray [LinkageIndex];
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return result;
}

BOOL
pCheckEnumConditions (
    IN      UINT KeyIndex,
    IN      PMEMDB_ENUMW MemDbEnum
    )
{
    PKEYSTRUCT keyStruct;
    UINT index;
    PWSTR segPtr, segEndPtr;

    keyStruct = GetKeyStruct (KeyIndex);
    MYASSERT (keyStruct);

    if (keyStruct->KeyFlags & KSF_ENDPOINT) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_ENDPOINTS)) {
            return FALSE;
        }
        MemDbEnum->EndPoint = TRUE;
    } else {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_NONENDPOINTS)) {
            return FALSE;
        }
        MemDbEnum->EndPoint = FALSE;
    }
    if (keyStruct->DataFlags & DATAFLAG_UNORDERED) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_UNORDERED)) {
            return FALSE;
        }
    }
    if (keyStruct->DataFlags & DATAFLAG_SINGLELINK) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_SINGLELINK)) {
            return FALSE;
        }
    }
    if (keyStruct->DataFlags & DATAFLAG_DOUBLELINK) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_DOUBLELINK)) {
            return FALSE;
        }
    }
    if (keyStruct->DataFlags & DATAFLAG_VALUE) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_VALUE)) {
            return FALSE;
        }
        MemDbEnum->Value = keyStruct->Value;
    } else {
        MemDbEnum->Value = 0;
    }
    if (keyStruct->DataFlags & DATAFLAG_FLAGS) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_FLAGS)) {
            return FALSE;
        }
        MemDbEnum->Flags = keyStruct->Flags;
    } else {
        MemDbEnum->Flags = 0;
    }
    if (!keyStruct->DataFlags) {
        if (!(MemDbEnum->EnumFlags & ENUMFLAG_EMPTY)) {
            return FALSE;
        }
    }
    if (MemDbEnum->BeginLevel != ENUMLEVEL_LASTLEVEL) {
        if (MemDbEnum->CurrentLevel - 1 < MemDbEnum->BeginLevel) {
            return FALSE;
        }
        if (MemDbEnum->CurrentLevel - 1 > MemDbEnum->EndLevel) {
            return FALSE;
        }
    }

    MYASSERT (KeyIndex != INVALID_OFFSET);
    MemDbEnum->KeyHandle = GET_EXTERNAL_INDEX (KeyIndex);

    index = 0;
    segPtr = MemDbEnum->KeyNameCopy;
    MemDbEnum->FullKeyName[0] = 0;
    MemDbEnum->KeyName[0] = 0;

    while (segPtr) {
        segEndPtr = wcschr (segPtr, L'\\');
        if (segEndPtr) {
            *segEndPtr = 0;
        }

        index ++;
        if (index > 1) {
            StringCatW (MemDbEnum->FullKeyName, L"\\");
            StringCatW (MemDbEnum->FullKeyName, segPtr);
        } else {
            switch (g_CurrentDatabaseIndex) {

            case DB_PERMANENT:
                StringCopyW (MemDbEnum->FullKeyName, segPtr);
                break;

            case DB_TEMPORARY:

                StringCopyW (MemDbEnum->FullKeyName, L"~");
                StringCatW (MemDbEnum->FullKeyName, segPtr);
                break;

            default:
                StringCopyW (MemDbEnum->FullKeyName, segPtr);

            }
        }
        if (MemDbEnum->BeginLevel == ENUMLEVEL_LASTLEVEL) {
            if (index >= MemDbEnum->CurrentLevel) {
                //this is the last segment, copy it to the
                //partial key
                StringCopyW (MemDbEnum->KeyName, segPtr);
            }
        } else {
            if (index > MemDbEnum->BeginLevel) {
                //copy the current segment in partial key
                if ((index - 1) == MemDbEnum->BeginLevel) {
                    if (index == 1) {
                        switch (g_CurrentDatabaseIndex) {

                        case DB_PERMANENT:
                            StringCopyW (MemDbEnum->KeyName, segPtr);
                            break;

                        case DB_TEMPORARY:

                            StringCopyW (MemDbEnum->KeyName, L"~");
                            StringCatW (MemDbEnum->KeyName, segPtr);
                            break;

                        default:
                            StringCopyW (MemDbEnum->KeyName, segPtr);

                        }
                    } else {
                        StringCopyW (MemDbEnum->KeyName, segPtr);
                    }
                } else {
                    StringCatW (MemDbEnum->KeyName, L"\\");
                    StringCatW (MemDbEnum->KeyName, segPtr);
                }
            }
        }

        if (segEndPtr) {
            segPtr = segEndPtr + 1;
            *segEndPtr = L'\\';
        } else {
            segPtr = NULL;
        }

        if (index >= MemDbEnum->CurrentLevel) {
            // no more segments to copy
            break;
        }
    }
    return TRUE;
}

VOID
pAddKeyToEnumStruct (
    IN OUT  PMEMDB_ENUMW MemDbEnum,
    IN      PCWSTR KeyName
    )
{
    PCWSTR lastName;
    PWSTR endPtr;

    lastName = MemDbEnum->KeyNameCopy;
    if (lastName) {
        MemDbEnum->KeyNameCopy = JoinTextExW (g_MemDbPool, lastName, L"\\", NULL, KeyName[0] + 1, &endPtr);
        StringPasCopyConvertFrom (endPtr, KeyName);
        MemDbReleaseMemory ((PBYTE)lastName);
    } else {
        MemDbEnum->KeyNameCopy = (PWSTR)MemDbGetMemory ((KeyName[0] + 1) * SIZEOF(WCHAR));
        StringPasCopyConvertFrom ((PWSTR)MemDbEnum->KeyNameCopy, KeyName);
    }
    // NTRAID#NTBUG9-153308-2000/08/01-jimschm  this way of doing it will fill out the pool very fast.
    // need to find a way to release first and allocate after that.
}

VOID
pDeleteLastKeyFromEnumStruct (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    PWSTR lastWackPtr;

    lastWackPtr = wcsrchr (MemDbEnum->KeyNameCopy, L'\\');
    if (lastWackPtr) {
        *lastWackPtr = 0;
    } else {
        MemDbReleaseMemory (MemDbEnum->KeyNameCopy);
        MemDbEnum->KeyNameCopy = NULL;
    }
}

BOOL
pMemDbEnumNextW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    BOOL shouldReturn = FALSE;
    BOOL result = FALSE;
    BOOL patternMatch = TRUE;
    BOOL goOn = TRUE;
    BOOL patternFound;
    UINT treeEnumContext;
    UINT treeEnumNode;
    UINT tempKeyIndex;
    PKEYSTRUCT tempKeyStruct;
    PBYTE gbAddress;
    UINT minLevel;
    UINT internalLevel;

    while (!shouldReturn) {

        if (MemDbEnum->EnumerationMode) {

            result = FALSE;

            minLevel = MemDbEnum->CurrentLevel;
            internalLevel = MemDbEnum->CurrentLevel;

            if (MemDbEnum->TreeEnumLevel == MemDbEnum->TreeEnumBuffer.End) {

                patternMatch = FALSE;

                while (!patternMatch) {

                    if (MemDbEnum->TreeEnumBuffer.End) {

                        goOn = TRUE;

                        while (goOn) {
                            // we are in the middle of some tree enumeration
                            // let's get back the context and continue
                            if (MemDbEnum->TreeEnumBuffer.End == 0) {
                                // we can't back out any more, we're done
                                break;
                            }
                            MemDbEnum->TreeEnumBuffer.End -= (SIZEOF(UINT)+SIZEOF(UINT));
                            if (MemDbEnum->TreeEnumLevel > MemDbEnum->TreeEnumBuffer.End) {
                                MemDbEnum->TreeEnumLevel = MemDbEnum->TreeEnumBuffer.End;
                            }
                            minLevel --;
                            if (MemDbEnum->CurrentLevel > minLevel) {
                                MemDbEnum->CurrentLevel = minLevel;
                            }
                            if (internalLevel > minLevel) {
                                internalLevel = minLevel;
                            }
                            pDeleteLastKeyFromEnumStruct (MemDbEnum);
                            treeEnumContext = *((PUINT) (MemDbEnum->TreeEnumBuffer.Buf+MemDbEnum->TreeEnumBuffer.End + SIZEOF(UINT)));
                            tempKeyIndex = BinTreeEnumNext (&treeEnumContext);
                            if (tempKeyIndex != INVALID_OFFSET) {
                                minLevel ++;
                                internalLevel ++;
                                goOn = FALSE;
                                // put them in the grow buffer
                                gbAddress = GbGrow (&(MemDbEnum->TreeEnumBuffer), SIZEOF(UINT)+SIZEOF(UINT));
                                if (gbAddress) {
                                    *((PUINT) (gbAddress)) = tempKeyIndex;
                                    *((PUINT) (gbAddress+SIZEOF(UINT))) = treeEnumContext;
                                }
                                tempKeyStruct = GetKeyStruct (tempKeyIndex);
                                MYASSERT (tempKeyStruct);
                                pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                                treeEnumNode = tempKeyStruct->NextLevelTree;
                                while ((treeEnumNode != INVALID_OFFSET) &&
                                       (internalLevel - 1 <= MemDbEnum->EndLevel)
                                       ) {
                                    tempKeyIndex = BinTreeEnumFirst (treeEnumNode, &treeEnumContext);
                                    if (tempKeyIndex != INVALID_OFFSET) {
                                        minLevel ++;
                                        internalLevel ++;
                                        // put them in the grow buffer
                                        gbAddress = GbGrow (&(MemDbEnum->TreeEnumBuffer), SIZEOF(UINT)+SIZEOF(UINT));
                                        if (gbAddress) {
                                            *((PUINT) (gbAddress)) = tempKeyIndex;
                                            *((PUINT) (gbAddress+SIZEOF(UINT))) = treeEnumContext;
                                        }
                                        tempKeyStruct = GetKeyStruct (tempKeyIndex);
                                        MYASSERT (tempKeyStruct);
                                        pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                                        treeEnumNode = tempKeyStruct->NextLevelTree;
                                    } else {
                                        treeEnumNode = INVALID_OFFSET;
                                    }
                                }
                            }
                        }

                    } else {
                        // we are about to start the tree enumeration
                        // let's start the enumeration and push the
                        // context data in our buffer

                        treeEnumNode = MemDbEnum->CurrentIndex;
                        while ((treeEnumNode != INVALID_OFFSET) &&
                               (internalLevel <= MemDbEnum->EndLevel)
                               ) {
                            tempKeyIndex = BinTreeEnumFirst (treeEnumNode, &treeEnumContext);
                            if (tempKeyIndex != INVALID_OFFSET) {
                                minLevel ++;
                                internalLevel ++;
                                // put them in the grow buffer
                                gbAddress = GbGrow (&(MemDbEnum->TreeEnumBuffer), SIZEOF(UINT)+SIZEOF(UINT));
                                if (gbAddress) {
                                    *((PUINT) (gbAddress)) = tempKeyIndex;
                                    *((PUINT) (gbAddress+SIZEOF(UINT))) = treeEnumContext;
                                }
                                tempKeyStruct = GetKeyStruct (tempKeyIndex);
                                MYASSERT (tempKeyStruct);
                                pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                                treeEnumNode = tempKeyStruct->NextLevelTree;
                            } else {
                                treeEnumNode = INVALID_OFFSET;
                            }
                        }
                    }
                    if (MemDbEnum->TreeEnumBuffer.End == 0) {
                        // we can't back out any more, we're done
                        break;
                    }
                    if (MemDbEnum->PatternStruct.PatternMatch) {
                        MYASSERT (MemDbEnum->PatternStruct.Data);
                        patternMatch =
                            MemDbEnum->PatternStruct.PatternMatch (
                                MemDbEnum->PatternStruct.Data,
                                MemDbEnum->KeyNameCopy
                                );
                    } else {
                        patternMatch = IsPatternMatchW (
                                            MemDbEnum->PatternCopy,
                                            MemDbEnum->KeyNameCopy
                                            );
                    }
                }
            }

            if (MemDbEnum->TreeEnumLevel == MemDbEnum->TreeEnumBuffer.End) {
                break;
            }
            MYASSERT (MemDbEnum->TreeEnumLevel < MemDbEnum->TreeEnumBuffer.End);

            // now implement segment by segment enumeration because we
            // just created a full key that matches the pattern
            MemDbEnum->CurrentLevel ++;
            shouldReturn = pCheckEnumConditions (
                                *((PUINT) (MemDbEnum->TreeEnumBuffer.Buf+MemDbEnum->TreeEnumLevel)),
                                MemDbEnum
                                );
            MemDbEnum->TreeEnumLevel += (SIZEOF(UINT)+SIZEOF(UINT));
            result = TRUE;

        } else {

            result = FALSE;

            if (!MemDbEnum->PatternEndPtr) {
                //we are done, no more segments
                break;
            }

            MemDbEnum->PatternPtr = MemDbEnum->PatternEndPtr;
            MemDbEnum->PatternEndPtr = wcschr (MemDbEnum->PatternPtr, L'\\');
            if (MemDbEnum->PatternEndPtr) {
                *MemDbEnum->PatternEndPtr = 0;
            }

            if (MemDbEnum->PatternStruct.PatternFind) {
                patternFound =
                    MemDbEnum->PatternStruct.PatternFind (
                        MemDbEnum->PatternPtr
                        );
            } else {
                patternFound = (wcschr (MemDbEnum->PatternPtr, L'*') ||
                                wcschr (MemDbEnum->PatternPtr, L'?')
                                );
            }

            if (patternFound) {

                MemDbEnum->EnumerationMode = TRUE;
                if (MemDbEnum->PatternEndPtr) {
                    *MemDbEnum->PatternEndPtr = L'\\';
                    MemDbEnum->PatternEndPtr++;
                }

            } else {
                tempKeyIndex = FindKeyStructInTree (
                                    MemDbEnum->CurrentIndex,
                                    MemDbEnum->PatternPtr,
                                    FALSE
                                    );
                if (tempKeyIndex == INVALID_OFFSET) {
                    // we are done, the segment we look for does not exist
                    break;
                }
                tempKeyStruct = GetKeyStruct (tempKeyIndex);
                MYASSERT (tempKeyStruct);
                pAddKeyToEnumStruct (MemDbEnum, tempKeyStruct->KeyName);
                MemDbEnum->CurrentIndex = tempKeyStruct->NextLevelTree;

                MemDbEnum->CurrentLevel ++;
                if (MemDbEnum->PatternEndPtr) {
                    *MemDbEnum->PatternEndPtr = L'\\';
                    MemDbEnum->PatternEndPtr++;
                }
                patternMatch = IsPatternMatchW (
                                    MemDbEnum->PatternCopy,
                                    MemDbEnum->KeyNameCopy
                                    );
                shouldReturn = patternMatch && pCheckEnumConditions (
                                                    tempKeyIndex,
                                                    MemDbEnum
                                                    );
                result = TRUE;
            }
        }
    }
    return result;
}

BOOL
RealMemDbEnumFirstExW (
    IN OUT  PMEMDB_ENUMW MemDbEnum,
    IN      PCWSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel,
    IN      PMEMDB_PATTERNSTRUCTW PatternStruct OPTIONAL
    )
{
    BOOL result = FALSE;
    PCWSTR subPattern;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subPattern = SelectHiveW (EnumPattern);
        if (!subPattern) {
            __leave;
        }

        ZeroMemory (MemDbEnum, SIZEOF (MEMDB_ENUMW));
        MemDbEnum->CurrentDatabaseIndex = GetCurrentDatabaseIndex ();
        MemDbEnum->EnumFlags = EnumFlags;
        MemDbEnum->PatternCopy = DuplicateTextExW (g_MemDbPool, subPattern, 0, NULL);
        if (!MemDbEnum->PatternCopy) {
            __leave;
        }
        MemDbEnum->PatternPtr = MemDbEnum->PatternCopy;
        MemDbEnum->PatternEndPtr = MemDbEnum->PatternPtr;
        MemDbEnum->CurrentIndex = g_CurrentDatabase->FirstLevelTree;
        MemDbEnum->BeginLevel = BeginLevel;
        if (MemDbEnum->BeginLevel == ENUMLEVEL_LASTLEVEL) {
            MemDbEnum->EndLevel = ENUMLEVEL_ALLLEVELS;
        } else {
            MemDbEnum->EndLevel = EndLevel;
            if (MemDbEnum->EndLevel < MemDbEnum->BeginLevel) {
                MemDbEnum->EndLevel = MemDbEnum->BeginLevel;
            }
        }
        MemDbEnum->CurrentLevel = 0;

        if (PatternStruct) {
            MemDbEnum->PatternStruct.PatternFind = PatternStruct->PatternFind;
            MemDbEnum->PatternStruct.PatternMatch = PatternStruct->PatternMatch;
            MemDbEnum->PatternStruct.Data = PatternStruct->Data;
        }

        result = pMemDbEnumNextW (MemDbEnum);

        if (!result) {
            MemDbAbortEnumW (MemDbEnum);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }
    return result;
}

BOOL
RealMemDbEnumFirstExA (
    IN OUT  PMEMDB_ENUMA MemDbEnum,
    IN      PCSTR EnumPattern,
    IN      UINT EnumFlags,
    IN      UINT BeginLevel,
    IN      UINT EndLevel,
    IN      PMEMDB_PATTERNSTRUCTW PatternStruct OPTIONAL
    )
{
    BOOL result = FALSE;
    PCWSTR unicodeStr;

    unicodeStr = ConvertAtoW (EnumPattern);
    if (!unicodeStr) {
        return FALSE;
    }
    result = RealMemDbEnumFirstExW (
                &(MemDbEnum->UnicodeEnum),
                unicodeStr,
                EnumFlags,
                BeginLevel,
                EndLevel,
                PatternStruct
                );
    if (result) {
        KnownSizeWtoA (MemDbEnum->FullKeyName, MemDbEnum->UnicodeEnum.FullKeyName);
        KnownSizeWtoA (MemDbEnum->KeyName, MemDbEnum->UnicodeEnum.KeyName);

        MemDbEnum->Value = MemDbEnum->UnicodeEnum.Value;
        MemDbEnum->Flags = MemDbEnum->UnicodeEnum.Flags;
        MemDbEnum->KeyHandle = MemDbEnum->UnicodeEnum.KeyHandle;
        MemDbEnum->EndPoint = MemDbEnum->UnicodeEnum.EndPoint;
    }

    FreeConvertedStr (unicodeStr);
    return result;
}

BOOL
RealMemDbEnumNextW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    BOOL result = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        if (!SelectDatabase (MemDbEnum->CurrentDatabaseIndex)) {
            __leave;
        }

        result = pMemDbEnumNextW (MemDbEnum);

        if (!result) {
            MemDbAbortEnumW (MemDbEnum);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }
    return result;
}

BOOL
RealMemDbEnumNextA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    )
{
    BOOL result = FALSE;

    result = RealMemDbEnumNextW (&(MemDbEnum->UnicodeEnum));
    if (result) {
        KnownSizeWtoA (MemDbEnum->FullKeyName, MemDbEnum->UnicodeEnum.FullKeyName);
        KnownSizeWtoA (MemDbEnum->KeyName, MemDbEnum->UnicodeEnum.KeyName);

        MemDbEnum->Value = MemDbEnum->UnicodeEnum.Value;
        MemDbEnum->Flags = MemDbEnum->UnicodeEnum.Flags;
        MemDbEnum->KeyHandle = MemDbEnum->UnicodeEnum.KeyHandle;
        MemDbEnum->EndPoint = MemDbEnum->UnicodeEnum.EndPoint;
    }

    return result;
}

BOOL
MemDbAbortEnumW (
    IN OUT  PMEMDB_ENUMW MemDbEnum
    )
{
    if (MemDbEnum->KeyNameCopy) {
        MemDbReleaseMemory (MemDbEnum->KeyNameCopy);
    }

    if (MemDbEnum->PatternCopy) {
        MemDbReleaseMemory (MemDbEnum->PatternCopy);
    }

    GbFree (&(MemDbEnum->TreeEnumBuffer));

    ZeroMemory (MemDbEnum, SIZEOF (MEMDB_ENUMW));
    return TRUE;
}

BOOL
MemDbAbortEnumA (
    IN OUT  PMEMDB_ENUMA MemDbEnum
    )
{
    MemDbAbortEnumW (&(MemDbEnum->UnicodeEnum));

    ZeroMemory (MemDbEnum, SIZEOF (MEMDB_ENUMA));
    return TRUE;
}

BOOL
MemDbSetInsertionOrderedA (
    IN      PCSTR Key
    )

/*++

Routine Description:

  MemDbSetInsertionOrderedA sets the enumeration order of the children of Key
  to be in the order they were inserted.

Arguments:

  Key - key to make insertion ordered

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PCWSTR unicodeKey;
    BOOL b = FALSE;

    unicodeKey = ConvertAtoW (Key);

    if (unicodeKey) {
        b = MemDbSetInsertionOrderedW (unicodeKey);
        FreeConvertedStr (unicodeKey);
    }
    return b;
}

BOOL
MemDbSetInsertionOrderedW (
    IN      PCWSTR Key
    )

/*++

Routine Description:

  MemDbSetInsertionOrderedW sets the enumeration order of the children of Key
  to be in the order they were inserted.

Arguments:

  Key - key to make insertion ordered

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    UINT keyIndex;
    PCWSTR subKey;
    BOOL b = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return b;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        subKey = SelectHiveW (Key);
        if (!subKey) {
            __leave;
        }

        keyIndex = FindKeyStruct (subKey);

        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        b = KeyStructSetInsertionOrdered(GetKeyStruct(keyIndex));
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}

BOOL
MemDbSetInsertionOrderedByKeyHandle (
    IN      KEYHANDLE KeyHandle
    )

/*++

Routine Description:

  MemDbSetInsertionOrderedByKeyHandle sets the enumeration order of the children of
  KeyHandle to be in the order they were inserted.

Arguments:

  KeyHandle - Specifies the key using the key handle

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    BYTE dbIndex;
    BOOL b = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return b;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        b = KeyStructSetInsertionOrdered (GetKeyStruct(GET_INDEX (KeyHandle)));
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}

BOOL
MemDbMoveKeyHandleToEnd (
    IN      KEYHANDLE KeyHandle
    )
{
    BYTE dbIndex;
    UINT keyIndex;
    PKEYSTRUCT keyStruct;
    UINT parentIndex;
    PKEYSTRUCT parentKeyStruct;
    UINT treeOffset;
    BOOL b = FALSE;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return b;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);

    __try {
        dbIndex = GET_DATABASE (KeyHandle);
        if (!SelectDatabase (dbIndex)) {
            __leave;
        }

        keyIndex = GET_INDEX (KeyHandle);
        if (keyIndex == INVALID_OFFSET) {
            __leave;
        }

        keyStruct = GetKeyStruct (keyIndex);
        if (!keyStruct) {
            __leave;
        }

        parentIndex = keyStruct->PrevLevelIndex;
        if (parentIndex == INVALID_OFFSET) {
            __leave;
        }

        parentKeyStruct = GetKeyStruct (parentIndex);
        if (!parentKeyStruct) {
            __leave;
        }

        if (!KeyStructSetInsertionOrdered (parentKeyStruct)) {
            __leave;
        }

        // reloading key struct and parent key struct
        keyStruct = GetKeyStruct (keyIndex);
        if (!keyStruct) {
            __leave;
        }
        parentKeyStruct = GetKeyStruct (parentIndex);
        if (!parentKeyStruct) {
            __leave;
        }

        treeOffset = parentKeyStruct->NextLevelTree;
        if (treeOffset == INVALID_OFFSET) {
            __leave;
        }

        if (!BinTreeDeleteNode (treeOffset, keyStruct->KeyName, NULL)) {
            __leave;
        }

        if (!BinTreeAddNode (treeOffset, keyIndex)) {
            __leave;
        }

        b = TRUE;
    }
    __finally {

#ifdef DEBUG
        if (g_DatabaseCheckLevel) {
            CheckDatabase (g_DatabaseCheckLevel);
        }
#endif
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}

PCBYTE
MemDbGetDatabaseAddress (
    VOID
    )
{
    PCBYTE result = NULL;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);

    EnterCriticalSection (&g_MemDbCs);
    if (SelectDatabase(0)) {
        result = g_CurrentDatabase->Buf;
    }

    LeaveCriticalSection (&g_MemDbCs);
    return result;
}

UINT
MemDbGetDatabaseSize (
    VOID
    )
/*++

Routine Description:

  MemDbGetDatabaseSize returns the size of the permanent database

Arguments:

  None.

Return Value:

  The size of the permanent database.

--*/
{
    UINT result = 0;

    if (!g_Initialized) {
        DEBUGMSG ((DBG_ERROR, "MemDb is not initialized"));
        return result;
    }

    MYASSERT (g_MemDbPool);
    EnterCriticalSection (&g_MemDbCs);

    if (SelectDatabase(0)) {
        result = g_CurrentDatabase->End;
    }

    LeaveCriticalSection (&g_MemDbCs);
    return result;
}

#ifdef DEBUG

BOOL
MemDbCheckDatabase(
    UINT Level
    )

/*++

Routine Description:

  MemDbCheckDatabase enumerates the entire database and verifies that each
  enumerated key can be found in the hash table.

Arguments:

  Level - Specifies database check level

Return Value:

  TRUE if the database is valid, FALSE otherwise.

--*/

{
    MYASSERT (g_MemDbPool);

    return (CheckDatabase(Level) && CheckLevel(g_CurrentDatabase->FirstLevelTree, INVALID_OFFSET));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\memdbp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbp.h

Abstract:

    internal functions for memdb operations

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:


--*/


//
// Constants
//

#define INVALID_OFFSET      (~((UINT)0))


//
// database types
//
#define DB_NOTHING          0x00
#define DB_PERMANENT        0x01
#define DB_TEMPORARY        0x02

#ifdef DEBUG

#define PTR_WAS_INVALIDATED(x)          (x=NULL)

#else

#define PTR_WAS_INVALIDATED(x)

#endif

//
// signatures for different memory structures.
//
#define KEYSTRUCT_SIGNATURE         ('K'+('E'<<8)+('E'<<16)+('Y'<<24))
#define DATABLOCK_SIGNATURE         ('B'+('L'<<8)+('O'<<16)+('K'<<24))
#define NODESTRUCT_SIGNATURE        ('N'+('O'<<8)+('D'<<16)+('E'<<24))
#define BINTREE_SIGNATURE           ('T'+('R'<<8)+('E'<<16)+('E'<<24))
#define LISTELEM_SIGNATURE          ('L'+('I'<<8)+('S'<<16)+('T'<<24))


#define MEMDB_VERBOSE   0


//
// KEYSTRUCT flags
//

#define KSF_ENDPOINT        0x01
#define KSF_DATABLOCK       0x02

//
// we only need this flag for easier checking
// of keys, in FindKeyStructInDatabase()
//
#ifdef DEBUG
#define KSF_DELETED         0x04
#endif






//
// database allocation parameters
//

#define ALLOC_TOLERANCE 32

#define MAX_HIVE_NAME       64


//
// Typedefs
//

typedef struct {
    UINT Size;
    UINT End;
    UINT FreeHead;
    PBYTE Buf;
} MEMDBHASH, *PMEMDBHASH;



//
//
// The DATABASE structure holds all pieces of information necessary
// to maintain a portion of the overall memory database.  There are
// two DATABASE structures, a permanent and a temporary one.
//

typedef struct {
    UINT AllocSize;
    UINT End;
    UINT FirstLevelTree;
    UINT FirstKeyDeleted;          // this stores the Offset of the key, not the Index
    UINT FirstBinTreeDeleted;
    UINT FirstBinTreeNodeDeleted;
    UINT FirstBinTreeListElemDeleted;
    BOOL AllocFailed;
    PMEMDBHASH HashTable;
    GROWBUFFER OffsetBuffer;
    UINT OffsetBufferFirstDeletedIndex;
    BYTE Buf[];
} DATABASE, *PDATABASE;



//
// Globals - defined in database.c
//

extern PDATABASE g_CurrentDatabase;
extern BYTE g_CurrentDatabaseIndex;
extern CRITICAL_SECTION g_MemDbCs;

#ifdef DEBUG
extern BOOL g_UseDebugStructs;
#endif




#define OFFSET_TO_PTR(Offset)   (g_CurrentDatabase->Buf+(Offset))
#define PTR_TO_OFFSET(Ptr)      (UINT)((UBINT)(Ptr)-(UBINT)(g_CurrentDatabase->Buf))



//
// GET_EXTERNAL_INDEX converts an internal index and converts it to a key or data handle (has database number as top byte).
// GET_DATABASE takes a key or data handle and returns the database number byte
// GET_INDEX takes a key or data handle and returns the index without the database number
//
#define GET_EXTERNAL_INDEX(Index) ((Index) | ((UINT)(g_CurrentDatabaseIndex) << (8*sizeof(UINT)-8)))
#define GET_DATABASE(Index) ((BYTE)((Index) >> (8*sizeof(UINT)-8)))
#define GET_INDEX(Index) ((Index) & (INVALID_OFFSET>>8))




//
// a KEYSTRUCT holds each piece of a memdb entry.  A single KEYSTRUCT
// holds a portion of a key (delimited by a backslash), and the
// KEYSTRUCTs are organized into a binary tree.  Each KEYSTRUCT
// can also contain additional binary trees.  This is what makes
// memdb so versatile--many relationships can be established by
// formatting key strings in various ways.
//
// when changing offset of KeyName in KEYSTRUCT (by adding new members
// or resizing or reordering, etc) be sure to change constant in
// GetDataStr macro below (currently (3*sizeof(UINT)+4)).


typedef struct {
#ifdef DEBUG
    DWORD Signature;
#endif

    union {
        UINT Value;                // value of key
        UINT DataSize;             // size of the actual data (if this is a data structure
        UINT NextDeleted;          // for deleted items, we keep a list of free blocks
    };

    UINT Flags;                    // key flags

    UINT DataStructIndex;          // offset of Data structure holding the binary data
    UINT NextLevelTree;            // offset of bintree holding next level keystructs
    UINT PrevLevelIndex;           // index of previous level keystruct

    UINT Size;                     // size of block (maybe not all of it is used)
    BYTE KeyFlags;
    BYTE DataFlags;

    union {
        WCHAR KeyName[];           // name of key (just this level, not full key)
        BYTE Data[];               // Binary data stored in this keystruct
    };
} KEYSTRUCT, *PKEYSTRUCT;

#define KEYSTRUCT_SIZE_MAIN ((WORD)(5*sizeof(UINT) + sizeof(UINT) + 2*sizeof(BYTE)))

#ifdef DEBUG
#define KEYSTRUCT_HEADER_SIZE   sizeof(DWORD)
#define KEYSTRUCT_SIZE      (KEYSTRUCT_SIZE_MAIN + \
                            (WORD)(g_UseDebugStructs ? KEYSTRUCT_HEADER_SIZE : 0))
#else
#define KEYSTRUCT_SIZE      KEYSTRUCT_SIZE_MAIN
#endif

//
// GetDataStr is used by the bintree.c functions to get
// the data string inside a data element, to be used for
// ordering in the tree.  For us, the data type is
// a KeyStruct.
//
#define GetDataStr(DataIndex) ((PWSTR)(OFFSET_TO_PTR(KeyIndexToOffset(DataIndex)+KEYSTRUCT_SIZE)))












//
// hash.c routines
//

PMEMDBHASH
CreateHashBlock (
    VOID
    );

VOID
FreeHashBlock (
    IN      PMEMDBHASH pHashTable
    );

BOOL
ReadHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    );

BOOL
WriteHashBlock (
    IN      PMEMDBHASH pHashTable,
    IN OUT  PBYTE *Buf
    );

UINT
GetHashTableBlockSize (
    IN      PMEMDBHASH pHashTable
    );

BOOL
AddHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString,
    IN      UINT Offset
    );

UINT
FindStringInHashTable (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    );

BOOL
RemoveHashTableEntry (
    IN      PMEMDBHASH pHashTable,
    IN      PCWSTR FullString
    );



//
// memdbfile.c
//



BOOL
SetSizeOfFile (
    HANDLE hFile,
    LONGLONG Size
    );

PBYTE
MapFileFromHandle (
    HANDLE hFile,
    PHANDLE hMap
    );

#define UnmapFileFromHandle(Buf, hMap) UnmapFile(Buf, hMap, INVALID_HANDLE_VALUE)





//
// database.c
//


BOOL
DatabasesInitializeA (
    IN      PCSTR DatabasePath  OPTIONAL
    );

BOOL
DatabasesInitializeW (
    IN      PCWSTR DatabasePath  OPTIONAL
    );

PCSTR
DatabasesGetBasePath (
    VOID
    );

VOID
DatabasesTerminate (
    IN      BOOL EraseDatabasePath
    );

BOOL
SizeDatabaseBuffer (
    IN      BYTE DatabaseIndex,
    IN      UINT NewSize
    );

UINT
DatabaseAllocBlock (
    IN      UINT Size
    );

BOOL
SelectDatabase (
    IN      BYTE DatabaseIndex
    );

PCWSTR
SelectHiveW (
    IN      PCWSTR FullKeyStr
    );

BYTE
GetCurrentDatabaseIndex (
    VOID
    );

#ifdef DEBUG

BOOL
CheckDatabase (
    IN      UINT Level
    );

#endif


//
// offsetbuf.c
//

VOID
RedirectKeyIndex (
    IN      UINT Index,
    IN      UINT TargetIndex
    );

UINT
KeyIndexToOffset (
    IN  UINT Index
    );

UINT
AddKeyOffsetToBuffer(
    IN  UINT Offset
    );

VOID
RemoveKeyOffsetFromBuffer(
    IN  UINT Index
    );

VOID
MarkIndexList (
    PUINT IndexList,
    UINT IndexListSize
    );

BOOL
ReadOffsetBlock (
    OUT     PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    );

BOOL
WriteOffsetBlock (
    IN      PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    );

UINT GetOffsetBufferBlockSize (
    IN      PGROWBUFFER pOffsetBuffer
    );



//
// pastring.c
// Pascal-style string: wide characters, first char
//      is number of characters, no null-termination
//

typedef WCHAR * PPASTR;
typedef WCHAR const * PCPASTR;

//
// these convert a WSTR in place from null-terminated
// to Pascal-style strings
//
PPASTR StringPasConvertTo (PWSTR str);
PWSTR StringPasConvertFrom (PPASTR str);

//
// these convert a WSTR from null-terminated
// to Pascal-style strings in new string buffer
//
PPASTR StringPasCopyConvertTo (PPASTR str1, PCWSTR str2);
PWSTR StringPasCopyConvertFrom (PWSTR str1, PCPASTR str2);

PPASTR StringPasCopy (PPASTR str1, PCPASTR str2);
UINT StringPasCharCount (PCPASTR str);

INT  StringPasCompare (PCPASTR str1, PCPASTR str2);
BOOL StringPasMatch (PCPASTR str1, PCPASTR str2);
INT  StringPasICompare (PCPASTR str1, PCPASTR str2);
BOOL StringPasIMatch (PCPASTR str1, PCPASTR str2);


//
// keystrct.c
//

#ifdef DEBUG

PKEYSTRUCT
GetKeyStructFromOffset (
    UINT Offset
    );

PKEYSTRUCT
GetKeyStruct (
    UINT Index
    );

#else

#define GetKeyStructFromOffset(Offset) ((Offset==INVALID_OFFSET) ?          \
                                        NULL :                              \
                                        (PKEYSTRUCT)OFFSET_TO_PTR(Offset))
#define GetKeyStruct(Index)            ((Index==INVALID_OFFSET) ?           \
                                        NULL :                              \
                                        GetKeyStructFromOffset(KeyIndexToOffset(Index)))
#endif



UINT
GetFirstIndex (
    IN      UINT TreeOffset,
    OUT     PUINT pTreeEnum
    );

UINT
GetNextIndex (
    IN OUT      PUINT pTreeEnum
    );

UINT
NewKey (
    IN  PCWSTR KeyStr
    );

UINT
NewEmptyKey (
    IN  PCWSTR KeyStr
    );


BOOL
PrivateDeleteKeyByIndex (
    IN      UINT Index
    );

BOOL
DeleteKey (
    IN      PCWSTR KeyStr,
    IN      UINT TreeOffset,
    IN      BOOL MustMatch
    );

BOOL
PrivateBuildKeyFromIndex (
    IN      UINT StartLevel,               // zero-based
    IN      UINT TailIndex,
    OUT     PWSTR Buffer,                   OPTIONAL
    OUT     PUINT ValPtr,                   OPTIONAL
    OUT     PUINT UserFlagsPtr,             OPTIONAL
    OUT     PUINT SizeInChars               OPTIONAL
    );


BOOL
KeyStructSetInsertionOrdered (
    IN      PKEYSTRUCT Key
    );


UINT KeyStructGetChildCount (
    IN      PKEYSTRUCT pKey
    );

UINT
FindKeyStructInTree (
    IN UINT TreeOffset,
    IN PWSTR KeyName,
    IN BOOL IsPascalString
    );




#ifdef DEBUG
BOOL
CheckLevel(UINT TreeOffset,
            UINT PrevLevelIndex
            );
#endif



//
// keyfind.c
//


UINT
FindKeyStruct(
    IN PCWSTR Key
    );

UINT
FindKey (
    IN  PCWSTR FullKeyPath
    );

UINT
FindKeyStructUsingTreeOffset (
    IN      UINT TreeOffset,
    IN OUT  PUINT pTreeEnum,
    IN      PCWSTR KeyStr
    );

#ifdef DEBUG
BOOL
FindKeyStructInDatabase(
    UINT KeyOffset
    );
#endif


//
// keydata.c
//


BOOL
KeyStructSetValue (
    IN      UINT KeyIndex,
    IN      UINT Value
    );

BOOL
KeyStructSetFlags (
    IN      UINT KeyIndex,
    IN      BOOL ReplaceFlags,
    IN      UINT SetFlags,
    IN      UINT ClearFlags
    );

UINT
KeyStructAddBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

UINT
KeyStructGrowBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

UINT
KeyStructGrowBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

BOOL
KeyStructDeleteBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    );

BOOL
KeyStructDeleteBinaryDataByIndex (
    IN      UINT DataIndex
    );

UINT
KeyStructReplaceBinaryDataByIndex (
    IN      UINT OldIndex,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

PBYTE
KeyStructGetBinaryData (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    OUT     PUINT DataSize,
    OUT     PUINT DataIndex     //OPTIONAL
    );

PBYTE
KeyStructGetBinaryDataByIndex (
    IN      UINT DataIndex,
    OUT     PUINT DataSize
    );

UINT
KeyStructGetDataIndex (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance
    );

DATAHANDLE
KeyStructAddLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

DATAHANDLE
KeyStructAddLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL AllowDuplicates
    );

BOOL
KeyStructDeleteLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
KeyStructDeleteLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage,
    IN      BOOL FirstOnly
    );

BOOL
KeyStructTestLinkage (
    IN      UINT KeyIndex,
    IN      BYTE Type,
    IN      BYTE Instance,
    IN      KEYHANDLE Linkage
    );

BOOL
KeyStructTestLinkageByIndex (
    IN      UINT DataIndex,
    IN      UINT Linkage
    );

BOOL
KeyStructGetValue (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Value
    );

BOOL
KeyStructGetFlags (
    IN  PKEYSTRUCT KeyStruct,
    OUT PUINT Flags
    );

VOID
KeyStructFreeAllData (
    PKEYSTRUCT KeyStruct
    );







//
// bintree.c
//

#ifdef DEBUG

//
// violating code hiding for easier debugging.
// (only database.c should see bintree functions)
//

UINT
BinTreeGetSizeOfStruct(
    DWORD Signature
    );

BOOL
BinTreeFindStructInDatabase(
    DWORD Sig,
    UINT Offset
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\offsetbuf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    offsetbuf.c

Abstract:

    Routines that manage the keystruct offsetbuffer

Author:

    Matthew Vanderzee (mvander) 13-Aug-1999

Revision History:


--*/

#include "pch.h"
#include "memdbp.h"



//
// we store index flags in the top two bits of the UINT offsets in
// the buffer, because offsets never have a top two bits set
//
// if the user links a key, we want to mark that index, so we
// dont add it to the deleted index list.  if a key is linked,
// and then deleted, we want to keep that key's index pointing
// to INVALID_OFFSET, instead of reusing the index.
//
// if a key is moved, we replace the key's original offset with
// the index of the new key's offset.  then we flag that the
// offset has been redirected.
//
// if an index is marked or redirected, when that key is deleted,
// we just set the true index (the index that any redirected indices
// point to) to INVALID_OFFSET.
//

#define INDEX_FLAG_BITS                 2
#define INDEX_MOVE_BITS_TO_POS(bits)    (((UINT)(bits)) << (8*sizeof(UINT)-INDEX_FLAG_BITS))
#define INDEX_MARKED_FLAG               INDEX_MOVE_BITS_TO_POS(0x01)
#define INDEX_REDIRECTED_FLAG           INDEX_MOVE_BITS_TO_POS(0x02)
#define INDEX_FLAG_MASK                 INDEX_MOVE_BITS_TO_POS(0x03)

#define GET_UINT_AT_INDEX(index)          (*(PUINT)(g_CurrentDatabase->OffsetBuffer.Buf + (index)))
#define SET_UINT_AT_INDEX(index, offset)  ((*(PUINT)(g_CurrentDatabase->OffsetBuffer.Buf + (index)))=(offset))

#define MARK_INDEX(Index)       (GET_UINT_AT_INDEX(Index) |= INDEX_MARKED_FLAG)
#define IS_INDEX_MARKED(Index)  ((BOOL)(GET_UINT_AT_INDEX(Index) & INDEX_FLAG_MASK))


VOID
MarkIndexList (
    IN      PUINT IndexList,
    IN      UINT IndexListSize
    )
{
    BYTE CurrentDatabase;
    UINT i;

    CurrentDatabase = g_CurrentDatabaseIndex;

    //
    // iterate through whole list, switch to correct
    // database, and mark list as linked.
    //
    for (i = 0; i < IndexListSize; i++) {
        SelectDatabase (GET_DATABASE (IndexList[i]));
        MARK_INDEX (GET_INDEX (IndexList[i]));
#ifdef _DEBUG
        if (GET_UINT_AT_INDEX (GET_INDEX (IndexList[i])) != INVALID_OFFSET) {
            MYASSERT (GetKeyStruct (GET_INDEX (IndexList[i])));
        }
#endif
    }

    SelectDatabase (CurrentDatabase);
}

VOID
RedirectKeyIndex (
    IN      UINT Index,
    IN      UINT TargetIndex
    )
/*++

Routine Description:
  sets the offset at Index to TargetIndex, with INDEX_REDIRECTED_FLAG
  set in the top byte.  also, we mark TargetIndex, indicating it has
  something redirected to it.

--*/
{
    MYASSERT(!(Index & INDEX_FLAG_MASK));
    MYASSERT(!(TargetIndex & INDEX_FLAG_MASK));
    MYASSERT(!(GET_UINT_AT_INDEX(Index) & INDEX_REDIRECTED_FLAG));
    MYASSERT(!(GET_UINT_AT_INDEX(TargetIndex) & INDEX_REDIRECTED_FLAG));
    SET_UINT_AT_INDEX(Index, TargetIndex | INDEX_REDIRECTED_FLAG);
    MARK_INDEX(TargetIndex);
}

UINT
pGetTrueIndex (
    IN  UINT Index
    )
/*++

Routine Description:
  takes and index and returns the true index, which is the index that
  actually holds the offset of the keystruct.  indexes with the
  redirected flag hold the index they are redirected to.

--*/
{
    MYASSERT(!(Index & INDEX_FLAG_MASK));
    while (GET_UINT_AT_INDEX(Index) & INDEX_REDIRECTED_FLAG) {
        Index = GET_UINT_AT_INDEX(Index) & ~INDEX_FLAG_MASK;
    }
    return Index;
}










UINT
KeyIndexToOffset (
    IN  UINT Index
    )
/*++

Routine Description:
  KeyIndexToOffset converts an index of a Keystruct
  (in g_CurrentDatabase->OffsetBuffer) to the Keystruct's offset in the database.

Arguments:
  Index - index in OffsetBuffer.  must be valid

Return Value:
  Offset of Keystruct.

--*/
{
    MYASSERT(!(Index & INDEX_FLAG_MASK));
    MYASSERT (Index <= g_CurrentDatabase->OffsetBuffer.End-sizeof(UINT));
    MYASSERT (g_CurrentDatabase);

    if (!g_CurrentDatabase->OffsetBuffer.Buf) {
        return INVALID_OFFSET;
    }

    do {
        Index = GET_UINT_AT_INDEX(Index);
        if (Index == INVALID_OFFSET) {
            return INVALID_OFFSET;
        }
        if (!(Index & INDEX_REDIRECTED_FLAG)) {
            //
            // we have found a non-redirected index, so check
            // that this points to a real keystruct, and return it.
            //
            MYASSERT(GetKeyStructFromOffset(Index & ~INDEX_FLAG_MASK));
            return Index & ~INDEX_FLAG_MASK;
        }
        Index &= ~INDEX_FLAG_MASK;
        MYASSERT (Index <= g_CurrentDatabase->OffsetBuffer.End-sizeof(UINT));
    } while (TRUE); //lint !e506
}






UINT
AddKeyOffsetToBuffer (
    IN  UINT Offset
    )
/*++

Routine Description:
  gets a space in g_CurrentDatabase->OffsetBuffer and sets it to Offset

Arguments:
  Offset - value to put in buffer space

Return Value:
  Index of space in g_CurrentDatabase->OffsetBuffer

--*/
{
    PUINT Ptr;

    MYASSERT (g_CurrentDatabase);

    if (Offset & INDEX_FLAG_MASK) {
        DEBUGMSG ((DBG_ERROR, "Offset to be put in list is too big, 0x%08lX", Offset));
        return FALSE;
    }

    //
    // this will check that Offset is valid and points to Keystruct
    //
    MYASSERT(GetKeyStructFromOffset(Offset));

    if (g_CurrentDatabase->OffsetBufferFirstDeletedIndex != INVALID_OFFSET)
    {
        //
        // if we have deleted offsets from offset list, we
        // find an open index, the first of which is stored
        // in g_CurrentDatabase->OffsetBufferFirstDeletedIndex.  the value at
        // this index in the buffer is the next open index,
        // and the value at that index is the next one, etc.
        //
        Ptr = &GET_UINT_AT_INDEX(g_CurrentDatabase->OffsetBufferFirstDeletedIndex);
        g_CurrentDatabase->OffsetBufferFirstDeletedIndex = *Ptr;
    } else {
        //
        // otherwise, make g_CurrentDatabase->OffsetBuffer bigger to hold new offset.
        //
        Ptr = (PUINT) GbGrow (&g_CurrentDatabase->OffsetBuffer, sizeof(UINT));
    }

    *Ptr = Offset;

    return (UINT)((UBINT)Ptr - (UBINT)g_CurrentDatabase->OffsetBuffer.Buf);
}


VOID
RemoveKeyOffsetFromBuffer(
    IN  UINT Index
    )
/*++

Routine Description:
  frees a space in g_CurrentDatabase->OffsetBuffer (adds to deleted index list)

Arguments:
  Index - position of space to free

--*/
{
    if (Index == INVALID_OFFSET) {
        return;
    }

    MYASSERT (g_CurrentDatabase);

    if (IS_INDEX_MARKED(Index)) {
        //
        // if index is marked, either it is redirected or something
        // is linked to this index.  either way, we do not want to
        // reuse the index, so just set true index (not a redirected
        // one) to INVALID_OFFSET.
        //
        SET_UINT_AT_INDEX(pGetTrueIndex(Index), INVALID_OFFSET);
    } else {
        //
        // index not marked, so we can reuse this index by
        // putting it in the deleted index list.
        //
        SET_UINT_AT_INDEX(Index, g_CurrentDatabase->OffsetBufferFirstDeletedIndex);
        g_CurrentDatabase->OffsetBufferFirstDeletedIndex = Index;
    }
}



BOOL
WriteOffsetBlock (
    IN      PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    )
{
    MYASSERT(pOffsetBuffer);

    *(((PUINT)*Buf)++) = pOffsetBuffer->End;
    CopyMemory (*Buf, pOffsetBuffer->Buf, pOffsetBuffer->End);

    *Buf += pOffsetBuffer->End;
    return TRUE;
}


BOOL
ReadOffsetBlock (
    OUT     PGROWBUFFER pOffsetBuffer,
    IN OUT  PBYTE *Buf
    )
{
    UINT OffsetBufferSize;

    MYASSERT(pOffsetBuffer);

    ZeroMemory (pOffsetBuffer, sizeof (GROWBUFFER));

    OffsetBufferSize = *(((PUINT)*Buf)++);

    if (OffsetBufferSize > 0) {
        if (!GbGrow(pOffsetBuffer, OffsetBufferSize)) {
            return FALSE;
        }
        CopyMemory (pOffsetBuffer->Buf, *Buf, OffsetBufferSize);
        *Buf += OffsetBufferSize;
    }

    return TRUE;
}


UINT GetOffsetBufferBlockSize (
    IN      PGROWBUFFER pOffsetBuffer
    )
{
    return sizeof (UINT) + pOffsetBuffer->End;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\memdbutil.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbutil.c

Abstract:

    MemDb Utility functions

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     xx-xxx-1999  split from memdb.c

--*/

#include "pch.h"

BOOL
MemDbValidateDatabase (
    VOID
    )
{
    // NTRAID#NTBUG9-153308-2000/08/01-jimschm Reimplement MemDbValidateDatabase
    return TRUE;
}


/*++

Routine Description:

  MemDbMakeNonPrintableKey converts the double-backslashe pairs in a string
  to ASCII 1, a non-printable character.  This allows the caller to store
  properly escaped strings in MemDb.

  This routine is desinged to be expanded for other types of escape
  processing.

Arguments:

  KeyName - Specifies the key text; receives the converted text.  The DBCS
            version may grow the text buffer, so the text buffer must be twice
            the length of the inbound string.

  Flags - Specifies the type of conversion.  Currently only
          MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1 is supported.

Return Value:

  none

--*/

VOID
MemDbMakeNonPrintableKeyA (
    IN OUT  PSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (_mbsnextc (KeyName) == '\\' &&
                _mbsnextc (_mbsinc (KeyName)) == '\\'
                ) {
                _setmbchar (KeyName, 1);
                KeyName = _mbsinc (KeyName);
                MYASSERT (_mbsnextc (KeyName) == '\\');
                _setmbchar (KeyName, 1);
            }

            DEBUGMSG_IF ((
                _mbsnextc (KeyName) == 1,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (_mbsnextc (KeyName) == '*') {
                _setmbchar (KeyName, 2);
            }

            DEBUGMSG_IF ((
                _mbsnextc (_mbsinc (KeyName)) == 2,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (_mbsnextc (KeyName) == '?') {
                _setmbchar (KeyName, 3);
            }

            DEBUGMSG_IF ((
                _mbsnextc (_mbsinc (KeyName)) == 3,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        KeyName = _mbsinc (KeyName);
    }
}


VOID
MemDbMakeNonPrintableKeyW (
    IN OUT  PWSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (KeyName[0] == L'\\' && KeyName[1] == L'\\') {
                KeyName[0] = 1;
                KeyName[1] = 1;
                KeyName++;
            }

            DEBUGMSG_IF ((
                KeyName[0] == 1,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (KeyName[0] == L'*') {
                KeyName[0] = 2;
            }

            DEBUGMSG_IF ((
                KeyName[1] == 2,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (KeyName[0] == L'*') {
                KeyName[0] = 3;
            }

            DEBUGMSG_IF ((
                KeyName[1] == 3,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        KeyName++;
    }
}


/*++

Routine Description:

  MemDbMakePrintableKey converts the ASCII 1 characters to backslashes,
  restoring the string converted by MemDbMakeNonPrintableKey.

  This routine is desinged to be expanded for other types of escape
  processing.

Arguments:

  KeyName - Specifies the key text; receives the converted text.  The DBCS
            version may grow the text buffer, so the text buffer must be twice
            the length of the inbound string.

  Flags - Specifies the type of conversion.  Currently only
          MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1 is supported.

Return Value:

  none

--*/

VOID
MemDbMakePrintableKeyA (
    IN OUT  PSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (_mbsnextc (KeyName) == 1) {
                _setmbchar (KeyName, '\\');
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (_mbsnextc (KeyName) == 2) {
                _setmbchar (KeyName, '*');
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (_mbsnextc (KeyName) == 3) {
                _setmbchar (KeyName, '?');
            }
        }
        KeyName = _mbsinc (KeyName);
    }
}


VOID
MemDbMakePrintableKeyW (
    IN OUT  PWSTR KeyName,
    IN      UINT Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (KeyName[0] == 1) {
                KeyName[0] = L'\\';
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (KeyName[0] == 2) {
                KeyName[0] = L'*';
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (KeyName[0] == 3) {
                KeyName[0] = L'?';
            }
        }
        KeyName++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\memdbfile.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbfile.c

Abstract:

    file operations for memdb saving/loading/exporting/importing

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    mvander     13-Aug-1999  split from memdb.c


--*/

#include "pch.h"
#include "memdbp.h"

//
// This is our version stamp.  Change MEMDB_VERSION_STAMP only.
//

#define MEMDB_VERSION_STAMP L"v9 "

#define VERSION_BASE_SIGNATURE  L"memdb dat file "
#define MEMDB_DEBUG_SIGNATURE   L"debug"
#define MEMDB_NODBG_SIGNATURE   L"nodbg"

#define VERSION_SIGNATURE VERSION_BASE_SIGNATURE MEMDB_VERSION_STAMP
#define DEBUG_FILE_SIGNATURE VERSION_SIGNATURE MEMDB_DEBUG_SIGNATURE
#define RETAIL_FILE_SIGNATURE VERSION_SIGNATURE MEMDB_NODBG_SIGNATURE

#ifdef DEBUG
#define FILE_SIGNATURE DEBUG_FILE_SIGNATURE
#else
#define FILE_SIGNATURE RETAIL_FILE_SIGNATURE
#endif

PBYTE
MapFileFromHandle (
    HANDLE hFile,
    PHANDLE hMap
    )
{
    MYASSERT(hMap);
    if (!hFile || hFile == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    *hMap = CreateFileMappingA (
        hFile,
        NULL,
        PAGE_READWRITE,
        0,
        0,
        NULL
        );
    if (*hMap == NULL) {
        return NULL;
    }

    return MapViewOfFile (*hMap, FILE_MAP_WRITE, 0, 0, 0);
}

BOOL
SetSizeOfFile (
    HANDLE hFile,
    LONGLONG Size
    )
{
    LONG a;
    LONG b;
    PLONG sizeHi;

    a = (LONG) Size;
    b = (LONG) (SHIFTRIGHT32(Size));
    if (b) {
        sizeHi = &b;
    } else {
        sizeHi = NULL;
    }

    if (SetFilePointer (hFile, a, sizeHi, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
        return FALSE;
    }
    if (!SetEndOfFile (hFile)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
WriteBlocks (
    IN OUT  PBYTE *Buf,
    IN      PMEMDBHASH pHashTable,
    IN      PGROWBUFFER pOffsetBuffer
    )
{
    MYASSERT(Buf);
    MYASSERT(pHashTable);
    MYASSERT(pOffsetBuffer);

    if (!WriteHashBlock (pHashTable, Buf)) {
        return FALSE;
    }
    if (!WriteOffsetBlock (pOffsetBuffer, Buf)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
ReadBlocks (
    IN OUT  PBYTE *Buf,
    OUT     PMEMDBHASH *ppHashTable,
    OUT     PGROWBUFFER pOffsetBuffer
    )
{
    MYASSERT(Buf);
    MYASSERT(ppHashTable);
    MYASSERT(pOffsetBuffer);

    //
    // fill hash block
    //
    if (!*ppHashTable) {
        return FALSE;
    }
    if (!ReadHashBlock (*ppHashTable, Buf)) {
        return FALSE;
    }
    if (!ReadOffsetBlock (pOffsetBuffer, Buf)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
pPrivateMemDbSave (
    PCSTR FileName
    )
{
    HANDLE FileHandle = NULL;
    HANDLE hMap = INVALID_HANDLE_VALUE;
    PBYTE Buf = NULL;
    PBYTE MapPtr = NULL;
    BOOL result = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {

        if (!SelectDatabase (DB_PERMANENT)) {
            __leave;
        }

        //
        // now we resize file to fit everything in it.
        //
        FileHandle = BfCreateFileA (FileName);

        if (!FileHandle) {
            __leave;
        }

        if (!SetSizeOfFile (
                FileHandle,
                (LONGLONG)(sizeof (FILE_SIGNATURE)) +
                g_CurrentDatabase->AllocSize +
                GetHashTableBlockSize (g_CurrentDatabase->HashTable) +
                GetOffsetBufferBlockSize (&g_CurrentDatabase->OffsetBuffer)
                )) {
            __leave;
        }

        Buf = MapFileFromHandle (FileHandle, &hMap);

        if (Buf == NULL) {
            __leave;
        }

        MapPtr = Buf;

        CopyMemory (Buf, FILE_SIGNATURE, sizeof (FILE_SIGNATURE));

        Buf += sizeof (FILE_SIGNATURE);

        CopyMemory (Buf, g_CurrentDatabase, g_CurrentDatabase->AllocSize);

        Buf += g_CurrentDatabase->AllocSize;

        if (!WriteBlocks (
                &Buf,
                g_CurrentDatabase->HashTable,
                &g_CurrentDatabase->OffsetBuffer
                )) {
            __leave;
        }

        result = TRUE;
    }
    __finally {

        UnmapFile (MapPtr, hMap, FileHandle);

        PushError();

        // lint is not familiar with __finally so...
        if (!result) {  //lint !e774
            if (FileHandle) {
                CloseHandle (FileHandle);
            }

            DeleteFileA (FileName);
        }

        LeaveCriticalSection (&g_MemDbCs);

        PopError();
    }

    return result;
}

BOOL
MemDbSaveA (
    PCSTR FileName
    )
{
    return pPrivateMemDbSave (FileName);                   // TRUE=UNICODE
}

BOOL
MemDbSaveW (
    PCWSTR FileName
    )
{
    PCSTR p;
    BOOL b = FALSE;

    p = ConvertWtoA (FileName);
    if (p) {
        b = pPrivateMemDbSave (p);
        FreeConvertedStr (p);
    }

    return b;
}

BOOL
pPrivateMemDbLoad (
    IN      PCSTR AnsiFileName,
    IN      PCWSTR UnicodeFileName,
    OUT     PMEMDB_VERSION Version,                 OPTIONAL
    IN      BOOL QueryVersionOnly
    )
{
    HANDLE FileHandle = NULL;
    HANDLE hMap = INVALID_HANDLE_VALUE;
    WCHAR FileSig[sizeof(FILE_SIGNATURE)];
    PCWSTR VerPtr;
    UINT DbSize;
    PMEMDBHASH pHashTable;
    PBYTE Buf = NULL;
    PBYTE SavedBuf = NULL;
    PCSTR databaseLocation = NULL;
    BOOL result = FALSE;


    EnterCriticalSection (&g_MemDbCs);

    __try {
        __try {

            if (Version) {
                ZeroMemory (Version, sizeof (MEMDB_VERSION));
            }

            //
            // Blow away existing resources
            //

            if (!QueryVersionOnly) {
                databaseLocation = DuplicatePathStringA (DatabasesGetBasePath (), 0);
                DatabasesTerminate (FALSE);
                DatabasesInitializeA (databaseLocation);
                FreePathStringA (databaseLocation);

                if (!SelectDatabase (DB_PERMANENT)) {
                    __leave;
                }
            }

            if (AnsiFileName) {
                Buf = MapFileIntoMemoryA (AnsiFileName, &FileHandle, &hMap);
            } else {
                Buf = MapFileIntoMemoryW (UnicodeFileName, &FileHandle, &hMap);
            }

            if (Buf == NULL) {
                __leave;
            }
            SavedBuf = Buf;

            //
            // Obtain the file signature
            //
            // NOTE: Entire file read is in UNICODE char set
            //

            CopyMemory (FileSig, Buf, sizeof(FILE_SIGNATURE));

            if (Version) {
                if (StringMatchByteCountW (
                        VERSION_BASE_SIGNATURE,
                        FileSig,
                        sizeof (VERSION_BASE_SIGNATURE) - sizeof (WCHAR)
                        )) {

                    Version->Valid = TRUE;

                    //
                    // Identify version number
                    //

                    VerPtr = (PCWSTR) ((PBYTE)FileSig + sizeof (VERSION_BASE_SIGNATURE) - sizeof (WCHAR));

                    if (StringMatchByteCountW (
                            MEMDB_VERSION_STAMP,
                            VerPtr,
                            sizeof (MEMDB_VERSION_STAMP) - sizeof (WCHAR)
                            )) {
                        Version->CurrentVersion = TRUE;
                    }

                    Version->Version = (UINT) _wtoi (VerPtr + 1);

                    //
                    // Identify checked or free build
                    //

                    VerPtr += (sizeof (MEMDB_VERSION_STAMP) / sizeof (WCHAR)) - 1;

                    if (StringMatchByteCountW (
                            MEMDB_DEBUG_SIGNATURE,
                            VerPtr,
                            sizeof (MEMDB_DEBUG_SIGNATURE) - sizeof (WCHAR)
                            )) {

                        Version->Debug = TRUE;

                    } else if (!StringMatchByteCountW (
                                    VerPtr,
                                    MEMDB_NODBG_SIGNATURE,
                                    sizeof (MEMDB_NODBG_SIGNATURE) - sizeof (WCHAR)
                                    )) {
                        Version->Valid = FALSE;
                    }
                }
            }

            if (!QueryVersionOnly) {

                if (!StringMatchW (FileSig, FILE_SIGNATURE)) {

#ifdef DEBUG
                    if (StringMatchW (FileSig, DEBUG_FILE_SIGNATURE)) {

                        g_UseDebugStructs = TRUE;

                    } else if (StringMatchW (FileSig, RETAIL_FILE_SIGNATURE)) {

                        DEBUGMSG ((DBG_ERROR, "memdb dat file is from free build; checked version expected"));
                        g_UseDebugStructs = FALSE;

                    } else {
#endif
                        SetLastError (ERROR_BAD_FORMAT);
                        LOG ((LOG_WARNING, "Warning: data file could be from checked build; free version expected"));
                        __leave;
#ifdef DEBUG
                    }
#endif
                }

                Buf += sizeof(FILE_SIGNATURE);
                DbSize = *((PUINT)Buf);

                //
                // resize the database.  SizeDatabaseBuffer also fixes g_CurrentDatabase
                // and other global variables, so we dont have to worry.
                //
                if (!SizeDatabaseBuffer(g_CurrentDatabaseIndex, DbSize)) {
                    __leave;
                }

                MYASSERT (g_CurrentDatabase);

                //
                // save hashtable pointer (which points to hashtable created
                // in InitializeDatabases (above)), then load database, then
                // fix hashtable pointer.
                //
                pHashTable = g_CurrentDatabase->HashTable;
                CopyMemory (g_CurrentDatabase, Buf, DbSize);
                g_CurrentDatabase->HashTable = pHashTable;
                Buf += DbSize;

                if (!ReadBlocks (
                        &Buf,
                        &g_CurrentDatabase->HashTable,
                        &g_CurrentDatabase->OffsetBuffer
                        )) {
                    __leave;
                }
                result = TRUE;
            }

            UnmapFile (SavedBuf, hMap, FileHandle);

        }
        __except (TRUE) {
            result = FALSE;
            PushError();

#ifdef DEBUG
            if (AnsiFileName) {
                LOGA ((LOG_ERROR, "MemDb dat file %s could not be loaded because of an exception", AnsiFileName));
            } else {
                LOGW ((LOG_ERROR, "MemDb dat file %s could not be loaded because of an exception", UnicodeFileName));
            }
#endif

            PopError();
        }
    }
    __finally {

        PushError();

        if (!result && !QueryVersionOnly) {
            databaseLocation = DuplicatePathStringA (DatabasesGetBasePath (), 0);
            DatabasesTerminate (FALSE);
            DatabasesInitializeA (databaseLocation);
            FreePathStringA (databaseLocation);
        }

        LeaveCriticalSection (&g_MemDbCs);

        PopError();
    }
    return result;
}

BOOL
MemDbLoadA (
    IN PCSTR FileName
    )
{

    return pPrivateMemDbLoad (FileName, NULL, NULL, FALSE);
}

BOOL
MemDbLoadW (
    IN PCWSTR FileName
    )
{
    return pPrivateMemDbLoad (NULL, FileName, NULL, FALSE);
}

BOOL
MemDbQueryVersionA (
    PCSTR FileName,
    PMEMDB_VERSION Version
    )
{
    BOOL b;

    b = pPrivateMemDbLoad (FileName, NULL, Version, TRUE);

    return b ? Version->Valid : FALSE;
}

BOOL
MemDbQueryVersionW (
    PCWSTR FileName,
    PMEMDB_VERSION Version
    )
{
    pPrivateMemDbLoad (NULL, FileName, Version, TRUE);
    return Version->Valid;
}

/* format for binary file export

    DWORD Signature

    UINT Version

    UINT GlobalFlags// 0x00000001 mask for Ansi format
                    // 0x00000002 mask for debug mode

        //
        // each _KEY block is followed by its children,
        // and each of those is followed by its children,
        // etc., so it is easy to recurse to gather
        // the whole tree.
        //

    struct _KEY {

      #if (GlobalFlags & MEMDB_EXPORT_FLAGS_DEBUG)
        WORD DebugSig       // signature for each keystruct block.
      #endif
        WORD StructSize;    // total number of bytes including this member
        WORD NameSize;      // total number of bytes in Key[]
        WORD DataSize;      // total number of bytes in Data[]
        WORD NumChildren    // number of children, whose data structures will follow
                            // this one (though not necessarily one after another, if
                            // any of them have children themselves)
        BYTE Key[];         // Should be PCSTR or PCWSTR (not zero terminated).
                            // the first key in the exported file will have the full
                            // key path as its key name.
        BYTE Data[];        // block of data pieces, all in same format as in datablock.c
    }

*/
#define MEMDB_EXPORT_SIGNATURE              ('M'+('D'<<8)+('B'<<16)+('X'<<24))
// NTRAID#NTBUG9-153308-2000/08/01-jimschm reenable the line below when implementing export and import functions
//#define MEMDB_EXPORT_DEBUG_SIG              ('K'+('Y'<<8))
#define MEMDB_EXPORT_VERSION                0x00000003
#define MEMDB_EXPORT_FLAGS_ANSI             0x00000001
#define MEMDB_EXPORT_FLAGS_DEBUG            0x00000002

// NTRAID#NTBUG9-153308-2000/08/01-jimschm  Implement the function and remove lint comments
//lint -save -e713 -e715
BOOL
pMemDbExportWorker (
    IN  HANDLE FileHandle,
    IN  UINT KeyIndex,
    IN  BOOL AnsiFormat,
    IN  PCWSTR FullKeyPath
    )
/*++

Routine Description:

  exports a key to a file, and then recurses through
  that key's children.

Arguments:

  FileHandle - already opened handle to write to

  KeyIndex - index of key to write

  AnsiFormat - if TRUE, then FullKeyPath (above) and KeyName
        (below) are actually ANSI strings (not unicode).

  FullKeyPath - only used for first keystruct to be written
        to file.  it specifies the full path of the root key.
        for all others, this argument should be NULL.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    return TRUE;
}
//lint -restore

BOOL
pMemDbExport (
    IN      PCWSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    )
/*++

Routine Description:

  exports a MemDb tree to a file

Arguments:

  RootTree - full key path of the top level key to write
        to the file.

  FileName - file to write to.

  AnsiFormat - if TRUE, then RootTree and FileName are
        actually ANSI strings (not unicode).


Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    HANDLE FileHandle = NULL;
    UINT Flags;
    DWORD written;
    UINT RootIndex = INVALID_OFFSET;
    PCWSTR SubRootTreeW, RootTreeW;
    BOOL b;

    if (AnsiFormat) {
        //
        // if we are in ansi mode, everything is ANSI strings,
        // but we still need unicode string for SelectHiveW ()
        //
        RootTreeW = ConvertAtoW ((PCSTR)RootTree);

        if (!RootTreeW) {
            return FALSE;
        }
    } else {
        RootTreeW = RootTree;
    }
    SubRootTreeW = SelectHiveW (RootTreeW);

    if (SubRootTreeW) {
        RootIndex = FindKeyStruct (SubRootTreeW);
    }

    if (AnsiFormat) {
        FreeConvertedStr(RootTreeW);
    }

    if (RootIndex == INVALID_OFFSET) {
        return FALSE;
    }

    FileHandle = BfCreateFileA (FileName);

    if (!FileHandle) {
        return FALSE;
    }

    Flags = MEMDB_EXPORT_SIGNATURE;
    WriteFile (FileHandle, &Flags, sizeof (DWORD), &written, NULL);

    Flags = MEMDB_EXPORT_VERSION;
    WriteFile (FileHandle, &Flags, sizeof (UINT), &written, NULL);

    Flags = AnsiFormat ? MEMDB_EXPORT_FLAGS_ANSI : 0;

#ifdef DEBUG
    Flags |= MEMDB_EXPORT_FLAGS_DEBUG;
#endif
    WriteFile (FileHandle, &Flags, sizeof (UINT), &written, NULL);

    //
    // write root index key and all children to file.
    //
    b = pMemDbExportWorker(FileHandle, RootIndex, AnsiFormat, RootTree);


    //
    // finally write the zero terminator
    //
    Flags = 0;
    WriteFile (FileHandle, &Flags, sizeof (WORD), &written, NULL);

    CloseHandle (FileHandle);

    return b;
}

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    )
{
    PCWSTR p;
    BOOL b;

    if (!AnsiFormat) {

        p = ConvertAtoW (RootTree);

        if (!p) {
            return FALSE;
        }

        b = pMemDbExport (p, FileName, FALSE);

        FreeConvertedStr (p);

    } else {

        b = pMemDbExport ((PCWSTR)RootTree, FileName, TRUE);

    }

    return b;
}

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    )
{
    PCSTR p, FileNameA;
    BOOL b;

    FileNameA = ConvertWtoA (FileName);

    if (!FileNameA) {

        return FALSE;

    }

    if (AnsiFormat) {

        p = ConvertWtoA (RootTree);

        if (!p) {

            FreeConvertedStr (FileNameA);
            return FALSE;

        }

        b = pMemDbExport ((PCWSTR)p, FileNameA, TRUE);

        FreeConvertedStr (p);

    } else {

        b = pMemDbExport (RootTree, FileNameA, FALSE);

    }

    FreeConvertedStr (FileNameA);

    return b;
}

// NTRAID#NTBUG9-153308-2000/08/01-jimschm Implement the function and remove lint comments
//lint -save -e713 -e715
BOOL
pMemDbImportWorker (
    IN      PBYTE *FileBuffer,
    IN      BOOL AnsiFormat,
    IN      BOOL DebugMode,
    IN      BOOL ExportRoot
    )
/*++

Routine Description:

  imports a key from a file, and then recurses through
  that key's children.

Arguments:

  FileBuffer - pointer to a memory pointer, which should
        initially point to the beginning of the
        memory-mapped file to read.  this will be updated
        as the function runs

  AnsiFormat - TRUE if the file is in ANSI mode (determined
        by file header)

  DebugMode - TRUE if the file is in debug mode (determined
        by file header)

  ExportRoot - TRUE if this is the first call to this function
        for a file (the name of the first keystruct in a file
        is the full key path for that keystruct, all other keys
        in the file have only the relative name).

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    return TRUE;
}
//lint -restore

BOOL
MemDbImportA (
    IN      PCSTR FileName
    )
{
    PCWSTR FileNameW;
    BOOL b = FALSE;

    FileNameW = ConvertAtoW (FileName);

    if (FileNameW) {
        b = MemDbImportW (FileNameW);
        FreeConvertedStr (FileNameW);
    }

    return b;
}

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    )

/*++

Routine Description:

  MemDbImportW imports a tree from a private binary format. The format is described above.

Arguments:

  FileName - Name of the binary format file to import from.

Return Value:

  TRUE is successfull, FALSE if not.

--*/
{
    PBYTE fileBuff, BufferPtr;
    HANDLE fileHandle;
    HANDLE mapHandle;
    BOOL b = FALSE;
    UINT Flags;

    fileBuff = MapFileIntoMemoryW (FileName, &fileHandle, &mapHandle);
    if (fileBuff == NULL) {
        DEBUGMSGW ((DBG_ERROR, "Could not execute MemDbImport for %s", FileName));
        return FALSE;
    }

    __try {
        BufferPtr = fileBuff;
        if (*((PDWORD) BufferPtr) != MEMDB_EXPORT_SIGNATURE) {
            DEBUGMSGW ((DBG_ERROR, "Unknown signature for file to import: %s", FileName));
            b = FALSE;
        } else {
            BufferPtr += sizeof (DWORD);

            if (*((PUINT) BufferPtr) != MEMDB_EXPORT_VERSION) {

                DEBUGMSGW ((DBG_ERROR, "Unknown or outdated version for file to import: %s", FileName));
                b = FALSE;
            } else {
                BufferPtr += sizeof (UINT);
                Flags = *((PUINT) BufferPtr);
                BufferPtr += sizeof (UINT);

                b = pMemDbImportWorker (
                    &BufferPtr,
                    Flags & MEMDB_EXPORT_FLAGS_ANSI,
                    Flags & MEMDB_EXPORT_FLAGS_DEBUG,
                    TRUE
                    );
            }
        }
    }
    __except (1) {
        DEBUGMSGW ((DBG_ERROR, "Access violation while importing: %s", FileName));
    }

    UnmapFile (fileBuff, mapHandle, fileHandle);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\pch\pch.h ===
#include "baseinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\pch\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\memdb\pastring.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    pastring.c

Abstract:

    Routines that manage the pascal strings

Author:

    Matthew Vanderzee (matthewv) 13-Aug-1999

Revision History:


--*/

#include "pch.h"
#include "memdbp.h"








PPASTR
StringPasConvertTo (
    IN OUT PWSTR str
    )
/*++

  Converts a string in place from a zero-terminated
  string to a pascal-style string.

--*/
{
    WCHAR Len;
    MYASSERT(str);
    Len = (WORD) CharCountW (str);
    MoveMemory (str + 1, str, Len * sizeof(WCHAR));
    *str = Len;
    return str;
}

PWSTR
StringPasConvertFrom (
    IN OUT PPASTR str
    )
/*++

  Converts a string in place from a pascal-style string
  to a null-terminated string.

--*/
{
    WCHAR Len;
    MYASSERT(str);
    Len = *str;
    MoveMemory (str, str + 1, Len * sizeof(WCHAR));
    *(str + Len) = 0;
    return str;
}

PPASTR
StringPasCopyConvertTo (
    OUT PPASTR str1,
    IN  PCWSTR str2
    )
/*++

  Converts a string from a zero-terminated
  string to a pascal-style string in a new buffer.

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    *str1 = (WORD) CharCountW (str2);
    CopyMemory (str1 + 1, str2, *str1 * sizeof(WCHAR));
    return str1;
}

PWSTR
StringPasCopyConvertFrom (
    OUT PWSTR str1,
    IN  PCPASTR str2
    )
/*++

  Converts a string from a pascal-style string
  to a null-terminated string in a new buffer.

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    CopyMemory (str1, str2 + 1, *str2 * sizeof(WCHAR));
    *(str1 + *str2) = 0;
    return str1;
}

PPASTR
StringPasCopy (
    OUT PPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Copys a pascal string to a new buffer.

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    CopyMemory (str1, str2, (*str2+1) * sizeof(WCHAR));
    return str1;
}

UINT
StringPasCharCount (
    IN  PCPASTR str
    )
/*++

  Returns the number of characters in a string.

--*/
{
    MYASSERT(str);
    return (UINT)(*str);
}


INT
StringPasCompare (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Compares two pascal-style strings, returns values
  in the same fashion as strcmp().

--*/
{
    INT equal;
    INT diff;
    MYASSERT(str1);
    MYASSERT(str2);
    //
    // diff is < 0 if str1 is shorter, = 0 if
    // strings are same length, otherwise > 0
    //
    diff = *str1 - *str2;
    equal = wcsncmp(str1+1, str2+1, (diff < 0) ? *str1 : *str2);
    if (equal != 0) {
        return equal;
    }
    return diff;
}

BOOL
StringPasMatch (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Returns TRUE if the two strings match

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    if (*str1 != *str2) {
        return FALSE;
    }
    return wcsncmp(str1+1, str2+1, *str2)==0;
}


INT
StringPasICompare (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Compares two pascal-style strings, returns values
  in the same fashion as strcmp().  (CASE INSENSITIVE)

--*/
{
    INT equal;
    INT diff;
    MYASSERT(str1);
    MYASSERT(str2);
    //
    // diff is < 0 if str1 is shorter, = 0 if
    // strings are same length, otherwise > 0
    //
    diff = *str1 - *str2;
    equal = _wcsnicmp(str1+1, str2+1, (diff < 0) ? *str1 : *str2);
    if (equal != 0) {
        return equal;
    }
    return diff;
}

BOOL
StringPasIMatch (
    IN  PCPASTR str1,
    IN  PCPASTR str2
    )
/*++

  Returns TRUE if the two strings match (CASE INSENSITIVE)

--*/
{
    MYASSERT(str1);
    MYASSERT(str2);
    if (*str1 != *str2) {
        return FALSE;
    }
    return _wcsnicmp(str1+1, str2+1, *str2)==0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\modimage\modimage.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    modimage.c

Abstract:

    Implements a set of routines for examining EXE modules

Author:

    Calin Negreanu (calinn) 27-Nov-1997

Revision History:

    calinn      08-Mar-2000 Moved over from Win9xUpg project.

--*/

//
// Includes
//

#include "pch.h"

//
// Debug constants
//

#define DBG_MODIMAGE    "ModImage"

//
// Strings
//

// None

//
// Constants
//

#define SEG_CODE_MASK                   0x0001
#define SEG_CODE                        0x0000
#define SEG_PRELOAD_MASK                0x0040
#define SEG_PRELOAD                     0x0040
#define SEG_RELOC_MASK                  0x0100
#define SEG_RELOC                       0x0100

#define RELOC_IMPORTED_ORDINAL          0x01
#define RELOC_IMPORTED_NAME             0x02
#define RELOC_ADDR_TYPE                 0x03

#define IMAGE_DOS_SIGNATURE             0x5A4D      // MZ
#define IMAGE_NE_SIGNATURE              0x454E      // NE
#define IMAGE_PE_SIGNATURE              0x00004550l // PE00

//
// Macros
//

// None

//
// Types
//

#pragma pack(push,1)

typedef struct _DOS_HEADER {  // DOS .EXE header
    WORD e_magic;           // Magic number
    WORD e_cblp;            // Bytes on last page of file
    WORD e_cp;              // Pages in file
    WORD e_crlc;            // Relocations
    WORD e_cparhdr;         // Size of header in paragraphs
    WORD e_minalloc;        // Minimum extra paragraphs needed
    WORD e_maxalloc;        // Maximum extra paragraphs needed
    WORD e_ss;              // Initial (relative) SS value
    WORD e_sp;              // Initial SP value
    WORD e_csum;            // Checksum
    WORD e_ip;              // Initial IP value
    WORD e_cs;              // Initial (relative) CS value
    WORD e_lfarlc;          // File address of relocation table
    WORD e_ovno;            // Overlay number
    WORD e_res[4];          // Reserved words
    WORD e_oemid;           // OEM identifier (for e_oeminfo)
    WORD e_oeminfo;         // OEM information; e_oemid specific
    WORD e_res2[10];        // Reserved words
    LONG e_lfanew;          // File address of new exe header
} DOS_HEADER, *PDOS_HEADER;

typedef struct _NE_HEADER {
    WORD  Magic;
    BYTE  MajorLinkerVersion;
    BYTE  MinorLinkerVersion;
    WORD  EntryTableOff;
    WORD  EntryTableLen;
    ULONG Reserved;
    WORD  Flags;
    WORD  NumberOfDataSeg;
    WORD  SizeOfHeap;
    WORD  SizeOfStack;
    ULONG CS_IP;
    ULONG SS_SP;
    WORD  NumEntriesSegTable;
    WORD  NumEntriesModuleTable;
    WORD  NonResNameTableSize;
    WORD  SegTableOffset;
    WORD  ResTableOffset;
    WORD  ResNameTableOffset;
    WORD  ModuleTableOffset;
    WORD  ImportedTableOffset;
    ULONG NonResNameTableOffset;
    WORD  NumberOfMovableEntryPoints;
    WORD  ShiftCount;
    WORD  NumberOfResourceSegments;
    BYTE  TargetOS;
    BYTE  AdditionalInfo;
    WORD  FastLoadOffset;
    WORD  FastLoadSize;
    WORD  Reserved1;
    WORD  WinVersionExpected;
} NE_HEADER, *PNE_HEADER;

typedef struct {
    WORD Signature;                             // 00h
    BYTE LinkerVersion;                         // 02h
    BYTE LinkerRevision;                        // 03h
    WORD OffsetToEntryTable;                    // 04h
    WORD LengthOfEntryTable;                    // 06h
    DWORD Reserved;                             // 08h
    WORD Flags;                                 // 0ch
    WORD AutoDataSegment;                       // 0eh
    WORD LocalHeapSize;                         // 10h
    WORD StackSize;                             // 12h
    DWORD EntryAddress;                         // 14h
    DWORD StackAddress;                         // 18h
    WORD SegmentTableEntries;                   // 1ch
    WORD ModuleReferenceTableEntries;           // 1eh
    WORD NonResidentTableSize;                  // 20h
    WORD OffsetToSegmentTable;                  // 22h
    WORD OffsetToResourceTable;                 // 24h
    WORD OffsetToResidentNameTable;             // 26h
    WORD OffsetToModuleReferenceTable;          // 28h
    WORD OffsetToImportedNameTable;             // 2ah
    WORD OffsetToNonResidentNameTable;          // 2ch
    WORD Unused;                                // 2eh
    WORD MovableEntryPoints;                    // 30h
    WORD LogicalSectorShiftCount;               // 32h
    WORD ResourceSegments;                      // 34h
    BYTE TargetOS;                              // 36h
    BYTE AdditionalFlags;                       // 37h
    WORD FastLoadOffset;                        // 38h
    WORD SectorsInFastLoad;                     // 3ah
    WORD Reserved2;                             // 3ch
    WORD WindowsVersion;                        // 3eh
} NE_INFO_BLOCK, *PNE_INFO_BLOCK;

typedef struct _NE_SEGMENT_ENTRY {
    WORD  SegmentOffset;
    WORD  SegmentLen;
    WORD  SegmentFlags;
    WORD  SegMinAlloc;
} NE_SEGMENT_ENTRY, *PNE_SEGMENT_ENTRY;

typedef struct _NE_RELOC_ITEM {
    BYTE  AddressType;
    BYTE  RelocType;
    WORD  RelocOffset;
    WORD  ModuleOffset;
    WORD  FunctionOffset;
} NE_RELOC_ITEM, *PNE_RELOC_ITEM;

typedef struct {
    WORD Offset;
    WORD Length;
    WORD Flags;
    WORD Id;
    WORD Handle;
    WORD Usage;
} NE_RES_NAMEINFO, *PNE_RES_NAMEINFO;

typedef struct {
    WORD TypeId;
    WORD ResourceCount;
    DWORD Reserved;
    NE_RES_NAMEINFO NameInfo[];
} NE_RES_TYPEINFO, *PNE_RES_TYPEINFO;

#pragma pack(pop)

typedef struct {
    WORD AlignShift;
    GROWLIST TypeInfoArray;
    GROWLIST ResourceNames;
} NE_RESOURCES, *PNE_RESOURCES;

typedef struct {
    PLOADED_IMAGE Image;
    PIMAGE_IMPORT_DESCRIPTOR ImageDescriptor;
    DWORD ImportFunctionAddr;
    PIMAGE_THUNK_DATA ImageData;
    PIMAGE_IMPORT_BY_NAME ImageName;
} MD_IMPORT_ENUM32_HANDLE, *PMD_IMPORT_ENUM32_HANDLE;

typedef struct {
    PBYTE Image;
    PDOS_HEADER DosHeader;
    PNE_HEADER NeHeader;
    PNE_SEGMENT_ENTRY SegmentEntry;
    WORD CurrSegEntry;
    PWORD CurrNrReloc;
    PNE_RELOC_ITEM RelocItem;
    WORD CurrRelocItem;
} MD_IMPORT_ENUM16_HANDLE, *PMD_IMPORT_ENUM16_HANDLE;

typedef struct {
    HANDLE File;
    DWORD HeaderOffset;
    NE_INFO_BLOCK Header;
    NE_RESOURCES Resources;
    BOOL ResourcesLoaded;
    PMHANDLE ResourcePool;
} NE_HANDLE, *PNE_HANDLE;

typedef BOOL (CALLBACK* ENUMRESTYPEPROCEXA)(HMODULE hModule, PCSTR lpType, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo);

typedef BOOL (CALLBACK* ENUMRESTYPEPROCEXW)(HMODULE hModule, PCWSTR lpType, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCEXA)(HMODULE hModule, PCSTR lpType,
        PSTR lpName, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo, PNE_RES_NAMEINFO NameInfo);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCEXW)(HMODULE hModule, PCWSTR lpType,
        PWSTR lpName, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo, PNE_RES_NAMEINFO NameInfo);

typedef struct {
    PCSTR TypeToFind;
    PNE_RES_TYPEINFO OutboundTypeInfo;
    BOOL Found;
} TYPESEARCHDATAA, *PTYPESEARCHDATAA;

typedef struct {
    PCSTR NameToFind;
    PNE_RES_TYPEINFO OutboundTypeInfo;
    PNE_RES_NAMEINFO OutboundNameInfo;
    BOOL Found;
} NAMESEARCHDATAA, *PNAMESEARCHDATAA;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
MdLoadModuleDataA (
    IN      PCSTR ModuleName,
    OUT     PMD_MODULE_IMAGE ModuleImage
    )
{
    HANDLE fileHandle;
    DWORD bytesRead;
    DOS_HEADER dh;
    DWORD sign;
    PWORD signNE = (PWORD)&sign;
    BOOL result = FALSE;

    ZeroMemory (ModuleImage, sizeof (MD_MODULE_IMAGE));

    fileHandle = CreateFileA (ModuleName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        ModuleImage->ModuleType = MODULETYPE_UNKNOWN;
        return FALSE;
    }
    __try {
        __try {
            if ((!ReadFile (fileHandle, &dh, sizeof (DOS_HEADER), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DOS_HEADER))
                ) {
                __leave;
            }
            result = TRUE;
            if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_UNKNOWN;
                __leave;
            }
            ModuleImage->ModuleType = MODULETYPE_DOS;

            if (SetFilePointer (fileHandle, dh.e_lfanew, NULL, FILE_BEGIN) != (DWORD)dh.e_lfanew) {
                __leave;
            }
            if ((!ReadFile (fileHandle, &sign, sizeof (DWORD), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DWORD))
                ) {
                __leave;
            }
            CloseHandle (fileHandle);
            fileHandle = INVALID_HANDLE_VALUE;

            if (sign == IMAGE_PE_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_WIN32;
                result = MapAndLoad ((PSTR)ModuleName, NULL, &ModuleImage->ModuleData.W32Data.Image, FALSE, TRUE);
            }
            if (*signNE == IMAGE_NE_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_WIN16;
                ModuleImage->ModuleData.W16Data.Image = MapFileIntoMemoryA (
                                                            ModuleName,
                                                            &ModuleImage->ModuleData.W16Data.FileHandle,
                                                            &ModuleImage->ModuleData.W16Data.MapHandle
                                                            );
                result = (ModuleImage->ModuleData.W16Data.Image != NULL);
            }
        }
        __finally {
            if (fileHandle != INVALID_HANDLE_VALUE) {
                CloseHandle (fileHandle);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        CloseHandle (fileHandle);
    }
    return result;
}

BOOL
MdLoadModuleDataW (
    IN      PCWSTR ModuleName,
    OUT     PMD_MODULE_IMAGE ModuleImage
    )
{
    PCSTR moduleNameA;
    HANDLE fileHandle;
    DWORD bytesRead;
    DOS_HEADER dh;
    DWORD sign;
    PWORD signNE = (PWORD)&sign;
    BOOL result = FALSE;

    ZeroMemory (ModuleImage, sizeof (MD_MODULE_IMAGE));

    fileHandle = CreateFileW (ModuleName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        ModuleImage->ModuleType = MODULETYPE_UNKNOWN;
        return FALSE;
    }
    __try {
        __try {
            if ((!ReadFile (fileHandle, &dh, sizeof (DOS_HEADER), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DOS_HEADER))
                ) {
                __leave;
            }
            result = TRUE;
            if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_UNKNOWN;
                __leave;
            }
            ModuleImage->ModuleType = MODULETYPE_DOS;

            if (SetFilePointer (fileHandle, dh.e_lfanew, NULL, FILE_BEGIN) != (DWORD)dh.e_lfanew) {
                __leave;
            }
            if ((!ReadFile (fileHandle, &sign, sizeof (DWORD), &bytesRead, NULL)) ||
                (bytesRead != sizeof (DWORD))
                ) {
                __leave;
            }
            CloseHandle (fileHandle);
            fileHandle = INVALID_HANDLE_VALUE;

            if (sign == IMAGE_PE_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_WIN32;
                moduleNameA = ConvertWtoA (ModuleName);
                if (moduleNameA) {
                    result = MapAndLoad ((PSTR) moduleNameA, NULL, &ModuleImage->ModuleData.W32Data.Image, FALSE, TRUE);
                    FreeConvertedStr (moduleNameA);
                }
            }
            if (*signNE == IMAGE_NE_SIGNATURE) {
                ModuleImage->ModuleType = MODULETYPE_WIN16;
                ModuleImage->ModuleData.W16Data.Image = MapFileIntoMemoryW (
                                                            ModuleName,
                                                            &ModuleImage->ModuleData.W16Data.FileHandle,
                                                            &ModuleImage->ModuleData.W16Data.MapHandle
                                                            );
                result = (ModuleImage->ModuleData.W16Data.Image != NULL);
            }
        }
        __finally {
            if (fileHandle != INVALID_HANDLE_VALUE) {
                CloseHandle (fileHandle);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        CloseHandle (fileHandle);
    }
    return result;
}

BOOL
MdUnloadModuleDataA (
    IN OUT  PMD_MODULE_IMAGE ModuleImage
    )
{
    switch (ModuleImage->ModuleType) {
    case MODULETYPE_WIN32:
        UnMapAndLoad (&ModuleImage->ModuleData.W32Data.Image);
        break;
    case MODULETYPE_WIN16:
        UnmapFile (
            (PVOID) ModuleImage->ModuleData.W16Data.Image,
            ModuleImage->ModuleData.W16Data.FileHandle,
            ModuleImage->ModuleData.W16Data.MapHandle
            );
        break;
    default:;
    }
    return TRUE;
}

BOOL
MdUnloadModuleDataW (
    IN OUT  PMD_MODULE_IMAGE ModuleImage
    )
{
    switch (ModuleImage->ModuleType) {
    case MODULETYPE_WIN32:
        UnMapAndLoad (&ModuleImage->ModuleData.W32Data.Image);
        break;
    case MODULETYPE_WIN16:
        UnmapFile (
            (PVOID) ModuleImage->ModuleData.W16Data.Image,
            ModuleImage->ModuleData.W16Data.FileHandle,
            ModuleImage->ModuleData.W16Data.MapHandle
            );
        break;
    default:;
    }
    return TRUE;
}

BOOL
MdEnumNextImport16A (
    IN OUT  PMD_IMPORT_ENUM16A ImportsEnum
    )
{
    PBYTE currSegmentOffset,importPtr;
    PWORD moduleNameOffset;
    BOOL itemFound;
    PMD_IMPORT_ENUM16_HANDLE handle;

    handle = (PMD_IMPORT_ENUM16_HANDLE) ImportsEnum->Handle;

    handle->RelocItem ++;
    handle->CurrRelocItem ++;

    itemFound = FALSE;

    while ((handle->CurrSegEntry <= handle->NeHeader->NumEntriesSegTable) && (!itemFound)) {

        if (((handle->SegmentEntry->SegmentFlags & SEG_CODE_MASK   ) == SEG_CODE   ) &&
            ((handle->SegmentEntry->SegmentFlags & SEG_RELOC_MASK  ) == SEG_RELOC  ) &&
            ((handle->SegmentEntry->SegmentFlags & SEG_PRELOAD_MASK) == SEG_PRELOAD)
           ) {
            __try {

                while ((handle->CurrRelocItem <= *(handle->CurrNrReloc)) && (!itemFound)) {

                    if (((handle->RelocItem->AddressType ==  0) ||
                         (handle->RelocItem->AddressType ==  2) ||
                         (handle->RelocItem->AddressType ==  3) ||
                         (handle->RelocItem->AddressType ==  5) ||
                         (handle->RelocItem->AddressType == 11) ||
                         (handle->RelocItem->AddressType == 13)
                        ) &&
                        ((handle->RelocItem->RelocType == RELOC_IMPORTED_ORDINAL) ||
                         (handle->RelocItem->RelocType == RELOC_IMPORTED_NAME   )
                        )
                       ) {
                        itemFound = TRUE;
                        moduleNameOffset = (PWORD) (handle->Image +
                                                    handle->DosHeader->e_lfanew +
                                                    handle->NeHeader->ModuleTableOffset +
                                                    (handle->RelocItem->ModuleOffset - 1) * sizeof (WORD));
                        importPtr = handle->Image +
                                    handle->DosHeader->e_lfanew +
                                    handle->NeHeader->ImportedTableOffset +
                                    *moduleNameOffset;
                        strncpy (ImportsEnum->ImportModule, importPtr + 1, (BYTE)importPtr[0]);
                        ImportsEnum->ImportModule[(BYTE)importPtr[0]] = 0;

                        if (handle->RelocItem->RelocType == RELOC_IMPORTED_ORDINAL) {
                            ImportsEnum->ImportFunction[0] = 0;
                            ImportsEnum->ImportFunctionOrd = handle->RelocItem->FunctionOffset;
                        }
                        else {
                            importPtr = handle->Image +
                                        handle->DosHeader->e_lfanew +
                                        handle->NeHeader->ImportedTableOffset +
                                        handle->RelocItem->FunctionOffset;
                            strncpy (ImportsEnum->ImportFunction, importPtr + 1, (BYTE)importPtr[0]);
                            ImportsEnum->ImportFunction[(BYTE)importPtr[0]] = 0;
                            ImportsEnum->ImportFunctionOrd = 0;
                        }
                    }

                    if (!itemFound) {
                        handle->RelocItem ++;
                        handle->CurrRelocItem ++;
                    }
                }
            }
            __except (1) {
                itemFound = FALSE;
            }
        }
        if (!itemFound) {
            handle->SegmentEntry ++;
            handle->CurrSegEntry ++;

            currSegmentOffset = handle->Image +
                                (handle->SegmentEntry->SegmentOffset << handle->NeHeader->ShiftCount);
            if (handle->SegmentEntry->SegmentLen == 0) {
                currSegmentOffset += 65535;
            }
            else {
                currSegmentOffset += handle->SegmentEntry->SegmentLen;
            }
            handle->CurrNrReloc = (PWORD) currSegmentOffset;
            currSegmentOffset += sizeof(WORD);

            handle->RelocItem = (PNE_RELOC_ITEM) currSegmentOffset;

            handle->CurrRelocItem = 1;
        }
    }
    return itemFound;
}


BOOL
MdEnumFirstImport16A (
    IN      PBYTE ModuleImage,
    IN OUT  PMD_IMPORT_ENUM16A ImportsEnum
    )
{
    PMD_IMPORT_ENUM16_HANDLE handle;
    PBYTE currSegmentOffset;

    ZeroMemory (ImportsEnum, sizeof (MD_IMPORT_ENUM16A));

    ImportsEnum->Handle = MemAlloc (g_hHeap, 0, sizeof (MD_IMPORT_ENUM16_HANDLE));

    handle = (PMD_IMPORT_ENUM16_HANDLE) ImportsEnum->Handle;

    handle->Image = ModuleImage;

    handle->DosHeader = (PDOS_HEADER) (handle->Image);
    handle->NeHeader = (PNE_HEADER) (handle->Image + handle->DosHeader->e_lfanew);

    handle->SegmentEntry = (PNE_SEGMENT_ENTRY) (handle->Image +
                                                handle->DosHeader->e_lfanew +
                                                handle->NeHeader->SegTableOffset
                                                );
    handle->CurrSegEntry = 1;

    currSegmentOffset = handle->Image +
                        (handle->SegmentEntry->SegmentOffset << handle->NeHeader->ShiftCount);
    if (handle->SegmentEntry->SegmentLen == 0) {
        currSegmentOffset += 65535;
    }
    else {
        currSegmentOffset += handle->SegmentEntry->SegmentLen;
    }
    handle->CurrNrReloc = (PWORD) currSegmentOffset;
    currSegmentOffset += sizeof(WORD);

    handle->RelocItem = (PNE_RELOC_ITEM) currSegmentOffset;

    handle->CurrRelocItem = 1;

    handle->RelocItem --;
    handle->CurrRelocItem --;

    return MdEnumNextImport16A (ImportsEnum);
}

BOOL
MdAbortImport16EnumA (
    IN      PMD_IMPORT_ENUM16A ImportsEnum
    )
{
    if (ImportsEnum->Handle) {
        MemFree (g_hHeap, 0, ImportsEnum->Handle);
        ImportsEnum->Handle = NULL;
    }
    return TRUE;
}

BOOL
MdEnumNextImportFunction32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    )
{
    PMD_IMPORT_ENUM32_HANDLE handle;

    handle = (PMD_IMPORT_ENUM32_HANDLE) ImportsEnum->Handle;

    if (handle->ImportFunctionAddr == 0) {
        return FALSE;
    }
    handle->ImageData = (PIMAGE_THUNK_DATA)
                         ImageRvaToVa (
                            handle->Image->FileHeader,
                            handle->Image->MappedAddress,
                            handle->ImportFunctionAddr,
                            NULL
                            );

    if (handle->ImageData->u1.AddressOfData) {
        handle->ImageName = (PIMAGE_IMPORT_BY_NAME)
                             ImageRvaToVa (
                                handle->Image->FileHeader,
                                handle->Image->MappedAddress,
                                (DWORD)handle->ImageData->u1.AddressOfData,
                                NULL
                                );

        if (handle->ImageName) {    //import by name

            ImportsEnum->ImportFunction = handle->ImageName->Name;
            ImportsEnum->ImportFunctionOrd = 0;
        }
        else {  //import by number

            ImportsEnum->ImportFunction = NULL;
            ImportsEnum->ImportFunctionOrd = (ULONG) handle->ImageData->u1.Ordinal & (~0x80000000);
        }
        handle->ImportFunctionAddr += 4;
        return TRUE;
    }
    else {
        handle->ImportFunctionAddr = 0;
        return FALSE;
    }
}

BOOL
MdEnumFirstImportFunction32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    )
{
    PMD_IMPORT_ENUM32_HANDLE handle;

    handle = (PMD_IMPORT_ENUM32_HANDLE) ImportsEnum->Handle;

    if ((handle->ImageDescriptor == NULL) ||
        (ImportsEnum->ImportModule == NULL)
        ) {
        return FALSE;
    }
    handle->ImportFunctionAddr = handle->ImageDescriptor->OriginalFirstThunk;

    return MdEnumNextImportFunction32A (ImportsEnum);
}

BOOL
MdEnumNextImportModule32A (
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    )
{
    PMD_IMPORT_ENUM32_HANDLE handle;

    handle = (PMD_IMPORT_ENUM32_HANDLE) ImportsEnum->Handle;

    if (handle->ImageDescriptor == NULL) {
        return FALSE;
    }

    handle->ImageDescriptor ++;

    if (handle->ImageDescriptor->Name == 0) {
        return FALSE;
    }
    ImportsEnum->ImportModule = (PCSTR)
                                 ImageRvaToVa (
                                    handle->Image->FileHeader,
                                    handle->Image->MappedAddress,
                                    handle->ImageDescriptor->Name,
                                    NULL
                                    );
    return (ImportsEnum->ImportModule != NULL);
}

BOOL
MdEnumFirstImportModule32A (
    IN      PLOADED_IMAGE ModuleImage,
    IN OUT  PMD_IMPORT_ENUM32A ImportsEnum
    )
{
    PMD_IMPORT_ENUM32_HANDLE handle;
    ULONG imageSize;

    ZeroMemory (ImportsEnum, sizeof (MD_IMPORT_ENUM32A));

    ImportsEnum->Handle = MemAlloc (g_hHeap, 0, sizeof (MD_IMPORT_ENUM32_HANDLE));

    handle = (PMD_IMPORT_ENUM32_HANDLE) ImportsEnum->Handle;

    handle->Image = ModuleImage;

    handle->ImageDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)
                               ImageDirectoryEntryToData (
                                    ModuleImage->MappedAddress,
                                    FALSE,
                                    IMAGE_DIRECTORY_ENTRY_IMPORT,
                                    &imageSize
                                    );
    if (!handle->ImageDescriptor) {
        DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Cannot load import directory for %s", ModuleImage->ModuleName));
        return FALSE;
    }
    if (handle->ImageDescriptor->Name == 0) {
        return FALSE;
    }
    ImportsEnum->ImportModule = (PCSTR)
                                 ImageRvaToVa (
                                    handle->Image->FileHeader,
                                    handle->Image->MappedAddress,
                                    handle->ImageDescriptor->Name,
                                    NULL
                                    );
    return (ImportsEnum->ImportModule != NULL);
}

BOOL
MdAbortImport32EnumA (
    IN      PMD_IMPORT_ENUM32A ImportsEnum
    )
{
    if (ImportsEnum->Handle) {
        MemFree (g_hHeap, 0, ImportsEnum->Handle);
        ImportsEnum->Handle = NULL;
    }
    return TRUE;
}

DWORD
MdGetModuleTypeA (
    IN      PCSTR ModuleName
    )
{
    MD_MODULE_IMAGE moduleImage;
    DWORD result = MODULETYPE_UNKNOWN;

    __try {
        if (!MdLoadModuleDataA (ModuleName, &moduleImage)) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        result = moduleImage.ModuleType;
    }
    __finally {
        MdUnloadModuleDataA (&moduleImage);
    }
    return result;
}

DWORD
MdGetModuleTypeW (
    IN      PCWSTR ModuleName
    )
{
    MD_MODULE_IMAGE moduleImage;
    DWORD result = MODULETYPE_UNKNOWN;

    __try {
        if (!MdLoadModuleDataW (ModuleName, &moduleImage)) {
            DEBUGMSGW((DBG_WARNING, DBG_MODIMAGE":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        result = moduleImage.ModuleType;
    }
    __finally {
        MdUnloadModuleDataW (&moduleImage);
    }
    return result;
}

PCSTR
MdGet16ModuleDescriptionA (
    IN      PCSTR ModuleName
    )
{
    MD_MODULE_IMAGE moduleImage;
    PSTR result = NULL;

    PDOS_HEADER dosHeader;
    PNE_HEADER  neHeader;
    PBYTE size;

    __try {
        if (!MdLoadModuleDataA (ModuleName, &moduleImage)) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        if (moduleImage.ModuleType != MODULETYPE_WIN16) {
            __leave;
        }
        __try {
            dosHeader = (PDOS_HEADER) (moduleImage.ModuleData.W16Data.Image);
            neHeader  = (PNE_HEADER)  (moduleImage.ModuleData.W16Data.Image + dosHeader->e_lfanew);
            size = (PBYTE) (moduleImage.ModuleData.W16Data.Image + neHeader->NonResNameTableOffset);
            if (*size == 0) {
                __leave;
            }
            result = AllocPathStringA (*size + 1);
            strncpy (result, moduleImage.ModuleData.W16Data.Image + neHeader->NonResNameTableOffset + 1, *size);
            result [*size] = 0;
        }
        __except (1) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Access violation while examining %s.", ModuleName));
            if (result != NULL) {
                FreePathStringA (result);
                result = NULL;
            }
            __leave;
        }
    }
    __finally {
        MdUnloadModuleDataA (&moduleImage);
    }
    return result;
}

PCWSTR
MdGet16ModuleDescriptionW (
    IN      PCWSTR ModuleName
    )
{
    MD_MODULE_IMAGE moduleImage;
    PSTR resultA = NULL;
    PCWSTR tempResult = NULL;
    PCWSTR result = NULL;

    PDOS_HEADER dosHeader;
    PNE_HEADER  neHeader;
    PBYTE size;

    __try {
        if (!MdLoadModuleDataW (ModuleName, &moduleImage)) {
            DEBUGMSGW((DBG_WARNING, DBG_MODIMAGE":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        if (moduleImage.ModuleType != MODULETYPE_WIN16) {
            __leave;
        }
        __try {
            dosHeader = (PDOS_HEADER) (moduleImage.ModuleData.W16Data.Image);
            neHeader  = (PNE_HEADER)  (moduleImage.ModuleData.W16Data.Image + dosHeader->e_lfanew);
            size = (PBYTE) (moduleImage.ModuleData.W16Data.Image + neHeader->NonResNameTableOffset);
            if (*size == 0) {
                __leave;
            }
            resultA = AllocPathStringA (*size + 1);
            if (resultA) {
                strncpy (resultA, moduleImage.ModuleData.W16Data.Image + neHeader->NonResNameTableOffset + 1, *size);
                resultA [*size] = 0;
                tempResult = ConvertAtoW (resultA);
                if (tempResult) {
                    result = DuplicatePathStringW (tempResult, 0);
                    FreeConvertedStr (tempResult);
                    tempResult = NULL;
                }
                FreePathStringA (resultA);
                resultA = NULL;
            }
        }
        __except (1) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Access violation while examining %s.", ModuleName));
            if (result != NULL) {
                FreePathStringW (result);
                result = NULL;
            }
            if (tempResult != NULL) {
                FreeConvertedStr (tempResult);
                tempResult = NULL;
            }
            if (resultA != NULL) {
                FreePathStringA (resultA);
                resultA = NULL;
            }
            __leave;
        }
    }
    __finally {
        MdUnloadModuleDataW (&moduleImage);
    }
    return result;
}

PIMAGE_NT_HEADERS
pGetImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);
            if (NtHeaders->Signature == IMAGE_NT_SIGNATURE) {
                return NtHeaders;
            }
        }
    }
    return NULL;
}

ULONG
MdGetPECheckSumA (
    IN      PCSTR ModuleName
    )
{
    MD_MODULE_IMAGE moduleImage;
    ULONG result = 0;
    PIMAGE_NT_HEADERS NtHeaders;

    __try {
        if (!MdLoadModuleDataA (ModuleName, &moduleImage)) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Cannot load image for %s. Error:%ld", ModuleName, GetLastError()));
            __leave;
        }
        if (moduleImage.ModuleType != MODULETYPE_WIN32) {
            __leave;
        }
        __try {
            NtHeaders = pGetImageNtHeader(moduleImage.ModuleData.W32Data.Image.MappedAddress);
            if (NtHeaders) {
                if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                    result = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum;
                } else
                if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                    result = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum;
                }
            }
        }
        __except (1) {
            DEBUGMSGA((DBG_WARNING, DBG_MODIMAGE":Access violation while examining %s.", ModuleName));
            result = 0;
            __leave;
        }
    }
    __finally {
        MdUnloadModuleDataA (&moduleImage);
    }
    return result;
}

DWORD
MdGetCheckSumA (
    IN      PCSTR ModuleName
    )
/*++

Routine Description:

  GetCheckSum will compute the check sum for 4096 bytes starting at offset 512. The offset and the size of
  the chunk are modified if the file size is too small.

Arguments:

  ModuleName - Specifies the file to compute the check sum for.

Return value:

  The computed checksum

--*/
{
    INT    i,size     = 4096;
    DWORD  startAddr  = 512;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCHAR  buffer     = NULL;
    DWORD  checkSum   = 0;
    DWORD  dontCare;
    WIN32_FIND_DATAA findData;

    if (!DoesFileExistExA (ModuleName, &findData)) {
        return checkSum;
    }

    if (findData.nFileSizeLow < (ULONG)size) {
        //
        // File size is less than 4096. We set the start address to 0 and set the size for the checksum
        // to the actual file size.
        //
        startAddr = 0;
        size = findData.nFileSizeLow;
    }
    else
    if (startAddr + size > findData.nFileSizeLow) {
        //
        // File size is too small. We set the start address so that size of checksum can be 4096 bytes
        //
        startAddr = findData.nFileSizeLow - size;
    }
    if (size <= 3) {
        //
        // we need at least 3 bytes to be able to do something here.
        //
        return 0;
    }
    __try {
        buffer = HeapAlloc (g_hHeap, 0, size);
        if (buffer == NULL) {
            __leave;
        }
        fileHandle = CreateFileA (ModuleName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (fileHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (SetFilePointer (fileHandle, startAddr, NULL, FILE_BEGIN) != startAddr) {
            __leave;
        }

        if (!ReadFile (fileHandle, buffer, size, &dontCare, NULL)) {
            __leave;
        }
        for (i = 0; i<(size - 3); i+=4) {
            checkSum += *((PDWORD) (buffer + i));
            checkSum = _rotr (checkSum ,1);
        }
    }
    __finally {
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (buffer != NULL) {
            HeapFree (g_hHeap, 0, buffer);
        }
    }
    return checkSum;
}

DWORD
MdGetCheckSumW (
    IN      PCWSTR ModuleName
    )
/*++

Routine Description:

  GetCheckSum will compute the check sum for 4096 bytes starting at offset 512. The offset and the size of
  the chunk are modified if the file size is too small.

Arguments:

  ModuleName - Specifies the file to compute the check sum for.

Return value:

  The computed checksum

--*/
{
    INT    i,size     = 4096;
    DWORD  startAddr  = 512;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCHAR  buffer     = NULL;
    DWORD  checkSum   = 0;
    DWORD  dontCare;
    WIN32_FIND_DATAW findData;

    if (!DoesFileExistExW (ModuleName, &findData)) {
        return checkSum;
    }

    if (findData.nFileSizeLow < (ULONG)size) {
        //
        // File size is less than 4096. We set the start address to 0 and set the size for the checksum
        // to the actual file size.
        //
        startAddr = 0;
        size = findData.nFileSizeLow;
    }
    else
    if (startAddr + size > findData.nFileSizeLow) {
        //
        // File size is too small. We set the start address so that size of checksum can be 4096 bytes
        //
        startAddr = findData.nFileSizeLow - size;
    }
    if (size <= 3) {
        //
        // we need at least 3 bytes to be able to do something here.
        //
        return 0;
    }
    __try {
        buffer = HeapAlloc (g_hHeap, 0, size);
        if (buffer == NULL) {
            __leave;
        }
        fileHandle = CreateFileW (ModuleName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (fileHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (SetFilePointer (fileHandle, startAddr, NULL, FILE_BEGIN) != startAddr) {
            __leave;
        }

        if (!ReadFile (fileHandle, buffer, size, &dontCare, NULL)) {
            __leave;
        }
        for (i = 0; i<(size - 3); i+=4) {
            checkSum += *((PDWORD) (buffer + i));
            checkSum = _rotr (checkSum ,1);
        }
    }
    __finally {
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (buffer != NULL) {
            HeapFree (g_hHeap, 0, buffer);
        }
    }
    return checkSum;
}

VOID
DestroyAnsiResourceId (
    IN      PCSTR AnsiId
    )
{
    if (HIWORD (AnsiId)) {
        FreeConvertedStr (AnsiId);
    }
}


VOID
DestroyUnicodeResourceId (
    IN      PCWSTR UnicodeId
    )
{
    if (HIWORD (UnicodeId)) {
        FreeConvertedStr (UnicodeId);
    }
}

BOOL
NeLoadHeader (
    IN      HANDLE File,
    OUT     PNE_INFO_BLOCK Header
    )
{
    DOS_HEADER dh;
    LONG rc = ERROR_BAD_FORMAT;
    BOOL b = FALSE;

    __try {
        SetFilePointer (File, 0, NULL, FILE_BEGIN);
        if (!BfReadFile (File, (PBYTE)(&dh), sizeof (DOS_HEADER))) {
            __leave;
        }

        if (dh.e_magic != ('M' + 'Z' * 256)) {
            __leave;
        }

        SetFilePointer (File, dh.e_lfanew, NULL, FILE_BEGIN);
        if (!BfReadFile (File, (PBYTE)Header, sizeof (NE_INFO_BLOCK))) {
            __leave;
        }

        if (Header->Signature != ('N' + 'E' * 256) &&
            Header->Signature != ('L' + 'E' * 256)
            ) {
            if (Header->Signature == ('P' + 'E' * 256)) {
                rc = ERROR_BAD_EXE_FORMAT;
            } else {
                rc = ERROR_INVALID_EXE_SIGNATURE;
            }

            DEBUGMSG ((DBG_NAUSEA, "Header signature is %c%c", Header->Signature & 0xff, Header->Signature >> 8));
            __leave;
        }

        SetFilePointer (File, (DWORD) dh.e_lfanew, NULL, FILE_BEGIN);

        b = TRUE;
    }
    __finally {
        if (!b) {
            SetLastError (rc);
        }
    }

    return b;
}

DWORD
pComputeSizeOfTypeInfo (
    IN      PNE_RES_TYPEINFO TypeInfo
    )
{
    return sizeof (NE_RES_TYPEINFO) + TypeInfo->ResourceCount * sizeof (NE_RES_NAMEINFO);
}

PNE_RES_TYPEINFO
pReadNextTypeInfoStruct (
    IN      HANDLE File,
    IN      PMHANDLE Pool
    )
{
    WORD Type;
    WORD ResCount;
    NE_RES_TYPEINFO TypeInfo;
    PNE_RES_TYPEINFO ReturnInfo = NULL;
    DWORD Size;

    if (!BfReadFile (File, (PBYTE)(&Type), sizeof (WORD))) {
        return NULL;
    }

    if (!Type) {
        return NULL;
    }

    if (!BfReadFile (File, (PBYTE)(&ResCount), sizeof (WORD))) {
        return NULL;
    }

    TypeInfo.TypeId = Type;
    TypeInfo.ResourceCount = ResCount;

    if (!BfReadFile (File, (PBYTE)(&TypeInfo.Reserved), sizeof (DWORD))) {
        return NULL;
    }

    Size = sizeof (NE_RES_NAMEINFO) * ResCount;

    ReturnInfo  = (PNE_RES_TYPEINFO) PmGetMemory (Pool, Size + sizeof (TypeInfo));
    if (!ReturnInfo) {
        return NULL;
    }

    CopyMemory (ReturnInfo, &TypeInfo, sizeof (TypeInfo));

    if (!BfReadFile (File, (PBYTE) ReturnInfo + sizeof (TypeInfo), Size)) {
        return NULL;
    }

    return ReturnInfo;
}

BOOL
pReadTypeInfoArray (
    IN      HANDLE File,
    IN OUT  PGROWLIST TypeInfoList
    )
{
    PNE_RES_TYPEINFO TypeInfo;
    DWORD Size;
    PMHANDLE TempPool;
    BOOL b = FALSE;

    TempPool = PmCreatePool();
    if (!TempPool) {
        return FALSE;
    }

    __try {

        TypeInfo = pReadNextTypeInfoStruct (File, TempPool);
        while (TypeInfo) {
            Size = pComputeSizeOfTypeInfo (TypeInfo);
            if (!GlAppend (TypeInfoList, (PBYTE) TypeInfo, Size)) {
                __leave;
            }

            TypeInfo = pReadNextTypeInfoStruct (File, TempPool);
        }

        b = TRUE;
    }
    __finally {

        PmDestroyPool (TempPool);
    }

    return b;
}

BOOL
pReadStringArrayA (
    IN      HANDLE File,
    IN OUT  PGROWLIST GrowList
    )
{
    BYTE Size;
    CHAR Name[256];

    if (!BfReadFile (File, (PBYTE)(&Size), sizeof (BYTE))) {
        return FALSE;
    }

    while (Size) {

        if (!BfReadFile (File, Name, (DWORD) Size)) {
            return FALSE;
        }

        Name[Size] = 0;

        GlAppendStringA (GrowList, Name);

        if (!BfReadFile (File, (PBYTE)(&Size), sizeof (BYTE))) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
NeLoadResources (
    IN      HANDLE File,
    OUT     PNE_RESOURCES Resources
    )
{
    NE_INFO_BLOCK Header;

    ZeroMemory (Resources, sizeof (NE_RESOURCES));

    if (!NeLoadHeader (File, &Header)) {
        return FALSE;
    }

    //
    // Read in NE_RESOURCES struct
    //

    SetFilePointer (File, (DWORD) Header.OffsetToResourceTable, NULL, FILE_CURRENT);

    if (!BfReadFile (File, (PBYTE)(&Resources->AlignShift), sizeof (WORD))) {
        return FALSE;
    }

    // Array of NE_RES_TYPEINFO structs
    if (!pReadTypeInfoArray (File, &Resources->TypeInfoArray)) {
        return FALSE;
    }

    // Resource names
    if (!pReadStringArrayA (File, &Resources->ResourceNames)) {
        return FALSE;
    }

    return TRUE;
}

VOID
NeFreeResources (
    PNE_RESOURCES Resources
    )
{
    GlFree (&Resources->TypeInfoArray);
    GlFree (&Resources->ResourceNames);

    ZeroMemory (Resources, sizeof (NE_RESOURCES));
}

HANDLE
NeOpenFileA (
    PCSTR FileName
    )
{
    PNE_HANDLE NeHandle;
    BOOL b = FALSE;

    NeHandle = (PNE_HANDLE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NE_HANDLE));

    __try {

        NeHandle->ResourcePool = PmCreatePool();
        if (!NeHandle->ResourcePool) {
            __leave;
        }

        NeHandle->File = CreateFileA (
                            FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if (NeHandle->File == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (!NeLoadHeader (NeHandle->File, &NeHandle->Header)) {
            __leave;
        }

        NeHandle->HeaderOffset = SetFilePointer (NeHandle->File, 0, NULL, FILE_CURRENT);

        b = TRUE;
    }
    __finally {
        if (!b) {
            PushError();

            if (NeHandle->ResourcePool) {
                PmDestroyPool (NeHandle->ResourcePool);
            }

            if (NeHandle->File != INVALID_HANDLE_VALUE) {
                CloseHandle (NeHandle->File);
            }

            MemFree (g_hHeap, 0, NeHandle);
            NeHandle = NULL;

            PopError();
        }
    }

    return (HANDLE) NeHandle;
}

HANDLE
NeOpenFileW (
    PCWSTR FileName
    )
{
    PNE_HANDLE NeHandle;
    BOOL b = FALSE;

    NeHandle = (PNE_HANDLE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NE_HANDLE));

    __try {

        NeHandle->ResourcePool = PmCreatePool();
        if (!NeHandle->ResourcePool) {
            __leave;
        }

        NeHandle->File = CreateFileW (
                            FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if (NeHandle->File == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (!NeLoadHeader (NeHandle->File, &NeHandle->Header)) {
            __leave;
        }

        NeHandle->HeaderOffset = SetFilePointer (NeHandle->File, 0, NULL, FILE_CURRENT);

        b = TRUE;
    }
    __finally {
        if (!b) {
            PushError();

            if (NeHandle->ResourcePool) {
                PmDestroyPool (NeHandle->ResourcePool);
            }

            if (NeHandle->File != INVALID_HANDLE_VALUE) {
                CloseHandle (NeHandle->File);
            }

            MemFree (g_hHeap, 0, NeHandle);
            NeHandle = NULL;

            PopError();
        }
    }

    return (HANDLE) NeHandle;
}

VOID
NeCloseFile (
    HANDLE Handle
    )
{
    PNE_HANDLE NeHandle;

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle) {
        return;
    }

    if (NeHandle->File != INVALID_HANDLE_VALUE) {
        CloseHandle (NeHandle->File);
    }

    if (NeHandle->ResourcesLoaded) {
        NeFreeResources (&NeHandle->Resources);
    }

    PmDestroyPool (NeHandle->ResourcePool);

    MemFree (g_hHeap, 0, NeHandle);
}

PCSTR
pConvertUnicodeResourceId (
    IN      PCWSTR ResId
    )
{
    if (HIWORD (ResId)) {
        return ConvertWtoA (ResId);
    }

    return (PCSTR) ResId;
}

PCSTR
pDecodeIdReferenceInString (
    IN      PCSTR ResName
    )
{
    if (HIWORD (ResName) && ResName[0] == '#') {
        return (PCSTR) (ULONG_PTR) atoi (&ResName[1]);
    }

    return ResName;
}

BOOL
pNeLoadResourcesFromHandle (
    IN      PNE_HANDLE NeHandle
    )
{
    if (NeHandle->ResourcesLoaded) {
        return TRUE;
    }

    if (!NeLoadResources (NeHandle->File, &NeHandle->Resources)) {
        return FALSE;
    }

    NeHandle->ResourcesLoaded = TRUE;
    return TRUE;
}

BOOL
pLoadNeResourceName (
    OUT     PSTR ResName,
    IN      HANDLE File,
    IN      DWORD StringOffset
    )
{
    BYTE ResNameSize;

    SetFilePointer (File, StringOffset, NULL, FILE_BEGIN);
    if (!BfReadFile (File, (PBYTE)(&ResNameSize), 1)) {
        return FALSE;
    }

    ResName[ResNameSize] = 0;

    return BfReadFile (File, ResName, ResNameSize);
}

BOOL
pNeEnumResourceTypesEx (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCEXA EnumFunc,
    IN      LONG_PTR lParam,
    IN      BOOL ExFunctionality,
    IN      BOOL UnicodeProc
    )
{
    PNE_HANDLE NeHandle;
    PNE_RES_TYPEINFO TypeInfo;
    INT Count;
    INT i;
    DWORD StringOffset;
    CHAR ResName[256];
    ENUMRESTYPEPROCA EnumFunc2 = (ENUMRESTYPEPROCA) EnumFunc;
    ENUMRESTYPEPROCEXW EnumFuncW = (ENUMRESTYPEPROCEXW) EnumFunc;
    ENUMRESTYPEPROCW EnumFunc2W = (ENUMRESTYPEPROCW) EnumFunc;
    PWSTR UnicodeResName = NULL;

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !EnumFunc) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pNeLoadResourcesFromHandle (NeHandle)) {
        return FALSE;
    }

    //
    // Enumerate all resource types
    //

    Count = GlGetSize (&NeHandle->Resources.TypeInfoArray);
    for (i = 0 ; i < Count ; i++) {
        TypeInfo = (PNE_RES_TYPEINFO) GlGetItem (&NeHandle->Resources.TypeInfoArray, i);

        if (TypeInfo->TypeId & 0x8000) {
            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, (PWSTR) (ULONG_PTR) (TypeInfo->TypeId & 0x7fff), lParam, TypeInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, (PSTR) (ULONG_PTR) (TypeInfo->TypeId & 0x7fff), lParam, TypeInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, (PWSTR) (ULONG_PTR) (TypeInfo->TypeId & 0x7fff), lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, (PSTR) (ULONG_PTR) (TypeInfo->TypeId & 0x7fff), lParam)) {
                        break;
                    }
                }
            }
        } else {
            //
            // TypeInfo->TypeId gives an offset to the resource string name,
            // relative to the start of the resource table
            //

            StringOffset = NeHandle->HeaderOffset + NeHandle->Header.OffsetToResourceTable + TypeInfo->TypeId;
            pLoadNeResourceName (ResName, NeHandle->File, StringOffset);

            if (UnicodeProc) {
                UnicodeResName = (PWSTR) ConvertAtoW (ResName);
            }

            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, UnicodeResName, lParam, TypeInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, ResName, lParam, TypeInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, UnicodeResName, lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, ResName, lParam)) {
                        break;
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
NeEnumResourceTypesA (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCA EnumFunc,
    IN      LONG_PTR lParam
    )
{
    return pNeEnumResourceTypesEx (
                Handle,
                (ENUMRESTYPEPROCEXA) EnumFunc,
                lParam,
                FALSE,          // no ex functionality
                FALSE           // ANSI enum proc
                );
}

BOOL
NeEnumResourceTypesW (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCW EnumFunc,
    IN      LONG_PTR lParam
    )
{
    return pNeEnumResourceTypesEx (
                Handle,
                (ENUMRESTYPEPROCEXA) EnumFunc,
                lParam,
                FALSE,          // no ex functionality
                TRUE            // UNICODE enum proc
                );
}

BOOL
pEnumTypeForNameSearchProcA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      LONG_PTR lParam,
    IN      PNE_RES_TYPEINFO TypeInfo
    )
{
    PTYPESEARCHDATAA Data;

    Data = (PTYPESEARCHDATAA) lParam;

    //
    // Compare type
    //

    if (HIWORD (Data->TypeToFind) == 0) {
        if (Type != Data->TypeToFind) {
            return TRUE;
        }
    } else {
        if (HIWORD (Type) == 0) {
            return TRUE;
        }

        if (!StringIMatchA (Type, Data->TypeToFind)) {
            return TRUE;
        }
    }

    //
    // Type found
    //

    Data->OutboundTypeInfo = TypeInfo;
    Data->Found = TRUE;

    return FALSE;
}

BOOL
pNeEnumResourceNamesEx (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCEXA EnumFunc,
    IN      LONG_PTR lParam,
    IN      BOOL ExFunctionality,
    IN      BOOL UnicodeProc
    )
{
    PNE_HANDLE NeHandle;
    PNE_RES_TYPEINFO TypeInfo;
    PNE_RES_NAMEINFO NameInfo;
    TYPESEARCHDATAA Data;
    WORD w;
    DWORD StringOffset;
    CHAR ResName[256];
    ENUMRESNAMEPROCA EnumFunc2 = (ENUMRESNAMEPROCA) EnumFunc;
    ENUMRESNAMEPROCEXW EnumFuncW = (ENUMRESNAMEPROCEXW) EnumFunc;
    ENUMRESNAMEPROCW EnumFunc2W = (ENUMRESNAMEPROCW) EnumFunc;
    PCWSTR UnicodeType = NULL;
    PCWSTR UnicodeResName = NULL;

    Type = pDecodeIdReferenceInString (Type);

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !EnumFunc) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pNeLoadResourcesFromHandle (NeHandle)) {
        return FALSE;
    }

    //
    // Locate type
    //

    ZeroMemory (&Data, sizeof (Data));

    Data.TypeToFind = Type;

    if (!pNeEnumResourceTypesEx (
            Handle,
            pEnumTypeForNameSearchProcA,
            (ULONG_PTR) &Data,
            TRUE,           // ex functionality
            FALSE           // ANSI enum proc
            )) {
        SetLastError (ERROR_RESOURCE_TYPE_NOT_FOUND);
        return FALSE;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_TYPE_NOT_FOUND);
        return FALSE;
    }

    TypeInfo = Data.OutboundTypeInfo;

    if (UnicodeProc) {
        if (HIWORD (Type)) {
            UnicodeType = ConvertAtoW (Type);
        } else {
            UnicodeType = (PCWSTR) Type;
        }
    }

    //
    // Enumerate the resource names
    //

    NameInfo = TypeInfo->NameInfo;

    for (w = 0 ; w < TypeInfo->ResourceCount ; w++) {

        if (NameInfo->Id & 0x8000) {
            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (
                            Handle,
                            UnicodeType,
                            (PWSTR) (ULONG_PTR) (NameInfo->Id & 0x7fff),
                            lParam,
                            TypeInfo,
                            NameInfo
                            )) {
                        break;
                    }
                } else {
                    if (!EnumFunc (
                            Handle,
                            Type,
                            (PSTR) (ULONG_PTR) (NameInfo->Id & 0x7fff),
                            lParam,
                            TypeInfo,
                            NameInfo
                            )) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (
                            Handle,
                            UnicodeType,
                            (PWSTR) (ULONG_PTR) (NameInfo->Id & 0x7fff),
                            lParam
                            )) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (
                            Handle,
                            Type,
                            (PSTR) (ULONG_PTR) (NameInfo->Id & 0x7fff),
                            lParam
                            )) {
                        break;
                    }
                }
            }
        } else {
            //
            // TypeInfo->TypeId gives an offset to the resource string name,
            // relative to the start of the resource table
            //

            StringOffset = NeHandle->HeaderOffset + NeHandle->Header.OffsetToResourceTable + NameInfo->Id;
            pLoadNeResourceName (ResName, NeHandle->File, StringOffset);

            if (UnicodeProc) {
                UnicodeResName = ConvertAtoW (ResName);
            }

            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, UnicodeType, (PWSTR) UnicodeResName, lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, Type, ResName, lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, UnicodeType, (PWSTR) UnicodeResName, lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, Type, ResName, lParam)) {
                        break;
                    }
                }
            }

            if (UnicodeProc) {
                FreeConvertedStr (UnicodeResName);
            }
        }

        NameInfo++;
    }

    if (UnicodeProc) {
       DestroyUnicodeResourceId (UnicodeType);
    }

    return TRUE;
}

BOOL
NeEnumResourceNamesA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCA EnumFunc,
    IN      LONG_PTR lParam
    )
{
    return pNeEnumResourceNamesEx (
                Handle,
                Type,
                (ENUMRESNAMEPROCEXA) EnumFunc,
                lParam,
                FALSE,      // no ex functionality
                FALSE       // ANSI enum proc
                );
}

BOOL
NeEnumResourceNamesW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      ENUMRESNAMEPROCW EnumFunc,
    IN      LONG_PTR lParam
    )
{
    BOOL b;
    PCSTR AnsiType;

    AnsiType = pConvertUnicodeResourceId (Type);

    b = pNeEnumResourceNamesEx (
            Handle,
            AnsiType,
            (ENUMRESNAMEPROCEXA) EnumFunc,
            lParam,
            FALSE,          // no ex functionality
            TRUE            // UNICODE enum proc
            );

    PushError();
    DestroyAnsiResourceId (AnsiType);
    PopError();

    return b;
}

BOOL
pEnumTypeForResSearchProcA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name,
    IN      LPARAM lParam,
    IN      PNE_RES_TYPEINFO TypeInfo,
    IN      PNE_RES_NAMEINFO NameInfo
    )
{
    PNAMESEARCHDATAA Data;

    Data = (PNAMESEARCHDATAA) lParam;

    //
    // Compare name
    //

    if (HIWORD (Data->NameToFind) == 0) {
        if (Name != Data->NameToFind) {
            return TRUE;
        }
    } else {
        if (HIWORD (Name) == 0) {
            return TRUE;
        }

        if (!StringIMatchA (Name, Data->NameToFind)) {
            return TRUE;
        }
    }

    //
    // Name found
    //

    Data->OutboundTypeInfo = TypeInfo;
    Data->OutboundNameInfo = NameInfo;
    Data->Found = TRUE;

    return FALSE;
}

PBYTE
NeFindResourceExA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    )
{
    PNE_HANDLE NeHandle;
    NAMESEARCHDATAA Data;
    DWORD Offset;
    DWORD Length;
    PNE_RES_NAMEINFO NameInfo;
    PBYTE ReturnData;

    Type = pDecodeIdReferenceInString (Type);
    Name = pDecodeIdReferenceInString (Name);

    ZeroMemory (&Data, sizeof (Data));

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !Type || !Name) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (!pNeLoadResourcesFromHandle (NeHandle)) {
        return NULL;
    }

    //
    // Find resource
    //

    Data.NameToFind = Name;

    if (!pNeEnumResourceNamesEx (
            Handle,
            Type,
            pEnumTypeForResSearchProcA,
            (LONG_PTR) &Data,
            TRUE,
            FALSE
            )) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return NULL;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return NULL;
    }

    NameInfo = Data.OutboundNameInfo;

    Offset = (DWORD) NameInfo->Offset << (DWORD) NeHandle->Resources.AlignShift;
    Length = (DWORD) NameInfo->Length << (DWORD) NeHandle->Resources.AlignShift;

    ReturnData = PmGetMemory (NeHandle->ResourcePool, Length);
    if (!ReturnData) {
        return NULL;
    }

    SetFilePointer (NeHandle->File, Offset, NULL, FILE_BEGIN);

    if (!BfReadFile (NeHandle->File, ReturnData, Length)) {
        PushError();
        MemFree (g_hHeap, 0, ReturnData);
        PopError();
        return NULL;
    }

    return ReturnData;
}

PBYTE
NeFindResourceExW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    )
{
    PCSTR AnsiType;
    PCSTR AnsiName;
    PBYTE Resource;

    AnsiType = pConvertUnicodeResourceId (Type);
    AnsiName = pConvertUnicodeResourceId (Name);

    Resource = NeFindResourceExA (
                    Handle,
                    AnsiType,
                    AnsiName
                    );

    PushError();

    DestroyAnsiResourceId (AnsiType);
    DestroyAnsiResourceId (AnsiName);

    PopError();

    return Resource;
}

DWORD
NeSizeofResourceA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    )
{
    PNE_HANDLE NeHandle;
    NAMESEARCHDATAA Data;
    DWORD result = 0;

    SetLastError (ERROR_SUCCESS);

    Type = pDecodeIdReferenceInString (Type);
    Name = pDecodeIdReferenceInString (Name);

    ZeroMemory (&Data, sizeof (Data));

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !Type || !Name) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!pNeLoadResourcesFromHandle (NeHandle)) {
        return 0;
    }

    //
    // Find resource
    //

    Data.NameToFind = Name;

    if (!pNeEnumResourceNamesEx (
            Handle,
            Type,
            pEnumTypeForResSearchProcA,
            (LONG_PTR) &Data,
            TRUE,
            FALSE
            )) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return 0;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return 0;
    }

    result = Data.OutboundNameInfo->Length;
    result = result<<4;
    return result;
}

DWORD
NeSizeofResourceW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    )
{
    PCSTR AnsiType;
    PCSTR AnsiName;
    DWORD Size;

    AnsiType = pConvertUnicodeResourceId (Type);
    AnsiName = pConvertUnicodeResourceId (Name);

    Size = NeSizeofResourceA (Handle, AnsiType, AnsiName);

    PushError();

    DestroyAnsiResourceId (AnsiType);
    DestroyAnsiResourceId (AnsiName);

    PopError();

    return Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\reg\regp.h ===
HKEY
OpenRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    );

HKEY
OpenRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
CloseRegKeyWorker (
    IN      HKEY Key
    );

#ifdef DEBUG

VOID
RegTrackTerminate (
    VOID
    );

VOID
AddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
AddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#define TRACK_KEYA(handle,keystr) AddKeyReferenceA(handle,keystr,__FILE__,__LINE__)
#define TRACK_KEYW(handle,keystr) AddKeyReferenceW(handle,keystr,__FILE__,__LINE__)

#else

#define TRACK_KEYA(handle,keystr)
#define TRACK_KEYW(handle,keystr)

#endif


//
// Cache apis
//

BOOL
RegEnumInitialize (
    VOID
    );

VOID
RegEnumTerminate (
    VOID
    );

VOID
RegRecordParentInCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR StringEnd
    );

HKEY
RegGetKeyFromCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR End,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    );

VOID
RegAddKeyToCacheA (
    IN      PCSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    );

VOID
RegRecordParentInCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR StringEnd
    );

HKEY
RegGetKeyFromCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR End,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    );

VOID
RegAddKeyToCacheW (
    IN      PCWSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    );

VOID
RegRemoveItemFromCacheA (
    IN      PCSTR RegKey
    );

VOID
RegRemoveItemFromCacheW (
    IN      PCWSTR RegKey
    );

BOOL
RegDecrementRefCount (
    IN      HKEY Key
    );

VOID
RegIncrementRefCount (
    IN      HKEY Key
    );

extern REGSAM g_OpenSam;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\reg\regenum.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regenum.c

Abstract:

    Implements a set of APIs to enumerate the local registry using Win32 APIs.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "reg.h"

//
// Includes
//

// None

#define DBG_REGENUM     "RegEnum"

//
// Strings
//

#define S_REGENUM       "REGENUM"

//
// Constants
//

// None

//
// Macros
//

#define pAllocateMemory(Size)   PmGetMemory (g_RegEnumPool,Size)
#define pFreeMemory(Buffer)     if (Buffer) PmReleaseMemory (g_RegEnumPool, (PVOID)Buffer)

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_RegEnumPool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
RegEnumInitialize (
    VOID
    )

/*++

Routine Description:

    RegEnumInitialize initializes this library.

Arguments:

    none

Return Value:

    TRUE if the init was successful.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    g_RegEnumPool = PmCreateNamedPool (S_REGENUM);
    return g_RegEnumPool != NULL;
}


VOID
RegEnumTerminate (
    VOID
    )

/*++

Routine Description:

    RegEnumTerminate is called to free resources used by this lib.

Arguments:

    none

Return Value:

    none

--*/

{
    DumpOpenKeys ();
    if (g_RegEnumPool) {
        PmDestroyPool (g_RegEnumPool);
        g_RegEnumPool = NULL;
    }
}

BOOL
RegEnumDefaultCallbackA (
    IN      PREGNODEA RegNode       OPTIONAL
    )
{
    return TRUE;
}

BOOL
RegEnumDefaultCallbackW (
    IN      PREGNODEW RegNode       OPTIONAL
    )
{
    return TRUE;
}


INT g_RootEnumIndexTable [] = { 2, 4, 6, 8, -1};

BOOL
EnumFirstRegRootA (
    OUT     PREGROOT_ENUMA EnumPtr
    )
{
    EnumPtr->Index = 0;
    return EnumNextRegRootA (EnumPtr);
}

BOOL
EnumFirstRegRootW (
    OUT     PREGROOT_ENUMW EnumPtr
    )
{
    EnumPtr->Index = 0;
    return EnumNextRegRootW (EnumPtr);
}


BOOL
EnumNextRegRootA (
    IN OUT  PREGROOT_ENUMA EnumPtr
    )
{
    INT i;
    LONG result;

    i = g_RootEnumIndexTable [EnumPtr->Index];

    while (i >= 0) {
        EnumPtr->RegRootName = GetRootStringFromOffsetA (i);
        EnumPtr->RegRootHandle = GetRootKeyFromOffset(i);
        EnumPtr->Index++;
        result = RegQueryInfoKey (
                    EnumPtr->RegRootHandle,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        if (result == ERROR_SUCCESS) {
            return TRUE;
        }
        i = g_RootEnumIndexTable [EnumPtr->Index];
    }
    return FALSE;
}

BOOL
EnumNextRegRootW (
    IN OUT  PREGROOT_ENUMW EnumPtr
    )
{
    INT i;
    LONG result;

    i = g_RootEnumIndexTable [EnumPtr->Index];

    while (i >= 0) {
        EnumPtr->RegRootName = GetRootStringFromOffsetW (i);
        EnumPtr->RegRootHandle = GetRootKeyFromOffset(i);
        EnumPtr->Index++;
        result = RegQueryInfoKey (
                    EnumPtr->RegRootHandle,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        if (result == ERROR_SUCCESS) {
            return TRUE;
        }
        i = g_RootEnumIndexTable [EnumPtr->Index];
    }
    return FALSE;
}

/*++

Routine Description:

    pGetRegEnumInfo is a private function that validates and translates the enumeration info
    in an internal form that's more accessible to the enum routines

Arguments:

    RegEnumInfo - Receives the enum info
    EncodedRegPattern - Specifies the encoded pattern (encoded as defined by the
                        ObjectString functions)
    EnumKeyNames - Specifies TRUE if key names should be returned during the enumeration
                   (if they match the pattern); a key name is returned before any of its
                   subkeys or values
    ContainersFirst - Specifies TRUE if keys should be returned before any of its
                      values or subkeys; used only if EnumKeyNames is TRUE
    ValuesFirst - Specifies TRUE if a key's values should be returned before key's subkeys;
                  this parameter decides the enum order between values and subkeys
                  for each key
    DepthFirst - Specifies TRUE if the current subkey of any key should be fully enumerated
                 before going to the next subkey; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum level of a key that is to be enumerated, relative to
                  the root; if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    keys/values are excluded from enumeration; this slows down the speed
    ReadValueData - Specifies TRUE if data associated with values should also be returned

Return Value:

    TRUE if all params are valid; in this case, RegEnumInfo is filled with the corresponding
         info.
    FALSE otherwise.

--*/

BOOL
pGetRegEnumInfoA (
    OUT     PREGENUMINFOA RegEnumInfo,
    IN      PCSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData
    )
{
    RegEnumInfo->RegPattern = ObsCreateParsedPatternA (EncodedRegPattern);
    if (!RegEnumInfo->RegPattern) {
        DEBUGMSGA ((DBG_ERROR, "pGetRegEnumInfoA: bad EncodedRegPattern: %s", EncodedRegPattern));
        return FALSE;
    }

    if (RegEnumInfo->RegPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsA (
                RegEnumInfo->RegPattern->ExactRoot,
                NULL,
                &RegEnumInfo->RootLevel,
                NULL
                )) {
            return FALSE;
        }
    } else {
        RegEnumInfo->RootLevel = 1;
    }

    if (!RegEnumInfo->RegPattern->Leaf) {
        //
        // no value pattern specified; assume only keynames will be returned
        // overwrite caller's setting
        //
        DEBUGMSGA ((
            DBG_REGENUM,
            "pGetRegEnumInfoA: no value pattern specified; forcing EnumDirNames to TRUE"
            ));
        EnumKeyNames = TRUE;
    }

    if (EnumKeyNames) {
        RegEnumInfo->Flags |= REIF_RETURN_KEYS;
    }
    if (ContainersFirst) {
        RegEnumInfo->Flags |= REIF_CONTAINERS_FIRST;
    }
    if (ValuesFirst) {
        RegEnumInfo->Flags |= REIF_VALUES_FIRST;
    }
    if (DepthFirst) {
        RegEnumInfo->Flags |= REIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        RegEnumInfo->Flags |= REIF_USE_EXCLUSIONS;
    }
    if (ReadValueData) {
        RegEnumInfo->Flags |= REIF_READ_VALUE_DATA;
    }

    RegEnumInfo->MaxSubLevel = min (MaxSubLevel, RegEnumInfo->RegPattern->MaxSubLevel);

    return TRUE;
}


BOOL
pGetRegEnumInfoW (
    OUT     PREGENUMINFOW RegEnumInfo,
    IN      PCWSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData
    )
{
    RegEnumInfo->RegPattern = ObsCreateParsedPatternW (EncodedRegPattern);
    if (!RegEnumInfo->RegPattern) {
        DEBUGMSGW ((DBG_ERROR, "pGetRegEnumInfoW: bad EncodedRegPattern: %s", EncodedRegPattern));
        return FALSE;
    }

    if (RegEnumInfo->RegPattern->ExactRoot) {
        if (!GetNodePatternMinMaxLevelsW (
                RegEnumInfo->RegPattern->ExactRoot, //lint !e64
                NULL,
                &RegEnumInfo->RootLevel,
                NULL
                )) {    //lint !e64
            return FALSE;
        }
    } else {
        RegEnumInfo->RootLevel = 1;
    }

    if (!RegEnumInfo->RegPattern->Leaf) {
        //
        // no value pattern specified; assume only keynames will be returned
        // overwrite caller's setting
        //
        DEBUGMSGW ((
            DBG_REGENUM,
            "pGetRegEnumInfoW: no value pattern specified; forcing EnumDirNames to TRUE"
            ));
        EnumKeyNames = TRUE;
    }

    if (EnumKeyNames) {
        RegEnumInfo->Flags |= REIF_RETURN_KEYS;
    }
    if (ContainersFirst) {
        RegEnumInfo->Flags |= REIF_CONTAINERS_FIRST;
    }
    if (ValuesFirst) {
        RegEnumInfo->Flags |= REIF_VALUES_FIRST;
    }
    if (DepthFirst) {
        RegEnumInfo->Flags |= REIF_DEPTH_FIRST;
    }
    if (UseExclusions) {
        RegEnumInfo->Flags |= REIF_USE_EXCLUSIONS;
    }
    if (ReadValueData) {
        RegEnumInfo->Flags |= REIF_READ_VALUE_DATA;
    }

    RegEnumInfo->MaxSubLevel = min (MaxSubLevel, RegEnumInfo->RegPattern->MaxSubLevel);

    return TRUE;
}


/*++

Routine Description:

    pGetRegNodeInfo retrieves information about a key, using its name

Arguments:

    RegNode - Receives information about this key
    ReadData - Specifies if the data associated with this value should be read

Return Value:

    TRUE if info was successfully read, FALSE otherwise.

--*/

BOOL
pGetRegNodeInfoA (
    IN OUT  PREGNODEA RegNode,
    IN      BOOL ReadData
    )
{
    LONG rc;

    rc = RegQueryInfoKeyA (
            RegNode->KeyHandle,
            NULL,
            NULL,
            NULL,
            &RegNode->SubKeyCount,
            &RegNode->SubKeyLengthMax,
            NULL,
            &RegNode->ValueCount,
            &RegNode->ValueLengthMax,
            ReadData ? &RegNode->ValueDataSizeMax : NULL,
            NULL,
            NULL
            );

    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    if (RegNode->SubKeyCount) {

        if (RegNode->SubKeyLengthMax) {
            //
            // add space for the NULL
            //
            RegNode->SubKeyLengthMax++;
        } else {
            //
            // OS bug
            //
            RegNode->SubKeyLengthMax = MAX_REGISTRY_KEYA;
        }
        RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (MBCHAR));
    }

    if (RegNode->ValueCount) {
        //
        // add space for the NULL
        //
        RegNode->ValueLengthMax++;
        RegNode->ValueName = pAllocateMemory (RegNode->ValueLengthMax * DWSIZEOF (MBCHAR));
        if (ReadData) {
            RegNode->ValueDataSizeMax++;
            RegNode->ValueData = pAllocateMemory (RegNode->ValueDataSizeMax);
        }
        RegNode->Flags |= RNF_VALUENAME_INVALID | RNF_VALUEDATA_INVALID;
    }

    return TRUE;
}

BOOL
pGetRegNodeInfoW (
    IN OUT  PREGNODEW RegNode,
    IN      BOOL ReadData
    )
{
    LONG rc;

    rc = RegQueryInfoKeyW (
            RegNode->KeyHandle,
            NULL,
            NULL,
            NULL,
            &RegNode->SubKeyCount,
            &RegNode->SubKeyLengthMax,
            NULL,
            &RegNode->ValueCount,
            &RegNode->ValueLengthMax,
            ReadData ? &RegNode->ValueDataSizeMax : NULL,
            NULL,
            NULL
            );

    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    if (RegNode->SubKeyCount) {

        if (RegNode->SubKeyLengthMax) {
            //
            // add space for the NULL
            //
            RegNode->SubKeyLengthMax++;
        } else {
            //
            // OS bug
            //
            RegNode->SubKeyLengthMax = MAX_REGISTRY_KEYW;
        }
        RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (WCHAR));
    }

    if (RegNode->ValueCount) {
        //
        // add space for the NULL
        //
        RegNode->ValueLengthMax++;
        RegNode->ValueName = pAllocateMemory (RegNode->ValueLengthMax * DWSIZEOF (WCHAR));
        if (ReadData) {
            RegNode->ValueDataSizeMax++;
            RegNode->ValueData = pAllocateMemory (RegNode->ValueDataSizeMax);
        }
        RegNode->Flags |= RNF_VALUENAME_INVALID | RNF_VALUEDATA_INVALID;
    }

    return TRUE;
}


/*++

Routine Description:

    pGetCurrentRegNode returns the current reg node to be enumerated, based on DepthFirst flag

Arguments:

    RegEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be retrieved, regardless of
                  DepthFirst flag

Return Value:

    The current node if any or NULL if none remaining.

--*/

PREGNODEA
pGetCurrentRegNodeA (
    IN      PREGTREE_ENUMA RegEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &RegEnum->RegNodes;

    if (gb->End - gb->UserIndex < DWSIZEOF (REGNODEA)) {
        return NULL;
    }

    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        return (PREGNODEA)(gb->Buf + gb->End) - 1;
    } else {
        return (PREGNODEA)(gb->Buf + gb->UserIndex);
    }
}

PREGNODEW
pGetCurrentRegNodeW (
    IN      PREGTREE_ENUMW RegEnum,
    IN      BOOL LastCreated
    )
{
    PGROWBUFFER gb = &RegEnum->RegNodes;

    if (gb->End - gb->UserIndex < DWSIZEOF (REGNODEW)) {
        return NULL;
    }

    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        return (PREGNODEW)(gb->Buf + gb->End) - 1;
    } else {
        return (PREGNODEW)(gb->Buf + gb->UserIndex);
    }
}


/*++

Routine Description:

    pDeleteRegNode frees the resources associated with the current reg node and destroys it

Arguments:

    RegEnum - Specifies the context
    LastCreated - Specifies TRUE if the last created node is to be deleted, regardless of
                  DepthFirst flag

Return Value:

    TRUE if there was a node to delete, FALSE if no more nodes

--*/

BOOL
pDeleteRegNodeA (
    IN OUT  PREGTREE_ENUMA RegEnum,
    IN      BOOL LastCreated
    )
{
    PREGNODEA regNode;
    PGROWBUFFER gb = &RegEnum->RegNodes;

    regNode = pGetCurrentRegNodeA (RegEnum, LastCreated);
    if (!regNode) {
        return FALSE;
    }

    if (regNode->KeyHandle) {
        CloseRegKey (regNode->KeyHandle);
    }
    if (regNode->KeyName) {
        FreePathStringExA (g_RegEnumPool, regNode->KeyName);
    }
    if (regNode->SubKeyName) {
        pFreeMemory (regNode->SubKeyName);
    }
    if (regNode->ValueName) {
        pFreeMemory (regNode->ValueName);
    }
    if (regNode->ValueData) {
        pFreeMemory (regNode->ValueData);
    }

    if (RegEnum->LastNode == regNode) {
        RegEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (REGNODEA);
    } else {
        gb->UserIndex += DWSIZEOF (REGNODEA);
        //
        // reset list
        //
        if (gb->Size - gb->End < DWSIZEOF (REGNODEA)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }
    }

    return TRUE;
}

BOOL
pDeleteRegNodeW (
    IN OUT  PREGTREE_ENUMW RegEnum,
    IN      BOOL LastCreated
    )
{
    PREGNODEW regNode;
    PGROWBUFFER gb = &RegEnum->RegNodes;

    regNode = pGetCurrentRegNodeW (RegEnum, LastCreated);
    if (!regNode) {
        return FALSE;
    }

    if (regNode->KeyHandle) {
        CloseRegKey (regNode->KeyHandle);
    }
    if (regNode->KeyName) {
        FreePathStringExW (g_RegEnumPool, regNode->KeyName);
    }
    if (regNode->SubKeyName) {
        pFreeMemory (regNode->SubKeyName);
    }
    if (regNode->ValueName) {
        pFreeMemory (regNode->ValueName);
    }
    if (regNode->ValueData) {
        pFreeMemory (regNode->ValueData);
    }

    if (RegEnum->LastNode == regNode) {
        RegEnum->LastNode = NULL;
    }

    //
    // delete node
    //
    if (LastCreated || (RegEnum->RegEnumInfo.Flags & REIF_DEPTH_FIRST)) {
        gb->End -= DWSIZEOF (REGNODEW);
    } else {
        gb->UserIndex += DWSIZEOF (REGNODEW);
        //
        // reset list
        //
        if (gb->Size - gb->End < DWSIZEOF (REGNODEW)) {
            MoveMemory (gb->Buf, gb->Buf + gb->UserIndex, gb->End - gb->UserIndex);
            gb->End -= gb->UserIndex;
            gb->UserIndex = 0;
        }
    }

    return TRUE;
}


/*++

Routine Description:

    pCreateRegNode creates a new node given a context, a key name or a parent node

Arguments:

    RegEnum - Specifies the context
    KeyName - Specifies the key name of the new node; may be NULL only if ParentNode is not NULL
    ParentNode - Specifies a pointer to the parent node of the new node; a pointer to the node
                 is required because the parent node location in memory may change as a result
                 of the growbuffer changing buffer location when it grows;
                 may be NULL only if KeyName is not;
    Ignore - Receives a meaningful value only if NULL is returned (no node created);
             if TRUE upon return, the failure of node creation should be ignored

Return Value:

    A pointer to the new node or NULL if no node was created

--*/

PREGNODEA
pCreateRegNodeA (
    IN OUT  PREGTREE_ENUMA RegEnum,
    IN      PCSTR KeyName,              OPTIONAL
    IN      PREGNODEA* ParentNode,      OPTIONAL
    IN      PBOOL Ignore                OPTIONAL
    )
{
    PREGNODEA newNode;
    PSTR newKeyName;
    REGSAM prevMode;
    PSEGMENTA FirstSegment;
    LONG offset = 0;

    if (KeyName) {
        newKeyName = DuplicateTextExA (g_RegEnumPool, KeyName, 0, NULL);
    } else {
        MYASSERT (ParentNode);
        newKeyName = JoinPathsInPoolExA ((
                        g_RegEnumPool,
                        (*ParentNode)->KeyName,
                        (*ParentNode)->SubKeyName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        FirstSegment = RegEnum->RegEnumInfo.RegPattern->NodePattern->Pattern->Segment;
        if (FirstSegment->Type == SEGMENTTYPE_EXACTMATCH &&
            !StringIMatchByteCountA (
                    FirstSegment->Exact.LowerCasePhrase,
                    newKeyName,
                    FirstSegment->Exact.PhraseBytes
                    )) {
            DEBUGMSGA ((
                DBG_REGENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newKeyName
                ));

            FreeTextExA (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
        //
        // look if this key and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2A (ELT_REGISTRY, newKeyName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {

            DEBUGMSGA ((
                DBG_REGENUM,
                "Skipping tree %s\\%s because it's excluded",
                newKeyName,
                RegEnum->RegEnumInfo.RegPattern->Leaf
                ));

            FreeTextExA (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PREGNODEA) GbGrow (&RegEnum->RegNodes, DWSIZEOF (REGNODEA));
    if (!newNode) {
        FreeTextExA (g_RegEnumPool, newKeyName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PREGNODEA)(RegEnum->RegNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (REGNODEA));

    newNode->KeyName = newKeyName;

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);

    if (ParentNode) {
        newNode->KeyHandle = OpenRegKeyA ((*ParentNode)->KeyHandle, (*ParentNode)->SubKeyName);
        newNode->Flags |= RNF_RETURN_KEYS;
    } else {
        newNode->KeyHandle = OpenRegKeyStrA (newNode->KeyName);
        if ((RegEnum->RegEnumInfo.RegPattern->Leaf == NULL) &&
            (RegEnum->RegEnumInfo.RegPattern->ExactRoot) &&
            (!WildCharsPatternA (RegEnum->RegEnumInfo.RegPattern->NodePattern))
            ) {
            newNode->Flags |= DNF_RETURN_DIRNAME;
        }
    }

    SetRegOpenAccessMode (prevMode);

    if (!newNode->KeyHandle) {
        DEBUGMSGA ((
            DBG_REGENUM,
            "pCreateRegNodeA: Cannot open registry key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    if (!pGetRegNodeInfoA (newNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
        DEBUGMSGA ((
            DBG_REGENUM,
            "pCreateRegNodeA: Cannot get info for key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    newNode->EnumState = RNS_ENUM_INIT;

    if ((RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternA (RegEnum->RegEnumInfo.RegPattern->NodePattern, newKeyName)
        ) {
        newNode->Flags |= RNF_KEYNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (RegEnum->RegEnumInfo.CallbackOnError) {
            *Ignore = (*RegEnum->RegEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    if (newNode) {
        pDeleteRegNodeA (RegEnum, TRUE);
    }
    return NULL;
}

PREGNODEW
pCreateRegNodeW (
    IN OUT  PREGTREE_ENUMW RegEnum,
    IN      PCWSTR KeyName,             OPTIONAL
    IN      PREGNODEW* ParentNode,      OPTIONAL
    OUT     PBOOL Ignore                OPTIONAL
    )
{
    PREGNODEW newNode;
    PWSTR newKeyName;
    REGSAM prevMode;
    PSEGMENTW FirstSegment;
    LONG offset = 0;

    if (KeyName) {
        newKeyName = DuplicateTextExW (g_RegEnumPool, KeyName, 0, NULL);
    } else {
        MYASSERT (ParentNode);
        newKeyName = JoinPathsInPoolExW ((
                        g_RegEnumPool,
                        (*ParentNode)->KeyName,
                        (*ParentNode)->SubKeyName,
                        NULL
                        ));

        //
        // check if this starting path may match the pattern before continuing
        //
        FirstSegment = RegEnum->RegEnumInfo.RegPattern->NodePattern->Pattern->Segment;
        if (FirstSegment->Type == SEGMENTTYPE_EXACTMATCH &&
            !StringIMatchByteCountW (
                    FirstSegment->Exact.LowerCasePhrase,
                    newKeyName,
                    FirstSegment->Exact.PhraseBytes
                    )) {    //lint !e64
            DEBUGMSGW ((
                DBG_REGENUM,
                "Skipping tree %s\\* because it cannot match the pattern",
                newKeyName
                ));

            FreeTextExW (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
        //
        // look if this key and the whole subtree are excluded; if so, soft block creation of node
        //
        if (ElIsTreeExcluded2W (ELT_REGISTRY, newKeyName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {   //lint !e64

            DEBUGMSGW ((
                DBG_REGENUM,
                "Skipping tree %s\\%s because it's excluded",
                newKeyName,
                RegEnum->RegEnumInfo.RegPattern->Leaf
                ));

            FreeTextExW (g_RegEnumPool, newKeyName);

            if (Ignore) {
                *Ignore = TRUE;
            }
            return NULL;
        }
    }

    if (ParentNode) {
        //
        // remember current offset
        //
        offset = (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf);
    }
    //
    // allocate space for the new node in the growbuffer
    //
    newNode = (PREGNODEW) GbGrow (&RegEnum->RegNodes, DWSIZEOF (REGNODEW));
    if (!newNode) {
        FreeTextExW (g_RegEnumPool, newKeyName);
        goto fail;
    }

    if (ParentNode) {
        //
        // check if the buffer moved
        //
        if (offset != (LONG)((PBYTE)*ParentNode - RegEnum->RegNodes.Buf)) {
            //
            // adjust the parent position
            //
            *ParentNode = (PREGNODEW)(RegEnum->RegNodes.Buf + offset);
        }
    }

    //
    // initialize the newly created node
    //
    ZeroMemory (newNode, DWSIZEOF (REGNODEW));

    newNode->KeyName = newKeyName;

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);

    if (ParentNode) {
        newNode->KeyHandle = OpenRegKeyW ((*ParentNode)->KeyHandle, (*ParentNode)->SubKeyName);
        newNode->Flags |= RNF_RETURN_KEYS;
    } else {
        newNode->KeyHandle = OpenRegKeyStrW (newNode->KeyName);
        if ((RegEnum->RegEnumInfo.RegPattern->Leaf == NULL) &&
            (RegEnum->RegEnumInfo.RegPattern->ExactRoot) &&
            (!WildCharsPatternW (RegEnum->RegEnumInfo.RegPattern->NodePattern))
            ) {
            newNode->Flags |= DNF_RETURN_DIRNAME;
        }
    }

    SetRegOpenAccessMode (prevMode);

    if (!newNode->KeyHandle) {
        DEBUGMSGW ((
            DBG_REGENUM,
            "pCreateRegNodeW: Cannot open registry key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    if (!pGetRegNodeInfoW (newNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
        DEBUGMSGW ((
            DBG_REGENUM,
            "pCreateRegNodeW: Cannot get info for key: %s; rc=%lu",
            newNode->KeyName,
            GetLastError()
            ));
        goto fail;
    }

    newNode->EnumState = RNS_ENUM_INIT;

    if ((RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTNODE | OBSPF_NODEISROOTPLUSSTAR)) ||
        TestParsedPatternW (RegEnum->RegEnumInfo.RegPattern->NodePattern, newKeyName)
        ) {
        newNode->Flags |= RNF_KEYNAME_MATCHES;
    }

    if (ParentNode) {
        newNode->SubLevel = (*ParentNode)->SubLevel + 1;
    } else {
        newNode->SubLevel = 0;
    }

    return newNode;

fail:
    if (Ignore) {
        if (RegEnum->RegEnumInfo.CallbackOnError) {
            *Ignore = (*RegEnum->RegEnumInfo.CallbackOnError)(newNode);
        } else {
            *Ignore = FALSE;
        }
    }
    if (newNode) {
        pDeleteRegNodeW (RegEnum, TRUE);
    }
    return NULL;
}


/*++

Routine Description:

    pEnumFirstRegRoot enumerates the first root that matches caller's conditions

Arguments:

    RegEnum - Specifies the context; receives updated info

Return Value:

    TRUE if a root node was created; FALSE if not

--*/

BOOL
pEnumFirstRegRootA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    PCSTR root;
    BOOL ignore;

    root = RegEnum->RegEnumInfo.RegPattern->ExactRoot;

    if (root) {

        if (pCreateRegNodeA (RegEnum, root, NULL, NULL)) {
            RegEnum->RootState = RES_ROOT_DONE;
            return TRUE;
        }
    } else {

        RegEnum->RootEnum = pAllocateMemory (DWSIZEOF (REGROOT_ENUMA));

        if (!EnumFirstRegRootA (RegEnum->RootEnum)) {
            return FALSE;
        }

        do {
            if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2A (ELT_REGISTRY, RegEnum->RootEnum->RegRootName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {
                    DEBUGMSGA ((DBG_REGENUM, "pEnumFirstRegRootA: Root is excluded: %s", RegEnum->RootEnum->RegRootName));
                    continue;
                }
            }
            if (!pCreateRegNodeA (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            RegEnum->RootState = RES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextRegRootA (RegEnum->RootEnum));

        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }

    return FALSE;
}

BOOL
pEnumFirstRegRootW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    PCWSTR root;
    BOOL ignore;

    root = RegEnum->RegEnumInfo.RegPattern->ExactRoot;  //lint !e64

    if (root) {

        if (pCreateRegNodeW (RegEnum, root, NULL, NULL)) {
            RegEnum->RootState = RES_ROOT_DONE;
            return TRUE;
        }
    } else {

        RegEnum->RootEnum = pAllocateMemory (DWSIZEOF (REGROOT_ENUMW));

        if (!EnumFirstRegRootW (RegEnum->RootEnum)) {
            return FALSE;
        }

        do {
            if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                if (ElIsTreeExcluded2W (ELT_REGISTRY, RegEnum->RootEnum->RegRootName, RegEnum->RegEnumInfo.RegPattern->Leaf)) {   //lint !e64
                    DEBUGMSGW ((DBG_REGENUM, "pEnumFirstRegRootW: Root is excluded: %s", RegEnum->RootEnum->RegRootName));
                    continue;
                }
            }
            if (!pCreateRegNodeW (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
                if (ignore) {
                    continue;
                }
                break;
            }
            RegEnum->RootState = RES_ROOT_NEXT;
            return TRUE;
        } while (EnumNextRegRootW (RegEnum->RootEnum));

        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }

    return FALSE;
}


/*++

Routine Description:

    pEnumNextRegRoot enumerates the next root that matches caller's conditions

Arguments:

    RegEnum - Specifies the context; receives updated info

Return Value:

    TRUE if a root node was created; FALSE if not

--*/

BOOL
pEnumNextRegRootA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    BOOL ignore;

    while (EnumNextRegRootA (RegEnum->RootEnum)) {
        if (pCreateRegNodeA (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    RegEnum->RootState = RES_ROOT_DONE;

    return FALSE;
}

BOOL
pEnumNextRegRootW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    BOOL ignore;

    while (EnumNextRegRootW (RegEnum->RootEnum)) {
        if (pCreateRegNodeW (RegEnum, RegEnum->RootEnum->RegRootName, NULL, &ignore)) {
            return TRUE;
        }
        if (!ignore) {
            break;
        }
    }

    RegEnum->RootState = RES_ROOT_DONE;

    return FALSE;
}


/*++

Routine Description:

    pEnumNextValue enumerates the next value that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info
    ReadData - Specifies if the data associated with this value should be read

Return Value:

    TRUE if a new value was found; FALSE if not

--*/

BOOL
pEnumNextValueA (
    IN OUT  PREGNODEA RegNode,
    IN      BOOL ReadData
    )
{
    LONG rc;
    DWORD valueNameLength;

    if (RegNode->ValueIndex == 0) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    RegNode->ValueIndex--;

    valueNameLength = RegNode->ValueLengthMax;
    if (ReadData) {
        RegNode->ValueDataSize = RegNode->ValueDataSizeMax;
    }

    rc = RegEnumValueA (
            RegNode->KeyHandle,
            RegNode->ValueIndex,
            RegNode->ValueName,
            &valueNameLength,
            NULL,
            &RegNode->ValueType,
            ReadData ? RegNode->ValueData : NULL,
            ReadData ? &RegNode->ValueDataSize : NULL
            );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc == ERROR_NO_MORE_ITEMS ? ERROR_SUCCESS : (DWORD)rc);
        return FALSE;
    }

    RegNode->Flags &= ~RNF_VALUENAME_INVALID;
    if (ReadData) {
        RegNode->Flags &= ~RNF_VALUEDATA_INVALID;
    }

    return TRUE;
}

BOOL
pEnumNextValueW (
    IN OUT  PREGNODEW RegNode,
    IN      BOOL ReadData
    )
{
    LONG rc;
    DWORD valueNameLength;

    if (RegNode->ValueIndex == 0) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    RegNode->ValueIndex--;

    valueNameLength = RegNode->ValueLengthMax;
    if (ReadData) {
        RegNode->ValueDataSize = RegNode->ValueDataSizeMax;
    }

    rc = RegEnumValueW (
            RegNode->KeyHandle,
            RegNode->ValueIndex,
            RegNode->ValueName,
            &valueNameLength,
            NULL,
            &RegNode->ValueType,
            ReadData ? RegNode->ValueData : NULL,
            ReadData ? &RegNode->ValueDataSize : NULL
            );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc == ERROR_NO_MORE_ITEMS ? ERROR_SUCCESS : (DWORD)rc);
        return FALSE;
    }

    RegNode->Flags &= ~RNF_VALUENAME_INVALID;
    if (ReadData) {
        RegNode->Flags &= ~RNF_VALUEDATA_INVALID;
    }

    return TRUE;
}


/*++

Routine Description:

    pEnumFirstValue enumerates the first value that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info
    ReadData - Specifies if the data associated with this value should be read

Return Value:

    TRUE if a first value was found; FALSE if not

--*/

BOOL
pEnumFirstValueA (
    IN OUT  PREGNODEA RegNode,
    IN      BOOL ReadData
    )
{
    RegNode->ValueIndex = RegNode->ValueCount;
    return pEnumNextValueA (RegNode, ReadData);
}

BOOL
pEnumFirstValueW (
    OUT     PREGNODEW RegNode,
    IN      BOOL ReadData
    )
{
    RegNode->ValueIndex = RegNode->ValueCount;
    return pEnumNextValueW (RegNode, ReadData);
}


/*++

Routine Description:

    pEnumNextSubKey enumerates the next subkey that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a new subkey was found; FALSE if not

--*/

BOOL
pEnumNextSubKeyA (
    IN OUT  PREGNODEA RegNode
    )
{
    LONG rc;

    RegNode->SubKeyIndex++;

    do {
        rc = RegEnumKeyA (
                RegNode->KeyHandle,
                RegNode->SubKeyIndex - 1,
                RegNode->SubKeyName,
                RegNode->SubKeyLengthMax
                );

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }

        if (rc == ERROR_MORE_DATA) {
            //
            // double the current buffer size
            //
            MYASSERT (RegNode->SubKeyName);
            pFreeMemory (RegNode->SubKeyName);
            RegNode->SubKeyLengthMax *= 2;
            RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (MBCHAR));
        }

    } while (rc == ERROR_MORE_DATA);

    return rc == ERROR_SUCCESS;
}

BOOL
pEnumNextSubKeyW (
    IN OUT  PREGNODEW RegNode
    )
{
    LONG rc;

    RegNode->SubKeyIndex++;

    do {
        rc = RegEnumKeyW (
                RegNode->KeyHandle,
                RegNode->SubKeyIndex - 1,
                RegNode->SubKeyName,
                RegNode->SubKeyLengthMax
                );

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }

        if (rc == ERROR_MORE_DATA) {
            //
            // double the current buffer size
            //
            MYASSERT (RegNode->SubKeyName);
            pFreeMemory (RegNode->SubKeyName);
            RegNode->SubKeyLengthMax *= 2;
            RegNode->SubKeyName = pAllocateMemory (RegNode->SubKeyLengthMax * DWSIZEOF (WCHAR));
        }

    } while (rc == ERROR_MORE_DATA);

    return rc == ERROR_SUCCESS;
}


/*++

Routine Description:

    pEnumFirstSubKey enumerates the first subkey that matches caller's conditions

Arguments:

    RegNode - Specifies the node and the current context; receives updated info

Return Value:

    TRUE if a first subkey was found; FALSE if not

--*/

BOOL
pEnumFirstSubKeyA (
    IN OUT  PREGNODEA RegNode
    )
{
    RegNode->SubKeyIndex = 0;
    return pEnumNextSubKeyA (RegNode);
}

BOOL
pEnumFirstSubKeyW (
    OUT     PREGNODEW RegNode
    )
{
    RegNode->SubKeyIndex = 0;
    return pEnumNextSubKeyW (RegNode);
}


/*++

Routine Description:

    pEnumNextRegObjectInTree is a private function that enumerates the next node matching
    the specified criteria; it's implemented as a state machine that travels the keys/values
    as specified the the caller; it doesn't check if they actually match the patterns

Arguments:

    RegEnum - Specifies the current enum context; receives updated info
    CurrentKeyNode - Receives the key node that is currently processed, if success is returned

Return Value:

    TRUE if a next match was found; FALSE if no more keys/values match

--*/

BOOL
pEnumNextRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum,
    OUT     PREGNODEA* CurrentKeyNode
    )
{
    PREGNODEA currentNode;
    PREGNODEA newNode;
    PCSTR valueName;
    BOOL ignore;
    LONG rc;

    while ((currentNode = pGetCurrentRegNodeA (RegEnum, FALSE)) != NULL) {

        *CurrentKeyNode = currentNode;

        switch (currentNode->EnumState) {

        case RNS_VALUE_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTLEAF) {

                BOOL readData = RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA;

                valueName = RegEnum->RegEnumInfo.RegPattern->Leaf;
                MYASSERT (valueName);

                currentNode->EnumState = RNS_VALUE_DONE;
                currentNode->ValueDataSize = currentNode->ValueDataSizeMax;

                rc = RegQueryValueExA (
                        currentNode->KeyHandle,
                        valueName,
                        NULL,
                        &currentNode->ValueType,
                        readData ? currentNode->ValueData : NULL,
                        readData ? &currentNode->ValueDataSize : NULL
                        );
                if (rc == ERROR_SUCCESS) {
                    if (SizeOfStringA (valueName) <=
                        currentNode->ValueLengthMax * DWSIZEOF (MBCHAR)
                        ) {
                        StringCopyA (currentNode->ValueName, valueName);
                        currentNode->Flags &= ~RNF_VALUENAME_INVALID;
                        if (readData) {
                            currentNode->Flags &= ~RNF_VALUEDATA_INVALID;
                        }
                        return TRUE;
                    }
                }

            } else {

                if (pEnumFirstValueA (currentNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
                    currentNode->EnumState = RNS_VALUE_NEXT;
                    return TRUE;
                }
                currentNode->EnumState = RNS_VALUE_DONE;
            }
            break;

        case RNS_VALUE_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (pEnumNextValueA (currentNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
                return TRUE;
            }

            //
            // no more values for this one, go to the next
            //
            currentNode->EnumState = RNS_VALUE_DONE;
            //
            // fall through
            //
        case RNS_VALUE_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) || !currentNode->SubKeyCount) {
                //
                // done with this node
                //
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }
            //
            // now enum subkeys
            //
            currentNode->EnumState = RNS_SUBKEY_FIRST;
            //
            // fall through
            //
        case RNS_SUBKEY_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            //
            // check new node's level; if too large, quit
            //
            if (currentNode->SubLevel >= RegEnum->RegEnumInfo.MaxSubLevel) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (!pEnumFirstSubKeyA (currentNode)) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            currentNode->EnumState = RNS_SUBKEY_NEXT;
            newNode = pCreateRegNodeA (RegEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // now look at the new node
                //
                if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                    if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                        newNode->Flags &= ~RNF_RETURN_KEYS;
                        *CurrentKeyNode = newNode;
                        return TRUE;
                    }
                }
                break;
            }
            if (!ignore) {
                //
                // abort enum
                //
                DEBUGMSGA ((
                    DBG_ERROR,
                    "Error encountered enumerating registry; aborting enumeration"
                    ));
                RegEnum->RootState = RES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case RNS_SUBKEY_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (pEnumNextSubKeyA (currentNode)) {
                newNode = pCreateRegNodeA (RegEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                        if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                            newNode->Flags &= ~RNF_RETURN_KEYS;
                            *CurrentKeyNode = newNode;
                            return TRUE;
                        }
                    }
                    break;
                }
                if (!ignore) {
                    //
                    // abort enum
                    //
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Error encountered enumerating registry; aborting enumeration"
                        ));
                    RegEnum->RootState = RES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subkey
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = RNS_SUBKEY_DONE;
            //
            // fall through
            //
        case RNS_SUBKEY_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // now enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = RNS_ENUM_DONE;
            //
            // fall through
            //
        case RNS_ENUM_DONE:

            if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                if (!(RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST)) {
                    if (currentNode->Flags & RNF_RETURN_KEYS) {
                        currentNode->Flags &= ~RNF_RETURN_KEYS;
                        //
                        // set additional data before returning
                        //
                        if (currentNode->ValueName) {
                            pFreeMemory (currentNode->ValueName);
                            currentNode->ValueName = NULL;
                            currentNode->Flags |= RNF_VALUENAME_INVALID;
                        }
                        return TRUE;
                    }
                }
            }
            pDeleteRegNodeA (RegEnum, FALSE);
            break;

        case RNS_ENUM_INIT:

            if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                    if (currentNode->Flags & RNF_RETURN_KEYS) {
                        currentNode->Flags &= ~RNF_RETURN_KEYS;
                        return TRUE;
                    }
                }
            }

            if (RegEnum->ControlFlags & RECF_SKIPKEY) {
                RegEnum->ControlFlags &= ~RECF_SKIPKEY;
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }

            if ((RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            if (currentNode->SubKeyCount) {
                //
                // enum keys
                //
                if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTNODE) {
                    currentNode->EnumState = RNS_SUBKEY_DONE;
                } else {
                    currentNode->EnumState = RNS_SUBKEY_FIRST;
                }
                break;
            }
            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            currentNode->EnumState = RNS_ENUM_DONE;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}

BOOL
pEnumNextRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum,
    OUT     PREGNODEW* CurrentKeyNode
    )
{
    PREGNODEW currentNode;
    PREGNODEW newNode;
    PCWSTR valueName;
    BOOL ignore;
    LONG rc;

    while ((currentNode = pGetCurrentRegNodeW (RegEnum, FALSE)) != NULL) {

        *CurrentKeyNode = currentNode;

        switch (currentNode->EnumState) {

        case RNS_VALUE_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTLEAF) {

                BOOL readData = RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA;

                valueName = RegEnum->RegEnumInfo.RegPattern->Leaf;
                MYASSERT (valueName);

                currentNode->EnumState = RNS_VALUE_DONE;
                currentNode->ValueDataSize = currentNode->ValueDataSizeMax;

                rc = RegQueryValueExW (
                        currentNode->KeyHandle,
                        valueName,
                        NULL,
                        &currentNode->ValueType,
                        readData ? currentNode->ValueData : NULL,
                        readData ? &currentNode->ValueDataSize : NULL
                        );
                if (rc == ERROR_SUCCESS) {
                    if (SizeOfStringW (valueName) <=
                        currentNode->ValueLengthMax * DWSIZEOF (WCHAR)
                        ) {
                        StringCopyW (currentNode->ValueName, valueName);
                        currentNode->Flags &= ~RNF_VALUENAME_INVALID;
                        if (readData) {
                            currentNode->Flags &= ~RNF_VALUEDATA_INVALID;
                        }
                        return TRUE;
                    }
                }

            } else {

                if (pEnumFirstValueW (currentNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
                    currentNode->EnumState = RNS_VALUE_NEXT;
                    return TRUE;
                }
                currentNode->EnumState = RNS_VALUE_DONE;
            }
            break;

        case RNS_VALUE_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPVALUES) {
                RegEnum->ControlFlags &= ~RECF_SKIPVALUES;
                currentNode->EnumState = RNS_VALUE_DONE;
                break;
            }

            if (pEnumNextValueW (currentNode, RegEnum->RegEnumInfo.Flags & REIF_READ_VALUE_DATA)) {
                return TRUE;
            }
            //
            // no more values for this one, go to the next
            //
            currentNode->EnumState = RNS_VALUE_DONE;
            //
            // fall through
            //
        case RNS_VALUE_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) || !currentNode->SubKeyCount) {
                //
                // done with this node
                //
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }
            //
            // now enum subkeys
            //
            currentNode->EnumState = RNS_SUBKEY_FIRST;
            //
            // fall through
            //
        case RNS_SUBKEY_FIRST:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            //
            // check new node's level; if too large, quit
            //
            if (currentNode->SubLevel >= RegEnum->RegEnumInfo.MaxSubLevel) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (!pEnumFirstSubKeyW (currentNode)) {
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            currentNode->EnumState = RNS_SUBKEY_NEXT;
            newNode = pCreateRegNodeW (RegEnum, NULL, &currentNode, &ignore);
            if (newNode) {
                //
                // now look at the new node
                //
                if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                    if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                        newNode->Flags &= ~RNF_RETURN_KEYS;
                        *CurrentKeyNode = newNode;
                        return TRUE;
                    }
                }
                break;
            }
            if (!ignore) {
                //
                // abort enum
                //
                DEBUGMSGW ((
                    DBG_ERROR,
                    "Error encountered enumerating registry; aborting enumeration"
                    ));
                RegEnum->RootState = RES_ROOT_DONE;
                return FALSE;
            }
            //
            // fall through
            //
        case RNS_SUBKEY_NEXT:

            if (RegEnum->ControlFlags & RECF_SKIPSUBKEYS) {
                RegEnum->ControlFlags &= ~RECF_SKIPSUBKEYS;
                currentNode->EnumState = RNS_SUBKEY_DONE;
                break;
            }

            if (pEnumNextSubKeyW (currentNode)) {
                newNode = pCreateRegNodeW (RegEnum, NULL, &currentNode, &ignore);
                if (newNode) {
                    //
                    // look at the new node first
                    //
                    if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                        if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                            newNode->Flags &= ~RNF_RETURN_KEYS;
                            *CurrentKeyNode = newNode;
                            return TRUE;
                        }
                    }
                    break;
                }
                if (!ignore) {
                    //
                    // abort enum
                    //
                    DEBUGMSGW ((
                        DBG_ERROR,
                        "Error encountered enumerating registry; aborting enumeration"
                        ));
                    RegEnum->RootState = RES_ROOT_DONE;
                    return FALSE;
                }
                //
                // continue with next subkey
                //
                break;
            }
            //
            // this node is done
            //
            currentNode->EnumState = RNS_SUBKEY_DONE;
            //
            // fall through
            //
        case RNS_SUBKEY_DONE:

            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // now enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            //
            // done with this node
            //
            currentNode->EnumState = RNS_ENUM_DONE;
            //
            // fall through
            //
        case RNS_ENUM_DONE:

            if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                if (!(RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST)) {
                    if (currentNode->Flags & RNF_RETURN_KEYS) {
                        currentNode->Flags &= ~RNF_RETURN_KEYS;
                        //
                        // set additional data before returning
                        //
                        if (currentNode->ValueName) {
                            pFreeMemory (currentNode->ValueName);
                            currentNode->ValueName = NULL;
                            currentNode->Flags |= RNF_VALUENAME_INVALID;
                        }
                        return TRUE;
                    }
                }
            }
            pDeleteRegNodeW (RegEnum, FALSE);
            break;

        case RNS_ENUM_INIT:

            if (RegEnum->RegEnumInfo.Flags & REIF_RETURN_KEYS) {
                if (RegEnum->RegEnumInfo.Flags & REIF_CONTAINERS_FIRST) {
                    if (currentNode->Flags & RNF_RETURN_KEYS) {
                        currentNode->Flags &= ~RNF_RETURN_KEYS;
                        return TRUE;
                    }
                }
            }

            if (RegEnum->ControlFlags & RECF_SKIPKEY) {
                RegEnum->ControlFlags &= ~RECF_SKIPKEY;
                currentNode->EnumState = RNS_ENUM_DONE;
                break;
            }

            if ((RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            if (currentNode->SubKeyCount) {
                //
                // enum keys
                //
                if (RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_EXACTNODE) {
                    currentNode->EnumState = RNS_SUBKEY_DONE;
                } else {
                    currentNode->EnumState = RNS_SUBKEY_FIRST;
                }
                break;
            }
            if (!(RegEnum->RegEnumInfo.Flags & REIF_VALUES_FIRST) && currentNode->ValueCount) {
                //
                // enum values
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & OBSPF_NOLEAF)) {
                    currentNode->EnumState = RNS_VALUE_FIRST;
                    break;
                }
            }
            currentNode->EnumState = RNS_ENUM_DONE;
            break;

        default:
            MYASSERT (FALSE);   //lint !e506
        }
    }

    return FALSE;
}


/*++

Routine Description:

    EnumFirstRegObjectInTreeEx enumerates registry keys, and optionally values, that match the
    specified criteria

Arguments:

    RegEnum - Receives the enum context info; this will be used in subsequent calls to
              EnumNextRegObjectInTree
    EncodedRegPattern - Specifies the encoded key pattern (encoded as defined by the
                        ParsedPattern functions)
    EncodedValuePattern - Specifies the encoded value pattern (encoded as defined by the
                          ParsedPattern functions); optional; NULL means no values
                          should be returned (only look for keys)
    EnumKeyNames - Specifies TRUE if key names should be returned during the enumeration
                   (if they match the pattern); a key name is returned before any of its
                   subkeys or values
    ContainersFirst - Specifies TRUE if keys should be returned before any of its
                      values or subkeys; used only if EnumKeyNames is TRUE
    ValuesFirst - Specifies TRUE if a key's values should be returned before key's subkeys;
                  this parameter decides the enum order between values and subkeys
                  for each key
    DepthFirst - Specifies TRUE if the current subkey of any key should be fully enumerated
                 before going to the next subkey; this parameter decides if the tree
                 traversal is depth-first (TRUE) or width-first (FALSE)
    MaxSubLevel - Specifies the maximum sub-level of a key that is to be enumerated,
                  relative to the root; if 0, only the root is enumerated;
                  if -1, all sub-levels are enumerated
    UseExclusions - Specifies TRUE if exclusion APIs should be used to determine if certain
                    keys/values are excluded from enumeration; this slows down the speed
    ReadValueData - Specifies TRUE if data associated with values should also be returned
    CallbackOnError - Specifies a pointer to a callback function that will be called during
                      enumeration if an error occurs; if the callback is defined and it
                      returns FALSE, the enumeration is aborted, otherwise it will continue
                      ignoring the error

Return Value:

    TRUE if a first match is found.
    FALSE otherwise.

--*/

BOOL
EnumFirstRegObjectInTreeExA (
    OUT     PREGTREE_ENUMA RegEnum,
    IN      PCSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData,
    IN      RPE_ERROR_CALLBACKA CallbackOnError     OPTIONAL
    )
{
    MYASSERT (RegEnum && EncodedRegPattern && *EncodedRegPattern);

    ZeroMemory (RegEnum, DWSIZEOF (REGTREE_ENUMA));  //lint !e613 !e668

    //
    // first try to get reg enum info in internal format
    //
    if (!pGetRegEnumInfoA (
            &RegEnum->RegEnumInfo,
            EncodedRegPattern,
            EnumKeyNames,
            ContainersFirst,
            ValuesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions,
            ReadValueData
            )) {    //lint !e613
        AbortRegObjectInTreeEnumA (RegEnum);
        return FALSE;
    }
    if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) { //lint !e613
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedA (ELT_REGISTRY, RegEnum->RegEnumInfo.RegPattern)) {    //lint !e613
            DEBUGMSGA ((
                DBG_REGENUM,
                "EnumFirstRegObjectInTreeExA: Root is excluded: %s",
                EncodedRegPattern
                ));
            AbortRegObjectInTreeEnumA (RegEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstRegRootA (RegEnum)) {
        AbortRegObjectInTreeEnumA (RegEnum);
        return FALSE;
    }

    /*lint -e(613)*/RegEnum->RegEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextRegObjectInTreeA (RegEnum);
}

BOOL
EnumFirstRegObjectInTreeExW (
    OUT     PREGTREE_ENUMW RegEnum,
    IN      PCWSTR EncodedRegPattern,
    IN      BOOL EnumKeyNames,
    IN      BOOL ContainersFirst,
    IN      BOOL ValuesFirst,
    IN      BOOL DepthFirst,
    IN      DWORD MaxSubLevel,
    IN      BOOL UseExclusions,
    IN      BOOL ReadValueData,
    IN      RPE_ERROR_CALLBACKW CallbackOnError     OPTIONAL
    )
{
    MYASSERT (RegEnum && EncodedRegPattern && *EncodedRegPattern);

    ZeroMemory (RegEnum, DWSIZEOF (REGTREE_ENUMW));  //lint !e613 !e668

    //
    // first try to get reg enum info in internal format
    //
    if (!pGetRegEnumInfoW (
            &RegEnum->RegEnumInfo,
            EncodedRegPattern,
            EnumKeyNames,
            ContainersFirst,
            ValuesFirst,
            DepthFirst,
            MaxSubLevel,
            UseExclusions,
            ReadValueData
            )) {    //lint !e613
        AbortRegObjectInTreeEnumW (RegEnum);
        return FALSE;
    }
    if (/*lint -e(613)*/RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
        //
        // next check if the starting key is in an excluded tree
        //
        if (ElIsObsPatternExcludedW (ELT_REGISTRY, /*lint -e(613)*/RegEnum->RegEnumInfo.RegPattern)) {
            DEBUGMSGW ((
                DBG_REGENUM,
                "EnumFirstRegObjectInTreeExW: Root is excluded: %s",
                EncodedRegPattern
                ));
            AbortRegObjectInTreeEnumW (RegEnum);
            return FALSE;
        }
    }

    if (!pEnumFirstRegRootW (RegEnum)) {
        AbortRegObjectInTreeEnumW (RegEnum);
        return FALSE;
    }

    /*lint -e(613)*/RegEnum->RegEnumInfo.CallbackOnError = CallbackOnError;

    return EnumNextRegObjectInTreeW (RegEnum);
}


/*++

Routine Description:

    EnumNextRegObjectInTree enumerates the next node matching the criteria specified in
    RegEnum; this is filled on the call to EnumFirstRegObjectInTreeEx;

Arguments:

    RegEnum - Specifies the current enum context; receives updated info

Return Value:

    TRUE if a next match was found; FALSE if no more keys/values match

--*/

BOOL
EnumNextRegObjectInTreeA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    PREGNODEA currentNode;
    BOOL success;

    MYASSERT (RegEnum);

    do {
        if (RegEnum->EncodedFullName) {
            ObsFreeA (RegEnum->EncodedFullName);
            RegEnum->EncodedFullName = NULL;
        }

        while (TRUE) {

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = '\\';
                RegEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextRegObjectInTreeA (RegEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->KeyName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & RNF_KEYNAME_MATCHES)) {   //lint !e613
                continue;
            }

            RegEnum->CurrentKeyHandle = /*lint -e(613)*/currentNode->KeyHandle;
            RegEnum->CurrentLevel = RegEnum->RegEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            if ((!currentNode->ValueName) || (currentNode->Flags & RNF_VALUENAME_INVALID)) {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->LastWackPtr = _mbsrchr (RegEnum->Location, '\\');
                if (!RegEnum->LastWackPtr) {
                    RegEnum->Name = RegEnum->Location;
                } else {
                    RegEnum->Name = _mbsinc (RegEnum->LastWackPtr);
                    if (!RegEnum->Name) {
                        RegEnum->Name = RegEnum->Location;
                    }
                }
                RegEnum->CurrentValueData = NULL;
                RegEnum->CurrentValueDataSize = 0;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;
                RegEnum->Attributes = REG_ATTRIBUTE_KEY;

                //
                // prepare full path buffer
                //
                StringCopyA (RegEnum->NativeFullName, RegEnum->Location);
                RegEnum->LastNode = currentNode;
                RegEnum->RegNameAppendPos = NULL;

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2A (ELT_REGISTRY, RegEnum->Location, NULL)) {
                        DEBUGMSGA ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s was found, but it's excluded",
                            RegEnum->Location
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExA (
                                                    RegEnum->Location,
                                                    NULL,
                                                    TRUE
                                                    );
            } else {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->Name = /*lint -e(613)*/currentNode->ValueName;
                RegEnum->CurrentValueData = /*lint -e(613)*/currentNode->ValueData;
                RegEnum->CurrentValueDataSize = currentNode->ValueDataSize;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;

                if (RegEnum->LastNode != currentNode) {
                    RegEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    RegEnum->NativeFullName[0] = 0;
                    RegEnum->RegNameAppendPos = StringCatA (RegEnum->NativeFullName, RegEnum->Location);
                    RegEnum->RegNameAppendPos = StringCatA (RegEnum->RegNameAppendPos, "\\[");
                } else if (!RegEnum->RegNameAppendPos) {
                    RegEnum->RegNameAppendPos = GetEndOfStringA (RegEnum->NativeFullName);
                    RegEnum->RegNameAppendPos = StringCatA (RegEnum->RegNameAppendPos, "\\[");
                }

                MYASSERT (RegEnum->Name);

                if ((RegEnum->RegNameAppendPos + SizeOfStringA (RegEnum->Name) / DWSIZEOF(CHAR))>
                    (RegEnum->NativeFullName + DWSIZEOF (RegEnum->NativeFullName) / DWSIZEOF(CHAR))) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "EnumNextRegObjectInTreeA: RegKey %s [%s] was found, but it's path is too long",
                        RegEnum->Location,
                        RegEnum->Name
                        ));
                    continue;
                }

                StringCopyA (RegEnum->RegNameAppendPos, RegEnum->Name);
                StringCatA (RegEnum->RegNameAppendPos, "]");

                RegEnum->Attributes = REG_ATTRIBUTE_VALUE;

                //
                // now test if the value matches
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !TestParsedPatternA (
                            RegEnum->RegEnumInfo.RegPattern->LeafPattern,
                            RegEnum->Name
                            )
                   ) {
                    continue;
                }

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (RegEnum->Name && ElIsExcluded2A (ELT_REGISTRY, NULL, RegEnum->Name)) {
                        DEBUGMSGA ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s [%s] was found, but it's excluded by value name",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                    if (ElIsExcluded2A (ELT_REGISTRY, RegEnum->Location, RegEnum->Name)) {
                        DEBUGMSGA ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s [%s] was found, but it's excluded",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExA (
                                                    RegEnum->Location,
                                                    RegEnum->Name,
                                                    TRUE
                                                    );
            }

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = 0;
            }

            return TRUE;
        }

        //
        // try the next root
        //
        if (RegEnum->RootState == RES_ROOT_DONE) {
            break;
        }

        MYASSERT (RegEnum->RootState == RES_ROOT_NEXT);
        MYASSERT (RegEnum->RootEnum);
        success = pEnumNextRegRootA (RegEnum);

    } while (success);

    AbortRegObjectInTreeEnumA (RegEnum);

    return FALSE;
}

BOOL
EnumNextRegObjectInTreeW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    PREGNODEW currentNode;
    BOOL success;

    MYASSERT (RegEnum);

    do {
        if (RegEnum->EncodedFullName) {
            ObsFreeW (RegEnum->EncodedFullName);
            RegEnum->EncodedFullName = NULL;
        }

        while (TRUE) {

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = L'\\';
                RegEnum->LastWackPtr = NULL;
            }

            if (!pEnumNextRegObjectInTreeW (RegEnum, &currentNode)) {
                break;
            }

            MYASSERT (currentNode && currentNode->KeyName);

            //
            // check if this object matches the pattern
            //
            if (!(currentNode->Flags & RNF_KEYNAME_MATCHES)) {   //lint !e613
                continue;
            }

            RegEnum->CurrentKeyHandle = /*lint -e(613)*/currentNode->KeyHandle;
            RegEnum->CurrentLevel = RegEnum->RegEnumInfo.RootLevel + /*lint -e(613)*/currentNode->SubLevel;

            if ((!currentNode->ValueName) || (currentNode->Flags & RNF_VALUENAME_INVALID)) {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->LastWackPtr = wcsrchr (RegEnum->Location, L'\\');
                if (!RegEnum->LastWackPtr) {
                    RegEnum->Name = RegEnum->Location;
                } else {
                    RegEnum->Name = RegEnum->LastWackPtr + 1;
                    if (!RegEnum->Name) {
                        RegEnum->Name = RegEnum->Location;
                    }
                }
                RegEnum->CurrentValueData = NULL;
                RegEnum->CurrentValueDataSize = 0;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;
                RegEnum->Attributes = REG_ATTRIBUTE_KEY;
                //
                // prepare full path buffer
                //
                StringCopyW (RegEnum->NativeFullName, RegEnum->Location);
                RegEnum->LastNode = currentNode;
                RegEnum->RegNameAppendPos = NULL;

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    if (ElIsExcluded2W (ELT_REGISTRY, RegEnum->Location, NULL)) {
                        DEBUGMSGW ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s was found, but it's excluded",
                            RegEnum->Location
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExW (
                                                    RegEnum->Location,
                                                    NULL,
                                                    TRUE
                                                    );
            } else {
                RegEnum->Location = /*lint -e(613)*/currentNode->KeyName;
                RegEnum->Name = /*lint -e(613)*/currentNode->ValueName;
                RegEnum->CurrentValueData = /*lint -e(613)*/currentNode->ValueData;
                RegEnum->CurrentValueDataSize = currentNode->ValueDataSize;
                RegEnum->CurrentValueType = /*lint -e(613)*/currentNode->ValueType;

                if (RegEnum->LastNode != currentNode) {
                    RegEnum->LastNode = currentNode;
                    //
                    // prepare full path buffer
                    //
                    RegEnum->NativeFullName[0] = 0;
                    RegEnum->RegNameAppendPos = StringCatW (RegEnum->NativeFullName, RegEnum->Location);
                    RegEnum->RegNameAppendPos = StringCatW (RegEnum->RegNameAppendPos, L"\\[");
                } else if (!RegEnum->RegNameAppendPos) {
                    RegEnum->RegNameAppendPos = GetEndOfStringW (RegEnum->NativeFullName);
                    RegEnum->RegNameAppendPos = StringCatW (RegEnum->RegNameAppendPos, L"\\[");
                }

                MYASSERT (RegEnum->Name);

				{
					UINT size1 = 0;
					UINT size2 = 0;
					INT size3 = 0;

					size1 = (UINT)(RegEnum->RegNameAppendPos + SizeOfStringW (RegEnum->Name) / DWSIZEOF(WCHAR));
					size2 = (UINT)(RegEnum->NativeFullName + DWSIZEOF (RegEnum->NativeFullName) / DWSIZEOF(WCHAR));
					size3 = size2 - size1;
				}

                if ((RegEnum->RegNameAppendPos + SizeOfStringW (RegEnum->Name) / DWSIZEOF(WCHAR))>
                    (RegEnum->NativeFullName + DWSIZEOF (RegEnum->NativeFullName) / DWSIZEOF(WCHAR))) {
                    DEBUGMSGW ((
                        DBG_ERROR,
                        "EnumNextRegObjectInTreeW: RegKey %s [%s] was found, but it's path is too long",
                        RegEnum->Location,
                        RegEnum->Name
                        ));
                    continue;
                }

                StringCopyW (RegEnum->RegNameAppendPos, RegEnum->Name);
                StringCatW (RegEnum->RegNameAppendPos, L"]");

                RegEnum->Attributes = REG_ATTRIBUTE_VALUE;

                //
                // now test if the value matches
                //
                if (!(RegEnum->RegEnumInfo.RegPattern->Flags & (OBSPF_EXACTLEAF | OBSPF_OPTIONALLEAF)) &&
                    !TestParsedPatternW (
                            RegEnum->RegEnumInfo.RegPattern->LeafPattern,
                            RegEnum->Name
                            )
                   ) {
                    continue;
                }

                if (RegEnum->RegEnumInfo.Flags & REIF_USE_EXCLUSIONS) {
                    //
                    // check if this object is excluded
                    //
                    if (RegEnum->Name && ElIsExcluded2W (ELT_REGISTRY, NULL, RegEnum->Name)) {
                        DEBUGMSGW ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s [%s] was found, but it's excluded by value name",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                    if (ElIsExcluded2W (ELT_REGISTRY, RegEnum->Location, RegEnum->Name)) {
                        DEBUGMSGW ((
                            DBG_REGENUM,
                            "EnumNextRegObjectInTreeA: RegKey %s [%s] was found, but it's excluded",
                            RegEnum->Location,
                            RegEnum->Name
                            ));
                        continue;
                    }
                }

                RegEnum->EncodedFullName = ObsBuildEncodedObjectStringExW (
                                                    RegEnum->Location,
                                                    RegEnum->Name,
                                                    TRUE
                                                    );
            }

            if (RegEnum->LastWackPtr) {
                *RegEnum->LastWackPtr = 0;
            }

            return TRUE;
        }

        //
        // try the next root
        //
        if (RegEnum->RootState == RES_ROOT_DONE) {
            break;
        }

        MYASSERT (RegEnum->RootState == RES_ROOT_NEXT);
        MYASSERT (RegEnum->RootEnum);
        success = pEnumNextRegRootW (RegEnum);

    } while (success);

    AbortRegObjectInTreeEnumW (RegEnum);

    return FALSE;
}


/*++

Routine Description:

    AbortRegObjectInTreeEnum aborts the enumeration, freeing all resources allocated

Arguments:

    RegEnum - Specifies the current enum context; receives a "clean" context

Return Value:

    none

--*/

VOID
AbortRegObjectInTreeEnumA (
    IN OUT  PREGTREE_ENUMA RegEnum
    )
{
    while (pDeleteRegNodeA (RegEnum, TRUE)) {
    }
    GbFree (&RegEnum->RegNodes);

    if (RegEnum->EncodedFullName) {
        ObsFreeA (RegEnum->EncodedFullName);
        RegEnum->EncodedFullName = NULL;
    }

    if (RegEnum->RegEnumInfo.RegPattern) {
        ObsDestroyParsedPatternA (RegEnum->RegEnumInfo.RegPattern);
        RegEnum->RegEnumInfo.RegPattern = NULL;
    }

    if (RegEnum->RootEnum) {
        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }
}

VOID
AbortRegObjectInTreeEnumW (
    IN OUT  PREGTREE_ENUMW RegEnum
    )
{
    while (pDeleteRegNodeW (RegEnum, TRUE)) {
    }
    GbFree (&RegEnum->RegNodes);

    if (RegEnum->EncodedFullName) {
        ObsFreeW (RegEnum->EncodedFullName);
        RegEnum->EncodedFullName = NULL;
    }

    if (RegEnum->RegEnumInfo.RegPattern) {
        ObsDestroyParsedPatternW (RegEnum->RegEnumInfo.RegPattern);
        RegEnum->RegEnumInfo.RegPattern = NULL;
    }

    if (RegEnum->RootEnum) {
        pFreeMemory (RegEnum->RootEnum);
        RegEnum->RootEnum = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\progbar\progbar.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    progbar.c

Abstract:

    Centralizes access to the progress bar and associated messages accross components
    (hwcomp,migapp,etc.) and sides (w9x, nt)

Author:

    Marc R. Whitten (marcw)     14-Apr-1997

Revision History:

    jimschm     19-Jun-1998     Improved to allow revision of estimates, necessary
                                for NT-side progress bar.

--*/

//
// Includes
//

#include "pch.h"

#define DBG_PROGBAR     "Progbar"

//
// Strings
//

// None

//
// Constants
//

#define TICKSCALE       100

//
// Macros
//

// None

//
// Types
//

typedef struct {
    BOOL    Started;
    BOOL    Completed;
    UINT    InitialGuess;
    UINT    TotalTicks;
    UINT    TicksSoFar;
    UINT    LastTickDisplayed;
} SLICE, *PSLICE;

typedef struct {
    HWND Window;
    HANDLE CancelEvent;
    PCSTR Message;
    DWORD MessageId;
    DWORD Delay;
    BOOL  InUse;
} DELAYTHREADPARAMS, *PDELAYTHREADPARAMS;


#if 0

typedef struct {
    HANDLE CancelEvent;
    DWORD TickCount;
    BOOL  InUse;
} TICKTHREADPARAMS, *PTICKTHREADPARAMS;

#endif

//
// Globals
//

static BOOL g_ProgBarInitialized = FALSE;

static HWND g_ProgressBar;
HWND g_Component;
HWND g_SubComponent;

static PBRANGE g_OrgRange;

HANDLE g_ComponentCancelEvent;
HANDLE g_SubComponentCancelEvent;

static BOOL *g_CancelFlagPtr;
static GROWBUFFER g_SliceArray;
static UINT g_SliceCount;
static UINT g_MaxTickCount;
static UINT g_PaddingTicks;
static UINT g_CurrentTickCount;
static UINT g_CurrentPos;
static UINT g_ReduceFactor;
static BOOL g_Reverse = FALSE;
static OUR_CRITICAL_SECTION g_ProgBarCriticalSection;
static UINT g_CurrentSliceId = (UINT)-1;
static INT g_ProgBarRefs;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
PbInitialize (
    IN      HWND ProgressBar,
    IN      HWND Component,             OPTIONAL
    IN      HWND SubComponent,          OPTIONAL
    IN      BOOL *CancelFlagPtr         OPTIONAL
    )
{
    LONG rc;
    DWORD Size;
    HKEY Key;

    MYASSERT (g_ProgBarRefs >= 0);

    g_ProgBarRefs++;

    if (g_ProgBarRefs == 1) {

        g_ProgressBar = ProgressBar;
        g_CancelFlagPtr = CancelFlagPtr;

        g_ProgBarInitialized = TRUE;

        SendMessage (ProgressBar, PBM_SETPOS, 0, 0);
        g_CurrentPos = 0;
        SendMessage (ProgressBar, PBM_GETRANGE, 0, (LPARAM) &g_OrgRange);

        //
        // Create cancel events for delayed messages.
        //
        g_ComponentCancelEvent      = CreateEvent (NULL, FALSE, FALSE, NULL);
        g_SubComponentCancelEvent   = CreateEvent (NULL, FALSE, FALSE, NULL);

        if (!g_ComponentCancelEvent || !g_SubComponentCancelEvent) {
            DEBUGMSG ((DBG_ERROR, "ProgressBar: Could not create cancel events."));
        }

        InitializeOurCriticalSection (&g_ProgBarCriticalSection);

        g_Component = Component;
        g_SubComponent = SubComponent;

        DEBUGMSG_IF ((
            Component && !IsWindow (Component),
            DBG_WHOOPS,
            "Progress bar component is not a valid window"
            ));

        DEBUGMSG_IF ((
            SubComponent && !IsWindow (SubComponent),
            DBG_WHOOPS,
            "Progress bar sub component is not a valid window"
            ));

        MYASSERT (!g_SliceCount);
        MYASSERT (!g_SliceArray.Buf);
        MYASSERT (!g_MaxTickCount);
        MYASSERT (!g_PaddingTicks);
        MYASSERT (!g_CurrentTickCount);
        MYASSERT (g_CurrentSliceId == (UINT)-1);

        g_ReduceFactor = 1;
    }
}


VOID
PbTerminate (
    VOID
    )
{
    MYASSERT (g_ProgBarRefs > 0);

    g_ProgBarRefs--;

    if (!g_ProgBarRefs) {
        if (g_ComponentCancelEvent) {
            CloseHandle (g_ComponentCancelEvent);
            g_ComponentCancelEvent = NULL;
        }

        if (g_SubComponentCancelEvent) {
            CloseHandle (g_SubComponentCancelEvent);
            g_SubComponentCancelEvent = NULL;
        }

        DeleteOurCriticalSection (&g_ProgBarCriticalSection);

        GbFree (&g_SliceArray);
        g_SliceCount = 0;
        g_MaxTickCount = 0;
        g_PaddingTicks = 0;
        g_CurrentTickCount = 0;
        g_CurrentSliceId = -1;
        g_Component = NULL;
        g_SubComponent = NULL;

        g_ReduceFactor = 1;

        SendMessage (g_ProgressBar, PBM_SETRANGE32, g_OrgRange.iLow, g_OrgRange.iHigh);

        g_ProgBarInitialized = FALSE;
    }
}


UINT
PbRegisterSlice (
    IN      UINT InitialEstimate
    )
{
    PSLICE Slice;
    UINT SliceId;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return 0;
    }

    SliceId = g_SliceCount;

    Slice = (PSLICE) GbGrow (&g_SliceArray, sizeof (SLICE));
    g_SliceCount++;

    Slice->Started = FALSE;
    Slice->Completed = FALSE;
    Slice->TotalTicks = InitialEstimate * TICKSCALE;
    Slice->InitialGuess = Slice->TotalTicks;
    Slice->TicksSoFar = 0;
    Slice->LastTickDisplayed = 0;

    return SliceId;
}


VOID
PbReviseSliceEstimate (
    IN      UINT SliceId,
    IN      UINT RevisedEstimate
    )
{
    PSLICE Slice;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return;
    }

    if (SliceId >= g_SliceCount) {
        DEBUGMSG ((DBG_WHOOPS, "ReviseSliceEstimate: Invalid slice ID %u", SliceId));
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + SliceId;

    if (!g_CurrentTickCount) {
        Slice->TotalTicks = RevisedEstimate;
        return;
    }

    if (Slice->Completed) {
        DEBUGMSG ((DBG_WHOOPS, "ReviseSliceEstimate: Can't revise completed slice"));
        return;
    }

    if (Slice->InitialGuess == 0) {
        return;
    }

    RevisedEstimate *= TICKSCALE;

    MYASSERT (Slice->TicksSoFar * RevisedEstimate >= Slice->TicksSoFar);
    MYASSERT (Slice->LastTickDisplayed * RevisedEstimate >= Slice->LastTickDisplayed);

    Slice->TicksSoFar = (UINT) ((LONGLONG) Slice->TicksSoFar * (LONGLONG) RevisedEstimate / (LONGLONG) Slice->TotalTicks);
    Slice->LastTickDisplayed = (UINT) ((LONGLONG) Slice->LastTickDisplayed * (LONGLONG) RevisedEstimate / (LONGLONG) Slice->TotalTicks);
    Slice->TotalTicks = RevisedEstimate;
}


VOID
PbBeginSliceProcessing (
    IN      UINT SliceId
    )
{
    PSLICE Slice;
    UINT u;
    UINT TotalTicks;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return;
    }

    if (!g_ProgressBar) {
        DEBUGMSG ((DBG_WHOOPS, "No progress bar handle"));
        return;
    }

    if (SliceId >= g_SliceCount) {
        DEBUGMSG ((DBG_WHOOPS, "BeginSliceProcessing: Invalid slice ID %u", SliceId));
        return;
    }

    if (!g_CurrentTickCount) {
        //
        // Initialize the progress bar
        //

        MYASSERT (g_CurrentSliceId == (UINT)-1);

        TotalTicks = 0;
        Slice = (PSLICE) g_SliceArray.Buf;

        for (u = 0 ; u < g_SliceCount ; u++) {
            TotalTicks += Slice->InitialGuess;
            Slice++;
        }

        TotalTicks /= TICKSCALE;
        g_PaddingTicks = TotalTicks * 5 / 100;
        g_MaxTickCount = TotalTicks + 2 * g_PaddingTicks;

        g_ReduceFactor = 1;
        while (g_MaxTickCount > 0xffff) {
            g_ReduceFactor *= 10;
            g_MaxTickCount /= 10;
        }

        SendMessage (g_ProgressBar, PBM_SETRANGE, 0, MAKELPARAM (0, g_MaxTickCount));
        SendMessage (g_ProgressBar, PBM_SETSTEP, 1, 0);

        if (g_Reverse) {
            SendMessage (
                g_ProgressBar,
                PBM_SETPOS,
                g_MaxTickCount - (g_PaddingTicks / g_ReduceFactor),
                0
                );
        } else {
            SendMessage (g_ProgressBar, PBM_SETPOS, g_PaddingTicks / g_ReduceFactor, 0);
        }

        g_CurrentTickCount = g_PaddingTicks;
        g_CurrentPos = g_PaddingTicks;

    } else if (SliceId <= g_CurrentSliceId) {
        DEBUGMSG ((DBG_WHOOPS, "BeginSliceProcessing: Slice ID %u processed already", SliceId));
        return;
    }


    g_CurrentSliceId = SliceId;
    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    Slice->Started = TRUE;
}


VOID
pIncrementBarIfNecessary (
    IN OUT  PSLICE Slice
    )
{
    UINT Increment;
    UINT Pos;

    if (Slice->TicksSoFar >= Slice->TotalTicks) {
        Slice->TicksSoFar = Slice->TotalTicks;
        Slice->Completed = TRUE;
    }

    if (Slice->TicksSoFar - Slice->LastTickDisplayed >= TICKSCALE) {
        Increment = (Slice->TicksSoFar - Slice->LastTickDisplayed) / TICKSCALE;
        Slice->LastTickDisplayed += Increment * TICKSCALE;

        Pos = ((g_CurrentPos + Slice->TicksSoFar) / TICKSCALE);

        Pos += g_PaddingTicks;
        Pos /= g_ReduceFactor;

        if (Pos > g_MaxTickCount) {
            Pos = g_MaxTickCount - (g_PaddingTicks / g_ReduceFactor);
        }

        if (g_Reverse) {

            SendMessage (g_ProgressBar, PBM_SETPOS, g_MaxTickCount - Pos, 0);

        } else {

            SendMessage (g_ProgressBar, PBM_SETPOS, Pos, 0);
        }
    }
}


VOID
static
pTickProgressBar (
    IN      UINT Ticks
    )
{
    PSLICE Slice;
    LONGLONG x;

    if (!Ticks || g_CurrentSliceId == (UINT)-1 || g_CurrentSliceId >= g_SliceCount) {
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    if (!Slice->InitialGuess) {
        return;
    }

    if (Slice->Completed) {
        DEBUGMSG ((DBG_WARNING, "Slice ID %u already completed", g_CurrentSliceId));
        return;
    }

    MYASSERT (Ticks * TICKSCALE > Ticks);
    x = ((LONGLONG) Ticks * TICKSCALE * (LONGLONG) Slice->TotalTicks) / (LONGLONG) Slice->InitialGuess;
    MYASSERT (x + (LONGLONG) Slice->TicksSoFar < 0x100000000);

    Slice->TicksSoFar += (UINT) x;

    pIncrementBarIfNecessary (Slice);

}


BOOL
PbTickDelta (
    IN      UINT TickCount
    )
{
    BOOL    rSuccess = TRUE;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    if (g_CancelFlagPtr && *g_CancelFlagPtr) {
        SetLastError (ERROR_CANCELLED);
        rSuccess = FALSE;
    } else {
        pTickProgressBar (TickCount);
    }

    return rSuccess;
}


BOOL
PbTick (
    VOID
    )
{
    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    return PbTickDelta (1);
}


VOID
PbGetSliceInfo (
    IN      UINT SliceId,
    OUT     PBOOL SliceStarted,     OPTIONAL
    OUT     PBOOL SliceFinished,    OPTIONAL
    OUT     PUINT TicksCompleted,   OPTIONAL
    OUT     PUINT TotalTicks        OPTIONAL
    )
{
    PSLICE Slice;

    Slice = (PSLICE) g_SliceArray.Buf + SliceId;

    if (SliceStarted) {
        *SliceStarted = Slice->Started;
    }

    if (SliceFinished) {
        *SliceFinished = Slice->Completed;
    }

    if (TicksCompleted) {
        *TicksCompleted = Slice->TicksSoFar / TICKSCALE;
    }

    if (TotalTicks) {
        *TotalTicks = Slice->TotalTicks / TICKSCALE;
    }
}

VOID
PbEndSliceProcessing (
    VOID
    )
{
    PSLICE Slice;

    MYASSERT (g_ProgBarInitialized);
    if (!g_ProgBarInitialized) {
        return;
    }

    Slice = (PSLICE) g_SliceArray.Buf + g_CurrentSliceId;

    if (!Slice->InitialGuess) {
        Slice->Completed = TRUE;
        return;
    }

    if (!Slice->Completed) {
        DEBUGMSG ((DBG_WARNING, "Progress bar slice %u was not completed.", g_CurrentSliceId));

        Slice->TicksSoFar = Slice->TotalTicks;
        Slice->Completed = TRUE;

        pIncrementBarIfNecessary (Slice);
    }

    g_CurrentPos += Slice->TotalTicks;

    if (g_CurrentSliceId == g_SliceCount - 1) {
        //
        // End of progress bar
        //

        SendMessage (g_ProgressBar, PBM_SETPOS, g_MaxTickCount, 0);
    }
}


BOOL
pCheckProgressBarState (
    IN HANDLE CancelEvent
    )
{

    SetEvent(CancelEvent);

    return (!g_CancelFlagPtr || !*g_CancelFlagPtr);
}


BOOL
PbSetWindowStringA (
    IN      HWND Window,
    IN      HANDLE CancelEvent,
    IN      PCSTR Message,        OPTIONAL
    IN      DWORD MessageId       OPTIONAL
    )
{
    BOOL rSuccess = TRUE;
    PCSTR string = NULL;

    EnterOurCriticalSection (&g_ProgBarCriticalSection);

    if (g_ProgBarInitialized) {

        if (pCheckProgressBarState(CancelEvent)) {

            if (Message) {

                //
                // We have a normal message string.
                //

                if (!SetWindowTextA(Window, Message)) {
                    rSuccess = FALSE;
                    DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                }
            }
            else if (MessageId) {

                //
                // We have a message ID. Convert it and set it.
                //
                string = GetStringResourceA(MessageId);

                if (string) {

                    if (!SetWindowTextA(Window, string)) {
                        rSuccess = FALSE;
                        DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                    }

                    FreeStringResourceA(string);
                }
                ELSE_DEBUGMSG((DBG_ERROR,"ProgressBar: Error with GetStringResource"));

            }
            else {

                //
                // Just clear the text.
                //

                if (!SetWindowTextA(Window, "")) {
                    rSuccess = FALSE;
                    DEBUGMSG((DBG_ERROR,"ProgressBar: SetWindowText failed."));
                }
            }
        }
        else {
            //
            // We are in a canceled state.
            //
            rSuccess = FALSE;
            SetLastError (ERROR_CANCELLED);
        }
    }

    LeaveOurCriticalSection (&g_ProgBarCriticalSection);

    return rSuccess;

}


DWORD
pSetDelayedMessageA (
    IN      PVOID Param
    )
{
    DWORD               rc = ERROR_SUCCESS;
    PDELAYTHREADPARAMS  tParams = (PDELAYTHREADPARAMS) Param;

    //
    //  Simply wait for the passed in delay or until someone signals the cancel
    //  event.
    //
    switch (WaitForSingleObject(tParams -> CancelEvent, tParams -> Delay)) {

    case WAIT_TIMEOUT:
        //
        // We timed out without cancel being signaled. Set the delayed message.
        //
        PbSetWindowStringA (
            tParams->Window,
            tParams->CancelEvent,
            tParams->Message,
            tParams->MessageId
            );

        break;

    case WAIT_OBJECT_0:
    default:
        //
        //  We were canceled (or something strange happened :> Do nothing!
        //
        break;
    }

    //
    // can set a new thread now
    //
    tParams->InUse = FALSE;

    return rc;
}


VOID
PbCancelDelayedMessage (
    IN HANDLE CancelEvent
    )
{
    if (!g_ProgBarInitialized) {
        return;
    }

    SetEvent(CancelEvent);

}


BOOL
PbSetDelayedMessageA (
    IN HWND             Window,
    IN HANDLE           CancelEvent,
    IN LPCSTR           Message,
    IN DWORD            MessageId,
    IN DWORD            Delay
    )
{
    BOOL                rSuccess = FALSE;
    DWORD               threadId;
    static DELAYTHREADPARAMS   tParams;

    if (!g_ProgBarInitialized || tParams.InUse) {
        return TRUE;
    }

    if (!pCheckProgressBarState(Window)) {


        //
        // Fill in the parameters for this call to create thread.
        //
        tParams.Window       = Window;
        tParams.CancelEvent  = CancelEvent;
        tParams.Message      = Message;
        tParams.MessageId    = MessageId;
        tParams.Delay        = Delay;

        //
        // Spawn off a thread that will set the message.
        //
        rSuccess = NULL != CreateThread (
                            NULL,   // No inheritance.
                            0,      // Normal stack size.
                            pSetDelayedMessageA,
                            &tParams,
                            0,      // Run immediately.
                            &threadId
                            );

        if (rSuccess) {
            tParams.InUse = TRUE;
        }
        ELSE_DEBUGMSG((DBG_ERROR,"Error spawning thread in PbSetDelayedMessageA."));
    }

    return rSuccess;
}

#if 0

DWORD
pTickProgressBarThread (
    IN      PVOID Param
    )
{
    DWORD               rc = ERROR_SUCCESS;
    PTICKTHREADPARAMS   Params = (PTICKTHREADPARAMS)Param;
    BOOL                Continue = TRUE;

    //
    //  Simply wait for the passed in delay or until someone signals the cancel
    //  event.
    //

    do {
        switch (WaitForSingleObject(Params->CancelEvent, Params->TickCount)) {

        case WAIT_TIMEOUT:
            //
            // We timed out without cancel being signaled. Tick the progress bar.
            //
            if (!PbTickDelta (Params->TickCount)) {
                //
                // cancelled
                //
                Continue = FALSE;
            }
            break;

        case WAIT_OBJECT_0:
        default:
            //
            //  We were canceled (or something strange happened :> Do nothing!
            //
            Continue = FALSE;
            break;
        }
    } while (Continue);

    //
    // can set a new thread now
    //
    Params->InUse = FALSE;

    return rc;
}


BOOL
PbCreateTickThread (
    IN      HANDLE CancelEvent,
    IN      DWORD TickCount
    )
{
    BOOL                    rSuccess = FALSE;
    DWORD                   threadId;
    static TICKTHREADPARAMS g_Params;

    if (g_ProgBarInitialized && !g_Params.InUse) {

        if (pCheckProgressBarState(NULL)) {

            //
            // Fill in the parameters for this call to create thread.
            //
            g_Params.CancelEvent = CancelEvent;
            g_Params.TickCount = TickCount;

            //
            // Spawn off a thread that will set the message.
            //
            if (CreateThread (
                    NULL,   // No inheritance.
                    0,      // Normal stack size.
                    pTickProgressBarThread,
                    &g_Params,
                    0,      // Run immediately.
                    &threadId
                    )) {
                rSuccess = TRUE;
                g_Params.InUse = TRUE;
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Error spawning thread in PbCreateTickThread."));
        }
    }

    return rSuccess;
}


BOOL
PbCancelTickThread (
    IN HANDLE CancelEvent
    )
{
    if (!g_ProgBarInitialized) {
        return TRUE;
    }

    return SetEvent(CancelEvent);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\reg\cache.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    cache.c

Abstract:

    Implements a cache mechanism to speed up OpenRegKeyStr.

Author:

    Jim Schmidt (jimschm)  11-Sep-2000

Revisions:

    <alias>     <date>      <comments>

--*/

#include "pch.h"
#include "regp.h"

#define DBG_REG     "Reg"

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    BYTE KeyString[];
} REGKEYCACHE, *PREGKEYCACHE;

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    CHAR KeyString[MAX_REGISTRY_KEY];
} WORKITEMA, *PWORKITEMA;

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    WCHAR KeyString[MAX_REGISTRY_KEY];
} WORKITEMW, *PWORKITEMW;

GROWLIST g_KeyCache = INIT_GROWLIST;
UINT g_MaxCacheCount = 0;
UINT g_CacheAddPos;
CHAR g_LastParent[MAX_REGISTRY_KEY];
UINT g_LastParentBytes;
UINT g_LastParentUse;
WCHAR g_LastParentW[MAX_REGISTRY_KEY];
UINT g_LastParentBytesW;
UINT g_LastParentUseW;

BOOL
pRemoveItemFromCache (
    IN      UINT Item
    );

//
// Implementation
//

VOID
RegInitializeCache (
    IN      UINT InitialCacheSize
    )
{
    if (InitialCacheSize > 64) {
        InitialCacheSize = 64;
    }

    g_MaxCacheCount = InitialCacheSize;
    g_CacheAddPos = 0;
    g_LastParentUse = 0;
    g_LastParentUseW = 0;
}


VOID
RegTerminateCache (
    VOID
    )
{
    UINT u;
    UINT count;

    count = GlGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        pRemoveItemFromCache (u);
    }

    GlFree (&g_KeyCache);
    g_MaxCacheCount = 0;
    g_LastParentUse = 0;
    g_LastParentUseW = 0;
}


BOOL
pRemoveItemFromCache (
    IN      UINT Item
    )
{
    PREGKEYCACHE cacheItem;

    // this function will always succeed.
    // It will close the opened key even
    // if refcount is not zero (but assert that).

    cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, Item);

    if (!cacheItem) {
        return TRUE;
    }

    MYASSERT (!cacheItem->RefCount);

    while (cacheItem->ClosesNeeded) {
        CloseRegKeyWorker (cacheItem->Key);
        cacheItem->ClosesNeeded--;
    }

    ZeroMemory (cacheItem, sizeof (REGKEYCACHE));

    return TRUE;
}


VOID
RegRecordParentInCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR StringEnd
    )
{
    HKEY key;
    UINT byteCount;
    CHAR lowerStr[MAX_REGISTRY_KEY];
    HKEY rootKey;
    UINT end;

    if (!g_MaxCacheCount) {
        return;
    }

    if (StringEnd <= KeyString) {
        return;
    }

    byteCount = (UINT) (HALF_PTR) ((PBYTE) StringEnd - (PBYTE) KeyString);

    if (byteCount >= (MAX_REGISTRY_KEY * sizeof (CHAR))) {
        return;
    }

    if (g_LastParentUse && g_LastParentUse < 3 && g_LastParentBytes == byteCount) {

        StringCopyABA (lowerStr, KeyString, StringEnd);
        CharLowerA (lowerStr);

        if (StringMatchA (g_LastParent, lowerStr)) {
            g_LastParentUse++;

            if (g_LastParentUse == 3) {
                //
                // Stimulate the cache
                //
                rootKey = ConvertRootStringToKeyA (lowerStr, &end);
                if (rootKey) {
                    if (lowerStr[end]) {
#ifdef DEBUG
                        key = OpenRegKeyWorkerA (rootKey, &lowerStr[end], __FILE__, __LINE__);
#else
                        key = OpenRegKeyWorkerA (rootKey, &lowerStr[end]);
#endif

                        if (key) {
                            RegAddKeyToCacheA (lowerStr, key, g_OpenSam);
                            CloseRegKey (key);
                        }
                    }
                }
            }

            return;
        }
    }

    StringCopyABA (g_LastParent, KeyString, StringEnd);
    CharLowerA (g_LastParent);
    g_LastParentBytes = byteCount;

    g_LastParentUse = 1;
}


HKEY
RegGetKeyFromCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR KeyEnd,       OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    )
{
    UINT stringBytes;
    PCSTR end;
    CHAR lowerStr[MAX_REGISTRY_KEY];
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    // The cache holds all open keys.

    count = GlGetSize (&g_KeyCache);
    if (!count) {
        return NULL;
    }

    if (!KeyEnd) {
        end = StackStringCopyA (lowerStr, KeyString);
    } else {
        if (KeyEnd > KeyString + MAX_REGISTRY_KEY) {
            KeyEnd = KeyString + MAX_REGISTRY_KEY;
        }

        end = StringCopyABA (lowerStr, KeyString, KeyEnd);
    }

    CharLowerA (lowerStr);

    stringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) lowerStr);

    //
    // Scan the cache sequentially (it should be small), and return a match
    // if one is found. Stored strings are always in lower case.
    //

    u = g_CacheAddPos;

    do {
        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, u);

        if (!cacheItem) {
            return NULL;
        }

        if ((cacheItem->KeyStringBytes == stringBytes) &&
            (!cacheItem->Unicode) &&
            ((cacheItem->Sam & Sam) == Sam) &&
            (StringMatchA ((PCSTR) cacheItem->KeyString, lowerStr))
            ) {

            if (IncRefCount) {
                cacheItem->RefCount++;
            }

            return cacheItem->Key;
        }

        u++;
        if (u >= count) {
            u = 0;
        }

    } while (u != g_CacheAddPos);

    return NULL;
}


VOID
RegAddKeyToCacheA (
    IN      PCSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    )
{
    PREGKEYCACHE cacheItem;
    PREGKEYCACHE lastAddItem;
    WORKITEMA workItem;
    PCSTR end;
    UINT minStructSize;
    UINT pos;
    UINT count;
    UINT u;

    // The cache holds all open keys.

    if (!g_MaxCacheCount || !Key) {
        return;
    }

    //
    // Scan the cache for the existing Key
    //

    count = GlGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, u);

        if (cacheItem->Key == Key) {
            cacheItem->RefCount++;

            g_CacheAddPos = u;
            cacheItem->Sam |= Sam;

            if (cacheItem->KeyStringBytes == 0 && *KeyString && !cacheItem->Unicode) {

                //
                // This key was added before we knew the name. Update the name
                // now.
                //

                DEBUGMSG ((DBG_REG, "Updating empty-named key %s", KeyString));

                minStructSize = sizeof (workItem) - sizeof (workItem.KeyString);
                CopyMemory (&workItem, cacheItem, minStructSize);

                end = StackStringCopyA (workItem.KeyString, KeyString);
                CharLowerA (workItem.KeyString);
                workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);
                workItem.ClosesNeeded++;

                minStructSize += workItem.KeyStringBytes + sizeof (CHAR);
                GlSetItem (&g_KeyCache, u, (PBYTE) &workItem, minStructSize);

            } else if (*KeyString == 0) {
                cacheItem->ClosesNeeded++;
            }

            return;
        }
    }

    //
    // Create the new cache item
    //

    workItem.Key = Key;
    workItem.Unicode = FALSE;
    workItem.RefCount = 1;
    workItem.ClosesNeeded = 1;
    workItem.Sam = Sam;
    end = StackStringCopyA (workItem.KeyString, KeyString);
    CharLowerA (workItem.KeyString);
    workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);

    minStructSize = sizeof (workItem) - sizeof (workItem.KeyString) + workItem.KeyStringBytes + sizeof (CHAR);

    //
    // Put work item into grow list
    //

    if (count < g_MaxCacheCount) {
        g_CacheAddPos = count;
        GlAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);
    } else {

        //
        // Look for a closed key to discard. If cache is too full, then
        // increase the cache size. If the cache size hits 64, then don't
        // cache this add.
        //

        lastAddItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, g_CacheAddPos);

        if (lastAddItem) {

            for (pos = 0 ; pos < count ; pos++) {

                if (pos == g_CacheAddPos) {
                    continue;
                }

                cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, pos);

                // never discard items that are currently referenced
                if (cacheItem->RefCount) {
                    continue;
                }

                // this is an optimization that has to do with how enumeration usually works.
                // If we have an item that's shorter that one that's in the cache already,
                // it's not very likely that we are going to go back to the one in the cache
                // so we just remove it.
                if (cacheItem->KeyStringBytes >= lastAddItem->KeyStringBytes) {
                    break;
                }

                if (cacheItem->Unicode) {
                    continue;
                }

                if (!StringPrefixA ((PCSTR) lastAddItem->KeyString, (PCSTR) cacheItem->KeyString)) {
                    break;
                }
            }

            if (pos == count) {
                if (g_MaxCacheCount == 64) {
                    DEBUGMSG ((DBG_REG, "Cache is full of open keys"));
                    return;
                }

                g_MaxCacheCount++;
                GlAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);

            } else {
                pRemoveItemFromCache (pos);
                GlSetItem (&g_KeyCache, pos, (PBYTE) &workItem, minStructSize);
            }

            g_CacheAddPos = pos;
        }
    }
}


BOOL
RegDecrementRefCount (
    IN      HKEY Key
    )
{
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    // The cache holds all open keys.

    if (!g_MaxCacheCount) {
        return FALSE;
    }

    count = GlGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, u);
        if (cacheItem->Key == Key) {
            if (cacheItem->RefCount == 0) {

                //
                // The caller is tried to close the key more times than what
                // it was opened.
                //

                if (cacheItem->Unicode) {
                    DEBUGMSGW ((
                        DBG_WHOOPS,
                        "Reg key %s ref count == 0; trying to close it too many times",
                        cacheItem->KeyString
                        ));
                } else {
                    DEBUGMSGA ((
                        DBG_WHOOPS,
                        "Reg key %s ref count == 0; trying to close it too many times",
                        cacheItem->KeyString
                        ));
                }
            } else {
                cacheItem->RefCount--;
            }

            // One more check. If the refcount is zero and this
            // is an item with an empty key string, let's get rid
            // of it.
            if ((cacheItem->RefCount == 0) &&
                (cacheItem->KeyStringBytes == 0)
                ) {
                pRemoveItemFromCache (u);
            }

            //
            // Return TRUE to either postpone the close
            // or to avoid the close because pRemoveItemFromCache did
            // it already
            //

            return TRUE;
        }
    }

    return FALSE;
}


VOID
RegRecordParentInCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR StringEnd
    )
{
    HKEY key;
    UINT byteCount;
    WCHAR lowerStr[MAX_REGISTRY_KEY];
    HKEY rootKey;
    UINT end;

    if (!g_MaxCacheCount) {
        return;
    }

    if (StringEnd <= KeyString) {
        return;
    }

    byteCount = (UINT) (HALF_PTR) ((PBYTE) StringEnd - (PBYTE) KeyString);

    if (byteCount >= (MAX_REGISTRY_KEY * sizeof (WCHAR))) {
        return;
    }

    if (g_LastParentUseW && g_LastParentUseW < 3 && g_LastParentBytesW == byteCount) {

        StringCopyABW (lowerStr, KeyString, StringEnd);
        CharLowerW (lowerStr);

        if (StringMatchW (g_LastParentW, lowerStr)) {
            g_LastParentUseW++;

            if (g_LastParentUseW == 3) {
                //
                // Stimulate the cache
                //

                rootKey = ConvertRootStringToKeyW (lowerStr, &end);
                if (rootKey) {
                    if (lowerStr[end]) {

#ifdef DEBUG
                        key = OpenRegKeyWorkerW (rootKey, &lowerStr[end], __FILE__, __LINE__);
#else
                        key = OpenRegKeyWorkerW (rootKey, &lowerStr[end]);
#endif

                        if (key) {
                            RegAddKeyToCacheW (lowerStr, key, g_OpenSam);
                            CloseRegKey (key);
                        }
                    }
                }
            }

            return;
        }
    }

    StringCopyABW (g_LastParentW, KeyString, StringEnd);
    CharLowerW (g_LastParentW);
    g_LastParentBytesW = byteCount;

    g_LastParentUseW = 1;
}


HKEY
RegGetKeyFromCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR KeyEnd,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    )
{
    UINT stringBytes;
    PCWSTR end;
    WCHAR lowerStr[MAX_REGISTRY_KEY];
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    // The cache holds all open keys.

    count = GlGetSize (&g_KeyCache);
    if (!count) {
        return NULL;
    }

    if (!KeyEnd) {
        end = StackStringCopyW (lowerStr, KeyString);
    } else {
        if (KeyEnd > KeyString + MAX_REGISTRY_KEY) {
            KeyEnd = KeyString + MAX_REGISTRY_KEY;
        }

        end = StringCopyABW (lowerStr, KeyString, KeyEnd);
    }

    CharLowerW (lowerStr);

    stringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) lowerStr);

    //
    // Scan the cache sequentially (it should be small), and return a match
    // if one is found. Stored strings are always in lower case.
    //

    u = g_CacheAddPos;

    do {
        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, u);

        if (!cacheItem) {
            return NULL;
        }

        if ((cacheItem->KeyStringBytes == stringBytes) &&
            (cacheItem->Unicode) &&
            ((cacheItem->Sam & Sam) == Sam) &&
            (StringMatchW ((PCWSTR) cacheItem->KeyString, lowerStr))
            ) {

            if (IncRefCount) {
                cacheItem->RefCount++;
            }

            return cacheItem->Key;
        }

        u++;
        if (u >= count) {
            u = 0;
        }

    } while (u != g_CacheAddPos);

    return NULL;
}


VOID
RegAddKeyToCacheW (
    IN      PCWSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    )
{
    PREGKEYCACHE cacheItem;
    PREGKEYCACHE lastAddItem;
    WORKITEMW workItem;
    PCWSTR end;
    UINT minStructSize;
    UINT pos;
    UINT count;
    UINT u;

    // The cache holds all open keys.

    if (!g_MaxCacheCount || !Key) {
        return;
    }

    //
    // Scan the cache for the existing Key
    //

    count = GlGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, u);

        if (cacheItem->Key == Key) {
            cacheItem->RefCount++;

            g_CacheAddPos = u;
            cacheItem->Sam |= Sam;

            if (cacheItem->KeyStringBytes == 0 && *KeyString && cacheItem->Unicode) {

                //
                // This key was added before we knew the name. Update the name
                // now.
                //

                minStructSize = sizeof (workItem) - sizeof (workItem.KeyString);
                CopyMemory (&workItem, cacheItem, minStructSize);

                end = StackStringCopyW (workItem.KeyString, KeyString);
                CharLowerW (workItem.KeyString);
                workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);
                workItem.ClosesNeeded++;

                minStructSize += workItem.KeyStringBytes + sizeof (WCHAR);
                GlSetItem (&g_KeyCache, u, (PBYTE) &workItem, minStructSize);

            } else if (*KeyString == 0) {
                cacheItem->ClosesNeeded++;
            }

            return;
        }
    }

    //
    // Create the new cache item
    //

    workItem.Key = Key;
    workItem.Unicode = TRUE;
    workItem.RefCount = 1;
    workItem.ClosesNeeded = 1;
    workItem.Sam = Sam;
    end = StackStringCopyW (workItem.KeyString, KeyString);
    CharLowerW (workItem.KeyString);
    workItem.KeyStringBytes = (UINT) (HALF_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);

    minStructSize = sizeof (workItem) - sizeof (workItem.KeyString) + workItem.KeyStringBytes + sizeof (WCHAR);

    //
    // Put work item into grow list
    //

    if (count < g_MaxCacheCount) {
        g_CacheAddPos = count;
        GlAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);
    } else {

        //
        // Look for a closed key to discard. If cache is too full, then
        // increase the cache size. If the cache size hits 64, then don't
        // cache this add.
        //

        lastAddItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, g_CacheAddPos);

        if (lastAddItem) {

            for (pos = 0 ; pos < count ; pos++) {

                if (pos == g_CacheAddPos) {
                    continue;
                }

                cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, pos);

                // never discard items that are currently referenced
                if (cacheItem->RefCount) {
                    continue;
                }

                // this is an optimization that has to do with how enumeration usually works.
                // If we have an item that's shorter that one that's in the cache already,
                // it's not very likely that we are going to go back to the one in the cache
                // so we just remove it.
                if (cacheItem->KeyStringBytes >= lastAddItem->KeyStringBytes) {
                    break;
                }

                if (!cacheItem->Unicode) {
                    continue;
                }

                if (!StringPrefixW ((PCWSTR) lastAddItem->KeyString, (PCWSTR) cacheItem->KeyString)) {
                    break;
                }
            }

            if (pos == count) {
                if (g_MaxCacheCount == 64) {
                    DEBUGMSG ((DBG_REG, "Cache is full of open keys"));
                    return;
                }

                g_MaxCacheCount++;
                GlAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);

            } else {
                pRemoveItemFromCache (pos);
                GlSetItem (&g_KeyCache, pos, (PBYTE) &workItem, minStructSize);
            }

            g_CacheAddPos = pos;
        }
    }
}


VOID
RegRemoveItemFromCacheA (
    IN      PCSTR RegKey
    )
{
    PREGKEYCACHE cacheItem;
    UINT pos;
    UINT count;

    count = GlGetSize (&g_KeyCache);

    for (pos = 0 ; pos < count ; pos++) {

        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, pos);

        if (StringIMatchA ((PCSTR) cacheItem->KeyString, RegKey)) {
            // we are forced to remove this, regardless of the refcount
            cacheItem->RefCount = 0;
            pRemoveItemFromCache (pos);
            // we need to keep going since different security
            // access masks would have generated different
            // items in the cache
        }
    }
}


VOID
RegRemoveItemFromCacheW (
    IN      PCWSTR RegKey
    )
{
    PREGKEYCACHE cacheItem;
    UINT pos;
    UINT count;

    count = GlGetSize (&g_KeyCache);

    for (pos = 0 ; pos < count ; pos++) {

        cacheItem = (PREGKEYCACHE) GlGetItem (&g_KeyCache, pos);

        if (StringIMatchW ((PCWSTR) cacheItem->KeyString, RegKey)) {
            // we are forced to remove this, regardless of the refcount
            cacheItem->RefCount = 0;
            pRemoveItemFromCache (pos);
            // we need to keep going since different security
            // access masks would have generated different
            // items in the cache
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\reg\reg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reg.c

Abstract:

    Implements utilities to parse a registry key string, and also implements
    wrappers to the registry API.  There are three groups of APIs in this
    source file: query functions, open and create functions, and registry
    string parsing functions.

    The query functions allow simplified querying, where the caller receives
    a MemAlloc'd pointer to the data and does not have to worry about managing
    the numerous parameters needed to do the query.  The query functions
    also allow filtering of values that are not the expected type.  All
    query functions have a version with 2 appended to the function name which
    allow the caller to specify an alternative allocator and deallocator.

    The open and create functions simplify the process of obtaining a key
    handle.  They allow the caller to specify a key string as input and return
    the key handle as output.

    The registry string parsing functions are utilities that can be used when
    processing registry key strings.  The functions extract the registry root
    from a string, convert it into a handle, convert a hive handle into a
    string, and so on.

Author:

    Jim Schmidt (jimschm)  20-Mar-1997

Revisions:

    jimschm     18-Sep-2000 Added cache
    ovidiut     22-Feb-1999 Added GetRegSubkeysCount
    calinn      23-Sep-1998 Fixed REG_SZ filtering
    jimschm     25-Mar-1998 Added CreateEncodedRegistryStringEx
    jimschm     21-Oct-1997 Added EnumFirstKeyInTree/EnumNextKeyInTree
    marcw       16-Jul-1997 Added CreateEncodedRegistryString/FreeEncodedRegistryString
    jimschm     22-Jun-1997 Added GetRegData

--*/

#include "pch.h"
#include "regp.h"

#ifdef DEBUG
#undef RegCloseKey
#endif

HKEY g_Root = HKEY_ROOT;
REGSAM g_OpenSam = KEY_ALL_ACCESS;
REGSAM g_CreateSam = KEY_ALL_ACCESS;
INT g_RegRefs;

#define DBG_REG     "Reg"

//
// Implementation
//


BOOL
RegInitialize (
    VOID
    )
{
    BOOL b = TRUE;

    MYASSERT (g_RegRefs >= 0);

    g_RegRefs++;

    if (g_RegRefs == 1) {

        RegInitializeCache (0);
        b = RegEnumInitialize ();
    }

    return b;
}


VOID
RegTerminate (
    VOID
    )
{
    MYASSERT (g_RegRefs > 0);

    g_RegRefs--;

    if (!g_RegRefs) {
        RegEnumTerminate ();
        RegTerminateCache ();
    }

#ifdef DEBUG
    RegTrackTerminate();
#endif
}


VOID
SetRegRoot (
    IN      HKEY Root
    )
{
    g_Root = Root;
}

HKEY
GetRegRoot (
    VOID
    )
{
    return g_Root;
}


REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_OpenSam;
    g_OpenSam = Mode;

    return OldMode;
}

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    )
{
    return g_OpenSam;
}

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_CreateSam;
    g_CreateSam = Mode;

    return OldMode;
}

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    )
{
    return g_CreateSam;
}

/*++

Routine Description:

  OpenRegKeyStrA and OpenRegKeyStrW parse a text string that specifies a
  registry key into the hive and subkey, and then they open the subkey
  and return the handle.

Arguments:

  RegKey    - Specifies the complete path to the registry subkey, including
              the hive.

Return Value:

  A non-NULL registry handle if successful, or NULL if either the subkey
  could not be opened or the string is malformed.

--*/

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;
    HKEY parentKey;
    PCSTR lastWack;

    //
    // Attempt to use cache
    //

    Key = RegGetKeyFromCacheA (RegKey, NULL, g_OpenSam, TRUE);
    if (Key) {
        TRACK_KEYA (Key, RegKey);
        return Key;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = _mbsrchr (RegKey, '\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheA (RegKey, lastWack, g_OpenSam, FALSE);
        if (parentKey) {
            Key = OpenRegKeyWorkerA (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheA (RegKey, Key, g_OpenSam);
            return Key;
        }
    }

    //
    // Not in cache; use full api
    //

    DEBUGMSGA ((DBG_REG, "Opening %s", RegKey));

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKeyA (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = OpenRegKeyWorkerA (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);

    if (Key) {
        RegAddKeyToCacheA (RegKey, Key, g_OpenSam);
        RegRecordParentInCacheA (RegKey, lastWack);
    }

    return Key;
}


HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;
    HKEY parentKey;
    PCWSTR lastWack;

    //
    // Attempt to use cache
    //

    Key = RegGetKeyFromCacheW (RegKey, NULL, g_OpenSam, TRUE);
    if (Key) {
        TRACK_KEYW (Key, RegKey);
        return Key;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = wcsrchr (RegKey, L'\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheW (RegKey, lastWack, g_OpenSam, FALSE);
        if (parentKey) {
            Key = OpenRegKeyWorkerW (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheW (RegKey, Key, g_OpenSam);
            return Key;
        }
    }

    //
    // Not in cache; use full api
    //

    DEBUGMSGW ((DBG_REG, "Opening %s", RegKey));

    RootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKeyW (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = OpenRegKeyWorkerW (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);

    if (Key) {
        RegAddKeyToCacheW (RegKey, Key, g_OpenSam);
        RegRecordParentInCacheW (RegKey, lastWack);
    }

    return Key;
}

BOOL
DeleteRegKeyA (
    IN      HKEY Key,
    IN      PCSTR SubKey
    )
{
    DWORD rc;

    rc = RegDeleteKeyA (Key, SubKey);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    return TRUE;
}

BOOL
DeleteRegKeyW (
    IN      HKEY Key,
    IN      PCWSTR SubKey
    )
{
    DWORD rc;

    rc = RegDeleteKeyW (Key, SubKey);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    return TRUE;
}

BOOL
DeleteRegKeyStrA (
    IN      PCSTR RegKey
    )
{
    DWORD End;
    HKEY RootKey;
    BOOL result = FALSE;

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!RegKey[End]) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    result = DeleteRegKeyA (RootKey, &RegKey[End]);

    if (result) {
        // if we have this in the cache we need to
        // remove it from there so subsequent open
        // will fail.
        RegRemoveItemFromCacheA (RegKey);
    }

    return result;
}

BOOL
DeleteRegKeyStrW (
    IN      PCWSTR RegKey
    )
{
    DWORD End;
    HKEY RootKey;
    BOOL result = FALSE;

    RootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!RootKey) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!RegKey[End]) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    result = DeleteRegKeyW (RootKey, &RegKey[End]);

    if (result) {
        // if we have this in the cache we need to
        // remove it from there so subsequent open
        // will fail.
        RegRemoveItemFromCacheW (RegKey);
    }

    return result;
}

BOOL
DeleteEmptyRegKeyStrA (
    IN      PCSTR RegKey
    )
{
    LONG rc;
    DWORD subKeys;
    DWORD values;
    HKEY key;

    key = OpenRegKeyStrA (RegKey);
    if (!key) {
        return TRUE;
    }

    rc = RegQueryInfoKey (key, NULL, NULL, NULL, &subKeys, NULL, NULL, &values, NULL, NULL, NULL, NULL);

    CloseRegKey (key);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    if (subKeys || values) {
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }

    return DeleteRegKeyStrA (RegKey);
}

BOOL
DeleteEmptyRegKeyStrW (
    IN      PCWSTR RegKey
    )
{
    LONG rc;
    DWORD subKeys;
    DWORD values;
    HKEY key;

    key = OpenRegKeyStrW (RegKey);
    if (!key) {
        return TRUE;
    }

    rc = RegQueryInfoKey (key, NULL, NULL, NULL, &subKeys, NULL, NULL, &values, NULL, NULL, NULL, NULL);

    CloseRegKey (key);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    if (subKeys || values) {
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }

    return DeleteRegKeyStrW (RegKey);
}

PVOID
MemAllocWrapper (
    IN      DWORD Size
    )

/*++

Routine Description:

  pemAllocWrapper implements a default allocation routine.  The APIs
  that have a "2" at the end allow the caller to supply an alternative
  allocator or deallocator.  The routines without the "2" use this
  default allocator.

Arguments:

  Size - Specifies the amount of memory (in bytes) to allocate

Return Value:

  A pointer to a block of memory that can hold Size bytes, or NULL
  if allocation fails.

--*/

{
    return MemAlloc (g_hHeap, 0, Size);
}


VOID
MemFreeWrapper (
    IN      PCVOID Mem
    )

/*++

Routine Description:

  MemFreeWrapper implements a default deallocation routine.
  See MemAllocWrapper above.

Arguments:

  Mem - Specifies the block of memory to free, and was allocated by the
        MemAllocWrapper function.

Return Value:

  none

--*/

{
    MemFree (g_hHeap, 0, Mem);
}


/*++

Routine Description:

  GetRegValueData2A and GetRegValueData2W query a registry value and
  return the data as a pointer.  They use the specified Alloc and Free
  routines to allocate and free the memory as needed.

  A GetRegValueData macro is defined, and it uses the default allocators,
  simplifying the function parameters and allowing the caller to free
  the return value via MemFree.

Arguments:

  hKey  - Specifies the registry key that holds the specified value.

  Value - Specifies the value name to query.

  Alloc - Specifies the allocation routine, called to allocate a block of
          memory for the return data.

  FreeRoutine  - Specifies the deallocation routine, called if an error is encountered
          during processing.

Return Value:

  A pointer to the data retrieved, or NULL if the value does not exist or an
  error occurred.  Call GetLastError to obtian the failure code.

--*/

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = RegQueryValueExA (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof (CHAR));
    rc = RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PSTR) DataBuf + BufSize) = 0;
        return DataBuf;
    }

    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize = 0;
    PBYTE DataBuf;

    rc = RegQueryValueExW (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }


    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


/*++

Routine Description:

  GetRegValueDataOfType2A and GetRegValueDataOfType2W are extensions of
  GetRegValueData.  They only return a data pointer when the data stored
  in the registry value is the correct type.

Arguments:

  hKey - Specifies the registry key to query

  Value - Specifies the value name to query

  MustBeType - Specifies the type of data (a REG_* constant).  If the specified
               value has data but is a different type, NULL will be returned.

  AllocRoutine - Specifies the allocation routine, called to allocate the return data.

  FreeRoutine - Specifies the deallocation routine, called when an error is encountered.

Return Value:

  If successful, returns a pointer to data that matches the specified type.
  If the data is a different type, the value name does not exist, or an
  error occurs during the query, NULL is returned, and the failure code
  can be obtained from GetLastError.

--*/


PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize = 0;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExA (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    switch (MustBeType) {

    case REG_SZ:
    case REG_EXPAND_SZ:
        if (Type == REG_SZ) {
            break;
        }
        if (Type == REG_EXPAND_SZ) {
            break;
        }
        return NULL;

    default:
        if (Type == MustBeType) {
            break;
        }
        return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof (WORD));
    rc = RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWORD) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    MYASSERT (FALSE);   //lint !e506
    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExW (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }
    switch (MustBeType) {
        case REG_SZ:
        case REG_EXPAND_SZ:
            if (Type == REG_SZ) break;
            if (Type == REG_EXPAND_SZ) break;
            return NULL;
        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
            if (Type == REG_DWORD) break;
            if (Type == REG_DWORD_BIG_ENDIAN) break;
            return NULL;
        default:
            if (Type == MustBeType) break;
            return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    MYASSERT (FALSE);   //lint !e506
    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size = 0;

    rc = RegQueryValueExA (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size;

    rc = RegQueryValueExW (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  GetRegKeyData2A and GetRegKeyData2W return default data associated
  with a registry key.  They open the specified subkey, query the value,
  close the subkey and return the data.

Arguments:

  Parent - Specifies the key that contains SubKey.

  SubKey - Specifies the name of the subkey to obtain the default value for.

  AllocRoutine  - Specifies the allocation routine, called to allocate a block of
           memory for the registry data.

  FreeRoutine   - Specifies the deallocation routine, called to free the block of
           data if an error occurs.

Return Value:

  A pointer to the block of data obtained from the subkey's default value,
  or NULL if the subkey does not exist or an error was encountered.  Call
  GetLastError for a failure code.

--*/

PBYTE
GetRegKeyData2A (
    IN      HKEY Parent,
    IN      PCSTR SubKey,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyA (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2A (SubKeyHandle, "", AllocRoutine, FreeRoutine);

    CloseRegKey (SubKeyHandle);

    return Data;
}


PBYTE
GetRegKeyData2W (
    IN      HKEY Parent,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyW (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2W (SubKeyHandle, L"", AllocRoutine, FreeRoutine);

    CloseRegKey (SubKeyHandle);

    return Data;
}


/*++

Routine Description:

  GetRegData2A and GetRegData2W open a registry key, query a value,
  close the registry key and return the value.

Arguments:

  KeyString - Specifies the registry key to open

  ValueName - Specifies the value to query

  AllocRoutine - Specifies the allocation routine, used to allocate a block of
          memory to hold the value data

  FreeRoutine  - Specifies the deallocation routine, used to free the block of
          memory when an error is encountered.

Return Value:

  A pointer to the registry data retrieved, or NULL if the key or value
  does not exist, or if an error occurs. Call GetLastError for a failure code.

--*/

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrA (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2A (Key, ValueName, AllocRoutine, FreeRoutine);

    CloseRegKey (Key);

    return Data;
}


PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrW (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2W (Key, ValueName, AllocRoutine, FreeRoutine);

    CloseRegKey (Key);

    return Data;
}


BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    )
/*++

Routine Description:

  GetRegSubkeysCount retrieves the number of subkeys of a given parent key.

Arguments:

  ParentKey - Specifies a handle to the parent registry key.

  SubKeyCount - Receives the number of subkeys

  MaxSubKeyLen - Receives the length, in chars, of the longest subkey string

Return Value:

  TRUE if the count was retrieved successfully, FALSE otherwise.
  In this case, call GetLastError for a failure code.

--*/

{
    LONG rc;

    rc = RegQueryInfoKey (
                ParentKey,
                NULL,
                NULL,
                NULL,
                SubKeyCount,
                MaxSubKeyLen,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  CreateRegKeyA and CreateRegKeyW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the new key.

  NewKeyName - Specifies the name of the subkey to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
pCreateRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = OurRegCreateKeyExA (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = pCreateRegKeyWorkerA (ParentKey, NewKeyName /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheA ("", result, g_CreateSam);

    return result;
}

HKEY
pCreateRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = OurRegCreateKeyExW (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = pCreateRegKeyWorkerW (ParentKey, NewKeyName /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheW (L"", result, g_CreateSam);

    return result;
}

/*++

Routine Description:

  CreateRegKeyStrA and CreateRegKeyStrW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  NewKeyName - Specifies the full path to the key to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    DWORD DontCare;
    CHAR RegKey[MAX_REGISTRY_KEYA];
    PCSTR Start;
    PCSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;
    PCSTR lastWack;
    HKEY parentKey;

    //
    // Attempt to use cache
    //

    NewKey = RegGetKeyFromCacheA (NewKeyName, NULL, g_CreateSam, TRUE);
    if (NewKey) {
        TRACK_KEYA (NewKey, NewKeyName);
        return NewKey;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = _mbsrchr (NewKeyName, '\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheA (NewKeyName, lastWack, g_CreateSam, FALSE);
        if (parentKey) {
            NewKey = pCreateRegKeyWorkerA (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheA (NewKeyName, NewKey, g_CreateSam);
            return NewKey;
        }
    }

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyA (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        OurRegOpenRootKeyA (Parent, NewKeyName/* , */ DEBUG_TRACKING_ARGS);
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = _mbschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringA (Start);
        }

        StringCopyABA (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) { //lint !e613
            rc = OurRegOpenKeyExA (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     DEBUG_TRACKING_ARGS
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = OurRegCreateKeyExA (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    DEBUG_TRACKING_ARGS
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError ((DWORD)rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) { //lint !e613
            Start = _mbsinc (Start);
        }

    } while (*Start);   //lint !e613

    if (Parent) {
        RegAddKeyToCacheA (NewKeyName, Parent, g_CreateSam);
        RegRecordParentInCacheA (NewKeyName, lastWack);
    }

    return Parent;
}


HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    DWORD DontCare;
    WCHAR RegKey[MAX_REGISTRY_KEYW];
    PCWSTR Start;
    PCWSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;
    PCWSTR lastWack;
    HKEY parentKey;

    //
    // Attempt to use cache
    //

    NewKey = RegGetKeyFromCacheW (NewKeyName, NULL, g_CreateSam, TRUE);
    if (NewKey) {
        TRACK_KEYW (NewKey, NewKeyName);
        return NewKey;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = wcsrchr (NewKeyName, L'\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheW (NewKeyName, lastWack, g_CreateSam, FALSE);
        if (parentKey) {
            NewKey = pCreateRegKeyWorkerW (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheW (NewKeyName, NewKey, g_CreateSam);
            return NewKey;
        }
    }

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyW (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        OurRegOpenRootKeyW (Parent, NewKeyName/* , */ DEBUG_TRACKING_ARGS);
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = wcschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringW (Start);
        }

        StringCopyABW (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) {
            rc = OurRegOpenKeyExW (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     DEBUG_TRACKING_ARGS
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = OurRegCreateKeyExW (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    DEBUG_TRACKING_ARGS
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError ((DWORD)rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) {
            Start++;
        }
    } while (*Start);

    if (Parent) {
        RegAddKeyToCacheW (NewKeyName, Parent, g_CreateSam);
        RegRecordParentInCacheW (NewKeyName, lastWack);
    }

    return Parent;
}


/*++

Routine Description:

  OpenRegKeyA and OpenRegKeyW open a subkey.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the subkey.

  KeyToOpen - Specifies the name of the subkey to open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
OpenRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY SubKey;
    LONG rc;

    rc = OurRegOpenKeyExA (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen            OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = OpenRegKeyWorkerA (ParentKey, KeyToOpen /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheA ("", result, g_OpenSam);

    return result;
}


HKEY
OpenRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;

    rc = OurRegOpenKeyExW (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen           OPTIONAL
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = OpenRegKeyWorkerW (ParentKey, KeyToOpen /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheW (L"", result, g_OpenSam);

    return result;
}


LONG
CloseRegKeyWorker (
    IN      HKEY Key
    )
{
    LONG rc = ERROR_INVALID_HANDLE;

    if (!Key) {
        return ERROR_SUCCESS;
    }

    if (GetOffsetOfRootKey (Key)) {
        return ERROR_SUCCESS;
    }

    __try {
        rc = RegCloseKey (Key);
    }
    __except (TRUE) {
        DEBUGMSG ((DBG_WHOOPS, "RegCloseKey threw an exception!"));
    }

    MYASSERT (rc == ERROR_SUCCESS);

    return rc;
}


LONG
RealCloseRegKey (
    IN      HKEY Key
    )

/*++

Routine Description:

  RealCloseRegKey closes the reg handle supplied, unless the handle is
  a pre-defined Win32 handle.  The CloseRegKey macro resolves directly
  to this function in the free build, and to OurCloseRegKey in the
  checked build.

Arguments:

  Key       - Specifies the reg handle to close

Return Value:

  A standard Win32 error code indicating outcome.

--*/

{
    if (RegDecrementRefCount (Key)) {
        //
        // Key is in the cache; don't call CloseRegKeyWorker. This will
        // be done by the cache code.
        //

        return ERROR_SUCCESS;
    }

    return CloseRegKeyWorker (Key);
}


/*++

Routine Description:

  GetOffsetOfRootString returns a non-zero offset to the g_RegRoots table
  below.  The offset can be used with GetRootStringFromOffset and
  GetRootKeyFromOffset.

Arguments:

  RootString    - A pointer to a string containing the path to a registry key
  LengthPtr     - A pointer to a variable that receives the length of the
                  registry root, including the joining backslash if it exists.

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if RootString does not
  contain a registry root.

--*/

typedef struct {
    PCSTR   RootText;
    PCWSTR  WideRootText;
    UINT    TextLength;
    HKEY    RootKey;
} REGISTRYROOT, *PREGISTRYROOT;

static
REGISTRYROOT g_RegRoots[] = {
    "HKR",                     L"HKR",                     3, HKEY_ROOT,
    "HKEY_ROOT",               L"HKEY_ROOT",               9, HKEY_ROOT,
    "HKLM",                    L"HKLM",                    4, HKEY_LOCAL_MACHINE,
    "HKEY_LOCAL_MACHINE",      L"HKEY_LOCAL_MACHINE",     18, HKEY_LOCAL_MACHINE,
    "HKU",                     L"HKU",                     3, HKEY_USERS,
    "HKEY_USERS",              L"HKEY_USERS",             10, HKEY_USERS,
    "HKCU",                    L"HKCU",                    4, HKEY_CURRENT_USER,
    "HKEY_CURRENT_USER",       L"HKEY_CURRENT_USER",      17, HKEY_CURRENT_USER,
    "HKCC",                    L"HKCC",                    4, HKEY_CURRENT_CONFIG,
    "HKEY_CURRENT_CONFIG",     L"HKEY_CURRENT_CONFIG",    19, HKEY_CURRENT_CONFIG,
    "HKCR",                    L"HKCR",                    4, HKEY_CLASSES_ROOT,
    "HKEY_CLASSES_ROOT",       L"HKEY_CLASSES_ROOT",      17, HKEY_CLASSES_ROOT,
    "HKDD",                    L"HKDD",                    4, HKEY_DYN_DATA,
    "HKEY_DYN_DATA",           L"HKEY_DYN_DATA",          13, HKEY_DYN_DATA,
    NULL,                      NULL,                       0, NULL
};

#define REGROOTS    14

INT
GetOffsetOfRootStringA (
    IN      PCSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    MBCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (StringIMatchCharCountA (
                RootString,
                g_RegRoots[i].RootText,
                g_RegRoots[i].TextLength
                )) {

            c = _mbsgetc (RootString, g_RegRoots[i].TextLength);
            if (c && c != '\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}

INT
GetOffsetOfRootStringW (
    IN      PCWSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    WCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (!_wcsnicmp (RootString, g_RegRoots[i].WideRootText,
                        g_RegRoots[i].TextLength)
            ) {
            c = _wcsgetc (RootString, g_RegRoots[i].TextLength);
            if (c && c != L'\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetOffsetOfRootKey returns a non-zero offset to the g_RegRoots table
  corresponding to the root that matches the supplied HKEY.  This offset
  can be used with GetRootStringFromOffset and GetRootKeyFromOffset.

Arguments:

  RootKey   - Supplies the handle to locate in g_RegRoots table

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if the handle is not
  a registry root.

--*/

INT
GetOffsetOfRootKey (
    IN      HKEY RootKey
    )
{
    INT i;

    if (RootKey == g_Root) {
        return 1;
    }

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (g_RegRoots[i].RootKey == RootKey) {
            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetRootStringFromOffset and GetRootKeyFromOffset return a pointer to a
  static string or HKEY, respectively.  If the offset supplied is invalid,
  these functions return NULL.

Arguments:

  i - The offset as returned by GetOffsetOfRootString or GetOffsetOfRootKey

Return Value:

  A pointer to a static string/HKEY, or NULL if offset is invalid

--*/

PCSTR
GetRootStringFromOffsetA (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].RootText;
}

PCWSTR
GetRootStringFromOffsetW (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].WideRootText;
}

HKEY
GetRootKeyFromOffset (
    IN      INT i
    )
{
    HKEY Ret;

    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    Ret = g_RegRoots[i - 1].RootKey;
    if (Ret == HKEY_ROOT) {
        Ret = g_Root;
    }

    return Ret;
}


/*++

Routine Description:

  ConvertRootStringToKey converts a registry key path's root to an HKEY.

Arguments:

  RegPath   - A pointer to a registry string that has a root at the begining
  LengthPtr - An optional pointer to a variable that receives the length of
              the root, including the joining backslash if it exists.

Return Value:

  A handle to the registry key, or NULL if RegPath does not have a root

--*/

HKEY
ConvertRootStringToKeyA (
    PCSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringA (RegPath, LengthPtr));
}

HKEY
ConvertRootStringToKeyW (
    PCWSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringW (RegPath, LengthPtr));
}


/*++

Routine Description:

  ConvertKeyToRootString converts a root HKEY to a registry root string

Arguments:

  RegRoot   - A handle to a registry root

Return Value:

  A pointer to a static string, or NULL if RegRoot is not a valid registry
  root handle

--*/

PCSTR
ConvertKeyToRootStringA (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetA (GetOffsetOfRootKey (RegRoot));
}

PCWSTR
ConvertKeyToRootStringW (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetW (GetOffsetOfRootKey (RegRoot));
}



/*++

Routine Description:

  CreateEncodedRegistryStringEx is used to create a registry string in the format commonly
  expected by w95upg reg routines. This format is:

    EncodedKey\[EncodedValue]

  Encoding is used to safely represent "special" characters
    (such as MBS chars and certain punctuation marks.)

  The [EncodedValue] part will exist only if Value is non null.

Arguments:

    Key - Contains an unencoded registry key.
    Value - Optionally contains an unencoded registry value.
    Tree - Specifies that the registry key refers to the entire key

Return Value:

    Returns a pointer to the encoded registry string, or NULL if there was an error.

--*/

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    )
{
    PSTR    rEncodedString = NULL;
    DWORD   requiredSize;
    PSTR    end;

    //
    // Determine required size and allocate buffer large enough to hold
    // the encoded string.
    //
    requiredSize    = SizeOfStringA(Key)*6 + (Value ? SizeOfStringA(Value)*6 : 0) + 10;
    rEncodedString  = AllocPathStringA(requiredSize);

    //
    // Encode the key portion of the string.
    //
    EncodeRuleCharsA(rEncodedString, Key);

    //
    // Finally, if a value exists, append it in encoded form. If a value does not exist,
    // then add an '*' to the line.
    //
    if (Value) {

        StringCopyA (AppendWackA (rEncodedString), "[");
        end = GetEndOfStringA (rEncodedString);
        EncodeRuleCharsA(end, Value);
        StringCatA(end, "]");

    } else if (Tree) {
        StringCopyA (AppendWackA (rEncodedString), "*");
    }

    return rEncodedString;
}


PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    )
{
    PWSTR   rEncodedString = NULL;
    DWORD   requiredSize;
    PWSTR   end;

    //
    // Determine required size and allocate buffer large enough to hold
    // the encoded string.
    //
    requiredSize    = SizeOfStringW(Key)*6 + (Value ? SizeOfStringW(Value)*6 : 0) + 10;
    rEncodedString  = AllocPathStringW(requiredSize);
    if (!rEncodedString) {
        return NULL;
    }

    //
    // Encode the key portion of the string.
    //
    EncodeRuleCharsW(rEncodedString, Key);

    //
    // Finally, if a value exists, append it in encoded form.
    // If a value doesn't exist, add na '*' to the line.
    //
    if (Value) {

        StringCopyW (AppendWackW (rEncodedString), L"[");
        end = GetEndOfStringW (rEncodedString);
        if (!end) {
            // we should never get here
            return NULL;
        }
        EncodeRuleCharsW(end, Value);
        StringCatW(end, L"]");
    } else if (Tree) {
        StringCopyW (AppendWackW (rEncodedString), L"*");
    }

    return rEncodedString;
}


/*++

Routine Description:

    FreeEncodedRegistryString frees the memory allocated by a call to CreateEncodedRegistryString.

Arguments:

    None.


Return Value:

    None.

--*/
VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    )
{
    FreePathStringA(RegString);
}


VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    )
{
    FreePathStringW(RegString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\reg\regtrack.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  regtrack.c

Abstract:

  Routines to track calls to registry APIs.  Used for debugging only.

Author:

  Jim Schmidt (jimschm)  02-Sept-1997

Revisions:

  marcw       2-Sep-1999  Moved over from Win9xUpg project.

--*/


#include "pch.h"
#include "regp.h"

#ifdef DEBUG


#undef RegOpenKeyExA
#undef RegCreateKeyExA
#undef RegOpenKeyExW
#undef RegCreateKeyExW

#define DBG_REGTRACK "RegTrack"

#define NO_MATCH        0xffffffff

DWORD g_DontCare;

typedef struct {
    PCSTR File;
    DWORD Line;
    HKEY Key;
    CHAR SubKey[];
} KEYTRACK, *PKEYTRACK;

GROWLIST g_KeyTrackList = INIT_GROWLIST;
extern INT g_RegRefs;

DWORD
pFindKeyReference (
    HKEY Key
    )
{
    INT i;
    DWORD Items;
    PKEYTRACK KeyTrack;

    Items = GlGetSize (&g_KeyTrackList);

    for (i = (INT) (Items - 1) ; i >= 0 ; i--) {
        KeyTrack = (PKEYTRACK) GlGetItem (&g_KeyTrackList, (DWORD) i);

        if (KeyTrack && KeyTrack->Key == Key) {
            return (DWORD) i;
        }
    }

    return NO_MATCH;
}

VOID
AddKeyReferenceA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PKEYTRACK KeyTrack;
    DWORD Size;

    MYASSERT (g_RegRefs > 0);

    Size = sizeof (KEYTRACK) + SizeOfStringA (SubKey);

    KeyTrack = (PKEYTRACK) MemAlloc (g_hHeap, 0, Size);
    KeyTrack->Key = Key;
    KeyTrack->File = File;
    KeyTrack->Line = Line;
    StringCopyA (KeyTrack->SubKey, SubKey);

    (VOID)GlAppend (&g_KeyTrackList, (PBYTE) KeyTrack, Size);

    MemFree (g_hHeap, 0, KeyTrack);
}

VOID
AddKeyReferenceW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    PCSTR AnsiSubKey;

    MYASSERT (g_RegRefs > 0);

    AnsiSubKey = ConvertWtoA (SubKey);
    AddKeyReferenceA (Key, AnsiSubKey, File, Line);
    FreeConvertedStr (AnsiSubKey);
}

BOOL
pDelKeyReference (
    HKEY Key
    )
{
    DWORD Index;

    Index = pFindKeyReference (Key);
    if (Index != NO_MATCH) {
        GlDeleteItem (&g_KeyTrackList, Index);
        return TRUE;
    }

    return FALSE;
}

VOID
DumpOpenKeys (
    VOID
    )
{
    DWORD d;
    DWORD Items;
    PKEYTRACK KeyTrack;

    RegTerminateCache();

    Items = GlGetSize (&g_KeyTrackList);

    if (Items) {
        DEBUGMSG ((DBG_ERROR, "Unclosed reg keys: %u", Items));
    }

    for (d = 0 ; d < Items ; d++) {
        KeyTrack = (PKEYTRACK) GlGetItem (&g_KeyTrackList, d);
        DEBUGMSG ((DBG_REGTRACK, "Open Key: %hs (%hs line %u)", KeyTrack->SubKey, KeyTrack->File, KeyTrack->Line));
    }

    GlFree (&g_KeyTrackList);
}

VOID
RegTrackTerminate (
    VOID
    )
{
    GlFree (&g_KeyTrackList);
}

VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    AddKeyReferenceA (Key, SubKey, File, Line);
}


VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    )
{
    AddKeyReferenceW (Key, SubKey, File, Line);
}


LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExA (Key, SubKey, Unused, SamMask, ResultPtr);
    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegOpenKeyExW (Key, SubKey, Unused, SamMask, ResultPtr);

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RealCloseRegKey (Key);
    if (rc == ERROR_SUCCESS) {
        if (!pDelKeyReference (Key)) {
            DEBUGMSG ((
                DBG_ERROR,
                "Reg key handle closed via CloseRegKey, but not opened "
                    "with a tracked registry API.  %s line %u",
                File,
                Line
                ));
        }
    }

    return rc;
}


LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExA (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceA (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    LPSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    )
{
    LONG rc;

    rc = RegCreateKeyExW (
            Key,
            SubKey,
            Reserved,
            Class,
            Options,
            SamMask,
            SecurityAttribs,
            ResultPtr,
            DispositionPtr
            );

    if (rc == ERROR_SUCCESS) {
        AddKeyReferenceW (*ResultPtr, SubKey, File, Line);
    }

    return rc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\version\version.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    version.c

Abstract:

    Implements a set of enumeration routines to access version
    information from a Win32 binary.

Author:

    Jim Schmidt (jimschm) 03-Dec-1997

Revision History:

    calinn      03-Sep-1999 Moved over from Win9xUpg project.

--*/

//
// Includes
//

#include "pch.h"

//
// Debug constants
//

#define DBG_VERSION     "VerAPI"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PCSTR g_DefaultTranslationsA[] = {
    "04090000",
    "040904E4",
    "040904B0",
    NULL
};

PCWSTR g_DefaultTranslationsW[] = {
    L"04090000",
    L"040904E4",
    L"040904B0",
    NULL
};

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

PCSTR
pVrEnumValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
pVrEnumValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

PCSTR
pVrEnumNextTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    );

PCWSTR
pVrEnumNextTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    );

//
// Macro expansion definition
//

// None

//
// Code
//


/*++

Routine Description:

  VrCreateEnumStructA and VrCreateEnumStructW are called to load a version
  structure from a file and to obtain the fixed version stamp info that is
  language-independent.

  The caller must call VrDestroyEnumStruct after the VrValueEnum is no
  longer needed.

Arguments:

  VrValueEnum - Receives the version stamp info to be used by other
                functions in this module

  FileSpec    - Specifies the file to obtain version information from

Return Value:

  TRUE if the routine was able to get version info, or FALSE if an
  error occurred.

--*/

BOOL
VrCreateEnumStructA (
    OUT     PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR FileSpec
    )
{
    //
    // Initialize the structure
    //

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMA));
    VrValueEnum->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VrValueEnum->Size = GetFileVersionInfoSizeA (
                                (PSTR) FileSpec,
                                &VrValueEnum->Handle
                                );

    if (!VrValueEnum->Size) {
        DEBUGMSG ((DBG_VERSION, "File %s does not have version information", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VrValueEnum->VersionBuffer = GbGrow (&VrValueEnum->GrowBuf, VrValueEnum->Size * 2);

    if (!VrValueEnum->VersionBuffer) {
        return FALSE;
    }

    VrValueEnum->StringBuffer = VrValueEnum->GrowBuf.Buf + VrValueEnum->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoA (
             (PSTR) FileSpec,
             VrValueEnum->Handle,
             VrValueEnum->Size,
             VrValueEnum->VersionBuffer
             )) {
        VrDestroyEnumStructA (VrValueEnum);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueA (
        VrValueEnum->VersionBuffer,
        "\\",
        &VrValueEnum->FixedInfo,
        &VrValueEnum->FixedInfoSize
        );

    return TRUE;
}

BOOL
VrCreateEnumStructW (
    OUT     PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR FileSpec
    )
{
    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMW));
    VrValueEnum->FileSpec = FileSpec;

    //
    // Allocate enough memory for the version stamp
    //

    VrValueEnum->Size = GetFileVersionInfoSizeW (
                                (PWSTR) FileSpec,
                                &VrValueEnum->Handle
                                );

    if (!VrValueEnum->Size) {
        DEBUGMSG ((DBG_VERSION, "File %S does not have version info", FileSpec));
        return FALSE;
    }

    //
    // fix for version info bug:
    // allocate both buffers at once; this way the first buffer will not point to invalid
    // memory when a reallocation occurs because of the second grow
    //
    VrValueEnum->VersionBuffer = GbGrow (&VrValueEnum->GrowBuf, VrValueEnum->Size * 2);

    if (!VrValueEnum->VersionBuffer) {
        return FALSE;
    }

    VrValueEnum->StringBuffer = VrValueEnum->GrowBuf.Buf + VrValueEnum->Size;

    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfoW (
             (PWSTR) FileSpec,
             VrValueEnum->Handle,
             VrValueEnum->Size,
             VrValueEnum->VersionBuffer
             )) {
        VrDestroyEnumStructW (VrValueEnum);
        return FALSE;
    }

    //
    // Extract the fixed info
    //

    VerQueryValueW (
        VrValueEnum->VersionBuffer,
        L"\\",
        &VrValueEnum->FixedInfo,
        &VrValueEnum->FixedInfoSize
        );

    return TRUE;
}


/*++

Routine Description:

  VrDestroyEnumStructA and VrDestroyEnumStructW cleans up all memory
  allocated by the routines in this module.

Arguments:

  VrValueEnum - Specifies the structure to clean up

Return Value:

  none

--*/

VOID
VrDestroyEnumStructA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )
{
    //
    // Clean up all allocations made by any routine using
    // the VrValueEnum
    //

    if (VrValueEnum->GrowBuf.Buf) {
        GbFree (&VrValueEnum->GrowBuf);
    }

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMA));
}

VOID
VrDestroyEnumStructW (
    IN      PVRVALUE_ENUMW VrValueEnum
    )
{
    //
    // Clean up all allocations made by any routine using
    // the VrValueEnum
    //

    if (VrValueEnum->GrowBuf.Buf) {
        GbFree (&VrValueEnum->GrowBuf);
    }

    ZeroMemory (VrValueEnum, sizeof (VRVALUE_ENUMW));
}


/*++

Routine Description:

  pVrEnumFirstTranslationA and pVrEnumFirstTranslationW return the translation
  string needed to access the string table of a version stamp.

Arguments:

  VrValueEnum - Specifies the structure that has been initialized
                by VrCreateEnumStruct.

Return Value:

  A pointer to a string specifying the first translation, or
  NULL if no translations exist.

--*/

PCSTR
pVrEnumFirstTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    UINT arraySize;

    //
    // Query version block for array of code pages/languages
    //

    if (!VerQueryValueA (
            VrValueEnum->VersionBuffer,
            "\\VarFileInfo\\Translation",
            &VrValueEnum->Translations,
            &arraySize
            )) {
        //
        // No translations are available
        //

        arraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VrValueEnum->CurrentDefaultTranslation = 0;
    VrValueEnum->MaxTranslations = arraySize / sizeof (TRANSLATION);
    VrValueEnum->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VrValueEnum->MaxTranslations == 0,
        DBG_VERSION,
        "File %s has no translations",
        VrValueEnum->FileSpec
        ));

    return pVrEnumNextTranslationA (VrValueEnum);
}

PCWSTR
pVrEnumFirstTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    UINT arraySize;

    //
    // Query version block for array of code pages/languages
    //

    if (!VerQueryValueW (
            VrValueEnum->VersionBuffer,
            L"\\VarFileInfo\\Translation",
            &VrValueEnum->Translations,
            &arraySize
            )) {
        //
        // No translations are available
        //

        arraySize = 0;
    }

    //
    // Return a pointer to the first translation
    //

    VrValueEnum->CurrentDefaultTranslation = 0;
    VrValueEnum->MaxTranslations = arraySize / sizeof (TRANSLATION);
    VrValueEnum->CurrentTranslation = 0;

    DEBUGMSG_IF ((
        VrValueEnum->MaxTranslations == 0,
        DBG_VERSION,
        "File %S has no translations",
        VrValueEnum->FileSpec
        ));

    return pVrEnumNextTranslationW (VrValueEnum);
}


/*++

Routine Description:

  pIsDefaultTranslationA and pIsDefaultTranslationW return TRUE
  if the specified translation string is enumerated by default.
  These routines stops multiple enumeration of the same
  translation string.

Arguments:

  TranslationStr - Specifies the translation string to test

Return Value:

  TRUE if the translation string is the same as a default translation
  string, or FALSE if it is not.

--*/

BOOL
pIsDefaultTranslationA (
    IN      PCSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslationsA[i] ; i++) {
        if (StringIMatchA (TranslationStr, g_DefaultTranslationsA[i])) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
pIsDefaultTranslationW (
    IN      PCWSTR TranslationStr
    )
{
    INT i;

    for (i = 0 ; g_DefaultTranslationsW[i] ; i++) {
        if (StringIMatchW (TranslationStr, g_DefaultTranslationsW[i])) {
            return TRUE;
        }
    }
    return FALSE;
}


/*++

Routine Description:

  pVrEnumNextTranslationA and pVrEnumNextTranslationW continue
  the enumeration of translation strings, needed to access the
  string table in a version stamp.

Arguments:

  VrValueEnum - Specifies the same structure passed to
                pVrEnumFirstTranslation.

Return Value:

  A pointer to a string specifying the next translation, or
  NULL if no additional translations exist.

--*/

PCSTR
pVrEnumNextTranslationA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PTRANSLATION translation;

    if (g_DefaultTranslationsA[VrValueEnum->CurrentDefaultTranslation]) {
        //
        // Return default translations first
        //

        StringCopyA (
            VrValueEnum->TranslationStr,
            g_DefaultTranslationsA[VrValueEnum->CurrentDefaultTranslation]
            );

        VrValueEnum->CurrentDefaultTranslation++;

    } else {

        do {
            //
            // Return NULL if all translations have been enumerated
            //

            if (VrValueEnum->CurrentTranslation == VrValueEnum->MaxTranslations) {
                return NULL;
            }

            //
            // Otherwise build translation string and return pointer to it
            //

            translation = &VrValueEnum->Translations[VrValueEnum->CurrentTranslation];

            wsprintfA (
                VrValueEnum->TranslationStr,
                "%04x%04x",
                translation->CodePage,
                translation->Language
                );

            VrValueEnum->CurrentTranslation++;

        } while (pIsDefaultTranslationA (VrValueEnum->TranslationStr));
    }

    return VrValueEnum->TranslationStr;
}

PCWSTR
pVrEnumNextTranslationW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PTRANSLATION translation;

    if (g_DefaultTranslationsW[VrValueEnum->CurrentDefaultTranslation]) {

        StringCopyW (
            VrValueEnum->TranslationStr,
            g_DefaultTranslationsW[VrValueEnum->CurrentDefaultTranslation]
            );

        VrValueEnum->CurrentDefaultTranslation++;

    } else {

        do {
            //
            // Return NULL if all translations have been enumerated
            //

            if (VrValueEnum->CurrentTranslation == VrValueEnum->MaxTranslations) {
                return NULL;
            }

            //
            // Otherwise build translation string and return pointer to it
            //

            translation = &VrValueEnum->Translations[VrValueEnum->CurrentTranslation];

            wsprintfW (
                VrValueEnum->TranslationStr,
                L"%04x%04x",
                translation->CodePage,
                translation->Language
                );

            VrValueEnum->CurrentTranslation++;

        } while (pIsDefaultTranslationW (VrValueEnum->TranslationStr));
    }

    return VrValueEnum->TranslationStr;
}


/*++

Routine Description:

  VrEnumFirstValueA and VrEnumFirstValueW return the first value
  stored in a version stamp for a specific field. If the field
  does not exist, the functions returns NULL.

  An enumeration of VrEnumFirstValue/VrEnumNextValue
  is used to list all localized strings for a field.

Arguments:

  VrValueEnum  - Specifies the structure that was initialized by
                 VrCreateEnumStruct.

  VersionField - Specifies the name of the version field to enumerate

Return Value:

  A pointer to the first value of the field, or NULL if the field does
  not exist.

--*/

PCSTR
VrEnumFirstValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionField
    )
{
    PCSTR result = NULL;

    if (!pVrEnumFirstTranslationA (VrValueEnum)) {
        return NULL;
    }

    VrValueEnum->VersionField = VersionField;

    result = pVrEnumValueA (VrValueEnum);

    if (!result) {
        result = VrEnumNextValueA (VrValueEnum);
    }

    return result;
}

PCWSTR
VrEnumFirstValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionField
    )
{
    PCWSTR result = NULL;

    if (!pVrEnumFirstTranslationW (VrValueEnum)) {
        return NULL;
    }

    VrValueEnum->VersionField = VersionField;

    result = pVrEnumValueW (VrValueEnum);

    if (!result) {
        result = VrEnumNextValueW (VrValueEnum);
    }

    return result;
}


/*++

Routine Description:

  VrEnumNextValueA and VrEnumNextValueW return the next value
  stored in a version stamp for a specific field.

Arguments:

  VrValueEnum - Specifies the same structure passed to VrEnumFirstValue

Return Value:

  A pointer to the next value of the field, or NULL if another field
  does not exist.

--*/

PCSTR
VrEnumNextValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PCSTR result = NULL;

    do {
        if (!pVrEnumNextTranslationA (VrValueEnum)) {
            break;
        }

        result = pVrEnumValueA (VrValueEnum);

    } while (!result);

    return result;
}

PCWSTR
VrEnumNextValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PCWSTR result = NULL;

    do {
        if (!pVrEnumNextTranslationW (VrValueEnum)) {
            break;
        }

        result = pVrEnumValueW (VrValueEnum);

    } while (!result);

    return result;
}


/*++

Routine Description:

  pVrEnumValueA and pVrEnumValueW are routines that obtain
  the value of a version field. They are used for both
  VrEnumFirstValue and VrEnumNextValue.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A pointer to the version value for the current translation, or
  NULL if the value does not exist for the current translation.

--*/

PCSTR
pVrEnumValueA (
    IN OUT  PVRVALUE_ENUMA VrValueEnum
    )
{
    PSTR text;
    UINT stringLen;
    PBYTE string;
    PCSTR result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    text = JoinPathsInPoolExA ((
                NULL,
                "StringFileInfo",
                VrValueEnum->TranslationStr,
                VrValueEnum->VersionField,
                NULL
                ));

    if (!text) {
        return NULL;
    }

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueA (
                VrValueEnum->VersionBuffer,
                text,
                &string,
                &stringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        //
        // Copy value into buffer
        //

        StringCopyByteCountA (VrValueEnum->StringBuffer, (PCSTR) string, stringLen);

        result = (PCSTR)VrValueEnum->StringBuffer;

    }
    __finally {
        FreePathStringA (text);
    }

    return result;
}

PCWSTR
pVrEnumValueW (
    IN OUT  PVRVALUE_ENUMW VrValueEnum
    )
{
    PWSTR text;
    UINT stringLen;
    PBYTE string;
    PCWSTR result = NULL;

    //
    // Prepare sub block for VerQueryValue API
    //

    text = JoinPathsInPoolExW ((
                NULL,
                L"StringFileInfo",
                VrValueEnum->TranslationStr,
                VrValueEnum->VersionField,
                NULL
                ));

    if (!text) {
        return NULL;
    }

    __try {
        //
        // Get the value from the version stamp
        //

        if (!VerQueryValueW (
                VrValueEnum->VersionBuffer,
                text,
                &string,
                &stringLen
                )) {
            //
            // No value is available
            //

            __leave;
        }

        //
        // Copy value into buffer
        //

        CopyMemory (VrValueEnum->StringBuffer, string, stringLen * sizeof (WCHAR));
        VrValueEnum->StringBuffer [stringLen * sizeof (WCHAR)] = 0;
        result = (PWSTR) VrValueEnum->StringBuffer;

    }
    __finally {
        FreePathStringW (text);
    }

    return result;
}

/*++

Routine Description:

  VrCheckVersionValueA and VrCheckVersionValueW return TRUE
  if the version value name specified has the specified version
  value.

Arguments:

  VrValueEnum  - Specifies the structure being processed

  VersionName  - Specifies the version value name.

  VersionValue - Specifies the version value.

Return value:

  TRUE  - the query was successful
  FALSE - the query failed

--*/

BOOL
VrCheckVersionValueA (
    IN      PVRVALUE_ENUMA VrValueEnum,
    IN      PCSTR VersionName,
    IN      PCSTR VersionValue
    )
{
    PCSTR CurrentStr;
    BOOL result = FALSE;

    if ((!VersionName) || (!VersionValue)) {
        return FALSE;
    }

    CurrentStr = VrEnumFirstValueA (VrValueEnum, VersionName);
    while (CurrentStr) {
        CurrentStr = SkipSpaceA (CurrentStr);
        TruncateTrailingSpaceA ((PSTR) CurrentStr);
        if (IsPatternMatchA (VersionValue, CurrentStr)) {
            result = TRUE;
            break;
        }
        CurrentStr = VrEnumNextValueA (VrValueEnum);
    }
    return result;
}

BOOL
VrCheckVersionValueW (
    IN      PVRVALUE_ENUMW VrValueEnum,
    IN      PCWSTR VersionName,
    IN      PCWSTR VersionValue
    )
{
    PCWSTR CurrentStr;
    BOOL result = FALSE;

    if ((!VersionName) || (!VersionValue)) {
        return FALSE;
    }

    CurrentStr = VrEnumFirstValueW (VrValueEnum, VersionName);
    while (CurrentStr) {
        CurrentStr = SkipSpaceW (CurrentStr);
        TruncateTrailingSpaceW ((PWSTR) CurrentStr);
        if (IsPatternMatchW (VersionValue, CurrentStr)) {
            result = TRUE;
            break;
        }
        CurrentStr = VrEnumNextValueW (VrValueEnum);
    }
    return result;
}

ULONGLONG
VrGetBinaryFileVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileVersion returns the FileVersion field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A ULONGLONG FileVersion field

--*/

{
    ULONGLONG result = 0;

    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VrValueEnum->FixedInfo->dwFileVersionLS;
        *(((PDWORD) (&result)) + 1) = VrValueEnum->FixedInfo->dwFileVersionMS;
    }
    return result;
}


ULONGLONG
VrGetBinaryProductVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryProductVersion returns the ProductVersion field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A ULONGLONG ProductVersion field

--*/

{
    ULONGLONG result = 0;

    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        *((PDWORD) (&result)) = VrValueEnum->FixedInfo->dwProductVersionLS;
        *(((PDWORD) (&result)) + 1) = VrValueEnum->FixedInfo->dwProductVersionMS;
    }
    return result;
}


DWORD
VrGetBinaryFileDateLoA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileDateLo returns the LS dword from FileDate field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD, LS dword of the FileDate field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileDateLS;
    }
    return 0;
}


DWORD
VrGetBinaryFileDateHiA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileDateHi returns the MS dword from FileDate field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD, MS dword of the FileDate field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileDateMS;
    }
    return 0;
}


DWORD
VrGetBinaryOsVersionA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryOsVersion returns the FileOS field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD FileOS field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileOS;
    }
    return 0;
}


DWORD
VrGetBinaryFileTypeA (
    IN      PVRVALUE_ENUMA VrValueEnum
    )

/*++

Routine Description:

  VrGetBinaryFileType returns the FileType field from
  the fixed info structure of version information.

Arguments:

  VrValueEnum - Specifies the structure being processed

Return Value:

  A DWORD FileType field

--*/

{
    if (VrValueEnum->FixedInfoSize >= sizeof (VS_FIXEDFILEINFO)) {
        return VrValueEnum->FixedInfo->dwFileType;
    }
    return 0;
}


/*++

Routine Description:

  VrCheckFileVersionA and VrCheckFileVersionW look in the file's version
  structure trying to see if a specific name has a specific value.

Arguments:

  FileName     - File to query for version struct.

  NameToCheck  - Name to query in version structure.

  ValueToCheck - Value to query in version structure.

Return value:

  TRUE  - the query was successful
  FALSE - the query failed

--*/

BOOL
VrCheckFileVersionA (
    IN      PCSTR FileName,
    IN      PCSTR NameToCheck,
    IN      PCSTR ValueToCheck
    )
{
    VRVALUE_ENUMA Version;
    PCSTR CurrentStr;
    BOOL result = FALSE;

    MYASSERT (NameToCheck);
    MYASSERT (ValueToCheck);

    if (VrCreateEnumStructA (&Version, FileName)) {
        __try {
            CurrentStr = VrEnumFirstValueA (&Version, NameToCheck);
            while (CurrentStr) {
                CurrentStr = SkipSpaceA (CurrentStr);
                TruncateTrailingSpaceA ((PSTR) CurrentStr);
                if (IsPatternMatchA (ValueToCheck, CurrentStr)) {
                    result = TRUE;
                    __leave;
                }

                CurrentStr = VrEnumNextValueA (&Version);
            }
        }
        __finally {
            VrDestroyEnumStructA (&Version);
        }
    }
    return result;
}

BOOL
VrCheckFileVersionW (
    IN      PCWSTR FileName,
    IN      PCWSTR NameToCheck,
    IN      PCWSTR ValueToCheck
    )
{
    VRVALUE_ENUMW Version;
    PCWSTR CurrentStr;
    BOOL result = FALSE;

    MYASSERT (NameToCheck);
    MYASSERT (ValueToCheck);

    if (VrCreateEnumStructW (&Version, FileName)) {
        __try {
            CurrentStr = VrEnumFirstValueW (&Version, NameToCheck);
            while (CurrentStr) {
                CurrentStr = SkipSpaceW (CurrentStr);
                TruncateTrailingSpaceW ((PWSTR) CurrentStr);
                if (IsPatternMatchW (ValueToCheck, CurrentStr)) {
                    result = TRUE;
                    __leave;
                }

                CurrentStr = VrEnumNextValueW (&Version);
            }
        }
        __finally {
            VrDestroyEnumStructW (&Version);
        }
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\crcmodel.c ===
/****************************************************************************/
/*							   Start of crcmodel.c							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the implementation (.c) file for the reference 	*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Implementation Notes 													*/
/* -------------------- 													*/
/* To avoid inconsistencies, the specification of each function is not		*/
/* echoed here. See the header file for a description of these functions.	*/
/* This package is light on checking because I want to keep it short and	*/
/* simple and portable (i.e. it would be too messy to distribute my entire	*/
/* C culture (e.g. assertions package) with this package.					*/
/*																			*/
/****************************************************************************/

#include "crcmodel.h"

/****************************************************************************/
/* The following definitions make the code more readable.					*/

#define BITMASK(X) (1L << (X))
#define MASK32 0xFFFFFFFFL
#define LOCAL static

/****************************************************************************/

/* Returns the value v with the bottom b [0,32] bits reflected. */
/* Example: reflect(0x3e23L,3) == 0x3e26						*/

LOCAL ulong reflect(
    ulong v,
    int   b)
{
 int   i;
 ulong t = v;
 for (i=0; i<b; i++)
   {
	if (t & 1L)
	   v|=	BITMASK((b-1)-i);
	else
	   v&= ~BITMASK((b-1)-i);

	t>>=1;

   }
 return v;
}

/****************************************************************************/

/* Returns a longword whose value is (2^p_cm->cm_width)-1.	   */
/* The trick is to do this portably (e.g. without doing <<32). */

LOCAL ulong widmask(p_cm_t p_cm)
{
 return (((1L<<(p_cm->cm_width-1))-1L)<<1)|1L;
}

/****************************************************************************/

void cm_ini (p_cm_t p_cm)
{
 p_cm->cm_reg = p_cm->cm_init;
}

/****************************************************************************/

void cm_nxt(p_cm_t p_cm, int ch)
{
 int   i;
 ulong uch	= (ulong) ch;
 ulong topbit = BITMASK(p_cm->cm_width-1);

 if (p_cm->cm_refin) uch = reflect(uch,8);
 p_cm->cm_reg ^= (uch << (p_cm->cm_width-8));
 for (i=0; i<8; i++)
   {
	if (p_cm->cm_reg & topbit)
	   p_cm->cm_reg = (p_cm->cm_reg << 1) ^ p_cm->cm_poly;
	else
	   p_cm->cm_reg <<= 1;
	p_cm->cm_reg &= widmask(p_cm);
   }
}

/****************************************************************************/

void cm_blk(
p_cm_t	 p_cm,
p_ubyte_ blk_adr,
ulong	 blk_len)
{
 while (blk_len--) cm_nxt(p_cm,*blk_adr++);
}

/****************************************************************************/

ulong cm_crc(p_cm_t p_cm)
{
 if (p_cm->cm_refot)
	return p_cm->cm_xorot ^ reflect(p_cm->cm_reg,p_cm->cm_width);
 else
	return p_cm->cm_xorot ^ p_cm->cm_reg;
}

/****************************************************************************/

ulong cm_tab(p_cm_t p_cm, int index)
{
 int   i;
 ulong r;
 ulong topbit = BITMASK(p_cm->cm_width-1);
 ulong inbyte = (ulong) index;

 if (p_cm->cm_refin) inbyte = reflect(inbyte,8);
 r = inbyte << (p_cm->cm_width-8);
 for (i=0; i<8; i++)
	if (r & topbit)
	   r = (r << 1) ^ p_cm->cm_poly;
	else
	   r<<=1;
 if (p_cm->cm_refin) r = reflect(r,p_cm->cm_width);
 return r & widmask(p_cm);
}

/****************************************************************************/
/*							   End of crcmodel.c							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\utils\reg\tree.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    tree.c

Abstract:

    Implements routines that do operations on entire trees

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

//
// Includes
//

// None

#define DBG_TREE        "Tree"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
RgRemoveAllValuesInKeyA (
    IN      PCSTR KeyToRemove
    )
{
    REGTREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    HKEY deleteHandle;
    REGSAM prevMode;
    LONG rc;

    pattern = ObsBuildEncodedObjectStringExA (KeyToRemove, "*", FALSE);

    if (EnumFirstRegObjectInTreeExA (
            &e,
            pattern,
            FALSE,      // no key names
            TRUE,       // ignored in this case
            TRUE,       // values first
            TRUE,       // depth first
            REGENUM_ALL_SUBLEVELS,
            TRUE,       // use exclusions
            FALSE,      // ReadValueData
            NULL
            )) {

        do {

            MYASSERT (!(e.Attributes & REG_ATTRIBUTE_KEY));

            prevMode = SetRegOpenAccessMode (KEY_ALL_ACCESS);
            deleteHandle = OpenRegKeyStrA (e.Location);
            if (deleteHandle) {
                rc = RegDeleteValueA (deleteHandle, e.Name);
                CloseRegKey (deleteHandle);
                SetRegOpenAccessMode (prevMode);
                if (rc != ERROR_SUCCESS && rc != ERROR_FILE_NOT_FOUND) {
                    SetLastError (rc);
                    AbortRegObjectInTreeEnumA (&e);
                    ObsFreeA (pattern);
                    return FALSE;
                }
            } else {
                SetRegOpenAccessMode (prevMode);
                AbortRegObjectInTreeEnumA (&e);
                ObsFreeA (pattern);
                return FALSE;
            }

        } while (EnumNextRegObjectInTreeA (&e));
    }

    ObsFreeA (pattern);

    return result;
}


BOOL
RgRemoveAllValuesInKeyW (
    IN      PCWSTR KeyToRemove
    )
{
    REGTREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    HKEY deleteHandle;
    REGSAM prevMode;
    LONG rc;

    pattern = ObsBuildEncodedObjectStringExW (KeyToRemove, L"*", FALSE);

    if (EnumFirstRegObjectInTreeExW (
            &e,
            pattern,
            FALSE,      // no key names
            TRUE,       // ignored in this case
            TRUE,       // values first
            TRUE,       // depth first
            REGENUM_ALL_SUBLEVELS,
            TRUE,       // use exclusions
            FALSE,      // ReadValueData
            NULL
            )) {

        do {

            MYASSERT (!(e.Attributes & REG_ATTRIBUTE_KEY));

            prevMode = SetRegOpenAccessMode (KEY_ALL_ACCESS);
            deleteHandle = OpenRegKeyStrW (e.Location);
            if (deleteHandle) {
                rc = RegDeleteValueW (deleteHandle, e.Name);
                CloseRegKey (deleteHandle);
                SetRegOpenAccessMode (prevMode);
                if (rc != ERROR_SUCCESS && rc != ERROR_FILE_NOT_FOUND) {
                    SetLastError (rc);
                    AbortRegObjectInTreeEnumW (&e);
                    ObsFreeW (pattern);
                    return FALSE;
                }
            } else {
                SetRegOpenAccessMode (prevMode);
                AbortRegObjectInTreeEnumW (&e);
                ObsFreeW (pattern);
                return FALSE;
            }

        } while (EnumNextRegObjectInTreeW (&e));
    }

    ObsFreeW (pattern);

    return result;
}


BOOL
pDeleteKeyStrA (
    IN OUT  PSTR *DeleteKey
    )
{
    PSTR p;
    HKEY key;
    LONG rc;

    if (*DeleteKey == NULL) {
        return TRUE;
    }

    p = (PSTR) FindLastWackA (*DeleteKey);
    if (p) {
        *p = 0;
        p++;

        key = OpenRegKeyStrA (*DeleteKey);
        if (key) {

            if (DeleteRegKeyA (key, p)) {
                rc = ERROR_SUCCESS;
            } else {
                rc = GetLastError ();
            }
            CloseRegKey (key);

        } else {
            rc = GetLastError();
        }

        if (rc == ERROR_FILE_NOT_FOUND) {
            rc = ERROR_SUCCESS;
        }

    } else {
        rc = ERROR_SUCCESS;
    }

    FreeTextA (*DeleteKey);
    *DeleteKey = NULL;

    SetLastError (rc);
    return rc == ERROR_SUCCESS;
}


BOOL
pDeleteKeyStrW (
    IN OUT  PWSTR *DeleteKey
    )
{
    PWSTR p;
    HKEY key;
    LONG rc;

    if (*DeleteKey == NULL) {
        return TRUE;
    }

    p = (PWSTR) FindLastWackW (*DeleteKey);
    if (p) {
        *p = 0;
        p++;

        key = OpenRegKeyStrW (*DeleteKey);
        if (key) {

            if (DeleteRegKeyW (key, p)) {
                rc = ERROR_SUCCESS;
            } else {
                rc = GetLastError ();
            }
            CloseRegKey (key);

        } else {
            rc = GetLastError();
        }

        if (rc == ERROR_FILE_NOT_FOUND) {
            rc = ERROR_SUCCESS;
        }

    } else {
        rc = ERROR_SUCCESS;
    }

    FreeTextW (*DeleteKey);
    *DeleteKey = NULL;

    SetLastError (rc);
    return rc == ERROR_SUCCESS;
}


BOOL
RgRemoveKeyA (
    IN      PCSTR KeyToRemove
    )
{
    REGTREE_ENUMA e;
    PCSTR pattern;
    BOOL result = TRUE;
    PSTR deleteKey = NULL;
    PSTR encodedKey;

    encodedKey = AllocTextA (ByteCountA (KeyToRemove) * 2 + 2 * sizeof (CHAR));
    ObsEncodeStringA (encodedKey, KeyToRemove);
    StringCatA (encodedKey, "\\*");
    pattern = ObsBuildEncodedObjectStringExA (encodedKey, NULL, FALSE);
    FreeTextA (encodedKey);

    if (EnumFirstRegObjectInTreeExA (
            &e,
            pattern,
            TRUE,       // key names
            FALSE,      // containers last
            TRUE,       // values first
            TRUE,       // depth first
            REGENUM_ALL_SUBLEVELS,
            TRUE,       // use exclusions
            FALSE,      // ReadValueData
            NULL
            )) {
        do {

            if (!pDeleteKeyStrA (&deleteKey)) {
                result = FALSE;
                break;
            }

            MYASSERT (e.Attributes & REG_ATTRIBUTE_KEY);

            if (!RgRemoveAllValuesInKeyA (e.NativeFullName)) {
                result = FALSE;
                break;
            }

            //
            // The reg enum wrappers hold on to a key handle, which prevents
            // us from deleting the key now. We need to hold on to the key
            // name, then continue on to the next item.  At that time, we can
            // delete the key.
            //

            deleteKey = DuplicateTextA (e.NativeFullName);

        } while (EnumNextRegObjectInTreeA (&e));
    }

    ObsFreeA (pattern);

    if (result) {

        result = pDeleteKeyStrA (&deleteKey);
        result = result && RgRemoveAllValuesInKeyA (KeyToRemove);

        if (result) {
            deleteKey = DuplicateTextA (KeyToRemove);
            result = pDeleteKeyStrA (&deleteKey);
        }

    } else {

        AbortRegObjectInTreeEnumA (&e);

        if (deleteKey) {
            FreeTextA (deleteKey);
            INVALID_POINTER (deleteKey);
        }
    }

    return result;
}


BOOL
RgRemoveKeyW (
    IN      PCWSTR KeyToRemove
    )
{
    REGTREE_ENUMW e;
    PCWSTR pattern;
    BOOL result = TRUE;
    PWSTR deleteKey = NULL;
    PWSTR encodedKey;

    encodedKey = AllocTextW (ByteCountW (KeyToRemove) * 2 + 2 * sizeof (WCHAR));
    ObsEncodeStringW (encodedKey, KeyToRemove);
    StringCatW (encodedKey, L"\\*");
    pattern = ObsBuildEncodedObjectStringExW (encodedKey, NULL, FALSE);
    FreeTextW (encodedKey);

    if (EnumFirstRegObjectInTreeExW (
            &e,
            pattern,
            TRUE,       // key names
            FALSE,      // containers last
            TRUE,       // values first
            TRUE,       // depth first
            REGENUM_ALL_SUBLEVELS,
            TRUE,       // use exclusions
            FALSE,      // ReadValueData
            NULL
            )) {
        do {

            if (!pDeleteKeyStrW (&deleteKey)) {
                result = FALSE;
                break;
            }

            MYASSERT (e.Attributes & REG_ATTRIBUTE_KEY);

            if (!RgRemoveAllValuesInKeyW (e.NativeFullName)) {
                result = FALSE;
                break;
            }

            //
            // The reg enum wrappers hold on to a key handle, which prevents
            // us from deleting the key now. We need to hold on to the key
            // name, then continue on to the next item.  At that time, we can
            // delete the key.
            //

            deleteKey = DuplicateTextW (e.NativeFullName);

        } while (EnumNextRegObjectInTreeW (&e));
    }

    ObsFreeW (pattern);

    if (result) {

        result = pDeleteKeyStrW (&deleteKey);
        result = result && RgRemoveAllValuesInKeyW (KeyToRemove);

        if (result) {
            deleteKey = DuplicateTextW (KeyToRemove);
            result = pDeleteKeyStrW (&deleteKey);
        }

    } else {

        AbortRegObjectInTreeEnumW (&e);

        if (deleteKey) {
            FreeTextW (deleteKey);
            INVALID_POINTER (deleteKey);
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\crcmodel.h ===
/****************************************************************************/
/*							   Start of crcmodel.h							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the header (.h) file for the reference 			*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* How to Use This Package													*/
/* -----------------------													*/
/* Step 1: Declare a variable of type cm_t. Declare another variable		*/
/*		   (p_cm say) of type p_cm_t and initialize it to point to the first*/
/*		   variable (e.g. p_cm_t p_cm = &cm_t). 							*/
/*																			*/
/* Step 2: Assign values to the parameter fields of the structure.			*/
/*		   If you don't know what to assign, see the document cited earlier.*/
/*		   For example: 													*/
/*			  p_cm->cm_width = 16;											*/
/*			  p_cm->cm_poly  = 0x8005L; 									*/
/*			  p_cm->cm_init  = 0L;											*/
/*			  p_cm->cm_refin = TRUE;										*/
/*			  p_cm->cm_refot = TRUE;										*/
/*			  p_cm->cm_xorot = 0L;											*/
/*		   Note: Poly is specified without its top bit (18005 becomes 8005).*/
/*		   Note: Width is one bit less than the raw poly width. 			*/
/*																			*/
/* Step 3: Initialize the instance with a call cm_ini(p_cm);				*/
/*																			*/
/* Step 4: Process zero or more message bytes by placing zero or more		*/
/*		   successive calls to cm_nxt. Example: cm_nxt(p_cm,ch);			*/
/*																			*/
/* Step 5: Extract the CRC value at any time by calling crc = cm_crc(p_cm); */
/*		   If the CRC is a 16-bit value, it will be in the bottom 16 bits.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Design Notes 															*/
/* ------------ 															*/
/* PORTABILITY: This package has been coded very conservatively so that 	*/
/* it will run on as many machines as possible. For example, all external	*/
/* identifiers have been restricted to 6 characters and all internal ones to*/
/* 8 characters. The prefix cm (for Crc Model) is used as an attempt to 	*/
/* avoid namespace collisions. This package is endian independent.			*/
/*																			*/
/* EFFICIENCY: This package (and its interface) is not designed for 		*/
/* speed. The purpose of this package is to act as a well-defined reference */
/* model for the specification of CRC algorithms. If you want speed, cook up*/
/* a specific table-driven implementation as described in the document cited*/
/* above. This package is designed for validation only; if you have found or*/
/* implemented a CRC algorithm and wish to describe it as a set of para-	*/
/* meters to the Rocksoft^tm Model CRC Algorithm, your CRC algorithm imple- */
/* mentation should behave identically to this package under those para-	*/
/* meters.																	*/
/*																			*/
/****************************************************************************/

/* The following #ifndef encloses this entire */
/* header file, rendering it idempotent.	 */

#ifndef CM_DONE
#define CM_DONE

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************/
/* The following definitions are extracted from my style header file which	*/
/* would be cumbersome to distribute with this package. The DONE_STYLE is	*/
/* the idempotence symbol used in my style header file. 					*/

#ifndef DONE_STYLE

typedef unsigned long	ulong;
typedef unsigned		ubool;
typedef unsigned char * p_ubyte_;

#ifndef TRUE
#define FALSE 0
#define TRUE  1
#endif

/* Uncomment this definition if you don't have void. */
/* typedef int void; */

#endif

/****************************************************************************/
/* CRC Model Abstract Type													*/
/* -----------------------													*/
/* The following type stores the context of an executing instance of the	*/
/* model algorithm. Most of the fields are model parameters which must be	*/
/* set before the first initializing call to cm_ini.						*/

typedef struct
  {
   int	 cm_width;	 /* Parameter: Width in bits [8,32].	   */
   ulong cm_poly;	 /* Parameter: The algorithm's polynomial. */
   ulong cm_init;	 /* Parameter: Initial register value.	   */
   ubool cm_refin;	 /* Parameter: Reflect input bytes? 	   */
   ubool cm_refot;	 /* Parameter: Reflect output CRC?		   */
   ulong cm_xorot;	 /* Parameter: XOR this to output CRC.	   */

   ulong cm_reg;	 /* Context: Context during execution.	   */
  } cm_t;
typedef cm_t *p_cm_t;

/****************************************************************************/
/* Functions That Implement The Model										*/
/* ----------------------------------										*/
/* The following functions animate the cm_t abstraction.					*/

void cm_ini(p_cm_t p_cm);

/* Initializes the argument CRC model instance. 		 */
/* All parameter fields must be set before calling this. */

void cm_nxt(p_cm_t p_cm, int ch);

/* Processes a single message byte [0,255]. */

void cm_blk(p_cm_t p_cm, p_ubyte_ blk_adr, ulong blk_len);

/* Processes a block of message bytes. */

ulong cm_crc(p_cm_t p_cm);

/* Returns the CRC value for the message bytes processed so far. */

/****************************************************************************/
/* Functions For Table Calculation											*/
/* -------------------------------											*/
/* The following function can be used to calculate a CRC lookup table.		*/
/* It can also be used at run-time to create or check static tables.		*/

ulong cm_tab(p_cm_t p_cm, int index);

/* Returns the i'th entry for the lookup table for the specified algorithm. */
/* The function examines the fields cm_width, cm_poly, cm_refin, and the	*/
/* argument table index in the range [0,255] and returns the table entry in */
/* the bottom cm_width bytes of the return value. */

/****************************************************************************/
/* End of the header file idempotence #ifndef								*/

#ifdef __cplusplus
}
#endif

#endif

/****************************************************************************/
/*							   End of crcmodel.h							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

    UMTYPE=windows
Author:

    Andrew Ritz (andrewr)

!ENDIF

MAJORCOMP=setup
MINORCOMP=complnce

SOURCES=

INCLUDES=\
  $(INCLUDES);\
  $(BASE_INC_PATH);\
  $(DS_INC_PATH);\
  ..\..\inc;\

!include $(PROJECT_ROOT)\ntsetup\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\compchk.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    compliance.c

Abstract:

    compliance checking routines.

Author:

    Vijayachandran Jayaseelan (vijayj) - 31 Aug 1999

Revision History:

    none

Notes:
    These routines are used for compliance checking. CCMedia abstracts the
    install media and the already existing COMPLIANCE_DATA structure is
    used to abstract installation details.

    The current compliance checking design uses factory design pattern
    (Eric Gamma et.al.) to allow extensibility. Polymorphic behavior of
    compliance check is implemented using a function pointer.

    CCMediaCreate(...) creates the correct media object and binds the
    appropriate compliance checking method to the object. To support a new media
    type one needs to write a compliance check function for that
    media and change CCMediaCreate(...) function to create the appropriate
    media object bound to the new check function.

    The compliance matrix is a  multidimensional matrix i.e. type,
    variation, suite, version (version in turn is made up of major,
    minor and build# elements). Since changing a the multi-dimensional
    compliance matrix can be error prone and not extensible in terms of
    index management, a static global compliance matrix data structure was avoided.

--*/

#ifdef KERNEL_MODE

#include "textmode.h"
#define assert(x) ASSERT(x)

#else // KERNEL_MODE

#if DBG
#define assert(x) if (!(x)) DebugBreak();
#else
#define assert(x)
#endif // DBG

#include "winnt32.h"
#include <stdio.h>
#include <compliance.h>

#endif // for KERNEL_MODE

//
// macros
//

//
// indicates whether a given suite is installed
//
#define SUITE_INSTALLED(X, Y)  \
    (((X) & (Y)) ? TRUE : FALSE)


#define DEFAULT_MINIMUM_VALIDBUILD_WKS 2428
#define DEFAULT_MINIMUM_VALIDBUILD_SRV 3505
#define DOTNET_BUILD_LE     3505
#define DOTNET_BUILD_BETA3  3590
#define DOTNET_BUILD_RC1    3663
#define DOTNET_BUILD_RC2    3718

static BOOL bDisableBuildCheck = FALSE;


VOID
CCDisableBuildCheck(
    VOID )
{
    bDisableBuildCheck = TRUE;
}


//
// indicates whether the build is allowed to upgrade
//


__inline
BOOL
IsValidBuild(
    IN  DWORD   InstallVersion,
    IN  DWORD   SourceInstallVersion,
    IN  DWORD   MinimumBuild )
{
    BOOL Result = TRUE;

    if (bDisableBuildCheck) {
        Result = TRUE;
    } else  if ((InstallVersion > 1381 && InstallVersion < 2031)  ||
                (InstallVersion > 2195 && InstallVersion < MinimumBuild) ||
                (InstallVersion > SourceInstallVersion)) {
        Result = FALSE;
    }

    return Result;
}

BOOLEAN
CCProfessionalCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    professional media.

Arguments:

    This            : professional media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    professional media, otherwise FALSE

--*/
{
    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
            if (CompData->MinimumVersion < 400) {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber, DEFAULT_MINIMUM_VALIDBUILD_WKS)) {
                    *FailureReason = COMPLIANCEERR_NONE;
                    *UpgradeAllowed = TRUE;
                } else {
                    *FailureReason = COMPLIANCEERR_VERSION;
                    *UpgradeAllowed = FALSE;
                }
            }

            break;

        case COMPLIANCE_INSTALLTYPE_WIN9X:
            // note: 401 is 4.1
            if (CompData->MinimumVersion < 401) {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSE:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
        case COMPLIANCE_INSTALLTYPE_NTSPOW:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullProfessionalCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    professional full media.

Arguments:

    This            : professional media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    professional full media, otherwise FALSE

--*/
{
#if defined _IA64_
    if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) &&
        (CompData->BuildNumberNt <= DOTNET_BUILD_RC2) ){
        *FailureReason = COMPLIANCEERR_VERSION;
        *UpgradeAllowed = FALSE;
        return TRUE;
    }
    switch (This->SourceVariation) {
        case COMPLIANCE_INSTALLVAR_OEM:
            if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) && 
                (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM) ){
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
                return TRUE;
            }
            break;
        case COMPLIANCE_INSTALLVAR_EVAL:
            if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) && 
                (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_EVAL)) {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
                return TRUE;
            }
            break;
        default:
            break;
    }
#endif

    switch (This->SourceVariation) {
        case COMPLIANCE_INSTALLVAR_OEM:
            if ( ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_WIN9X) && (CompData->MinimumVersion > 400) && (CompData->MinimumVersion <= 490)) ||
                 ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) && (CompData->MinimumVersion == 400)) ||
                 ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) && (CompData->MinimumVersion == 500)) ||
                 (((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) || (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTWP) )
                    && (CompData->MinimumVersion == 501)
                    && (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM)) ){
                *FailureReason = COMPLIANCEERR_VARIATION;
                *UpgradeAllowed = FALSE;
            } else {
                CCProfessionalCheck(This, CompData, FailureReason, UpgradeAllowed);
            }
            break;

        case COMPLIANCE_INSTALLVAR_EVAL:
            if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) &&
                (CompData->MinimumVersion >= 501) &&
                (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_EVAL)) {
                *FailureReason = COMPLIANCEERR_VARIATION;
                *UpgradeAllowed = FALSE;
            }
            else {
                CCProfessionalCheck(This, CompData, FailureReason, UpgradeAllowed);
            }
            break;
        default:
            CCProfessionalCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}


BOOLEAN
CCProfessionalUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    professional upgrade media.

Arguments:

    This            : professional media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    professional upgrade media, otherwise FALSE

--*/
{
    if (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_NFR) {
        *FailureReason = COMPLIANCEERR_VARIATION;
        *UpgradeAllowed = FALSE;
    } else {
        switch (This->SourceVariation) {
            case COMPLIANCE_INSTALLVAR_OEM:
                if ( ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_WIN9X) && (CompData->MinimumVersion > 400) && (CompData->MinimumVersion <= 490)) ||
                     ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) && (CompData->MinimumVersion == 400)) ||
                     ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) && (CompData->MinimumVersion == 500) && (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM)) ||
                     (((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTW) || (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTWP) )
                        && (CompData->MinimumVersion == 501)
                        && (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM)) ){
                    *FailureReason = COMPLIANCEERR_VARIATION;
                    *UpgradeAllowed = FALSE;
                } else {
                    CCProfessionalCheck(This, CompData, FailureReason, UpgradeAllowed);
                }
                break;

            default:
                CCProfessionalCheck(This, CompData, FailureReason, UpgradeAllowed);
                break;
        }
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}


BOOLEAN
CCPersonalCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    personal media.

Arguments:

    This            : personal media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    personal media, otherwise FALSE

--*/
{
    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_WIN9X:
            // note: 401 is version 4.1
            if (CompData->MinimumVersion < 401) {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTWP:
            if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber, DEFAULT_MINIMUM_VALIDBUILD_WKS)) {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            } else {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSE:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
        case COMPLIANCE_INSTALLTYPE_NTSPOW:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            *UpgradeAllowed = FALSE;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullPersonalCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    personal full media.

Arguments:

    This            : personal media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    personal full media, otherwise FALSE

--*/
{
    switch (This->SourceVariation) {
        case COMPLIANCE_INSTALLVAR_OEM:
            if ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_WIN9X) && (CompData->MinimumVersion > 400) && (CompData->MinimumVersion <= 490)) {
                *FailureReason = COMPLIANCEERR_VARIATION;
                *UpgradeAllowed = FALSE;
            } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTWP) &&
                       (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM)) {
                *FailureReason = COMPLIANCEERR_VARIATION;
                *UpgradeAllowed = FALSE;
            }
            else {
                CCPersonalCheck(This, CompData, FailureReason, UpgradeAllowed);
            }
            break;

        case COMPLIANCE_INSTALLVAR_EVAL:
            if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTWP) &&
                (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_EVAL)) {
                *FailureReason = COMPLIANCEERR_VARIATION;
                *UpgradeAllowed = FALSE;
            }
            else {
                CCPersonalCheck(This, CompData, FailureReason, UpgradeAllowed);
            }
            break;
        default:
            CCPersonalCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}


BOOLEAN
CCPersonalUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    personal upgrade media.

Arguments:

    This            : personal media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    personal upgrade media, otherwise FALSE

--*/
{
    if (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_NFR) {
        *FailureReason = COMPLIANCEERR_VARIATION;
        *UpgradeAllowed = FALSE;
    } else {
        switch (This->SourceVariation) {
            case COMPLIANCE_INSTALLVAR_OEM:
                if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTWP) &&
                       (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM)) {
                    *FailureReason = COMPLIANCEERR_VARIATION;
                    *UpgradeAllowed = FALSE;
                }
                else {
                    CCPersonalCheck(This, CompData, FailureReason, UpgradeAllowed);
                }
                break;
            default:
                CCPersonalCheck(This, CompData, FailureReason, UpgradeAllowed);
                break;
        }
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}


BOOLEAN
CCBladeServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server media.  Policy is to allow blade server to be installed on
    older version of blade or on Windows Powered boxes (ADS w/EMBED suite).

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server media, otherwise FALSE

--*/
{
    DWORD  SuitesToCheck = 0;

    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTSB:
            if (CompData->MinimumVersion < 501) {
                *UpgradeAllowed = FALSE;
                *FailureReason = COMPLIANCEERR_TYPE;
            } else {
                if (!IsValidBuild(CompData->BuildNumberNt, This->BuildNumber, DEFAULT_MINIMUM_VALIDBUILD_SRV) ||
                    (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_OEM &&
                     CompData->BuildNumberNt <= DOTNET_BUILD_RC2)
                    ) {
                    *FailureReason = COMPLIANCEERR_VERSION;
                    *UpgradeAllowed = FALSE;
                } else {
                    *FailureReason = COMPLIANCEERR_NONE;
                    *UpgradeAllowed = TRUE;
                }
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSE:
        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
        case COMPLIANCE_INSTALLTYPE_NTSPOW:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullBladeServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server full media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server media, otherwise FALSE

--*/
{
    switch (This->SourceVariation) {
        case COMPLIANCE_INSTALLVAR_OEM:
            if ( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSB) &&
                 ((CompData->MinimumVersion == 501) || (CompData->MinimumVersion == 502)) &&
                 (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM) ){
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                CCBladeServerCheck(This, CompData, FailureReason, UpgradeAllowed);
            }
            break;

        case COMPLIANCE_INSTALLVAR_EVAL:
            if ( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSB) &&
                 (CompData->BuildNumberNt > DOTNET_BUILD_RC2) &&
                 (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_EVAL) ){
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                CCBladeServerCheck(This, CompData, FailureReason, UpgradeAllowed);
            }
            break;

        default:
            CCBladeServerCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}

BOOLEAN
CCBladeServerUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server upgrade media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server upgrade media, otherwise FALSE

--*/
{
    switch (CompData->InstallVariation) {
        case COMPLIANCE_INSTALLVAR_NFR:
        case COMPLIANCE_INSTALLVAR_EVAL:
            *FailureReason = COMPLIANCEERR_VARIATION;
            *UpgradeAllowed = FALSE;

            break;

        default:
            CCBladeServerCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCSmallBusinessServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server media.  Policy is to only allow Whistler SBS to upgrade Win2k Server,
	Whistler Server, and SBS 2k.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server media, otherwise FALSE

--*/
{
    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
            if ((CompData->BuildNumberNt >= 2195) &&
				 (CompData->BuildNumberNt <= This->BuildNumber)) {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            } else {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSE:
        case COMPLIANCE_INSTALLTYPE_NTSPOW:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullSmallBusinessServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    blade server full media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server media, otherwise FALSE

--*/
{
    CCSmallBusinessServerCheck(This, CompData, FailureReason, UpgradeAllowed);

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}

BOOLEAN
CCSmallBusinessServerUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    sbs upgrade media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    blade server upgrade media, otherwise FALSE

--*/
{
    switch (CompData->InstallVariation) {
        case COMPLIANCE_INSTALLVAR_NFR:
        case COMPLIANCE_INSTALLVAR_EVAL:
            *FailureReason = COMPLIANCEERR_VARIATION;
            *UpgradeAllowed = FALSE;

            break;

        default:
            CCSmallBusinessServerCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}


BOOLEAN
CCServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    server media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    server media, otherwise FALSE

--*/
{
    DWORD  SuitesToCheck = 0;

    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTS:
            SuitesToCheck = (COMPLIANCE_INSTALLSUITE_ENT |
                             COMPLIANCE_INSTALLSUITE_SBSR |
                             COMPLIANCE_INSTALLSUITE_BACK);

            if (SUITE_INSTALLED(CompData->InstallSuite, SuitesToCheck)) {
                *FailureReason = COMPLIANCEERR_SUITE;
                *UpgradeAllowed = FALSE;
            } else {
                if (CompData->MinimumVersion < 400) {
                    *FailureReason = COMPLIANCEERR_VERSION;
                    *UpgradeAllowed = FALSE;
                } else {
                    if (!IsValidBuild(CompData->BuildNumberNt, This->BuildNumber, DEFAULT_MINIMUM_VALIDBUILD_SRV) ||
                        ( (CompData->MinimumVersion >= 501) &&
                          (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_OEM) &&
                          (CompData->BuildNumberNt >= DOTNET_BUILD_BETA3) &&
                          (CompData->BuildNumberNt <= DOTNET_BUILD_RC2)) ) {
                        *FailureReason = COMPLIANCEERR_VERSION;
                        *UpgradeAllowed = FALSE;
                    } else {
                        *FailureReason = COMPLIANCEERR_NONE;
                        *UpgradeAllowed = TRUE;
                    }
                }
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSTSE:
            if (CompData->BuildNumberNt < 1381) {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSBS:
        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSE:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSPOW:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    server full media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    server media, otherwise FALSE

--*/
{
    switch (This->SourceVariation) {
    case COMPLIANCE_INSTALLVAR_OEM:
        if ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTS) &&
            (CompData->MinimumVersion == 400) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSTSE) &&
                   (CompData->MinimumVersion == 400) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTS) &&
                   (CompData->MinimumVersion == 500) &&
                   (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTS) &&
                   ((CompData->MinimumVersion == 501) || (CompData->MinimumVersion == 502))&&
                   (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else {
            CCServerCheck(This, CompData, FailureReason, UpgradeAllowed);
        }
        break;

    case COMPLIANCE_INSTALLVAR_EVAL:
        if ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTS) &&
            (CompData->BuildNumberNt > DOTNET_BUILD_RC2) &&
            (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_EVAL) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else {
            CCServerCheck(This, CompData, FailureReason, UpgradeAllowed);
        }
        break;

    default:
        CCServerCheck(This, CompData, FailureReason, UpgradeAllowed);
        break;
    }



    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}

BOOLEAN
CCServerUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    server upgrade media.

Arguments:

    This            : server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    server upgrade media, otherwise FALSE

--*/
{
    switch (CompData->InstallVariation) {
        case COMPLIANCE_INSTALLVAR_NFR:
        case COMPLIANCE_INSTALLVAR_EVAL:
            *FailureReason = COMPLIANCEERR_VARIATION;
            *UpgradeAllowed = FALSE;

            break;

        default:
            CCServerCheck(This, CompData, FailureReason, UpgradeAllowed);
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

#if defined _IA64_

BOOLEAN
CCAdvancedServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    advanced server media.

Arguments:

    This            : advanced server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    advanced server media, otherwise FALSE

--*/
{
    DWORD   SuitesToCheck = 0;

    switch (CompData->InstallType) {

        case COMPLIANCE_INSTALLTYPE_NTSE:
            if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber, DOTNET_BUILD_RC1)) {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            } else {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSTSE:
        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSPOW:
        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSBS:

            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullAdvancedServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    advanced server full media.

Arguments:

    This            : advanced server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    advanced server full media, otherwise FALSE

--*/
{
    switch (This->SourceVariation) {
        case COMPLIANCE_INSTALLVAR_OEM:
            if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSE) &&
                (CompData->BuildNumberNt <= DOTNET_BUILD_RC2) && 
                (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_EVAL) ){
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
                return TRUE;
            } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSE) &&
                       (CompData->BuildNumberNt > DOTNET_BUILD_RC2) &&
                       (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM) ){
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
                return TRUE;
            }
            break;
        
        case COMPLIANCE_INSTALLVAR_EVAL:
            if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSE) &&
                (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_EVAL) ){
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
                return TRUE;
            }
            break;
        default:
            break;
    }
    CCAdvancedServerCheck(This, CompData, FailureReason, UpgradeAllowed);

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}

#else // !ia64
BOOLEAN
CCAdvancedServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    advanced server media.

Arguments:

    This            : advanced server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    advanced server media, otherwise FALSE

--*/
{
    DWORD   SuitesToCheck = 0;

    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTS:
            // note: 502 is version 5.2 because of calculation major*100 + minor
            if (CompData->MinimumVersion <= 502 && CompData->MinimumVersion > 351) {
                SuitesToCheck = (COMPLIANCE_INSTALLSUITE_SBSR |
                                 COMPLIANCE_INSTALLSUITE_BACK);

                if (SUITE_INSTALLED(CompData->InstallSuite, SuitesToCheck)) {
                    *FailureReason = COMPLIANCEERR_SUITE;
                    *UpgradeAllowed = FALSE;
                } else {
                    if (!IsValidBuild(CompData->BuildNumberNt, This->BuildNumber, DEFAULT_MINIMUM_VALIDBUILD_SRV) ||
                        ((CompData->MinimumVersion >= 501) &&
                            (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_OEM) &&
                            (CompData->BuildNumberNt >= DOTNET_BUILD_BETA3) &&
                            (CompData->BuildNumberNt <= DOTNET_BUILD_RC2)) ) {
                        *FailureReason = COMPLIANCEERR_VERSION;
                        *UpgradeAllowed = FALSE;
                    } else {
                        *FailureReason = COMPLIANCEERR_NONE;
                        *UpgradeAllowed = TRUE;
                        
                    }
                }
            } else {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSTSE:
            if (CompData->BuildNumberNt < 1381) {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSE:
            if (!IsValidBuild(CompData->BuildNumberNt, This->BuildNumber, DEFAULT_MINIMUM_VALIDBUILD_SRV) ||
                ((CompData->MinimumVersion >= 501) &&
                    (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_OEM) &&
                    (CompData->BuildNumberNt >= DOTNET_BUILD_BETA3) &&
                    (CompData->BuildNumberNt <= DOTNET_BUILD_RC2)) ) {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            } else {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTSPOW:
        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
        case COMPLIANCE_INSTALLTYPE_NTSBS:

            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}

BOOLEAN
CCFullAdvancedServerCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    advanced server full media.

Arguments:

    This            : advanced server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    advanced server full media, otherwise FALSE

--*/
{
    switch (This->SourceVariation) {
    case COMPLIANCE_INSTALLVAR_OEM:
        if ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTS) &&
            (CompData->MinimumVersion == 400) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSTSE) &&
                   (CompData->MinimumVersion == 400) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSE) &&
                   (CompData->MinimumVersion == 400) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTS) &&
                   (CompData->MinimumVersion == 500) &&
                   (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSE) &&
                   (CompData->MinimumVersion == 500) &&
                   (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTS) &&
                   ((CompData->MinimumVersion == 501) || (CompData->MinimumVersion == 502))&&
                   (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSE) &&
                   ((CompData->MinimumVersion == 501) || (CompData->MinimumVersion == 502))&&
                   (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_OEM) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSPOW) &&
                   (CompData->MinimumVersion == 500) &&
                   (CompData->BuildNumberNt == 2195) &&
                   (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_OEM) ) {
            *FailureReason = COMPLIANCEERR_NONE;
            *UpgradeAllowed = TRUE;
        } else {
            CCAdvancedServerCheck(This, CompData, FailureReason, UpgradeAllowed);
        }
        break;

    case COMPLIANCE_INSTALLVAR_EVAL:
        if( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSE) &&
            (CompData->BuildNumberNt > DOTNET_BUILD_RC2) &&
            (CompData->InstallVariation != COMPLIANCE_INSTALLVAR_EVAL) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else {
            CCAdvancedServerCheck(This, CompData, FailureReason, UpgradeAllowed);
        }
        break;

    default:
        CCAdvancedServerCheck(This, CompData, FailureReason, UpgradeAllowed);
        break;
    }

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}

#endif

BOOLEAN
CCAdvancedServerUpgCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    advanced server upgrade media.

Arguments:

    This            : advanced server media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    advanced server upgrade media, otherwise FALSE

--*/
{
    DWORD   CurrentSuite = 0;
    DWORD   SuitesToCheck = 0;

    switch (CompData->InstallVariation) {
        case COMPLIANCE_INSTALLVAR_NFR:
        case COMPLIANCE_INSTALLVAR_EVAL:
            *FailureReason = COMPLIANCEERR_VARIATION;
            *UpgradeAllowed = FALSE;

            break;

        default:
            switch (CompData->InstallType) {
                case COMPLIANCE_INSTALLTYPE_NTS:
                    CurrentSuite = CompData->InstallSuite;

                    if (SUITE_INSTALLED(CurrentSuite, COMPLIANCE_INSTALLSUITE_ENT)) {
                        if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber, DEFAULT_MINIMUM_VALIDBUILD_SRV)) {
                            *FailureReason = COMPLIANCEERR_NONE;
                            *UpgradeAllowed = TRUE;
                        } else {
                            *FailureReason = COMPLIANCEERR_VERSION;
                            *UpgradeAllowed = FALSE;
                        }
                    } else {
                        if (SUITE_INSTALLED(CurrentSuite, COMPLIANCE_INSTALLSUITE_NONE)) {
                            *FailureReason = COMPLIANCEERR_TYPE;
                            *UpgradeAllowed = FALSE;
                        } else {
                            *FailureReason = COMPLIANCEERR_SUITE;
                            *UpgradeAllowed = FALSE;
                        }
                    }

                    break;

                case COMPLIANCE_INSTALLTYPE_NTSTSE:
                    *FailureReason = COMPLIANCEERR_SUITE;
                    *UpgradeAllowed = FALSE;

                    break;

                default:
                    CCAdvancedServerCheck(This, CompData, FailureReason, UpgradeAllowed);
                    break;
            }

            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}


BOOLEAN
CCDataCenterCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    datacenter media.

Arguments:

    This            : datacenter media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    datacenter media, otherwise FALSE

--*/
{
    DWORD   SuitesToCheck = 0;

    switch (CompData->InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTSDTC:
            if (CompData->MinimumVersion < 500) {
                *UpgradeAllowed = FALSE;
                *FailureReason = COMPLIANCEERR_VERSION;
            } else if (CompData->MinimumVersion == 500) {
                if( (CompData->BuildNumberNt == 2195) &&
                    ((CompData->InstallVariation == COMPLIANCE_INSTALLVAR_CDRETAIL) ||
                     (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_OEM))) {
                    *UpgradeAllowed = TRUE;
                    if( (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_OEM)) {
                        *FailureReason = COMPLIANCEERR_DTCWARNING;
                    } else {
                        *FailureReason = COMPLIANCEERR_NONE;
                    }
                } else {
                    *UpgradeAllowed = FALSE;
                    *FailureReason = COMPLIANCEERR_VERSION;
                }
            } else {
                switch (CompData->InstallVariation) {
                    case COMPLIANCE_INSTALLVAR_CDRETAIL:
                        if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber, DOTNET_BUILD_RC1)) {
                            *FailureReason = COMPLIANCEERR_NONE;
                            *UpgradeAllowed = TRUE;
                        } else {
                            *FailureReason = COMPLIANCEERR_VERSION;
                            *UpgradeAllowed = FALSE;
                        }

                        break;

                    default:
                        *FailureReason = COMPLIANCEERR_VERSION;
                        *UpgradeAllowed = FALSE;
                        break;
                }
            }

            break;

        case COMPLIANCE_INSTALLTYPE_NTS:
        case COMPLIANCE_INSTALLTYPE_NTSB:
        case COMPLIANCE_INSTALLTYPE_NTSE:
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
        case COMPLIANCE_INSTALLTYPE_WIN9X:
        case COMPLIANCE_INSTALLTYPE_WIN31:
        case COMPLIANCE_INSTALLTYPE_NTWP:
        case COMPLIANCE_INSTALLTYPE_NTW:
        case COMPLIANCE_INSTALLTYPE_NTSBS:
        case COMPLIANCE_INSTALLTYPE_NTSPOW:
            *FailureReason = COMPLIANCEERR_TYPE;
            *UpgradeAllowed = FALSE;
            break;

        default:
            *UpgradeAllowed = FALSE;
            *FailureReason = COMPLIANCEERR_UNKNOWNTARGET;
            break;
    }

    return (*FailureReason == COMPLIANCEERR_NONE) ? TRUE : FALSE;
}


BOOLEAN
CCFullDataCenterCheck(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               UpgradeAllowed )
/*++

Routine Description:

    This routine checks whether the an installation is compliant with the
    datacenter full media.

Arguments:

    This            : datacenter media object pointer
    CompData        : compliance data describing details for an installation
    FailureReason   : receives the reason for failure, if any.
    UpgradeAllowed  : receives a bool indicating whether upgrade is allowed
                      or not

Return Value:

    TRUE if the given install is compliant for installing using the
    datacenter full media, otherwise FALSE

--*/
{
    switch (This->SourceVariation) {
    case COMPLIANCE_INSTALLVAR_OEM:
        if ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSDTC) &&
            (CompData->MinimumVersion == 500) &&
            (CompData->BuildNumberNt == 2195) &&
            (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_OEM) ) {
            *FailureReason = COMPLIANCEERR_NONE;
            *UpgradeAllowed = TRUE;
        } else if ( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSDTC) &&
                    (CompData->MinimumVersion == 500) &&
                    (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_CDRETAIL) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else if ((CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSDTC) &&
            ((CompData->MinimumVersion == 501) || (CompData->MinimumVersion == 502)) &&
            (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_OEM) ) {
            if (IsValidBuild(CompData->BuildNumberNt, This->BuildNumber, DEFAULT_MINIMUM_VALIDBUILD_SRV)) {
                *FailureReason = COMPLIANCEERR_NONE;
                *UpgradeAllowed = TRUE;
            } else {
                *FailureReason = COMPLIANCEERR_VERSION;
                *UpgradeAllowed = FALSE;
            }
        } else if ( (CompData->InstallType == COMPLIANCE_INSTALLTYPE_NTSDTC) &&
                    ((CompData->MinimumVersion == 501) || (CompData->MinimumVersion == 502)) &&
                    (CompData->InstallVariation == COMPLIANCE_INSTALLVAR_CDRETAIL) ) {
            *FailureReason = COMPLIANCEERR_VERSION;
            *UpgradeAllowed = FALSE;
        } else{
            CCDataCenterCheck(This, CompData, FailureReason, UpgradeAllowed);
        }
        break;

    case COMPLIANCE_INSTALLVAR_EVAL:
        *FailureReason = COMPLIANCEERR_TYPE;
        *UpgradeAllowed = FALSE;
        break;

    default:
        CCDataCenterCheck(This, CompData, FailureReason, UpgradeAllowed);
        break;
    }

    return (*FailureReason != COMPLIANCEERR_UNKNOWNTARGET) ? TRUE : FALSE;
}


PCCMEDIA
CCMediaCreate(
    IN          DWORD   SourceSKU,
    IN          DWORD   SourceVariation,
    IN OPTIONAL DWORD   Version,
    IN OPTIONAL DWORD   BuildNumber )
/*++

Routine Description:

    This routine creates a media object and binds the appropriate compliance
    checking function to the media object.

Arguments:

    SourceSKU       : the kind of SKU
    SourceVariation : the kind of variation (oem, msdn, retail etc)
    Version         : the version ((major ver + minor ver) * 100)
    BuildNumber     : the build number

Return Value:

    A new allocated and initialized media object of the appropriate type if
    the media type is supported otherwise NULL.

    NOTE:
    Once you are done with the object, free the media object using CCMemFree()
    macro. This function uses factory design pattern.

--*/
{
    PCCMEDIA    SourceMedia = CCMemAlloc(sizeof(CCMEDIA));

    if( !SourceMedia ) {
        return SourceMedia;
    }

    SourceMedia->SourceVariation = SourceVariation;
    SourceMedia->Version = Version;
    SourceMedia->BuildNumber = BuildNumber;

    switch (SourceSKU) {
        case COMPLIANCE_SKU_NTWFULL:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTW;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullProfessionalCheck;
            break;

        case COMPLIANCE_SKU_NTW32U:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTW;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCProfessionalUpgCheck;

            break;

        case COMPLIANCE_SKU_NTWPFULL:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTWP;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullPersonalCheck;

            break;

        case COMPLIANCE_SKU_NTWPU:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTWP;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCPersonalUpgCheck;

            break;

        case COMPLIANCE_SKU_NTSB:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSB;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullBladeServerCheck;

            break;

        case COMPLIANCE_SKU_NTSBU:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSB;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCBladeServerUpgCheck;

            break;
	
        case COMPLIANCE_SKU_NTSBS:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSBS;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullSmallBusinessServerCheck;
	
            break;
	
        case COMPLIANCE_SKU_NTSBSU:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSBS;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCSmallBusinessServerUpgCheck;
	
            break;

        case COMPLIANCE_SKU_NTSFULL:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTS;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullServerCheck;

            break;

        case COMPLIANCE_SKU_NTSU:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTS;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCServerUpgCheck;
            break;

        case COMPLIANCE_SKU_NTSEFULL:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSE;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullAdvancedServerCheck;

            break;

        case COMPLIANCE_SKU_NTSEU:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSE;
            SourceMedia->StepUpMedia = TRUE;
            SourceMedia->CheckInstall = CCAdvancedServerUpgCheck;

            break;

        case COMPLIANCE_SKU_NTSDTC:
            SourceMedia->SourceType = COMPLIANCE_INSTALLTYPE_NTSDTC;
            SourceMedia->StepUpMedia = FALSE;
            SourceMedia->CheckInstall = CCFullDataCenterCheck;

            break;

        default:
            CCMemFree(SourceMedia);
            SourceMedia = 0;
            break;
    }

    return SourceMedia;
}

BOOLEAN
CCMediaInitialize(
    OUT PCCMEDIA        DestMedia,
    IN          DWORD   Type,
    IN          DWORD   Variation,
    IN          BOOLEAN StepupMedia,
    IN OPTIONAL DWORD   Version,
    IN OPTIONAL DWORD   BuildNumber)
/*++

Routine Description:

    The routine initializes a CCMEDIA structure with the given values
    particularly the binding of "CheckInstall" method based on "Type"
    and "StepupMedia".

Arguments:

 DestMedia   - The media object which needs to be initialized
 Type  - The type of media object (eg. COMPLIANCE_INSTALLTYPE_NTS)
 Variation - The variation of the media object (eg. COMPLIANCE_INSTALLVAR_CDRETAIL)
 StepupMedia - TRUE if the media is a stepup media or FALSE otherwise
 Version  - Optional OS Version (major * 100 + minor)
 BuildNumber - Optinal Build number of OS (eg. 2172)

Return Value:

    TRUE if the given media object could be initialized otherwise FALSE.

--*/
{
    BOOLEAN Result = FALSE;

    if (DestMedia) {
        Result = TRUE;

        DestMedia->SourceType = Type;
        DestMedia->SourceVariation = Variation;
        DestMedia->StepUpMedia = StepupMedia;
        DestMedia->Version = Version;
        DestMedia->BuildNumber = BuildNumber;
        DestMedia->CheckInstall = 0;

        switch (Type) {
            case COMPLIANCE_INSTALLTYPE_NTW:
                DestMedia->CheckInstall = StepupMedia ?
                    CCProfessionalUpgCheck : CCFullProfessionalCheck;
                break;

            case COMPLIANCE_INSTALLTYPE_NTWP:
                DestMedia->CheckInstall = StepupMedia ?
                    CCPersonalUpgCheck : CCFullPersonalCheck;
                break;

            case COMPLIANCE_INSTALLTYPE_NTSB:
                DestMedia->CheckInstall = StepupMedia ?
                    CCBladeServerUpgCheck : CCFullBladeServerCheck;
                break;

            case COMPLIANCE_INSTALLTYPE_NTS:
                DestMedia->CheckInstall = StepupMedia ?
                    CCServerUpgCheck : CCFullServerCheck;
                break;

            case COMPLIANCE_INSTALLTYPE_NTSE:
                DestMedia->CheckInstall = StepupMedia ?
                    CCAdvancedServerUpgCheck : CCFullAdvancedServerCheck;
                break;

            case COMPLIANCE_INSTALLTYPE_NTSDTC:
                if (!StepupMedia) {
                    DestMedia->CheckInstall = CCFullDataCenterCheck;
                } else {
                    Result = FALSE;
                }

                break;

            default:
                assert(FALSE);
                Result = FALSE;
                break;
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\compliance.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    compliance.c

Abstract:

    compliance checking routines.

Author:

    Andrew Ritz (andrewr) 2-Sept-1998

Revision History:

    2-Sept-1998 (andrewr) - created


Notes:

    These routines are for compliance checking:

    They check to see if an upgrade is allowed from the specified source to the destination.
    Since there are so many SKUs to be supported, it's necessary to have a small framework
    in place to handle all of these cases.  There are generally three parts to the compliance
    check:

    1) retreive source information and determine what SKU you want to install
    2) retrieve target information and determine what you are installing over
    3) do the actual compliance check of the target against the source to determine if upgrades
    are allowed, or if any installations are allowed from the target to the source.

    These types of checks need to be run in both kernel-mode and user-mode installations, so this
    common code library was created.  The kernel-mode specific code is in an #ifdef KERNEL_MODE
    block, and the usermode-specific code is in the #else branch.  Common code is outside of
    any #ifdef.  This library is only to be run (will only link with) setupdd.sys or winnt32a|u.dll.
    So when you change this code, keep in mind that it needs to run in both kernel mode and user mode.

    Also note that we have to do a bunch of handwaving since NT supports upgrades from win95.  Because of
    this, we cannot simply read the setupreg.hiv for some information about the installation.  Instead, we
    encode some additional information into setupp.ini (which is encoded in such a way as to discourage
    tinkering with it, but it by no means secure.  It provides about the same level of security (obscurity?!?)
    as setupreg.hiv gave us in the past.)


--*/




#ifdef KERNEL_MODE
    #include "textmode.h"
#else
    #include "winnt32.h"
    #include <stdio.h>
#endif

#include "COMPLIANCE.H"
#include "crcmodel.h"

#ifdef KERNEL_MODE
    #define assert(x) ASSERT(x);
#else
    #if DBG
        #define assert(x) if (!(x)) DebugBreak();
    #else
        #define assert(x)
    #endif
#endif

//
// NOTE - this MUST match setup\textmode\kernel\spconfig.c's array of product suites
// NOTE - need to handle terminal server, as well as citrix terminal server on NT3.51
//
#define SUITE_VALUES        COMPLIANCE_INSTALLSUITE_SBS,    \
                            COMPLIANCE_INSTALLSUITE_ENT,    \
                            COMPLIANCE_INSTALLSUITE_BACK,   \
                            COMPLIANCE_INSTALLSUITE_COMM,   \
                            COMPLIANCE_INSTALLSUITE_HYDRA,  \
                            COMPLIANCE_INSTALLSUITE_SBSR,   \
                            COMPLIANCE_INSTALLSUITE_EMBED,  \
                            COMPLIANCE_INSTALLSUITE_DTC,    \
                            COMPLIANCE_INSTALLSUITE_PER,    \
                            COMPLIANCE_INSTALLSUITE_BLADE


//
// globals
//

//
// Common functions shared between user-mode and kernel mode
//


DWORD
CRC_32(LPBYTE pb, DWORD cb)
{

//              CRC-32 algorithm used in PKZip, AUTODIN II, Ethernet, and FDDI
//              but xor out (xorot) has been changed from 0xFFFFFFFF to 0 so
//              we can store the CRC at the end of the block and expect 0 to be
//              the value of the CRC of the resulting block (including the stored
//              CRC).

        cm_t cmt = {
                32,             // cm_width  Parameter: Width in bits [8,32].
                0x04C11DB7, // cm_poly   Parameter: The algorithm's polynomial.
                0xFFFFFFFF, // cm_init   Parameter: Initial register value.
                TRUE,           // cm_refin  Parameter: Reflect input bytes?
                TRUE,           // cm_refot  Parameter: Reflect output CRC?
                0, // cm_xorot  Parameter: XOR this to output CRC.
                0                       // cm_reg        Context: Context during execution.
        };

        // Documented test case for CRC-32:
        // Checking "123456789" should return 0xCBF43926

        cm_ini(&cmt);
        cm_blk(&cmt, pb, cb);

        return cm_crc(&cmt);
}

#ifdef KERNEL_MODE

BOOLEAN
PsGetVersion(
    PULONG MajorVersion OPTIONAL,
    PULONG MinorVersion OPTIONAL,
    PULONG BuildNumber OPTIONAL,
    PUNICODE_STRING CSDVersion OPTIONAL
    );

BOOLEAN
DetermineSourceVersionInfo(
  OUT PDWORD Version,
  OUT PDWORD BuildNumber
  )
/*++

Routine Description:

  Finds the version and build number from

Arguments:

  InfPath - Fully qualified path to a inf file containing
  [version] section.

  Version - Place holder for version information
  BuildNumber - Place holder for build number

Return Value:

  Returns TRUE if Version and Build number are successfully extracted, otherwise
  returns FALSE

--*/
{
  BOOLEAN Result = FALSE;
  ULONG Major = 0, Minor = 0, Build = 0;

  //
  // We use PsGetVersion(...) API exported by the kernel
  //
  PsGetVersion(&Major, &Minor, &Build, NULL);

  if ((Major > 0) || (Minor > 0) || (Build > 0)) {
    Result = TRUE;

    if (Version)
      *Version = Major * 100 + Minor;

    if (BuildNumber)
      *BuildNumber = Build;
  }

  return Result;
}

#else

BOOLEAN
pGetVersionFromStr(
  TCHAR *VersionStr,
  DWORD *Version,
  DWORD *BuildNumber
  )
/*++

Routine Description:

  Parses a string with version information like "5.0.2195.1"
  and returns the values.

Arguments:

  VersionStr - The version string (most of the time its DriverVer string
               from the [Version] section in a inf like dosnet.inf)
  Version - The version (i.e. major * 100 + minor)
  BuildNumber - The build number like 2195

Return Value:

  Returns TRUE if Version and Build number are successfully extracted, otherwise
  returns FALSE

--*/
{
  BOOLEAN Result = FALSE;
  DWORD MajorVer = 0, MinorVer = 0, BuildNum = 0;
  TCHAR *EndPtr;
  TCHAR *EndChar;
  TCHAR TempBuff[64] = {0};

  if (VersionStr) {
    EndPtr = _tcschr(VersionStr, TEXT('.'));

    if (EndPtr) {
      _tcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));
      MajorVer = _tcstol(TempBuff, &EndChar, 10);

      VersionStr = EndPtr + 1;

      if (VersionStr) {
        EndPtr = _tcschr(VersionStr, TEXT('.'));

        if (EndPtr) {
          memset(TempBuff, 0, sizeof(TempBuff));
          _tcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));
          MinorVer = _tcstol(TempBuff, &EndChar, 10);

          VersionStr = EndPtr + 1;

          if (VersionStr) {
            EndPtr = _tcschr(VersionStr, TEXT('.'));

            if (EndPtr) {
              memset(TempBuff, 0, sizeof(TempBuff));
              _tcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));

              BuildNum = _tcstol(TempBuff, &EndChar, 10);
            }
          }
        }
      }
    }
  }

  if ((MajorVer > 0) || (MinorVer > 0) || (BuildNum > 0))
    Result = TRUE;

  if (Result) {
    if (Version)
      *Version = (MajorVer * 100) + MinorVer;

    if (BuildNumber)
      *BuildNumber = BuildNum;
  }

  return Result;
}

BOOLEAN
DetermineSourceVersionInfo(
  IN TCHAR *InfPath,
  OUT PDWORD Version,
  OUT PDWORD BuildNumber
  )
/*++

Routine Description:

  Finds the version and build number from

Arguments:

  InfPath - Fully qualified path to inf file containing
  [version] section.

  Version - Place holder for version information
  BuildNumber - Place holder for build number

Return Value:

  Returns TRUE if Version and Build number are successfully extracted, otherwise
  returns FALSE

--*/
{
  BOOLEAN Result = FALSE;
  TCHAR FileName[MAX_PATH];
  TCHAR Buffer[64] = {0};
  DWORD CharCount;

  CharCount = GetPrivateProfileString(TEXT("Version"), TEXT("DriverVer"), TEXT("0"),
                  Buffer, sizeof(Buffer)/sizeof(TCHAR), InfPath);

  if (CharCount) {
    TCHAR *TempPtr = _tcschr(Buffer, TEXT(','));

    if (TempPtr) {
      TempPtr++;
      Result = pGetVersionFromStr(TempPtr, Version, BuildNumber);
    }
  }

  return Result;
}


#endif


DWORD
DetermineSourceProduct(
    OUT DWORD *SourceSkuVariation,
    IN  PCOMPLIANCE_DATA Target
    )
/*++

Routine Description:

    This routine determines which sku you are installing.

    It does this by looking at
    a) the source install type
    b) the source install "sku" (stepup or full install)
    c) source suite type

Arguments:

    None.

Return Value:

    a COMPLIANCE_SKU_* flag indicating what sku you are installing, and COMPLIANCE_SKU_NONE for error

--*/

{
    COMPLIANCE_DATA cd;

    DWORD sku = COMPLIANCE_SKU_NONE;

    *SourceSkuVariation = COMPLIANCE_INSTALLVAR_SELECT;

#ifdef KERNEL_MODE

    if (!pSpGetCurrentInstallVariation(PidString,SourceSkuVariation)) {
        return(COMPLIANCE_SKU_NONE);
    }

    if (!pSpDetermineSourceProduct(&cd)) {
        return(COMPLIANCE_SKU_NONE);
    }
#else
    if (!GetSourceInstallVariation(SourceSkuVariation)) {
        return(COMPLIANCE_SKU_NONE);
    }

    if (!GetSourceComplianceData(&cd,Target)){
        return(COMPLIANCE_SKU_NONE);
    }
#endif

    switch (cd.InstallType) {
        case COMPLIANCE_INSTALLTYPE_NTW:
            // suite check is done because kernel mode does not detect personal for the type.
            if (cd.InstallSuite & COMPLIANCE_INSTALLSUITE_PER) {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTWPU;
                } else {
                    sku = COMPLIANCE_SKU_NTWPFULL;
                }
            } else {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTW32U;
                } else {
                    sku = COMPLIANCE_SKU_NTWFULL;
                }
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTWP:
            if (cd.RequiresValidation) {
                sku = COMPLIANCE_SKU_NTWPU;
            } else {
                sku = COMPLIANCE_SKU_NTWPFULL;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTS:
            // suite checks are done because kernel mode does not detect dtc or ent for the type.
            if (cd.InstallSuite & COMPLIANCE_INSTALLSUITE_DTC) {
                sku = COMPLIANCE_SKU_NTSDTC;
            } else if (cd.InstallSuite & COMPLIANCE_INSTALLSUITE_BLADE) {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTSBU;
                } else {
                    sku = COMPLIANCE_SKU_NTSB;
                }
            } else if (cd.InstallSuite & COMPLIANCE_INSTALLSUITE_SBSR) {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTSBSU;
                } else {
                    sku = COMPLIANCE_SKU_NTSBS;
                }
            } else if (cd.InstallSuite & COMPLIANCE_INSTALLSUITE_ENT) {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTSEU;
                } else {
                    sku = COMPLIANCE_SKU_NTSEFULL;
                }
            } else {
                if (cd.RequiresValidation) {
                    sku = COMPLIANCE_SKU_NTSU;
                } else {
                    sku = COMPLIANCE_SKU_NTSFULL;
                }
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTSB:
            if (cd.RequiresValidation) {
                sku = COMPLIANCE_SKU_NTSBU;
            } else {
                sku = COMPLIANCE_SKU_NTSB;
            }
            break;
	
        case COMPLIANCE_INSTALLTYPE_NTSBS:
            if (cd.RequiresValidation) {
                sku = COMPLIANCE_SKU_NTSBSU;
            } else {
                sku = COMPLIANCE_SKU_NTSBS;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTSE:
            if (cd.RequiresValidation) {
                sku = COMPLIANCE_SKU_NTSEU;
            } else {
                sku = COMPLIANCE_SKU_NTSEFULL;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTSDTC:
            sku = COMPLIANCE_SKU_NTSDTC;
            break;

        default:
            sku = COMPLIANCE_SKU_NONE;
    }


    return( sku );
}

BOOLEAN
CheckCompliance(
    IN DWORD SourceSku,
    IN DWORD SourceSkuVariation,
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PCOMPLIANCE_DATA pcd,
    OUT PUINT Reason,
    OUT PBOOL NoUpgradeAllowed
    )
/*++

Routine Description:

    This routines determines if your current installation is compliant (if you are allowed to proceed with your installation).

    To do this, it retreives your current installation and determines the sku for your source installation.

    It then compares the target against the source to determine if the source sku allows an upgrade/clean install
    from your target installation.

Arguments:

    SourceSku           - a COMPLIANCE_SKU_* flag indicating the source type
    SourceSkuVariation  - a COMPLIANCE_VARIATION_* flag indicating what variation the source is
    pcd                 - pointer to a COMPLIANCE_DATA structure describing the current source
    Reason              - COMPLIANCEERR_ flag indicating why compliance check fails

Return Value:

    TRUE if the install is compliant, FALSE if it isn't allowed

    NOTE : The error value could be set irrespective of return value of TRUE or false. For full media
    the return value is always true and only the "NoUpgradeAllowed" variable gets set indicating
    whether upgrade is allowed or not.

--*/
{
    PCCMEDIA    SourceMedia = 0;
    BOOL        UpgradeAllowed = FALSE;
    BOOLEAN     Result;
    TCHAR       DebugStr[1024];

    if (pcd) {
        SourceMedia = CCMediaCreate(SourceSku, SourceSkuVariation,
                                        SourceVersion, SourceBuildNum);

        if (SourceMedia) {
            Result = SourceMedia->CheckInstall(SourceMedia, pcd, Reason, &UpgradeAllowed);
            *NoUpgradeAllowed = (UpgradeAllowed) ? FALSE : TRUE;

            CCMemFree(SourceMedia);
        } else {
            *Reason = COMPLIANCEERR_UNKNOWNSOURCE;
            *NoUpgradeAllowed = TRUE;
            Result = FALSE;
        }
    } else {
        *Reason = COMPLIANCEERR_UNKNOWNTARGET;
        *NoUpgradeAllowed = TRUE;
        Result = FALSE;
    }

    return Result;
}


BOOL IsValidStepUpMode(
    CHAR  *StepUpArray,
    ULONG *StepUpMode
    )
{

    DWORD crcvalue,outval;

    #define BASE 'a'


    crcvalue = CRC_32( (LPBYTE)StepUpArray, 10 );
    RtlCopyMemory(&outval,&StepUpArray[10],sizeof(DWORD));
    if (crcvalue != outval ) {

#ifdef DBG

#ifdef KERNEL_MODE
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Setup: SpGetStepUpMode CRC didn't match for StepUpArray: %x %x\n", crcvalue, outval ));
#else
        OutputDebugString(TEXT("IsValidStepUpMode CRC failed\n"));
#endif

#endif // DBG

        return(FALSE);
        }

    if ((StepUpArray[3]-BASE)%2) {
        if ((StepUpArray[5]-BASE)%2) {

#ifdef DBG

#ifdef KERNEL_MODE
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "setup: this is stepup mode\n"));
#else
            OutputDebugString(TEXT("this is stepup mode\n"));
#endif

#endif //DBG

            *StepUpMode = 1;
            return(TRUE);
        } else {
#ifdef DBG

#ifdef KERNEL_MODE
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "setup: bad pid signature\n"));
#else
            OutputDebugString(TEXT("bad pid signature\n"));
#endif

#endif //DBG

            return(FALSE);
        }
    } else
        if ((StepUpArray[5]-BASE)%2) {

#ifdef DBG

#ifdef KERNEL_MODE
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "setup: bad pid signature\n"));
#else
            OutputDebugString(TEXT("bad pid signature\n"));
#endif

#endif //DBG

            return(FALSE);
        } else {
            *StepUpMode = 0;
            return(TRUE);
        }

    //
    // should never make it here
    //
    assert(FALSE);
    return(TRUE);

}



//
// Kernel mode only functions
//
#ifdef KERNEL_MODE
BOOL
pSpDetermineSourceProduct(
    PCOMPLIANCE_DATA pcd
    )
{
    ULONG i,tmp;

    TCHAR Dbg[1000];

    DWORD SuiteArray[] = { SUITE_VALUES };

    #define SuiteArrayCount sizeof(SuiteArray)/sizeof(DWORD)

    RtlZeroMemory(pcd,sizeof(COMPLIANCE_DATA));

    pcd->InstallType = AdvancedServer ?
                        COMPLIANCE_INSTALLTYPE_NTS :
                        COMPLIANCE_INSTALLTYPE_NTW ;
    pcd->RequiresValidation = (StepUpMode) ? TRUE : FALSE;


    for (i = 0,tmp=SuiteType; i<SuiteArrayCount;i++) {
        if (tmp&1) {
            pcd->InstallSuite |= SuiteArray[i];
        }
        tmp = tmp >> 1;
    }

    if (pcd->InstallSuite == COMPLIANCE_INSTALLSUITE_UNKNOWN) {
        pcd->InstallSuite = COMPLIANCE_INSTALLSUITE_NONE;
    }

    return TRUE;

}

BOOLEAN
pSpGetCurrentInstallVariation(
    IN  PWSTR szPid20,
    OUT LPDWORD CurrentInstallVariation
    )
/*++

Routine Description:

    This routine determines what "variation" you have installed (retail,oem, select,etc.)

Arguments:

    CurrentInstallVariation - receives a COMPLIANCE_INSTALLVAR_* flag

    It looks at the product Id in the registry to determine this, assuming that the
    product ID is a PID2.0 string.

Return Value:

    None.

--*/

{

    BOOLEAN retval = FALSE;
    WCHAR	Pid20Site[4] = {0};

    assert(CurrentInstallVariation != NULL);
    assert(szPid20 != NULL);

    if (!CurrentInstallVariation) {
        return(FALSE);
    }

    if (!szPid20 || (wcslen(szPid20) < 5)) {
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;
        return(TRUE);
    }

    *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;

    //
    // some versions of the product ID have hyphens in the registry, some do not
    //
    if (wcslen(szPid20) >= 8) {
	    if (wcschr(szPid20, '-')) {
	        wcsncpy(Pid20Site, szPid20 + 6, 3);
	    } else {
	        wcsncpy(Pid20Site, szPid20 + 5, 3);
	    }
	}		

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "Current site code: %S\n", Pid20Site ));

    if (wcscmp(Pid20Site, OEM_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_OEM;

    } else if (wcscmp(Pid20Site, SELECT_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;

    } else if (wcscmp(Pid20Site, MSDN_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_MSDN;

    } else if ((wcsncmp(szPid20, EVAL_MPC, 5) == 0) || (wcsncmp(szPid20, DOTNET_EVAL_MPC, 5) == 0)) {
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_EVAL;

    } else if ((wcsncmp(szPid20, SRV_NFR_MPC, 5) == 0) ||
               (wcsncmp(szPid20, ASRV_NFR_MPC, 5) == 0) ||
               (wcsncmp(szPid20, NT4SRV_NFR_MPC, 5) == 0)) {
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_NFR;

    } else {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;

    }

    return(TRUE);

}


BOOLEAN
pSpDetermineCurrentInstallation(
    IN PDISK_REGION OsPartRegion,
    IN PWSTR SystemRoot,
    OUT PCOMPLIANCE_DATA pcd
    )
/*++

Routine Description:

    This routine determines the sku you have currently have installed

Arguments:

    OsPartRegion - what region we're interested in looking at
    SystemRoot   - systemroot we want to look at
    pcd          - pointer to COMPLIANCE_DATA structure that gets filled in with info about the
                   installation the first params point to

Return Value:

    None.

--*/
{
    ULONG               MajorVersion, MinorVersion,
                        BuildNumber, ProductSuiteMask, ServicePack;
    NT_PRODUCT_TYPE     ProductType;
    UPG_PROGRESS_TYPE   UpgradeProgressValue;
    PWSTR               UniqueIdFromReg = NULL, Pid = NULL;
    NTSTATUS            NtStatus;
    ULONG               i,tmp;
    BOOLEAN             bIsEvalVariation = FALSE;
    DWORD               *pInstallSuite = 0;
    DWORD               *pInstallType = 0;


    DWORD SuiteArray[] = { SUITE_VALUES };

    #define SuiteArrayCount sizeof(SuiteArray)/sizeof(DWORD)

    assert( pcd != NULL ) ;

    RtlZeroMemory(pcd,sizeof(COMPLIANCE_DATA));

    NtStatus = SpDetermineProduct(OsPartRegion,
                                  SystemRoot,
                                  &ProductType,
                                  &MajorVersion,
                                  &MinorVersion,
                                  &BuildNumber,
                                  &ProductSuiteMask,
                                  &UpgradeProgressValue,
                                  &UniqueIdFromReg,
                                  &Pid,
                                  &bIsEvalVariation,
                                  NULL,
                                  &ServicePack);

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "Setup: pSpIsCompliant couldn't SpDetermineProduct(), ec = %x\n", NtStatus ));
        return(FALSE);
    }

    /*
    //
    // Note that we don't handle the case of upgrading from win9x here
    // this is because the compliance check for win9x is *always* completed in
    // winnt32; you can't upgrade to NT from win9x without running winnt32.
    //
    pcd->InstallType = AdvancedServer ? COMPLIANCE_INSTALLTYPE_NTS : COMPLIANCE_INSTALLTYPE_NTW;
    */

    switch (ProductType) {
        case NtProductWinNt:
            pcd->InstallType = COMPLIANCE_INSTALLTYPE_NTW;
            break;

        case NtProductLanManNt:
        case NtProductServer:
            pcd->InstallType = COMPLIANCE_INSTALLTYPE_NTS;
            break;

        default:
            // by default assume the installation type to be
            // NT workstation
            pcd->InstallType = COMPLIANCE_INSTALLTYPE_NTW;
            break;
    }

    pSpGetCurrentInstallVariation(Pid, &pcd->InstallVariation);

    //
    // if we defaulted in previous call and installation has time bomb
    // then assume the var is of type EVAL
    //
    if ((pcd->InstallVariation == COMPLIANCE_INSTALLVAR_CDRETAIL) && bIsEvalVariation)
        pcd->InstallVariation = COMPLIANCE_INSTALLVAR_EVAL;

    pcd->RequiresValidation = StepUpMode ? TRUE : FALSE;
    pcd->MinimumVersion = MajorVersion * 100 + MinorVersion*10;
    pcd->InstallServicePack = ServicePack;
    pcd->BuildNumberNt = BuildNumber;
    pcd->BuildNumberWin9x = 0;

    for (i = 0,tmp=ProductSuiteMask; i<SuiteArrayCount;i++) {
        if (tmp&1) {
            pcd->InstallSuite |= SuiteArray[i];
        }
        tmp = tmp >> 1;
    }

    pInstallSuite = &(pcd->InstallSuite);
    pInstallType = &(pcd->InstallType);

    //
    // from the install suite find the correct type of install
    // type for the server (i.e. NTS, NTSE, NTSDTC or NTSTSE)
    //
    if (*pInstallSuite == COMPLIANCE_INSTALLSUITE_UNKNOWN)
        *pInstallSuite = COMPLIANCE_INSTALLSUITE_NONE;
    else {
        if (*pInstallType == COMPLIANCE_INSTALLTYPE_NTS) {
            if ((BuildNumber <= 1381) &&
                    *pInstallSuite == COMPLIANCE_INSTALLSUITE_HYDRA) {
                *pInstallType = COMPLIANCE_INSTALLTYPE_NTSTSE;
            } else {
                if (*pInstallSuite & COMPLIANCE_INSTALLSUITE_DTC) {
                    *pInstallType = COMPLIANCE_INSTALLTYPE_NTSDTC;
                } else {
                    if (*pInstallSuite & COMPLIANCE_INSTALLSUITE_ENT) {
                        if( *pInstallSuite & COMPLIANCE_INSTALLSUITE_BLADE) {
                            *pInstallType = COMPLIANCE_INSTALLTYPE_NTSPOW;
                        } else {
                            *pInstallType = COMPLIANCE_INSTALLTYPE_NTSE;
                        }
                    } else {
                        if (*pInstallSuite & COMPLIANCE_INSTALLSUITE_SBSR) {
                            *pInstallType = COMPLIANCE_INSTALLTYPE_NTSBS;
                        }
                    }
                }
            }
        }
    }

    //
    // since there is no data center EVAL type if we detect its eval
    // because of time bomb set, we assume it to be CD-Retail.
    //
    if((pcd->InstallVariation == COMPLIANCE_INSTALLVAR_EVAL) &&
            (*pInstallType == COMPLIANCE_INSTALLTYPE_NTSDTC)) {
        pcd->InstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;
    }	

    //
    // Free up the allocated memory
    //
    if (UniqueIdFromReg)
        SpMemFree(UniqueIdFromReg);

    if (Pid)
        SpMemFree(Pid);

    return(TRUE);
}

BOOLEAN
pSpIsCompliant(
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PDISK_REGION OsPartRegion,
    IN PWSTR SystemRoot,
    OUT PBOOLEAN UpgradeOnlyCompliant
    )
/*++

Routine Description:

    This routine determines if the current specified installation is compliant for the
    source we want to install

Arguments:

    InfPath - inf file path containing [Version] section with DriverVer data
    OsPartRegion - points to target
    SystemRoot - points to target
    UpgradeOnlyCompliant - set to TRUE if we can only allow upgrades from the source SKU

Return Value:

    TRUE if the current target is compliant for the source.

--*/
{
    ULONG MajorVersion, MinorVersion, BuildNumber, ProductSuiteMask;
    NT_PRODUCT_TYPE ProductType;
    UPG_PROGRESS_TYPE UpgradeProgressValue;
    PWSTR UniqueIdFromReg, Pid;
    NTSTATUS NtStatus;
    BOOLEAN Rslt;
    BOOL UpgOnly = FALSE;
    COMPLIANCE_DATA TargetData;
    DWORD SourceData,SourceSkuVariation;
    UINT dontcare;
    BOOL dontcare2;

    assert(UpgradeOnlyCompliant != NULL);

    if ((SourceData = DetermineSourceProduct(&SourceSkuVariation,NULL))== COMPLIANCE_SKU_NONE) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "setup: Couldnt' determine source SKU\n" ));
        return(FALSE);
    }

    if (!pSpDetermineCurrentInstallation( OsPartRegion, SystemRoot, &TargetData)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "setup: pSpDetermineCurrentInstallation failed\n" ));
        return(FALSE);
    }

    UpgOnly = TargetData.RequiresValidation;

    Rslt = CheckCompliance(SourceData, SourceSkuVariation, SourceVersion,
                      SourceBuildNum, &TargetData,&dontcare,&dontcare2);

	*UpgradeOnlyCompliant = (UpgOnly != 0);

    return(Rslt);
}

#define NibbleToChar(x) (N2C[x])
#define CharToNibble(x) ((x)>='0'&&(x)<='9' ? (x)-'0' : ((10+(x)-'A')&0x000f))
char N2C[] = {
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
};


BOOLEAN
MyTranslatePrivateProfileStruct(
    PSTR   InputString,
    LPVOID lpStruct,
    UINT   uSizeStruct
    )
/*++

Routine Description:

    translates a string from an encoded checksummed version into the real structure.
    stolen from GetPrivateProfileStructA

Arguments:

    InputString - pointer to input string to convert
    lpStruct - point to structure that receives the converted data
    uSizeStruct - size of the input structure

Return Value:

    TRUE if it succeeds in translating into the specified structure, FALSE otherwise.

--*/

{

    CHAR szBuf[256] = {0};
    PSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen,tmp;
    BYTE checksum;
    BOOLEAN Result;

    lpFreeBuffer = NULL;
    lpBuf = (PSTR)szBuf;

    Result = FALSE;

    nLen = strlen( InputString );
    RtlCopyMemory( lpBuf, InputString, nLen );

    if (nLen == uSizeStruct*2+2) {
        /* Room for the one byte check sum */
        uSizeStruct+=1;
        checksum = 0;
        for (lpBufTemp=lpBuf; uSizeStruct!=0; --uSizeStruct) {
            BYTE bStruct;
            BYTE cTemp;

            cTemp = *lpBufTemp++;
            bStruct = (BYTE)CharToNibble(cTemp);
            cTemp = *lpBufTemp++;
            bStruct = (BYTE)((bStruct<<4) | CharToNibble(cTemp));

            if (uSizeStruct == 1) {
                if (checksum == bStruct) {
                    Result = TRUE;
                    }
                break;
                }

            checksum += bStruct;
            *((LPBYTE)lpStruct)++ = bStruct;
            }
        }

    return Result;
}



BOOLEAN
SpGetStepUpMode(
    PWSTR   PidExtraData,
    BOOLEAN *StepUpMode
    )
/*++

Routine Description:

    This routine determines if the specified source is in Step Up Mode or
    if it's a full retail install.

Arguments:

    PidExtraData - checksummed encoded data read out of setupp.ini
    StepUpMode   - set to TRUE if we're in stepup mode.  value is undefined if
                   we fail to translate the input data.

    This routine assumes that the data passed in is a string set by the "pidinit"
    program.  It decodes this data and makes sure the checksum is correct.
    It then checks the CRC value tacked onto the string to determine if the
    data has been tampered with.
    If both of these checks pass, then it looks at the actual data.
    The actual check is this: If the 3rd and 5th bytes are modulo 2 (when
    subtracted from the base value 'a'), then we're in stepup mode.  Otherwise
    we're in full retail mode.

    Note that the intent of this algorithm isn't to provide alot of security
    (it will be trivial to copy the desired setupp.ini over the current one),
    it's main intent is to discourage people from tampering with these values
    in the same manner that data is set in the default hives to discourage
    tampering.

Return Value:

    TRUE if we're able to determine the stepupmode.  FALSE if the input data is bogus.

--*/
{
    CHAR Buffer[64] = {0};
    CHAR StepUpArray[14];
    ULONG Needed;
    BOOL Mode;
    NTSTATUS NtStatus;

    NtStatus = RtlUnicodeToOemN(Buffer,
                                sizeof(Buffer),
                                &Needed,
                                PidExtraData,
                                wcslen(PidExtraData)*sizeof(WCHAR)
                                );

    if (! NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "Setup: SpGetStepUpMode couldn't RtlUnicodeToOemN failed, ec = %x\n", NtStatus ));
        return(FALSE);
    }


    if (!MyTranslatePrivateProfileStruct(Buffer,StepUpArray,sizeof(StepUpArray))) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "Setup: SpGetStepUpMode couldn't MyTranslatePrivateProfileStruct\n" ));
        return(FALSE);
    }

    if (!IsValidStepUpMode( StepUpArray , &Mode )) {
        return(FALSE);
    }

    *StepUpMode = Mode ? TRUE : FALSE;
    return(TRUE);



}

#endif


//
// User mode only functions
//

#ifndef KERNEL_MODE

BOOL
GetCdSourceInstallType(
    LPDWORD SourceInstallType
    )
/*++

Routine Description:

    This routine determines what version of NT you are installing, NTW or NTS.  It does this by looking in
    dosnet.inf

Arguments:

    SourceInstallType -- receives a COMPLIANCE_INSTALLTYPE flag indicating what type you are installing

Return Value:

    TRUE for success, FALSE for failure

--*/

{

    TCHAR FileName[MAX_PATH];
    TCHAR Buffer[10];
    TCHAR ptr[1] = {0};
    LPTSTR p = &ptr[1];

    wsprintf( FileName, TEXT("%s\\dosnet.inf"), NativeSourcePaths[0]);

    GetPrivateProfileString(TEXT("Miscellaneous"), TEXT("ProductType"), TEXT("0"),
            Buffer, sizeof(Buffer)/sizeof(TCHAR), FileName);

    switch (_tcstoul(Buffer, &p, 10) ) {
        case 0:
            *SourceInstallType = COMPLIANCE_INSTALLTYPE_NTW;
            break;
        case 1:
            *SourceInstallType  = COMPLIANCE_INSTALLTYPE_NTS;
            break;
        case 2:
            *SourceInstallType  = COMPLIANCE_INSTALLTYPE_NTSE;
            break;
        case 3:
            *SourceInstallType  = COMPLIANCE_INSTALLTYPE_NTSDTC;
            break;
        case 4:
            *SourceInstallType = COMPLIANCE_INSTALLTYPE_NTWP;
            break;
        case 5:
            *SourceInstallType = COMPLIANCE_INSTALLTYPE_NTSB;
            break;
        case 6:
            *SourceInstallType = COMPLIANCE_INSTALLTYPE_NTSBS;
            break;
        default:
            *SourceInstallType  = COMPLIANCE_INSTALLTYPE_NTW;
            return(FALSE);
    }

    return(TRUE);

}

BOOL
GetStepUpMode(
    BOOL *StepUpMode
    )
/*++

Routine Description:

    This routine determines if the specified source is in Step Up Mode or
    if it's a full retail install.

Arguments:

    StepUpMode   - set to TRUE if we're in stepup mode.  value is undefined if
                   we fail to translate the input data.

    This routine assumes that the data passed in is a string set by the "pidinit"
    program.  It decodes this data and makes sure the checksum is correct.
    It then checks the CRC value tacked onto the string to determine if the
    data has been tampered with.
    If both of these checks pass, then it looks at the actual data.
    The actual check is this: If the 3rd and 5th bytes are modulo 2 (when
    subtracted from the base value 'a'), then we're in stepup mode.  Otherwise
    we're in full retail mode.

    Note that the intent of this algorithm isn't to provide alot of security
    (it will be trivial to copy the desired setupp.ini over the current one),
    it's main intent is to discourage people from tampering with these values
    in the same manner that data is set in the default hives to discourage
    tampering.

Return Value:

    TRUE if we're able to determine the stepupmode.  FALSE if the input data is bogus.

--*/
{

    char FileName[MAX_PATH];
    char  data[14];
    TCHAR ptr[1] = {0};
    LPTSTR p = &ptr[1];

#ifdef UNICODE
    char SourcePath[MAX_PATH];
    BOOL changed = FALSE;

    WideCharToMultiByte(CP_ACP,
                        0,
                        NativeSourcePaths[0],
                        MAX_PATH,
                        SourcePath,
                        sizeof(SourcePath),
                        "?",
                        &changed);

    sprintf( FileName, "%s\\setupp.ini", SourcePath);
#else
    sprintf( FileName, "%s\\setupp.ini", NativeSourcePaths[0]);
#endif

    GetPrivateProfileStructA("Pid",
                             "ExtraData",
                             data,
                             sizeof(data),
                             FileName);



    if (!IsValidStepUpMode(data,StepUpMode)) {
        return(FALSE);
    }

    return(TRUE);

}

BOOL
GetSuiteInfoFromDosnet(
    OUT LPDWORD Suite
    )
/*++

Routine Description:

    This routine determines what suite you are installing
    It does this by looking at dosnet.inf

Arguments:

    Suite  -- receives a COMPLIANCE_INSTALLSUITE flag

Return Value:

    TRUE for success, FALSE for failure

--*/

{

    TCHAR FileName[MAX_PATH];
    TCHAR Buffer[10];
    TCHAR ptr[1] = {0};
    LPTSTR p = &ptr[1];

    *Suite = COMPLIANCE_INSTALLSUITE_ANY;

    wsprintf( FileName, TEXT("%s\\dosnet.inf"), NativeSourcePaths[0]);

    GetPrivateProfileString(TEXT("Miscellaneous"), TEXT("ProductType"), TEXT("0"),
                Buffer, sizeof(Buffer)/sizeof(TCHAR), FileName);

    switch (_tcstoul(Buffer, &p, 10) ) {
        case 0:
        case 1:
            *Suite = COMPLIANCE_INSTALLSUITE_NONE;
            break;
        case 2:
            *Suite = COMPLIANCE_INSTALLSUITE_ENT;
            break;
        case 3:
            *Suite = COMPLIANCE_INSTALLSUITE_DTC;
            break;
        case 4:
            *Suite = COMPLIANCE_INSTALLSUITE_PER;
            break;
        case 5:
            *Suite = COMPLIANCE_INSTALLSUITE_BLADE;
            break;
        case 6:
            *Suite = COMPLIANCE_INSTALLSUITE_SBS;
            break;
        default:
            ;
#ifdef DBG
            OutputDebugString( TEXT("Invalid ProductType!\n"));
#endif
            return(FALSE);
    }

    return (TRUE);

}


BOOL
GetSourceInstallVariation(
    LPDWORD SourceInstallVariation
    )
/*++

Routine Description:

    This routine determines what variation of NT you are installing, SELECT,OEM,retail...

Arguments:

    SourceInstallVariation -- receives a COMPLIANCE_INSTALLVAR flag indicating what var
                              type you are installing

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    GetSourceInstallType(SourceInstallVariation);


    /*
    switch(SourceInstallType) {
        case SelectInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;
            break;

        case OEMInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_OEM;
            break;

        case RetailInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;
            break;

        case MSDNInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_MSDN;
            break;

        case EvalInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_EVAL;
            break;

        case NFRInstall:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_NFR;
            break;

        default:
            *SourceInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;
            break;
    }
    */

    return(TRUE);
}


BOOL
GetSourceComplianceData(
    OUT PCOMPLIANCE_DATA pcd,
    IN  PCOMPLIANCE_DATA Target
    )
{
#ifdef USE_HIVE
    TCHAR HiveLocation[MAX_PATH];
    TCHAR HiveTarget[MAX_PATH];
    TCHAR HivePath[MAX_PATH];
    TCHAR HiveName[MAX_PATH] = TEXT("xSETREG");
    TCHAR lpszSetupReg[MAX_PATH] = TEXT("xSETREG\\ControlSet001\\Services\\setupdd");
    TCHAR TargetPath[MAX_PATH];

    LONG rslt;
    HKEY hKey;
    DWORD Type;
    DWORD Buffer[4];
    DWORD BufferSize = sizeof(Buffer);
    DWORD tmp,i;
#endif

    BOOL RetVal = FALSE;

#ifdef DBG
    TCHAR Dbg[1000];
#endif

#ifdef USE_HIVE
    DWORD SuiteArray[] = { SUITE_VALUES };

    #define SuiteArrayCount sizeof(SuiteArray)/sizeof(DWORD)
#endif

    ZeroMemory( pcd, sizeof(COMPLIANCE_DATA) );

    if (!GetCdSourceInstallType(&pcd->InstallType)) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't getcdsourceinstalltype\n"));
#endif
        goto e0;
    }


    if (!GetSourceInstallVariation(&pcd->InstallVariation)) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't getsourceinstallvariation\n"));
#endif
        goto e0;
    }

    if (!GetStepUpMode(&pcd->RequiresValidation)) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't getstepupmode\n"));
#endif
        goto e0;
    }

    RetVal = GetSuiteInfoFromDosnet( &pcd->InstallSuite ) ;
    goto e0;

#ifdef USE_HIVE
    //
    // now we need to determine if we are installing enterprise or datacenter
    // To do this, we try to load the registry hive, but this won't work on
    // win9x or nt 3.51.  So we use dosnet.inf to get the information we need
    // in those cases.
    //
    if ( (Target->InstallType &
         (COMPLIANCE_INSTALLTYPE_WIN31 | COMPLIANCE_INSTALLTYPE_WIN9X)) ||
         (Target->BuildNumberNt < 1381) ) {
        RetVal = GetSuiteInfoFromDosnet( &pcd->InstallSuite ) ;
        goto e0;
    }


    //
    // copy the hive locally since you can only have one open on a hive at a time
    //
    wsprintf( HiveLocation, TEXT("%s\\setupreg.hiv"), NativeSourcePaths[0]);
    GetTempPath(MAX_PATH,TargetPath);
    GetTempFileName(TargetPath,TEXT("set"),0,HiveTarget);

    CopyFile(HiveLocation,HiveTarget,FALSE);
    SetFileAttributes(HiveTarget,FILE_ATTRIBUTE_NORMAL);

#ifdef DBG
    OutputDebugString(HiveLocation);
    OutputDebugString(TEXT("\n"));
    OutputDebugString(HiveTarget);
#endif

    //
    // try to unload this first in case we faulted or something and the key is still loaded
    //
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HiveName );

    //
    // need SE_RESTORE_NAME priviledge to call this API!
    //
    rslt = RegLoadKey( HKEY_LOCAL_MACHINE, HiveName, HiveTarget );
    if (rslt != ERROR_SUCCESS) {
#ifdef DBG
        wsprintf( Dbg, TEXT("Couldn't RegLoadKey, ec = %d\n"), rslt );
        OutputDebugString(Dbg);
#endif
        //assert(FALSE);
        goto e1;
    }

    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,lpszSetupReg,&hKey);
    if (rslt != ERROR_SUCCESS) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't RegOpenKey\n"));
#endif
        //assert(FALSE);
        goto e2;
    }

    rslt = RegQueryValueEx(hKey, NULL, NULL, &Type, (LPBYTE) Buffer, &BufferSize);
    if (rslt != ERROR_SUCCESS || Type != REG_BINARY) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't RegQueryValueEx\n"));
#endif
        //assert(FALSE);
        goto e3;
    }

    for (i = 0,tmp=Buffer[3]; i<SuiteArrayCount;i++) {
        if (tmp & 1) {
            pcd->InstallSuite |= SuiteArray[i];
        }
        tmp = tmp >> 1;
    }

    RetVal = TRUE;

e3:
    RegCloseKey( hKey );
e2:
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HiveName );

e1:
    if (GetFileAttributes(HiveTarget) != 0xFFFFFFFF) {
        SetFileAttributes(HiveTarget,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(HiveTarget);
    }
#endif // USE_HIVE
e0:

    return(RetVal);

}


BOOL
GetCurrentNtVersion(
    LPDWORD CurrentInstallType,
    LPDWORD CurrentInstallSuite
    )
/*++

Routine Description:

    This routine determines what type of NT you currently have installed, NTW or NTS,
    as well as what product suite you have installed.

    It looks in the registry for this data.

Arguments:

    CurrentInstallType - receives a COMPLIANCE_INSTALLTYPE_* flag
    CurrentInstallSuite - receives a COMPLIANCE_INSTALLSUITE_* flag

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    LPCTSTR lpszProductKey = TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions");
    LPCTSTR lpszProductType = TEXT("ProductType");
    LPCTSTR lpszProductSuite = TEXT("ProductSuite");
    LPCTSTR lpszProductSuites[] = { TEXT("Small Business"),
                                    TEXT("Enterprise"),
                                    TEXT("BackOffice"),
                                    TEXT("CommunicationServer"),
                                    TEXT("Terminal Server"),
                                    TEXT("Small Business(Restricted)"),
                                    TEXT("EmbeddedNT"),
                                    TEXT("DataCenter"),
                                    TEXT("Personal"),
                                    TEXT("Blade")
                                  };

    LPCTSTR lpszProductPowered = TEXT("Server Appliance");

    DWORD   ProductSuites[] = { SUITE_VALUES };

    #define CountProductSuites  sizeof(ProductSuites)/sizeof(DWORD)

    LPCTSTR lpszProductTypeNTW = TEXT("WinNT");

    LPCTSTR lpszCitrixKey = TEXT("SYSTEM\\CurrentControlSet\\Control\\Citrix");
    LPCTSTR lpszOemKey = TEXT("OemId");
    LPCTSTR lpszProductVersion = TEXT("ProductVersion");

    HKEY hKey;
    long rslt;
    DWORD Type;
    LPTSTR p;
    TCHAR Buffer[MAX_PATH];
    DWORD BufferSize = sizeof(Buffer);
    DWORD i;
    BOOL retval = FALSE;


    //
    // default to NTW
    //
    *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTW;
    *CurrentInstallSuite = COMPLIANCE_INSTALLSUITE_NONE;

    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,lpszProductKey,&hKey);
    if (rslt != NO_ERROR) {
        return(FALSE);
    }

    rslt = RegQueryValueEx(hKey, lpszProductType, NULL, &Type, (LPBYTE) Buffer, &BufferSize);
    if (rslt != NO_ERROR || Type != REG_SZ) {
        goto exit;
    }

    if (lstrcmpi(Buffer,lpszProductTypeNTW) != 0) {
        //
        // we have some version of NTS
        //
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTS;
    }

    retval = TRUE;

    BufferSize = sizeof(Buffer);
    ZeroMemory(Buffer,sizeof(Buffer));
    rslt = RegQueryValueEx(hKey, lpszProductSuite, NULL, &Type, (LPBYTE) Buffer, &BufferSize);
    if (rslt != NO_ERROR || Type != REG_MULTI_SZ) {
        //
        // might not be there for NT 3.51, just succeed if it's not there
        // Also, won't be there for Professional - aka WKS
        //
        goto exit;
    }

    p = &Buffer[0];
    while (p && *p) {
        for (i = 0; i < CountProductSuites; i++) {
            if (lstrcmp(p, lpszProductSuites[i]) == 0) {
                *CurrentInstallSuite |= ProductSuites[i];
            }
            // W2k powered windows uses the same bit as blade.
            else if( lstrcmp(p, lpszProductPowered) == 0) {
                *CurrentInstallSuite |= COMPLIANCE_INSTALLSUITE_BLADE;
            }
        }

        //
        // point to the next product suite
        //
        p += lstrlen(p) + 1;
    }

    retval = TRUE;
                                                    
    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_DTC)
     && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTS) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSDTC;
    }

    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_ENT)
         && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTS) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSE;
    }

    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_BLADE)
         && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTS) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSB;
    }
    
    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_SBSR)
         && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTS) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSBS;
    }

    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_PER)
         && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTW) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTWP;
    }

    // special case for powered windows which has enterprise and blade suite!
    if ( (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_BLADE)
         && (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_ENT)
         && *CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTSE) {
        *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSPOW;
    }

    if (*CurrentInstallSuite & COMPLIANCE_INSTALLSUITE_ANY) {
        *CurrentInstallSuite = *CurrentInstallSuite & (~COMPLIANCE_INSTALLSUITE_NONE);
    }


exit:
    RegCloseKey(hKey);

    //
    // if we haven't found a product suite at this point, look for Citrix WinFrame,
    // which we'll treat as terminal server
    //

    if (*CurrentInstallSuite == COMPLIANCE_INSTALLSUITE_NONE) {

        rslt = RegOpenKey(HKEY_LOCAL_MACHINE,lpszCitrixKey,&hKey);
        if (rslt != NO_ERROR) {
            return(TRUE);
        }

        BufferSize = sizeof(Buffer);
        rslt = RegQueryValueEx(
                       hKey,
                       lpszOemKey,
                       NULL,
                       &Type,
                       (LPBYTE) Buffer,
                       &BufferSize);
        if (rslt == NO_ERROR && Type == REG_SZ) {
            if (Buffer[0] != TEXT('\0')) {
                BufferSize = sizeof(Buffer);
                rslt = RegQueryValueEx(
                                hKey,
                                lpszProductVersion,
                                NULL,
                                &Type,
                                (LPBYTE) Buffer,
                                &BufferSize);

                if (rslt == NO_ERROR) {
                    *CurrentInstallSuite = COMPLIANCE_INSTALLSUITE_HYDRA;
                    *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSTSE;
                }
            }
        }

        RegCloseKey(hKey);
    }

    return(retval);
}

BOOL
GetCurrentInstallVariation(
    OUT LPDWORD CurrentInstallVariation,
    IN  DWORD   CurrentInstallType,
    IN  DWORD   CurrentInstallBuildNT,
    IN  DWORD   InstallVersion
    )
/*++

Routine Description:

    This routine determines what "variation" you have installed (retail,oem, select,etc.)

Arguments:

    CurrentInstallVariation - receives a COMPLIANCE_INSTALLVAR_* flag

    It looks at the product Id in the registry to determine this, assuming that the
    product ID is a PID2.0 string. To check whether its a EVAL variation or not
    it looks at "PriorityQuantumMatrix" value in registry

Return Value:

    None.

--*/

{
    LPCTSTR lpszPidKeyWin      = TEXT("Software\\Microsoft\\Windows\\CurrentVersion");
    LPCTSTR lpszPidKeyWinNT    = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
    LPCTSTR lpszProductId      = TEXT("ProductId");
    LPCTSTR szEvalKey          = TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Executive");
    LPCTSTR szPQMValue         = TEXT("PriorityQuantumMatrix");

    HKEY    hKey = NULL;
    long    rslt;
    DWORD   Type;
    LPTSTR  p;
    TCHAR   Buffer[MAX_PATH];
    DWORD   BufferSize = sizeof(Buffer);
    DWORD   i;
    BOOL    bResult = FALSE;
    BOOLEAN bDone = FALSE;
    TCHAR   Pid20Site[4];
    TCHAR   MPCCode[6] = {-1};
    BYTE    abPQM[64] = {-1};

    *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;

    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,
                      ISNT() ? lpszPidKeyWinNT : lpszPidKeyWin,
                      &hKey);

    if (rslt != NO_ERROR) {
        goto exit;
    }

    rslt = RegQueryValueEx(hKey, lpszProductId, NULL, &Type, (LPBYTE) Buffer, &BufferSize);

    if (rslt != NO_ERROR || Type!=REG_SZ || (!IsWinPEMode() && (lstrlen(Buffer) < 20))) {
        //
        // nt 3.51 is pid 1.0 instead of pid 2.0.  Just assume it's
        // oem variation for now.
        //
        if (((CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTS) ||
            (CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTW)  ||
            (CurrentInstallType == COMPLIANCE_INSTALLTYPE_NTSTSE)) &&
            (CurrentInstallBuildNT < 1381 )) {
            *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_OEM;
            bResult = TRUE;
        }
        goto exit;
    }

    // get the MPC code from PID
    lstrcpyn(MPCCode, Buffer, 6);

    //
    // some versions of the product ID have hyphens in the registry, some do not
    //
    if (_tcschr(Buffer, TEXT('-'))) {
        lstrcpyn(Pid20Site,&Buffer[6],4);
        Pid20Site[3] = (TCHAR) NULL;
    } else {
        lstrcpyn(Pid20Site,&Buffer[5],4);
        Pid20Site[3] = (TCHAR) NULL;
    }

//    OutputDebugString(Pid20Site);
//    OutputDebugString(TEXT("\r\n"));
//    OutputDebugString(MPCCode);


    if (lstrcmp(Pid20Site, OEM_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_OEM;

    } else if (lstrcmp(Pid20Site, SELECT_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_SELECT;

    } else if (lstrcmp(Pid20Site, MSDN_INSTALL_RPC)== 0) {

        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_MSDN;

    } else if ((lstrcmp(MPCCode, EVAL_MPC) == 0) || (lstrcmp(MPCCode, DOTNET_EVAL_MPC) == 0)) {
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_EVAL;

    } else if ((lstrcmp(MPCCode, SRV_NFR_MPC) == 0) ||
             (lstrcmp(MPCCode, ASRV_NFR_MPC) == 0) ||
             (lstrcmp(MPCCode, NT4SRV_NFR_MPC) == 0)){
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_NFR;

    } else {
        //
        // find out if installation is of type EVAL variation (On NT install only)
        // if timebomb is set we assume its EVAL except for DataCenter because
        // there is no EVAL DataCenter SKU.
        //
        if (ISNT() && (CurrentInstallType != COMPLIANCE_INSTALLTYPE_NTSDTC) && (InstallVersion < 500)) {
            HKEY    hEvalKey = NULL;

            if (RegOpenKey(HKEY_LOCAL_MACHINE, szEvalKey, &hEvalKey) == ERROR_SUCCESS) {
                DWORD   dwSize = sizeof(abPQM);

                if (RegQueryValueEx(hEvalKey, szPQMValue, NULL, &Type, abPQM, &dwSize)
                        == ERROR_SUCCESS) {

                    // any of bytes 4-7 (inclusive)
                    if ((Type == REG_BINARY) && (dwSize >= 8) && (*(ULONG *)(abPQM + 4))) {
                        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_EVAL;
					}
                }

                RegCloseKey(hEvalKey);
            }
        }


        // last default assumption (since we could not find var type).
        if (*CurrentInstallVariation == COMPLIANCE_INSTALLVAR_SELECT)
	        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;
    }

    bResult = TRUE;

exit:
    //
    // If we couldn't find a PID, just treat the current OS as retail
    //
    if (!bResult) {
        *CurrentInstallVariation = COMPLIANCE_INSTALLVAR_CDRETAIL;
        bResult = TRUE;
    }

    if (hKey)
        RegCloseKey(hKey);

    return  bResult;
}


BOOL
DetermineCurrentInstallation(
    LPDWORD CurrentInstallType,
    LPDWORD CurrentInstallVariation,
    LPDWORD CurrentInstallVersion,
    LPDWORD CurrentInstallBuildNT,
    LPDWORD CurrentInstallBuildWin9x,
    LPDWORD CurrentInstallSuite,
    LPDWORD CurrentInstallServicePack
    )
/*++

Routine Description:

    This routine determines the current installation you have installed, including
    a) current install type (NTW,NTS,Win9x
    b) current install variation (oem,select, retail)
    c) current install version (for NT only!)
    d) current install suite (SBS, ENTERPRISE,etc.)

Arguments:

    CurrentInstallType -  receives a COMPLIANCE_INSTALLTYPE_* flag
    CurrentInstallVariation - receives a COMPLIANCE_INSTALLVAR_* flag
    CurrentInstallVersion - receives a representation of the build (major.minor * 100), ie., 3.51 == 351
    CurrentInstallBuildNT -  build number for an nt install
    CurrentInstallBuildWin9 - build number for a win9x install
    CurrentInstallSuite - receives a COMPLIANCE_INSTALLSUITE_* flag

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    BOOL useExtendedInfo;
    union {
        OSVERSIONINFO Normal;
        OSVERSIONINFOEX Ex;
    } Ovi;


#ifdef DBG
    TCHAR dbg[1000];
#endif

    if (!CurrentInstallType || !CurrentInstallVariation || !CurrentInstallVersion || !CurrentInstallSuite) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return(FALSE);
    }

    useExtendedInfo = TRUE;
    Ovi.Ex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx((OSVERSIONINFO *)&Ovi.Ex) ) {
        //
        // EX size not available; try the normal one
        //

        Ovi.Normal.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (!GetVersionEx((OSVERSIONINFO *)&Ovi.Normal) ) {
            assert(FALSE);
            return(FALSE);
        }

        useExtendedInfo = FALSE;
    }

    switch (Ovi.Normal.dwPlatformId) {
        case VER_PLATFORM_WIN32s:
#ifdef DBG
            OutputDebugString(TEXT("Win32s current installation!!!"));
#endif
            //assert(FALSE);
            return(FALSE);
            break;
        case VER_PLATFORM_WIN32_WINDOWS:
            *CurrentInstallType = COMPLIANCE_INSTALLTYPE_WIN9X;
            *CurrentInstallSuite = COMPLIANCE_INSTALLSUITE_NONE;
            *CurrentInstallBuildNT = 0;
            *CurrentInstallBuildWin9x = Ovi.Normal.dwBuildNumber;
#ifdef DBG
            wsprintf(dbg, TEXT("%d\n"), *CurrentInstallBuildWin9x);
            OutputDebugString(dbg);
#endif
            //
            // Need to know what version of windows is installed so we can block upgrade
            // from win95.
            //
            *CurrentInstallVersion = Ovi.Normal.dwMajorVersion * 100 + Ovi.Normal.dwMinorVersion;

            if (useExtendedInfo) {
                *CurrentInstallServicePack = Ovi.Ex.wServicePackMajor * 100 + Ovi.Ex.wServicePackMinor;
            } else {
                *CurrentInstallServicePack = 0;
            }
            break;
        case VER_PLATFORM_WIN32_NT:
            if (!GetCurrentNtVersion(
                                CurrentInstallType,
                                CurrentInstallSuite)) {
                return(FALSE);
            }

            *CurrentInstallVersion = Ovi.Normal.dwMajorVersion * 100 + Ovi.Normal.dwMinorVersion;

            if (useExtendedInfo) {
                *CurrentInstallServicePack = Ovi.Ex.wServicePackMajor * 100 + Ovi.Ex.wServicePackMinor;
            } else {
                *CurrentInstallServicePack = 0;
            }

            *CurrentInstallBuildWin9x = 0;
            *CurrentInstallBuildNT = Ovi.Normal.dwBuildNumber;

            if (*CurrentInstallBuildNT <= 1381
                && *CurrentInstallSuite == COMPLIANCE_INSTALLSUITE_HYDRA) {
                *CurrentInstallType = COMPLIANCE_INSTALLTYPE_NTSTSE;
            }

            break;
    default:
#ifdef DBG
        OutputDebugString(TEXT("unknown installation!!!"));
#endif
        assert(FALSE);
        return(FALSE);
    }

    if (!GetCurrentInstallVariation(CurrentInstallVariation,*CurrentInstallType,*CurrentInstallBuildNT, *CurrentInstallVersion)) {
#ifdef DBG
        OutputDebugString(TEXT("GetCurrentInstallVariation failed\n"));
#endif
        //assert(FALSE);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
IsCompliant(
    PBOOL UpgradeOnly,
    PBOOL NoUpgradeAllowed,
    PUINT SrcSku,
    PUINT CurrentInstallType,
    PUINT CurrentInstallVersion,
    PUINT Reason
    )
/*++

Routine Description:

    This routines determines if your current installation is compliant (if you are allowed to proceed with your installation).

    To do this, it retreives your current installation and determines the sku for your source installation.

    It then compares the target against the source to determine if the source sku allows an upgrade/clean install
    from your target installation.

Arguments:

    UpgradeOnly - This flag gets set to TRUE if the current SKU only allows upgrades.  This
                  lets winnt32 know that it should not allow a clean install from the current
                  media.  This get's set correctly regardless of the compliance check passing
    SrcSku      - COMPLIANCE_SKU flag indicating source sku (for error msg's)
    Reason      - COMPLIANCEERR flag indicating why compliance check failed.

Return Value:

    TRUE if the install is compliant, FALSE if it isn't allowed

--*/
{
    DWORD SourceSku;
    DWORD SourceSkuVariation;
    DWORD SourceVersion;
    DWORD SourceBuildNum;
    TCHAR DosnetPath[MAX_PATH] = {0};

    COMPLIANCE_DATA TargetData;

    ZeroMemory(&TargetData, sizeof(TargetData) );

    *UpgradeOnly = FALSE;
    *NoUpgradeAllowed = TRUE;
    *Reason = COMPLIANCEERR_UNKNOWN;
    *SrcSku = COMPLIANCE_SKU_NONE;
    *CurrentInstallType = COMPLIANCE_INSTALLTYPE_UNKNOWN;
    *CurrentInstallVersion = 0;

    if (!DetermineCurrentInstallation(&TargetData.InstallType,
                                  &TargetData.InstallVariation,
                                  &TargetData.MinimumVersion,
                                  &TargetData.BuildNumberNt,
                                  &TargetData.BuildNumberWin9x,
                                  &TargetData.InstallSuite,
                                  &TargetData.InstallServicePack)) {
#ifdef DBG
        OutputDebugString(TEXT("Error determining current installation"));
#endif
        *Reason = COMPLIANCEERR_UNKNOWNTARGET;
        return(FALSE);
    }

    *CurrentInstallType = TargetData.InstallType;
    if (TargetData.InstallType & COMPLIANCE_INSTALLTYPE_WIN9X) {
        *CurrentInstallVersion = TargetData.BuildNumberWin9x;
    } else {
        *CurrentInstallVersion = TargetData.BuildNumberNt;
    }

    if ((SourceSku = DetermineSourceProduct(&SourceSkuVariation,&TargetData)) == COMPLIANCE_SKU_NONE) {
#ifdef DBG
        OutputDebugString(TEXT("couldn't determine source sku!"));
#endif
        *Reason = COMPLIANCEERR_UNKNOWNSOURCE;
        return(FALSE);
    }

    wsprintf(DosnetPath, TEXT("%s\\dosnet.inf"), NativeSourcePaths[0]);

    if (!DetermineSourceVersionInfo(DosnetPath, &SourceVersion, &SourceBuildNum)) {
        *Reason = COMPLIANCEERR_UNKNOWNSOURCE;
        return(FALSE);
    }

    switch (SourceSku) {
        case COMPLIANCE_SKU_NTW32U:
        //case COMPLIANCE_SKU_NTWU:
        //case COMPLIANCE_SKU_NTSEU:
        case COMPLIANCE_SKU_NTSU:
        case COMPLIANCE_SKU_NTSEU:
        case COMPLIANCE_SKU_NTWPU:
        case COMPLIANCE_SKU_NTSBU:
        case COMPLIANCE_SKU_NTSBSU:
            *UpgradeOnly = TRUE;
            break;
        default:
            *UpgradeOnly = FALSE;
    }

    *SrcSku = SourceSku;

    if( ISNT() && TargetData.MinimumVersion == 400 && TargetData.InstallServicePack < 500) {
        *Reason = COMPLIANCEERR_SERVICEPACK5;
        *NoUpgradeAllowed = TRUE;
        return(FALSE);
    }

    return CheckCompliance(SourceSku, SourceSkuVariation, SourceVersion,
                            SourceBuildNum, &TargetData, Reason, NoUpgradeAllowed);
}

BOOL 
IsWinPEMode(
    VOID
    )
/*++

Routine Description:

    Finds out if we are running under WinPE environment.

Arguments:

    None

Return value:

    TRUE or FALSE

--*/
{
    static BOOL Initialized = FALSE;
    static BOOL WinPEMode = FALSE;


    if (!Initialized) {
        TCHAR   *MiniNTKeyName = TEXT("SYSTEM\\CurrentControlSet\\Control\\MiniNT");
        HKEY    MiniNTKey = NULL;
        LONG    RegResult;
        
            
        RegResult = RegOpenKey(HKEY_LOCAL_MACHINE,
                                MiniNTKeyName,
                                &MiniNTKey);

        if (RegResult == ERROR_SUCCESS) {
            WinPEMode = TRUE;
            RegCloseKey(MiniNTKey);
        }

        Initialized = TRUE;
    }                

    return WinPEMode;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\compfile.cpp ===
#pragma warning( disable:4786 )


#include <compfile.h>
//
// ComplianceFile methods
//
void ComplianceFile::readLines() {
  ifstream   inputFile(m_szFileName.c_str());

  if (!inputFile)
    throw InvalidFileName(m_szFileName);

  char    szTemp[256];
  int     counter = 0;

  while (!inputFile.eof()) {
    inputFile.getline(szTemp, sizeof(szTemp));

    if (szTemp[0] && szTemp[0] != ';')
      m_lines.push_back(szTemp);
  }
}

bool ComplianceFile::isSectionName(const string& szLine) const{
  if (szLine.length() > 2)
    return (szLine[0] == '[' && szLine[szLine.length() - 1] == ']');
  else
    return false;
}

void ComplianceFile::createSections() {
  vector<string>::const_iterator  iter = m_lines.begin();
  vector<string>  sectionLines;
  string          sectionName;

  while (iter != m_lines.end()) {
    if ((*iter)[0] == '[') {
      if (!isSectionName(*iter))
        throw Section::InvalidSectionFormat(*iter);

      if (iter != m_lines.begin()) {
        Section *pSec = sectionFactory().create(sectionName, sectionLines, *this);
        m_sections.push_back(pSec);

        if (sectionName == "[type#values]")
          m_typesSection = dynamic_cast<ValueSection *>(pSec);
        else if (sectionName == "[var#values]")
          m_varsSection = dynamic_cast<ValueSection *>(pSec);
        else if (sectionName == "[suite#values]")
          m_suitesSection = dynamic_cast<ValueSection *>(pSec);
        else if (sectionName == "[oldsource#values]")
          m_sourcesSection = dynamic_cast<ValueSection *>(pSec);       
        else if (sectionName == "[error#values]")
        	m_errorsSection = dynamic_cast<ValueSection *>(pSec);
      }
      
      sectionLines.clear();
      sectionName = (*iter);
    } else {
      sectionLines.push_back(*iter);
    }

    iter++;
  }

  if ((sectionLines.size() > 0) && isSectionName(sectionName))
    m_sections.push_back(sectionFactory().create(sectionName, sectionLines, *this));

  //
  // copy all the test sections here
  //
  vector<Section*>::const_iterator sec = m_sections.begin();

  while (sec != m_sections.end()) {
    if ((*sec)->name().find("[test#") != (*sec)->name().npos) 
      m_upgSections.push_back(dynamic_cast<TestSection*>(*sec));

    sec++;
  }
}

void ComplianceFile::executeTestCases(ostream& os) {
	vector<TestSection*>::iterator	iter = m_upgSections.begin();

	while (iter != m_upgSections.end()) {
		(*iter)->executeTestCases(os);
		iter++;
	}
}

vector<Section*>::iterator
ComplianceFile::findSection(vector<Section*> &sections, const string& szName){
  vector<Section*>::iterator iter = sections.begin();

  while (iter != sections.end()) {
    if ((*iter)->name() == szName)
      return iter;

    iter++;
  }

  return iter;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\media.h ===
#ifndef __MEDIA_H_
#define __MEDIA_H_

#define MAX_SOURCE_COUNT    8

extern char *NativeSourcePathsA;
extern WCHAR DosnetPath[MAX_PATH];
extern DWORD SourceSku;
extern DWORD SourceSkuVariation;
extern DWORD SourceVersion;
extern DWORD SourceBuildNum;

extern bool bVerbose;
extern bool bUITest;
extern bool bDebug;
BOOL UITest(
    IN DWORD SourceSku,
    IN DWORD SourceSkuVariation,
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PCOMPLIANCE_DATA pcd,
    OUT PUINT Reason,
    OUT PBOOL NoUpgradeAllowed
    );

void ReadMediaData(void);
void MediaDataCleanUp(void);
extern "C" {
extern WCHAR NativeSourcePaths[MAX_SOURCE_COUNT][MAX_PATH];
}

#endif  // for __MEDIA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\comptest.cpp ===
// comptest.cpp : Defines the entry point for the console application.
//
#pragma warning( disable:4786 )

#include <iostream>
#include <compfile.h>
#include "media.h"

using namespace std;

extern "C" {
    WCHAR NativeSourcePaths[MAX_SOURCE_COUNT][MAX_PATH];
}

char *NativeSourcePathsA = NULL;

/*extern "C" {
    WCHAR  *NativeSourcePaths[] = {0};
}*/

//
// main() entry point
//
bool bUITest = FALSE;
bool bVerbose = FALSE;
bool bDebug = FALSE;

int
__cdecl
main(
    int argc, 
    char * argv[]
    )
{
    bool bOutputFile = FALSE;
    char *pCompFileName = NULL;
    ComplianceFile *pCompFile;
    ofstream *pOutFile;

    if (argc > 1) {
        try {
            int count = 1;
            while ( count < argc) {
                if( argv[count] && (sizeof(argv[count]) > 3) && (*argv[count] == '-')) {
                    switch ( *(argv[count]+1)) {
                    case 's':
                    case 'S':
                        NativeSourcePathsA = argv[count]+3;
                        MultiByteToWideChar( CP_ACP, 0, NativeSourcePathsA, -1, NativeSourcePaths[0], 
                                             sizeof(NativeSourcePaths[0])/sizeof(NativeSourcePaths[0][0]));
                        wprintf( L"NativeSourcePaths %s\n",NativeSourcePaths[0]);
                        if ( NativeSourcePaths[0][0]) {
                            ReadMediaData();
                        }
                        break;
                    case 'i':
                    case 'I':
                        pCompFileName = argv[count]+3;
                        break;
                    case 'o':
                    case 'O':
                        cerr << "outFile " << argv[count]+3 <<endl;
                        pOutFile = new ofstream(argv[count]+3);

                        if (!(pOutFile)->good()) {
                            throw ComplianceFile::InvalidFileName(argv[count]+3);
                        }
                        bOutputFile = TRUE;
                        break;
                    case 'u':
                    case 'U':
                        bUITest = TRUE;
                        break;
                    case 'd':
                    case 'D':
                        bDebug = TRUE;
                        break;
                    case 'v':
                    case 'V':
                        bVerbose = TRUE;
                        break;
                    default:
                        break;
                    }
                }
                count++;
            }
            if ( !pCompFileName) {
                cerr << "-i:inputfile must be specified" << endl;
            } else {
                pCompFile = new ComplianceFile(pCompFileName);

                if ( bOutputFile) {
                    (pCompFile)->executeTestCases(*pOutFile);            
                } else {
                    (pCompFile)->executeTestCases(cerr);
                }
                MediaDataCleanUp();
            }
        } catch (ComplianceFile::InvalidFileFormat iff) {
            cerr << iff;
        } catch (ComplianceFile::InvalidFileName ifn) {
            cerr << ifn;
        } catch (ComplianceFile::MissingSection ms) {
            cerr << ms;
        } catch (Section::InvalidSectionFormat isf) {
            cerr << isf;
        } catch (Section::InvalidSectionName isn) {
            cerr << isn;
        } catch (ValueSection::ValueNotFound vnf) {
            cerr << vnf;
        } catch (TestCase::InvalidFormat itf) {
            cerr << itf;
        } catch (...) {
            cerr << "Unknown Exception caught... :(" << endl;        
        }
    } else {
        cerr << "illegal usage :(" << endl;
    }

    return 0;
}

/*

namespace Compliance {

//
// static data initialization
//
const string UpgradeTestCase::m_szDelimiters = ":#";

//
// utility function to tokenize a given line based on the delimiters
// specified
//
template< class T >
unsigned Tokenize(const T &szInput, const T & szDelimiters, vector<T>& tokens) {
  unsigned uDelimiterCount = 0;

    tokens.clear();

    if(!szInput.empty()){
        if(!szDelimiters.empty()){
            T::const_iterator	inputIter = szInput.begin();
            T::const_iterator	copyIter = szInput.begin();

            while(inputIter != szInput.end()){			
                if(szDelimiters.find(*inputIter) != string::npos){
          if (copyIter < inputIter) {
                        tokens.push_back(szInput.substr(copyIter - szInput.begin(), 
                                  inputIter - copyIter));
          }

          uDelimiterCount++;
          inputIter++;
          copyIter = inputIter;
          continue;
                }

              inputIter++;
            }

      if(copyIter != inputIter){
                tokens.push_back(szInput.substr(copyIter - szInput.begin(), 
                              inputIter - szInput.begin()));
      }
        }
        else
            tokens.push_back(szInput);
    }

  return uDelimiterCount;
}

//
// debug output for section
//
ostream& operator<<(ostream &os, const Section &section){
    os << "Section Name: " << section.name() << endl;
    os << "Number of child sections : " << section.childSections().size() << endl;
  os << "Section content : " << endl;

  
  vector<string>::const_iterator liter = section.lines().begin();

  while (liter != section.lines().end()) 
    os << *liter++ << endl;

    // dump all the child sections
    vector<Section>::const_iterator	iter = section.childSections().begin();

    while (iter != section.childSections().end()) {
        os << (const Section &)(*iter) << endl;
    iter++;
    }

    return os;
}

//
// debug output for compliance file
//
ostream& operator<<(ostream& os, const ComplianceFile &cf){
    os << "------------------------------------------------------------" << endl;
    os << "Compliance File State - Dump" << endl;
    os << "Name : " << cf.name() << endl;
    os << "Num Lines : " << cf.lines().size() << endl;
    os << "Section Dump : " << endl;

  if (cf.topLevelSection())
      os << *(cf.topLevelSection()) << endl;

    os << "------------------------------------------------------------" << endl;	

  return os;
}

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#define IDS_APPTITLE                    1
#define IDS_LARGEFONTSIZE               2
#define IDS_LARGEFONTNAME               3
#define IDS_MULTIPLE                    4
#define IDS_EXAMINE_SOURCE              5
#define IDS_LOADINGINF                  6
#define IDS_BUILDING_COPY_LIST          7
#define IDS_CHECKING_SPACE              8
#define IDS_FIND_NT_FILES               9
#define IDS_INSPECTING                  10
#define IDS_REMOVING_OLD_TEMPFILES      11
#define IDS_MICROSOFT_WINDOWS           12
#define IDS_REBOOT_MESSAGE              13
#define IDS_APPTITLE_ASRV               14
#define IDS_APPTITLE_DAT                15
#define IDS_APPTITLE_SRV                16
#define IDS_APPTITLE_WKS                17
#define IDS_BOOTFLOP_WKS                18
#define IDS_BOOTFLOP_SRV                19
#define IDS_FLOPPY_N_WKS                20
#define IDS_FLOPPY_N_SRV                21
#define IDS_SETTING_NVRAM               22
#define IDS_BOOTMSG_FAT_NTLDR_MISSING   23
#define IDS_BOOTMSG_FAT_DISKERROR       24
#define IDS_BOOTMSG_FAT_PRESSKEY        25
#define IDS_COMMENT                     26
#define IDS_VISIBLE_NARRATOR_CONTROL    27
#define IDS_RECOVERY_CONSOLE            28
#define IDS_APPTITLE_BLADE              29
#define IDS_CANCEL_SETUP                30
#define IDS_WINPE_INSTALLATION          31
#define IDS_APPTITLE_SBS                32
#define IDB_WELCOME                     101
#define IDD_UPGRADE                     102
#define IDB_ARROW                       102
#define IDD_DONE0                       103
#define IDB_CHECK                       103
#define IDD_OPTIONS                     104
#define IDB_WIZARD1                     105
#define IDB_OEM                         105
#define IDD_ADVANCED                    106
#define IDB_CDKEY                       106
#define IDD_WORKING1                    107
#define IDB_HEADER                      108
#define IDA_COMP_MAGNIFY                109
#define IDD_COPYING                     110
#define IDA_FILECOPY                    111
#define IDD_DONE                        112
#define IDD_COPYERROR                   113
#define IDD_CLEANING                    114
#define IDD_NOTDONE                     115
#define IDB_WATERMARK                   116
#define IDB_TEST                        117
#define IDD_FLOPPY                      118
#define IDB_WATERMARK16                 119
#define IDB_WATERMARK256                120
#define IDI_ACCESS                      121
#define IDI_GLOBE                       122
#define IDI_SETUP                       123
#define IDD_ADVANCED2                   124
#define IDD_CLEANING2                   125
#define IDD_COPYING2                    126
#define IDD_DONE2                       127
#define IDD_FLOPPY2                     128
#define IDD_NOTDONE2                    129
#define IDD_OPTIONS2                    130
#define IDD_WELCOME2                    131
#define IDD_WORKING12                   132
#define IDD_LANGUAGE                    133
#define IDD_WELCOME                     134
#define IDD_ACCESSIBILITY               135
#define IDD_COMPATIBILITY               136
#define IDD_COMPATIBILITY_TEXT          137
#define IDI_WATCH_OUT                   138
#define IDI_ERROR_ICON                  139
#define IDI_FLAGS                       140
#define IDR_SHUTDOWN                    140
#define IDI_ADVANCED                    141
#define IDR_NOSHUTDOWN                  141
#define IDD_EULA                        143
#define IDD_PID_CD                      144
#define IDD_PID_OEM                     145
#define IDD_NTFS_CONVERT                146
#define IDI_HDISK                       147
#define IDD_ADVANCED3                   148
#define IDI_INSTALL                     148
#define IDD_DISKSPACE                   149
#define IDD_SRVCOMP                     150
#define IDB_HEARDER2                    151
#define IDA_COMPGLOB                    152
#define IDD_DYNAMICSETUP                153
#define IDD_DYNAMICSETUP2               154
#define IDD_DYNAMICSETUP3               155
#define IDD_DYNAMICSETUP_MANUAL         156
#define IDD_EMPTY                       157
#define IDD_PID_SELECT                  158
#define IDI_NOTE                        159
#define IDT_TITLE                       1000
#define IDC_ANIMATE                     1000
#define IDC_CHECK1                      1001
#define IDC_USEFLOPPIES                 1001
#define IDC_FAREAST_LANG                1001
#define IDC_EDIT1                       1002
#define IDC_INSTALL_DIR                 1002
#define IDC_DISKDIAG                    1002
#define IDC_SOURCE                      1003
#define IDB_ADVANCED                    1004
#define IDC_CONVERT                     1004
#define IDC_HEADLESS_PORT               1004
#define IDC_NOUPGRADE                   1005
#define IDC_UPGRADE                     1005
#define IDB_BROWSE                      1005
#define IDB_ACCESSIBILITY               1006
#define IDC_MAKELOCALSOURCEFROMCD       1007
#define IDC_SYSPARTDRIVE                1008
#define IDC_KEYBOARD                    1008
#define IDT_SYSPARTTEXT                 1009
#define IDC_VOICE                       1009
#define IDT_WORKING                     1010
#define IDC_READER                      1010
#define IDC_CHOOSE_INSTALLPART          1010
#define IDC_SOURCE2                     1011
#define IDB_BROWSE2                     1012
#define IDT_EDIT1                       1012
#define IDT_EULA_LIC_TEXT               1012
#define IDC_BOOT16                      1012
#define IDC_ENABLE_HEADLESS             1012
#define IDC_PROGRESS                    1013
#define IDT_BOOT16TEXT                  1013
#define IDT_HEADLESS_PORT               1013
#define IDT_SOURCE1                     1014
#define IDT_SOURCE2                     1015
#define IDT_SOURCE3                     1016
#define IDT_SOURCE4                     1017
#define IDT_SOURCE5                     1018
#define IDT_SOURCE6                     1019
#define IDT_SOURCE7                     1020
#define IDT_SOURCE8                     1021
#define IDT_SOURCE9                     1022
#define IDT_SIZE2                       1022
#define IDS_DETAILS                     1023
#define IDT_ERROR_TEXT                  1024
#define IDT_ELAPSED_TIME2               1024
#define IDC_HEADER_BOTTOM               1025
#define IDC_MAGNIFIER                   1027
#define IDT_SUPERTITLE                  1028
#define IDT_SUBTITLE                    1029
#define IDC_BUTTON1                     1030
#define IDB_LANGUAGE                    1030
#define IDT_EDIT_PID1                   1030
#define IDT_DETAIL_TEXT                 1030
#define IDC_LIST1                       1031
#define IDC_LIST                        1031
#define IDT_EDIT_PID2                   1031
#define IDC_ROOT_LIST                   1032
#define IDT_EDIT_PID3                   1032
#define IDC_DETAILS                     1033
#define IDT_EDIT_PID4                   1033
#define IDC_TEXT                        1034
#define IDT_EDIT_PID5                   1034
#define IDC_DIALOG_ICON                 1035
#define IDC_NOSHUTDOWN                  1035
#define IDC_RADIO1                      1035
#define IDC_BOOT16_1                    1035
#define IDC_INTRO_TEXT                  1036
#define IDC_BOOT16_2                    1036
#define IDC_HAVE_DISK                   1037
#define IDC_CHECK2                      1037
#define IDC_BOOT16_3                    1037
#define IDS_SERVICE_STOP                1038
#define IDC_RADIO2                      1038
#define IDS_COMPAT_ERR                  1038
#define IDS_SERVICE_DISABLE             1039
#define IDC_COMBO1                      1039
#define IDS_COMPAT_WRN                  1039
#define IDC_ACCESS_ICON                 1040
#define IDS_NO_REBOOT                   1040
#define IDC_SAVE_AS                     1041
#define IDC_PROGRESS1                   1041
#define IDS_COMPAT_ERR_WRN              1041
#define IDS_RISCBootString              1042
#define IDC_SCROLLBAR1                  1043
#define IDS_COMPAT_NOPROBLEMS           1043
#define IDT_DISKMSG0                    1044
#define IDS_COMPAT_PENDING_REBOOT       1044
#define IDT_DISKMSG1                    1045
#define IDS_COMPAT_REPORTHEADER         1045
#define IDT_DISKMSG2                    1046
#define IDNORESTART                     1047
#define IDC_READER_TEXT                 1048
#define IDS_SRV_APP_DIRECTORY           1049
#define IDS_PRO_APP_DIRECTORY           1050
#define IDC_DIRECTORY                   1051
#define IDS_FILE_MASK_TYPES             1051
#define IDS_DEFAULT_COMPATIBILITY_REPORT_NAME 1052
#define IDT_DYNSETUP_DIALING            1052
#define IDT_INSTALLTYPE                 1052
#define IDT_DYNSETUP_TIME               1053
#define IDS_APPTITLE_CHECKUPGRADE       1053
#define IDC_IF_EXPRESS                  1053
#define IDC_INSTALLCOMBO                1053
#define IDS_COMPAT_CHECKUPGRADE         1054
#define IDR_DYNSETUP_RETRY              1054
#define IDT_DYNSETUP_DOWNLOADING        1054
#define IDR_DYNSETUP_MANUAL             1055
#define IDS_SIZE_GBYTES                 1055
#define IDC_EXPRESS                     1055
#define IDT_DYNSETUP_PROCESSING         1055
#define IDS_SIZE_MBYTES                 1056
#define IDR_DYNSETUP_SKIP               1056
#define IDC_ADVANCED                    1056
#define IDS_SIZE_KBYTES                 1057
#define IDC_IF_ADVANCED                 1057
#define IDC_NOTE_TEXT_CLEAN             1057
#define IDS_SIZE_BYTES                  1058
#define IDC_COPY_BMP                    1058
#define IDC_NOTE_CLEAN                  1058
#define IDS_COMPAT_DIVIDER              1059
#define IDC_COPY_BMP2                   1059
#define IDS_COMPAT_STRT_MENU            1060
#define IDC_COPY_BMP3                   1060
#define IDS_BB_COPYING                  1061
#define IDS_TIMEESTIMATE_UNKNOWN        1062
#define IDS_ESC_TOCANCEL                1063
#define IDS_TIMEESTIMATE_MINUTES        1064
#define IDS_TIMEESTIMATE_LESSTHENONEMINUTE 1065
#define IDS_ESC_TOCANCEL_DOWNLOAD       1066
#define IDS_RESTART_SETUP               1067
#define IDB_HEADER2                     1090
#define IDT_LABEL1                      2000
#define IDT_LABEL2                      2001
#define IDT_LABEL3                      2002
#define IDT_LABEL4                      2003
#define IDT_LABEL5                      2004
#define IDT_LABEL6                      2005
#define IDT_LABEL7                      2006
#define IDT_LABEL8                      2007
#define IDT_LABEL9                      2008
#define IDT_SIZE                        2008
#define IDC_UPGRADE_OR_INSTALL          2009
#define IDT_ELAPSED_TIME                2009
#define IDC_IF_UPGRADE                  2010
#define IDC_IF_NEW_COPY                 2011
#define IDC_WHAT_TO_DO                  2012
#define IDS_CERTSRV_UPGRADE_WARNING     2013
#define IDS_INSTALLTYPE_EXPRESS         2014
#define IDS_INSTALLTYPE_CUSTOM          2015
#define IDS_INSTALL_EXPRESS             2016
#define IDS_INSTALL_CUSTOM              2017
#define IDS_PROCESSOR_UPGRADE_WARNING   2018
#define IDS_BB_REBOOT_TXT               2019
#define IDB_SYSPARSE                    2020
#define IDD_SYSPARSE                    2021
#define IDC_BITMAP                      2022
#define IDD_RESTART                     2022
#define IDD_DYNAMICSETUP4               2023
#define IDD_DYNAMICSETUP5               2024
#define IDS_SHUTDOWN_REMOTE             2711
#define IDS_SHUTDOWN_REMOTE_OTHERUSERS  2712
#define IDS_SHUTDOWN_OTHERUSERS         2713
#define IDS_RESTART_OTHERUSERS          2714
#define IDC_NOTE_TEXT_UPG               2715
#define IDC_NOTE_UPG                    2716
#define IDS_ESC_TOCANCEL_REBOOT         2717
#define IDS_DRWATSON_LCID               2718
#define IDS_DRWATSON_ERRORTEXT          2719
#define IDD_REPORT_HELP                 3000
#define IDI_CHECKMARK                   3001
#define IDC_CATEGORY                    3002
#define IDC_TEXT1                       3003
#define IDC_CRITICAL_ISSUES             3004
#define IDC_ALL_ISSUES                  3005
#define IDC_NO_REPORT                   3006
#define IDC_NAMES                       3007
#define IDC_TEXT2                       3007
#define IDC_TEXT3                       3008
#define IDC_STATIC                      -1
#define ID_RETRY_MESSAGE                65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        160
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1059
#define _APS_NEXT_SYMED_VALUE           142
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\compfile.h ===
#ifndef __COMPFILE_H_
#define __COMPFILE_H_

#include <vector>
#include <string>
#include <fstream>
#include <section.h>

//
// This class abstracts the compliance file
//
class ComplianceFile {
public:
	ComplianceFile(const string& szFileName){
    m_szFileName = szFileName;
    bindSectionFactory();
    readLines();
    createSections();
	}
 
  virtual ~ComplianceFile(){
    vector<Section*>::iterator  iter = m_sections.begin();

    while (iter != m_sections.end())
      delete *iter++;

    delete m_sectionFactory;
  }

  void executeTestCases(ostream& os);
  
  //
  // accessors
  //
  const string& name() const{ return m_szFileName; }
  const vector<string>& lines() const{ return m_lines; }
  const vector<Section*>& sections() const{ return m_sections; }
  const ValueSection& typesSection() const { return *m_typesSection; }
  const ValueSection& varsSection() const { return *m_varsSection; }
  const ValueSection& suitesSection() const { return *m_suitesSection; }
  const ValueSection& sourcesSection() const { return *m_sourcesSection; }
  const ValueSection& errorsSection() const { return *m_errorsSection; }
  const SectionFactory& sectionFactory() const { return *m_sectionFactory; }

  //
  // exception classes
  //
  struct InvalidFileName {
    InvalidFileName(const string& name) : m_name(name) {}
    
    friend ostream& operator<<(ostream& os, const InvalidFileName& rhs) {
      os << "Exception : Invalid file name : " << rhs.m_name;
      return os;
    }

    string  m_name;
  };
  
  struct InvalidFileFormat {
    InvalidFileFormat(const string& name) : m_name(name) {}
    
    friend ostream& operator<<(ostream& os, const struct InvalidFileFormat &rhs) {
      os << "Exception : Invalid file format : " << rhs.m_name;
      return os;
    }

    string m_name;
  };

  struct MissingSection {
    MissingSection(const string& name) : m_name(name){}

    friend ostream& operator<<(ostream& os, const struct MissingSection &rhs) {
      os << "Exception : The following section is missing : " << rhs.m_name;
      return os;
    }
  
    string m_name;
  };

  //
  // overloaded operators
  //
  friend ostream& operator<<(ostream& os, const ComplianceFile &cf);
  
  /*
  ComplianceFile& operator=(const ComplianceFile& rhs) {
    m_lines = rhs.m_lines;
    m_szFileName = rhs.m_szFileName;
    
    delete m_typesSection;
    m_typesSection = sectionFactory().create(rhs.typesSection());

    delete m_varsSection;
    m_varsSection = sectionFactory().create(rhs.varsSection());

    delete m_suitesSection;
    m_suitesSection = sectionFactory().create(rhs.suitesSection());
    
    m_upgSections = rhs.TestSections();
  }
  */
  void  executeTestCases();

protected:
  virtual void bindSectionFactory() {
    m_sectionFactory = new OldFormatSectionFactory();
  }

  //
  // data members
  //
  vector<string>	    m_lines;
  string                m_szFileName;
  ValueSection          *m_typesSection;
  ValueSection          *m_varsSection;
  ValueSection          *m_suitesSection;
  ValueSection          *m_sourcesSection;
  ValueSection          *m_errorsSection;
  SectionFactory        *m_sectionFactory;  
  vector<TestSection*>  m_upgSections;
  vector<Section*>      m_sections;

private:
  void  readLines();
  bool  isSectionName(const string& szLine) const;
  void  createSections();

  static vector<Section*>::iterator 
        findSection(vector<Section*> &sections, const string& szName);
};

#endif  // for __COMPFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\msg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_FIRST
//
// MessageText:
//
//  MSG_FIRST
//
#define MSG_FIRST                        0x00002710L

//
// MessageId: MSG_OUT_OF_MEMORY
//
// MessageText:
//
//  Out of Memory.%0
//
#define MSG_OUT_OF_MEMORY                0x00002711L

//
// MessageId: MSG_NOT_ADMIN
//
// MessageText:
//
//  You must be an administrator to run this application.%0
//
#define MSG_NOT_ADMIN                    0x00002712L

//
// MessageId: MSG_ALREADY_RUNNING
//
// MessageText:
//
//  Another copy of this application is already running.%0
//
#define MSG_ALREADY_RUNNING              0x00002713L

//
// MessageId: MSG_CANT_OPEN_HELP_FILE
//
// MessageText:
//
//  Setup could not locate help file %1. Help is not available.%0
//
#define MSG_CANT_OPEN_HELP_FILE          0x00002714L

//
// MessageId: MSG_SURE_EXIT
//
// MessageText:
//
//  This will exit Setup. You will need to run it again later to install or upgrade to Windows XP. Are you sure you want to cancel?%0
//
#define MSG_SURE_EXIT                    0x00002715L

//
// MessageId: MSG_INVALID_SOURCE
//
// MessageText:
//
//  Setup could not locate Windows XP files at the specified location (%1).
//  
//  Click OK. Setup will allow you to specify a different location by clicking on Advanced Options.%0
//
#define MSG_INVALID_SOURCE               0x00002716L

//
// MessageId: MSG_INVALID_SOURCES
//
// MessageText:
//
//  None of the specified source locations are accessible and valid.%0
//
#define MSG_INVALID_SOURCES              0x00002717L

//
// MessageId: MSG_CANT_LOAD_INF_GENERIC
//
// MessageText:
//
//  Setup was unable to load INF file %1.
//  
//  Contact your system administrator.%0
//
#define MSG_CANT_LOAD_INF_GENERIC        0x00002718L

//
// MessageId: MSG_CANT_LOAD_INF_IO
//
// MessageText:
//
//  Setup was unable to read INF file %1.
//  
//  Try again later. If this error occurs again, contact your system administrator.%0
//
#define MSG_CANT_LOAD_INF_IO             0x00002719L

//
// MessageId: MSG_CANT_LOAD_INF_SYNTAXERR
//
// MessageText:
//
//  INF file %1 contains a syntax error.
//  
//  Contact your system administrator.%0
//
#define MSG_CANT_LOAD_INF_SYNTAXERR      0x0000271AL

//
// MessageId: MSG_ERROR_WITH_SYSTEM_ERROR
//
// MessageText:
//
//  %1
//  
//  %2%0
//
#define MSG_ERROR_WITH_SYSTEM_ERROR      0x0000271BL

//
// MessageId: MSG_CANT_BUILD_SOURCE_LIST
//
// MessageText:
//
//  Setup was unable to build the list of files to be copied.%0
//
#define MSG_CANT_BUILD_SOURCE_LIST       0x0000271CL

//
// MessageId: MSG_NO_VALID_LOCAL_SOURCE
//
// MessageText:
//
//  Setup was unable to locate a locally attached hard drive suitable for holding temporary Setup files.
//  
//  A drive with approximately %1!u! MB to %2!u! MB of free space is required (actual requirements vary depending on drive size and formatting).
//  
//  You may avoid this requirement by installing/upgrading from a Compact Disk (CD).%0
//
#define MSG_NO_VALID_LOCAL_SOURCE        0x0000271DL

//
// MessageId: MSG_CANT_START_COPYING
//
// MessageText:
//
//  Setup was unable to start copying files.%0
//
#define MSG_CANT_START_COPYING           0x0000271EL

//
// MessageId: MSG_UNKNOWN_SYSTEM_ERROR
//
// MessageText:
//
//  An unknown system error (code 0x%1!x!) has occurred.%0
//
#define MSG_UNKNOWN_SYSTEM_ERROR         0x0000271FL

//
// MessageId: MSG_DOSNET_INF_DESC
//
// MessageText:
//
//  Windows XP file list (%1)%0
//
#define MSG_DOSNET_INF_DESC              0x00002720L

//
// MessageId: MSG_REBOOT_FAILED
//
// MessageText:
//
//  Setup was unable to restart your computer. Please close all applications and shut down your computer to continue installing Windows XP.%0
//
#define MSG_REBOOT_FAILED                0x00002721L

//
// MessageId: MSG_DIR_CREATE_FAILED
//
// MessageText:
//
//  Setup was unable to create a critical folder (%1).%0
//
#define MSG_DIR_CREATE_FAILED            0x00002722L

//
// MessageId: MSG_BOOT_FILE_ERROR
//
// MessageText:
//
//  Setup was unable to create, locate, or modify a critical file (%1) needed to start Windows XP.%0
//
#define MSG_BOOT_FILE_ERROR              0x00002723L

//
// MessageId: MSG_UNATTEND_FILE_INVALID
//
// MessageText:
//
//  The specified Setup script file (%1) is inaccessible or invalid. Contact your system administrator.%0
//
#define MSG_UNATTEND_FILE_INVALID        0x00002724L

//
// MessageId: MSG_UDF_FILE_INVALID
//
// MessageText:
//
//  Setup was unable to access the the specified Uniqueness Database File (%1). Contact your system administrator.%0
//
#define MSG_UDF_FILE_INVALID             0x00002725L

//
// MessageId: MSG_COPY_ERROR_TEMPLATE
//
// MessageText:
//
//  An error occurred copying file %1 to %2.
//  
//  %3
//  
//  %4%0
//
#define MSG_COPY_ERROR_TEMPLATE          0x00002726L

//
// MessageId: MSG_COPY_ERROR_NOSRC
//
// MessageText:
//
//  The file is missing. Contact your system administrator.%0
//
#define MSG_COPY_ERROR_NOSRC             0x00002727L

//
// MessageId: MSG_COPY_ERROR_DISKFULL
//
// MessageText:
//
//  Your disk is full. Another application may be using a large amount of disk space while Setup is running.%0
//
#define MSG_COPY_ERROR_DISKFULL          0x00002728L

//
// MessageId: MSG_COPY_ERROR_OPTIONS
//
// MessageText:
//
//  You may choose to retry the copy, skip this file, or exit Setup.
//  
//  * If you select Retry, Setup will try to copy the file again.
//  
//  * If you select Skip File, the file will not be copied. This option is intended for advanced users who are familiar with the various Windows XP system files.
//  
//  * If you select Exit Setup, you will need to run Setup again later to install Windows XP.%0
//
#define MSG_COPY_ERROR_OPTIONS           0x00002729L

//
// MessageId: MSG_REALLY_SKIP
//
// MessageText:
//
//  This option is intended for advanced users who understand the ramifications of missing system files.
//  
//  If you skip this file, you may encounter problems later during the installation process.
//  
//  Are you sure you want to skip this file?%0
//
#define MSG_REALLY_SKIP                  0x0000272AL

//
// MessageId: MSG_SYSTEM_ON_HPFS
//
// MessageText:
//
//  Windows XP is installed on a drive formatted with the OS/2 File System (HPFS). Windows XP does not support this file system.
//  
//  You must convert this drive to the Windows NT File System (NTFS) before upgrading.%0
//
#define MSG_SYSTEM_ON_HPFS               0x0000272BL

//
// MessageId: MSG_HPFS_DRIVES_EXIST
//
// MessageText:
//
//  The OS/2 File System (HPFS) is in use on your computer. Windows XP does not support this file system.
//  
//  If you will need to access the data stored on these drives from Windows XP, you must convert them to the Windows NT File System (NTFS) before continuing.
//  
//  Would you like to continue installing Windows XP?%0
//
#define MSG_HPFS_DRIVES_EXIST            0x0000272CL

//
// MessageId: MSG_CANT_SAVE_FT_INFO
//
// MessageText:
//
//  Setup was unable to retrieve or save information about your disk drives.%0
//
#define MSG_CANT_SAVE_FT_INFO            0x0000272DL

//
// MessageId: MSG_USER_LOCAL_SOURCE_TOO_SMALL
//
// MessageText:
//
//  The drive you specified (%1!c!:) is too small to hold the required temporary Setup files.
//  
//  A drive with approximately %2!u! MB of free space is required.
//  
//  You may avoid this requirement by installing/upgrading from a Compact Disk.%0
//
#define MSG_USER_LOCAL_SOURCE_TOO_SMALL  0x0000272EL

//
// MessageId: MSG_CANT_UPGRADE_SERVER_TO_WORKSTATION
//
// MessageText:
//
//  Setup is unable to upgrade this Server product to Windows XP Professional.%0
//
#define MSG_CANT_UPGRADE_SERVER_TO_WORKSTATION 0x0000272FL

//
// MessageId: MSG_NOTIFY_EVALUATION_INSTALLATION
//
// MessageText:
//
//  This BETA version of the product is intended for evaluation purposes only.%0
//
#define MSG_NOTIFY_EVALUATION_INSTALLATION 0x00002730L

//
// MessageId: MSG_CANT_LOAD_SETUPAPI
//
// MessageText:
//
//  Setup was unable to locate or load %1, or the file is corrupt. Contact your system administrator.%0
//
#define MSG_CANT_LOAD_SETUPAPI           0x00002731L

//
// MessageId: MSG_SYSTEM_PARTITION_TOO_SMALL
//
// MessageText:
//
//  There is not enough space on your system partition (Drive %1!c!:).
//  
//  Approximately %2!u! MB of free space is required (actual requirements vary depending on drive size and formatting).%0
//
#define MSG_SYSTEM_PARTITION_TOO_SMALL   0x00002732L

//
// MessageId: MSG_INCORRECT_PLATFORM
//
// MessageText:
//
//  Setup error: The winnt32.exe was unable to run because the machine type is not correct.
//  Please use path\filename to setup Windows XP for your machine type.%0
//
#define MSG_INCORRECT_PLATFORM           0x00002733L

//
// MessageId: MSG_CANT_MIGRATE_UNSUP_DRIVERS
//
// MessageText:
//
//  Your computer has a mass storage device that is not supported on Windows XP. Setup was unable to migrate the driver for this device.
//  
//  You will need to provide the Manufacturer-supplied support disk for this device during the next phase of setup.%0
//
#define MSG_CANT_MIGRATE_UNSUP_DRIVERS   0x00002734L

//
// MessageId: MSG_DSCHECK_REQD_FILE_MISSING
//
// MessageText:
//
//  The required file %1 is not found on the source %2 during schema version check. Setup cannot continue.%0
//
#define MSG_DSCHECK_REQD_FILE_MISSING    0x00002735L

//
// MessageId: MSG_DSCHECK_COPY_ERROR
//
// MessageText:
//
//  During the schema version check, Windows could not copy file %1 from source %2. Make sure you have at least 2 MB of free disk space and write permission to the Windows and System folders, and then try the version check again.%0
//
#define MSG_DSCHECK_COPY_ERROR           0x00002736L

//
// MessageId: MSG_DSCHECK_SCHEMA_UPGRADE_NEEDED
//
// MessageText:
//
//  The schema version on the DC is %1. The schema version in the Windows software to which you are upgrading is %2. You must update the schema before Setup can upgrade the DC.
//  
//  To update the schema, run Schupgr.exe. All necessary files (including Schupgr.exe) are in your system folder. Run Schupgr.exe only once on one DC in the enterprise. Changes will be copied to all other DCs. When the update is complete, restart Setup.%0
//
#define MSG_DSCHECK_SCHEMA_UPGRADE_NEEDED 0x00002737L

//
// MessageId: MSG_DSCHECK_SCHEMA_UPGRADE_COPY_ERROR
//
// MessageText:
//
//  The schema version on the DC is %1. The schema version in the Windows software to which you are upgrading is %2. You must update the schema before Setup can upgrade the DC. Setup cannot continue.
//  
//  An error occurred during the copying of necessary schema upgrade files to your system folder.%0
//
#define MSG_DSCHECK_SCHEMA_UPGRADE_COPY_ERROR 0x00002738L

//
// MessageId: MSG_DSCHECK_SCHEMA_CLEAN_INSTALL_NEEDED
//
// MessageText:
//
//  The schema version on the DC is %1. The schema version in the Windows software to which you are upgrading is %2. You cannot upgrade a DC that has a schema version earlier than 10 to a schema version later than or equal to 10. To upgrade to the new schema version, you must first perform a fresh install on all DCs in your enterprise.%0
//
#define MSG_DSCHECK_SCHEMA_CLEAN_INSTALL_NEEDED 0x00002739L

//
// MessageId: MSG_INSTALL_DRIVE_TOO_SMALL
//
// MessageText:
//
//  There is not enough free disk space on the drive that contains your current Windows installation for Setup to continue.
//  
//  Approximately %1!u! MB of free disk space is required on this drive for an upgrade.%0
//
#define MSG_INSTALL_DRIVE_TOO_SMALL      0x0000273AL

//
// MessageId: MSG_INSTALL_DRIVE_INVALID
//
// MessageText:
//
//  The drive that contains your current Windows installation is not suitable for holding a new installation of Windows XP.
//
#define MSG_INSTALL_DRIVE_INVALID        0x0000273BL

//
// MessageId: MSG_USER_LOCAL_SOURCE_INVALID
//
// MessageText:
//
//  The drive you specified (%1!c!:) is not suitable for holding temporary Setup files.%0
//
#define MSG_USER_LOCAL_SOURCE_INVALID    0x0000273CL

//
// MessageId: MSG_WRN_TRUNC_WINDIR
//
// MessageText:
//
//  The directory name is invalid.  Directory names must contain 8 or less valid characters.
//
#define MSG_WRN_TRUNC_WINDIR             0x0000273DL

//
// MessageId: MSG_EULA_FAILED
//
// MessageText:
//
//  
//  Setup was unable to locate or load the End User License Agreement, the file is corrupt, or you specified an invalid installation source path.  Contact your system administrator.%0
//
#define MSG_EULA_FAILED                  0x0000273EL

//
// MessageId: MSG_CD_PID_IS_INVALID
//
// MessageText:
//
//  
//  The CD Key which you entered is invalid.  Please try again.
//
#define MSG_CD_PID_IS_INVALID            0x0000273FL

//
// MessageId: MSG_UNATTEND_CD_PID_IS_INVALID
//
// MessageText:
//
//  
//  The Setup script file does not contain a valid CD key.  Contact your system administrator for a valid CD key.
//
#define MSG_UNATTEND_CD_PID_IS_INVALID   0x00002740L

//
// MessageId: MSG_OEM_PID_IS_INVALID
//
// MessageText:
//
//  
//  The Product ID which you entered is invalid. Please try again.
//
#define MSG_OEM_PID_IS_INVALID           0x00002741L

//
// MessageId: MSG_UNATTEND_OEM_PID_IS_INVALID
//
// MessageText:
//
//  
//  The Setup script file does not contain a valid Product ID. Contact your system administrator for a valid Product ID.
//
#define MSG_UNATTEND_OEM_PID_IS_INVALID  0x00002742L

//
// MessageId: MSG_SMS_SUCCEED
//
// MessageText:
//
//  Initial setup stage completed successfully. Rebooting system.%0
//
#define MSG_SMS_SUCCEED                  0x00002743L

//
// MessageId: MSG_SMS_FAIL
//
// MessageText:
//
//  Unable to complete Windows XP setup because of the following error: %1%0
//
#define MSG_SMS_FAIL                     0x00002744L

//
// MessageId: MSG_CANT_UPGRADE_FROM_BUILD_NUMBER
//
// MessageText:
//
//  This version of Windows XP cannot be upgraded. The option to upgrade will not be available.%0
//
#define MSG_CANT_UPGRADE_FROM_BUILD_NUMBER 0x00002745L

//
// MessageId: MSG_DSCHECK_SCHEMA_OLD_BUILD
//
// MessageText:
//
//  The schema version on the DC is %1. The schema version in the Windows software to which you are upgrading is %2. You can only upgrade a DC to a schema version later than or equal to the current schema version on the DC (%1). Setup cannot continue.%0
//
#define MSG_DSCHECK_SCHEMA_OLD_BUILD     0x00002746L

//
// MessageId: MSG_INVALID_PARAMETER
//
// MessageText:
//
//  Setup was invoked with an invalid command line parameter (%1).%0
//
#define MSG_INVALID_PARAMETER            0x00002747L

//
// MessageId: MSG_INCOMPATIBILITIES
//
// MessageText:
//
//  One or more services on your system are incompatible with Windows XP.%0
//
#define MSG_INCOMPATIBILITIES            0x00002748L

//
// MessageId: MSG_TS_CLIENT_FAIL
//
// MessageText:
//
//  Windows XP can not be run inside of a Terminal Services Client environment.%0
//
#define MSG_TS_CLIENT_FAIL               0x00002749L

//
// MessageId: MSG_CLUSTER_WARNING
//
// MessageText:
//
//  
//  Running Windows XP setup on a cluster node without using the winnt32.exe /tempdrive:<drive_letter> option may result in placement of temporary setup files on a clustered disk. Setup will fail after reboot. For more information on the /tempdrive option, see the unattended setup information in the Getting Started book.
//  
//  If you would like to exit Setup and restart with this command-line option, please press the CANCEL button below.  Otherwise, Setup will continue and attempt to select a drive to hold your temporary files.
//
#define MSG_CLUSTER_WARNING              0x0000274AL

//
// MessageId: MSG_INVALID_SOURCEPATH
//
// MessageText:
//
//  
//  The installation source path specified to Setup is invalid.  Contact your system administrator.%0
//
#define MSG_INVALID_SOURCEPATH           0x0000274BL

//
// MessageId: MSG_NO_UNATTENDED_UPGRADE
//
// MessageText:
//
//  This version of Windows XP cannot be upgraded.  Setup cannot continue.%0
//
#define MSG_NO_UNATTENDED_UPGRADE        0x0000274CL

//
// MessageId: MSG_NO_UPGRADE_ALLOWED
//
// MessageText:
//
//  Windows XP Setup does not support upgrading from %1 to %2.%0
//
#define MSG_NO_UPGRADE_ALLOWED           0x0000274DL

//
// MessageId: MSG_TYPE_WIN31
//
// MessageText:
//
//  Microsoft Windows 3.1%0
//
#define MSG_TYPE_WIN31                   0x0000274EL

//
// MessageId: MSG_TYPE_WIN95
//
// MessageText:
//
//  Microsoft Windows 95%0
//
#define MSG_TYPE_WIN95                   0x0000274FL

//
// MessageId: MSG_TYPE_WIN98
//
// MessageText:
//
//  Microsoft Windows 98%0
//
#define MSG_TYPE_WIN98                   0x00002750L

//
// MessageId: MSG_TYPE_NTW
//
// MessageText:
//
//  Microsoft Windows NT Workstation%0
//
#define MSG_TYPE_NTW                     0x00002751L

//
// MessageId: MSG_TYPE_NTS
//
// MessageText:
//
//  Microsoft Windows NT Server%0
//
#define MSG_TYPE_NTS                     0x00002752L

//
// MessageId: MSG_TYPE_NTSE
//
// MessageText:
//
//  Microsoft Windows NT Server, Enterprise Edition%0
//
#define MSG_TYPE_NTSE                    0x00002753L

//
// MessageId: MSG_TYPE_NTPRO
//
// MessageText:
//
//  Microsoft Windows 2000 Professional%0
//
#define MSG_TYPE_NTPRO                   0x00002754L

//
// MessageId: MSG_TYPE_NTS2
//
// MessageText:
//
//  Microsoft Windows 2000 Server%0
//
#define MSG_TYPE_NTS2                    0x00002755L

//
// MessageId: MSG_TYPE_NTAS
//
// MessageText:
//
//  Microsoft Windows 2000 Advanced Server%0
//
#define MSG_TYPE_NTAS                    0x00002756L

//
// MessageId: MSG_TYPE_NTSDTC
//
// MessageText:
//
//  Microsoft Windows 2000 Datacenter Server%0
//
#define MSG_TYPE_NTSDTC                  0x00002757L

//
// MessageId: MSG_TYPE_NTPROPRE
//
// MessageText:
//
//  Microsoft Windows 2000 Professional Prerelease%0
//
#define MSG_TYPE_NTPROPRE                0x00002758L

//
// MessageId: MSG_TYPE_NTSPRE
//
// MessageText:
//
//  Microsoft Windows Whistler Server Prerelease%0
//
#define MSG_TYPE_NTSPRE                  0x00002759L

//
// MessageId: MSG_TYPE_NTASPRE
//
// MessageText:
//
//  Microsoft Windows 2000 Advanced Server Prerelease%0
//
#define MSG_TYPE_NTASPRE                 0x0000275AL

//
// MessageId: MSG_NO_UNATTENDED_UPGRADE_SPECIFIC
//
// MessageText:
//
//  Windows XP Setup does not support upgrading from %1 to %2.
//  Setup cannot continue.%0
//
#define MSG_NO_UNATTENDED_UPGRADE_SPECIFIC 0x0000275BL

//
// MessageId: MSG_NO_UPGRADE_ALLOWED_GENERIC
//
// MessageText:
//
//  Windows XP Setup cannot upgrade the currently installed operating system. However, you can install a separate copy of Windows XP. To do this, click OK.%0
//
#define MSG_NO_UPGRADE_ALLOWED_GENERIC   0x0000275CL

//
// MessageId: MSG_TYPE_NTSTSE
//
// MessageText:
//
//  Microsoft Windows NT, Terminal Server Edition%0
//
#define MSG_TYPE_NTSTSE                  0x0000275DL

//
// MessageId: MSG_TYPE_NTSCITRIX
//
// MessageText:
//
//  Citrix WinFrame-based product%0
//
#define MSG_TYPE_NTSCITRIX               0x0000275EL

//
// MessageId: MSG_CCP_MEDIA_FPP_PID
//
// MessageText:
//
//  The pid is invalid for this version of Windows XP, provide the pid that came with the Windows XP Upgrade CD.
//
#define MSG_CCP_MEDIA_FPP_PID            0x0000275FL

//
// MessageId: MSG_FPP_MEDIA_CCP_PID
//
// MessageText:
//
//  The pid is invalid for this version of Windows XP, provide the pid that came with the Windows XP CD.
//
#define MSG_FPP_MEDIA_CCP_PID            0x00002760L

//
// MessageId: MSG_TYPE_NTPRO51PRE
//
// MessageText:
//
//  Microsoft Windows Whistler Professional%0
//
#define MSG_TYPE_NTPRO51PRE              0x00002761L

//
// MessageId: MSG_TYPE_NTS51PRE
//
// MessageText:
//
//  Microsoft Windows Whistler Server%0
//
#define MSG_TYPE_NTS51PRE                0x00002762L

//
// MessageId: MSG_TYPE_NTAS51PRE
//
// MessageText:
//
//  Microsoft Windows Whistler Advanced Server%0
//
#define MSG_TYPE_NTAS51PRE               0x00002763L

//
// MessageId: MSG_TYPE_NTSDTC51PRE
//
// MessageText:
//
//  Microsoft Windows Whistler Datacenter Server%0
//
#define MSG_TYPE_NTSDTC51PRE             0x00002764L

//
// MessageId: MSG_TYPE_NTPER51PRE
//
// MessageText:
//
//  Microsoft Windows Whistler Personal%0
//
#define MSG_TYPE_NTPER51PRE              0x00002765L

//
// MessageId: MSG_DSCHECK_SCHEMA_WHISTLER_BETA1_DETECTED
//
// MessageText:
//
//  Setup has detected that Whistler beta 1 domain controllers were previously installed in this forest. Whister beta 2 domain controllers cannot coexist in the same forest as Whistler beta 1 domain controllers.
//  
//  Demote all Whistler beta 1 domain controllers in this forest before upgrading to Whistler beta 2. An attempt to run both beta versions in a forest may cause loss of data.
//
#define MSG_DSCHECK_SCHEMA_WHISTLER_BETA1_DETECTED 0x00002766L

//
// MessageId: MSG_UPGRADE_INSPECTION_MISSING_BOOT_INI
//
// MessageText:
//
//  Setup was unable to access your existing boot configuration file, %1
//  
//  You may not start an NT upgrade without an existing boot configuration file.  You must restart the computer into the Recovery Console and follow the recovery steps to recreate your boot environment files before performing the upgrade.
//
#define MSG_UPGRADE_INSPECTION_MISSING_BOOT_INI 0x00002767L

//
// MessageId: MSG_UPGRADE_BOOT_INI_MUNGE_MISSING_BOOT_INI
//
// MessageText:
//
//  Setup was unable to access your existing boot configuration file, %1
//  
//  This file is required during an upgrade, and future restarts of this computer will fail.  Please restart this computer into the Recovery Console, and choose the option to repair/recover your boot and configuration files.
//
#define MSG_UPGRADE_BOOT_INI_MUNGE_MISSING_BOOT_INI 0x00002768L

#if defined(REMOTE_BOOT)
MessageId=xxxxx SymbolicName=MSG_REQUIRES_UPGRADE
Language=English
Remote boot clients must be upgraded; installation of a new operating system version is disabled. Upgrade is not possible, therefore this program must exit.%0
.

MessageId=xxxxx SymbolicName=MSG_CANT_UPGRADE_REMOTEBOOT_TO_SERVER
Language=English
Windows Whistler remote boot clients cannot be upgraded to Windows Whistler Server.%0
.
#endif // defined(REMOTE_BOOT)
//
// MessageId: MSG_X86_FIRST
//
// MessageText:
//
//  MSG_X86_FIRST
//
#define MSG_X86_FIRST                    0x00004E20L

//
// MessageId: MSG_REQUIRES_586
//
// MessageText:
//
//  Windows XP requires a Pentium or later processor.%0
//
#define MSG_REQUIRES_586                 0x00004E21L

//
// MessageId: MSG_CANT_GET_C_COLON
//
// MessageText:
//
//  Setup was unable to locate the drive from which your computer starts.%0
//
#define MSG_CANT_GET_C_COLON             0x00004E22L

//
// MessageId: MSG_DASD_ACCESS_FAILURE
//
// MessageText:
//
//  Setup was unable to read from or write to drive %1!c!. If a virus scanner is running, disable it then restart Setup.%0
//
#define MSG_DASD_ACCESS_FAILURE          0x00004E23L

//
// MessageId: MSG_UNSUPPORTED_SECTOR_SIZE
//
// MessageText:
//
//  Drive %1!c! uses an unsupported data block size. Setup cannot configure your computer to start Windows XP from the drive.%0
//
#define MSG_UNSUPPORTED_SECTOR_SIZE      0x00004E24L

//
// MessageId: MSG_UNKNOWN_FS
//
// MessageText:
//
//  Setup could not determine the file system in use on drive %1!c!, or the file system is not recognized by Setup. Your computer cannot be configured to start Windows XP from the drive.%0
//
#define MSG_UNKNOWN_FS                   0x00004E25L

//
// MessageId: MSG_NTLDR_NOT_COPIED
//
// MessageText:
//
//  The critical system file %1!c!:\NTLDR was not successfully copied. Setup cannot continue.%0
//
#define MSG_NTLDR_NOT_COPIED             0x00004E26L

//
// MessageId: MSG_SYSPART_IS_HPFS
//
// MessageText:
//
//  The hard drive from which your computer starts (%1!c!:) is formatted with the OS/2 File System (HPFS). Windows XP does not support this file system.
//  
//  You must convert this drive to the Windows NT File System (NTFS) before upgrading.%0
//
#define MSG_SYSPART_IS_HPFS              0x00004E27L

//
// MessageId: MSG_SYSTEM_ON_CVF
//
// MessageText:
//
//  Windows is installed on a DriveSpace, DoubleSpace, or other compressed drive. Windows XP does not support compressed drives.
//  
//  You must uncompress the drive before upgrading.%0
//
#define MSG_SYSTEM_ON_CVF                0x00004E28L

//
// MessageId: MSG_CVFS_EXIST
//
// MessageText:
//
//  DriveSpace, DoubleSpace, or other compressed drives exist on your computer. Windows XP does not support compressed drives. You will not be able to access data stored on these drives from Windows XP.
//  
//  Would you like to continue installing Windows XP?%0
//
#define MSG_CVFS_EXIST                   0x00004E29L

//
// MessageId: MSG_GENERIC_FLOPPY_PROMPT
//
// MessageText:
//
//  Please insert a formatted, blank high-density floppy disk into drive A:. This disk will become "%1."
//  
//  Click OK when the disk is in the drive, or click Cancel to exit Setup.%0
//
#define MSG_GENERIC_FLOPPY_PROMPT        0x00004E2AL

//
// MessageId: MSG_FIRST_FLOPPY_PROMPT
//
// MessageText:
//
//  You must now provide %2!u! formatted, blank high-density floppy disks.
//  
//  Please insert one of these disks into drive A:. This disk will become "%1."
//  
//  Click OK when the disk is in the drive, or click Cancel to exit Setup.%0
//
#define MSG_FIRST_FLOPPY_PROMPT          0x00004E2BL

//
// MessageId: MSG_FLOPPY_BAD_FORMAT
//
// MessageText:
//
//  If you inserted a floppy disk, it is too small or it is not formatted with a recognized file system. Setup is unable to use this disk.
//  
//  Click OK. Setup will prompt you for a different floppy disk.%0
//
#define MSG_FLOPPY_BAD_FORMAT            0x00004E2CL

//
// MessageId: MSG_FLOPPY_CANT_GET_SPACE
//
// MessageText:
//
//  Setup is unable to determine the amount of free space on the floppy disk you have provided. Setup is unable to use this disk.
//  
//  Click OK. Setup will prompt you for a different floppy disk.%0
//
#define MSG_FLOPPY_CANT_GET_SPACE        0x00004E2DL

//
// MessageId: MSG_FLOPPY_NOT_BLANK
//
// MessageText:
//
//  The floppy disk you have provided is not blank. Setup is unable to use this disk.
//  
//  Click OK. Setup will prompt you for a different floppy disk.%0
//
#define MSG_FLOPPY_NOT_BLANK             0x00004E2EL

//
// MessageId: MSG_CANT_WRITE_FLOPPY
//
// MessageText:
//
//  Setup was unable to write to the floppy disk in drive A:. The floppy disk may be damaged or write-protected. Remove write protection or try a different floppy disk.
//  
//  Click OK. Setup will prompt you for a different floppy disk.%0
//
#define MSG_CANT_WRITE_FLOPPY            0x00004E2FL

//
// MessageId: MSG_FLOPPY_BUSY
//
// MessageText:
//
//  Setup is unable to access the floppy disk in drive A:. The drive may be in use by another application.
//  
//  Click OK. Setup will prompt you for a different floppy disk.%0
//
#define MSG_FLOPPY_BUSY                  0x00004E30L

//
// MessageId: MSG_CANT_MOVE_FILE_TO_FLOPPY
//
// MessageText:
//
//  Setup was unable to move file %2 to drive %1!c!:.%0
//
#define MSG_CANT_MOVE_FILE_TO_FLOPPY     0x00004E31L

//
// MessageId: MSG_EVIL_FLOPPY_DRIVE
//
// MessageText:
//
//  Setup has determined that floppy drive A: is non-existent or is not a high-density 3.5" drive. An A: drive with a capacity of 1.44 Megabytes or higher is required for Setup operation with floppies.%0
//
#define MSG_EVIL_FLOPPY_DRIVE            0x00004E32L

//
// MessageId: MSG_UPGRADE_DLL_CORRUPT
//
// MessageText:
//
//  The file %1 needed by Setup in order to upgrade the current environment to Windows XP is corrupt. Contact your system administrator.
//  
//  Setup will continue but the option to upgrade will not be available.%0
//
#define MSG_UPGRADE_DLL_CORRUPT          0x00004E33L

//
// MessageId: MSG_UPGRADE_DLL_ERROR
//
// MessageText:
//
//  The option to upgrade will not be available at this time because Setup was unable to load the file %1.%0
//
#define MSG_UPGRADE_DLL_ERROR            0x00004E34L

//
// MessageId: MSG_UPGRADE_INIT_ERROR
//
// MessageText:
//
//  The option to upgrade will not be available at this time.%0
//
#define MSG_UPGRADE_INIT_ERROR           0x00004E35L

//
// MessageId: MSG_MEMPHIS_NOT_YET_SUPPORTED
//
// MessageText:
//
//  MSG_MEMPHIS_NOT_YET_SUPPORTED
//
#define MSG_MEMPHIS_NOT_YET_SUPPORTED    0x00004E37L

//
// MessageId: MSG_BOOT_TEXT_TOO_LONG
//
// MessageText:
//
//  Internal Setup error: the translated boot code messages are too long.%0
//
#define MSG_BOOT_TEXT_TOO_LONG           0x00004E38L

//
// MessageId: MSG_UPGRADE_LANG_ERROR
//
// MessageText:
//
//  The language of this installation of Windows differs from the one you are installing. The option to upgrade will not be available.%0
//
#define MSG_UPGRADE_LANG_ERROR           0x00004E39L

//
// MessageId: MSG_NO_CROSS_PLATFORM
//
// MessageText:
//
//  32 bit Setup cannot run on this platform. Setup is unable to continue.%0
//
#define MSG_NO_CROSS_PLATFORM            0x00004E3AL

//
// MessageId: MSG_RISC_FIRST
//
// MessageText:
//
//  MSG_RISC_FIRST
//
#define MSG_RISC_FIRST                   0x00007530L

//
// MessageId: MSG_SYSTEM_PARTITION_INVALID
//
// MessageText:
//
//  No valid system partitions were found. Setup is unable to continue.%0
//
#define MSG_SYSTEM_PARTITION_INVALID     0x00007531L

//
// MessageId: MSG_COULDNT_READ_NVRAM
//
// MessageText:
//
//  An unexpected error occured reading your computer's startup environment. Contact your computer manufacturer.%0
//
#define MSG_COULDNT_READ_NVRAM           0x00007532L

//
// MessageId: MSG_COULDNT_WRITE_NVRAM
//
// MessageText:
//
//  Setup was unable to modify your computer's startup settings. The startup environment may be full.%0
//
#define MSG_COULDNT_WRITE_NVRAM          0x00007533L

//
// MessageId: MSG_NOT_FOUND
//
// MessageText:
//
//  The system could not locate message #%1!x!.
//
#define MSG_NOT_FOUND                    0x00007534L

//
// MessageId: MSG_INF_SINGLELINE
//
// MessageText:
//
//  %1
//
#define MSG_INF_SINGLELINE               0x00007536L

//
// MessageId: MSG_INF_BAD_REGSPEC_1
//
// MessageText:
//
//  ; Warning: the following line represents a registry change that could be
//  ; expressed in an INF file. The root key has been changed to HKR.
//
#define MSG_INF_BAD_REGSPEC_1            0x00007537L

//
// MessageId: MSG_INF_BAD_REGSPEC_2
//
// MessageText:
//
//  ; Warning: the following line represents a registry change that could be
//  ; expressed in an INF file. The data type has been changed to REG_BINARY.
//
#define MSG_INF_BAD_REGSPEC_2            0x00007538L

//
// MessageId: MSG_SUCCESSFUL_UPGRADE_CHECK
//
// MessageText:
//
//  Windows XP upgrade check successfully completed.
//
#define MSG_SUCCESSFUL_UPGRADE_CHECK     0x00007539L

//
// MessageId: MSG_NOT_ENOUGH_MEMORY
//
// MessageText:
//
//  Setup detected %1!u!MB of RAM, but %2!u!MB is required.
//
#define MSG_NOT_ENOUGH_MEMORY            0x0000753BL

//
// MessageId: MSG_INTLINF_NOT_FOUND
//
// MessageText:
//
//  Setup was unable to locate or load the international settings INF, or the file is corrupt.  Make sure the location of Windows XP files is set correctly under Advanced Options.
//
#define MSG_INTLINF_NOT_FOUND            0x0000753CL

//
// MessageId: MSG_CMDCONS_RISC
//
// MessageText:
//
//  The Recovery Console option is not supported on this platform.
//
#define MSG_CMDCONS_RISC                 0x0000753DL

//
// MessageId: MSG_DCPROMO_DISKSPACE
//
// MessageText:
//
//  Setup has detected that you may not have enough disk space on your installation partition to use Active Directory after the upgrade is complete.
//  
//  To complete the upgrade and then store the Active Directory data in a separate location or on a new disk, click OK. To exit Setup and free an additional %1!u! MB from your installation partition now, click Cancel.
//  
//
#define MSG_DCPROMO_DISKSPACE            0x0000753EL

//
// MessageId: MSG_CMDCONS_WIN9X
//
// MessageText:
//
//  You can only install the Recovery Console from Windows XP.
//
#define MSG_CMDCONS_WIN9X                0x0000753FL

//
// MessageId: MSG_LOG_START
//
// MessageText:
//
//  MSG_LOG_START
//
#define MSG_LOG_START                    0x00009C40L

//
// MessageId: MSG_LOG_ADDED_DIR_TO_COPY_LIST
//
// MessageText:
//
//  Added directory to copy list:
//  
//      SourceName = %1
//      TargetName = %2
//      InfSymbol  = %3
//  
//
#define MSG_LOG_ADDED_DIR_TO_COPY_LIST   0x00009C41L

//
// MessageId: MSG_LOG_ADDED_FILE_TO_COPY_LIST
//
// MessageText:
//
//  Added file to copy list:
//  
//      SourceName = %1
//      Directory  = %2
//      Size       = %3
//      TargetName = %4
//      Flags      = %5
//  
//
#define MSG_LOG_ADDED_FILE_TO_COPY_LIST  0x00009C42L

//
// MessageId: MSG_LOG_CHECKING_DRIVES
//
// MessageText:
//
//  Examining drives:
//
#define MSG_LOG_CHECKING_DRIVES          0x00009C43L

//
// MessageId: MSG_LOG_DRIVE_NOT_HARD
//
// MessageText:
//
//  Drive %1!c!: doesn't exist or is not a local hard drive
//
#define MSG_LOG_DRIVE_NOT_HARD           0x00009C44L

//
// MessageId: MSG_LOG_DRIVE_NO_VOL_INFO
//
// MessageText:
//
//  Drive %1!c!: unsupported file system
//
#define MSG_LOG_DRIVE_NO_VOL_INFO        0x00009C45L

//
// MessageId: MSG_LOG_DRIVE_NTFT
//
// MessageText:
//
//  Drive %1!c!: part of FT set
//
#define MSG_LOG_DRIVE_NTFT               0x00009C46L

//
// MessageId: MSG_LOG_DRIVE_NO_ARC
//
// MessageText:
//
//  Drive %1!c!: not visible from firmware
//
#define MSG_LOG_DRIVE_NO_ARC             0x00009C47L

//
// MessageId: MSG_LOG_DRIVE_CANT_GET_SPACE
//
// MessageText:
//
//  Drive %1!c!: unable to determine free space (error = %2!u!)
//
#define MSG_LOG_DRIVE_CANT_GET_SPACE     0x00009C48L

//
// MessageId: MSG_LOG_DRIVE_NOT_ENOUGH_SPACE
//
// MessageText:
//
//  Drive %1!c!: not enough space (%2!u! bpc, %3!u! clus, %4!u! free)
//
#define MSG_LOG_DRIVE_NOT_ENOUGH_SPACE   0x00009C49L

//
// MessageId: MSG_LOG_DRIVE_OK
//
// MessageText:
//
//  Drive %1!c!: acceptable
//
#define MSG_LOG_DRIVE_OK                 0x00009C4AL

//
// MessageId: MSG_LOG_COPY_OK
//
// MessageText:
//
//  Source %3!u!: copy %1 to %2 [OK]
//
#define MSG_LOG_COPY_OK                  0x00009C4BL

//
// MessageId: MSG_LOG_COPY_ERR
//
// MessageText:
//
//  Source %3!u!: copy %1 to %2 [error %4!u!]
//
#define MSG_LOG_COPY_ERR                 0x00009C4CL

//
// MessageId: MSG_LOG_SKIPPED_FILE
//
// MessageText:
//
//  File %1 autoskipped
//
#define MSG_LOG_SKIPPED_FILE             0x00009C4DL

//
// MessageId: MSG_LOG_CHECKING_USER_DRIVE
//
// MessageText:
//
//  Examining drive %1!c!: specified on command line:
//
#define MSG_LOG_CHECKING_USER_DRIVE      0x00009C4EL

//
// MessageId: MSG_LOG_DRIVE_VERITAS
//
// MessageText:
//
//  Drive %1!c!: Soft partition on a dynamic volume
//
#define MSG_LOG_DRIVE_VERITAS            0x00009C4FL

//
// MessageId: MSG_LOG_DECOMP_ERR
//
// MessageText:
//
//  Source %3!u!: decompress %1 to %2 [error %4!u!]
//
#define MSG_LOG_DECOMP_ERR               0x00009C50L

//
// MessageId: MSG_LOG_SYSTEM_PARTITION_TOO_SMALL
//
// MessageText:
//
//  Drive %1!c!: not enough space for boot files (%2!u! free, %3!u! required)
//
#define MSG_LOG_SYSTEM_PARTITION_TOO_SMALL 0x00009C51L

//
// MessageId: MSG_LOG_SYSTEM_PARTITION_INVALID
//
// MessageText:
//
//  Drive %1!c!: is not a valid system partition.
//
#define MSG_LOG_SYSTEM_PARTITION_INVALID 0x00009C52L

//
// MessageId: MSG_LOG_SYSTEM_PARTITION_VALID
//
// MessageText:
//
//  Drive %1!c!: acceptable for boot files
//
#define MSG_LOG_SYSTEM_PARTITION_VALID   0x00009C53L

//
// MessageId: MSG_LOG_LOCAL_SOURCE_TOO_SMALL
//
// MessageText:
//
//  Drive %1!c!: not enough space for temporary installation files (%2!u! MB free, %3!u! MB required)
//
#define MSG_LOG_LOCAL_SOURCE_TOO_SMALL   0x00009C54L

//
// MessageId: MSG_LOG_LOCAL_SOURCE_INVALID
//
// MessageText:
//
//  Drive %1!c!: not valid for holding temporary installation files.
//
#define MSG_LOG_LOCAL_SOURCE_INVALID     0x00009C55L

//
// MessageId: MSG_LOG_LOCAL_SOURCE_VALID
//
// MessageText:
//
//  Drive %1!c!: acceptable for local source.
//
#define MSG_LOG_LOCAL_SOURCE_VALID       0x00009C56L

//
// MessageId: MSG_LOG_INSTALL_DRIVE_TOO_SMALL
//
// MessageText:
//
//  Drive %1!c!: not enough space to upgrade final installation directory (%2!u! free, %3!u! required)
//
#define MSG_LOG_INSTALL_DRIVE_TOO_SMALL  0x00009C57L

//
// MessageId: MSG_LOG_INSTALL_DRIVE_INVALID
//
// MessageText:
//
//  Drive %1!c!: is not a valid for holding final installation directory.
//
#define MSG_LOG_INSTALL_DRIVE_INVALID    0x00009C58L

//
// MessageId: MSG_LOG_INSTALL_DRIVE_OK
//
// MessageText:
//
//  Drive %1!c!: acceptable for final installation directory.
//
#define MSG_LOG_INSTALL_DRIVE_OK         0x00009C59L

//
// MessageId: MSG_LOG_BEGIN
//
// MessageText:
//
//  The WINNT32 portion of Setup has started.
//  
//
#define MSG_LOG_BEGIN                    0x00009C5BL

//
// MessageId: MSG_LOG_END
//
// MessageText:
//
//  
//  The WINNT32 portion of Setup has completed.
//  
//
#define MSG_LOG_END                      0x00009C5CL

//
// MessageId: MSG_SKU_UNKNOWNSOURCE
//
// MessageText:
//
//  Windows XP Setup could not load the Setup configuration files.  Your Windows XP Setup files may be damaged or unreadable.
//  
//  Setup cannot continue.
//
#define MSG_SKU_UNKNOWNSOURCE            0x00009C5DL

//
// MessageId: MSG_SKU_VERSION
//
// MessageText:
//
//  The version of Windows you have is not supported for upgrade.
//
#define MSG_SKU_VERSION                  0x00009C5EL

//
// MessageId: MSG_SKU_VARIATION
//
// MessageText:
//
//  Your copy of Windows XP does not support upgrading from an evaluation copy of Windows.
//
#define MSG_SKU_VARIATION                0x00009C5FL

//
// MessageId: MSG_SKU_SUITE
//
// MessageText:
//
//  Your copy of Windows XP does not support the required product suite.
//
#define MSG_SKU_SUITE                    0x00009C60L

//
// MessageId: MSG_SKU_TYPE_NTW
//
// MessageText:
//
//  Your copy of Windows XP only supports upgrades from Windows 95, Windows 98, and Windows NT Workstation.
//
#define MSG_SKU_TYPE_NTW                 0x00009C61L

//
// MessageId: MSG_SKU_TYPE_NTS
//
// MessageText:
//
//  Your copy of Windows XP only supports upgrading from Windows NT Server versions 3.51 and 4.0.
//
#define MSG_SKU_TYPE_NTS                 0x00009C62L

//
// MessageId: MSG_SKU_TYPE_NTSE
//
// MessageText:
//
//  Your copy of Windows XP only allows upgrades from Windows NT Server, Enterprise Edition version 4.0.
//
#define MSG_SKU_TYPE_NTSE                0x00009C63L

//
// MessageId: MSG_SKU_FULL
//
// MessageText:
//
//  Setup cannot upgrade your current installation to Windows XP.
//  %1
//  You can install a new copy of Windows XP, but you will have to reinstall your applications and settings.
//
#define MSG_SKU_FULL                     0x00009C64L

//
// MessageId: MSG_SKU_UPGRADE
//
// MessageText:
//
//  Setup cannot upgrade your current installation to Windows XP.
//  %1
//  Setup cannot continue.
//
#define MSG_SKU_UPGRADE                  0x00009C65L

//
// MessageId: MSG_NO_UPGRADE_OR_CLEAN
//
// MessageText:
//
//  Setup cannot continue because upgrade functionality is disabled and your copy of Windows XP only allows upgrades.
//
#define MSG_NO_UPGRADE_OR_CLEAN          0x00009C66L

//
// MessageId: MSG_SKU_UNKNOWNTARGET
//
// MessageText:
//
//  Windows XP Setup could not detect the version of Windows you are currently running.  Setup cannot continue.
//
#define MSG_SKU_UNKNOWNTARGET            0x00009C68L

//
// MessageId: MSG_NEC98_NEED_UNINSTALL_DMITOOL
//
// MessageText:
//
//  Windows XP setup found DMITOOL Ver2.0. This application blocks Windows XP setup.
//  Please uninstall DMITOOL and run setup again.
//
#define MSG_NEC98_NEED_UNINSTALL_DMITOOL 0x00009C69L

//
// MessageId: MSG_NEC98_NEED_REMOVE_ATA
//
// MessageText:
//
//  Windows setup found an ATA Disk. This device blocks Windows setup.
//  Please remove the ATA Disk and run setup again.
//
#define MSG_NEC98_NEED_REMOVE_ATA        0x00009C6AL

//
// MessageId: MSG_CMDCONS_ASK
//
// MessageText:
//
//  You can install the Windows Recovery Console as a startup option.  The Recovery Console helps you gain access to your Windows installation to replace damaged files and disable or enable services.
//  
//  If you cannot start the Recovery Console from your computer's hard disk, you can run the Recovery Console from the Windows Setup CD.
//  
//  The Recovery Console requires approximately 7MB of hard disk space.
//  
//  Do you want to install the Recovery Console?
//
#define MSG_CMDCONS_ASK                  0x0000C350L

//
// MessageId: MSG_CMDCONS_DONE
//
// MessageText:
//
//  The Windows Recovery Console has been successfully installed.
//  
//  To use the Windows Recovery Console, restart your computer and then select Windows Recovery Console from the Startup Menu.
//  
//  For a list of commands you can use with the Recovery Console, type HELP at the Recovery Console command prompt.
//
#define MSG_CMDCONS_DONE                 0x0000C351L

//
// MessageId: MSG_CMDCONS_DID_NOT_FINISH
//
// MessageText:
//
//  The installation did not complete correctly.
//  
//  It is possible that Windows XP startup files in the root directory were missing or in use during the installation. Please close any applications that might be using those files.
//
#define MSG_CMDCONS_DID_NOT_FINISH       0x0000C352L

//
// MessageId: MSG_NO_PLATFORM
//
// MessageText:
//
//  Dosnet does not have a Destination Platform.
//
#define MSG_NO_PLATFORM                  0x0000C353L

//
// MessageId: MSG_WINNT32_CANCELLED
//
// MessageText:
//
//  Winnt32 Has been cancelled.
//
#define MSG_WINNT32_CANCELLED            0x0000C354L

//
// MessageId: MSG_INVALID_HEADLESS_SETTING
//
// MessageText:
//
//  The specified COM port selection is invalid.
//
#define MSG_INVALID_HEADLESS_SETTING     0x0000C355L

//
// MessageId: MSG_UDF_INVALID_USAGE
//
// MessageText:
//
//  To use the %1 file with Windows XP Setup, start Windows XP Setup from a network share or from a CD-ROM, and use the /makelocalsource option.
//  %0
//
#define MSG_UDF_INVALID_USAGE            0x0000C3B4L

//
// MessageId: MSG_UPGRADE_OTHER_OS_FOUND
//
// MessageText:
//
//  You cannot upgrade your Windows installation to Windows XP because you have more than one operating system installed on your computer. Upgrading one operating system can cause problems with files shared by the other operating system, and is therefore not permitted.
//  %0
//
#define MSG_UPGRADE_OTHER_OS_FOUND       0x0000C418L

//
// MessageId: MSG_UPGRADE_W95UPG_OLDER_REGISTERED
//
// MessageText:
//
//  Setup found a registered dll on your machine which is older than the one on CD, and therefore will be ignored.
//  %0
//
#define MSG_UPGRADE_W95UPG_OLDER_REGISTERED 0x0000C47CL

//
// MessageId: MSG_REGISTRY_ACCESS_ERROR
//
// MessageText:
//
//  Setup cannot continue because some necessary information cannot be accessed in the registry.%0
//
#define MSG_REGISTRY_ACCESS_ERROR        0x0000C4E0L

//
// MessageId: MSG_LOG_SYSTEM_PARTITION_TOO_SMALL2
//
// MessageText:
//
//  Drive %1 not enough space for boot files (%2!u! free, %3!u! required)
//
#define MSG_LOG_SYSTEM_PARTITION_TOO_SMALL2 0x0000C544L

//
// MessageId: MSG_LOG_SYSTEM_PARTITION_VALID2
//
// MessageText:
//
//  Drive %1 acceptable for boot files
//
#define MSG_LOG_SYSTEM_PARTITION_VALID2  0x0000C545L

//
// MessageId: MSG_LOG_SYSTEM_PARTITION_INVALID2
//
// MessageText:
//
//  Drive %1 is not a valid system partition.
//
#define MSG_LOG_SYSTEM_PARTITION_INVALID2 0x0000C546L

//
// MessageId: MSG_LOG_DRIVE_NOT_HARD2
//
// MessageText:
//
//  Drive %1 doesn't exist or is not a local hard drive
//
#define MSG_LOG_DRIVE_NOT_HARD2          0x0000C547L

//
// MessageId: MSG_SYSTEM_PARTITION_TOO_SMALL2
//
// MessageText:
//
//  There is not enough space on your system partition (Volume %1).
//  
//  Approximately %2!u! MB of free space is required (actual requirements vary depending on drive size and formatting).%0
//
#define MSG_SYSTEM_PARTITION_TOO_SMALL2  0x0000C548L

//
// MessageId: LOG_DYNUPDT_DISABLED
//
// MessageText:
//
//  The Dynamic Update feature is disabled.
//  %0
//
#define LOG_DYNUPDT_DISABLED             0x0000C549L

//
// MessageId: MSG_PLATFORM_NOT_SUPPORTED
//
// MessageText:
//
//  Windows XP does not support this platform. Setup is unable to continue.
//  %0
//
#define MSG_PLATFORM_NOT_SUPPORTED       0x0000C54DL

//
// MessageId: MSG_SURE_CANCEL_DOWNLOAD_DRIVERS
//
// MessageText:
//
//  Setup is downloading important product updates and up to %1!u! driver(s) required for your hardware devices. If you cancel, these devices might not work after the upgrade is completed. Are you sure you want to cancel the download?%0
//
#define MSG_SURE_CANCEL_DOWNLOAD_DRIVERS 0x0000C54EL

//
// MessageId: MSG_NO_UPDATE_SHARE
//
// MessageText:
//
//  Setup cannot update the installation sources because no update share was specified.%0
//
#define MSG_NO_UPDATE_SHARE              0x0000C54FL

//
// MessageId: MSG_PREPARE_SHARE_FAILED
//
// MessageText:
//
//  Setup encountered an error while updating the installation sources.%0
//
#define MSG_PREPARE_SHARE_FAILED         0x0000C550L

//
// MessageId: MSG_INVALID_INF_FILE
//
// MessageText:
//
//  Setup information file %1 is invalid.
//  
//  Contact your system administrator.%0
//
#define MSG_INVALID_INF_FILE             0x0000C551L

//
// MessageId: MSG_RESTART
//
// MessageText:
//
//  Restart%0
//
#define MSG_RESTART                      0x0000C552L

//
// MessageId: MSG_ERROR_PROCESSING_DRIVER
//
// MessageText:
//
//  Unable to process information files in package %1. Replace or remove it before restarting Setup.%0
//
#define MSG_ERROR_PROCESSING_DRIVER      0x0000C553L

//
// MessageId: MSG_ERROR_WRITING_FILE
//
// MessageText:
//
//  Setup encountered an error (%1!u!) writing to file %2. Make sure the path is accessible and you have write permissions.%0
//
#define MSG_ERROR_WRITING_FILE           0x0000C554L

//
// MessageId: MSG_ERROR_PROCESSING_UPDATES
//
// MessageText:
//
//  Setup encountered an error (%1!u!) while processing %2. For more information examine setup log files.%0
//
#define MSG_ERROR_PROCESSING_UPDATES     0x0000C555L

//
// MessageId: MSG_LOG_USE_UPDATED
//
// MessageText:
//
//  Source %3!u!: Using replacement file %1 for %2.
//
#define MSG_LOG_USE_UPDATED              0x0000C556L

//
// MessageId: MSG_MUST_PREPARE_SHARE
//
// MessageText:
//
//  The specified share %1 must be prepared before use.
//  
//  Contact your system administrator.%0
//
#define MSG_MUST_PREPARE_SHARE           0x0000C557L

//
// MessageId: MSG_SKU_SERVICEPACK
//
// MessageText:
//
//  Windows Setup cannot continue without service pack 5 or greater installed.
//  Please install the latest Windows NT 4.0 service pack.%0
//
#define MSG_SKU_SERVICEPACK              0x0000C558L

//
// MessageId: MSG_SYSTEM_PARTITIONTYPE_INVALID
//
// MessageText:
//
//  The disk containing the system partition is not partitioned in the GPT format, which is required to install Windows.  You must repartition this disk in the GPT format.  You can do this by installing Windows from CD media.  Setup cannot continue.
//
#define MSG_SYSTEM_PARTITIONTYPE_INVALID 0x0000C559L

//
// MessageId: MSG_LOG_DISKSPACE_CHECK
//
// MessageText:
//
//  DiskSpace Check:
//  
//          DriveLetter        = %1!c!
//          ClusterSize        = %2!u!
//          FreeSpace          = %3!u!MB
//          
//          SpaceLocalSource   = %4!u!MB  (includes %5!u!MB padding)
//          SpaceBootFiles     = %6!u!MB
//          SpaceWinDirSpace   = %7!u!MB
//          TotalSpaceRequired = %8!u!MB
//  
//
#define MSG_LOG_DISKSPACE_CHECK          0x0000C55AL

//
// MessageId: MSG_TYPE_WINME
//
// MessageText:
//
//  Microsoft Windows Millennium%0
//
#define MSG_TYPE_WINME                   0x0000C55CL

//
// MessageId: MSG_NO_DETAILS
//
// MessageText:
//
//  There are no details available for this incompatibility.
//
#define MSG_NO_DETAILS                   0x0000C55DL

//
// MessageId: MSG_SXS_ERROR_DIRECTORY_IS_MISSING_MANIFEST
//
// MessageText:
//
//  The manifest file "%2" is missing from the directory %1.
//
#define MSG_SXS_ERROR_DIRECTORY_IS_MISSING_MANIFEST 0x0000C5A8L

//
// MessageId: MSG_SXS_ERROR_DIRECTORY_IS_MISSING_CATALOG
//
// MessageText:
//
//  The catalog file "%2" is missing from the directory %1.
//
#define MSG_SXS_ERROR_DIRECTORY_IS_MISSING_CATALOG 0x0000C5A9L

//
// MessageId: MSG_SXS_ERROR_FILE_IS_ALL_ZEROES
//
// MessageText:
//
//  The file %1 is corrupt; it contains all zeroes.
//
#define MSG_SXS_ERROR_FILE_IS_ALL_ZEROES 0x0000C5AAL

//
// MessageId: MSG_SXS_ERROR_FILE_INSTEAD_OF_DIRECTORY
//
// MessageText:
//
//  %1 is expected to be a directory, but it is a file.
//
#define MSG_SXS_ERROR_FILE_INSTEAD_OF_DIRECTORY 0x0000C5ABL

//
// MessageId: MSG_SXS_ERROR_NON_LEAF_DIRECTORY_CONTAINS_FILE
//
// MessageText:
//
//  %1 should only contain directories, but it contains the file %2.
//
#define MSG_SXS_ERROR_NON_LEAF_DIRECTORY_CONTAINS_FILE 0x0000C5ACL

//
// MessageId: MSG_SXS_ERROR_REQUIRED_DIRECTORY_MISSING
//
// MessageText:
//
//  The required directory %1 is missing.
//
#define MSG_SXS_ERROR_REQUIRED_DIRECTORY_MISSING 0x0000C5ADL

//
// MessageId: MSG_SXS_ERROR_FILE_OPEN_FAILED
//
// MessageText:
//
//  Setup was unable to open the file %1.
//
#define MSG_SXS_ERROR_FILE_OPEN_FAILED   0x0000C5AEL

//
// MessageId: MSG_SXS_ERROR_FILE_READ_FAILED
//
// MessageText:
//
//  Setup was unable to read the file %1.
//
#define MSG_SXS_ERROR_FILE_READ_FAILED   0x0000C5AFL

//
// MessageId: MSG_SXS_ERROR_DIRECTORY_EMPTY
//
// MessageText:
//
//  The directory %1 is empty.
//
#define MSG_SXS_ERROR_DIRECTORY_EMPTY    0x0000C5B0L

//
// MessageId: MSG_SXS_ERROR_OBSOLETE_DIRECTORY_PRESENT
//
// MessageText:
//
//  The directory %1 is from an older version of Windows and should not be present.
//
#define MSG_SXS_ERROR_OBSOLETE_DIRECTORY_PRESENT 0x0000C5B1L

//
// MessageId: MSG_SURE_CANCEL_DOWNLOAD
//
// MessageText:
//
//  Setup is downloading important product updates. Are you sure you want to cancel the download?%0
//
#define MSG_SURE_CANCEL_DOWNLOAD         0x0000C5B2L

//
// MessageId: MSG_WARNING_ACCESSIBILITY
//
// MessageText:
//
//  If you want to choose the install drive letter and partition, there will be parts of setup during which the accessibility features will not be available. Do you wish to continue?
//
#define MSG_WARNING_ACCESSIBILITY        0x0000C5B3L

//
// MessageId: MSG_TYPE_NTPRO51
//
// MessageText:
//
//  Microsoft Windows XP Professional%0
//
#define MSG_TYPE_NTPRO51                 0x0000C5B4L

//
// MessageId: MSG_TYPE_NTS51
//
// MessageText:
//
//  Microsoft Windows Whistler Server%0
//
#define MSG_TYPE_NTS51                   0x0000C5B5L

//
// MessageId: MSG_TYPE_NTAS51
//
// MessageText:
//
//  Microsoft Windows Whistler Advanced Server%0
//
#define MSG_TYPE_NTAS51                  0x0000C5B6L

//
// MessageId: MSG_TYPE_NTSDTC51
//
// MessageText:
//
//  Microsoft Windows Whistler Datacenter Server%0
//
#define MSG_TYPE_NTSDTC51                0x0000C5B7L

//
// MessageId: MSG_TYPE_NTPER51
//
// MessageText:
//
//  Microsoft Windows XP Home Edition%0
//
#define MSG_TYPE_NTPER51                 0x0000C5B8L

//
// MessageId: MSG_TYPE_NTBLA51
//
// MessageText:
//
//  Microsoft Windows Whistler Blade Server%0
//
#define MSG_TYPE_NTBLA51                 0x0000C5B9L

//
// MessageId: MSG_RESTART_TO_RUN_AGAIN
//
// MessageText:
//
//  Before Setup continues, please restart your computer.%0
//
#define MSG_RESTART_TO_RUN_AGAIN         0x0000C5BAL

//
// MessageId: MSG_SKU_TYPE
//
// MessageText:
//
//  Your current installation of Windows is not a supported upgrade path.
//
#define MSG_SKU_TYPE                     0x0000C5BBL

//
// MessageId: MSG_SYSTEM_HAS_THIRD_PARTY_KERNEL
//
// MessageText:
//
//  Setup cannot upgrade due to third-party kernel.%0
//
#define MSG_SYSTEM_HAS_THIRD_PARTY_KERNEL 0x0000C5BCL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\media.cpp ===
/*

*/


#include <compfile.h>
#include "media.h"
#include "msg.h"
#include "resource.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

#define GetBBhwnd() NULL
#define SETUP_TYPE_BUFFER_LEN                8
#define MAX_PID30_SITE                       3
#define MAX_PID30_RPC                        5

#define SETUPP_INI_A            "SETUPP.INI"
#define SETUPP_INI_W            L"SETUPP.INI"
#define PID_SECTION_A           "Pid"
#define PID_SECTION_W           L"Pid"
#define PID_KEY_A               "Pid"
#define PID_KEY_W               L"Pid"
#define OEM_INSTALL_RPC_A       "OEM"
#define OEM_INSTALL_RPC_W       L"OEM"
#define SELECT_INSTALL_RPC_A    "270"
#define SELECT_INSTALL_RPC_W    L"270"
#define MSDN_INSTALL_RPC_A      "335"
#define MSDN_INSTALL_RPC_W      L"335"
#define MSDN_PID30_A            "MD97J-QC7R7-TQJGD-3V2WM-W7PVM"
#define MSDN_PID30_W            L"MD97J-QC7R7-TQJGD-3V2WM-W7PVM"

#define INF_FILE_HEADER         "[Version]\r\nSignature = \"$Windows NT$\"\r\n\r\n"


#ifdef UNICODE
#define SETUPP_INI              SETUPP_INI_W
#define PID_SECTION             PID_SECTION_W
#define PID_KEY                 PID_KEY_W
#define OEM_INSTALL_RPC         OEM_INSTALL_RPC_W
#define SELECT_INSTALL_RPC      SELECT_INSTALL_RPC_W
#define MSDN_INSTALL_RPC        MSDN_INSTALL_RPC_W
#define MSDN_PID30              MSDN_PID30_W
#else
#define SETUPP_INI              SETUPP_INI_A
#define PID_SECTION             PID_SECTION_A
#define PID_KEY                 PID_KEY_A
#define OEM_INSTALL_RPC         OEM_INSTALL_RPC_A
#define SELECT_INSTALL_RPC      SELECT_INSTALL_RPC_A
#define MSDN_INSTALL_RPC        MSDN_INSTALL_RPC_A
#define MSDN_PID30              MSDN_PID30_A
#endif


typedef enum InstallType
{
   SelectInstall,
   OEMInstall,
   RetailInstall
};


LONG SourceInstallType = RetailInstall;

WCHAR DosnetPath[MAX_PATH];
DWORD SourceSku;
DWORD SourceSkuVariation;
DWORD SourceVersion;
DWORD SourceBuildNum;
DWORD OsVersionNumber = 500;
HINSTANCE hInstA =NULL;
HINSTANCE hInstU =NULL;
HINSTANCE hInst =NULL;
UINT AppTitleStringId = IDS_APPTITLE;
BOOL Cancelled;

/* Taken from winnt32\dll\util.c 
   Keep in sync
   */

VOID
ConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

{
    BOOL NeedBackslash = TRUE;
    DWORD l;

    if(!Path1)
        return;

    l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(Path2 && ((l+lstrlen(Path2)) < BufferSizeChars)) {
        lstrcat(Path1,Path2);
    }
}



/* Code from winnt32\dll\eula.c
   Need to keep in sync */
WCHAR Pid30Rpc[MAX_PID30_RPC+1];
WCHAR Pid30Site[MAX_PID30_SITE+1];
   
extern "C"
VOID GetSourceInstallType(
    OUT OPTIONAL LPDWORD InstallVariation
    )
/*++

Routine Description:

    Determines the installation type (by looking in setupp.ini in the source directory)

Arguments:

    Installvaration - one of the install variations defined in compliance.h

Returns:

    none.  sets SourceInstallType global variable.

--*/
{
    TCHAR TypeBuffer[256];
    TCHAR FilePath[MAX_PATH];
    DWORD    InstallVar = COMPLIANCE_INSTALLVAR_UNKNOWN;
    TCHAR    MPCode[6] = { -1 };

    //
    // SourcePaths is guaranteed to be valid at this point, so just use it
    //
    lstrcpy(FilePath,NativeSourcePaths[0]);

    ConcatenatePaths (FilePath, SETUPP_INI, MAX_PATH );

    GetPrivateProfileString(PID_SECTION,
                            PID_KEY,
                            TEXT(""),
                            TypeBuffer,
                            sizeof(TypeBuffer)/sizeof(TCHAR),
                            FilePath);

    if (lstrlen(TypeBuffer)==SETUP_TYPE_BUFFER_LEN) {
        if (lstrcmp(&TypeBuffer[5], OEM_INSTALL_RPC) ==  0) {
            SourceInstallType = OEMInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_OEM;
        } else if (lstrcmp(&TypeBuffer[5], SELECT_INSTALL_RPC) == 0) {
            SourceInstallType = SelectInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_SELECT;
            // Since Select also requires a PID, don't zero the PID and call.
/*	        // get/set the pid.
	        {
	            TCHAR Temp[5][ MAX_PID30_EDIT + 1 ];
                Temp[0][0] = TEXT('\0');
	            ValidatePid30(Temp[0],Temp[1],Temp[2],Temp[3],Temp[4]);
	        }*/
        } else if (lstrcmp(&TypeBuffer[5], MSDN_INSTALL_RPC) == 0) {
            SourceInstallType = RetailInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_MSDN;         
        } else {
            // defaulting
            SourceInstallType = RetailInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_CDRETAIL;
        }

        StringCchCopy(Pid30Site, ARRAYSIZE(Pid30Site), &TypeBuffer[5]);
        StringCchCopy(Pid30Rpc, 6, TypeBuffer);
        Pid30Rpc[MAX_PID30_RPC] = (TCHAR)0;
    } else {
        //
        // the retail install doesn't have an RPC code in the PID, so it's shorter in length
        //
        SourceInstallType = RetailInstall;
        InstallVar = COMPLIANCE_INSTALLVAR_CDRETAIL;
    }

    if (lstrlen(TypeBuffer) >= 5) {
        StringCchCopy(MPCode, 6, TypeBuffer);

        if ( (lstrcmp(MPCode, EVAL_MPC) == 0) || (lstrcmp(MPCode, DOTNET_EVAL_MPC) == 0)) {
            InstallVar = COMPLIANCE_INSTALLVAR_EVAL;
        } else if ((lstrcmp(MPCode, SRV_NFR_MPC) == 0) || (lstrcmp(MPCode, ASRV_NFR_MPC) == 0)) {
            InstallVar = COMPLIANCE_INSTALLVAR_NFR;
        }
    }


    if (InstallVariation){
        *InstallVariation = InstallVar;
    }

}

void MediaDataCleanUp( void) {
    
    if( hInstU) {
        FreeLibrary(hInstU);
    }
    if( hInstA) {
        FreeLibrary(hInstA);
    }
}

void ReadMediaData( void) {
    BOOL BUpgradeOnly;
    BOOL *UpgradeOnly = &BUpgradeOnly;
    COMPLIANCE_DATA TargetData;
    WCHAR Winnt32Path[MAX_PATH];

    ZeroMemory(&TargetData, sizeof(TargetData) );

    *UpgradeOnly = FALSE;
    //*NoUpgradeAllowed = TRUE;
    //*Reason = COMPLIANCEERR_UNKNOWN;
    //*SrcSku = COMPLIANCE_SKU_NONE;
    //*CurrentInstallType = COMPLIANCE_INSTALLTYPE_UNKNOWN;
    //*CurrentInstallVersion = 0;


    if ((SourceSku = DetermineSourceProduct(&SourceSkuVariation,&TargetData)) != COMPLIANCE_SKU_NONE) {
        wsprintf(DosnetPath, TEXT("%s\\dosnet.inf"), NativeSourcePaths[0]);
        wprintf(L"dosnetpath %s\n", DosnetPath);

        if (DetermineSourceVersionInfo(DosnetPath, &SourceVersion, &SourceBuildNum)) {
            switch (SourceSku) {
            case COMPLIANCE_SKU_NTW32U:
                //case COMPLIANCE_SKU_NTWU:
                //case COMPLIANCE_SKU_NTSEU:
            case COMPLIANCE_SKU_NTSU:
            case COMPLIANCE_SKU_NTSEU:
            case COMPLIANCE_SKU_NTWPU:
            case COMPLIANCE_SKU_NTSBU:
            case COMPLIANCE_SKU_NTSBSU:
                *UpgradeOnly = TRUE;
                break;
            default:
                *UpgradeOnly = FALSE;
            }

            wprintf( TEXT("SKU=%d, VAR=%d, Ver=%d, Build=%d, UpgradeOnly=%d\n"), SourceSku, SourceSkuVariation, SourceVersion, SourceBuildNum, *UpgradeOnly);
            wsprintf(Winnt32Path, TEXT("%s\\winnt32a.dll"), NativeSourcePaths[0]);
            hInstA = LoadLibraryEx( Winnt32Path, NULL, 0);
            wsprintf(Winnt32Path, TEXT("%s\\winnt32u.dll"), NativeSourcePaths[0]);
            hInstU = LoadLibraryEx( Winnt32Path, NULL, 0);
            hInst = hInstU;
            if( !hInstA || !hInstU) {
                throw Section::InvalidMedia("Failed to load winnt32");
            }
            
        } else {
            throw Section::InvalidMedia("Media1");
        }
    } else {
        throw Section::InvalidMedia("Media1");
    }
}


/*++
BOOL
GetMediaData(
    PBOOL UpgradeOnly,
    PBOOL NoUpgradeAllowed,
    PUINT SrcSku,
    PUINT CurrentInstallType,
    PUINT CurrentInstallVersion,
    PUINT Reason
    )

Routine Description:

    This routines determines if your current installation is compliant (if you are allowed to proceed with your installation).

    To do this, it retreives your current installation and determines the sku for your source installation.

    It then compares the target against the source to determine if the source sku allows an upgrade/clean install
    from your target installation.

Arguments:

    UpgradeOnly - This flag gets set to TRUE if the current SKU only allows upgrades.  This
                  lets winnt32 know that it should not allow a clean install from the current
                  media.  This get's set correctly regardless of the compliance check passing
    SrcSku      - COMPLIANCE_SKU flag indicating source sku (for error msg's)
    Reason      - COMPLIANCEERR flag indicating why compliance check failed.

Return Value:

    TRUE if the install is compliant, FALSE if it isn't allowed

{
    DWORD SourceSku;
    DWORD SourceSkuVariation;
    DWORD SourceVersion;
    DWORD SourceBuildNum;
    TCHAR DosnetPath[MAX_PATH] = {0};
    COMPLIANCE_DATA TargetData;

    ZeroMemory(&TargetData, sizeof(TargetData) );


    *UpgradeOnly = FALSE;
    *NoUpgradeAllowed = TRUE;
    *Reason = COMPLIANCEERR_UNKNOWN;
    *SrcSku = COMPLIANCE_SKU_NONE;
    *CurrentInstallType = COMPLIANCE_INSTALLTYPE_UNKNOWN;
    *CurrentInstallVersion = 0;


    if ((SourceSku = DetermineSourceProduct(&SourceSkuVariation,&TargetData)) == COMPLIANCE_SKU_NONE) {
#ifdef DBG
        OutputDebugString(TEXT("couldn't determine source sku!"));
#endif
        *Reason = COMPLIANCEERR_UNKNOWNSOURCE;
        return(FALSE);
    }

    wsprintf(DosnetPath, TEXT("%s\\dosnet.inf"), NativeSourcePaths[0]);

    if (!DetermineSourceVersionInfo(DosnetPath, &SourceVersion, &SourceBuildNum)) {
        *Reason = COMPLIANCEERR_UNKNOWNSOURCE;
        return(FALSE);
    }

    switch (SourceSku) {
        case COMPLIANCE_SKU_NTW32U:
        //case COMPLIANCE_SKU_NTWU:
        //case COMPLIANCE_SKU_NTSEU:
        case COMPLIANCE_SKU_NTSU:
        case COMPLIANCE_SKU_NTSEU:
        case COMPLIANCE_SKU_NTWPU:
        case COMPLIANCE_SKU_NTSBU:
        case COMPLIANCE_SKU_NTSBSU:
            *UpgradeOnly = TRUE;
            break;
        default:
            *UpgradeOnly = FALSE;
    }

    *SrcSku = SourceSku;

    return CheckCompliance(SourceSku, SourceSkuVariation, SourceVersion,
                            SourceBuildNum, &TargetData, Reason, NoUpgradeAllowed);
}
--*/

int
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN va_list *Args
    )
{
    TCHAR   Caption[512];
    TCHAR   Buffer[5000];
    HWND    Parent;


    if(!LoadString(hInst,CaptionStringId,Caption,sizeof(Caption)/sizeof(TCHAR))) {
        Caption[0] = 0;
    }

    FormatMessage(
        SystemMessage ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE,
        hInst,
        MessageId,
        0,
        Buffer,
        sizeof(Buffer) / sizeof(TCHAR),
        Args
        );

    //SaveTextForSMS(Buffer);

    //
    // In batch mode, we don't want to wait on the user.
    //
    /*if(BatchMode) {
        if( Style & MB_YESNO ) {
            return( IDYES );
        } else {
            return( IDOK );
        }
    }*/

    //
    // Force ourselves into the foreground manually to guarantee that we get
    // a chance to set our palette. Otherwise the message box gets the
    // palette messages and color in our background bitmap can get hosed.
    // We assume the parent is a wizard page.
    //
    if(Window && IsWindow(Window)) {
        Parent = GetParent(Window);
        if(!Parent) {
            Parent = Window;
        }
    } else {
        Parent = NULL;
    }

    SetForegroundWindow(Parent);

    //
    // If we're just checking upgrades
    // then throw this message into the compatibility list.
    // NOTE: there's no reason not ot do this on Win9x as well
    //
    /*if( CheckUpgradeOnly) {
    PCOMPATIBILITY_DATA CompData;

        CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
        if (CompData == NULL) {
            return 0;
        }

        ZeroMemory( CompData, sizeof(COMPATIBILITY_DATA) );

        CompData->Description = DupString( Buffer );
        CompData->Flags = COMPFLAG_STOPINSTALL;
        if( !CompatibilityData.Flink ) {
            InitializeListHead( &CompatibilityData );
        }

        InsertTailList( &CompatibilityData, &CompData->ListEntry );
        CompatibilityCount++;
        IncompatibilityStopsInstallation = TRUE;

        if( Style & MB_YESNO ) {
            return( IDYES );
        } else {
            return( IDOK );
        }
    }*/

    //
    // always make sure the window is visible
    //
    /*if (Window && !IsWindowVisible (Window)) {
        //
        // if this window is the wizard handle or one of its pages
        // then use a special message to restore it
        //
        if (WizardHandle && 
            (WizardHandle == Window || IsChild (WizardHandle, Window))
            ) {
            SendMessage(WizardHandle, WMX_BBTEXT, (WPARAM)FALSE, 0);
        } else {
            //
            // the window is one of the billboard windows;
            // just leave it alone or weird things may happen
            //
        }
    }*/
    return(MessageBox(Window,Buffer,Caption,Style));
}


int
MessageBoxFromMessage(
    IN HWND  Window,
    IN DWORD MessageId,
    IN BOOL  SystemMessage,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    )
{
    va_list arglist;
    int i;

    //
    // before displaying any dialog, make sure Winnt32.exe wait dialog is gone
    //
    /*if (Winnt32Dlg) {
        DestroyWindow (Winnt32Dlg);
        Winnt32Dlg = NULL;
    }
    if (WinNT32StubEvent) {
        SetEvent (WinNT32StubEvent);
        WinNT32StubEvent = NULL;
    }*/

    va_start(arglist,Style);

    i = MessageBoxFromMessageV(Window,MessageId,SystemMessage,CaptionStringId,Style,&arglist);

    va_end(arglist);

    return(i);
}


BOOL
IsCompliantMediaCheck(
    IN DWORD SourceSku,
    IN DWORD SourceSkuVariation,
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PCOMPLIANCE_DATA pcd,
    OUT PUINT Reason,
    OUT PBOOL NoUpgradeAllowed,
    PBOOL UpgradeOnly,
    PUINT SrcSku,
    PUINT CurrentInstallType,
    PUINT CurrentInstallVersion
    
    )
/*++

Routine Description:

    This routines determines if your current installation is compliant (if you are allowed to proceed with your installation).

    To do this, it retreives your current installation and determines the sku for your source installation.

    It then compares the target against the source to determine if the source sku allows an upgrade/clean install
    from your target installation.

Arguments:

    UpgradeOnly - This flag gets set to TRUE if the current SKU only allows upgrades.  This
                  lets winnt32 know that it should not allow a clean install from the current
                  media.  This get's set correctly regardless of the compliance check passing
    SrcSku      - COMPLIANCE_SKU flag indicating source sku (for error msg's)
    Reason      - COMPLIANCEERR flag indicating why compliance check failed.

Return Value:

    TRUE if the install is compliant, FALSE if it isn't allowed

--*/
{
    *UpgradeOnly = FALSE;
    *NoUpgradeAllowed = TRUE;
    *Reason = COMPLIANCEERR_UNKNOWN;
    *SrcSku = COMPLIANCE_SKU_NONE;
    *CurrentInstallType = COMPLIANCE_INSTALLTYPE_UNKNOWN;
    *CurrentInstallVersion = 0;
    *CurrentInstallType = pcd->InstallType;
    if (pcd->InstallType & COMPLIANCE_INSTALLTYPE_WIN9X) {
        *CurrentInstallVersion = pcd->BuildNumberWin9x;
    } else {
        *CurrentInstallVersion = pcd->BuildNumberNt;
    }
    switch (SourceSku) {
        case COMPLIANCE_SKU_NTW32U:
        //case COMPLIANCE_SKU_NTWU:
        //case COMPLIANCE_SKU_NTSEU:
        case COMPLIANCE_SKU_NTSU:
        case COMPLIANCE_SKU_NTSEU:
        case COMPLIANCE_SKU_NTWPU:
        case COMPLIANCE_SKU_NTSBU:
        case COMPLIANCE_SKU_NTSBSU:
            *UpgradeOnly = TRUE;
            break;
        default:
            *UpgradeOnly = FALSE;
    }

    *SrcSku = SourceSku;

    /*if( ISNT() && pcd->MinimumVersion == 400 && pcd->InstallServicePack < 500) {
        *Reason = COMPLIANCEERR_SERVICEPACK5;
        *NoUpgradeAllowed = TRUE;
        return(FALSE);
    }*/

    return CheckCompliance(SourceSku, SourceSkuVariation, SourceVersion,
                            SourceBuildNum, pcd, Reason, NoUpgradeAllowed);
}

BOOL
GetComplianceIds(
    DWORD SourceSku,
    DWORD DestinationType,
    DWORD DestinationVersion,
    PDWORD pSourceId,
    PDWORD pDestId
    )
{

    BOOL bError = FALSE;

    switch (SourceSku) {
        case COMPLIANCE_SKU_NTSDTC:
            *pSourceId = MSG_TYPE_NTSDTC51;
            break;
        case COMPLIANCE_SKU_NTSFULL:
        case COMPLIANCE_SKU_NTSU:
            *pSourceId = MSG_TYPE_NTS51;
            break;
        case COMPLIANCE_SKU_NTSEFULL:
        case COMPLIANCE_SKU_NTSEU:
            *pSourceId = MSG_TYPE_NTAS51;
            break;
        case COMPLIANCE_SKU_NTWFULL:
        case COMPLIANCE_SKU_NTW32U:
            *pSourceId = MSG_TYPE_NTPRO51;
            break;
        case COMPLIANCE_SKU_NTWPFULL:
        case COMPLIANCE_SKU_NTWPU:
            *pSourceId = MSG_TYPE_NTPER51;
            break;
        case COMPLIANCE_SKU_NTSB:
        case COMPLIANCE_SKU_NTSBU:
            *pSourceId = MSG_TYPE_NTBLA51;
            break;
        default:
            bError = TRUE;
    };

    switch (DestinationType) {
        case COMPLIANCE_INSTALLTYPE_WIN31:
            *pDestId = MSG_TYPE_WIN31;
            break;
        case COMPLIANCE_INSTALLTYPE_WIN9X:
            switch (OsVersionNumber) {
                case 410:
                    *pDestId = MSG_TYPE_WIN98;
                    break;
                case 490:
                    *pDestId = MSG_TYPE_WINME;
                    break;
                default:
                    *pDestId = MSG_TYPE_WIN95;
                    break;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTW:
            if (DestinationVersion > 1381) {
                if (DestinationVersion < 2031) {
                    *pDestId = MSG_TYPE_NTPROPRE;
                } else if (DestinationVersion <= 2195) {
                    *pDestId = MSG_TYPE_NTPRO;
                } else {
                    *pDestId = MSG_TYPE_NTPRO51;
                }
            } else {
                *pDestId = MSG_TYPE_NTW;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTS:
            if (DestinationVersion > 1381) {
                if (DestinationVersion < 2031) {
                    *pDestId = MSG_TYPE_NTSPRE;
                } else if (DestinationVersion <= 2195) {
                    *pDestId = MSG_TYPE_NTS2;
                } else {
                    *pDestId = MSG_TYPE_NTS51;
                }
            } else {
                *pDestId = MSG_TYPE_NTS;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTSE:
            if (DestinationVersion > 1381) {
                if (DestinationVersion < 2031) {
                    *pDestId = MSG_TYPE_NTASPRE;
                } else if (DestinationVersion <= 2195) {
                    *pDestId = MSG_TYPE_NTAS;
                } else {
                    *pDestId = MSG_TYPE_NTAS51;
                }
            } else {
                *pDestId = MSG_TYPE_NTSE;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTSTSE:
            if (DestinationVersion < 1381) {
                *pDestId = MSG_TYPE_NTSCITRIX;
            } else {
                *pDestId = MSG_TYPE_NTSTSE;
            }
            break;

        case COMPLIANCE_INSTALLTYPE_NTSDTC:
            if (DestinationVersion <= 2195) {
                *pDestId = MSG_TYPE_NTSDTC;
            } else {
                *pDestId = MSG_TYPE_NTSDTC51;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTWP:
            if (DestinationVersion <= 2195) {
                bError = TRUE;
            } else {
                *pDestId = MSG_TYPE_NTPER51;
            }
            break;
        case COMPLIANCE_INSTALLTYPE_NTSB:
            if (DestinationVersion <= 2195) {
                bError = TRUE;
            } else {
                *pDestId = MSG_TYPE_NTBLA51;
            }
            break;
        default:
            bError = TRUE;

    };

    return (!bError);

}

BOOL UITest(
    IN DWORD SourceSku,
    IN DWORD SourceSkuVariation,
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PCOMPLIANCE_DATA pcd,
    OUT PUINT Reason,
    OUT PBOOL NoUpgradeAllowed
    )
{
    BOOL NoCompliance = FALSE;
    
    bool b;
    LONG l;
    static BOOL WantToUpgrade; // need to remember if "Upgrade" is in the listbox
    UINT srcsku,desttype,destversion;
    TCHAR reasontxt[200];
    PTSTR p;
    TCHAR buffer[MAX_PATH];
    TCHAR win9xInf[MAX_PATH];
    BOOL    CompliantInstallation = FALSE;
    BOOLEAN CleanInstall = FALSE;
    BOOL Upgrade = TRUE;
    BOOL UpgradeOnly = FALSE;
    

    *NoUpgradeAllowed = FALSE;

    UINT skuerr[] = {
        0,               // COMPLIANCE_SKU_NONE
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTWFULL
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTW32U
        0,               // COMPLIANCE_SKU_NTWU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSEFULL
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSFULL
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTSEU
        0,               // COMPLIANCE_SKU_NTSSEU
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTSU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSDTC
        0,               // COMPLIANCE_SKU_NTSDTCU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTWPFULL
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTWPU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSB
        MSG_SKU_UPGRADE, // COMPLIANCE_SKU_NTSBU
        MSG_SKU_FULL,    // COMPLIANCE_SKU_NTSBS
        MSG_SKU_UPGRADE  // COMPLIANCE_SKU_NTSBSU
    } ;


    UINT skureason[] = {
        0, //MSG_SKU_REASON_NONE;
        MSG_SKU_VERSION, //COMPLIANCEERR_VERSION;
        MSG_SKU_SUITE, //COMPLIANCEERR_SUITE;
        MSG_SKU_TYPE, // COMPLIANCEERR_TYPE;
        MSG_SKU_VARIATION, //COMPLIANCEERR_VARIATION;
        MSG_SKU_UNKNOWNTARGET, //COMPLIANCEERR_UNKNOWNTARGET
        MSG_SKU_UNKNOWNSOURCE, //COMPLIANCEERR_UNKNOWNSOURCE
        MSG_CANT_UPGRADE_FROM_BUILD_NUMBER //COMPLIANCEERR_VERSION (Old on New Builds)
    } ;

    //
    // We're about to check if upgrades are allowed.
    // Remember if the user wants an upgrade (this would be via an unattend
    // mechanism).
    //

    if( pcd->InstallType < 4) {
        // win9x
        hInst = hInstA;
    } else {
        hInst = hInstU;
    }

    WantToUpgrade = Upgrade;

    if (!NoCompliance) {
        TCHAR SourceName[200];
        DWORD srcid, destid;
        TCHAR DestName[200];

        OsVersionNumber = pcd->MinimumVersion;
        CompliantInstallation = IsCompliantMediaCheck(
                    SourceSku,
                    SourceSkuVariation,
                    SourceVersion,
                    SourceBuildNum,
                    pcd,
                    Reason,
                    NoUpgradeAllowed,
                    &UpgradeOnly,
                    &srcsku,
                    &desttype,
                    &destversion
                    );

        if( bDebug) {
            wprintf(TEXT("InstallType =%d\n")
                    TEXT("InstallVariation =%d\n")
                    TEXT("InstallSuite =%d\n")
                    TEXT("MinimumVersion =%d\n")
                    TEXT("RequiresValidation =%d\n")
                    TEXT("MaximumKnownVersionNt =%d\n")
                    TEXT("BuildNumberNt =%d\n")
                    TEXT("BuildNumberWin9x =%d\n")
                    TEXT("InstallServicePack =%d\n")
                    TEXT("CompliantInstallation=%d\n")
                    TEXT("UpgradeOnly=%d\n")
                    TEXT("noupgradeallowed=%d\n")
                    TEXT("srcsku=%d\n")
                    TEXT("desttype=%d\n")
                    TEXT("destversion=%d\n")
                    TEXT("reason=%d\n"),
                    pcd->InstallType,
                    pcd->InstallVariation,
                    pcd->InstallSuite,
                    pcd->MinimumVersion,
                    pcd->RequiresValidation,
                    pcd->MaximumKnownVersionNt,
                    pcd->BuildNumberNt,
                    pcd->BuildNumberWin9x,
                    pcd->InstallServicePack,
                    CompliantInstallation,
                    UpgradeOnly,
                    *NoUpgradeAllowed,
                    srcsku,
                    desttype,
                    destversion,
                    *Reason);
        }


        //DebugLog(Winnt32LogInformation, TEXT("Upgrade only = %1"), 0, UpgradeOnly?TEXT("Yes"):TEXT("No"));
        //DebugLog(Winnt32LogInformation, TEXT("Upgrade allowed = %1"), 0, noupgradeallowed?TEXT("No"):TEXT("Yes"));
        if (GetComplianceIds(
                srcsku,
                desttype,
                destversion,
                &srcid,
                &destid))
        {
              FormatMessage(
                  FORMAT_MESSAGE_FROM_HMODULE,
                  hInst,
                  srcid,
                  0,
                  SourceName,
                  sizeof(SourceName) / sizeof(TCHAR),
                  NULL
                  );
            //DebugLog(Winnt32LogInformation, TEXT("Source SKU = %1!ld!"), 0, srcsku);
            //DebugLog(Winnt32LogInformation, TEXT("Source SKU = %1"), 0, SourceName);

              FormatMessage(
                  FORMAT_MESSAGE_FROM_HMODULE,
                  hInst,
                  destid,
                  0,
                  DestName,
                  sizeof(DestName) / sizeof(TCHAR),
                  NULL
                  );
            //DebugLog(Winnt32LogInformation, TEXT("Current installed SKU = %1!ld!"), 0, desttype);
            //DebugLog(Winnt32LogInformation, TEXT("Current installed SKU = %1"), 0, DestName);
        }
        else
        {
            //DebugLog(Winnt32LogInformation, TEXT("Source SKU = %1!ld!"), 0, srcsku);
            //DebugLog(Winnt32LogInformation, TEXT("Current installed SKU = %1!ld!"), 0, desttype);
        }
        //DebugLog(Winnt32LogInformation, TEXT("Current Version = %1!ld!"), 0, destversion);
        if (!CompliantInstallation)
        {
            //DebugLog(Winnt32LogInformation, TEXT("Reason = %1!ld!"), 0, reason);
        }
        //
        // Do only clean installs in WinPE mode & don't
        // shut down automatically once Winnt32.exe completes
        //
        /*if (IsWinPEMode()) {
            noupgradeallowed = TRUE;
            AutomaticallyShutDown = FALSE;
        }*/

        CleanInstall = CompliantInstallation ? TRUE : FALSE;

        if (!CompliantInstallation) {
            //
            // if they aren't compliant, we won't let them upgrade.
            // we also won't let them do a clean install from winnt32
            //


            switch(*Reason) {
                case COMPLIANCEERR_UNKNOWNTARGET:
                    MessageBoxFromMessage(
                          GetBBhwnd(),
                          MSG_SKU_UNKNOWNTARGET,
                          FALSE,
                          AppTitleStringId,
                          MB_OK | MB_ICONERROR | MB_TASKMODAL
                          );
                    Cancelled = TRUE;
                    //PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    goto eh;

                case COMPLIANCEERR_UNKNOWNSOURCE:
                    MessageBoxFromMessage(
                          GetBBhwnd(),
                          MSG_SKU_UNKNOWNSOURCE,
                          FALSE,
                          AppTitleStringId,
                          MB_OK | MB_ICONERROR | MB_TASKMODAL
                          );
                    Cancelled = TRUE;
                    //PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    goto eh;
                case COMPLIANCEERR_SERVICEPACK5:
                    MessageBoxFromMessage(
                          GetBBhwnd(),
                          MSG_SKU_SERVICEPACK,
                          FALSE,
                          AppTitleStringId,
                          MB_OK | MB_ICONWARNING | MB_TASKMODAL
                          );
                    Cancelled = TRUE;
                    //PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    goto eh;

                default:
                    break;
            };

            // If we add this part to the message, it sound bad and is not needed.
            if (*Reason == COMPLIANCEERR_VERSION)
            {
                reasontxt[0] = TEXT('\0');
            }
            else
            {
                FormatMessage(
                    FORMAT_MESSAGE_FROM_HMODULE,
                    hInst,
                    skureason[*Reason],
                    0,
                    reasontxt,
                    sizeof(reasontxt) / sizeof(TCHAR),
                    NULL
                    );
            }

            //
            // don't warn again if winnt32 just restarted
            //
            //if (!Winnt32Restarted ()) {
                MessageBoxFromMessage(
                                      GetBBhwnd(),
                                      skuerr[srcsku],
                                      FALSE,
                                      AppTitleStringId,
                                      MB_OK | MB_ICONERROR | MB_TASKMODAL,
                                      reasontxt
                                      );
            //}

            if (UpgradeOnly) {
                Cancelled = TRUE;
                //PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                goto eh;
            }
            Upgrade = FALSE;
        } else if (Upgrade && *NoUpgradeAllowed) {
            Upgrade = FALSE;
            /*if (!UnattendedOperation && !BuildCmdcons && !IsWinPEMode() &&
                //
                // don't warn again if winnt32 just restarted
                //
                !Winnt32Restarted ()) */{

                //
                // put up an error message for the user.
                //

                if (GetComplianceIds(
                        srcsku,
                        desttype,
                        destversion,
                        &srcid,
                        &destid)) {

                    if (srcid != destid) {
#ifdef UNICODE
                        if( pcd->InstallType >= 4) 
                        {
                              //
                              // for Win9x upgrades, the message is already displayed
                              // by the upgrade module; no need to repeat it here
                              //
                              FormatMessage(
                                  FORMAT_MESSAGE_FROM_HMODULE,
                                  hInst,
                                  srcid,
                                  0,
                                  SourceName,
                                  sizeof(SourceName) / sizeof(TCHAR),
                                  NULL
                                  );
    
                              FormatMessage(
                                  FORMAT_MESSAGE_FROM_HMODULE,
                                  hInst,
                                  destid,
                                  0,
                                  DestName,
                                  sizeof(DestName) / sizeof(TCHAR),
                                  NULL
                                  );
    
                            MessageBoxFromMessage(
                                        GetBBhwnd(),
                                        MSG_NO_UPGRADE_ALLOWED,
                                        FALSE,
                                        AppTitleStringId,
                                        MB_OK | MB_ICONWARNING | MB_TASKMODAL,
                                        DestName,
                                        SourceName
                                        );
                        }
#endif
                    } else {

                        MessageBoxFromMessage(
                              GetBBhwnd(),
                              MSG_CANT_UPGRADE_FROM_BUILD_NUMBER,
                              FALSE,
                              AppTitleStringId,
                              MB_OK | MB_ICONWARNING | MB_TASKMODAL
                              );
                    }
                } else {
                    MessageBoxFromMessage(
                                  GetBBhwnd(),
                                  MSG_NO_UPGRADE_ALLOWED_GENERIC,
                                  FALSE,
                                  AppTitleStringId,
                                  MB_OKCANCEL | MB_ICONWARNING | MB_TASKMODAL
                                  );
                }
            }
        }
    } else {
            CleanInstall = !UpgradeOnly;
    }

    //
    // Set install type combo box.
    //
    /*if (!UpgradeSupport.DllModuleHandle) {
        MYASSERT(!Upgrade);
    }*/

    //
    // Upgrade defaults to TRUE.  If it's set to FALSE, then assume
    // something has gone wrong, so disable the user's ability to
    // upgrade.
    //


    if (UpgradeOnly && !Upgrade) {
        //
        // in this case upgrade isn't possible, but neither is clean install
        // post an error message and bail.
        //

        MessageBoxFromMessage(
                              GetBBhwnd(),
                              MSG_NO_UPGRADE_OR_CLEAN,
                              FALSE,
                              AppTitleStringId,
                              MB_OK | MB_ICONERROR | MB_TASKMODAL
                              );
        Cancelled = TRUE;
        //PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
        //break;

    } else if (!Upgrade && WantToUpgrade && 0 && 1) {
        //
        // we can't do an upgrade and they wanted unattended upgrade.
        // let the user know and then bail out
        //
        //
        // don't warn again if winnt32 just restarted
        //
        /*if (!Winnt32Restarted ()) */{
            TCHAR SourceName[200];
            DWORD srcid, destid;
            TCHAR DestName[200];

            if (GetComplianceIds(
                    srcsku,
                    desttype,
                    destversion,
                    &srcid,
                    &destid) && (srcid != destid)) {
                FormatMessage(
                    FORMAT_MESSAGE_FROM_HMODULE,
                    hInst,
                    srcid,
                    0,
                    SourceName,
                    sizeof(SourceName) / sizeof(TCHAR),
                    NULL
                    );

                FormatMessage(
                    FORMAT_MESSAGE_FROM_HMODULE,
                    hInst,
                    destid,
                    0,
                    DestName,
                    sizeof(DestName) / sizeof(TCHAR),
                    NULL
                    );


                MessageBoxFromMessage(
                              GetBBhwnd(),
                              MSG_NO_UNATTENDED_UPGRADE_SPECIFIC,
                              FALSE,
                              AppTitleStringId,
                              MB_OK | MB_ICONWARNING | MB_TASKMODAL,
                              DestName,
                              SourceName
                              );
            } else {
                MessageBoxFromMessage(
                                  GetBBhwnd(),
                                  MSG_NO_UNATTENDED_UPGRADE,
                                  FALSE,
                                  AppTitleStringId,
                                  MB_OK | MB_ICONERROR | MB_TASKMODAL
                                  );
            }
        }

        //
        // let setup go if they did /CheckUpgradeOnly
        // so they can see the message in the report
        //
        /*if (!CheckUpgradeOnly) {
            Cancelled = TRUE;
            //PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
            break;
        }*/
    }

eh:
    
    return CompliantInstallation;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\pidinit\crcmodel.c ===
/****************************************************************************/
/*							   Start of crcmodel.c							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the implementation (.c) file for the reference 	*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Implementation Notes 													*/
/* -------------------- 													*/
/* To avoid inconsistencies, the specification of each function is not		*/
/* echoed here. See the header file for a description of these functions.	*/
/* This package is light on checking because I want to keep it short and	*/
/* simple and portable (i.e. it would be too messy to distribute my entire	*/
/* C culture (e.g. assertions package) with this package.					*/
/*																			*/
/****************************************************************************/

#include "crcmodel.h"

/****************************************************************************/
/* The following definitions make the code more readable.					*/

#define BITMASK(X) (1L << (X))
#define MASK32 0xFFFFFFFFL
#define LOCAL static

/****************************************************************************/

/* Returns the value v with the bottom b [0,32] bits reflected. */
/* Example: reflect(0x3e23L,3) == 0x3e26						*/

LOCAL ulong reflect(
    ulong v,
    int   b)
{
 int   i;
 ulong t = v;
 for (i=0; i<b; i++)
   {
	if (t & 1L)
	   v|=	BITMASK((b-1)-i);
	else
	   v&= ~BITMASK((b-1)-i);

	t>>=1;

   }
 return v;
}

/****************************************************************************/

/* Returns a longword whose value is (2^p_cm->cm_width)-1.	   */
/* The trick is to do this portably (e.g. without doing <<32). */

LOCAL ulong widmask(p_cm_t p_cm)
{
 return (((1L<<(p_cm->cm_width-1))-1L)<<1)|1L;
}

/****************************************************************************/

void cm_ini (p_cm_t p_cm)
{
 p_cm->cm_reg = p_cm->cm_init;
}

/****************************************************************************/

void cm_nxt(p_cm_t p_cm, int ch)
{
 int   i;
 ulong uch	= (ulong) ch;
 ulong topbit = BITMASK(p_cm->cm_width-1);

 if (p_cm->cm_refin) uch = reflect(uch,8);
 p_cm->cm_reg ^= (uch << (p_cm->cm_width-8));
 for (i=0; i<8; i++)
   {
	if (p_cm->cm_reg & topbit)
	   p_cm->cm_reg = (p_cm->cm_reg << 1) ^ p_cm->cm_poly;
	else
	   p_cm->cm_reg <<= 1;
	p_cm->cm_reg &= widmask(p_cm);
   }
}

/****************************************************************************/

void cm_blk(
p_cm_t	 p_cm,
p_ubyte_ blk_adr,
ulong	 blk_len)
{
 while (blk_len--) cm_nxt(p_cm,*blk_adr++);
}

/****************************************************************************/

ulong cm_crc(p_cm_t p_cm)
{
 if (p_cm->cm_refot)
	return p_cm->cm_xorot ^ reflect(p_cm->cm_reg,p_cm->cm_width);
 else
	return p_cm->cm_xorot ^ p_cm->cm_reg;
}

/****************************************************************************/

ulong cm_tab(p_cm_t p_cm, int index)
{
 int   i;
 ulong r;
 ulong topbit = BITMASK(p_cm->cm_width-1);
 ulong inbyte = (ulong) index;

 if (p_cm->cm_refin) inbyte = reflect(inbyte,8);
 r = inbyte << (p_cm->cm_width-8);
 for (i=0; i<8; i++)
	if (r & topbit)
	   r = (r << 1) ^ p_cm->cm_poly;
	else
	   r<<=1;
 if (p_cm->cm_refin) r = reflect(r,p_cm->cm_width);
 return r & widmask(p_cm);
}

/****************************************************************************/
/*							   End of crcmodel.c							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\pidinit\crcmodel.h ===
/****************************************************************************/
/*							   Start of crcmodel.h							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the header (.h) file for the reference 			*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* How to Use This Package													*/
/* -----------------------													*/
/* Step 1: Declare a variable of type cm_t. Declare another variable		*/
/*		   (p_cm say) of type p_cm_t and initialize it to point to the first*/
/*		   variable (e.g. p_cm_t p_cm = &cm_t). 							*/
/*																			*/
/* Step 2: Assign values to the parameter fields of the structure.			*/
/*		   If you don't know what to assign, see the document cited earlier.*/
/*		   For example: 													*/
/*			  p_cm->cm_width = 16;											*/
/*			  p_cm->cm_poly  = 0x8005L; 									*/
/*			  p_cm->cm_init  = 0L;											*/
/*			  p_cm->cm_refin = TRUE;										*/
/*			  p_cm->cm_refot = TRUE;										*/
/*			  p_cm->cm_xorot = 0L;											*/
/*		   Note: Poly is specified without its top bit (18005 becomes 8005).*/
/*		   Note: Width is one bit less than the raw poly width. 			*/
/*																			*/
/* Step 3: Initialize the instance with a call cm_ini(p_cm);				*/
/*																			*/
/* Step 4: Process zero or more message bytes by placing zero or more		*/
/*		   successive calls to cm_nxt. Example: cm_nxt(p_cm,ch);			*/
/*																			*/
/* Step 5: Extract the CRC value at any time by calling crc = cm_crc(p_cm); */
/*		   If the CRC is a 16-bit value, it will be in the bottom 16 bits.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Design Notes 															*/
/* ------------ 															*/
/* PORTABILITY: This package has been coded very conservatively so that 	*/
/* it will run on as many machines as possible. For example, all external	*/
/* identifiers have been restricted to 6 characters and all internal ones to*/
/* 8 characters. The prefix cm (for Crc Model) is used as an attempt to 	*/
/* avoid namespace collisions. This package is endian independent.			*/
/*																			*/
/* EFFICIENCY: This package (and its interface) is not designed for 		*/
/* speed. The purpose of this package is to act as a well-defined reference */
/* model for the specification of CRC algorithms. If you want speed, cook up*/
/* a specific table-driven implementation as described in the document cited*/
/* above. This package is designed for validation only; if you have found or*/
/* implemented a CRC algorithm and wish to describe it as a set of para-	*/
/* meters to the Rocksoft^tm Model CRC Algorithm, your CRC algorithm imple- */
/* mentation should behave identically to this package under those para-	*/
/* meters.																	*/
/*																			*/
/****************************************************************************/

/* The following #ifndef encloses this entire */
/* header file, rendering it idempotent.	 */

#ifndef CM_DONE
#define CM_DONE

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************/
/* The following definitions are extracted from my style header file which	*/
/* would be cumbersome to distribute with this package. The DONE_STYLE is	*/
/* the idempotence symbol used in my style header file. 					*/

#ifndef DONE_STYLE

typedef unsigned long	ulong;
typedef unsigned		ubool;
typedef unsigned char * p_ubyte_;

#ifndef TRUE
#define FALSE 0
#define TRUE  1
#endif

/* Uncomment this definition if you don't have void. */
/* typedef int void; */

#endif

/****************************************************************************/
/* CRC Model Abstract Type													*/
/* -----------------------													*/
/* The following type stores the context of an executing instance of the	*/
/* model algorithm. Most of the fields are model parameters which must be	*/
/* set before the first initializing call to cm_ini.						*/

typedef struct
  {
   int	 cm_width;	 /* Parameter: Width in bits [8,32].	   */
   ulong cm_poly;	 /* Parameter: The algorithm's polynomial. */
   ulong cm_init;	 /* Parameter: Initial register value.	   */
   ubool cm_refin;	 /* Parameter: Reflect input bytes? 	   */
   ubool cm_refot;	 /* Parameter: Reflect output CRC?		   */
   ulong cm_xorot;	 /* Parameter: XOR this to output CRC.	   */

   ulong cm_reg;	 /* Context: Context during execution.	   */
  } cm_t;
typedef cm_t *p_cm_t;

/****************************************************************************/
/* Functions That Implement The Model										*/
/* ----------------------------------										*/
/* The following functions animate the cm_t abstraction.					*/

void cm_ini(p_cm_t p_cm);

/* Initializes the argument CRC model instance. 		 */
/* All parameter fields must be set before calling this. */

void cm_nxt(p_cm_t p_cm, int ch);

/* Processes a single message byte [0,255]. */

void cm_blk(p_cm_t p_cm, p_ubyte_ blk_adr, ulong blk_len);

/* Processes a block of message bytes. */

ulong cm_crc(p_cm_t p_cm);

/* Returns the CRC value for the message bytes processed so far. */

/****************************************************************************/
/* Functions For Table Calculation											*/
/* -------------------------------											*/
/* The following function can be used to calculate a CRC lookup table.		*/
/* It can also be used at run-time to create or check static tables.		*/

ulong cm_tab(p_cm_t p_cm, int index);

/* Returns the i'th entry for the lookup table for the specified algorithm. */
/* The function examines the fields cm_width, cm_poly, cm_refin, and the	*/
/* argument table index in the range [0,255] and returns the table entry in */
/* the bottom cm_width bytes of the return value. */

/****************************************************************************/
/* End of the header file idempotence #ifndef								*/

#ifdef __cplusplus
}
#endif

#endif

/****************************************************************************/
/*							   End of crcmodel.h							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\pidinit\crc-32.h ===
/*++ 

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    crc-32.h

Abstract:

--*/
#include "crcmodel.h"

DWORD WINAPI CRC_32(LPBYTE pb, DWORD cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\pidinit\crc-32.cpp ===
/*++ 

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    crc-32.cpp

Abstract:

--*/

#include <windows.h>
#include "crc-32.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\strutil.h ===
#include <vector>
#include <cstdlib>

using namespace std;

//
// utility function to tokenize a given line based on the delimiters
// specified
//
template< class T >
unsigned Tokenize(const T &szInput, const T & szDelimiters, vector<T>& tokens) {
  unsigned uDelimiterCount = 0;

	tokens.clear();

	if(!szInput.empty()){
		if(!szDelimiters.empty()){
			T::const_iterator	inputIter = szInput.begin();
			T::const_iterator	copyIter = szInput.begin();

			while(inputIter != szInput.end()){			
				if(szDelimiters.find(*inputIter) != string::npos){
          if (copyIter < inputIter) {
						tokens.push_back(szInput.substr(copyIter - szInput.begin(), 
                                  inputIter - copyIter));
          }

          uDelimiterCount++;
          inputIter++;
          copyIter = inputIter;
          continue;
				}

			  inputIter++;
			}

      if(copyIter != inputIter){
				tokens.push_back(szInput.substr(copyIter - szInput.begin(), 
                              inputIter - szInput.begin()));
      }
		}
		else
			tokens.push_back(szInput);
	}

  return uDelimiterCount;
}

unsigned long toUnsignedLong(const string& str) {
  int radix = 10; //decimal

  if ((str.find("0x") != str.npos) || (str.find("0X") != str.npos))
    radix = 16; // hex decimal

  return ::strtoul(str.c_str(), 0, radix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\section.cpp ===
#pragma warning( disable:4786 )

#include <section.h>
#include <cstdlib>
#include <strutil.h>
#include <compfile.h>
#include <iomanip>
#include <media.h>

extern "C" {
    DWORD SourceInstallType;
    CHAR  *SourcePaths[] = { 0};
    DWORD OsVersion;
    VOID GetSourceInstallType(LPDWORD InstallVariation);
};

//
// ValueSection methods
//

void ValueSection::parse() {
    vector<string>::const_iterator  iter = lines().begin();

    while (iter != lines().end()) {
        vector<string>  tokens;

        Tokenize((const string&)(*iter), string(" ="), tokens);

        if (tokens.size() != 2)
            throw InvalidSectionFormat(name());

        m_values[tokens[0]] = toUnsignedLong(tokens[1].c_str());
        iter++;
    }
}

//
// TestSection methods
//
void TestSection::parse() {
    vector<string>::const_iterator  iter = lines().begin();

    while (iter != lines().end()) {
        m_testCases.push_back(testCaseFactory().create(*this, *iter));
        iter++;
    }
}

TestSection& TestSection::operator=(const TestSection& rhs){
    cerr << "Copying section " << endl;
    *(Section *)this = (Section&)rhs;

    m_testCases.clear();

    vector<TestCase*>::const_iterator iter = rhs.m_testCases.begin();

    while (iter != rhs.m_testCases.end()) {
        m_testCases.push_back(testCaseFactory().create(**iter));
        iter++;
    }

    return *this;
}

void TestSection::executeTestCases(ostream& os) {
    vector<TestCase*>::iterator iter = m_testCases.begin();

    bool allpassed = true;

    os << endl << endl;
    if( iter != m_testCases.end() && (*iter)->mediamatched()) {
        os << "Media Matched:";
    }

    os << "Executing test cases for {" << name() << "}" 
    << endl << endl;

    
    while (iter != m_testCases.end()) {
        if( bVerbose) {
        os << dec << setw(3) << setfill('0') 
            << (iter - m_testCases.begin() + 1) << ": TestCase : [" 
            << (*iter)->line() << "]" << " " << endl;
        }
        (*iter)->execute(os);

        if (!(*iter)->passed()) {
            if( !bVerbose) {
                os << dec << setw(3) << setfill('0') 
                << (iter - m_testCases.begin() + 1) << ": TestCase : [" 
                << (*iter)->line() << "]" << " FAILED" << endl;
            }
            (*iter)->dump(os);
            allpassed = false;
        }

        iter++;
    }

    if (allpassed)
        os << "all the test cases passed for this section" << endl;
}


//
// ComplianceTestCase methods
//
void ComplianceTestCase::parse() {
    vector<string>  tokens;

    Tokenize(line(), string("#=,"), tokens);

    if (tokens.size() == 7) {
        m_expectedResult = ((tokens[6][0] == 'y') || (tokens[6][0] == 'Y'));
        sourceDetails();
        installationDetails(tokens);
    } else {
        throw InvalidFormat(line(), section().name());
    }
}

void ComplianceTestCase::sourceDetails() {
    vector<string>  tokens;
    char *pstr;

    Tokenize(section().name(), string("[#]"), tokens);

    if ((tokens.size() == 7) && (tokens[0] == "test")) {
        m_sourceSKU = section().file().sourcesSection().value(tokens[1] + "#" + tokens[6]);
        m_sourceVAR = section().file().varsSection().value(tokens[5]);
        m_sourceVer = atol(tokens[2].c_str()) * 100; // (major * 100 + minor)
        pstr = strchr( tokens[2].c_str(), '.');
        if( pstr != NULL && *(pstr+1) != NULL) {
            m_sourceVer += atol( pstr+1);
        }
        m_sourceBuild = atol(tokens[3].c_str());

        //wprintf( TEXT("SKU=%d, VAR=%d, Ver=%d, Build=%d\n"), m_sourceSKU, m_sourceVAR, m_sourceVer, m_sourceBuild);
        if( m_sourceSKU == SourceSku &&
            m_sourceVAR == SourceSkuVariation &&
            m_sourceVer == SourceVersion &&
            m_sourceBuild == SourceBuildNum) {
            m_mediamatched = TRUE;
            //printf("Media matched\n");
        } else {
            m_mediamatched = FALSE;
        }
    } else {
        throw Section::InvalidSectionName(section().name());
    }
}

void ComplianceTestCase::installationDetails(const vector<string>& tokens) {
    int length,i;
    int version;

    if ((tokens.size() == 7)) {
        m_errExpected = section().file().errorsSection().value(tokens[5]);
        m_cd.InstallType = section().file().typesSection().value(tokens[0]);
        m_cd.InstallVariation = section().file().varsSection().value(tokens[4]);
        m_cd.InstallSuite = section().file().suitesSection().value(tokens[3]);
        m_cd.RequiresValidation = (section().name().find("#ccp") != section().name().npos);
        //m_cd.MinimumVersion = ::strtod(tokens[1].c_str()) * 100;
        length = tokens[1].size();
        i = 0;
        version = 0;
        while (i < length) {
            if ( tokens[1][i] != '.') {
                version = version*10 + tokens[1][i] - '0';
            } else {
                if (i == (length-3)) { // two decimal places
                    version = version*100+ (tokens[1][i+1] - '0')*10 + (tokens[1][i+2]-'0');
                } else {
                    version = version*100+ (tokens[1][i+1] - '0');
                }
                i = length;
            }
            i++;
        }
        m_cd.MinimumVersion = version;
        // cerr << "minimum version" << m_cd.MinimumVersion << endl;
        m_cd.MaximumKnownVersionNt = 510;
        if ( m_cd.InstallType & COMPLIANCE_INSTALLTYPE_WIN9X) {
            m_cd.BuildNumberWin9x = toUnsignedLong(tokens[2].c_str());
            m_cd.BuildNumberNt = 0;
        } else {
            m_cd.BuildNumberNt = toUnsignedLong(tokens[2].c_str());
            m_cd.BuildNumberWin9x = 0;
        }
    } else
        throw Section::InvalidSectionName(section().name());
}

bool ComplianceTestCase::passed() {
    bool  result = false;

    if (m_errExpected) {
        // negative testcase
        if (m_cd.RequiresValidation) {
            // should have failed with expected error code & upgrade flag
            result = (!m_passed && (m_errExpected == m_reason) &&
                      (m_allowUpgrade == m_expectedResult));
        } else {
            // should pass with expected error code & upgrade flag			
            // target errors are special case
            result = ((m_reason != 0x5) ? m_passed : !m_passed) && (m_errExpected == m_reason) &&
                     (m_allowUpgrade == m_expectedResult);
        }                               
    } else {
        result = (m_passed && (m_allowUpgrade == m_expectedResult) && (m_errExpected == m_reason));
    }    

    return result;
}

void ComplianceTestCase::execute(ostream &os) {
    m_reason = 0;
    m_noUpgrade = true;

    if( bUITest) {
        m_passed = UITest( m_sourceSKU, m_sourceVAR, m_sourceVer,
                               m_sourceBuild, &m_cd,  &m_reason, &m_noUpgrade) ? true : false;
    
    }else {
        m_passed = CheckCompliance(m_sourceSKU, m_sourceVAR, m_sourceVer,
                               m_sourceBuild, &m_cd,  &m_reason, &m_noUpgrade) ? true : false;

    }
    m_allowUpgrade = (m_noUpgrade) ? false : true;  
}

void ComplianceTestCase::dump(ostream &os) {
    // (Error expected or not, The error that was expected in hex, Upgrade allowed)
    os << "Expected result : (error="  << hex << m_errExpected << ",upgradeallowed="
    << ((m_expectedResult) ? "true" : "false") << ")" << endl;

    // (Compliant or not(can we do clean install?), Reason in hex, Upgrade allowed)
    os << "Actual result   : (compliant=" << (m_passed  ? "true" : "false")
    << ",error=" << hex << m_reason << ",upgradeallowed="
    << ((m_allowUpgrade) ? "true" : "false") << ")" << endl; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\winnt32.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <winioctl.h>
#include <setupbat.h>
#include <setupapi.h>
#include <winnls.h>
#include <shlwapi.h>
#include <winspool.h>
#include <wininet.h>

#include <tchar.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>

#include <winnt32p.h>
#include <pidgen.h>
#include <locale.h>
#include <ntverp.h>
#include <patchapi.h>
#include <cfgmgr32.h>
#include <regstr.h>
#include <imagehlp.h>


#include "resource.h"

#include "util.h"
#include "hwdb.h"
#include "wsdu.h"
#include "dynupdt.h"
#include "diamond.h"

//
// moved to precomp.h
//
//#include "msg.h"
#include "helpids.h"

#include "comp.h"
#include "compliance.h"

#include "mgdlllib.h"


#ifdef PRERELEASE
#define TRY
#define EXCEPT(e)   goto __skip;
#define _exception_code() 0
#define END_EXCEPT  __skip:;
#else
#define TRY         __try
#define EXCEPT(e)   __except (e)
#define END_EXCEPT
#endif

#define SIZEOFARRAY(a)      (sizeof (a) / sizeof (a[0]))

#define HideWindow(_hwnd)   SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#define UnHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)|WS_VISIBLE)
#define UNATTENDED(btn)     if((UnattendedOperation) && (!CancelPending)) PostMessage(hdlg,WMX_UNATTENDED,btn,0)
#define CHECKUPGRADEONLY()  if(CheckUpgradeOnly) return( FALSE )
#define CHECKUPGRADEONLY_Q()  if(CheckUpgradeOnlyQ) return( FALSE )
#define SetDialogFocus(_hwnd, _hwndchild) SendMessage(_hwnd, WM_NEXTDLGCTL, (WPARAM)_hwndchild, MAKELPARAM(TRUE, 0))
#define MAKEULONGLONG(low,high) ((ULONGLONG)(((DWORD)(low)) | ((ULONGLONG)((DWORD)(high))) << 32))
#define HIULONG(_val_)      ((ULONG)(_val_>>32))
#define LOULONG(_val_)      ((ULONG)_val_)
#define TYPICAL()     (dwSetupFlags & UPG_FLAG_TYPICAL)


extern HINSTANCE hInst;
extern UINT AppTitleStringId;
extern DWORD TlsIndex;
extern HINSTANCE hinstBB;
extern HWND WizardHandle;
extern BOOL g_DeleteRunOnceFlag;
HWND GetBBhwnd();
HWND GetBBMainHwnd();


#define S_WINNT32_WARNING               TEXT("Winnt32RunOnceWarning")
// #define RUN_SYSPARSE 1

//
// Flag indicating whether we are initiating an MSI-Install.
//
extern BOOL RunFromMSI;
//
// Flag indicating whether we are initiating an Typical install
//
extern DWORD dwSetupFlags;
//
// Flag indicating whether we are initiating an upgrade.
//
extern BOOL Upgrade;

//
// Flag to say if we need to write the AcpiHAL value to the winnt.sif file
//
extern BOOL WriteAcpiHalValue;

//
// What should we write as the value for the AcpiHalValue
//
extern BOOL AcpiHalValue;

//
// Flag indicating whether we're installing/upgrading to NT Server
//
extern BOOL Server;

//
// Flag to indicate if we are running BVT's
//
extern BOOL RunningBVTs;

//
// When running BVT's, what baudrate should we set the debugger to?
//
extern LONG lDebugBaudRate;

//
// When running BVT's, what comport should we set the debugger to?
//
extern LONG lDebugComPort;

//
// When running BVT's, should we copy the symbols locally?
//
extern BOOL CopySymbols;

//
// Flag to indicate if we are running ASR tests
//
extern DWORD AsrQuickTest;

//
// Product type and flavor for upgrade modules
//
extern PRODUCTTYPE UpgradeProductType;
extern UINT ProductFlavor;

//
// fat to ntfs conversion flag
//
extern BOOL ForceNTFSConversion;
extern BOOL NTFSConversionChanged;

//
// 16 bit environment boot (Win9x upgrade only)
//
typedef enum {
    BOOT16_AUTOMATIC,
    BOOT16_YES,
    BOOT16_NO
} BOOT16_OPTIONS;
extern UINT g_Boot16;

//
// Global flag indicating whether the entire overall program operation
// was successful. Also a flag indicating whether to shut down automatically
// when the wizard is done in the non-unattended case.
//
extern BOOL GlobalResult;
extern BOOL AutomaticallyShutDown;

//
// Global OS version info.
//
extern OSVERSIONINFO OsVersion;
extern DWORD OsVersionNumber;
#define BUILDNUM()  (OsVersion.dwBuildNumber)
#ifdef UNICODE
#define ISNT()      (TRUE)
#define ISOSR2()    (FALSE)
#else
#define ISNT()      (FALSE)
#define ISOSR2()    (LOWORD(OsVersion.dwBuildNumber) > 1080)
#endif

extern WINNT32_PLUGIN_INIT_INFORMATION_BLOCK info;

//
// Flags indicating how we were run and whether to create
// a local source.
//
extern BOOL RunFromCD;
extern BOOL MakeLocalSource;
extern BOOL UserSpecifiedMakeLocalSource;
extern BOOL NoLs;
extern TCHAR UserSpecifiedLocalSourceDrive;
extern LONG SourceInstallType; // uses InstallType enum
extern DWORD MLSDiskID;

//
// Used for win9xupg reporting (reportonly mode)
//
extern UINT UpgRequiredMb;
extern UINT UpgAvailableMb;

//
// advanced install options
//
extern BOOL ChoosePartition;
extern BOOL UseSignatures;
extern TCHAR InstallDir[MAX_PATH];
extern TCHAR HeadlessSelection[MAX_PATH];
extern ULONG HeadlessBaudRate;
#ifdef PRERELEASE
extern BOOL AppendDebugDataToBoot;
#endif

//
// SMS support
//
extern PSTR LastMessage;

#if defined(REMOTE_BOOT)
//
// Flag indicating whether we're running on a remote boot client.
//
extern BOOL RemoteBoot;

//
// Path to the machine directory for a remote boot client.
//
extern TCHAR MachineDirectory[MAX_PATH];
#endif // defined(REMOTE_BOOT)

//
// Flags indicating which Accessibility utilities to use
//
extern BOOL AccessibleMagnifier;
extern BOOL AccessibleKeyboard;
extern BOOL AccessibleVoice;
extern BOOL AccessibleReader;

//
// Build number we're upgrading from
//
extern DWORD BuildNumber;
#define     NT351   1057
#define     NT40    1381
#define     NT50B1  1671
#define     NT50B3  2031
#define     NT50    2195
#define     NT51B2  2462

//
// Are any of the Accesssibility utilities enabled?
//
extern BOOL AccessibleSetup;

//
// Flags and values relating to unattended operation.
//
extern BOOL UnattendedOperation;
extern BOOL UnattendSwitchSpecified;
extern PTSTR UnattendedScriptFile;
extern UINT UnattendedShutdownTimeout;
extern UINT UnattendedCountdown;
extern BOOL BatchMode;

//
// Name of unattended script file to be used for Accessible Setup
//
extern TCHAR AccessibleScriptFile[MAX_PATH];

//
// Name of inf file and handles to dosnet.inf and txtsetup.sif.
//
extern TCHAR InfName[MAX_PATH];
extern PVOID MainInf;
extern TCHAR FullInfName[MAX_PATH];
extern PVOID TxtsetupSif;
extern PVOID NtcompatInf;

BOOL
GetMainInfValue (
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      DWORD FieldNumber,
    OUT     PTSTR Buffer,
    IN      DWORD BufChars
    );

//
// Language options stuff
//
extern BOOL    IntlInfProcessed;
extern DWORD   PrimaryLocale;

// Global used in WriteParamsFile and AddExternalParams
extern TCHAR ActualParamFile[MAX_PATH];

BOOL InitLangControl(HWND hdlg, BOOL bFarEast);
BOOL IsFarEastLanguage(DWORD LangIdx);
BOOL SelectFarEastLangGroup(BOOL bSelect);

void BB_SetProgressText(LPTSTR szText);
void BB_SetTimeEstimateText(LPTSTR szText);
void BB_SetInfoText(LPTSTR szText);

extern
BOOL
ReadIntlInf(
    IN HWND   hdlg
    );

extern
VOID
SaveLanguageDirs(
    );

extern
BOOL
SaveLanguageParams(
    IN LPCTSTR FileName
    );

extern
VOID
FreeLanguageData(
    );

VOID
CleanUpOldLocalSources(
    IN HWND hdlg
    );

BOOL
InspectFilesystems(
    IN HWND hdlg
    );

BOOL
LoadInfWorker(
    IN  HWND     hdlg,
    IN  LPCTSTR  FilenamePart,
    OUT PVOID   *InfHandle,
    IN  BOOL     Winnt32File
    );

BOOL
FindLocalSourceAndCheckSpace(
    IN HWND hdlg,
    IN BOOL QuickTest,
    IN LONGLONG  AdditionalPadding
    );

BOOL
EnoughMemory(
    IN HWND hdlg,
    IN BOOL QuickTest
    );

//
// Optional directory stuff.
//
#define MAX_OPTIONALDIRS    20
extern UINT OptionalDirectoryCount;
extern TCHAR OptionalDirectories[MAX_OPTIONALDIRS][MAX_PATH];
extern UINT OptionalDirectoryFlags[MAX_OPTIONALDIRS];

#define OPTDIR_TEMPONLY                 0x00000001
#define OPTDIR_OEMSYS                   0x00000002
#define OPTDIR_OVERLAY                  0x00000004
#define OPTDIR_ADDSRCARCH               0x00000008
#define OPTDIR_ABSOLUTE                 0x00000010
#define OPTDIR_DEBUGGEREXT              0x00000020  // speficies that this optional dir is to be copied to %windir%\system32\pri (for debugger extensions)
// OPTDIR_PLATFORM_INDEP becomes DIR_IS_PLATFORM_INDEPEND and FILE_IN_PLATFORM_INDEPEND_DIR
#define OPTDIR_PLATFORM_INDEP           0x00000040
#define OPTDIR_IN_LOCAL_BOOT            0x00000080
#define OPTDIR_SUPPORT_DYNAMIC_UPDATE   0x00000100
#define OPTDIR_USE_TAIL_FOLDER_NAME     0x00000200
#define OPTDIR_PLATFORM_SPECIFIC_FIRST  0x00000400
#define OPTDIR_DOESNT_SUPPORT_PRIVATES  0x00000800
#define OPTDIR_SIDE_BY_SIDE             0x00001000

//
// Source paths and count of paths.
//
extern TCHAR SourcePaths[MAX_SOURCE_COUNT][MAX_PATH];
extern TCHAR NativeSourcePaths[MAX_SOURCE_COUNT][MAX_PATH];
extern UINT SourceCount;
extern TCHAR *UserSpecifiedOEMShare;
//
// Local source information.
//
#define DEFAULT_INSTALL_DIR     TEXT("\\WINDOWS")
#define INTERNAL_WINNT32_DIR    TEXT("winnt32")

#define LOCAL_SOURCE_DIR_A      "$WIN_NT$.~LS"
#define LOCAL_SOURCE_DIR_W      L"$WIN_NT$.~LS"
#define TEXTMODE_INF_A          "TXTSETUP.SIF"
#define TEXTMODE_INF_W          L"TXTSETUP.SIF"
#define NTCOMPAT_INF_A          "COMPDATA\\NTCOMPAT.INF"
#define NTCOMPAT_INF_W          L"COMPDATA\\NTCOMPAT.INF"
#define DRVINDEX_INF_A          "DRVINDEX.INF"
#define DRVINDEX_INF_W          L"DRVINDEX.INF"
#define SETUPP_INI_A            "SETUPP.INI"
#define SETUPP_INI_W            L"SETUPP.INI"
#define PID_SECTION_A           "Pid"
#define PID_SECTION_W           L"Pid"
#define PID_KEY_A               "Pid"
#define PID_KEY_W               L"Pid"
#define OEM_INSTALL_RPC_A       "OEM"
#define OEM_INSTALL_RPC_W       L"OEM"
#define SELECT_INSTALL_RPC_A    "270"
#define SELECT_INSTALL_RPC_W    L"270"
#define MSDN_INSTALL_RPC_A      "335"
#define MSDN_INSTALL_RPC_W      L"335"
#define MSDN_PID30_A            "MD97J-QC7R7-TQJGD-3V2WM-W7PVM"
#define MSDN_PID30_W            L"MD97J-QC7R7-TQJGD-3V2WM-W7PVM"

#define INF_FILE_HEADER         "[Version]\r\nSignature = \"$Windows NT$\"\r\n\r\n"


#ifdef UNICODE
#define LOCAL_SOURCE_DIR        LOCAL_SOURCE_DIR_W
#define TEXTMODE_INF            TEXTMODE_INF_W
#define NTCOMPAT_INF            NTCOMPAT_INF_W
#define DRVINDEX_INF            DRVINDEX_INF_W
#define SETUPP_INI              SETUPP_INI_W
#define PID_SECTION             PID_SECTION_W
#define PID_KEY                 PID_KEY_W
#define OEM_INSTALL_RPC         OEM_INSTALL_RPC_W
#define SELECT_INSTALL_RPC      SELECT_INSTALL_RPC_W
#define MSDN_INSTALL_RPC        MSDN_INSTALL_RPC_W
#define MSDN_PID30              MSDN_PID30_W
#else
#define LOCAL_SOURCE_DIR        LOCAL_SOURCE_DIR_A
#define TEXTMODE_INF            TEXTMODE_INF_A
#define NTCOMPAT_INF            NTCOMPAT_INF_A
#define DRVINDEX_INF            DRVINDEX_INF_A
#define SETUPP_INI              SETUPP_INI_A
#define PID_SECTION             PID_SECTION_A
#define PID_KEY                 PID_KEY_A
#define OEM_INSTALL_RPC         OEM_INSTALL_RPC_A
#define SELECT_INSTALL_RPC      SELECT_INSTALL_RPC_A
#define MSDN_INSTALL_RPC        MSDN_INSTALL_RPC_A
#define MSDN_PID30              MSDN_PID30_A
#endif

#ifdef _X86_
#define LOCAL_BOOT_DIR_A        "$WIN_NT$.~BT"
#define LOCAL_BOOT_DIR_W        L"$WIN_NT$.~BT"
#define AUX_BS_NAME_A           "$LDR$"
#define AUX_BS_NAME_W           L"$LDR$"
#define FLOPPY_COUNT            4
//
// Local BACKUP information, on NEC98.
//
#define LOCAL_BACKUP_DIR_A      "$WIN_NT$.~BU"
#define LOCAL_BACKUP_DIR_W      L"$WIN_NT$.~BU"
#ifdef UNICODE
#define LOCAL_BOOT_DIR          LOCAL_BOOT_DIR_W
#define AUX_BS_NAME             AUX_BS_NAME_W
#define LOCAL_BACKUP_DIR        LOCAL_BACKUP_DIR_W
#else
#define LOCAL_BOOT_DIR          LOCAL_BOOT_DIR_A
#define AUX_BS_NAME             AUX_BS_NAME_A
#define LOCAL_BACKUP_DIR        LOCAL_BACKUP_DIR_A
#endif
extern TCHAR LocalBackupDirectory[MAX_PATH];
extern TCHAR FirstFloppyDriveLetter;
#endif

extern DWORD LocalSourceDriveOffset;

extern TCHAR LocalSourceDrive;
extern TCHAR LocalSourceDirectory[MAX_PATH];
extern TCHAR LocalSourceWithPlatform[MAX_PATH];
extern TCHAR LocalBootDirectory[MAX_PATH];
extern BOOL  BlockOnNotEnoughSpace;
extern LONGLONG LocalSourceSpaceRequired;
extern LONGLONG WinDirSpaceFor9x;
extern BOOL UpginfsUpdated;
extern BOOL Win95upgInfUpdated;

//
// wizard stuff
//

// wizard page size
#define WIZ_PAGE_SIZE_X 317
#define WIZ_PAGE_SIZE_Y 179

#define BBSTEP_NONE                         0
#define BBSTEP_COLLECTING_INFORMATION       1
#define BBSTEP_DYNAMIC_UPDATE               2
#define BBSTEP_PREPARING                    3

typedef struct _PAGE_COMMON_DATA {

    DLGPROC DialogProcedure;

    UINT BillboardStep;

    //
    // State to initialize buttons to.
    //
    DWORD Buttons;

    UINT Flags;

} PAGE_COMMON_DATA, *PPAGE_COMMON_DATA;


typedef struct _PAGE_CREATE_DATA {
    //
    // If these are specified, then a range of pages may come
    // from somewhere else. Otherwise, it's one page whose
    // resource id is given below.
    //
    LPPROPSHEETPAGE *ExternalPages;
    PUINT ExternalPageCount;

    UINT Template;

    PAGE_COMMON_DATA CommonData;

} PAGE_CREATE_DATA, *PPAGE_CREATE_DATA;


typedef struct _PAGE_RUNTIME_DATA {

    PAGE_COMMON_DATA CommonData;

    //
    // Per-page (private) data
    //
    DWORD PerPageData;

} PAGE_RUNTIME_DATA, *PPAGE_RUNTIME_DATA;


typedef struct _BITMAP_DATA {
    CONST BITMAPINFOHEADER *BitmapInfoHeader;
    PVOID                   BitmapBits;
    HPALETTE                Palette;
    UINT                    PaletteColorCount;
    BOOL                    Adjusted;
} BITMAP_DATA, *PBITMAP_DATA;


#define WIZPAGE_FULL_PAGE_WATERMARK 0x00000001
#define WIZPAGE_SEPARATOR_CREATED   0x00000002
#define WIZPAGE_NEW_HEADER          0x00000004


//
// compatibility data
//

typedef struct _COMPATIBILITY_DATA {
    //
    // general
    //
    LIST_ENTRY ListEntry;
    //
    // what type of entry
    //
    TCHAR    Type;
    //
    // service-driver data
    //
    LPCTSTR  ServiceName;
    //
    // registry data
    //
    LPCTSTR  RegKey;
    LPCTSTR  RegValue;
    LPCTSTR  RegValueExpect;
    //
    // file data
    //
    LPCTSTR  FileName;
    LPCTSTR  FileVer;
    //
    // common
    //
    LPCTSTR  Description;
    LPCTSTR  HtmlName;
    LPCTSTR  TextName;
    LPTSTR   RegKeyName;
    LPTSTR   RegValName;
    LPVOID   RegValData;
    DWORD    RegValDataSize;
    LPVOID   SaveValue;
    DWORD    Flags;
    LPCTSTR  InfName;
    LPCTSTR  InfSection;

    HMODULE                 hModDll;
    PCOMPAIBILITYHAVEDISK   CompHaveDisk;

} COMPATIBILITY_DATA, *PCOMPATIBILITY_DATA;

extern LIST_ENTRY CompatibilityData;
extern DWORD CompatibilityCount;
extern DWORD IncompatibilityStopsInstallation;
extern BOOL AnyNt5CompatDlls;

BOOL
AnyBlockingCompatibilityItems (
    VOID
    );

//
// Plug and Play device migration routines.
// (linked into winnt.dll from pnpsif.lib)
//
BOOL
MigrateDeviceInstanceData(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateClassKeys(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateHashValues(
    OUT LPTSTR  *Buffer
    );

//
// Array of drive letters for all system partitions.
// Note that on x86 there will always be exactly one.
// The list is 0-terminated.
//
extern TCHAR SystemPartitionDriveLetters[27];
extern TCHAR SystemPartitionDriveLetter;

#ifdef UNICODE
extern UINT SystemPartitionCount;
extern PWSTR* SystemPartitionNtNames;
extern PWSTR SystemPartitionNtName;
extern PWSTR SystemPartitionVolumeGuid;
#else
extern PCSTR g_LocalSourcePath;
#endif

//
// UDF stuff
//
extern LPCTSTR UniquenessId;
extern LPCTSTR UniquenessDatabaseFile;

//
// Preinstall stuff
//
extern BOOL OemPreinstall;

#ifdef _X86_
typedef struct _OEM_BOOT_FILE {
    struct _OEM_BOOT_FILE *Next;
    LPCTSTR Filename;
} OEM_BOOT_FILE, *POEM_BOOT_FILE;

extern POEM_BOOT_FILE OemBootFiles;
#endif

extern TCHAR ForcedSystemPartition;

//
// Miscellaneous other command line parameters.
//
extern LPCTSTR CmdToExecuteAtEndOfGui;
extern BOOL AutoSkipMissingFiles;
extern BOOL HideWinDir;
extern TCHAR ProductId[64];

//
// Flag indicating that the user cancelled.
// Flag indicating that a succssessful abort should be performed.
// Handle for mutex used to guarantee that only one error dialog
// is on the screen at once.
//
extern BOOL Cancelled;
extern BOOL CancelPending;
extern BOOL Aborted;
extern HANDLE UiMutex;

//
// This indicates that well give the user some detailed data-throughput
// info.
//
extern BOOL DetailedCopyProgress;
extern ULONGLONG TotalDataCopied;

//
// Upgrade Options variables. Used to pass a multistring of
// upgrade command line options to the plugin DLLs.
//
extern LPTSTR UpgradeOptions;
extern DWORD  UpgradeOptionsLength;
extern DWORD  UpgradeOptionsSize;

BOOL
AppendUpgradeOption (
    IN      PCTSTR String
    );

#ifdef _X86_
//
// Win9x upgrade report status
//

extern UINT g_UpgradeReportMode;
#endif

//
// Compliance variables
//
extern BOOL   NoCompliance;
extern BOOL   NoBuildCheck;

// UpgradeOnly is true is the media is CCP media and only valid
// to upgrade a system.  eula.c will use this to ensure that an
// FPP pid is not used with CCP media and vice-versa
extern BOOL   UpgradeOnly;

extern BOOL   SkipLocaleCheck;
extern BOOL   SkipVirusScannerCheck;

extern BOOL   UseBIOSToBoot;

//
// TargetNativeLangID : this is native language ID of running system
//
extern LANGID TargetNativeLangID;

//
// SourceNativeLangID : this is native language ID of new NT you want to install
//
extern LANGID SourceNativeLangID;

//
// IsLanguageMatched : if source and target language are matched (or compatible)
//
//                     1. if SourceNativeLangID == TargetNativeLangID
//
//                     2. if SourceNativeLangID's alternative ID == TargetNativeLangID
//
extern BOOL IsLanguageMatched;

BOOL
InitLanguageDetection(
    LPCTSTR SourcePath,
    LPCTSTR InfFile
    );



//
// Routines from Setupapi.dll
//
extern
BOOL
(*SetupapiCabinetRoutine)(
    IN LPCTSTR CabinetFile,
    IN DWORD Flags,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID Context
    );

extern
DWORD
(*SetupapiDecompressOrCopyFile)(
    IN  PCTSTR  SourceFileName,
    OUT PCTSTR  TargetFileName,
    OUT PUINT   CompressionType OPTIONAL
    );

extern
HINF
(*SetupapiOpenInfFile)(
    IN  LPCTSTR FileName,
    IN  LPCTSTR InfClass,    OPTIONAL
    IN  DWORD   InfStyle,
    OUT PUINT   ErrorLine    OPTIONAL
    );

extern
VOID
(*SetupapiCloseInfFile)(
    IN HINF InfHandle
    );

extern
BOOL
(*SetupapiFindFirstLine)(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN  PCTSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    );

extern
BOOL
(*SetupapiFindNextLine)(
    PINFCONTEXT ContextIn,
    PINFCONTEXT ContextOut
    );

extern
BOOL
(*SetupapiFindNextMatchLine)(
    PINFCONTEXT ContextIn,
    PCTSTR Key,
    PINFCONTEXT ContextOut
    );

extern
LONG
(*SetupapiGetLineCount)(
    IN HINF   InfHandle,
    IN LPCTSTR Section
    );

extern
DWORD
(*SetupapiGetFieldCount)(
    IN  PINFCONTEXT Context
    );

extern
BOOL
(*SetupapiGetStringField)(
    IN  PINFCONTEXT Context,
    DWORD FieldIndex,
    PTSTR ReturnBuffer,
    DWORD ReturnBufferSize,
    PDWORD RequiredSize
    );

extern
BOOL
(*SetupapiGetLineByIndex)(
    IN  HINF        InfHandle,
    IN  LPCTSTR     Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    );

extern
HSPFILEQ
(*SetupapiOpenFileQueue) (
    VOID
    );

extern
BOOL
(*SetupapiCloseFileQueue) (
    IN HSPFILEQ QueueHandle
    );

extern
BOOL
(*SetupapiQueueCopy) (
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourceRootPath,     OPTIONAL
    IN PCTSTR   SourcePath,         OPTIONAL
    IN PCTSTR   SourceFilename,
    IN PCTSTR   SourceDescription,  OPTIONAL
    IN PCTSTR   SourceTagfile,      OPTIONAL
    IN PCTSTR   TargetDirectory,
    IN PCTSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    );

extern
BOOL
(*SetupapiCommitFileQueue) (
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    );

extern
UINT
(*SetupapiDefaultQueueCallback) (
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

extern
PVOID
(*SetupapiInitDefaultQueueCallback) (
    HWND OwnerWindow
);

extern
VOID
(*SetupapiTermDefaultQueueCallback) (
    PVOID Context
);

//
// Custom window messages. Define so they don't overlap with
// any being used by plug-in dll's.
//
#define WMX_EDITCONTROLSTATE    (WMX_PLUGIN_FIRST-1)
#define WMX_INSPECTRESULT       (WMX_PLUGIN_FIRST-2)
//#define WMX_SETPROGRESSTEXT     (WMX_PLUGIN_FIRST-3)
#define WMX_ERRORMESSAGEUP      (WMX_PLUGIN_FIRST-4)
#define WMX_I_AM_VISIBLE        (WMX_PLUGIN_FIRST-5)
#define WMX_COPYPROGRESS        (WMX_PLUGIN_FIRST-6)
#define WMX_I_AM_DONE           (WMX_PLUGIN_FIRST-7)
#define WMX_FINISHBUTTON        (WMX_PLUGIN_FIRST-8)
#define WMX_UNATTENDED          (WMX_PLUGIN_FIRST-9)
#define WMX_NEXTBUTTON          (WMX_PLUGIN_FIRST-10)
#define WMX_BACKBUTTON          (WMX_PLUGIN_FIRST-11)
#define WMX_VALIDATE            (WMX_PLUGIN_FIRST-12)
#define WMX_SETUPUPDATE_PREPARING       (WMX_PLUGIN_FIRST-13)
#define WMX_SETUPUPDATE_DOWNLOADING     (WMX_PLUGIN_FIRST-14)
#define WMX_SETUPUPDATE_PROCESSING      (WMX_PLUGIN_FIRST-15)
#define WMX_SETUPUPDATE_DONE            (WMX_PLUGIN_FIRST-16)
#define WMX_SETUPUPDATE_CANCEL          (WMX_PLUGIN_FIRST-17)
#define WMX_SETUPUPDATE_INIT_RETRY      (WMX_PLUGIN_FIRST-18)
#define WMX_SETUPUPDATE_THREAD_DONE     (WMX_PLUGIN_FIRST-19)
#ifdef RUN_SYSPARSE
#define WMX_SYSPARSE_DONE               (WMX_PLUGIN_FIRST-20)
#endif    
#define WMX_DYNAMIC_UPDATE_COMPLETE     (WMX_PLUGIN_FIRST-21)


//
// Helper macro for uppercasing
//
#define TOUPPER(x)  (TCHAR)CharUpper((LPTSTR)x)



//
// Routine that does everything by starting the wizard.
//
VOID
Wizard(
    VOID
    );


//
// Routine that builds a cmdcons installation.
//
VOID
DoBuildCmdcons(
    VOID
    );


VOID
FixUpWizardTitle(
    IN HWND Wizard
    );

//
// Cleanup routine and globals used by the cleanup stuff.
//
DWORD
StartCleanup(
    IN PVOID ThreadParameter
    );

#ifdef _X86_

BOOL
RestoreBootSector(
    VOID
    );

BOOL
RestoreBootIni(
    VOID
    );

BOOL
SaveRestoreBootFiles_NEC98(
    IN UCHAR Flag
    );
#define NEC98SAVEBOOTFILES      0
#define NEC98RESTOREBOOTFILES   1

BOOL
IsDriveAssignNEC98(
    VOID
    );

//
// Check ATA Drive
//

BOOLEAN
CheckATACardonNT4(
    HANDLE hDisk
    );


//
// Check formatted drive type
//
BOOLEAN
IsValidDrive(
    TCHAR Drive
    );

#endif //_X86_

BOOL
RestoreNvRam(
    VOID
    );


//
// Thread that inspects sources, loads infs, builds the copy list,
// checks disk space, etc. And some worker routines.
//

DWORD
InspectAndLoadThread(
    IN PVOID ThreadParam
    );

BOOL
InspectSources(
    IN HWND ParentWnd
    );


BOOL
BuildCopyListWorker(
    IN HWND hdlg
    );

BOOL
FindLocalSourceAndCheckSpaceWorker(
    IN HWND hdlg,
    IN BOOL QuickTest,
    IN LONGLONG  AdditionalPadding
    );

UINT
GetTotalFileCount(
    VOID
    );

DWORD
StartCopyingThread(
    IN PVOID ThreadParameter
    );

VOID
CancelledMakeSureCopyThreadsAreDead(
    VOID
    );

DWORD
DoPostCopyingStuff(
    IN PVOID ThreadParam
    );

//
// File copy error routine and outcomes.
//
UINT
FileCopyError(
    IN HWND    ParentWindow,
    IN LPCTSTR SourceFilename,
    IN LPCTSTR TargetFilename,
    IN UINT    Win32Error,
    IN BOOL    MasterList
    );

#define COPYERR_SKIP    1
#define COPYERR_EXIT    2
#define COPYERR_RETRY   3


//
// Routine to add an optional directory to the list of dirs
// we copy.
//
BOOL
RememberOptionalDir(
    IN LPCTSTR Directory,
    IN UINT    Flags
    );

//
// Resource utility routines.
//

PCTSTR
GetStringResource (
    IN UINT Id              // ID or pointer to string name
    );

VOID
FreeStringResource (
    IN PCTSTR String
    );

VOID
SaveMessageForSMS(
    IN DWORD MessageId,
    ...
    );

VOID
SaveTextForSMS(
    IN PCTSTR Buffer
    );

int
MessageBoxFromMessage(
    IN HWND  Window,
    IN DWORD MessageId,
    IN BOOL  SystemMessage,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    );

int
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN va_list *Args
    );

int
MessageBoxFromMessageWithSystem(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN HMODULE  hMod
    );

int
MessageBoxFromMessageAndSystemError(
    IN HWND  Window,
    IN DWORD MessageId,
    IN DWORD SystemMessageId,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    );

HBITMAP
LoadResourceBitmap(
    IN  HINSTANCE hInst,
    IN  LPCTSTR   Id,
    OUT HPALETTE *Palette
    );

BOOL
GetBitmapDataAndPalette(
    IN  HINSTANCE                hInst,
    IN  LPCTSTR                  Id,
    OUT HPALETTE                *Palette,
    OUT PUINT                    ColorCount,
    OUT CONST BITMAPINFOHEADER **BitmapData
    );

UINT
GetYPositionOfDialogItem(
    IN LPCTSTR Dialog,
    IN UINT    ControlId
    );

//
// Security routines.
//
BOOL
IsUserAdmin(
    VOID
    );

BOOL
DoesUserHavePrivilege(
    PTSTR PrivilegeName
    );

BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    );

//
// Inf routines.
//
DWORD
LoadInfFile(
   IN  LPCTSTR Filename,
   IN  BOOL    OemCodepage,
   OUT PVOID  *InfHandle
   );

VOID
UnloadInfFile(
   IN PVOID InfHandle
   );

LONG
InfGetSectionLineCount(
   IN PVOID INFHandle,
   IN PTSTR SectionName
   );

LPCTSTR
InfGetFieldByIndex(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN unsigned LineIndex,
   IN unsigned ValueIndex
   );

LPCTSTR
InfGetFieldByKey(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN LPCTSTR  Key,
   IN unsigned ValueIndex
   );

BOOL
InfDoesLineExistInSection(
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Key
   );

BOOL
InfDoesEntryExistInSection (
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Entry
   );

LPCTSTR
InfGetLineKeyName(
    IN PVOID    INFHandle,
    IN LPCTSTR  SectionName,
    IN unsigned LineIndex
    );


typedef struct {
    // Caller members (read-only)
    PCTSTR FieldZeroData;
    unsigned LineIndex;

    // Internal members
    PVOID InfHandle;
    PCTSTR SectionName;
} INF_ENUM, *PINF_ENUM;

BOOL
EnumFirstInfLine (
    OUT     PINF_ENUM InfEnum,
    IN      PVOID InfHandle,
    IN      PCTSTR InfSection
    );

BOOL
EnumNextInfLine (
    IN OUT  PINF_ENUM InfEnum
    );

VOID
AbortInfLineEnum (
    IN      PINF_ENUM InfEnum           // ZEROED
    );

//
// Routines to manipulate parameters files like unattend.txt,
// the param file we pass to text mode setup, etc.
//
BOOL
WriteParametersFile(
    IN HWND ParentWindow
    );

BOOL
AddExternalParams(
    IN HWND ParentWindow
    );

//
// Miscellaenous utility routines.
//
LPTSTR *
CommandLineToArgv(
    OUT int *NumArgs
    );

VOID
MyWinHelp(
    IN HWND  Window,
    IN UINT  Command,
    IN ULONG_PTR Data
    );

VOID
ConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    );

LPTSTR
DupString(
    IN LPCTSTR String
    );

UINT
MyGetDriveType(
    IN TCHAR Drive
    );

#ifdef UNICODE
UINT
MyGetDriveType2 (
    IN      PCWSTR NtDeviceName
    );

BOOL
MyGetDiskFreeSpace (
    IN      PCWSTR NtVolumeName,
    IN      PDWORD SectorsPerCluster,
    IN      PDWORD BytesPerSector,
    IN      PDWORD NumberOfFreeClusters,
    IN      PDWORD TotalNumberOfClusters
    );

#endif

BOOL
GetPartitionInfo(
    IN  TCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    );

BOOL
IsDriveNTFT(
    IN TCHAR Drive,
    IN      PCTSTR NtVolumeName
    );

BOOL
IsDriveVeritas(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    );

#ifdef UNICODE

BOOL
IsSoftPartition(
    IN TCHAR Drive,
    IN PCTSTR NtVolumeName
    );
#else

#define IsSoftPartition(d,n)    (FALSE)

#endif

BOOL
IsDriveNTFS(
    IN TCHAR Drive
    );

BOOL
IsMachineSupported(
    OUT PCOMPATIBILITY_ENTRY CompEntry
    );

BOOL
GetAndSaveNTFTInfo(
    IN HWND ParentWindow
    );

VOID
ForceStickyDriveLetters(
    );

DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );

DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    );

VOID
GenerateCompressedName(
    IN  LPCTSTR Filename,
    OUT LPTSTR  CompressedName
    );

DWORD
CreateMultiLevelDirectory(
    IN LPCTSTR Directory
    );

VOID
MyDelnode(
    IN LPCTSTR Directory
    );

BOOL
ForceFileNoCompress(
    IN LPCTSTR Filename
    );

BOOL
IsCurrentOsServer(
    void
    );

BOOL
IsCurrentAdvancedServer(
    void
    );

BOOL
IsNTFSConversionRecommended(
    void
    );


BOOL
ForceBootFilesUncompressed(
    IN HWND ParentWindow,
    IN BOOL TellUserAboutError
    );

BOOLEAN
AdjustPrivilege(
    PCTSTR   Privilege
    );

BOOL
GetUserPrintableFileSizeString(
    IN DWORDLONG Size,
    OUT LPTSTR Buffer,
    IN DWORD BufferSize
    );

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

BOOL
DoesDirectoryExist (
    IN      PCTSTR DirSpec
    );

BOOL
InDriverCacheInf(
    IN      PVOID InfHandle,
    IN      PCTSTR FileName,
    OUT     PTSTR DriverCabName,        OPTIONAL
    IN      DWORD BufferChars           OPTIONAL
    );

BOOL
BuildSystemPartitionPathToFile (
    IN      PCTSTR FileName,
    OUT     PTSTR Path,
    IN      DWORD BufferSizeChars
    );

BOOL
FindPathToInstallationFileEx (
    IN      PCTSTR FileName,
    OUT     PTSTR PathToFile,
    IN      DWORD PathToFileBufferSize,
    OUT     PBOOL Compressed                OPTIONAL
    );

#define FindPathToInstallationFile(n,p,s)   FindPathToInstallationFileEx(n,p,s,NULL)


BOOL
FindPathToWinnt32File (
    IN      PCTSTR FileRelativePath,
    OUT     PTSTR PathToFile,
    IN      DWORD PathToFileBufferSize
    );

BOOL
GetFileVersion (
    IN      PCTSTR FilePath,
    OUT     PTSTR FileVersion
    );


//
// #define to use MyPrivateProfileString to get around virus checkers monitoring operations to C
// drive that cause us to fail WritePrivateProfileString
// The problem is that usually these s/w examine the files we touch and in somecases open it
// with exclusive access. We just need to wait for them to be done.
//


BOOL
MyWritePrivateProfileString(
    LPCTSTR lpAppName,  // pointer to section name
    LPCTSTR lpKeyName,  // pointer to key name
    LPCTSTR lpString,   // pointer to string to add
    LPCTSTR lpFileName  // pointer to initialization filename
    );


#ifdef UNICODE
    #define WritePrivateProfileStringW(w,x,y,z) MyWritePrivateProfileString(w,x,y,z)
#else
    #define WritePrivateProfileStringA(w,x,y,z) MyWritePrivateProfileString(w,x,y,z)
#endif

//
// Routines having to do with advanced program options
//
VOID
InitVariousOptions(
    VOID
    );

VOID
DoOptions(
    IN HWND Parent
    );

VOID
DoLanguage(
    IN HWND Parent
    );

VOID
DoAccessibility(
    IN HWND Parent
    );

BOOL
BrowseForDosnetInf(
    IN  HWND    hdlg,
    IN  LPCTSTR InitialPath,
    OUT TCHAR   NewPath[MAX_PATH]
    );

BOOL
IsValid8Dot3(
    IN LPCTSTR Path
    );

//
// Routines having to do with eula and pid
//
#define MAX_PID30_EDIT                       5
extern LPTSTR g_EncryptedPID;
extern BOOL g_bDeferPIDValidation;

extern BOOL EulaComplete;

typedef enum InstallType
{
   SelectInstall,
   OEMInstall,
   RetailInstall
};

VOID
GetSourceInstallType(
    OUT OPTIONAL PDWORD InstallVariation
    );

BOOL
SetPid30(
    HWND hdlg,
    LONG ExpectedPidType,
    LPTSTR pProductId
    );

#ifdef UNICODE
PCHAR
FindRealHalName(
    TCHAR *pHalFileName
    );
#endif

//
// Debugging and logging
//
typedef enum {
    Winnt32LogSevereError,
    Winnt32LogError,
    Winnt32LogWarning,
    Winnt32LogInformation,
    Winnt32LogDetailedInformation,
    Winnt32LogMax
#define WINNT32_HARDWARE_LOG 0x40000000
} Winnt32DebugLevel;

extern Winnt32DebugLevel DebugLevel;

BOOL
StartDebugLog(
    IN LPCTSTR           DebugFileLog,
    IN Winnt32DebugLevel Level
    );

VOID
CloseDebugLog(
    VOID
    );

BOOL
DebugLog(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,        OPTIONAL
    IN UINT              MessageId,
    ...
    );

BOOL
DebugLog2(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,        OPTIONAL
    IN UINT              MessageId,
    IN va_list           ArgList
    );

BOOL
DynUpdtDebugLog(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,
    IN UINT              MessageId,
    ...
    );

BOOL
ConcatenateFile(
    IN HANDLE   hOpenFile,
    IN  LPTSTR  FileName
    );

VOID
GatherOtherLogFiles(
    VOID
    );

//
// Memory allocation.
//
#define MALLOC(s)       malloc(s)
#define FREE(b)         free(b)
#define REALLOC(b,s)    realloc((b),(s))


//
// Floppy-related stuff.
//
extern BOOL MakeBootMedia;
extern BOOL Floppyless;

//
// boot loader timeout value, in string form
//
extern TCHAR Timeout[32];

#ifdef _X86_
UINT
FloppyGetTotalFileCount(
    VOID
    );

DWORD
FloppyWorkerThread(
    IN PVOID ThreadParameter
    );

//
// Routine to lay NT boot code, munge boot.ini, create aux boot sector, etc.
//
BOOL
DoX86BootStuff(
    IN HWND ParentWindow
    );

BOOL
PatchTextIntoBootCode(
    VOID
    );


VOID
MigrateBootIniData();

//
// Drive information abstraction
//
typedef struct _WINNT32_DRIVE_INFORMATION {
    DWORD       CylinderCount;
    DWORD       HeadCount;
    DWORD       SectorsPerTrack;
    ULONGLONG   SectorCount;
    WORD        BytesPerSector;
} WINNT32_DRIVE_INFORMATION, *PWINNT32_DRIVE_INFORMATION;

//
// Routine to get drive form-factor/type.
//
MEDIA_TYPE
GetMediaType(
    IN TCHAR Drive,
    IN PWINNT32_DRIVE_INFORMATION DriveInfo OPTIONAL
    );

//
// Disk sector I/O routines
//
BOOL
ReadDiskSectors(
    IN  TCHAR  Drive,
    IN  UINT   StartSector,
    IN  UINT   SectorCount,
    IN  UINT   SectorSize,
    OUT LPBYTE Buffer
    );

BOOL
WriteDiskSectors(
    IN TCHAR  Drive,
    IN UINT   StartSector,
    IN UINT   SectorCount,
    IN UINT   SectorSize,
    IN LPBYTE Buffer
    );

BOOL
MarkPartitionActive(
    IN TCHAR DriveLetter
    );

//
// Enum for filesystems we recognize
//
typedef enum {
    Winnt32FsUnknown,
    Winnt32FsFat,
    Winnt32FsFat32,
    Winnt32FsNtfs
} WINNT32_SYSPART_FILESYSTEM;

//
// Hardcoded constant for sector size, and sizes
// of bootcode areas for various filesystems.
//
#define WINNT32_SECTOR_SIZE             512

#define WINNT32_FAT_BOOT_SECTOR_COUNT   1
#define WINNT32_NTFS_BOOT_SECTOR_COUNT  16

#define WINNT32_MAX_BOOT_SIZE           (16*WINNT32_SECTOR_SIZE)

BOOL
PatchBootCode(
    IN      WINNT32_SYSPART_FILESYSTEM  FileSystem,
    IN      TCHAR   Drive,
    IN OUT  PUCHAR  BootCode,
    IN      DWORD   BootCodeSize
    );

#endif //_X86_

//
// ARC/NV-RAM stuff
//

#if defined _IA64_
#define SETUPLDR_FILENAME L"SETUPLDR.EFI"

#elif defined _X86_
#define SETUPLDR_FILENAME L"arcsetup.exe"

#else
#define SETUPLDR_FILENAME L"SETUPLDR"

#endif

BOOL
SetUpNvRam(
    IN HWND ParentWindow
    );

DWORD
DriveLetterToArcPath(
    IN  WCHAR   DriveLetter,
    OUT LPWSTR *ArcPath
    );


//
// Implement a terminalserver-safe GetWindowsDirectory()
//
UINT
MyGetWindowsDirectory(
    LPTSTR  MyBuffer,
    UINT    Size
    );


//
// Upgrade stuff
//

typedef struct _UPGRADE_SUPPORT {
    TCHAR DllPath[MAX_PATH];
    HINSTANCE DllModuleHandle;

    UINT AfterWelcomePageCount;
    LPPROPSHEETPAGE Pages1;

    UINT AfterOptionsPageCount;
    LPPROPSHEETPAGE Pages2;

    UINT BeforeCopyPageCount;
    LPPROPSHEETPAGE Pages3;

    PWINNT32_PLUGIN_INIT_ROUTINE InitializeRoutine;
    PWINNT32_PLUGIN_GETPAGES_ROUTINE GetPagesRoutine;
    PWINNT32_PLUGIN_WRITEPARAMS_ROUTINE WriteParamsRoutine;
    PWINNT32_PLUGIN_CLEANUP_ROUTINE CleanupRoutine;
    PWINNT32_PLUGIN_OPTIONAL_DIRS_ROUTINE OptionalDirsRoutine;

} UPGRADE_SUPPORT, *PUPGRADE_SUPPORT;

extern UPGRADE_SUPPORT UpgradeSupport;

//
// Only check to see if we can upgrade or not.
//
extern BOOL CheckUpgradeOnly;
extern BOOL CheckUpgradeOnlyQ;
extern BOOL UpgradeAdvisorMode;

BOOL
InitializeArcStuff(
    IN HWND Parent
    );

BOOL
ArcInitializeArcStuff(
    IN HWND Parent
    );


//
// Test to see if we're on an ARC based machine

#ifdef UNICODE

#if defined(_X86_)
BOOL
IsArc(
    VOID
    );
#else
#define IsArc() TRUE
#endif

#if defined(EFI_NVRAM_ENABLED)
BOOL
IsEfi(
    VOID
    );
#else
#define IsEfi() FALSE
#endif

VOID
MigrateBootVarData(
    VOID
    );

#else

#define IsArc()                 (FALSE)
#define MigrateBootVarData()

#endif

//
// Build the command console.
//
extern BOOL BuildCmdcons;


#ifdef RUN_SYSPARSE
//
// NoSysparse. Set to true if we don't want to run sysparse.exe
// This hack should be removed before RTM.
//
extern BOOL NoSysparse;
extern PROCESS_INFORMATION piSysparse;
#endif

//
// Internal/undoc'ed stuff
//
extern UINT NumberOfLicensedProcessors;
extern BOOL IgnoreExceptionPackages;

//
// Where to get missing files.
//

extern TCHAR AlternateSourcePath[MAX_PATH];


VOID
InternalProcessCmdLineArg(
    IN LPCTSTR Arg
    );

//
// Get Harddisk BPS
//
ULONG
GetHDBps(
    HANDLE hDisk
    );

#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

#ifdef _X86_
//
// PC-98 stuff
//
VOID
SetAutomaticBootselector(
    VOID
    );

VOID
SetAutomaticBootselectorNT(
    VOID
    );
VOID
SetAutomaticBootselector95(
    VOID
    );

#define ALIGN(p,val)                                        \
                                                            \
    (PVOID)((((ULONG)(p) + (val) - 1)) & (~((val) - 1)))

//
// read/write disk sectors
//
NTSTATUS
SpReadWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer,
    IN     BOOL    Write
    );

#define NEC_WRITESEC    TRUE
#define NEC_READSEC     FALSE

//
// Get WindowsNT System Position
//
UCHAR
GetSystemPosition(
    PHANDLE phDisk,
    PDISK_GEOMETRY SystemMediaInfo
    );

BOOL
IsNEC98(
    VOID
    );

LONG
CalcHiddenSector(
    IN TCHAR SystemPartitionDriveLetter,
    IN SHORT Bps
    );

#endif

//
//  Registry migration stuff
//

//
// Context structure used for generating inf files (infgen.c)
//
#define INFLINEBUFLEN   512

typedef struct _INFFILEGEN {

    TCHAR FileName[MAX_PATH];
    HANDLE FileHandle;

    BOOL SawBogusOp;

    TCHAR LineBuf[INFLINEBUFLEN];
    unsigned LineBufUsed;

} INFFILEGEN, *PINFFILEGEN;


DWORD
InfStart(
    IN  LPCTSTR       InfName,
    IN  LPCTSTR       Directory,
    OUT PINFFILEGEN   *Context
    );

DWORD
InfEnd(
    IN OUT PINFFILEGEN *Context
    );

DWORD
InfCreateSection(
    IN     LPCTSTR      SectionName,
    IN OUT PINFFILEGEN  *Context
    );

DWORD
InfRecordAddReg(
    IN OUT PINFFILEGEN Context,
    IN     HKEY        Key,
    IN     LPCTSTR     Subkey,
    IN     LPCTSTR     Value,       OPTIONAL
    IN     DWORD       DataType,
    IN     PVOID       Data,
    IN     DWORD       DataLength,
    IN     BOOL        SetNoClobberFlag
    );

ULONG
DumpRegKeyToInf(
    IN  PINFFILEGEN InfContext,
    IN  HKEY        PredefinedKey,
    IN  LPCTSTR     FullKeyPath,
    IN  BOOL        DumpIfEmpty,
    IN  BOOL        DumpSubKeys,
    IN  BOOL        SetNoClobberFlag,
    IN  BOOL        DumpNonVolatileKey
    );

DWORD
WriteText(
    IN HANDLE FileHandle,
    IN UINT   MessageId,
    ...
    );


//
//  Unsupported driver migration stuff
//


//
//  Structure used to build a list of files associated to and usupported
//  driver that was detected on the NT system to be upgraded.
//
typedef struct _UNSUPORTED_PNP_HARDWARE_ID {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_PNP_HARDWARE_ID *Next;

    //
    //  String that represents the hardware id of a PNP device.
    //
    LPTSTR Id;

    //
    // Service for the device
    //
    LPTSTR Service;

    //
    // GUID for this device, if any
    //
    LPTSTR ClassGuid;

} UNSUPORTED_PNP_HARDWARE_ID, *PUNSUPORTED_PNP_HARDWARE_ID;


typedef struct _UNSUPORTED_DRIVER_FILE_INFO {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_DRIVER_FILE_INFO *Next;

    //
    //  Pointer to the file name
    //
    LPTSTR FileName;

    //
    // Pointer to the path relative to %SystemRoot% where the file
    // should be installed.
    //
    LPTSTR TargetDirectory;

} UNSUPORTED_DRIVER_FILE_INFO, *PUNSUPORTED_DRIVER_FILE_INFO;


typedef struct _UNSUPORTED_DRIVER_REGKEY_INFO {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_DRIVER_REGKEY_INFO *Next;

    //
    //  A predefined key
    //
    HKEY PredefinedKey;

    //
    //  Path to the key to be migrated, relative to a predefined key.
    //
    LPTSTR KeyPath;

    //
    //  Undicates whether or not volatile keys should be migrated
    //
    BOOL MigrateVolatileKeys;

} UNSUPORTED_DRIVER_REGKEY_INFO, *PUNSUPORTED_DRIVER_REGKEY_INFO;


typedef struct _UNSUPORTED_DRIVER_INFO {

    //
    //  Pointer to the next element in the list
    //
    struct _UNSUPORTED_DRIVER_INFO *Next;

    //
    //  A string that identifies the driver to be migrated (such as aic78xx)
    //
    LPTSTR DriverId;

    //
    //  Points to the list of files associated to the unsupported driver
    //
    PUNSUPORTED_DRIVER_REGKEY_INFO KeyList;

    //
    //  Points to the list of keys associated to the unsupported driver
    //
    PUNSUPORTED_DRIVER_FILE_INFO FileList;

    //
    //  Points to the list of hardware ids associated to the unsupported driver
    //
    PUNSUPORTED_PNP_HARDWARE_ID HardwareIdsList;


} UNSUPORTED_DRIVER_INFO, *PUNSUPORTED_DRIVER_INFO;


//
//  Unsupported driver list
//  This list contains the information about the unsupported drivers that needs
//  to be migrated on a clean install or upgrade.
//
// extern PUNSUPORTED_DRIVER_INFO UnsupportedDriverList;


BOOL
BuildUnsupportedDriverList(
    IN  PVOID                    TxtsetupSifHandle,
    OUT PUNSUPORTED_DRIVER_INFO* DriverList
    );

BOOL
SaveUnsupportedDriverInfo(
    IN HWND                    ParentWindow,
    IN LPTSTR                  FileName,
    IN PUNSUPORTED_DRIVER_INFO DriverList
    );

BOOL
AddUnsupportedFilesToCopyList(
    IN HWND ParentWindow,
    IN PUNSUPORTED_DRIVER_INFO DriverList
    );

BOOL
MigrateUnsupportedNTDrivers(
    IN HWND   ParentWindow,
    IN PVOID  TxtsetupSifHandle
    );


// Error codes and Function to check schema version for NT5 DC Upgrades

#define  DSCHECK_ERR_SUCCESS           0
#define  DSCHECK_ERR_FILE_NOT_FOUND    1
#define  DSCHECK_ERR_FILE_COPY         2
#define  DSCHECK_ERR_VERSION_MISMATCH  3
#define  DSCHECK_ERR_CREATE_DIRECTORY  4

BOOL
ISDC(
    VOID
    );

BOOL
IsNT5DC();

int
CheckSchemaVersionForNT5DCs(
    IN HWND  ParentWnd
    );

//
// Diagnostic/debug functions in debug.c
//

//
// Allow assertion checking to be turned on independently
// of DBG, like by specifying C_DEFINES=-DASSERTS_ON=1 in sources file.
//
#ifndef ASSERTS_ON
#if DBG
#define ASSERTS_ON 1
#else
#define ASSERTS_ON 0
#endif
#endif

#if ASSERTS_ON

#ifndef MYASSERT

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    );

#endif

#else

#define MYASSERT(x)

#endif


#ifdef _X86_

VOID
ProtectAllModules (
    VOID
    );

#endif


BOOL
WriteHeadlessParameters(
    IN LPCTSTR FileName
    );



//
// Setup Log prototypes in setupapi.dll
//

typedef BOOL(WINAPI * SETUPOPENLOG)(BOOL Erase);
typedef BOOL(WINAPI * SETUPLOGERROR)(PCTSTR MessageString, LogSeverity Severity);
typedef VOID(WINAPI * SETUPCLOSELOG)(VOID);

//
// Default throughput (5 KB/msec)
//
#define DEFAULT_IO_THROUGHPUT   (5 * 1024)

extern DWORD dwThroughPutSrcToDest;
extern DWORD dwThroughPutHDToHD;
void CalcThroughput();

// Should allow 1K for strings for localization
#define MAX_STRING 1024

BOOL
SaveAdvancedOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
SaveLanguageOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
SaveAccessibilityOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
LoadAdvancedOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
LoadLanguageOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
LoadAccessibilityOptions (
    IN      PCTSTR AnswerFile
    );

BOOL
AddCopydirIfExists(
    IN LPTSTR pszPathToCopy,
    IN UINT Flags
    );

BOOL
IsNetConnectivityAvailable (
    VOID
    );

BOOL
ValidatePidEx(LPTSTR PID, BOOL *pbStepup, BOOL *bSelect);


#ifdef PRERELEASE
#define TEST_EXCEPTION 1
#endif

#define SETUP_FAULTH_APPNAME "drw\\faulth.dll"
//#define SETUP_URL     "officewatson"
#define SETUP_URL       "watson.microsoft.com"

#define S_WINNT32LOGFILE                TEXT("WINNT32.LOG")
#define S_DEFAULT_NT_COMPAT_FILENAME    TEXT("UPGRADE.TXT")

#ifdef TEST_EXCEPTION
void DoException( DWORD dwSetupArea);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\pidinit\pidinit.c ===
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <direct.h>
#include "crc-32.h"

// length of the string we expect with the /m option
#define RPC_LENGTH 5

// (max) length of the _SUFFIX strings
#define RPC_SUFFIX_LENGTH 3

#define STEPUPFLAG              TEXT("_STEPUP_")
#define BASE                    'a'
#define DEFAULT_RPC	"00000"
#define SELECT_SUFFIX	"270"
#define MSDN_SUFFIX	"335"
#define RETAIL_SUFFIX	"000"
#define OEM_SUFFIX	"OEM"

    
DWORD WINAPI CRC_32(LPBYTE pb, DWORD cb)
{

//		CRC-32 algorithm used in PKZip, AUTODIN II, Ethernet, and FDDI
//		but xor out (xorot) has been changed from 0xFFFFFFFF to 0 so
//		we can store the CRC at the end of the block and expect 0 to be
//		the value of the CRC of the resulting block (including the stored
//		CRC).

	cm_t cmt = {
		32, 		// cm_width  Parameter: Width in bits [8,32].
		0x04C11DB7, // cm_poly	 Parameter: The algorithm's polynomial.
		0xFFFFFFFF, // cm_init	 Parameter: Initial register value.
		TRUE,		// cm_refin  Parameter: Reflect input bytes?
		TRUE,		// cm_refot  Parameter: Reflect output CRC?
		0, // cm_xorot  Parameter: XOR this to output CRC.
		0			// cm_reg	 Context: Context during execution.
	};

	// Documented test case for CRC-32:
	// Checking "123456789" should return 0xCBF43926
                        
	cm_ini(&cmt);
	cm_blk(&cmt, pb, cb);

	return cm_crc(&cmt);
}

VOID GiveUsage() {
    _tprintf(TEXT("pidinit -d <flags> -g <outputname> -m <mpccode> -s[smro] -z -h -?\n"));
    _tprintf(TEXT("writes a signature to <outputname> based on <flags>\n"));
    _tprintf(TEXT("-s (SiteType) s (select) m (msdn) r (retail) o (oem)\n"));
    _tprintf(TEXT("-z (decode)\n"));
    _tprintf(TEXT("-m <mpccode> : mpccode is a 5 digit number\n"));
    _tprintf(TEXT("-h or -? this message\n"));
}

int _cdecl
main(
 int argc,
 char *argvA[]
 ) 
/*++

Routine Description:

    Entry point to the setup program

Arguments:

    argc - Number of args.
    argvA - the commandline arguments.


Return Value:


--*/
{
    LPTSTR *argv;
    int argcount = 0;
    
    long rslt;

    char data[10+4+1] = {0};
    char buf[1000] = {0};

    DWORD value, crcvalue,outval;//,tmp;
    BOOL StepUp = FALSE;
    BOOL decode = FALSE;
    BOOL bMpc = FALSE;

    LPSTR SiteSuffix[] = { SELECT_SUFFIX,
                           MSDN_SUFFIX,
                           RETAIL_SUFFIX,
                           OEM_SUFFIX
                        };

    typedef enum SiteType {
        Select = 0,
        Msdn,
        Retail,
        Oem,        
    } ;

    enum SiteType st = Select;
    int i, randval;

    char *outname = NULL;
    char path[MAX_PATH];
    char *mpcName = NULL;
    char tString[RPC_LENGTH+RPC_SUFFIX_LENGTH+1];
    
    
    // do commandline stuff
#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

    // check for commandline switches
    for (argcount=0; argcount<argc; argcount++) {
       if ((argv[argcount][0] == L'/') || (argv[argcount][0] == L'-')) {
            switch (towlower(argv[argcount][1])) {
            case 'd':
               if (lstrcmpi(&argv[argcount][2],STEPUPFLAG ) == 0) {
                   StepUp = TRUE;
               }
               break;
            case 'g':
                outname = argv[argcount + 1];
                break;
            case 's':
                switch (towlower(argv[argcount+1][0])) {
                    case 's':
                        st = Select;
                        break;
                    case 'm':
                        st = Msdn;
                        break;
                    case 'r':
                        st = Retail;
                        break;
                    case 'o':
                        st = Oem;
                        break;
                    default:
                        st = Select;
                        break;
                }
                break;

            case 'z':
                decode = TRUE;
                break;

	    case 'm':
		bMpc = TRUE;
		mpcName = argv[argcount + 1];
		break;

            case 'h':
            case '?':
               GiveUsage();
               return 1;
               break;                        
            default:
               break;
            }
       }
    }    

    if (!outname) {
        _tprintf(TEXT("you must supply a filename\n"));
        GiveUsage();
        return 1;
    }

    //
    // the decode section is really only for testing
    //
    if (decode) {
        _getcwd ( path, MAX_PATH );
        sprintf( path, "%s\\%s", path, outname );
        GetPrivateProfileStruct(  "Pid",
                                  "ExtraData",
                                  data, 
                                  14,
                                  path
                                  );

        crcvalue = CRC_32( (LPBYTE)data, 10 );
        memcpy(&outval,&data[10],sizeof(DWORD));
        if (crcvalue != outval ) {
            printf("CRC doesn't match %x %x!\n", crcvalue, outval);
            return 1;
        }

        if ((data[3]-BASE)%2) {
            if ((data[5]-BASE)%2) {
                printf("stepup mode\n");
                return 1;
            } else {
                printf("bogus!\n");
                return -1;
            }
        } else 
            if ((data[5]-BASE)%2) {
                printf("bogus!\n");
                return -1;
            } else {
                printf("full retail mode\n");
                return 1;
            }


    }
                                      
    srand( (unsigned)time( NULL ) );      
    
    for (i=0;i< 10; i++ ) {
        randval = rand() ;
        data[i] = BASE + (randval % 26);
    }

    if (StepUp) {
        if (!((data[3]- BASE)%2)) {
           data[3] = data[3] + 1;
        }

        if (!((data[5]- BASE )%2)) {
           data[5] = data[5] + 1;
        }                
    } else {
        if ((data[3]- BASE)%2) {
            data[3] = data[3] + 1;
        }
        if ((data[5]- BASE)%2) {
            data[5] = data[5] + 1;
        }        
    }

    //printf( "data : %s\n" , data );

    crcvalue = CRC_32( (LPBYTE)data, strlen(data) );
    memcpy(&data[10],&crcvalue,4);
    
    _getcwd ( path, MAX_PATH );
    sprintf( path, "%s\\%s", path, outname );

    WritePrivateProfileStruct( "Pid",
                               "ExtraData",
                               data,
                               14,
                               path
                             );


    //
    // Allow another to specify the RPC code
    //
    if (bMpc){
	lstrcpyn(tString,mpcName,RPC_LENGTH+1);
    } else {
        lstrcpyn(tString,DEFAULT_RPC,RPC_LENGTH+1);
    }
    lstrcpy(&tString[RPC_LENGTH],SiteSuffix[st]);
    WritePrivateProfileString( "Pid",
			       "Pid",
			       tString,
			       path
			     );

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\encrypt\encrypt.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    encrypt.c

Abstract:

    Provides a set of functions dealing with OWF hash values of passwords.

Author:

    Ovidiu Temereanca (ovidiut) 14-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include <windows.h>

#include "encrypt.h"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

PSTR
ConvertW2A (
    IN      PCWSTR Unicode,
    IN      UINT CodePage
    )

/*++

Routine Description:

    Converts an UNICODE string to it's ANSI equivalent, using the given codepage.

Arguments:

    Unicode - Specifies the string to be converted
    CodePage - Specifies the code page used for conversion

Return value:

    A pointer to the ANSI string if successful, or NULL on error. Call GetLastError()
    to determine the cause of failure.

--*/

{
    PSTR ansi = NULL;
    DWORD rc;

    rc = WideCharToMultiByte (
             CodePage,
             WC_NO_BEST_FIT_CHARS,
             Unicode,
             -1,
             NULL,
             0,
             NULL,
             NULL
             );

    if (rc || *Unicode == L'\0') {

        ansi = (PSTR)HeapAlloc (GetProcessHeap (), 0, (rc + 1) * sizeof (CHAR));
        if (ansi) {
            rc = WideCharToMultiByte (
                     CodePage,
                     WC_NO_BEST_FIT_CHARS,
                     Unicode,
                     -1,
                     ansi,
                     rc + 1,
                     NULL,
                     NULL
                     );

            if (!(rc || *Unicode == L'\0')) {
                rc = GetLastError ();
                HeapFree (GetProcessHeap (), 0, (PVOID)ansi);
                ansi = NULL;
                SetLastError (rc);
            }
        }
    }

    return ansi;
}


PWSTR
ConvertA2W (
    IN      PCSTR Ansi,
    IN      UINT CodePage
    )

/*++

Routine Description:

    Converts an ANSI string to it's UNICODE equivalent, using the given codepage.

Arguments:

    Ansi - Specifies the string to be converted
    CodePage - Specifies the code page used for conversion

Return value:

    A pointer to the UNICODE string if successful, or NULL on error. Call GetLastError()
    to determine the cause of failure.

--*/

{
    PWSTR unicode = NULL;
    DWORD rc;

    rc = MultiByteToWideChar (
             CodePage,
             MB_ERR_INVALID_CHARS,
             Ansi,
             -1,
             NULL,
             0
             );

    if (rc || *Ansi == '\0') {

        unicode = (PWSTR) HeapAlloc (GetProcessHeap (), 0, (rc + 1) * sizeof (WCHAR));
        if (unicode) {
            rc = MultiByteToWideChar (
                     CodePage,
                     MB_ERR_INVALID_CHARS,
                     Ansi,
                     -1,
                     unicode,
                     rc + 1
                     );

            if (!(rc || *Ansi == '\0')) {
                rc = GetLastError ();
                HeapFree (GetProcessHeap (), 0, (PVOID)unicode);
                unicode = NULL;
                SetLastError (rc);
            }
        }
    }

    return unicode;
}


/*++

Routine Description:

    EncodeLmOwfPassword converts a password to the LM OWF format.

Arguments:

    Password - Specifies the password to be hashed
    OwfPassword - Receives the hash form
    ComplexNtPassword - Receives TRUE if the password is complex (longer than 14 chars);
                        optional

Return value:

    TRUE on successful hashing

--*/

BOOL
EncodeLmOwfPasswordA (
    IN      PCSTR AnsiPassword,
    OUT     PLM_OWF_PASSWORD OwfPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    CHAR oemPassword[LM_PASSWORD_SIZE_MAX];
    CHAR password[LM_PASSWORD_SIZE_MAX];
    BOOL complex;

    if (!AnsiPassword) {
        AnsiPassword = "";
    }

    complex = lstrlenA (AnsiPassword) > LM20_PWLEN;
    if (ComplexNtPassword) {
        *ComplexNtPassword = complex;
    }

    if (complex) {
        password[0] = 0;
    } else {
        lstrcpyA (oemPassword, AnsiPassword);
        CharUpperA (oemPassword);
        CharToOemA (oemPassword, password);
    }

    return CalculateLmOwfPassword (password, OwfPassword);
}

BOOL
EncodeLmOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PLM_OWF_PASSWORD OwfPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    PSTR ansi;
    BOOL b = FALSE;

    if (!Password) {
        Password = L"";
    }

    ansi = ConvertW2A (Password, CP_ACP);
    if (ansi) {
        b = EncodeLmOwfPasswordA (ansi, OwfPassword, ComplexNtPassword);
        HeapFree (GetProcessHeap (), 0, (PVOID)ansi);
    }

    return b;
}


/*++

Routine Description:

    StringEncodeLmOwfPassword converts a password to the LM OWF format, expressed as
    a string of characters (each byte converted to 2 hex digits).

Arguments:

    Password - Specifies the password to be hashed
    EncodedPassword - Receives the hash form, as a string of hex digits
    ComplexNtPassword - Receives TRUE if the password is complex (longer than 14 chars);
                        optional

Return value:

    TRUE on successful hashing

--*/

BOOL
StringEncodeLmOwfPasswordA (
    IN      PCSTR Password,
    OUT     PSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    LM_OWF_PASSWORD owfPassword;
    PBYTE start;
    PBYTE end;
    PSTR dest;

    if (!EncodeLmOwfPasswordA (Password, &owfPassword, ComplexNtPassword)) {
        return FALSE;
    }
    //
    // each byte will be represented as 2 chars, so it will be twice as long
    //
    start = (PBYTE)&owfPassword;
    end = start + sizeof (LM_OWF_PASSWORD);
    dest = EncodedPassword;
    while (start < end) {
        dest += wsprintfA (dest, "%02x", (UINT)(*start));
        start++;
    }

    return TRUE;
}

BOOL
StringEncodeLmOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PWSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    LM_OWF_PASSWORD owfPassword;
    PBYTE start;
    PBYTE end;
    PWSTR dest;

    if (!EncodeLmOwfPasswordW (Password, &owfPassword, ComplexNtPassword)) {
        return FALSE;
    }

    //
    // each byte will be represented as 2 chars, so it will be twice as long
    //
    start = (PBYTE)&owfPassword;
    end = start + sizeof (LM_OWF_PASSWORD);
    dest = EncodedPassword;
    while (start < end) {
        dest += wsprintfW (dest, L"%02x", (UINT)(*start));
        start++;
    }

    return TRUE;
}


/*++

Routine Description:

    EncodeNtOwfPassword converts a password to the NT OWF format.

Arguments:

    Password - Specifies the password to be hashed
    OwfPassword - Receives the hash form

Return value:

    TRUE on successful hashing

--*/

BOOL
EncodeNtOwfPasswordA (
    IN      PCSTR Password,
    OUT     PNT_OWF_PASSWORD OwfPassword
    )
{
    PWSTR unicode;
    BOOL b = FALSE;

    unicode = ConvertA2W (Password, CP_ACP);
    if (unicode) {
        b = EncodeNtOwfPasswordW (unicode, OwfPassword);
        HeapFree (GetProcessHeap (), 0, unicode);
    }

    return b;
}

BOOL
EncodeNtOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PNT_OWF_PASSWORD OwfPassword
    )
{
    NT_PASSWORD pwd;

    if (Password) {
        pwd.Buffer = (PWSTR)Password;
        pwd.Length = (USHORT)lstrlenW (Password) * (USHORT)sizeof (WCHAR);
        pwd.MaximumLength = pwd.Length + (USHORT) sizeof (WCHAR);
    } else {
        ZeroMemory (&pwd, sizeof (pwd));
    }

    return CalculateNtOwfPassword (&pwd, OwfPassword);
}


/*++

Routine Description:

    StringEncodeNtOwfPassword converts a password to the NT OWF format, expressed as
    a string of characters (each byte converted to 2 hex digits).

Arguments:

    Password - Specifies the password to be hashed
    EncodedPassword - Receives the hash form, as a string of hex digits

Return value:

    TRUE on successful hashing

--*/

BOOL
StringEncodeNtOwfPasswordA (
    IN      PCSTR Password,
    OUT     PSTR EncodedPassword
    )
{
    NT_OWF_PASSWORD owfPassword;
    PBYTE start;
    PBYTE end;
    PSTR dest;

    if (!EncodeNtOwfPasswordA (Password, &owfPassword)) {
        return FALSE;
    }
    //
    // each byte will be represented as 2 chars, so it will be twice as long
    //
    start = (PBYTE)&owfPassword;
    end = start + sizeof (NT_OWF_PASSWORD);
    dest = EncodedPassword;
    while (start < end) {
        dest += wsprintfA (dest, "%02x", (UINT)(*start));
        start++;
    }

    return TRUE;
}

BOOL
StringEncodeNtOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PWSTR EncodedPassword
    )
{
    NT_OWF_PASSWORD owfPassword;
    PBYTE start;
    PBYTE end;
    PWSTR dest;

    if (!EncodeNtOwfPasswordW (Password, &owfPassword)) {
        return FALSE;
    }

    //
    // each byte will be represented as 2 chars, so it will be twice as long
    //
    start = (PBYTE)&owfPassword;
    end = start + sizeof (NT_OWF_PASSWORD);
    dest = EncodedPassword;
    while (start < end) {
        dest += wsprintfW (dest, L"%02x", (UINT)(*start));
        start++;
    }

    return TRUE;
}


/*++

Routine Description:

    StringDecodeLmOwfPassword converts a hashed password to the LM OWF format

Arguments:

    EncodedOwfPassword - Specifies the password to be hashed
    OwfPassword - Receives the hash form

Return value:

    TRUE on successful decoding of the string

--*/

BOOL
StringDecodeLmOwfPasswordA (
    IN      PCSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD OwfPassword
    )
{
    DWORD nible;
    PCSTR p;
    PBYTE dest;
    CHAR ch;

    if (lstrlenA (EncodedOwfPassword) != sizeof (LM_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    nible = 0;
    p = EncodedOwfPassword;
    dest = (PBYTE)OwfPassword;
    ch = 0;
    while (*p) {
        if (!((*p >= '0' && *p <= '9') || (*p >= 'a' && *p <= 'f') || (*p >= 'A' && *p <= 'F'))) {
            return FALSE;
        }
        if (*p <= '9') {
            ch |= *p - '0';
        } else if (*p <= 'F') {
            ch |= *p - 'A' + 10;
        } else {
            ch |= *p - 'a' + 10;
        }
        p++;
        nible++;
        if ((nible & 1) == 0) {
            *dest++ = ch;
            ch = 0;
        } else {
            ch <<= 4;
        }
    }

    return TRUE;
}

BOOL
StringDecodeLmOwfPasswordW (
    IN      PCWSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD OwfPassword
    )
{
    DWORD nible;
    PCWSTR p;
    PBYTE dest;
    WCHAR ch;

    if (lstrlenW (EncodedOwfPassword) != sizeof (LM_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    nible = 0;
    p = EncodedOwfPassword;
    dest = (PBYTE)OwfPassword;
    ch = 0;
    while (*p) {
        if (!((*p >= L'0' && *p <= L'9') || (*p >= L'a' && *p <= L'f') || (*p >= L'A' && *p <= L'F'))) {
            return FALSE;
        }
        if (*p <= L'9') {
            ch |= *p - L'0';
        } else if (*p <= L'F') {
            ch |= *p - L'A' + 10;
        } else {
            ch |= *p - L'a' + 10;
        }
        p++;
        nible++;
        if ((nible & 1) == 0) {
            *dest++ = (BYTE)ch;
            ch = 0;
        } else {
            ch <<= 4;
        }
    }

    return TRUE;
}


/*++

Routine Description:

    StringDecodeNtOwfPassword converts a hashed password to the NT OWF format

Arguments:

    EncodedOwfPassword - Specifies the password to be hashed
    OwfPassword - Receives the hash form

Return value:

    TRUE on successful decoding of the string

--*/

BOOL
StringDecodeNtOwfPasswordA (
    IN      PCSTR EncodedOwfPassword,
    OUT     PNT_OWF_PASSWORD OwfPassword
    )
{
    DWORD nible;
    PCSTR p;
    PBYTE dest;
    CHAR ch;

    if (lstrlenA (EncodedOwfPassword) != sizeof (NT_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    nible = 0;
    p = EncodedOwfPassword;
    dest = (PBYTE)OwfPassword;
    ch = 0;
    while (*p) {
        if (!((*p >= '0' && *p <= '9') || (*p >= 'a' && *p <= 'f') || (*p >= 'A' && *p <= 'F'))) {
            return FALSE;
        }
        if (*p <= '9') {
            ch |= *p - '0';
        } else if (*p <= 'F') {
            ch |= *p - 'A' + 10;
        } else {
            ch |= *p - 'a' + 10;
        }
        p++;
        nible++;
        if ((nible & 1) == 0) {
            *dest++ = ch;
            ch = 0;
        } else {
            ch <<= 4;
        }
    }

    return TRUE;
}

BOOL
StringDecodeNtOwfPasswordW (
    IN      PCWSTR EncodedOwfPassword,
    OUT     PNT_OWF_PASSWORD OwfPassword
    )
{
    DWORD nible;
    PCWSTR p;
    PBYTE dest;
    WCHAR ch;

    if (lstrlenW (EncodedOwfPassword) != sizeof (NT_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    nible = 0;
    p = EncodedOwfPassword;
    dest = (PBYTE)OwfPassword;
    ch = 0;
    while (*p) {
        if (!((*p >= L'0' && *p <= L'9') || (*p >= L'a' && *p <= L'f') || (*p >= L'A' && *p <= L'F'))) {
            return FALSE;
        }
        if (*p <= L'9') {
            ch |= *p - L'0';
        } else if (*p <= L'F') {
            ch |= *p - L'A' + 10;
        } else {
            ch |= *p - L'a' + 10;
        }
        p++;
        nible++;
        if ((nible & 1) == 0) {
            *dest++ = (BYTE)ch;
            ch = 0;
        } else {
            ch <<= 4;
        }
    }

    return TRUE;
}


/*++

Routine Description:

    StringEncodeOwfPassword converts a password to its hashed format, expressed as
    a string of characters (each byte converted to 2 hex digits). The result is
    obtained joining the 2 substrings, one representing LM OWF and the other NT OWF

Arguments:

    Password - Specifies the password to be hashed
    EncodedPassword - Receives the hash form, as a string of hex digits; the buffer
                      MUST be at least STRING_ENCODED_PASSWORD_SIZE chars (including nul)
    ComplexNtPassword - Receives TRUE if the password is complex (longer than 14 chars);
                        optional

Return value:

    TRUE on successful hashing

--*/

BOOL
StringEncodeOwfPasswordA (
    IN      PCSTR Password,
    OUT     PSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    return StringEncodeLmOwfPasswordA (Password, EncodedPassword, ComplexNtPassword) &&
           StringEncodeNtOwfPasswordA (Password, EncodedPassword + STRING_ENCODED_LM_OWF_PWD_LENGTH);
}

BOOL
StringEncodeOwfPasswordW (
    IN      PCWSTR Password,
    OUT     PWSTR EncodedPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    return StringEncodeLmOwfPasswordW (Password, EncodedPassword, ComplexNtPassword) &&
           StringEncodeNtOwfPasswordW (Password, EncodedPassword + STRING_ENCODED_LM_OWF_PWD_LENGTH);
}


/*++

Routine Description:

    StringDecodeOwfPassword decodes a password's LM OWF and NT OWF forms from its hashed format,
    expressed as a string of hex digits.

Arguments:

    EncodedOwfPassword - Specifies the password to be hashed
    LmOwfPassword - Receives the LM OWF hash form
    NtOwfPassword - Receives the NT OWF hash form
    ComplexNtPassword - Receives TRUE if the password is complex (longer than 14 chars);
                        optional

Return value:

    TRUE on successful hashing

--*/

BOOL
StringDecodeOwfPasswordA (
    IN      PCSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD LmOwfPassword,
    OUT     PNT_OWF_PASSWORD NtOwfPassword,
    OUT     PBOOL ComplexNtPassword             OPTIONAL
    )
{
    PSTR p;
    CHAR ch;
    BOOL b;
    CHAR buffer[sizeof (LM_OWF_PASSWORD) * 2 + sizeof (NT_OWF_PASSWORD) * 2 + 2];
    LM_OWF_PASSWORD lmNull;
    NT_OWF_PASSWORD ntNull;

    if (lstrlenA (EncodedOwfPassword) != sizeof (LM_OWF_PASSWORD) * 2 + sizeof (NT_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    lstrcpyA (buffer, EncodedOwfPassword);
    //
    // split the string in two
    //
    p = buffer + (sizeof (LM_OWF_PASSWORD) * 2);

    ch = *p;
    *p = 0;
    b = StringDecodeLmOwfPasswordA (EncodedOwfPassword, LmOwfPassword);
    *p = ch;

    if (b) {
        b = StringDecodeNtOwfPasswordA (p, NtOwfPassword);
    }

    if (b && ComplexNtPassword) {
        b = EncodeLmOwfPasswordA ("", &lmNull, NULL) && EncodeNtOwfPasswordA ("", &ntNull);
        if (b) {
            //
            // it's a complex password if the LM hash is for NULL pwd
            // but NT hash it's not
            //
            *ComplexNtPassword = CompareLmPasswords (LmOwfPassword, &lmNull) == 0 &&
                                 CompareNtPasswords (NtOwfPassword, &ntNull) != 0;
        }
    }

    return b;
}

BOOL
StringDecodeOwfPasswordW (
    IN      PCWSTR EncodedOwfPassword,
    OUT     PLM_OWF_PASSWORD LmOwfPassword,
    OUT     PNT_OWF_PASSWORD NtOwfPassword,
    OUT     PBOOL ComplexNtPassword                 OPTIONAL
    )
{
    PWSTR p;
    WCHAR ch;
    BOOL b;
    WCHAR buffer[sizeof (LM_OWF_PASSWORD) * 2 + sizeof (NT_OWF_PASSWORD) * 2 + 2];
    LM_OWF_PASSWORD lmNull;
    NT_OWF_PASSWORD ntNull;

    if (lstrlenW (EncodedOwfPassword) != sizeof (LM_OWF_PASSWORD) * 2 + sizeof (NT_OWF_PASSWORD) * 2) {
        return FALSE;
    }

    lstrcpyW (buffer, EncodedOwfPassword);
    //
    // split the string in two
    //
    p = buffer + (sizeof (LM_OWF_PASSWORD) * 2);

    ch = *p;
    *p = 0;
    b = StringDecodeLmOwfPasswordW (buffer, LmOwfPassword);
    *p = ch;

    if (b) {
        b = StringDecodeNtOwfPasswordW (p, NtOwfPassword);
    }

    if (b && ComplexNtPassword) {
        b = EncodeLmOwfPasswordW (L"", &lmNull, NULL) && EncodeNtOwfPasswordW (L"", &ntNull);
        if (b) {
            //
            // it's a complex password if the LM hash is for NULL pwd
            // but NT hash it's not
            //
            *ComplexNtPassword = CompareLmPasswords (LmOwfPassword, &lmNull) == 0 &&
                                 CompareNtPasswords (NtOwfPassword, &ntNull) != 0;
        }
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\section.h ===
#ifndef __SECTION_H_
#define __SECTION_H_

#include <windows.h>
#include <vector>
#include <string>
#include <map>
#include <iostream>

extern "C" {
#include <compliance.h>
}

using namespace std;

class ComplianceFile;

//
// This class represents a section in the compliance
// data file
//
class Section {
public:
  Section(const string &name, const vector<string>& lines,
          const ComplianceFile& file) : m_file(file) {
    m_name = name;
    m_lines = lines;
  }

  Section(const Section& rhs) : m_file(rhs.m_file){
    *this = rhs;
  }

  virtual ~Section() {}
  
  //
  // accessors
  //
  const string& name() const { return m_name; }
  const vector<string>& lines() const { return m_lines; }
  const ComplianceFile& file() const{ return m_file; }
  
  //
  // parses the section content
  //
  virtual void parse() {}

  //
  // exceptions which methods of this class
  // can throw
  //
  struct SectionException {
    SectionException(const string& sectionName) : m_name(sectionName) {}

    string m_name;

    friend ostream& operator<<(ostream& os, const struct SectionException& rhs) {
      os << "Exception : Section Error : " << rhs.m_name;
      return os;
    }
  };

  struct InvalidSectionFormat : public SectionException {
    InvalidSectionFormat(const string& sectionName) : SectionException(sectionName) {}

    friend ostream& operator<<(ostream& os, const struct InvalidSectionFormat& rhs) {
      os << "Exception : Invalid Section Format : " << rhs.m_name;
      return os;
    }
  };

  struct InvalidSectionName : public SectionException {
    InvalidSectionName(const string &sectionName) : SectionException(sectionName) {}

    friend ostream& operator<<(ostream& os, const struct InvalidSectionName &rhs) {
      os << "Exception : Invalid Section Name : " << rhs.m_name;
      return os;
    }
  };

  struct InvalidMedia : public SectionException {
    InvalidMedia(const string &sectionName) : SectionException(sectionName) {}

    friend ostream& operator<<(ostream& os, const struct InvalidMedia &rhs) {
      os << "Exception : Invalid Media : " << rhs.m_name;
      return os;
    }
  };

  //
  // overloaded operators
  //
  Section& operator=(const Section& rhs) {
    m_name = rhs.m_name;
    m_lines = rhs.m_lines;

    return *this;
  }
    
protected:
  //
  // data members
  //
  string                m_name;
  vector<string>        m_lines;
  const ComplianceFile& m_file;
};


//
// This class represents a value section in the compliance
// data file
//
class ValueSection : public Section {
public:
  ValueSection(const string& name, const vector<string>& lines,
      const ComplianceFile& file) : Section(name, lines, file) {
    parse();
  }

  //
  // parse the section and create <name, value> pairs
  //
  virtual void parse();

  unsigned long value(const string &key) const{
    map<string, unsigned long>::const_iterator  iter = m_values.find(key);

    if (iter == m_values.end())
      throw ValueNotFound(name(), key);

    return (*iter).second;
  }

  //
  // exceptions which can be thrown by the methods
  // of this class
  //
  struct ValueNotFound : public Section::SectionException {
    ValueNotFound(const string& name, const string &valname) :
        SectionException(name), m_valname(valname){}

    string m_valname;

    friend ostream& operator<<(ostream& os, const struct ValueNotFound& rhs) {
      os << "Exception : Value " << rhs.m_valname << " was not found in "
         << rhs.m_name;
      return os;
    }
  };

protected:
  //
  // data members
  //
  map<string, unsigned long>  m_values;
};

//
// this class represents a single test case in an test
// section
//
class TestCase {
public:
  TestCase(const Section& section, const string& line) :
      m_section(section), m_line(line) {
  }

  virtual ~TestCase() {}

  //
  // accessors
  //
  const string& line() const { return m_line; }
  const Section& section() const { return m_section; }

  virtual void parse() = 0;
  virtual void execute(ostream &os) = 0;
  virtual bool passed() = 0;
  virtual void dump(ostream& os) = 0;
  bool mediamatched() { return m_mediamatched;};

  //
  // exceptions
  //
  struct InvalidFormat {
    InvalidFormat(const string& line, const string& section) {
      m_line = line;
      m_section = section;
    };

    string m_section, m_line;

    friend ostream& operator<<(ostream& os, const struct InvalidFormat& rhs) {
      os << "Exception : Invalid Test Case : " << rhs.m_line << " in section : "
         << rhs.m_section;
      return os;
    }
  };

protected:
  //
  // data members
  //
  const Section&  m_section;
  string          m_line;
  bool            m_mediamatched;
};

//
// this class represents a test case (single line
// in an test section) 
//
class ComplianceTestCase : public TestCase {
public:
  ComplianceTestCase(const Section& section, const string& line) :
      TestCase(section, line) {
    ::memset(&m_cd, 0, sizeof(COMPLIANCE_DATA));
    m_passed = false;
    m_allowUpgrade = false;
    parse();
  }

  virtual void execute(ostream &os);
  virtual bool passed();
  virtual void parse();
  virtual void dump(ostream& os);

protected:
  void sourceDetails();
  void installationDetails(const vector<string>& tokens);

  //
  // data members
  //
  bool            m_passed;
  COMPLIANCE_DATA m_cd;
  unsigned long   m_sourceSKU;
  unsigned long   m_sourceVAR;
  unsigned long   m_sourceVer;
  unsigned long   m_sourceBuild;
  bool            m_expectedResult;
  UINT            m_reason;
  BOOL            m_noUpgrade;
  bool            m_allowUpgrade;
  UINT            m_errExpected;
};

//
// default factory to create test cases
//
class TestCaseFactory {
public:
  virtual TestCase* create(const Section& section, const string& line) const {
    TestCase *pTestCase = new ComplianceTestCase(section, line);    
    return pTestCase;
  }

  virtual TestCase* create(const TestCase& tc) const {
    return create(tc.section(), tc.line());
  }
};


//
// this class represents the test section in the compliance
// data file
//
class TestSection : public Section {
public:
  TestSection(const string& name, const vector<string>& lines,
      const ComplianceFile& file) : Section(name, lines, file){
    bindFactory();
    parse();
  }
  
  ~TestSection() {
    vector<TestCase*>::iterator iter = m_testCases.begin();

    while (iter != m_testCases.end())
      delete (*iter++);

    delete m_tcFactory;
  }

  TestSection& operator=(const TestSection& rhs);

  void executeTestCases(ostream& os);

  //
  // accessors
  //
//  const vector<TestCase *> testCases() const{ return m_testCases; }
  const TestCaseFactory& testCaseFactory() const{ return *m_tcFactory; }

  void parse();

protected:
  void bindFactory() {
    m_tcFactory = new TestCaseFactory();
  }

  //
  // data members
  //
  vector<TestCase *>  m_testCases;
  TestCaseFactory     *m_tcFactory;
};


//
// default factory to create sections
//
class SectionFactory {
public:
  virtual Section* create(const string& name, 
            const vector<string>& lines, const ComplianceFile& file) const {
    return new Section(name, lines, file);
  }

  virtual Section* create(const Section& section) const {
    return create(section.name(), section.lines(), section.file());
  }
};


//
// current factory to create sections
//
class OldFormatSectionFactory : public SectionFactory {
public:
  virtual Section* create(const string& name, 
                const vector<string>& lines, const ComplianceFile& file) const {
    if (name.find("[test#") != name.npos)
      return new TestSection(name, lines, file);
    else if (name.find("#values]") != name.npos)
      return new ValueSection(name, lines, file);
    else
      return new Section(name, lines, file);
  }
};


#endif // for __SECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\encrypt\pch.h ===
#include <windows.h>
#include "encrypt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\encrypt\owf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    owf.c

Abstract:

    Implentation of the one-way-functions used to implement password hashing.

        CalculateLmOwfPassword
        CalculateNtOwfPassword

Author:

    David Chalmers (Davidc) 10-21-91
    David Arnold (DavidAr) 12-15-93 (Adapted for WfW RPC SSP)

Revision History:

--*/

#include <windows.h>
#include <descrypt.h>
#include <md4.h>

#include "encrypt.h"


BOOL
CalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )

/*++

Routine Description:

    Takes the passed LmPassword and performs a one-way-function on it.
    The current implementation does this by using the password as a key
    to encrypt a known block of text.

Arguments:

    LmPassword - The password to perform the one-way-function on.

    LmOwfPassword - The hashed password is returned here

Return Values:

    TRUE - The function was completed successfully. The hashed
    password is in LmOwfPassword.

    FALSE - Something failed. The LmOwfPassword is undefined.
--*/

{
    char StdEncrPwd[] = "KGS!@#$%";
    BLOCK_KEY    Key[2];
    PCHAR       pKey;

    // Copy the password into our key buffer and zero pad to fill the 2 keys

    pKey = (PCHAR)(&Key[0]);

    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {
        *pKey++ = *LmPassword++;
    }

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }


    // Use the keys to encrypt the standard text

    if (DES_ECB_LM(ENCR_KEY,
                   (unsigned char *)&Key[0],
                   (unsigned char *)StdEncrPwd,
                   (unsigned char *)&LmOwfPassword->data[0]
                   ) != CRYPT_OK) {

        return (FALSE);
    }

    if (DES_ECB_LM(ENCR_KEY,
                   (unsigned char *)&Key[1],
                   (unsigned char *)StdEncrPwd,
                   (unsigned char *)&LmOwfPassword->data[1]
                   ) != CRYPT_OK) {

        return (FALSE);
    }

    //
    // clear our copy of the cleartext password
    //

    pKey = (PCHAR)(&Key[0]);

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    return(TRUE);
}


BOOL
CalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )

/*++

Routine Description:

    Takes the passed NtPassword and performs a one-way-function on it.
    Uses the RSA MD4 function

Arguments:

    NtPassword - The password to perform the one-way-function on.

    NtOwfPassword - The hashed password is returned here

Return Values:

    TRUE - The function was completed successfully. The hashed
           password is in NtOwfPassword.
--*/

{
    MD4_CTX     MD4_Context;


    MD4Init(&MD4_Context);

    MD4Update(&MD4_Context, (PCHAR)NtPassword->Buffer, NtPassword->Length);

    MD4Final(&MD4_Context);

    if (sizeof(*NtOwfPassword) != sizeof(MD4_Context.digest)) {
        return(FALSE);
    }

    memcpy((PVOID)NtOwfPassword, (PVOID)MD4_Context.digest, sizeof(*NtOwfPassword));

    return(TRUE);
}

INT
CompareLmPasswords (
    IN      PLM_OWF_PASSWORD LmOwfPassword1,
    IN      PLM_OWF_PASSWORD LmOwfPassword2
    )

/*++

Routine Description:

    Compares 2 LM OWF passwords.

Arguments:

    LmOwfPassword1 - The first password to compare

    LmOwfPassword2 - The second password to compare

Return Values:

    0 if they are equal, -1 if first is smaller (regarded as a string of bytes),
    1 if first is greater

--*/

{
    PBYTE p1 = (PBYTE)LmOwfPassword1;
    PBYTE p2 = (PBYTE)LmOwfPassword2;
    DWORD size = sizeof (LM_OWF_PASSWORD);
    CHAR diff;

    while (size--) {
        diff = *p1++ - *p2++;
        if (diff) {
            return (INT)diff;
        }
    }
    return 0;
}

INT
CompareNtPasswords (
    IN      PNT_OWF_PASSWORD NtOwfPassword1,
    IN      PNT_OWF_PASSWORD NtOwfPassword2
    )

/*++

Routine Description:

    Compares 2 NT OWF passwords.

Arguments:

    NtOwfPassword1 - The first password to compare

    NtOwfPassword2 - The second password to compare

Return Values:

    0 if they are equal, -1 if first is smaller (regarded as a string of bytes),
    1 if first is greater

--*/

{
    PBYTE p1 = (PBYTE)NtOwfPassword1;
    PBYTE p2 = (PBYTE)NtOwfPassword2;
    DWORD size = sizeof (NT_OWF_PASSWORD);
    CHAR diff;

    while (size--) {
        diff = *p1++ - *p2++;
        if (diff) {
            return (INT)diff;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\encrypt\setpwd.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    setpwd.c

Abstract:

    Sets a user's password based on OWF password hash strings
    Calls SamiChangePasswordUser with encoded passwords.

Author:

    Ovidiu Temereanca   17-Mar-2000     Initial implementation

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntsamp.h>
//#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
//#include <lmcons.h>
#include <align.h>
//#include <lm.h>
//#include <limits.h>
//#include <rpcutil.h>
//#include <secobj.h>
//#include <stddef.h>
//#include <ntdsapi.h>
//#include <dsgetdc.h>
#include <windows.h>

#include "encrypt.h"



NTSTATUS
pGetDomainId (
    IN      SAM_HANDLE ServerHandle,
    OUT     PSID* DomainId
    )

/*++

Routine Description:

    Return a domain ID of the account domain of a server.

Arguments:

    ServerHandle - A handle to the SAM server to open the domain on

    DomainId - Receives a pointer to the domain ID.
                Caller must deallocate buffer using SamFreeMemory.

Return Value:

    Error code for the operation.

--*/

{
    NTSTATUS status;
    SAM_ENUMERATE_HANDLE EnumContext;
    PSAM_RID_ENUMERATION EnumBuffer = NULL;
    DWORD CountReturned = 0;
    PSID LocalDomainId = NULL;
    BYTE LocalBuiltinDomainSid[sizeof(SID) + SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)];
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    BOOL b = FALSE;
    ULONG i;

    //
    // Compute the builtin domain sid.
    //
    RtlInitializeSid((PSID) LocalBuiltinDomainSid, &BuiltinAuthority, 1);
    *(RtlSubAuthoritySid((PSID)LocalBuiltinDomainSid,  0)) = SECURITY_BUILTIN_DOMAIN_RID;

    //
    // Loop getting the list of domain ids from SAM
    //
    EnumContext = 0;
    do {

        //
        // Get several domain names.
        //
        status = SamEnumerateDomainsInSamServer (
                            ServerHandle,
                            &EnumContext,
                            &EnumBuffer,
                            8192,
                            &CountReturned
                             );

        if (!NT_SUCCESS (status)) {
            goto exit;
        }

        if (status != STATUS_MORE_ENTRIES) {
            b = TRUE;
        }

        //
        // Lookup the domain ids for the domains
        //

        for(i = 0; i < CountReturned; i++) {

            //
            // Free the sid from the previous iteration.
            //
            if (LocalDomainId != NULL) {
                SamFreeMemory (LocalDomainId);
                LocalDomainId = NULL;
            }

            //
            // Lookup the domain id
            //
            status = SamLookupDomainInSamServer (
                            ServerHandle,
                            &EnumBuffer[i].Name,
                            &LocalDomainId
                            );

            if (!NT_SUCCESS (status)) {
                goto exit;
            }

            if (RtlEqualSid ((PSID)LocalBuiltinDomainSid, LocalDomainId)) {
                continue;
            }

            *DomainId = LocalDomainId;
            LocalDomainId = NULL;
            status = NO_ERROR;
            goto exit;
        }

        SamFreeMemory(EnumBuffer);
        EnumBuffer = NULL;

    } while (!b);

    status = ERROR_NO_SUCH_DOMAIN;

exit:
    if (EnumBuffer != NULL) {
        SamFreeMemory(EnumBuffer);
    }

    return status;
}


DWORD
pSamOpenLocalUser (
    IN      PCWSTR UserName,
    IN      ACCESS_MASK DesiredAccess,
    IN      PSAM_HANDLE DomainHandle,
    OUT     PSAM_HANDLE UserHandle
    )

/*++

Routine Description:

    Returns a user handle given its name, desired access and a domain handle.

Arguments:

    UserName - Specifies the user name

    DesiredAccess - Specifies the desired access to this user

    DoaminHandle - A handle to the domain to open the user on

    UserHandle - Receives a user handle.
                 Caller must free the handle using SamCloseHandle.

Return Value:

    Error code for the operation.

--*/

{
    DWORD status;
    UNICODE_STRING uniUserName;
    ULONG rid, *prid;
    PSID_NAME_USE nameUse;

    //
    // Lookup the RID
    //
    RtlInitUnicodeString (&uniUserName, UserName);

    status = SamLookupNamesInDomain (
               DomainHandle,
               1,
               &uniUserName,
               &prid,
               &nameUse
               );
    if (status != NO_ERROR) {
        return status;
    }

    //
    // Save the RID
    //
    rid = *prid;

    //
    // free the memory.
    //
    SamFreeMemory (prid);
    SamFreeMemory (nameUse);

    //
    // Open the user object.
    //
    status = SamOpenUser(
                DomainHandle,
                DesiredAccess,
                rid,
                UserHandle
                );

    return status;
}


DWORD
SetLocalUserEncryptedPassword (
    IN      PCWSTR User,
    IN      PCWSTR OldPassword,
    IN      BOOL OldIsEncrypted,
    IN      PCWSTR NewPassword,
    IN      BOOL NewIsEncrypted
    )

/*++

Routine Description:

    Sets a new password for the given user. The password is in encrypted format (see encrypt.h for details).

Arguments:

    User - Specifies the user name

    OldPassword - Specifies the old password
    OldIsEncrypted - Specifies TRUE if old password is provided in encrypted form
                   or FALSE if it's in clear text
    OldIsComplex - Specifies TRUE if old password is complex; used only if OldIsEncrypted is TRUE,
                   otherwise it's ignored.
    NewPassword - Specifies the new password
    NewIsEncrypted - Specifies TRUE if new password is provided in encrypted form
                     or FALSE if it's in clear text

Return Value:

    Win32 error code for the operation.

--*/

{
    DWORD status;
    LM_OWF_PASSWORD lmOwfOldPwd;
    NT_OWF_PASSWORD ntOwfOldPwd;
    BOOL complexOldPassword;
    LM_OWF_PASSWORD lmOwfNewPwd;
    NT_OWF_PASSWORD ntOwfNewPwd;
    UNICODE_STRING unicodeString;
    PSID serverHandle = NULL;
    PSID sidAccountsDomain = NULL;
    SAM_HANDLE handleAccountsDomain = NULL;
    SAM_HANDLE handleUser = NULL;

    if (!User) {
        return ERROR_INVALID_PARAMETER;
    }

    if (OldIsEncrypted) {
        if (!StringDecodeOwfPasswordW (OldPassword, &lmOwfOldPwd, &ntOwfOldPwd, &complexOldPassword)) {
            return ERROR_INVALID_PARAMETER;
        }
    } else {
        if (!EncodeLmOwfPasswordW (OldPassword, &lmOwfOldPwd, &complexOldPassword) ||
            !EncodeNtOwfPasswordW (OldPassword, &ntOwfOldPwd)
            ) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if (NewIsEncrypted) {
        if (!StringDecodeOwfPasswordW (NewPassword, &lmOwfNewPwd, &ntOwfNewPwd, NULL)) {
            return ERROR_INVALID_PARAMETER;
        }
    } else {
        if (!EncodeLmOwfPasswordW (NewPassword, &lmOwfNewPwd, NULL) ||
            !EncodeNtOwfPasswordW (NewPassword, &ntOwfNewPwd)
            ) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    __try {
        //
        // Use SamConnect to connect to the local domain ("")
        // and get a handle to the local SAM server
        //
        RtlInitUnicodeString (&unicodeString, L"");
        status = SamConnect (
                    &unicodeString,
                    &serverHandle,
                    SAM_SERVER_LOOKUP_DOMAIN | SAM_SERVER_ENUMERATE_DOMAINS,
                    NULL
                    );
        if (status != NO_ERROR) {
            __leave;
        }

        status = pGetDomainId (serverHandle, &sidAccountsDomain);
        if (status != NO_ERROR) {
            __leave;
        }

        //
        // Open the domain.
        //
        status = SamOpenDomain (
                    serverHandle,
                    DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS,
                    sidAccountsDomain,
                    &handleAccountsDomain
                    );
        if (status != NO_ERROR) {
            __leave;
        }

        status = pSamOpenLocalUser (
                    User,
                    USER_CHANGE_PASSWORD,
                    handleAccountsDomain,
                    &handleUser
                    );
        if (status != NO_ERROR) {
            __leave;
        }

        status = SamiChangePasswordUser (
                    handleUser,
                    !complexOldPassword,
                    &lmOwfOldPwd,
                    &lmOwfNewPwd,
                    TRUE,
                    &ntOwfOldPwd,
                    &ntOwfNewPwd
                    );
    }
    __finally {
        if (handleUser) {
            SamCloseHandle (handleUser);
        }
        if (handleAccountsDomain) {
            SamCloseHandle (handleAccountsDomain);
        }
        if (sidAccountsDomain) {
            SamFreeMemory (sidAccountsDomain);
        }
        if (serverHandle) {
            SamCloseHandle (serverHandle);
        }
    }

    return RtlNtStatusToDosError (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\excppkg\register.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    register.c

Abstract:

    Implementation of exception package migration registration.
    
    An exception package consists is a setupapi package that can be installed
    on the system.  The package consists of an exception INF, a catalog file, 
    and the corresponding files for the package.  All files in this package 
    must be signed.  The catalog is signed and contains signatures for all 
    other files in the catalog (including the INF).
    
    Packages to be migrated from downlevel systems are registered with the
    following APIs in this module.  The APIs simply validate that the package
    is put together properly and stores migration information in the registry
    in a well-known location.
    
    The data is stored under the following key:
    
    Software\Microsoft\Windows\CurrentVersion\Setup\ExceptionComponents
    
    There is one subkey corresponding to the GUID for each component.
    The data for each component is then stored under this key.
    
    In addition, the toplevel key has a "ComponentList" REG_EXPAND_SZ, which
    lists the order in which the components should be enumerated.
    
    Note that the following code only uses common system APIs instead of 
    any pre-defined library routines.  This is to ensure that this library can
    run on downlevel systems without any odd dependencies.

Author:

    Andrew Ritz (AndrewR) 21-Oct-1999

Revision History:

    Andrew Ritz (andrewr) 21-Oct-1999 : Created It

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <setupapi.h>
#include <ole2.h>
#include <excppkg.h>

#define COMPONENT_KEY  L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\ExceptionComponents"
#define COMPONENT_LIST L"ComponentList"

#define EXCEPTION_CLASS_GUID L"{F5776D81-AE53-4935-8E84-B0B283D8BCEF}"

#define COMPONENT_FRIENDLY_NAME L"FriendlyName"
#define COMPONENT_GUID          L"ComponentGUID"
#define COMPONENT_VERSION       L"Version"
#define COMPONENT_SUBVERSION    L"Sub-Version"
#define EXCEPTION_INF_NAME      L"ExceptionInfName"
#define EXCEPTION_CATALOG_NAME  L"ExceptionCatalogName"

#define MALLOC(_size_)  HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, _size_ )
#define FREE(_ptr_)     HeapFree( GetProcessHeap(), 0 , _ptr_ )


typedef struct _COMPONENT_ENUMERATION_LIST {
    LPGUID InputComponentList;
    DWORD  ComponentCount;
    DWORD  ValidatedCount;
    PDWORD ComponentVector;
} COMPONENT_ENUMERATION_LIST, *PCOMPONENT_ENUMERATION_LIST;
    

BOOL
WINAPI
_SetupSetRegisteredOsComponentsOrder(
    IN  DWORD    ComponentCount,
    IN  const LPGUID   ComponentList,
    IN  BOOL     DoValidation
    );

BOOL
pSetComponentData(
    IN HKEY hKey,
    IN const PSETUP_OS_COMPONENT_DATA ComponentData
    )
/*++

Routine Description:

    Set's the data in the SETUP_OS_COMPONENT_DATA structure in the
    registry at the specified registry key

Arguments:

    hKey          - registry key specifying location to insert data at 
    ComponentData - specifies the data to be set in the registry
    

Return Value:

    TRUE if the data was successfully set in the registry.

--*/
{
    LONG rslt;
    BOOL RetVal;
    DWORD value;
    PWSTR GuidString;

    //
    // just set the data, assume that it's already been validated
    //

    //
    // FriendlyName
    //
    rslt = RegSetValueEx( 
                    hKey, 
                    COMPONENT_FRIENDLY_NAME,
                    0,
                    REG_SZ,
                    (CONST PBYTE)ComponentData->FriendlyName,
                    (wcslen(ComponentData->FriendlyName)+1)*sizeof(WCHAR));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e0;
    }


    StringFromIID( &ComponentData->ComponentGuid, &GuidString );
    
    //
    // ComponentGUID
    //
    rslt = RegSetValueEx( 
                    hKey, 
                    COMPONENT_GUID,
                    0,
                    REG_SZ,
                    (CONST PBYTE)GuidString,
                    (wcslen(GuidString)+1)*sizeof(WCHAR));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e1;
    }    

    //
    // Version
    //
    value = MAKELONG( ComponentData->VersionMinor, ComponentData->VersionMajor );
    rslt = RegSetValueEx( 
                    hKey, 
                    COMPONENT_VERSION,
                    0,
                    REG_DWORD,
                    (CONST PBYTE)&value,
                    sizeof(DWORD));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e1;
    }

    //
    // build+QFE
    //
    value = MAKELONG( ComponentData->QFENumber, ComponentData->BuildNumber );
    rslt = RegSetValueEx( 
                    hKey, 
                    COMPONENT_SUBVERSION,
                    0,
                    REG_DWORD,
                    (CONST PBYTE)&value,
                    sizeof(DWORD));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e1;
    }

    RetVal = TRUE;

e1:
    CoTaskMemFree( GuidString );
e0:
    return(RetVal);
}

BOOL
pGetComponentData(
    IN HKEY hKey,
    IN const PSETUP_OS_COMPONENT_DATA ComponentData
    )
/*++

Routine Description:

    Retreives the data in the SETUP_OS_COMPONENT_DATA structure in the
    registry at the specified registry key

Arguments:

    hKey          - registry key specifying location to insert data at 
    ComponentData - specifies the data to be set in the registry
    

Return Value:

    TRUE if the data was successfully retreived.

--*/
{
    LONG rslt;
    BOOL RetVal;
    DWORD Type,Size;
    DWORD Version;
    DWORD SubVersion;
    WCHAR GuidString[40];

    //
    // FriendlyName
    //
    Size = sizeof(ComponentData->FriendlyName);
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_FRIENDLY_NAME,
                    0,
                    &Type,
                    (LPBYTE)ComponentData->FriendlyName,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e0;
    }

    if (Type != REG_SZ) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e1;
    }

    //
    // ComponentGUID
    //
    Size = sizeof(GuidString);
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_GUID,
                    0,
                    &Type,
                    (LPBYTE)GuidString,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e1;
    }

    if (Type != REG_SZ) {    
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e1;
    }
    

    if (IIDFromString( GuidString, &ComponentData->ComponentGuid ) != S_OK) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e1;
    }


    //
    // Version
    //
    Size = sizeof(Version);
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_VERSION,
                    0,
                    &Type,
                    (LPBYTE)&Version,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e2;
    }

    if (Type != REG_DWORD) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e2;
    }

    ComponentData->VersionMajor = HIWORD(Version);
    ComponentData->VersionMinor = LOWORD(Version);

    //
    // Sub-Version
    //
    Size = sizeof(SubVersion);
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_SUBVERSION,
                    0,
                    &Type,
                    (LPBYTE)&SubVersion,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e3;
    }

    if (Type != REG_DWORD) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e3;
    }

    ComponentData->BuildNumber = HIWORD(SubVersion);
    ComponentData->QFENumber  = LOWORD(SubVersion);

    RetVal = TRUE;
    goto e0;

e3:
    ComponentData->VersionMajor = 0;
    ComponentData->VersionMinor = 0;
e2:
    ZeroMemory(
            &ComponentData->ComponentGuid, 
            sizeof(ComponentData->ComponentGuid));
e1:
    ComponentData->FriendlyName[0] = L'0';
e0:
    return(RetVal);
}

BOOL
pSetExceptionData(
    IN HKEY hKey,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    )
/*++

Routine Description:

    Set's the data in the SETUP_OS_EXCEPTION_DATA structure in the
    registry at the specified registry key

Arguments:

    hKey          - registry key specifying location to insert data at 
    ComponentData - specifies the data to be set in the registry
    

Return Value:

    TRUE if the data is successfully stored in the registry.

--*/
{
    LONG rslt;
    BOOL RetVal;

    //
    // just set the data, assume that it's already been validated
    //

    //
    // InfName
    //
    rslt = RegSetValueEx( 
                    hKey, 
                    EXCEPTION_INF_NAME,
                    0,
                    REG_EXPAND_SZ,
                    (CONST PBYTE)ExceptionData->ExceptionInfName,
                    (wcslen(ExceptionData->ExceptionInfName)+1)*sizeof(WCHAR));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e0;
    }

    //
    // CatalogName
    //
    rslt = RegSetValueEx( 
                    hKey, 
                    EXCEPTION_CATALOG_NAME,
                    0,
                    REG_EXPAND_SZ,
                    (CONST PBYTE)ExceptionData->CatalogFileName,
                    (wcslen(ExceptionData->CatalogFileName)+1)*sizeof(WCHAR));

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e0;
    }

    RetVal = TRUE;

e0:
    return(RetVal);
}

BOOL
pGetExceptionData(
    IN HKEY hKey,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    )
/*++

Routine Description:

    Retreives the data in the SETUP_OS_EXCEPTION_DATA structure in the
    registry at the specified registry key

Arguments:

    hKey          - registry key specifying location to insert data at 
    ComponentData - specifies the data to be set in the registry
    

Return Value:

    TRUE if the data is successfully retreived from the registry.

--*/
{
    LONG rslt;
    BOOL RetVal;
    DWORD Type,Size;
    WCHAR Buffer[MAX_PATH];

    //
    // InfName
    //
    Size = sizeof(Buffer);
    rslt = RegQueryValueEx( 
                    hKey, 
                    EXCEPTION_INF_NAME,
                    0,
                    &Type,
                    (LPBYTE)Buffer,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e0;
    }

    if (Type != REG_EXPAND_SZ) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e0;
    }

    if (!ExpandEnvironmentStrings(
                Buffer,
                ExceptionData->ExceptionInfName,
                sizeof(ExceptionData->ExceptionInfName)/sizeof(WCHAR))) {
        RetVal = FALSE;
        goto e0;
    }

    //
    // Catalog Name
    //
    Size = sizeof(Buffer);
    rslt = RegQueryValueEx( 
                    hKey, 
                    EXCEPTION_CATALOG_NAME,
                    0,
                    &Type,
                    (LPBYTE)Buffer,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError(rslt);
        RetVal = FALSE;
        goto e1;
    }

    if (Type != REG_EXPAND_SZ) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e1;
    }

    if(!ExpandEnvironmentStrings(
                Buffer,
                ExceptionData->CatalogFileName,
                sizeof(ExceptionData->CatalogFileName)/sizeof(WCHAR))) {
        RetVal = FALSE;
        goto e1;
    }

    RetVal = TRUE;
    goto e0;


e1:
    ExceptionData->ExceptionInfName[0] = L'0';
e0:
    return(RetVal);

}


BOOL
WINAPI
SetupRegisterOsComponent(
    IN const PSETUP_OS_COMPONENT_DATA ComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    )
/*++

Routine Description:

    Registers the specified component as a exception migration component.
    
    This function does validation of the package, trying to assert that the
    package has a good probability of succeeding installation.  It then
    records the data about the package in the registry.
    

Arguments:

    ComponentData - specifies the component identification data
    ExceptionData - specifies the exception package identification data        
    
Return Value:

    TRUE if the component is successfully registered with the operating system.

--*/
{
    BOOL RetVal;
    HKEY hKey,hKeyComponent;
    LONG rslt;
    HINF hInf;
    DWORD ErrorLine;
    INFCONTEXT InfContext;
    WCHAR InfComponentGuid[64];
    PWSTR InputGuidString;
    WCHAR InfName[MAX_PATH];
    WCHAR CatalogName[MAX_PATH];
    WCHAR InfCatName[MAX_PATH];
    DWORD Disposition;

    DWORD ComponentCount;
    DWORD Size;
    PWSTR p;
    LPGUID ComponentList;

    //
    // parameter validation
    //
    if (!ComponentData || !ExceptionData) {
        SetLastError(ERROR_INVALID_PARAMETER);
        RetVal = FALSE;
        goto e0;
    }

    //
    // make sure we only register a component for a revision level 
    // which we understand.
    //
    if ((ComponentData->SizeOfStruct != sizeof(SETUP_OS_COMPONENT_DATA)) || 
        (ExceptionData->SizeOfStruct != sizeof(SETUP_OS_EXCEPTION_DATA))) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e0;
    }

    //
    // All of the parameters in the structure are required
    //
    if (!*ComponentData->FriendlyName || 
        !*ExceptionData->ExceptionInfName || !*ExceptionData->CatalogFileName) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e0;
    }

    //
    // Make sure that the INF and catalog are both present.
    //
    ExpandEnvironmentStrings(
                    ExceptionData->ExceptionInfName,
                    InfName,
                    sizeof(InfName)/sizeof(WCHAR));

    ExpandEnvironmentStrings(
                    ExceptionData->CatalogFileName,
                    CatalogName,
                    sizeof(CatalogName)/sizeof(WCHAR));

    if (GetFileAttributes(InfName) == -1 ||
        GetFileAttributes(CatalogName) == -1) {
        SetLastError(ERROR_FILE_NOT_FOUND);
        RetVal = FALSE;
        goto e0;
    }

    //
    // open the INF to do some validation
    //
    hInf = SetupOpenInfFile( InfName, 
                             NULL, //EXCEPTION_CLASS_GUID,
                             INF_STYLE_WIN4,
                             &ErrorLine);

    if (hInf == INVALID_HANDLE_VALUE) {
        // return last error code from setupopeninffile
        RetVal = FALSE;
        goto e0;
    }

    //
    // Make sure the class GUID matches the expected exception class
    // class GUID.
    //
    if (!SetupFindFirstLine(
                    hInf,
                    L"Version",
                    L"ClassGUID",
                    &InfContext)) {
        RetVal = FALSE;
        goto e1;
    }

    if (!SetupGetStringField(
                    &InfContext,
                    1,
                    InfComponentGuid,
                    sizeof(InfComponentGuid) / sizeof(InfComponentGuid[0]),
                    &ErrorLine)) {
        RetVal = FALSE;
        goto e1;
    }

    if (_wcsicmp(EXCEPTION_CLASS_GUID, InfComponentGuid)) {
        SetLastError(ERROR_INVALID_CLASS);
        RetVal = FALSE;
        goto e1;
    }

    //
    // Make sure that the INF component ID matches the supplied GUID
    //
    if (!SetupFindFirstLine(
                    hInf,
                    L"Version",
                    L"ComponentId", 
                    &InfContext)) {
        RetVal = FALSE;
        goto e1;
    }

    if (!SetupGetStringField(
                    &InfContext,
                    1,
                    InfComponentGuid,
                    sizeof(InfComponentGuid) / sizeof(InfComponentGuid[0]),
                    &ErrorLine)) {
        RetVal = FALSE;
        goto e1;
    }

    StringFromIID( &ComponentData->ComponentGuid, &InputGuidString );

    if (_wcsicmp(InfComponentGuid, InputGuidString)) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e2;
    }

    //
    // Make sure the INF has a catalogfile= line, and that this line matches
    // the specified catalog file
    //
    //
    if (!SetupFindFirstLine(
                    hInf,
                    L"Version",
                    L"CatalogFile", 
                    &InfContext)) {        
        RetVal = FALSE;
        goto e2;
    }

    if (!SetupGetStringField(
                    &InfContext,
                    1,
                    InfCatName,
                    sizeof(InfCatName) / sizeof(InfCatName[0]),
                    &ErrorLine)) {
        RetVal = FALSE;
        goto e2;
    }

    p = wcsrchr( CatalogName, L'\\' );
    if (p) {
        p += 1;
    } else {
        p = CatalogName;
    }

    if (_wcsicmp(p, InfCatName)) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e2;
    }


    //
    // Everything seems to validate.  Try to add the new component.
    //

    //
    // Before we try to add the component, get the list of existing components 
    // so we can set the component in the list of components.
    // 
    Size = 0;
    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    NULL
                                    )) {
        RetVal = FALSE;
        goto e2;
    }

    ComponentList = (LPGUID)MALLOC((ComponentCount+1)*sizeof(GUID));
    if (!ComponentList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RetVal = FALSE;
        goto e2;
    }

    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    ComponentList)) {
        RetVal = FALSE;
        goto e3;
    }
    
    //
    // put the new component at the tail of the component list (since this is
    // a zero-based array, this is easy to insert).
    //
    RtlMoveMemory(
            &ComponentList[ComponentCount],
            &ComponentData->ComponentGuid,
            sizeof(ComponentData->ComponentGuid));
    
    //
    // First open the main key which all components live under
    //
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,                
                &hKey,
                &Disposition);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e3;
    }

    //
    // now look at the actual key we'll store this component under
    //
    rslt = RegCreateKeyEx(
                hKey,
                InputGuidString,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKeyComponent,
                &Disposition);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e4;
    } 
    
    //
    // If this component is already registered, then bail
    //
    if (Disposition != REG_CREATED_NEW_KEY) {
        SetLastError(ERROR_ALREADY_EXISTS);
        RetVal = FALSE;
        goto e5;
    }

    //
    // The key is created, now set all of the data under the key
    //
    if (!pSetComponentData(hKeyComponent, ComponentData) ||
        !pSetExceptionData(hKeyComponent, ExceptionData)) {
        //
        // if we failed, we need to delete everything under this key
        //
        rslt = GetLastError();
        RegDeleteKey( hKey, InputGuidString );
        SetLastError(rslt);
        RetVal = FALSE;
        goto e5;
    }    

    //
    // now set the component order in the registry
    //
    if (!_SetupSetRegisteredOsComponentsOrder(
                                    ComponentCount+1,
                                    ComponentList,
                                    FALSE)) {
        rslt = GetLastError();
        RegDeleteKey( hKey, InputGuidString );
        SetLastError(rslt);
        RetVal = FALSE;
        goto e5;
    }

    RetVal = TRUE;
        
e5:
    RegCloseKey(hKeyComponent);
e4:    
    RegCloseKey(hKey);
e3:
    FREE(ComponentList);
e2:
    CoTaskMemFree(InputGuidString);
e1:
    SetupCloseInfFile(hInf);
e0:
    return(RetVal);

}


BOOL
WINAPI
SetupUnRegisterOsComponent(
    IN const LPGUID ComponentGuid
    )
/*++

Routine Description:

    De-Registers the specified component as a exception migration component.
    
    This function only removes the exception package data from the registry.
    It does not remove any on-disk files which correspond with the migration
    component data.
    

Arguments:

    ComponentData - specifies the component identification data
    ExceptionData - specifies the exception package identification data        
    
Return Value:

    TRUE if the component is successfully registered with the operating system.

--*/
{
    HKEY hKey;
    LONG rslt;
    BOOL RetVal;
    DWORD Disposition;
    DWORD Size,ComponentCount;
    PWSTR GuidString;
    LPGUID ComponentList,NewList,src,dst;
    DWORD i;

    //
    // parameter validation
    //
    if (!ComponentGuid) {
        SetLastError(ERROR_INVALID_PARAMETER);
        RetVal = FALSE;
        goto e0;
    }

    StringFromIID( ComponentGuid, &GuidString );
    
    //
    // open the main component key where all of the subcomponents live
    //
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &Disposition);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e0;
    }

    //
    // query the component order list so that we can remove this component
    // from the list
    //
    Size = 0;
    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    NULL)) {
        RetVal = FALSE;
        goto e1;
    }

    ComponentList = (LPGUID)MALLOC((ComponentCount)*sizeof(GUID));
    if (!ComponentList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RetVal = FALSE;
        goto e1;
    }

    NewList = (LPGUID)MALLOC((ComponentCount)*sizeof(GUID));
    if (!NewList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RetVal = FALSE;
        goto e2;
    }

    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    ComponentList)) {
        RetVal = FALSE;
        goto e3;
    }

    if (ComponentCount) {    
        //
        // Iterate through the list of components, keeping all of the components
        // except for the one we're removing.
        //
        BOOL FoundEntry;
        src = ComponentList;
        dst = NewList;
        i = 0;
        FoundEntry = FALSE;
        while(i < ComponentCount) {
            if (!IsEqualGUID(src,ComponentGuid)) {
                RtlMoveMemory(dst,src,sizeof(GUID));
                dst = dst + 1;
            } else {
                FoundEntry = TRUE;
            }
    
            src = src + 1;
            i +=1;
        }

        if (!FoundEntry) {
            SetLastError(ERROR_FILE_NOT_FOUND);
            RetVal = FALSE;
            goto e3;
        }
    
        if (!_SetupSetRegisteredOsComponentsOrder(
                                        ComponentCount-1,
                                        NewList,
                                        FALSE)) {
            RetVal = FALSE;
            goto e3;
        }
    }

    //
    // Delete the key corresponding to the specified component.
    //
    rslt = RegDeleteKey( hKey, GuidString );
    if (rslt != ERROR_SUCCESS) {
        //
        // If this fails, we don't bother to put the component back in the list
        //
        SetLastError( rslt );
        RetVal = FALSE;
        goto e3;
    }

    RetVal = TRUE;

e3:
    FREE(NewList);
e2:
    FREE(ComponentList);
e1:
    RegCloseKey( hKey );
e0:
    return(RetVal);
}


BOOL
WINAPI
SetupEnumerateRegisteredOsComponents(
    IN PSETUPCOMPONENTCALLBACK SetupOsComponentCallback,
    IN DWORD_PTR Context
    )
/*++

Routine Description:

    This function calls the specified callback function once for each
    registered component.  The registered components are enumerated in
    the order defined by the "ComponentList".
    
    The enumeration stops if the enumerator returns FALSE or when all
    of the installed packages have been enumerated.        

Arguments:

    SetupOsComponentCallback - specifies a callback function which is called 
              once for each component.
    Context - specifies an opaque context point passed onto the callback
              function
              
The callback is of the form:
    
typedef BOOL
(CALLBACK *PSETUPCOMPONENTCALLBACK) (
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    );
    
    where
    
    SetupOsComponentData - specifies the component identification data for the 
                           component
    SetupOsExceptionData - specifies the exception package data for the 
                           component
    Context              - the context pointer passed into this function is passed
                           into the callback function
    
Return Value:

    TRUE if all of the components are enumerated.  If the callback stops
    enumeration, the function returns FALSE and GetLastError() returns 
    ERROR_CANCELLED.

--*/
{   
    BOOL    RetVal;
    LONG    rslt;
    HKEY    hKey;
    HKEY    hKeyEnum = NULL;
    DWORD   Index = 0;
    DWORD   Disposition;
    WCHAR   SubKeyName[100];
    DWORD   Size;
    DWORD   ComponentCount = 0;
    LPGUID  ComponentList;

    SETUP_OS_EXCEPTION_DATA OsExceptionDataInternal;
    SETUP_OS_COMPONENT_DATA OsComponentDataInternal;

    //
    // Caller must supply a callback
    //
    if (!SetupOsComponentCallback) {
        SetLastError(ERROR_INVALID_PARAMETER);
        RetVal = FALSE;
        goto e0;
    }

    //
    // open the main component key where all of the subcomponents live
    // (Note that we only require READ access)
    //
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,
                NULL,
                &hKey,
                &Disposition);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e0;
    }


    //
    // query the component order list so that we can remove this component
    // from the list
    //
    Size = 0;
    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    NULL)) {
        RetVal = FALSE;
        goto e1;
    }

    if (!ComponentCount) {
        SetLastError(ERROR_NO_MORE_ITEMS);
        RetVal = TRUE;
        goto e1;
    }

    ComponentList = (LPGUID)MALLOC(ComponentCount*sizeof(GUID));
    if (!ComponentList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RetVal = FALSE;
        goto e1;
    }

    if (!SetupQueryRegisteredOsComponentsOrder(
                                    &ComponentCount,
                                    ComponentList)) {
        RetVal = FALSE;
        goto e2;
    }

    //
    // Iterate through the list of components, calling into the callback
    // for each one
    //
    for (Index = 0; Index < ComponentCount; Index++) {
        PWSTR GuidString;

        StringFromIID( &ComponentList[Index], &GuidString );

        //
        // open that key name
        //
        rslt = RegOpenKeyEx(
                    hKey,
                    GuidString,
                    0,
                    KEY_READ,
                    &hKeyEnum);

        CoTaskMemFree( GuidString );

        if (rslt != ERROR_SUCCESS) {
            SetLastError( rslt );
            RetVal = FALSE;
            goto e2;
        } 
        
        //
        // retreive the data under this key
        //
        OsComponentDataInternal.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
        OsExceptionDataInternal.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
        if (!pGetComponentData(hKeyEnum, &OsComponentDataInternal) ||
            !pGetExceptionData(hKeyEnum, &OsExceptionDataInternal)) {
            RetVal = FALSE;
            goto e3;
        } 
        
        if (!SetupOsComponentCallback( 
                            &OsComponentDataInternal, 
                            &OsExceptionDataInternal,
                            Context )) {
            SetLastError(ERROR_CANCELLED);
            RetVal = FALSE;
            goto e3;
        }

        RegCloseKey( hKeyEnum );
        hKeyEnum = NULL;

    }

    RetVal = TRUE;

e3:
    if (hKeyEnum) {
        RegCloseKey( hKeyEnum );
    }
e2:
    FREE( ComponentList );
e1:
    RegCloseKey( hKey );
e0:
    return(RetVal);
}
    

BOOL
WINAPI
SetupQueryRegisteredOsComponent(
    IN LPGUID ComponentGuid,
    OUT PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    OUT PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData
    )
/*++

Routine Description:

    Retrieves information about the specified component.
    
Arguments:

    ComponentGuid - specifies the GUID for the component to retreive data about
    ComponentData - receives the component identification data
    ExceptionData - receives the exception package identification data        
    
Return Value:

    TRUE if the component data is successfully retreieved.

--*/
{
    HKEY hKey,hKeyComponent;
    LONG rslt;
    BOOL RetVal;
    DWORD Disposition;
    SETUP_OS_EXCEPTION_DATA OsExceptionDataInternal;
    SETUP_OS_COMPONENT_DATA OsComponentDataInternal;
    PWSTR GuidString;

    //
    // parameter validation
    //
    if (!ComponentGuid || !SetupOsComponentData || !SetupOsExceptionData) {
        SetLastError(ERROR_INVALID_PARAMETER);
        RetVal = FALSE;
        goto e0;
    }

    //
    // make sure we only retreive a component for a revision level
    // which we understand
    //
    if (SetupOsComponentData->SizeOfStruct > sizeof(SETUP_OS_COMPONENT_DATA) || 
        SetupOsExceptionData->SizeOfStruct > sizeof(SETUP_OS_EXCEPTION_DATA)) {
        SetLastError(ERROR_INVALID_DATA);
        RetVal = FALSE;
        goto e0;
    }

    //
    // open the main component key where all of the subcomponents live
    // (note that we only need READ access)
    //
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,
                NULL,
                &hKey,
                &Disposition);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e0;
    }

    StringFromIID( ComponentGuid, &GuidString );

    //
    // now look at the actual key this component lives under
    //
    rslt = RegOpenKeyEx(
                hKey,
                GuidString,
                0,
                KEY_READ,
                &hKeyComponent);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e1;
    } 
    
    //
    // retrieve the data into internal buffers
    //
    OsComponentDataInternal.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    OsExceptionDataInternal.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    if (!pGetComponentData(hKeyComponent, &OsComponentDataInternal) ||
        !pGetExceptionData(hKeyComponent, &OsExceptionDataInternal)) {
        RetVal = FALSE;
        goto e2;
    }

    //
    // move the data into the caller supplied buffer, but only copy as much 
    // data as the caller will understand
    //
    RtlMoveMemory(SetupOsComponentData,&OsComponentDataInternal,SetupOsComponentData->SizeOfStruct);
    RtlMoveMemory(SetupOsExceptionData,&OsExceptionDataInternal,SetupOsExceptionData->SizeOfStruct);
    

    RetVal = TRUE;
e2:
    RegCloseKey( hKeyComponent );
e1:
    CoTaskMemFree( GuidString );
    RegCloseKey( hKey );
e0:
    return(RetVal);
}



BOOL
WINAPI
SetupQueryRegisteredOsComponentsOrder(
     OUT PDWORD   ComponentCount,
     OUT LPGUID   ComponentList OPTIONAL
    )
/*++

Routine Description:

    Retrieves a list which specifies the order in which components will be applied.
    
Arguments:

    ComponentCount - Receives the number of installed components
    ComponentList  - This buffer receives an array of component GUIDs.  If 
                     this parameter is specified, it must be at least
                     )ComponentCount *sizeof(GUID)) bytes large.
    
Return Value:

    TRUE if the component ordering data is successfully retreieved.

--*/
{
    HKEY hKey;
    LONG rslt;
    BOOL RetVal;
    DWORD Disposition;
    DWORD Type,Size;
    DWORD Count;
    GUID  CurrentGuid;
    DWORD Index;
    PWSTR RegData;
    PWSTR p;
    

    //
    // parameter validation
    //
    if (!ComponentCount) {
        SetLastError(ERROR_INVALID_PARAMETER);
        RetVal = FALSE;
        goto e0;
    }

    //
    // open the main component key where the component order list lives.
    // (note that we only need READ access)
    //
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,
                NULL,
                &hKey,
                &Disposition);
    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e0;
    }

    //
    // if the key was just created, then there can be no registered components
    //
    if (Disposition == REG_CREATED_NEW_KEY) {
        *ComponentCount = 0;
        SetLastError( ERROR_SUCCESS );
        RetVal = TRUE;
        goto e1;
    }

    //
    // try to access the registry value, seeing how much space we need for the
    // component;
    //
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_LIST,
                    0,
                    &Type,
                    (LPBYTE)NULL,
                    &Size);

    if (rslt != ERROR_SUCCESS) {
        if (rslt == ERROR_FILE_NOT_FOUND) {
            *ComponentCount = 0;        
            SetLastError( ERROR_SUCCESS );
            RetVal = TRUE;
            goto e1;
        } else {
            SetLastError( rslt );
            RetVal = FALSE;
            goto e1;
        }
    }

    //
    // allocate enough space to retrieve the data (plus some slop)
    //
    RegData = (PWSTR) MALLOC(Size+4);
    if (!RegData) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        RetVal = TRUE;
        goto e1;
    }
    
    //
    // Now query the data
    //
    rslt = RegQueryValueEx( 
                    hKey, 
                    COMPONENT_LIST,
                    0,
                    &Type,
                    (LPBYTE)RegData,
                    &Size);
    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e2;
    }

    //
    // Count how many registry entries we have
    //
    Count = 0;
    p = RegData;
    while(*p) {
        p += wcslen(p)+1;
        Count += 1;
    }

    *ComponentCount = Count;

    //
    // if the caller didn't specify the ComponentList parameter, they just 
    // wanted to know how much space to allocate, so we're done.
    //
    if (!ComponentList) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        RetVal = TRUE;
        goto e2;
    }

    //
    // loop through the component list again, converting the string GUID
    // into a GUID structure, and copy this into the caller supplied buffer
    //
    for(Index = 0,p=RegData; Index < Count ; Index++,p += wcslen(p)+1) {
        if (IIDFromString( p, &CurrentGuid ) != S_OK) {
            RetVal = FALSE;
            goto e2;
        }

        RtlMoveMemory(&ComponentList[Index],&CurrentGuid,sizeof(GUID));
    }

    RetVal = TRUE;

e2:
    FREE( RegData );
e1:
    RegCloseKey( hKey );
e0:
    return(RetVal);
}


BOOL
CALLBACK
pComponentListValidator(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
{
    PCOMPONENT_ENUMERATION_LIST cel = (PCOMPONENT_ENUMERATION_LIST) Context;
    
    DWORD i;

    i = 0;
    //
    // make sure that each component GUID is in our list once.
    //
    while(i < cel->ComponentCount) {
        if (IsEqualGUID(
                &SetupOsComponentData->ComponentGuid,
                &cel->InputComponentList[i])) {
            //
            // if the vector is already set, this means that the GUID
            // is already in the list and we've hit a dup.
            //
            if(cel->ComponentVector[i]) {
                return(FALSE);
            }
            cel->ComponentVector[i] = 1;
            cel->ValidatedCount += 1;
            break;
        }
        i += 1;        
    }
    
    return(TRUE);
}
    

BOOL
WINAPI
_SetupSetRegisteredOsComponentsOrder(
    IN  DWORD    ComponentCount,
    IN  const LPGUID   ComponentList,
    IN  BOOL     DoValidation
    )
/*++

Routine Description:

    Allows the caller to specify the order in which components should be 
    applied.
    
    This is an internal call that allows us to control whether or not we do
    parameter validation (We don't validate parameters on internal calls 
    because we are adding or removing components in internal calls and our
    validation checks will all be off by one.)
    
Arguments:

    ComponentCount - specifies the component order (by GUID). 
    ComponentList - specifies the number of registered components
    DoValidation  - specifies whether the component list should be validated
    
    
Return Value:

    TRUE if the component order is successfully changed.

--*/
{
    HKEY hKey;
    LONG rslt;
    BOOL RetVal;
    DWORD Disposition;
    DWORD Type,Size;
    DWORD Count;
    PWSTR RegData,p,GuidString;
    COMPONENT_ENUMERATION_LIST cel;

    cel.ComponentVector = NULL;

    if (DoValidation) {
        DWORD ActualComponentCount;

        //
        // parameter validation
        //
        if (!ComponentCount || !ComponentList) {
            SetLastError(ERROR_INVALID_PARAMETER);
            RetVal = FALSE;
            goto e0;
        }

        //
        // Make sure that the specified list contains all of the components and 
        // that all components are only listed once.
        //
        cel.InputComponentList = ComponentList;
        cel.ComponentCount = ComponentCount;
        cel.ValidatedCount = 0;
        cel.ComponentVector = MALLOC( ComponentCount * sizeof(DWORD));
        if (!cel.ComponentVector) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            RetVal = FALSE;
            goto e0;
        }

        RtlZeroMemory( cel.ComponentVector, ComponentCount * sizeof(DWORD));
    
        if (!SetupEnumerateRegisteredOsComponents( pComponentListValidator, (DWORD_PTR)&cel)) {
            SetLastError(ERROR_INVALID_DATA);
            RetVal = FALSE;
            goto e1;
        }
        
        if (cel.ValidatedCount != ComponentCount) {
            SetLastError(ERROR_INVALID_DATA);
            RetVal = FALSE;
            goto e1;
        }

        //
        // make sure that the caller is specifying the actual number of
        // registered components
        //
        if (!SetupQueryRegisteredOsComponentsOrder(&ActualComponentCount, NULL) ||
            ActualComponentCount != ComponentCount) {
            SetLastError(ERROR_INVALID_DATA);
            RetVal = FALSE;
            goto e1;
        }

    }


    //
    // open the main component key where the component order list lives.
    //     
    rslt = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                COMPONENT_KEY,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &Disposition);
    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e1;
    }


    //
    // if the count is zero, we remove the value.
    //
    if (ComponentCount == 0) {
        rslt = RegDeleteValue(
                        hKey,
                        COMPONENT_LIST);

        SetLastError( rslt );
        RetVal = (rslt == ERROR_SUCCESS);
        goto e2;
    }

    //
    // allocate space for the string we will set in the registry
    // size = (# of components * (40 WCHAR for GuidString + 1 for NULL)
    //        +terminating NULL)
    //
    RegData = (PWSTR) MALLOC( sizeof(WCHAR) + 
                              (ComponentCount * (41*sizeof(WCHAR))) );
    if (!RegData) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        RetVal = FALSE;
        goto e2;
    }

    Size = 0;
    for (Count = 0,p = RegData; Count < ComponentCount; Count++) {
    
        HRESULT hr = StringFromIID( &ComponentList[Count], &GuidString );

        if(FAILED(hr)) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            RetVal = FALSE;
            goto e3;
        }

        wcscpy( p, GuidString );
        Size += (wcslen(p)+1)*sizeof(WCHAR);
        p += wcslen(p)+1;

        CoTaskMemFree( GuidString );

    }

    //
    // add in one more character for the double-null terminator
    //
    Size += sizeof(WCHAR);

    //
    // now set the data
    //
    rslt = RegSetValueEx( 
                    hKey, 
                    COMPONENT_LIST,
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)RegData,
                    Size);

    if (rslt != ERROR_SUCCESS) {
        SetLastError( rslt );
        RetVal = FALSE;
        goto e3;        
    }

    RetVal = TRUE;

e3:
    FREE( RegData );
e2:
    RegCloseKey( hKey );
e1:
    if (cel.ComponentVector) {
        FREE( cel.ComponentVector );
    }
e0:
    return(RetVal);
}



BOOL
WINAPI
SetupSetRegisteredOsComponentsOrder(
     IN  DWORD    ComponentCount,
     IN  const LPGUID   ComponentList
    )
/*++

Routine Description:

    Allows the caller to specify the order in which components should be applied.
    
Arguments:

    ComponentCount - specifies the component order (by string GUID) in a NULL 
                     separated list
    ComponentList - specifies the number of registered components
    
    
Return Value:

    TRUE if the component order is successfully changed.

--*/
{
    return(_SetupSetRegisteredOsComponentsOrder(
                                    ComponentCount,
                                    ComponentList,
                                    TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\excppkg\test\test.c ===
#include <windows.h>
#include <setupapi.h>
#include <spapip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ole2.h>
#include <excppkg.h>

#define MYPACKAGE_GUID       L"{0e25c565-2fcc-4dcb-8e3e-4378a024c50e}"
#define PACKAGE_DIRECTORY    L"%windir%\\RegisteredPackages\\"

#define PACKAGE_CAT          L"exception.cat"
#define PACKAGE_INF          L"exception.inf"
#define PACKAGE_CAB          L"exception.cab"
        


BOOL
CALLBACK
pComponentLister(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
{
    PDWORD Count = (PDWORD) Context;
    PWSTR GuidString;

    StringFromIID(&SetupOsComponentData->ComponentGuid, &GuidString);

    wprintf( L"Component Data\n\tName: %ws\n\tGuid: %ws\n\tVersionMajor: %d\n\tVersionMinor: %d\n",
             SetupOsComponentData->FriendlyName,
             GuidString,
             SetupOsComponentData->VersionMajor,
             SetupOsComponentData->VersionMinor);

    wprintf( L"ExceptionData\n\tInf: %ws\n\tCatalog: %ws\n",
             SetupOsExceptionData->ExceptionInfName,
             SetupOsExceptionData->CatalogFileName);

    *Count += 1;

    CoTaskMemFree( GuidString );

    return(TRUE);
}

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    WCHAR Path[MAX_PATH];
    SETUP_OS_COMPONENT_DATA ComponentData,cd;
    SETUP_OS_EXCEPTION_DATA ExceptionData,ed;
    PWSTR s,t;
    GUID MyGuid;
    PWSTR GuidString;

    WCHAR SourcePath[MAX_PATH];
    PCWSTR FileList[] = {PACKAGE_INF,PACKAGE_CAT,PACKAGE_CAB};
    #define FileListCount (sizeof(FileList)/sizeof(PCWSTR))
    DWORD i;




    
    //
    // 1. Make sure my package isn't already installed.
    //
    ComponentData.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    ExceptionData.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    IIDFromString( MYPACKAGE_GUID, &MyGuid);
    if (SetupQueryRegisteredOsComponent(
                                &MyGuid,
                                &ComponentData,
                                &ExceptionData)) {
        wprintf(L"My component is already registered with the OS, removing it!\n");
        if (!SetupUnRegisterOsComponent(&MyGuid)) {
            wprintf(L"couldn't remove my component, ec = %d\n", GetLastError());
            return 1;

        }        
    }
        
    //
    // 2. unregister any packages that are superceded by my package
    //

    //
    // 3. Install my package
    //
    //
    // 3a. copy my exception package to the appropriate location
    //

    //
    // 3a.1 make sure the main package directory exists
    // 
    ExpandEnvironmentStrings(
                    PACKAGE_DIRECTORY,
                    Path,
                    sizeof(Path)/sizeof(WCHAR));

    CreateDirectory( Path, NULL );

    //
    // 3a.2 now create my package directory
    //
    wcscat( Path, MYPACKAGE_GUID );

    CreateDirectory( Path, NULL );

    
    //
    // 3a.3 now copy the bits to this location
    //
    wcscat( Path, L"\\" );
    t = wcsrchr( Path, L'\\' );
    t += 1;

    ExpandEnvironmentStrings(
                        L"%temp%\\mypackagesource\\",
                        SourcePath,
                        sizeof(SourcePath)/sizeof(WCHAR));

    s = wcsrchr( SourcePath, L'\\' );
    s += 1;
    

    for (i = 0; i < FileListCount; i++) {
        *s = '\0';
        *t = '\0';
        wcscat(s,FileList[i]);
        wcscat(t,FileList[i]);
        CopyFile(SourcePath, Path ,FALSE);
    }


    //
    // 3b. register the package
    //
    ComponentData.VersionMajor = 2;
    ComponentData.VersionMinor = 5;
    RtlMoveMemory(&ComponentData.ComponentGuid, &MyGuid,sizeof(GUID));
    wcscpy(ComponentData.FriendlyName, L"My Exception Package");

    wcscpy( Path, PACKAGE_DIRECTORY  );
    wcscat( Path, MYPACKAGE_GUID );
    wcscat( Path, L"\\" );
    t = wcsrchr( Path, L'\\' );
    t += 1;
    *t = '\0';
    wcscat( t, PACKAGE_INF );
    wcscpy(ExceptionData.ExceptionInfName, Path);

    *t = '\0';
    wcscat( t, PACKAGE_CAT );
    wcscpy(ExceptionData.CatalogFileName, Path);

    if (!SetupRegisterOsComponent(&ComponentData, &ExceptionData)) {
        wprintf( L"Failed to register component, ec = %d\n", GetLastError() );
        return 1;
    }

    //
    // 4. retrieve my package
    //
    cd.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    ed.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    if (!SetupQueryRegisteredOsComponent(
                                &MyGuid,
                                &cd,
                                &ed)) {
        wprintf( L"Failed to register component, ec = %d\n", GetLastError() );
        return 1;
    }

    StringFromIID(&cd.ComponentGuid, &GuidString);

    wprintf( L"Component Data\n\tName: %ws\n\tGuid: %ws\n\tVersionMajor: %d\n\tVersionMinor: %d\n",
             cd.FriendlyName,GuidString,cd.VersionMajor,cd.VersionMinor);

    wprintf( L"ExceptionData\n\tInf: %ws\n\tCatalog: %ws\n",
             ed.ExceptionInfName,ed.CatalogFileName);

    CoTaskMemFree( GuidString );

    //
    // enumerate packages
    //
    i = 0;
    if (!SetupEnumerateRegisteredOsComponents( pComponentLister, (DWORD_PTR)&i)) {
        wprintf( L"Failed to enumerate components, ec = %d\n", GetLastError() );
        return 1;
    }

    wprintf( L"Done (%d enumerated components)!!!\n", i );
    return 0;

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\excppkg\test2\test.c ===
#include <windows.h>
#include <setupapi.h>
#include <spapip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ole2.h>
#include <excppkg.h>

#define PACKAGE_DIRECTORY    L"%windir%\\RegisteredPackages\\"

       
BOOL
CALLBACK
pComponentLister(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
{
    PDWORD Count = (PDWORD) Context;
    PWSTR GuidString;

    StringFromIID(&SetupOsComponentData->ComponentGuid, &GuidString);

    wprintf( L"Component Data\n\tName: %ws\n\tGuid: %ws\n\tVersionMajor: %d\n\tVersionMinor: %d\n",
             SetupOsComponentData->FriendlyName,
             GuidString,
             SetupOsComponentData->VersionMajor,
             SetupOsComponentData->VersionMinor);

    wprintf( L"ExceptionData\n\tInf: %ws\n\tCatalog: %ws\n",
             SetupOsExceptionData->ExceptionInfName,
             SetupOsExceptionData->CatalogFileName);

    *Count += 1;

    CoTaskMemFree( GuidString );

    return(TRUE);
}

VOID
Usage(
    VOID
    )
{
    wprintf(L"test <infname>\n");
}

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    WCHAR Path[MAX_PATH];
    SETUP_OS_COMPONENT_DATA ComponentData,cd;
    SETUP_OS_EXCEPTION_DATA ExceptionData,ed;
    PWSTR s,t;
    GUID MyGuid;
    PCWSTR GuidString;
    PWSTR AGuidString;
    DWORD VersionInInf, RegisteredVersion;
    BOOL ForcePackageUninstall;

    WCHAR SourcePath[MAX_PATH];
    DWORD i;
    PCSTR InfName;
    PCWSTR InfSrcPath,FriendlyName;
    PCWSTR PackageCatName, PackageInfName;
    HINF hInf;
    INFCONTEXT Context;
    HSPFILEQ hFileQueue;
    PVOID QueueContext;
    
    if (argc < 2)  {
        wprintf(L"Missing arguments!\n");
        Usage();
        return 1;
    }

    InfName = argv[1];

    ForcePackageUninstall = (argc == 3);

    hInf = SetupOpenInfFileA( InfName, NULL, INF_STYLE_WIN4, NULL );
    if (hInf == INVALID_HANDLE_VALUE) {
        wprintf(L"Couldn't open inf, ec = %x\n", GetLastError());
        Usage();
        return 1;
    }

    if (!SetupFindFirstLine(hInf, 
                       L"Version", 
                       L"ComponentId",
                       &Context)) {
        wprintf(L"Couldn't find ComponentId in inf, ec = %x\n", GetLastError());
        SetupCloseInfFile( hInf );
        Usage();
        return 1;
    }

    GuidString = pSetupGetField( &Context, 1);

    if (!SetupFindFirstLine(hInf, 
                       L"Version", 
                       L"ComponentVersion",
                       &Context)) {
        wprintf(L"Couldn't find ComponentVersion in inf, ec = %x\n", GetLastError());
        SetupCloseInfFile( hInf );
        Usage();
        return 1;
    }

    SetupGetIntField( &Context, 1, &VersionInInf);

    SetupFindFirstLine(hInf, L"DefaultInstall", L"InfName", &Context);
    PackageInfName = pSetupGetField( &Context, 1);
    SetupFindFirstLine(hInf, L"DefaultInstall", L"CatalogName", &Context);
    PackageCatName = pSetupGetField( &Context, 1);
    
    
    //
    // 1. Make sure my package isn't already installed.
    //
    ComponentData.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    ExceptionData.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    IIDFromString( (PWSTR)GuidString, &MyGuid);
    if (SetupQueryRegisteredOsComponent(
                                &MyGuid,
                                &ComponentData,
                                &ExceptionData)) {
        wprintf(L"My component is already registered with the OS, removing it!\n");
        //
        // 2. unregister any packages that are superceded by my package
        //
        RegisteredVersion = MAKELONG( 
                                ComponentData.VersionMajor, 
                                ComponentData.VersionMinor );

        if (RegisteredVersion < VersionInInf || ForcePackageUninstall) {

            if (!SetupUnRegisterOsComponent(&MyGuid)) {
                SetupCloseInfFile( hInf );
                wprintf(L"couldn't remove my component, ec = %d\n", GetLastError());
                return 1;
    
            }        

        }
    }
        
    

    //
    // 3. Install my package
    //
    //
    // 3a. copy my exception package to the appropriate location
    //

    //
    // 3a.1 make sure the main package directory exists
    // 
    ExpandEnvironmentStrings(
                    PACKAGE_DIRECTORY,
                    Path,
                    sizeof(Path)/sizeof(WCHAR));

    CreateDirectory( Path, NULL );

    //
    // 3a.2 now create my package directory
    //
    wcscat( Path, GuidString );

    CreateDirectory( Path, NULL );

    if (!SetupFindFirstLine(hInf, L"DefaultInstall", L"InstallSource", &Context)) {
        wprintf(L"Couldn't find InstallSource in INF\n");
        SetupCloseInfFile( hInf );
        return 1;
    }

    InfSrcPath = pSetupGetField( &Context, 1);
    ExpandEnvironmentStrings(InfSrcPath,SourcePath,sizeof(SourcePath)/sizeof(WCHAR));


    hFileQueue = SetupOpenFileQueue();
    QueueContext = SetupInitDefaultQueueCallbackEx( NULL, INVALID_HANDLE_VALUE, 0, 0, NULL);
    SetupSetDirectoryId(hInf, DIRID_USER, Path);

    if (!SetupInstallFilesFromInfSection( 
                            hInf, 
                            NULL, 
                            hFileQueue, 
                            L"DefaultInstall",
                            SourcePath,
                            SP_COPY_NEWER)) {
        wprintf(L"failed to SetupInstallFilesFromInfSection, ec = %x\n", GetLastError()); 
        SetupCloseFileQueue(hFileQueue);
        SetupTermDefaultQueueCallback( QueueContext );
        SetupCloseInfFile( hInf );
        return 1;
    }

    if (!SetupCommitFileQueue(NULL, hFileQueue, SetupDefaultQueueCallback, QueueContext)) {
        wprintf(L"failed to SetupCommitFileQueue, ec = %x\n", GetLastError());
        SetupCloseFileQueue(hFileQueue);
        SetupTermDefaultQueueCallback( QueueContext );
        SetupCloseInfFile( hInf );
        return 1;
    }

    SetupCloseFileQueue(hFileQueue);
    SetupTermDefaultQueueCallback( QueueContext );

    SetupFindFirstLine(hInf, L"Version", L"FriendlyName", &Context);
    FriendlyName = pSetupGetField( &Context, 1);

    
    //
    // 3b. register the package
    //
    ComponentData.VersionMajor = HIWORD(VersionInInf);
    ComponentData.VersionMinor = LOWORD(VersionInInf);
    RtlMoveMemory(&ComponentData.ComponentGuid, &MyGuid,sizeof(GUID));
    wcscpy(ComponentData.FriendlyName, FriendlyName);

    wcscpy( Path, PACKAGE_DIRECTORY  );
    wcscat( Path, GuidString );
    wcscat( Path, L"\\" );
    t = wcsrchr( Path, L'\\' );
    t += 1;
    *t = '\0';
    wcscat( t, PackageInfName );
    wcscpy(ExceptionData.ExceptionInfName, Path);

    *t = '\0';
    wcscat( t, PackageCatName );
    wcscpy(ExceptionData.CatalogFileName, Path);

    if (!SetupRegisterOsComponent(&ComponentData, &ExceptionData)) {
        wprintf( L"Failed to register component, ec = %d\n", GetLastError() );
        SetupCloseInfFile( hInf );
        return 1;
    }

    //
    // 4. retrieve my package
    //
    cd.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
    ed.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
    if (!SetupQueryRegisteredOsComponent(
                                &MyGuid,
                                &cd,
                                &ed)) {
        wprintf( L"Failed to register component, ec = %d\n", GetLastError() );
        SetupCloseInfFile( hInf );
        return 1;
    }

    StringFromIID(&cd.ComponentGuid, &AGuidString);

    wprintf( L"Component Data\n\tName: %ws\n\tGuid: %ws\n\tVersionMajor: %d\n\tVersionMinor: %d\n",
             cd.FriendlyName,AGuidString,cd.VersionMajor,cd.VersionMinor);

    wprintf( L"ExceptionData\n\tInf: %ws\n\tCatalog: %ws\n",
             ed.ExceptionInfName,ed.CatalogFileName);

    CoTaskMemFree( AGuidString );

    //
    // enumerate packages
    //
    i = 0;
    if (!SetupEnumerateRegisteredOsComponents( pComponentLister, (DWORD_PTR)&i)) {
        wprintf( L"Failed to enumerate components, ec = %d\n", GetLastError() );
        SetupCloseInfFile( hInf );
        return 1;
    }

    wprintf( L"Done (%d enumerated components)!!!\n", i );
    SetupCloseInfFile( hInf );
    return 0;

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\excppkg\test3\test.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    test.c

Abstract:

    Simple wrapper test that executes the gui setup exception migration code.

Environment:

    WIN32 User Mode

Author:

    Andrew Ritz (AndrewR) 21-Oct-1999

--*/


#include "setupp.h"
#include "setuplog.h"

BOOL
MigrateExceptionPackages(
    IN HWND hProgress,
    IN DWORD StartAtPercent,
    IN DWORD StopAtPercent
    );


int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    SETUPLOG_CONTEXT lc;
    BOOL RetVal;

    InitializeSetupLog(&lc);

    RetVal = MigrateExceptionPackages(NULL,0,10);

    TerminateSetupLog(&lc);

    return RetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\sources.inc ===
# Each hive dir has to serialize on the prior one since only one instance
# of hiveini can run at a time
SYNCHRONIZE_BLOCK=1

NTTARGETFILE0=$(O)\setupreg.hiv

HIVE_FILES= \
    $(O)\setupreg.hiv  \
    $(O)\setupupg.hiv  \
    $(O)\setupret.hiv \
    $(O)\setupret.hiv  \
    $(O)\setup2p.hiv  \
    $(O)\setup4p.hiv  \
    $(O)\setup8p.hiv  \
    $(O)\setup16p.hiv  \
    $(O)\setup32p.hiv \
    $(O)\tbomb5.hiv  \
    $(O)\tbomb15.hiv  \
    $(O)\tbomb30.hiv  \
    $(O)\tbomb60.hiv  \
    $(O)\tbomb90.hiv  \
    $(O)\tbomb120.hiv  \
    $(O)\tbomb180.hiv  \
    $(O)\tbomb240.hiv  \
    $(O)\tbomb360.hiv  \
    $(O)\tbomb444.hiv  \
    $(O)\tb32p444.hiv \
    $(O)\setupp.ini  \
    $(O)\setuppv.ini  \
    $(O)\setuppupg.ini  \
    $(O)\setuppret.ini  \
    $(O)\setuppreg.ini \
    $(O)\setupp2p.ini  \
    $(O)\setupp4p.ini  \
    $(O)\setupp8p.ini  \
    $(O)\setupp16p.ini  \
    $(O)\setupp32p.ini \
    $(O)\setupptb5.ini  \
    $(O)\setupptb15.ini  \
    $(O)\setupptb30.ini  \
    $(O)\setupptb60.ini  \
    $(O)\setupptb90.ini  \
    $(O)\setupptb120.ini  \
    $(O)\setupptb150.ini  \
    $(O)\setupptb180.ini  \
    $(O)\setupptb240.ini  \
    $(O)\setupptb360.ini  \
    $(O)\setupptb444.ini  \
    $(O)\setupp32ptb444.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\makefile.inc ===
$(O)\setupreg.hiv : makefile.inc ..\mkhives.cmd ..\mkhive1.cmd ..\setupreg.ini
    cd..
    set HIVE_OUTPUT_DIR=$(HIVEDIR)\$(O)
    set MPC_VALUE=$(_MPC_VALUE)
    mkhives $(TARGET_DIRECTORY) $(HIVE_VERSION)
    cd $(MAKEDIR)

$(O)\setupupg.hiv  : $(O)\setupreg.hiv

$(O)\setupret.hiv : $(O)\setupreg.hiv

$(O)\setupret.hiv  : $(O)\setupreg.hiv

$(O)\setup2p.hiv  : $(O)\setupreg.hiv

$(O)\setup4p.hiv  : $(O)\setupreg.hiv

$(O)\setup8p.hiv  : $(O)\setupreg.hiv

$(O)\setup16p.hiv  : $(O)\setupreg.hiv

$(O)\setup32p.hiv : $(O)\setupreg.hiv

$(O)\tbomb5.hiv  : $(O)\setupreg.hiv

$(O)\tbomb15.hiv  : $(O)\setupreg.hiv

$(O)\tbomb30.hiv  : $(O)\setupreg.hiv

$(O)\tbomb60.hiv  : $(O)\setupreg.hiv

$(O)\tbomb90.hiv  : $(O)\setupreg.hiv

$(O)\tbomb120.hiv  : $(O)\setupreg.hiv

$(O)\tbomb180.hiv  : $(O)\setupreg.hiv

$(O)\tbomb240.hiv  : $(O)\setupreg.hiv

$(O)\tbomb360.hiv  : $(O)\setupreg.hiv

$(O)\tbomb444.hiv  : $(O)\setupreg.hiv

$(O)\tb32p444.hiv : $(O)\setupreg.hiv

$(O)\setuppupg.ini  : $(O)\setupreg.hiv

$(O)\setuppret.ini  : $(O)\setupreg.hiv

$(O)\setuppreg.ini : $(O)\setupreg.hiv

$(O)\setupp2p.ini  : $(O)\setupreg.hiv

$(O)\setupp4p.ini  : $(O)\setupreg.hiv

$(O)\setupp8p.ini  : $(O)\setupreg.hiv

$(O)\setupp16p.ini  : $(O)\setupreg.hiv

$(O)\setupp32p.ini : $(O)\setupreg.hiv

$(O)\setupptb5.ini  : $(O)\setupreg.hiv

$(O)\setupptb15.ini  : $(O)\setupreg.hiv

$(O)\setupptb30.ini  : $(O)\setupreg.hiv

$(O)\setupptb60.ini  : $(O)\setupreg.hiv

$(O)\setupptb90.ini  : $(O)\setupreg.hiv

$(O)\setupptb120.ini  : $(O)\setupreg.hiv

$(O)\setupptb150.ini  : $(O)\setupreg.hiv

$(O)\setupptb180.ini  : $(O)\setupreg.hiv

$(O)\setupptb240.ini  : $(O)\setupreg.hiv

$(O)\setupptb360.ini  : $(O)\setupreg.hiv

$(O)\setupptb444.ini  : $(O)\setupreg.hiv

$(O)\setupp32ptb444.ini: $(O)\setupreg.hiv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\blade\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\enterprise\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\personal\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\retail\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\server\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\smallbiz\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\datacenter\makefile.inc ===
!include ..\makefile.inc

$(O)\setup64p.hiv : $(O)\setupreg.hiv

$(O)\tb64p444.hiv : $(O)\setupreg.hiv

$(O)\setupp64p.ini : $(O)\setupreg.hiv

$(O)\setupp64ptb444.ini: $(O)\setupreg.hiv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\cmnres.h ===
#define IDC_PROGRESS_BAR_LABEL          1200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hwlogexe\hwlogexe.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ntsetup\hwlogexe\hwlogexe.c

Abstract:

    Command line interface to hwlog.lib.

Author:

    Jay Krell (JayKrell) December 13, 2001

Revision History:

Environment:

    Windows XP+ Win32 usermode console app
--*/

#include <stdio.h>
#include "windows.h"
#include "setupapi.h"
#include "hwlog.h"
#include "shellapi.h"
#include "io.h"

#define STANDALONE 1

void Main(
    PSP_LOG_HARDWARE_IN Parameters
    )
{
#if STANDALONE == 1
    Parameters->LogFile = (HANDLE)_get_osfhandle(_fileno(stdout));
#elif STANDALONE == 2
    SetupOpenLog(FALSE);
    Parameters->SetupLogError = SetupLogError;
#endif
    SpLogHardware(Parameters);
#if STANDALONE == 2
    SetupCloseLog();
#endif
}

#ifdef UNICODE
int __cdecl wmain(int argc, WCHAR** argv)
{
    SP_LOG_HARDWARE_IN Parameters = { 0 };
    Parameters.MachineName = (argc > 1) ? argv[1] : NULL;
    Main(&Parameters);
    return 0;
}
#endif

int __cdecl main(int argc, CHAR** argv)
{
    SP_LOG_HARDWARE_IN Parameters = { 0 };
#ifdef UNICODE
    WCHAR** argvw = NULL;
    argvw = CommandLineToArgvW(GetCommandLineW(), &argc);
    Parameters.MachineName = (argc > 1) ? argvw[1] : NULL;
#else
    Parameters.MachineName = (argc > 1) ? argv[1] : NULL;
#endif
    Main(&Parameters);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hwdb\dllentry.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dllentry.c

Abstract:

    Module's entry points.

Author:

    Ovidiu Temereanca (ovidiut) 02-Jul-2000  Initial implementation

Revision History:

--*/

#include "pch.h"
#include "hwdbp.h"


//
// Implementation
//


PCSTR
pConvertMultiSzToAnsi (
    IN      PCWSTR MultiSz
    )
{
    UINT logChars;

    if (!MultiSz) {
        return NULL;
    }

    logChars = MultiSzSizeInCharsW (MultiSz);

    return UnicodeToDbcsN (NULL, MultiSz, logChars);
}


BOOL
WINAPI
HwdbInitializeA (
    IN      PCSTR TempDir
    )
{
    BOOL b;

    if (HwdbpInitialized ()) {
        DEBUGMSGA ((DBG_WARNING, "Module already initialized"));
        return TRUE;
    }

    //
    // don't call any logging APIs until the log module is actually initialized
    //

    b = HwdbpInitialize ();
    if (b) {
        if (TempDir) {
            HwdbpSetTempDir (TempDir);
        }
        DEBUGMSGA ((DBG_VERBOSE, "HwdbInitializeA(%s) succeeded", TempDir));
    }

    return b;
}


BOOL
WINAPI
HwdbInitializeW (
    IN      PCWSTR TempDir
    )
{
    BOOL b;
    PCSTR ansi;

    if (HwdbpInitialized ()) {
        DEBUGMSGA ((DBG_WARNING, "Module already initialized"));
        return TRUE;
    }

    //
    // don't call any logging APIs until the log module is actually initialized
    //

    b = HwdbpInitialize ();

    if (b) {

        if (TempDir) {
            ansi = ConvertWtoA (TempDir);
            HwdbpSetTempDir (ansi);
        } else {
            ansi = NULL;
        }

        DEBUGMSGA ((DBG_VERBOSE, "HwdbInitializeW(%s) succeeded", ansi));

        if (ansi) {
            FreeConvertedStr (ansi);
        }
    }

    return b;
}


VOID
WINAPI
HwdbTerminate (
    VOID
    )
{
    if (!HwdbpInitialized ()) {
        return;
    }

    DEBUGMSGA ((DBG_VERBOSE, "HwdbTerminate(): entering (TID=%u)", GetCurrentThreadId ()));
    HwdbpTerminate ();
}


HANDLE
WINAPI
HwdbOpenA (
    IN      PCSTR DatabaseFile     OPTIONAL
    )
{
    PHWDB p;

    if (!HwdbpInitialized ()) {
        return NULL;
    }

    DEBUGMSGA ((DBG_VERBOSE, "HwdbOpenA(%s): entering (TID=%u)", DatabaseFile, GetCurrentThreadId ()));

    p = HwdbpOpen (DatabaseFile);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbOpenA: leaving (p=%p, rc=%u)", p, GetLastError ()));

    return (HANDLE)p;
}


HANDLE
WINAPI
HwdbOpenW (
    IN      PCWSTR DatabaseFile     OPTIONAL
    )
{
    PHWDB p;
    PCSTR ansi;

    if (!HwdbpInitialized ()) {
        return NULL;
    }

    if (DatabaseFile) {
        ansi = ConvertWtoA (DatabaseFile);
    } else {
        ansi = NULL;
    }

    DEBUGMSGA ((DBG_VERBOSE, "HwdbOpenW(%s): entering (TID=%u)", ansi, GetCurrentThreadId ()));

    p = HwdbpOpen (ansi);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbOpenW: leaving (p=%p, rc=%u)", p, GetLastError ()));

    if (ansi) {
        FreeConvertedStr (ansi);
    }

    return (HANDLE)p;
}


VOID
WINAPI
HwdbClose (
    IN      HANDLE Hwdb
    )
{
    if (!HwdbpInitialized ()) {
        return;
    }

    DEBUGMSGA ((DBG_VERBOSE, "HwdbClose(%p): entering (TID=%u)", Hwdb, GetCurrentThreadId ()));

    HwdbpClose ((PHWDB)Hwdb);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbClose: leaving (rc=%u)", GetLastError ()));
}


BOOL
WINAPI
HwdbAppendInfsA (
    IN      HANDLE Hwdb,
    IN      PCSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    )
{
    BOOL b;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbAppendInfsA(%p,%s): entering (TID=%u)",
        Hwdb,
        SourceDirectory,
        GetCurrentThreadId ()
        ));

    b = HwdbpAppendInfs ((PHWDB)Hwdb, SourceDirectory, Callback, CallbackContext, FALSE);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbAppendInfsA: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

BOOL
WINAPI
HwdbAppendInfsW (
    IN      HANDLE Hwdb,
    IN      PCWSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKW Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    )
{
    BOOL b;
    PCSTR ansi;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    MYASSERT (SourceDirectory);
    ansi = ConvertWtoA (SourceDirectory);

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbAppendInfsW(%p,%s): entering (TID=%u)",
        Hwdb,
        ansi,
        GetCurrentThreadId ()
        ));

    b = HwdbpAppendInfs ((PHWDB)Hwdb, ansi, (HWDBAPPENDINFSCALLBACKA)Callback, CallbackContext, TRUE);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbAppendInfsW: leaving (b=%u,rc=%u)", b, GetLastError ()));

    FreeConvertedStr (ansi);

    return b;
}

BOOL
WINAPI
HwdbAppendDatabase (
    IN      HANDLE HwdbTarget,
    IN      HANDLE HwdbSource
    )
{
    BOOL b;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbAppendDatabase(%p,%p): entering (TID=%u)",
        HwdbTarget,
        HwdbSource
        ));

    b = HwdbpAppendDatabase ((PHWDB)HwdbTarget, (PHWDB)HwdbSource);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbAppendDatabase: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

BOOL
WINAPI
HwdbFlushA (
    IN      HANDLE Hwdb,
    IN      PCSTR OutputFile
    )
{
    BOOL b;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbFlushA(%p,%s): entering (TID=%u)",
        Hwdb,
        OutputFile,
        GetCurrentThreadId ()
        ));

    b = HwdbpFlush ((PHWDB)Hwdb, OutputFile);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbFlushA: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

BOOL
WINAPI
HwdbFlushW (
    IN      HANDLE Hwdb,
    IN      PCWSTR OutputFile
    )
{
    BOOL b;
    PCSTR ansi;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    MYASSERT (OutputFile);
    ansi = ConvertWtoA (OutputFile);

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbFlushW(%p,%s): entering (TID=%u)",
        Hwdb,
        ansi,
        GetCurrentThreadId ()
        ));

    b = HwdbpFlush ((PHWDB)Hwdb, ansi);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbFlushW: leaving (b=%u,rc=%u)", b, GetLastError ()));

    FreeConvertedStr (ansi);

    return b;
}


BOOL
WINAPI
HwdbHasDriverA (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    )
{
    BOOL b;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbHasDriverA(%p,%s,%p): entering (TID=%u)",
        Hwdb,
        PnpId,
        Unsupported,
        GetCurrentThreadId ()
        ));

    b = HwdbpHasDriver ((PHWDB)Hwdb, PnpId, Unsupported);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbHasDriverA: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

BOOL
WINAPI
HwdbHasDriverW (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpId,
    OUT     PBOOL Unsupported
    )
{
    BOOL b;
    PCSTR ansi;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    MYASSERT (PnpId);
    ansi = ConvertWtoA (PnpId);

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbHasDriverW(%p,%s,%p): entering (TID=%u)",
        Hwdb,
        ansi,
        Unsupported,
        GetCurrentThreadId ()
        ));

    b = HwdbpHasDriver ((PHWDB)Hwdb, ansi, Unsupported);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbHasDriverW: leaving (b=%u,rc=%u)", b, GetLastError ()));

    FreeConvertedStr (ansi);

    return b;
}


BOOL
WINAPI
HwdbHasAnyDriverA (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpIds,
    OUT     PBOOL Unsupported
    )
{
    BOOL b;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbHasAnyDriverA(%p,%s,%p): entering (TID=%u)",
        Hwdb,
        PnpIds,
        Unsupported,
        GetCurrentThreadId ()
        ));

    b = HwdbpHasAnyDriver ((PHWDB)Hwdb, PnpIds, Unsupported);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbHasAnyDriverA: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

BOOL
WINAPI
HwdbHasAnyDriverW (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpIds,
    OUT     PBOOL Unsupported
    )
{
    BOOL b;
    PCSTR ansi;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    ansi = pConvertMultiSzToAnsi (PnpIds);

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbHasAnyDriverW(%p,%s,%p): entering (TID=%u)",
        Hwdb,
        ansi,
        Unsupported,
        GetCurrentThreadId ()
        ));

    b = HwdbpHasAnyDriver ((PHWDB)Hwdb, ansi, Unsupported);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbHasAnyDriverW: leaving (b=%u,rc=%u)", b, GetLastError ()));

    FreeConvertedStr (ansi);

    return b;
}

#if 0

BOOL
HwdbEnumeratePnpIdA (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKA EnumCallback,
    IN      PVOID UserContext
    )
{
    BOOL b;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbEnumeratePnpIdA: entering (TID=%u)",
        GetCurrentThreadId ()
        ));

    b = HwdbpEnumeratePnpIdA ((PHWDB)Hwdb, EnumCallback, UserContext);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbEnumeratePnpIdA: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

BOOL
HwdbEnumeratePnpIdW (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKW EnumCallback,
    IN      PVOID UserContext
    )
{
    BOOL b;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbEnumeratePnpIdW: entering (TID=%u)",
        GetCurrentThreadId ()
        ));

    b = HwdbpEnumeratePnpIdW ((PHWDB)Hwdb, EnumCallback, UserContext);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbEnumeratePnpIdW: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}
#endif

BOOL
HwdbEnumFirstInfA (
    OUT     PHWDBINF_ENUMA EnumPtr,
    IN      PCSTR DatabaseFile
    )
{
    BOOL b;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbEnumFirstInfA(%s): entering (TID=%u)",
        DatabaseFile,
        GetCurrentThreadId ()
        ));

    b = HwdbpEnumFirstInfA (EnumPtr, DatabaseFile);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbEnumFirstInfA(%s): leaving (b=%u,rc=%u)", DatabaseFile, b, GetLastError ()));

    return b;
}

BOOL
HwdbEnumFirstInfW (
    OUT     PHWDBINF_ENUMW EnumPtr,
    IN      PCWSTR DatabaseFile
    )
{
    BOOL b;
    PCSTR ansi;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    MYASSERT (DatabaseFile);
    ansi = ConvertWtoA (DatabaseFile);

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbEnumFirstInfW: entering (TID=%u)",
        GetCurrentThreadId ()
        ));

    b = HwdbpEnumFirstInfW (EnumPtr, ansi);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbEnumFirstInfW(%s): leaving (b=%u,rc=%u)",  ansi, b, GetLastError ()));

    FreeConvertedStr (ansi);

    return b;
}

BOOL
HwdbEnumNextInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    )
{
    BOOL b;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbEnumNextInfA: entering (TID=%u)",
        GetCurrentThreadId ()
        ));

    b = HwdbpEnumNextInfA (EnumPtr);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbEnumNextInfA: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

BOOL
HwdbEnumNextInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    )
{
    BOOL b;

    if (!HwdbpInitialized ()) {
        return FALSE;
    }

    DEBUGMSGA ((
        DBG_VERBOSE,
        "HwdbEnumNextInfW: entering (TID=%u)",
        GetCurrentThreadId ()
        ));

    b = HwdbpEnumNextInfW (EnumPtr);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbEnumNextInfW: leaving (b=%u,rc=%u)", b, GetLastError ()));

    return b;
}

VOID
HwdbAbortEnumInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    )
{
    if (!HwdbpInitialized ()) {
        return;
    }

    DEBUGMSGA ((DBG_VERBOSE, "HwdbAbortEnumInfA: entering"));

    HwdbpAbortEnumInfA (EnumPtr);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbAbortEnumInfA: leaving"));
}

VOID
HwdbAbortEnumInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    )
{
    if (!HwdbpInitialized ()) {
        return;
    }

    DEBUGMSGA ((DBG_VERBOSE, "HwdbAbortEnumInfW: entering"));

    HwdbpAbortEnumInfW (EnumPtr);

    DEBUGMSGA ((DBG_VERBOSE, "HwdbAbortEnumInfW: leaving"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hwdb\hwdbp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    hwdbp.h

Abstract:

    Module's private definitions.

Author:

    Ovidiu Temereanca (ovidiut) 11-Jul-2000  Initial implementation

Revision History:

--*/

#include "migshared.h"
#include "hwdb.h"

#include <infstr.h>
#include <strsafe.h>


typedef struct {
    HASHTABLE InfFileTable;
    HASHTABLE PnpIdTable;
    HASHTABLE UnsupPnpIdTable;
    DWORD Checksum;
} HWDB, *PHWDB;


BOOL
HwdbpInitialized (
    VOID
    );

BOOL
HwdbpInitialize (
    VOID
    );

VOID
HwdbpTerminate (
    VOID
    );

PHWDB
HwdbpOpen (
    IN      PCSTR DatabaseFile
    );

BOOL
HwdbpClose (
    IN      HANDLE Hwdb
    );

BOOL
HwdbpAppendInfs (
    IN      HANDLE Hwdb,
    IN      PCSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext,                  OPTIONAL
    IN      BOOL CallbackIsUnicode
    );

BOOL
HwdbpAppendDatabase (
    IN      HANDLE HwdbTarget,
    IN      HANDLE HwdbSource
    );

BOOL
HwdbpFlush (
    IN      HANDLE Hwdb,
    IN      PCSTR OutputFile
    );

BOOL
HwdbpHasDriver (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    );

BOOL
HwdbpHasAnyDriver (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpIds,
    OUT     PBOOL Unsupported
    );

BOOL
HwpAddPnpIdsInInf (
    IN      PCSTR InfPath,
    IN OUT  PHWDB Hwdb,
    IN      PCSTR SourceDirectory,
    IN      PCSTR InfFilename,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext,                  OPTIONAL
    IN      BOOL CallbackIsUnicode
    );

#if 0

BOOL
HwdbpEnumeratePnpIdA (
    IN      PHWDB Hwdb,
    IN      PHWDBENUM_CALLBACKA EnumCallback,
    IN      PVOID UserContext
    );

BOOL
HwdbpEnumeratePnpIdW (
    IN      PHWDB Hwdb,
    IN      PHWDBENUM_CALLBACKW EnumCallback,
    IN      PVOID UserContext
    );

#endif

typedef struct {
    HANDLE File;
    GROWBUFFER GrowBuf;
} HWDBINF_ENUM_INTERNAL, *PHWDBINF_ENUM_INTERNAL;


BOOL
HwdbpEnumFirstInfA (
    OUT     PHWDBINF_ENUMA EnumPtr,
    IN      PCSTR DatabaseFile
    );

BOOL
HwdbpEnumFirstInfW (
    OUT     PHWDBINF_ENUMW EnumPtr,
    IN      PCSTR DatabaseFile
    );

BOOL
HwdbpEnumNextInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    );

BOOL
HwdbpEnumNextInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    );

VOID
HwdbpAbortEnumInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    );

VOID
HwdbpAbortEnumInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    );

BOOL
HwdbpSetTempDir (
    IN      PCSTR TempDir
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hwdb\hwdb.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    hwdb.c

Abstract:

    PNP device manipulation routines.
    Adapted from the win95upg project.

Author:

    Ovidiu Temereanca (ovidiut) 02-Jul-2000  Initial implementation

Revision History:

--*/


#include "pch.h"
#include "hwdbp.h"

#define DBG_HWDB    "Hwdb"

static HANDLE g_hHwdbHeap = NULL;
static PCSTR g_TempDir = NULL;

#define HWCOMPDAT_SIGNATURE     "HwCompDat-v2"
#define MAX_PNPID               1024

#ifdef DEBUG
extern BOOL g_DoLog;
extern BOOL g_ResetLog;
#endif

typedef struct {
    HANDLE File;
    HASHITEM InfFileOffset;
    BOOL UnsupportedDevice;
    PHWDB Hwbd;
} SAVE_ENUM_PARAMS, *PSAVE_ENUM_PARAMS;


PCWSTR
pConvertMultiSzToUnicode (
    IN      PCSTR MultiSz
    )
{
    UINT logChars;

    if (!MultiSz) {
        return NULL;
    }

    logChars = MultiSzSizeInCharsA (MultiSz);

    return DbcsToUnicodeN (NULL, MultiSz, logChars);
}



//
// REM - g_ExcludedInfs was removed because hwdb will be used for any 3rd party driver files
// and we need to make suer ALL infs are scanned
//

//
// Implementation
//

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

HINSTANCE g_hInst;
HANDLE g_hHeap;


BOOL
HwdbpInitialized (
    VOID
    )
{
    return g_hHwdbHeap != NULL;
}


BOOL
HwdbpInitialize (
    VOID
    )
{
    BOOL b = TRUE;

    //
    // only initialize data once
    //
    MYASSERT (!g_hHwdbHeap);

    g_hHwdbHeap = HeapCreate (0, 65536, 0);
    if (!g_hHwdbHeap) {
        return FALSE;
    }

#ifdef DEBUG
    g_DoLog = TRUE;
    g_ResetLog = TRUE;
#endif
    g_hHeap = g_hHwdbHeap;

    if (!g_hInst) {
        //
        // If DllMain didn't set this, then set it now
        //

        g_hInst = GetModuleHandle (NULL);
    }

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        b = FALSE;
    }

    if (!b) {
        HwdbpTerminate ();
    }

    return b;
}


VOID
HwdbpTerminate (
    VOID
    )
{
    HwdbpSetTempDir (NULL);

    MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL);

    if (g_hHwdbHeap) {
        HeapDestroy (g_hHwdbHeap);
        g_hHwdbHeap = NULL;
    }
}


BOOL
pReadDword (
    IN      HANDLE File,
    OUT     PDWORD Data
    )

/*++

Routine Description:

  pReadDword reads the next DWORD at the current file position of File.

Arguments:

  File - Specifies file to read

  Data - Receives the DWORD

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD BytesRead;

    return ReadFile (File, Data, sizeof (DWORD), &BytesRead, NULL) &&
           BytesRead == sizeof (DWORD);
}


BOOL
pReadWord (
    IN      HANDLE File,
    OUT     PWORD Data
    )

/*++

Routine Description:

  pReadWord reads the next WORD at the current file position of File.

Arguments:

  File - Specifies file to read

  Data - Receive s the WORD

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/
{
    DWORD BytesRead;

    return ReadFile (File, Data, sizeof (WORD), &BytesRead, NULL) &&
           BytesRead == sizeof (WORD);
}


BOOL
pReadString (
    IN      HANDLE File,
    OUT     PSTR Buf,
    IN      DWORD BufSizeInBytes
    )

/*++

Routine Description:

  pReadString reads a WORD length from File, and then reads in the
  string from File.

Arguments:

  File - Specifies file to read

  Buf - Receives the zero-terminated string

  BufSizeInBytes - Specifies the size of Buf in bytes

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  This function will fail if the string is larger than Buf.
  Call GetLastError for additional failure information.

--*/
{
    DWORD BytesRead;
    WORD Length;

    MYASSERT (BufSizeInBytes);
    if (!BufSizeInBytes) {
        return FALSE;
    }

    if (!pReadWord (File, &Length)) {
        return FALSE;
    }

    if ((Length + 1 ) * sizeof (CHAR) > BufSizeInBytes) {
        return FALSE;
    }

    if (Length) {
        if (!ReadFile (File, Buf, Length, &BytesRead, NULL) ||
            Length != BytesRead
            ) {
            return FALSE;
        }
    }

    Buf[Length] = 0;

    return TRUE;
}


BOOL
pWriteDword (
    IN      HANDLE File,
    IN      DWORD Val
    )

/*++

Routine Description:

  pWriteDword writes the specified DWORD value to File.

Arguments:

  File - Specifies file to write to

  Val - Specifies value to write

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD bytesWritten;

    return WriteFile (File, &Val, sizeof (Val), &bytesWritten, NULL) &&
           bytesWritten == sizeof (Val);
}


BOOL
pWriteWord (
    IN      HANDLE File,
    IN      WORD Val
    )

/*++

Routine Description:

  pWriteWord writes the specified WORD vlue to File.

Arguments:

  File - Specifies file to write to

  Val - Specifies value to write

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    DWORD bytesWritten;

    return WriteFile (File, &Val, sizeof (Val), &bytesWritten, NULL) &&
           bytesWritten == sizeof (Val);
}


BOOL
pWriteString (
    IN      HANDLE File,
    IN      PCSTR String
    )

/*++

Routine Description:

  pWriteString writes a string to a File

Arguments:

  File - Specifies file to write to

  String - Specifies the zero-terminated string

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/
{
    DWORD bytesWritten;
    DWORD Length;
    PCSTR End;
    BOOL b = TRUE;

    Length = lstrlenA (String);

    if (Length > 0xffff) {
        SetLastError (ERROR_INTERNAL_ERROR);
        DEBUGMSGA ((DBG_ERROR, "pWriteString: string too long!"));
        return FALSE;
    }

    b = pWriteWord (File, (WORD)Length);

    if (b && Length) {
        b = WriteFile (File, String, Length, &bytesWritten, NULL) &&
            Length == bytesWritten;
    }

    return b;
}


PHWDB
HwdbpOpen (
    IN      PCSTR DatabaseFile     OPTIONAL
    )
{
    CHAR buffer[MAX_PATH];
    CHAR infFile[MAX_MBCHAR_PATH];
    CHAR pnpId[1024];
    CHAR sig[sizeof (HWCOMPDAT_SIGNATURE)];
    DWORD rc;
    HANDLE file = INVALID_HANDLE_VALUE;
    PHWDB phwdb;
    DWORD BytesRead;
    HASHITEM infOffset, result;
    BOOL b = FALSE;

    __try {

        phwdb = (PHWDB) MemAlloc (g_hHwdbHeap, 0, sizeof (*phwdb));
        if (!phwdb) {
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }
        ZeroMemory (phwdb, sizeof (*phwdb));

        //
        // Create hash tables
        //
        phwdb->InfFileTable = HtAlloc ();
        phwdb->PnpIdTable = HtAllocWithData (sizeof (HASHITEM*));
        phwdb->UnsupPnpIdTable = HtAllocWithData (sizeof (HASHITEM*));
        if (!phwdb->InfFileTable || !phwdb->PnpIdTable || !phwdb->UnsupPnpIdTable) {
            __leave;
        }

        if (DatabaseFile) {

            if (!GetFullPathNameA (DatabaseFile, ARRAYSIZE(buffer), buffer, NULL)) {
                __leave;
            }

            //
            // Try to open the file
            //
            file = CreateFileA (
                        buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ,            // share for read access
                        NULL,                       // no security attribs
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL                        // no template
                        );
            if (file == INVALID_HANDLE_VALUE) {
                __leave;
            }
            //
            // Look at the signature
            //
            ZeroMemory (sig, sizeof(sig));
            if (!ReadFile (file, sig, sizeof (HWCOMPDAT_SIGNATURE) - 1, &BytesRead, NULL) ||
                lstrcmpA (HWCOMPDAT_SIGNATURE, sig)
                ) {
                SetLastError (ERROR_BAD_FORMAT);
                __leave;
            }
            //
            // Get INF checksum
            //
            if (!pReadDword (file, &phwdb->Checksum)) {
                SetLastError (ERROR_BAD_FORMAT);
                __leave;
            }
            //
            // Read in all PNP IDs
            //
            for (;;) {
                //
                // Get INF file name.  If empty, we are done.
                //
                if (!pReadString (file, infFile, sizeof (infFile))) {
                    SetLastError (ERROR_BAD_FORMAT);
                    __leave;
                }
                if (*infFile == 0) {
                    break;
                }
                infOffset = HtAddStringA (phwdb->InfFileTable, infFile);
                if (!infOffset) {
                    __leave;
                }

                //
                // Read in all PNP IDs for the INF
                //
                for (;;) {
                    //
                    // Get the PNP ID.  If empty, we are done.
                    //
                    if (!pReadString (file, pnpId, sizeof (pnpId))) {
                        SetLastError (ERROR_BAD_FORMAT);
                        __leave;
                    }
                    if (*pnpId == 0) {
                        break;
                    }
                    //
                    // Add to hash table
                    //
                    if (*pnpId == '!') {
                        result = HtAddStringExA (phwdb->UnsupPnpIdTable, pnpId + 1, &infOffset, CASE_INSENSITIVE);
                    } else {
                        result = HtAddStringExA (phwdb->PnpIdTable, pnpId, &infOffset, CASE_INSENSITIVE);
                    }
                    if (!result) {
                        __leave;
                    }
                }
            }
        }

        b = TRUE;
    }
    __finally {
        rc = GetLastError ();

        if (file != INVALID_HANDLE_VALUE) {
            CloseHandle (file);
        }
        if (!b && phwdb) {
            if (phwdb->InfFileTable) {
                HtFree (phwdb->InfFileTable);
            }
            if (phwdb->PnpIdTable) {
                HtFree (phwdb->PnpIdTable);
            }
            if (phwdb->UnsupPnpIdTable) {
                HtFree (phwdb->UnsupPnpIdTable);
            }
            MemFree (g_hHwdbHeap, 0, phwdb);
        }

        SetLastError (rc);
    }

    return phwdb;
}

/*
BOOL
pWriteHashTableString (
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    )
{
    MYASSERT (String && *String);
    return pWriteString ((HANDLE)lParam, String);
}
*/

BOOL
pSavePnpID (
    IN      HASHTABLE Table,
    IN      HASHITEM StringId,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  pSavePnpID is a string table callback function that writes a PNP
  ID to the file indicated in the params struct (the lParam argument).

  This function only writes PNP IDs for a specific INF file (indicated
  by the ExtraData arg).

Arguments:

  Table - Specifies table being enumerated

  StringId - Specifies offset of string in Table

  String - Specifies string being enumerated

  ExtraData - Specifies a pointer to a LONG that holds the INF ID
              to enumerate.  The PNP ID's INF ID must match this
              parameter.

  lParam - Specifies a pointer to a SAVE_ENUM_PARAMS struct

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.

--*/

{
    PSAVE_ENUM_PARAMS params;
    CHAR bangString[MAX_PNPID + 2];
    BOOL b = TRUE;

    params = (PSAVE_ENUM_PARAMS) lParam;

    if (*(HASHITEM UNALIGNED*)ExtraData == params->InfFileOffset) {
        //
        // Write this PNP ID to the file
        //
        if (params->UnsupportedDevice) {

            bangString[0] = '!';
            b = SUCCEEDED (StringCchCopyA (bangString + 1, ARRAYSIZE(bangString) - 1, String)) &&
                pWriteString (params->File, bangString);

        } else {

            b = pWriteString (params->File, String);

        }
    }

    return b;
}


BOOL
pSaveInfWithPnpIDList (
    IN      HASHTABLE Table,
    IN      HASHITEM StringId,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  pSaveInfWithPnpIDList is a string table callback function and is called for
  each INF in g_InfFileTable.

  This routine writes the name of the INF to disk, and then enumerates
  the PNP IDs for the INF, writing them to disk.

  The PNP ID list is terminated with an empty string.

Arguments:

  Table - Specifies g_InfFileTable

  StringId - Specifies offset of String in g_InfFileTable

  String - Specifies current INF file being enumerated

  ExtraData - unused

  ExtraDataSize - unused

  lParam - Specifies a pointer to SAVE_ENUM_PARAMS struct.

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.

--*/

{
    PSAVE_ENUM_PARAMS params;

    params = (PSAVE_ENUM_PARAMS) lParam;
    params->InfFileOffset = StringId;

    //
    // Save the file name
    //

    if (!pWriteString (params->File, String)) {
        return FALSE;
    }

    //
    // Enumerate all PNP IDs
    //

    params->UnsupportedDevice = FALSE;

    if (!EnumHashTableWithCallbackA (params->Hwbd->PnpIdTable, pSavePnpID, lParam)) {
        LOGA ((LOG_ERROR, "Error while saving device list."));
        return FALSE;
    }

    params->UnsupportedDevice = TRUE;

    if (!EnumHashTableWithCallbackA (params->Hwbd->UnsupPnpIdTable, pSavePnpID, lParam)) {
        LOGA ((LOG_ERROR, "Error while saving device list. (2)"));
        return FALSE;
    }

    //
    // Terminate the PNP ID list
    //

    if (!pWriteString (params->File, "")) {
        return FALSE;
    }

    return TRUE;
}


BOOL
HwdbpFlush (
    IN      PHWDB Hwdb,
    IN      PCSTR OutputFile
    )
{
    CHAR buffer[MAX_PATH];
    DWORD rc;
    HANDLE file = INVALID_HANDLE_VALUE;
    DWORD bytesWritten;
    SAVE_ENUM_PARAMS params;
    BOOL b = FALSE;

    __try {
        if (!OutputFile) {
            SetLastError (ERROR_INVALID_PARAMETER);
            __leave;
        }

        if (!GetFullPathNameA (OutputFile, ARRAYSIZE(buffer), buffer, NULL)) {
            __leave;
        }

        //
        // Try to open the file
        //
        file = CreateFileA (
                    OutputFile,
                    GENERIC_WRITE,
                    0,                          // no sharing
                    NULL,                       // no security attribs
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL                        // no template
                    );
        if (file == INVALID_HANDLE_VALUE) {
            __leave;
        }
        //
        // Write the signature
        //
        if (!WriteFile (file, HWCOMPDAT_SIGNATURE, sizeof (HWCOMPDAT_SIGNATURE) - 1, &bytesWritten, NULL)) {
            __leave;
        }
        //
        // Store INF checksum
        //
        if (!pWriteDword (file, Hwdb->Checksum)) {
            __leave;
        }

        //
        // Enumerate the INF table, writing the INF file name and all PNP IDs
        //

        params.File = file;
        params.Hwbd = Hwdb;

        if (!EnumHashTableWithCallbackA (
                Hwdb->InfFileTable,
                pSaveInfWithPnpIDList,
                (LPARAM) (&params)
                )) {
            DEBUGMSGA ((DBG_WARNING, "SaveDeviceList: EnumHashTableWithCallbackA returned FALSE"));
            __leave;
        }
        //
        // end with an empty string
        //
        pWriteString (file, "");

        b = TRUE;
    }
    __finally {
        rc = GetLastError ();

        if (file != INVALID_HANDLE_VALUE) {
            CloseHandle (file);
        }
        if (!b) {
            DeleteFile (OutputFile);
        }

        SetLastError (rc);
    }

    return b;
}


BOOL
HwdbpClose (
    IN      PHWDB Hwdb
    )
{
    BOOL b = FALSE;

    __try {
        if (Hwdb) {
            if (Hwdb->InfFileTable) {
                HtFree (Hwdb->InfFileTable);
            }
            if (Hwdb->PnpIdTable) {
                HtFree (Hwdb->PnpIdTable);
            }
            if (Hwdb->UnsupPnpIdTable) {
                HtFree (Hwdb->UnsupPnpIdTable);
            }

            MemFree (g_hHwdbHeap, 0, Hwdb);

            b = TRUE;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    return b;
}


BOOL
HwpIsValidInfName (
    IN      PCSTR FileName,
    OUT     PSTR UncompressedFileName,
    IN      DWORD BufferSizeInChars
    )
{
    PSTR p;
    PCSTR* q;
    PCSTR comparationName;

    if (!FileName || *FileName == 0) {
        MYASSERT (FALSE);
        return FALSE;
    }

    if (FAILED (StringCchCopyA (UncompressedFileName, BufferSizeInChars, FileName))) {
        return FALSE;
    }

    p = our_mbsdec (UncompressedFileName, GetEndOfStringA (UncompressedFileName));
    if (!p) {
        return FALSE;
    }

    if (*p == '_') {
        *p = 'f';
        comparationName = UncompressedFileName;
    } else {
        if (_mbctolower (_mbsnextc (p)) != 'f') {
            return FALSE;
        }
        *UncompressedFileName = 0;
        comparationName = FileName;
    }

    return TRUE;
}


BOOL
HwpAddPnpIdsInInf (
    IN      PCSTR InfPath,
    IN OUT  PHWDB Hwdb,
    IN      PCSTR SourceDirectory,
    IN      PCSTR InfFilename,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext,                  OPTIONAL
    IN      BOOL CallbackIsUnicode
    )

/*++

Routine Description:

  HwpAddPnpIdsInInf scans an NT INF and places all hardware device
  IDs in the PNP string table.

Arguments:

  InfPath - The path to an INF file
  Hwdb - Database to append PNPIDs to

Return Value:

  TRUE if the function completes successfully, or FALSE if it fails.
  Call GetLastError for additional failure information.

--*/

{
    HINF inf;
    INFCONTEXT is;
    INFCONTEXT isMfg;
    INFCONTEXT isDev;
    CHAR manufacturer[2048];
    CHAR devSection[2048];
    CHAR pnpId[2048];
    BOOL unsupportedDevice;
    PSTR AppendPos;
    CHAR trimmedPnpId[512];
    CHAR field[12];
    PCSTR p;
    LONG rc;
    BOOL b;
    PCSTR fileName;
    PCWSTR uInfPath = NULL;
    PCWSTR uSourceDirectory = NULL;
    PCWSTR uInfFilename = NULL;
    HASHITEM infOffset = NULL;
    BOOL result = FALSE;

    //
    // Determine if this is an NT4 INF
    //
    inf = SetupOpenInfFileA (InfPath, NULL, INF_STYLE_WIN4, NULL);
    if (inf == INVALID_HANDLE_VALUE) {
        DEBUGMSGA ((DBG_ERROR, "HwpAddPnpIdsInInf: SetupOpenInfFileA (%s) failed", InfPath));
        return FALSE;
    }

    DEBUGMSGA ((DBG_HWDB, "HwpAddPnpIdsInInf: analyzing %s", InfPath));

    __try {
        //
        // Enumerate [Manufacturer] section
        //
        if (SetupFindFirstLineA (inf, "Manufacturer", NULL, &is)) {

            do  {
                //
                // Get the manufacturer name
                //
                if (!SetupGetLineTextA (&is, NULL, NULL, NULL, manufacturer, ARRAYSIZE(manufacturer), NULL)) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "HwpAddPnpIdsInInf: SetupGetLineText failed at line %u in [Manufacturer]",
                        is.Line
                        ));
                    __leave;
                }
                //
                // Enumerate the devices listed in the manufacturer's section,
                // looking for PnpId
                //
                if (!SetupFindFirstLineA (inf, manufacturer, NULL, &isMfg)) {
                    rc = GetLastError();
                    //
                    // if section not found, move on to next manufacturer
                    //
                    if (rc == ERROR_SECTION_NOT_FOUND || rc == ERROR_LINE_NOT_FOUND) {
                        DEBUGMSGA ((
                            DBG_HWDB,
                            "HwpAddPnpIdsInInf: manufacturer %s section does not exist",
                            manufacturer
                            ));
                        continue;
                    }
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "HwpAddPnpIdsInInf: error searching for lines in [%s]",
                        manufacturer
                        ));
                    __leave;
                }

                do  {
                    if (!SetupGetStringFieldA (&isMfg, 1, devSection, ARRAYSIZE(devSection), NULL)) {
                        DEBUGMSGA ((
                            DBG_HWDB,
                            "HwpAddPnpIdsInInf: error retrieving first field in line %u in [%s]",
                            isMfg.Line,
                            devSection
                            ));
                        continue;
                    }

                    //
                    // Try platform-specific section first, then section.NT, then section
                    //
                    AppendPos = GetEndOfStringA (devSection);
#if defined(_AMD64_)
                    if (FAILED (StringCchPrintfA (
                                    AppendPos,
                                    ARRAYSIZE(devSection) - (AppendPos - devSection),
                                    TEXT(".%s"),
                                    INFSTR_PLATFORM_NTAMD64
                                    ))) {
#elif defined(_IA64_)
                    if (FAILED (StringCchPrintfA (
                                    AppendPos,
                                    ARRAYSIZE(devSection) - (AppendPos - devSection),
                                    TEXT(".%s"),
                                    INFSTR_PLATFORM_NTIA64
                                    ))) {
#elif defined(_X86_)
                    if (FAILED (StringCchPrintfA (
                                    AppendPos,
                                    ARRAYSIZE(devSection) - (AppendPos - devSection),
                                    TEXT(".%s"),
                                    INFSTR_PLATFORM_NTX86
                                    ))) {
#else
#error "No Target Architecture"
#endif
                        __leave;
                    }

                    b = SetupFindFirstLineA (inf, devSection, NULL, &isDev);
                    if (!b) {
                        if (FAILED (StringCchPrintfA (
                                    AppendPos,
                                    ARRAYSIZE(devSection) - (AppendPos - devSection),
                                    TEXT(".%s"),
                                    INFSTR_PLATFORM_NT
                                    ))) {
                            __leave;
                        }
                        b = SetupFindFirstLineA (inf, devSection, NULL, &isDev);
                        if (!b) {
                            *AppendPos = 0;
                            b = SetupFindFirstLineA (inf, devSection, NULL, &isDev);
                        }
                    }

                    unsupportedDevice = FALSE;
                    if (b) {
                        if (SetupFindFirstLineA (inf, devSection, "DeviceUpgradeUnsupported", &isDev)) {
                            if (SetupGetStringFieldA (&isDev, 1, field, ARRAYSIZE(field), NULL)) {
                                if (atoi (field)) {
                                    unsupportedDevice = TRUE;
                                }
                            }
                        }
                    } else {
                        DEBUGMSGA ((
                            DBG_HWDB,
                            "HwpAddPnpIdsInInf: no device section [%s] for [%s]",
                            devSection,
                            manufacturer
                            ));
                    }

                    //
                    // Get the device id
                    //
                    if (!SetupGetMultiSzFieldA (&isMfg, 2, pnpId, ARRAYSIZE(pnpId), NULL)) {
                        DEBUGMSGA ((
                            DBG_HWDB,
                            "HwpAddPnpIdsInInf: error retrieving PNPID field(s) in line %u in [%s]",
                            isMfg.Line,
                            manufacturer
                            ));
                        continue;
                    }

                    //
                    // Add each device id to the hash table
                    //
                    p = pnpId;
                    while (*p) {
                        BOOL b = TRUE;
                        //
                        // first invoke the callback (if specified)
                        //
                        if (Callback) {
                            if (CallbackIsUnicode) {
                                PCWSTR uPnpid = ConvertAtoW (p);
                                if (!uPnpid) {
                                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                                    __leave;
                                }
                                if (!uInfPath) {
                                    uInfPath = ConvertAtoW (InfPath);
                                }
                                if (!uSourceDirectory) {
                                    uSourceDirectory = ConvertAtoW (SourceDirectory);
                                }
                                if (!uInfFilename) {
                                    uInfFilename = ConvertAtoW (InfFilename);
                                }
                                b = (*(HWDBAPPENDINFSCALLBACKW)Callback) (CallbackContext, uPnpid, uInfFilename, uSourceDirectory, uInfPath);
                                FreeConvertedStr (uPnpid);
                            } else {
                                b = (*Callback) (CallbackContext, p, InfFilename, SourceDirectory, InfPath);
                            }
                        }
                        if (b) {
                            //
                            // First time through add the INF file name to string table
                            //
                            if (!infOffset) {
                                if (Hwdb->InfFileTable) {
                                    fileName = _mbsrchr (InfPath, '\\') + 1;
                                    infOffset = HtAddStringA (Hwdb->InfFileTable, fileName);
                                    if (!infOffset) {
                                        DEBUGMSGA ((DBG_ERROR, "Cannot add %s to table of INFs.", fileName));
                                        __leave;
                                    }
                                }
                            }

                            if (FAILED (StringCchCopyA (trimmedPnpId, ARRAYSIZE(trimmedPnpId), SkipSpaceA (p)))) {
                                __leave;
                            }
                            TruncateTrailingSpaceA (trimmedPnpId);

                            if (!HtAddStringExA (
                                        unsupportedDevice ? Hwdb->UnsupPnpIdTable : Hwdb->PnpIdTable,
                                        trimmedPnpId,
                                        (PVOID)&infOffset,
                                        CASE_INSENSITIVE
                                        )) {
                                DEBUGMSGA ((
                                    DBG_ERROR,
                                    "HwpAddPnpIdsInInf: cannot add %s to table of PNP IDs",
                                    trimmedPnpId
                                    ));
                                __leave;
                            }
                        }

                        p = GetEndOfStringA (p) + 1;
                    }

                } while (SetupFindNextLine (&isMfg, &isMfg));

            } while (SetupFindNextLine (&is, &is));

        } else {

            rc = GetLastError();
            //
            // If section not found, return success
            //
            if (rc == ERROR_SECTION_NOT_FOUND || rc == ERROR_LINE_NOT_FOUND) {
                SetLastError (ERROR_SUCCESS);
                DEBUGMSGA ((
                    DBG_HWDB,
                    "HwpAddPnpIdsInInf: %s has no [manufacturer] section or it's empty",
                    InfPath
                    ));
            } else {
                DEBUGMSGA ((
                    DBG_ERROR,
                    "HwpAddPnpIdsInInf: error trying to find the [manufacturer] section",
                    InfPath
                    ));
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {
        PushError();
        SetupCloseInfFile (inf);
        FreeConvertedStr (uInfPath);
        FreeConvertedStr (uSourceDirectory);
        FreeConvertedStr (uInfFilename);
        PopError();
        DEBUGMSGA ((DBG_HWDB, "HwpAddPnpIdsInInf: done parsing %s", InfPath));
    }

    return result;
}


BOOL
HwdbpAppendInfs (
    IN      PHWDB Hwdb,
    IN      PCSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext,                  OPTIONAL
    IN      BOOL CallbackIsUnicode
    )
{
    HANDLE h;
    WIN32_FIND_DATA fd;
    CHAR buffer[MAX_PATH];
    CHAR uncompressedFile[MAX_PATH];
    CHAR fullPath[MAX_PATH];
    DWORD rc;

    if (!g_TempDir) {
        //
        // the temp dir must be set first
        //
        SetLastError (ERROR_INVALID_FUNCTION);
        return FALSE;
    }

    if (FAILED (StringCchPrintfA (buffer, ARRAYSIZE(buffer), "%s\\*.in?", SourceDirectory))) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSGA ((
            DBG_ERROR,
            "HwdbpAppendInfs: SourceDir name too long: %s",
            SourceDirectory
            ));
        return FALSE;
    }

    h = FindFirstFileA (buffer, &fd);
    if (h != INVALID_HANDLE_VALUE) {
        do {
            if (!HwpIsValidInfName (fd.cFileName, buffer, ARRAYSIZE(buffer))) {
                continue;
            }
            if (*buffer) {
                if (FAILED (StringCchPrintfA (uncompressedFile, ARRAYSIZE(uncompressedFile), "%s\\%s", g_TempDir, buffer))) {
                    SetLastError (ERROR_INVALID_PARAMETER);
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "HwdbpAppendInfs: file name too long: %s\\%s",
                        g_TempDir,
                        buffer
                        ));
                    continue;
                }
                if (FAILED (StringCchPrintfA (fullPath, ARRAYSIZE(fullPath), "%s\\%s", SourceDirectory, fd.cFileName))) {
                    SetLastError (ERROR_INVALID_PARAMETER);
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "HwdbpAppendInfs: file name too long: %s\\%s",
                        SourceDirectory,
                        fd.cFileName
                        ));
                    continue;
                }

                SetFileAttributesA (uncompressedFile, FILE_ATTRIBUTE_NORMAL);
                DeleteFileA (uncompressedFile);

                rc = SetupDecompressOrCopyFileA (fullPath, uncompressedFile, 0);

                if (rc != ERROR_SUCCESS) {
                    LOGA ((
                        LOG_ERROR,
                        "HwdbpAppendInfs: Could not decompress %s to %s",
                        fullPath,
                        uncompressedFile
                        ));
                    continue;
                }
            } else {
                if (FAILED (StringCchPrintfA (uncompressedFile, ARRAYSIZE(uncompressedFile), "%s\\%s", SourceDirectory, fd.cFileName))) {
                    SetLastError (ERROR_INVALID_PARAMETER);
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "HwdbpAppendInfs: file name too long: %s\\%s",
                        g_TempDir,
                        buffer
                        ));
                    continue;
                }
            }

            if (!HwpAddPnpIdsInInf (
                    uncompressedFile,
                    Hwdb,
                    SourceDirectory,
                    *buffer ? buffer : fd.cFileName,
                    Callback,
                    CallbackContext,
                    CallbackIsUnicode
                    )) {
                DEBUGMSGA ((
                    DBG_ERROR,
                    "HwdbpAppendInfs: HwpAddPnpIdsInInf(%s) failed",
                    *buffer ? fullPath : uncompressedFile
                    ));
                continue;
            }

            if (*buffer) {
                SetFileAttributesA (uncompressedFile, FILE_ATTRIBUTE_NORMAL);
                DeleteFileA (uncompressedFile);
            }
        } while (FindNextFile (h, &fd));

        FindClose (h);
    }

    return TRUE;
}


BOOL
pAppendToHashTable (
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    )
{
    MYASSERT (lParam);
    return HtAddStringA ((HASHTABLE)lParam, String) != NULL;
}


BOOL
HwdbpAppendDatabase (
    IN      PHWDB HwdbTarget,
    IN      PHWDB HwdbSource
    )
{
#if 0
    BOOL b = TRUE;

    if (HwdbSource->PnpIdTable) {
        if (!HwdbTarget->PnpIdTable) {
            HwdbTarget->PnpIdTable = HtAllocWithData (sizeof (HASHITEM*));
            if (!HwdbTarget->PnpIdTable) {
                b = FALSE;
            }
        }
        if (b) {
            b = EnumHashTableWithCallbackA (
                    HwdbSource->PnpIdTable,
                    pAppendToHashTable,
                    HwdbTarget->PnpIdTable
                    );
        }
    }
    if (b && HwdbSource->UnsupPnpIdTable) {
        if (!HwdbTarget->UnsupPnpIdTable) {
            HwdbTarget->UnsupPnpIdTable = HtAllocWithData (sizeof (HASHITEM*));
            if (!HwdbTarget->UnsupPnpIdTable) {
                b = FALSE;
            }
        }
        if (b) {
            b = EnumHashTableWithCallbackA (
                    HwdbSource->UnsupPnpIdTable,
                    pAppendToHashTable,
                    HwdbTarget->UnsupPnpIdTable
                    );
        }
    }

    return b;
#endif
    //
    // not implemented
    //
    return FALSE;
}


BOOL
HwdbpHasDriver (
    IN      PHWDB Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    )

/*++

Routine Description:

  HwdbpHasDriver determines if the PnpId is in the database

Arguments:

  Hwdb - Specifies the database to search

  PnpId - Specifies the PNPID to look for

  Unsupported - Receives TRUE if the PNPID is unsupported

Return Value:

  TRUE if the database has the PNPID

--*/

{
    if (!Hwdb || !PnpId || !Unsupported) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // check if it's unsupported first
    //
    if (HtFindStringA (Hwdb->UnsupPnpIdTable, PnpId)) {
        *Unsupported = TRUE;
        return TRUE;
    }

    if (!HtFindStringA (Hwdb->PnpIdTable, PnpId)) {
        return FALSE;
    }

    //
    // fill out info
    //
    *Unsupported = FALSE;

    return TRUE;
}


BOOL
HwdbpHasAnyDriver (
    IN      PHWDB Hwdb,
    IN      PCSTR PnpIds,
    OUT     PBOOL Unsupported
    )

/*++

Routine Description:

  HwdbpHasAnyDriver determines if any PNPID from the PnpIds multisz is in the database

Arguments:

  Hwdb - Specifies the database to search

  PnpIds - Specifies the list (multisz) of PNPIDs to look for

  Unsupported - Receives TRUE if any PNPID in this list is unsupported

Return Value:

  TRUE if the database has at least one of the PNPIDs in the list

--*/

{
    BOOL bFound = FALSE;
    PCSTR pnpID;

    if (!Hwdb || !PnpIds || !Unsupported) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for (pnpID = PnpIds; *pnpID; pnpID = strchr (pnpID, 0) + 1) {
        //
        // check if it's unsupported first
        //
        if (HtFindStringA (Hwdb->UnsupPnpIdTable, pnpID)) {
            *Unsupported = TRUE;
            return TRUE;
        }

        if (HtFindStringA (Hwdb->PnpIdTable, pnpID)) {
            bFound = TRUE;
        }
    }

    //
    // fill out info
    //
    *Unsupported = FALSE;

    return bFound;
}

#if 0

typedef struct {
    PHWDB Hwdb;
    PHWDBENUM_CALLBACKA EnumCallback;
    PVOID UserContext;
} HWDBENUM_DATAA, *PHWDBENUM_DATAA;

typedef struct {
    PHWDB Hwdb;
    PHWDBENUM_CALLBACKW EnumCallback;
    PVOID UserContext;
} HWDBENUM_DATAW, *PHWDBENUM_DATAW;


BOOL
pCallbackEnumA (
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCSTR PnpId,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    )
{
    PHWDBENUM_DATAA ped = (PHWDBENUM_DATAA)lParam;
/*
    PPNPID_DATA data = (PPNPID_DATA)ExtraData;

    MYASSERT (ExtraDataSize == sizeof (PNPID_DATA);

    return (*ped->EnumCallback) (
                ped->UserContext,
                PnpId,
                pGetInfPath (ped->Hwdb, data->InfOffset),
                data->Flags
                );
*/
    return FALSE;
}

BOOL
HwdbpEnumeratePnpIdA (
    IN      PHWDB Hwdb,
    IN      PHWDBENUM_CALLBACKA EnumCallback,
    IN      PVOID UserContext
    )
{
    HWDBENUM_DATAA ed;

    if (!Hwdb || !EnumCallback) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    ed.Hwdb = Hwdb;
    ed.EnumCallback = EnumCallback;
    ed.UserContext = UserContext;
    return EnumHashTableWithCallbackA (Hwdb->PnpIdTable, pCallbackEnumA, (LPARAM)&ed);
}

BOOL
pCallbackEnumW (
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCSTR PnpId,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    )
{
    PHWDBENUM_DATAW ped = (PHWDBENUM_DATAW)lParam;
/*
    PPNPID_DATA data = (PPNPID_DATA)ExtraData;

    MYASSERT (ExtraDataSize == sizeof (PNPID_DATA);

    return (*ped->EnumCallback) (
                ped->UserContext,
                PnpId,
                pGetInfPath (ped->Hwdb, data->InfOffset),
                data->Flags
                );
*/
    return FALSE;
}

BOOL
HwdbpEnumeratePnpIdW (
    IN      PHWDB Hwdb,
    IN      PHWDBENUM_CALLBACKW EnumCallback,
    IN      PVOID UserContext
    )
{
    HWDBENUM_DATAW ed;

    if (!Hwdb || !EnumCallback) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    ed.Hwdb = Hwdb;
    ed.EnumCallback = EnumCallback;
    ed.UserContext = UserContext;
    return EnumHashTableWithCallbackA (Hwdb->PnpIdTable, pCallbackEnumW, (LPARAM)&ed);
}

#endif


BOOL
HwdbpEnumFirstInfA (
    OUT     PHWDBINF_ENUMA EnumPtr,
    IN      PCSTR DatabaseFile
    )
{
    CHAR buffer[MAX_PATH];
    CHAR sig[sizeof (HWCOMPDAT_SIGNATURE)];
    DWORD checksum;
    DWORD rc;
    DWORD BytesRead;
    HASHITEM infOffset;
    PHWDBINF_ENUM_INTERNAL pei;

    if (!DatabaseFile || !EnumPtr) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!GetFullPathNameA (DatabaseFile, MAX_PATH, buffer, NULL)) {
        return FALSE;
    }

    EnumPtr->Internal = (PHWDBINF_ENUM_INTERNAL) MemAlloc (g_hHwdbHeap, 0, sizeof (HWDBINF_ENUM_INTERNAL));
    if (!EnumPtr->Internal) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }
    ZeroMemory (EnumPtr->Internal, sizeof (HWDBINF_ENUM_INTERNAL));
    pei = (PHWDBINF_ENUM_INTERNAL)EnumPtr->Internal;

    //
    // Try to open the file
    //
    pei->File = CreateFileA (
                        buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ,            // share for read access
                        NULL,                       // no security attribs
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL                        // no template
                        );
    if (pei->File == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Look at the signature
    //
    ZeroMemory (sig, sizeof(sig));
    if (!ReadFile (pei->File, sig, sizeof (HWCOMPDAT_SIGNATURE) - 1, &BytesRead, NULL) ||
        lstrcmpA (HWCOMPDAT_SIGNATURE, sig)
        ) {
        SetLastError (ERROR_BAD_FORMAT);
        goto exit;
    }

    //
    // Get INF checksum
    //
    if (!pReadDword (pei->File, &checksum)) {
        SetLastError (ERROR_BAD_FORMAT);
        goto exit;
    }
    //
    // Read in all PNP IDs
    //
    return HwdbpEnumNextInfA (EnumPtr);

exit:
    HwdbpAbortEnumInfA (EnumPtr);
    return FALSE;
}


BOOL
HwdbpEnumFirstInfW (
    OUT     PHWDBINF_ENUMW EnumPtr,
    IN      PCSTR DatabaseFile
    )
{
    HWDBINF_ENUMA ea;

    if (!HwdbpEnumFirstInfA (&ea, DatabaseFile)) {
        return FALSE;
    }
    EnumPtr->Internal = ea.Internal;
    EnumPtr->InfFile = ConvertAtoW (ea.InfFile);
    EnumPtr->PnpIds = pConvertMultiSzToUnicode (ea.PnpIds);
    if (EnumPtr->InfFile && EnumPtr->PnpIds) {
        return TRUE;
    }
    HwdbpAbortEnumInfW (EnumPtr);
    return FALSE;
}


BOOL
HwdbpEnumNextInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    )
{
    CHAR pnpId[1024];
    PHWDBINF_ENUM_INTERNAL pei = (PHWDBINF_ENUM_INTERNAL)EnumPtr->Internal;

    //
    // Get next INF file name.  If empty, we are done.
    //
    if (!pReadString (pei->File, EnumPtr->InfFile, sizeof (EnumPtr->InfFile))) {
        SetLastError (ERROR_BAD_FORMAT);
        goto exit;
    }
    if (EnumPtr->InfFile[0] == 0) {
        SetLastError (ERROR_SUCCESS);
        goto exit;
    }

    //
    // Read in all PNP IDs for the INF
    //
    for (;;) {
        //
        // Get the PNP ID.  If empty, we are done.
        //
        if (!pReadString (pei->File, pnpId, sizeof (pnpId))) {
            SetLastError (ERROR_BAD_FORMAT);
            goto exit;
        }
        if (*pnpId == 0) {
            break;
        }

        if (!MultiSzAppendA (&pei->GrowBuf, pnpId)) {
            SetLastError (ERROR_OUTOFMEMORY);
            goto exit;
        }
    }

    EnumPtr->PnpIds = (PCSTR)pei->GrowBuf.Buf;

    return TRUE;

exit:
    HwdbpAbortEnumInfA (EnumPtr);
    return FALSE;
}

BOOL
HwdbpEnumNextInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    )
{
    HWDBINF_ENUMA ea;

    ea.Internal = EnumPtr->Internal;

    if (!HwdbpEnumNextInfA (&ea)) {
        return FALSE;
    }
    EnumPtr->InfFile = ConvertAtoW (ea.InfFile);
    EnumPtr->PnpIds = pConvertMultiSzToUnicode (ea.PnpIds);
    if (EnumPtr->InfFile && EnumPtr->PnpIds) {
        return TRUE;
    }
    HwdbpAbortEnumInfW (EnumPtr);
    return FALSE;
}

VOID
HwdbpAbortEnumInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    )
{
    PHWDBINF_ENUM_INTERNAL pei = (PHWDBINF_ENUM_INTERNAL)EnumPtr->Internal;
    DWORD rc = GetLastError ();

    if (pei) {
        if (pei->File != INVALID_HANDLE_VALUE) {
            CloseHandle (pei->File);
            pei->File = INVALID_HANDLE_VALUE;
        }
        FreeGrowBuffer (&pei->GrowBuf);
    }

    SetLastError (rc);
}


VOID
HwdbpAbortEnumInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    )
{
    PHWDBINF_ENUM_INTERNAL pei = (PHWDBINF_ENUM_INTERNAL)EnumPtr->Internal;
    DWORD rc = GetLastError ();

    if (EnumPtr->InfFile) {
        FreeConvertedStr (EnumPtr->InfFile);
        EnumPtr->InfFile = NULL;
    }
    if (EnumPtr->PnpIds) {
        FreeConvertedStr (EnumPtr->PnpIds);
        EnumPtr->PnpIds = NULL;
    }
    if (pei) {
        if (pei->File != INVALID_HANDLE_VALUE) {
            CloseHandle (pei->File);
            pei->File = INVALID_HANDLE_VALUE;
        }
        FreeGrowBuffer (&pei->GrowBuf);
    }

    SetLastError (rc);
}

BOOL
HwdbpSetTempDir (
    IN      PCSTR TempDir
    )
{
    BOOL b = TRUE;

    if (TempDir) {
        g_TempDir = DuplicateTextA (TempDir);
        if (!g_TempDir) {
            b = FALSE;
        }
    } else {
        if (g_TempDir) {
            FreeTextA (g_TempDir);
            g_TempDir = NULL;
        }
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hwlog\hwlog.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ntsetup\hwlog\hwlog.c

Abstract:

    Logging some aspects of the hardware configuration to winnt32.log / setupact.log.
    Esp. disk drive by connection, and map drive letters to disk drives.

Author:

    Jay Krell (JayKrell) April 2001, May 2001

Revision History:

Environment:

    winnt32.dll -- Win9x ANSI (down to Win95gold) or NT Unicode
                   libcmt statically linked in, _tcs* ok
                   actually only built for Unicode/NT, and does nothing
                   if run on less than Windows 2000

    setup.exe -newsetup -- guimode setup
--*/

/* Platform notes
Win95:
 apparently no setupapi.dll (redist)
 apparently no cfgmgr32.dll
 no kernel32.dll::GetVolumeNameForVolumeMountPoint
NT 3.1
 no kernel32.dll::GetVolumeNameForVolumeMountPoint
NT 3.51
 apparently no setupapi.dll
 apparently no cfgmgr32.dll
 no kernel32.dll::GetVolumeNameForVolumeMountPoint
NT4
 no kernel32.dll::GetVolumeNameForVolumeMountPoint
 setupapi.dll
   has SetupDiGetClassDevs
   does not have SetupDiGetClassDevsEx
   does not have SetupDiEnumDeviceInterfaces
   does not have SetupDiGetDeviceInterfaceDetail
 cfgmgr32.dll
   has the functions we call
Win2000, WinXp:
 has all the functions we call
Win98, Win98se:
 no kernel32.dll::GetVolumeNameForVolumeMountPoint
 setupapi.dll, has everything we use
   has SetupDiGetClassDevs
   has SetupDiGetClassDevsEx
   has SetupDiEnumDeviceInterfaces
   has SetupDiGetDeviceInterfaceDetail
 cfgmgr32.dll, has everything we use
    has CM_Get_Parent_Ex
    has CM_Connect_MachineA
    has CM_Get_DevNode_Registry_Property_ExA

existing versions of

winnt32a.dll
    not statically dependent on setupapi.dll
    not statically dependent on cfgmgr32.dll
winnt32u.dll
    not statically dependent on setupapi.dll
    statically dependent on cfgmgr32.dll, all functions exported on NT4 and Win98
        CM_Get_Device_ID_List_SizeW
        CM_Get_Device_ID_ListW
        CM_Get_DevNode_Registry_PropertyW
        CM_Locate_DevNodeW

conclusions
    works on Win2000 and WinXp
    maybe some of it works on Win98, Win98se, Win9me
    maybe can be changed slightly to work on NT4
    cannot easily work on NT 3 or Win95
    but GetVolumeNameForVolumeMountPoint and the DeviceIoControl might prevent it
    dynamically link it "all"
*/

#define STANDALONE 0
#define DYNLINK    1

#if STANDALONE

#define UNICODE
#define _UNICODE

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0501
#endif
// from windows.h, but we want this before nt.h
#if !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#define _X86_
#endif

#if !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#if !defined(_IA64_) && !defined(_X86_) && !defined(_M_IX86) && !defined(_AMD64_) && defined(_M_IA64)
#define _IA64_
#endif

#include "io.h"

#if !defined(_WIN64)
typedef unsigned long ULONG_PTR; // vc6 compatibility
typedef unsigned long DWORD_PTR; // vc6 compatibility
#endif

#endif

#include <stdio.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "cfgmgr32.h"
#include "objbase.h"
#include "initguid.h"
#include "devguid.h"
#include "setupapi.h"
#include "winioctl.h"
#include <stdlib.h>
#include "tchar.h"
#include <stdarg.h>
#include <stdlib.h>
#include "hwlog.h"
typedef CONST VOID* PCVOID;

struct _SP_LINKAGE;
typedef struct _SP_LINKAGE SP_LINKAGE, *PSP_LINKAGE;
typedef CONST SP_LINKAGE* PCSP_LINKAGE;

typedef struct _SP_MACHINE {
    PCTSTR      Name;   // for setupapi.dll functions
    HMACHINE    Handle; // for cfgmgr32.dll functions
} SP_MACHINE, *PSP_MACHINE;
typedef CONST SP_MACHINE* PCSP_MACHINE;

typedef struct _SP_LOG_HARDWARE {
    SP_MACHINE  Machine;
    HANDLE      LogFile;
#if !DYNLINK
    CONST
#endif
    SP_LINKAGE* Linkage;
    BOOL (WINAPI* SetupLogError)(PCTSTR MessageString, LogSeverity);
    BOOL (__cdecl * SetuplogError)(
        IN  LogSeverity         Severity,
        IN  LPCTSTR             MessageString,
        IN  UINT                MessageId,      OPTIONAL
        ...
        ) OPTIONAL;
} SP_LOG_HARDWARE, *PSP_LOG_HARDWARE;
typedef CONST SP_LOG_HARDWARE* PCSP_LOG_HARDWARE;

#if STANDALONE || defined(UNICODE)

#define QUASH_SIMPLE_PHYSICAL_DEVICE_OBJECT_NAMES 1
#define INDENT_FACTOR          2
#define UNAVAILABLE_VERBOSE    1
#if 0 /* this is more like a small tree, one device per line, indenting */
#define ONE_PROPERTY_PER_LINE  0
#define INDENT_CHILDREN        1
#define NUMBER_CHILDREN        0
#define DESCRIPTION_DASH_PHYSICAL_DEVICE_OBJECT 0
#else
#define ONE_PROPERTY_PER_LINE  1
#define INDENT_CHILDREN        0
#define NUMBER_CHILDREN        1
#define DESCRIPTION_DASH_PHYSICAL_DEVICE_OBJECT 1
#endif
#define ONE_DEVICE_PER_LINE    (!ONE_PROPERTY_PER_LINE)

#if !defined(DBG)
#define DBG 1
#endif
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

#if !defined(ISNT)
#if STANDALONE || !defined(UNICODE)
#define ISNT()                    ((GetVersion() & 0x80000000) == 0)
#else
#define ISNT()                    TRUE
#endif
#endif
#define SP_FILE_SHARE_DELETE()    (ISNT() ? FILE_SHARE_DELETE : 0)

// RTL_* from ntdef.h
#define FIELD_TYPE(type, field)    (((type*)0)->field)
#define BITS_OF_FIELD(type, field) (BITS_OF(FIELD_TYPE(type, field)))
#define BITS_OF(sizeOfArg)         (sizeof(sizeOfArg) * 8)

#define xPASTE(x,y) x##y
#define PASTE(x,y) xPASTE(x,y)

typedef struct _SP_LINKAGE
{
#if DYNLINK
#define U(x) union { PCSTR PASTE(Name, __LINE__); x; }
#else
#define U(x) x
#endif

    PCSTR Kernel32Dll;
    U(BOOL (WINAPI* GetVolumeNameForVolumeMountPoint)(PCTSTR lpszVolumeMountPoint, PTSTR lpszVolumeName, DWORD cchBufferLength));

    PCSTR Setupapidll;
    U(BOOL (WINAPI* SetupDiEnumDeviceInterfaces)(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, CONST GUID* InterfaceClassGuid, DWORD MemberIndex, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData));
    U(HDEVINFO (WINAPI* SetupDiGetClassDevsEx)(CONST GUID* ClassGuid, PCTSTR Enumerator, HWND hwndParent, DWORD Flags, HDEVINFO DeviceInfoSet, PCTSTR MachineName, PVOID Reserved));
    U(BOOL (WINAPI* SetupDiGetDeviceInterfaceDetail)(HDEVINFO DeviceInfoSet, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData, DWORD DeviceInterfaceDetailDataSize, PDWORD RequiredSize, PSP_DEVINFO_DATA DeviceInfoData));
    U(CONFIGRET (WINAPI* CM_Get_Parent_Ex)(OUT PDEVINST pdnDevInst, IN  DEVINST  dnDevInst, IN  ULONG ulFlags, IN  HMACHINE hMachine));
    U(CONFIGRET (WINAPI* CM_Connect_Machine)(IN  PCTSTR UNCServerName, OUT PHMACHINE phMachine));
    U(CONFIGRET (WINAPI* CM_Get_DevNode_Registry_Property_Ex)(
            IN DEVINST dnDevInst, IN ULONG ulProperty,
            OUT PULONG pulRegDataType OPTIONAL, OUT PVOID Buffer OPTIONAL,
            IN OUT PULONG pulLength, IN ULONG ulFlags, IN HMACHINE hMachine));

#undef U
} SP_LINKAGE;

#if defined(UNICODE)
#define T "W"
#else
#define T "A"
#endif
#if !DYNLINK
CONST
#endif
static SP_LINKAGE SpLinkage =
{
#if DYNLINK
    //
    // note: lowercase => .dll name
    //
    "kernel32.dll",
    "GetVolumeNameForVolumeMountPoint" T,

    "setupapi.dll",
    "SetupDiEnumDeviceInterfaces",
    "SetupDiGetClassDevsEx" T,
    "SetupDiGetDeviceInterfaceDetail" T,
    "CM_Get_Parent_Ex",
    "CM_Connect_Machine" T,
    "CM_Get_DevNode_Registry_Property_Ex" T
#undef T
#else
    NULL, // kernel32
    GetVolumeNameForVolumeMountPoint,

    NULL, // setupapi
    SetupDiEnumDeviceInterfaces,
    SetupDiGetClassDevsEx,
    SetupDiGetDeviceInterfaceDetail,
    CM_Get_Parent_Ex,
    CM_Connect_Machine,
    CM_Get_DevNode_Registry_Property_Ex
#endif
};

BOOL
SpDoDynlink(
    PSP_LOG_HARDWARE This
    )
{
#if DYNLINK
    SIZE_T i;
    FARPROC* rgproc = (FARPROC*)This->Linkage;
    PCSTR* rgpsz = (PCSTR*)This->Linkage;
    HMODULE DllHandle;

    for (i = 0 ; i != sizeof(SpLinkage)/sizeof(PVOID) ; ++i)
    {
        if (islower(rgpsz[i][0]))
        {
            if ((DllHandle = LoadLibraryA(rgpsz[i])) == NULL)
                return FALSE;
        }
        else if ((rgproc[i] = GetProcAddress(DllHandle, rgpsz[i])) == NULL)
        {
            return FALSE;
        }
    }
#endif
    return TRUE;
}

PCTSTR
SpGetSpacesString(
    SIZE_T n
    );

PCTSTR
SpGetDashesString(
    SIZE_T n
    );

PVOLUME_DISK_EXTENTS
SpGetVolumeDiskExtents(
    HANDLE DeviceFileHandle
    );

//
// need a downlevel static .lib version of ntdll.dll..
//
typedef struct SP_STRING {
    PTSTR  Chars;
    SIZE_T Length;
    SIZE_T MaximumLength;
} SP_STRING, *PSP_STRING;
typedef CONST SP_STRING* PCSP_STRING;

#define SpStringLength(s) ((s)->Length)

#define SpInitString(s, t) \
    ((s)->MaximumLength = sizeof((s)->Chars[0]) + ((s)->Length = lstrlen((s)->Chars = (PTSTR)t)))

VOID
SpHwDebugLog(
    PSP_LOG_HARDWARE This,
    PCTSTR           Format,
    ...
    );

VOID SpStringAppendFormatVa(PSP_STRING Buffer, PCSP_STRING Format, va_list va)
{
    if (Buffer->MaximumLength > Buffer->Length + 1)
    {
        _vsntprintf(
            Buffer->Chars + Buffer->Length,
            Buffer->MaximumLength - Buffer->Length,
            Format->Chars,
            va
            );
    }
    Buffer->Chars[Buffer->MaximumLength - 1] = 0;
}

VOID SpStringAppendFormat(PSP_STRING Buffer, PCSP_STRING Format, ...)
{
    va_list va;

    va_start(va, Format);
    SpStringAppendFormatVa(Buffer, Format, va);
    va_end(va);
}

VOID SpStringAppend(PSP_STRING s, PCSP_STRING t)
{
    SP_STRING Format;

    Format.Chars = TEXT("%s");
    Format.Length = 2;

    SpStringAppendFormat(s, &Format, t);
}

VOID SpStringCopy(PSP_STRING s, PCSP_STRING t)
{
    s->Chars[0] = 0;
    SpStringAppend(s, t);
}

VOID SpStringFormat(PSP_STRING s, PCSP_STRING Format, ...)
{
    va_list va;
    va_start(va, Format);

    s->Chars[0] = 0;
    SpStringAppendFormatVa(s, Format, va);

    va_end(va);
}

PVOID SpMalloc(SIZE_T n)
{ 
    return HeapAlloc(GetProcessHeap(), 0, n);
}

VOID SpFree(PVOID p)
{ 
    HeapFree(GetProcessHeap(), 0, p);
}

PVOID SpRealloc(PVOID p, SIZE_T n)
{ 
    return HeapReAlloc(GetProcessHeap(), 0, p, n);
}

VOID SpStringFree(PTSTR s) {  SpFree(s); }

VOID SpRemoveTrailingChars(PSP_STRING s, PCTSTR ch)
{
    while (s->Length != 0
        && (s->Chars[s->Length - 1] == ch[0] || s->Chars[s->Length - 1] == ch[1])
        && !(s->Chars[s->Length - 1] = 0)
        && (s->Length -= 1)
        )
    {
        // nothing
    }
}

VOID SpEnsureTrailingChar(PSP_STRING s, TCHAR ch)
{
    if (s->Length == 0
        || s->Chars[s->Length - 1] != ch)
    {
        s->Length += 1;
        s->Chars[s->Length - 1] = ch;
        s->Chars[s->Length] = 0;
    }
}

//
// for now, let's hope that device numbers stay in the range 0-63
//
typedef struct SP_DEVICE_NUMBERS {
    ULONGLONG Bitset;
} SP_DEVICE_NUMBERS, *PSP_DEVICE_NUMBERS;
typedef CONST SP_DEVICE_NUMBERS* PCSP_DEVICE_NUMBERS;

typedef struct SP_VOLUME
{
    PTSTR GuidVolumeNamePointer; // if this is null, use GuidVolumeNameBuffer
    TCHAR GuidVolumeNameBuffer[64];  // \\?\{guid}
#define SP_VOLUME_GET_NAME(v) (((v)->GuidVolumeNamePointer != NULL) ? (v)->GuidVolumeNamePointer : (v)->GuidVolumeNameBuffer)

//
// DiskNumbers are gotten via DeviceIoControl(STORAGE_DEVICE_NUMBER) (Win2K)
// and DeviceIoControl(IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS) (Whistler)
//
    ULONG             DeviceType;
    SP_DEVICE_NUMBERS DeviceNumbers;
    TCHAR  DriveLetter;
} SP_VOLUME, *PSP_VOLUME;
typedef CONST SP_VOLUME* PCSP_VOLUME;

//
// most systems are limited to 24 volumes, C-Z, unless they use
// mount points, and setup is unlikely to be affected by those volumes
//
typedef struct _SP_VOLUMES {
    SP_VOLUME Entries[24];
} SP_VOLUMES, *PSP_VOLUMES;
typedef CONST SP_VOLUMES* PCSP_VOLUMES;

#define SP_PROPERTY_QUIET_UNAVAILABLE (0x00000001)

typedef struct _SP_DEVICE_PROPERTY_CONST {
    //ULONG   SetupapiInteger;
    ULONG   ConfigManagerInteger;
    PCTSTR  Name;
    ULONG   Flags;
}  SP_DEVICE_PROPERTY_CONST, *PSP_DEVICE_PROPERTY_CONST;
typedef CONST SP_DEVICE_PROPERTY_CONST* PCSP_DEVICE_PROPERTY_CONST;

#if ONE_DEVICE_PER_LINE
//CONST static TCHAR FriendlyNameString[] = TEXT("FriendlyName");
//CONST static TCHAR DescriptionString[] = TEXT("Description");
CONST static TCHAR PhysicalDeviceObjectNameString[] = TEXT("");
CONST static TCHAR HardwareIdString[] = TEXT("");
CONST static TCHAR LowerFiltersString[] = TEXT("");
CONST static TCHAR UpperFiltersString[] = TEXT("");
//CONST static TCHAR FlagsString[] = TEXT("");
CONST static TCHAR LocationInformationString[] = TEXT("");
#else
//CONST static TCHAR FriendlyNameString[] = TEXT("FriendlyName");
//CONST static TCHAR DescriptionString[] = TEXT("Description");
CONST static TCHAR PhysicalDeviceObjectNameString[] = TEXT("PhysicalDeviceObjectName");
CONST static TCHAR HardwareIdString[] = TEXT("HardwareId");
CONST static TCHAR LowerFiltersString[] = TEXT("LowerFilters");
CONST static TCHAR UpperFiltersString[] = TEXT("UpperFilters");
//CONST static TCHAR FlagsString[] = TEXT("Flags");
CONST static TCHAR LocationInformationString[] = TEXT("Location");
#endif

#define SETUPAPI_PROPERTY_NUMBER(x) /* nothing */

#define DESCRIPTION             0
#define PHYSICAL_DEVICE_OBJECT  1
#define FRIENDLY_NAME           2
#define HARDWARE_ID             3
#define FIRST_GENERIC_PROPERTY  4

CONST static SP_DEVICE_PROPERTY_CONST DevicePropertyMetaInfo[] =
{
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_DEVICEDESC) CM_DRP_DEVICEDESC, TEXT(""), SP_PROPERTY_QUIET_UNAVAILABLE },
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_PHYSICAL_DEVICE_OBJECT_NAME) CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME, PhysicalDeviceObjectNameString },
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_FRIENDLYNAME) CM_DRP_FRIENDLYNAME, TEXT(""), SP_PROPERTY_QUIET_UNAVAILABLE },
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_HARDWAREID) CM_DRP_HARDWAREID, HardwareIdString },
    { SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_LOCATION_INFORMATION, LocationInformationString, SP_PROPERTY_QUIET_UNAVAILABLE },
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_LOWERFILTERS) CM_DRP_LOWERFILTERS, LowerFiltersString, SP_PROPERTY_QUIET_UNAVAILABLE },
    { SETUPAPI_PROPERTY_NUMBER(SPDRP_UPPERFILTERS) CM_DRP_UPPERFILTERS, UpperFiltersString, SP_PROPERTY_QUIET_UNAVAILABLE },
    //{ SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_CONFIGFLAGS, FlagsString },
    //{ SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_CAPABILITIES, TEXT("Capabilities") },
    //{ SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_UI_NUMBER, TEXT("UI Number") },
    //{ SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_CHARACTERISTICS, TEXT("Characteristics") },
    //{ SETUPAPI_PROPERTY_NUMBER(x) CM_DRP_ADDRESS, TEXT("Address") },
};

typedef struct _SP_DEVICE_PROPERTY {
    PCSP_DEVICE_PROPERTY_CONST   Const;
    TCHAR                        Value[256];
    ULONG                        Type;
} SP_DEVICE_PROPERTY, *PSP_DEVICE_PROPERTY;
typedef CONST SP_DEVICE_PROPERTY* PCSP_DEVICE_PROPERTY;

typedef struct _SP_DEVICE_CLASS {
    CONST GUID* Guid;
    ULONG       IsInterface;
    //PCTSTR       Name;
} SP_DEVICE_CLASS, *PSP_DEVICE_CLASS;
typedef CONST SP_DEVICE_CLASS* PCSP_DEVICE_CLASS;

/*
CONST static TCHAR VolumesString[] = TEXT("Volumes");
CONST static TCHAR DisksString[] = TEXT("Disks");
CONST static TCHAR CDROMsString[] = TEXT("CDROMs");
CONST static TCHAR PartitionsString[] = TEXT("Partitions");
*/

CONST static SP_DEVICE_CLASS DeviceClasses[] =
{
    { &GUID_DEVINTERFACE_CDROM, DIGCF_DEVICEINTERFACE,      /*CDROMsString*/ },
    { &GUID_DEVINTERFACE_DISK, DIGCF_DEVICEINTERFACE,       /*DisksString*/ },
    { &GUID_DEVINTERFACE_PARTITION, DIGCF_DEVICEINTERFACE,  /*PartitionsString*/ },
    // The information this adds is not very useful.
    //{ &GUID_DEVINTERFACE_VOLUME, DIGCF_DEVICEINTERFACE,     /*VolumesString*/ },
};

typedef struct _SP_DEVICE {
    PCSP_DEVICE_CLASS   Class;
    ULONG               DevInst;
    ULONG               DeviceType;
    SP_DEVICE_NUMBERS   DeviceNumbers;
    //BOOL              IsLeaf;
    SIZE_T              NumberOfParents;
    ULONG               ParentDevInsts[MAX_DEVICE_ID_LEN];
    TCHAR               DevicePath[MAX_PATH];
    TCHAR               GuidVolumePath[64];
    //SP_DEVICE_PROPERTY Properties[NUMBER_OF(DevicePropertyMetaInfo)];
} SP_DEVICE, *PSP_DEVICE;
typedef CONST SP_DEVICE* PCSP_DEVICE;

#define SP_IS_PATH_SEPERATOR(ch) ((ch) == '\\' || (ch) == '/')

SIZE_T
SpStringLengthWithoutTrailingPathSeperators(
    PCTSTR s
    )
{
    SIZE_T Length;

    if (s == NULL || *s == 0)
        return 0;

    Length = _tcslen(s);
    s += Length - 1;
    while (SP_IS_PATH_SEPERATOR(s[Length]))
        Length -= 1;

    return Length;
}

int __cdecl SpCompareVolume(CONST VOID* v1, CONST VOID* v2)
{
    CONST PCSP_VOLUME p1 = (PCSP_VOLUME)v1;
    CONST PCSP_VOLUME p2 = (PCSP_VOLUME)v2;
    CONST PCTSTR s1 = (p1 != NULL) ? SP_VOLUME_GET_NAME(p1) : TEXT("");
    CONST SIZE_T len1 = SpStringLengthWithoutTrailingPathSeperators(s1);
    CONST PCTSTR s2 = (p1 != NULL) ? SP_VOLUME_GET_NAME(p2) : TEXT("");
    CONST SIZE_T len2 = SpStringLengthWithoutTrailingPathSeperators(s2);

    return _tcsicmp(s1, s2);
}

VOID SpSortVolumes(PSP_VOLUMES Volumes)
{
    qsort(
        Volumes->Entries,
        NUMBER_OF(Volumes->Entries),
        sizeof(Volumes->Entries[0]),
        SpCompareVolume
        );
}

PCSP_VOLUME
SpFindVolume(
    PSP_VOLUMES Volumes,
    PCTSTR VolumeGuidPath
    )
{
    CONST SP_VOLUME VolumeKey = { (PTSTR)VolumeGuidPath };
    PCSP_VOLUME VolumeFound =
        (PCSP_VOLUME)
        bsearch(
            &VolumeKey,
            Volumes->Entries,
            NUMBER_OF(Volumes->Entries),
            sizeof(Volumes->Entries[0]),
            SpCompareVolume
            );

    return VolumeFound;
}

#if 0
void
SpCovertRNToN(
    PTSTR Buffer
    )
{
    PTSTR p;
    PTSTR q;
    for (p = q = Buffer ; *p != 0 && *(p + 1) != 0 ; )
    {
        if (*p == '\r' && *(p + 1) == '\n')
        {
            *q++ = '\n';
            p += 2;
        }
        else
        {
            *q++ = *p++;
        }
    }
    if (*p != 0)
        *q++ = *p++;
    *q++ = 0;
}

void
SpCovertNToRN(
    PTSTR Buffer
    )
{
    // determine size
    // heap alloc
    // convert
}
#endif

VOID
SpHwDebugLog(
    PSP_LOG_HARDWARE    This,
    PCTSTR              Format,
    ...
    )
{
    va_list va;
    TCHAR BufferT[500];
#ifdef UNICODE
     CHAR BufferA[500];
#endif
    SIZE_T Length;
    BOOLEAN Newline = FALSE;

    BufferT[0] = 0;
    va_start(va, Format);
    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING,
        Format,
        0,
        0,
        BufferT,
        NUMBER_OF(BufferT),
        &va
        );
    BufferT[NUMBER_OF(BufferT) - 1] = 0;

    Length = lstrlen(BufferT);
    if (Length != 0)
    {
#if 0
        Newline = (BufferT[Length - 1] == '\n' || BufferT[Length - 1] == '\r');
        if (Newline)
        {
            while (Length != 0 && (BufferT[Length - 1] == '\n' || BufferT[Length - 1] == '\r'))
                Length -= 1;
            if (Length != 0)
                BufferT[Length] = 0;
            else
                Newline = FALSE;
        }
#endif
        if (Newline)
            lstrcat(BufferT, TEXT("\r\n"));
        if (This->LogFile != NULL)
        {
            DWORD BytesWritten;

            if (Newline)
                lstrcat(BufferT, TEXT("\r\n"));
#ifdef UNICODE
            WideCharToMultiByte(
                 CP_ACP,
                 0,
                 BufferT,
                 -1,
                 BufferA,
                 sizeof(BufferA) - 1,
                 NULL,
                 NULL
                 );
            WriteFile(This->LogFile, &BufferA, lstrlenA(BufferA), &BytesWritten, NULL);
#else
            WriteFile(This->LogFile, &BufferT, lstrlen(BufferT), &BytesWritten, NULL);
#endif
        }
        if (This->SetupLogError != NULL)
        {
            This->SetupLogError(BufferT, LogSevInformation);
        }
        if (This->SetuplogError != NULL)
        {
            This->SetuplogError(
                LogSevInformation,
                TEXT("%1"),
                0,
                BufferT,
                (PVOID)NULL,
                (PVOID)NULL
                );
        }
    }
    va_end(va);
}

#define SpHwLog SpHwDebugLog

#if 0
VOID PrependString(PTSTR s, PCTSTR t)
{
    SIZE_T slen = _tcslen(s);
    SIZE_T tlen = _tcslen(t);

    MoveMemory(s + tlen, s, (slen + 1) * sizeof(*s));
    MoveMemory(s, t, tlen);
}
#endif

#define SP_CLOSE_HANDLE(h) \
    do { if ((h) != NULL && (h) != INVALID_HANDLE_VALUE) { CloseHandle(h); h = INVALID_HANDLE_VALUE; } } while(0)

#define SP_FREE(p) \
    do { if ((p) != NULL) { SpFree(p); (p) = NULL; } } while(0)

PVOLUME_DISK_EXTENTS 
SpGetVolumeDiskExtents(
    HANDLE DeviceFileHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    //
    // This pattern is iffy, but it is used elsewhere, and the implementation of
    // IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS is iffy too, and not quite as documented.
    // See drivers\vsm\vsmio\nt\voldev.c.
    //
    struct {
        VOLUME_DISK_EXTENTS VolumeDiskExtents;
        DISK_EXTENT         DiskExtents[4];
    } StackDiskExtents;
    PVOLUME_DISK_EXTENTS HeapDiskExtents = NULL;
    PVOLUME_DISK_EXTENTS DiskExtents = NULL;
    PVOLUME_DISK_EXTENTS ResultDiskExtents = NULL;
    DWORD BytesReturned;
    BOOL Success = FALSE;
    DWORD Size;

    DiskExtents = &StackDiskExtents.VolumeDiskExtents;
    Size = sizeof(StackDiskExtents);
    //
    // loop in case it is changing
    //
    while (!Success)
    {
        Success =
            DeviceIoControl(
                DeviceFileHandle,
                IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                NULL,
                0,
                DiskExtents,
                Size,
                &BytesReturned,
                NULL
                );
        if (!Success) {
            if (GetLastError() != ERROR_MORE_DATA)
                goto Exit;
            Size = sizeof(VOLUME_DISK_EXTENTS) + DiskExtents->NumberOfDiskExtents * sizeof(DISK_EXTENT);
            SP_FREE(HeapDiskExtents);
            HeapDiskExtents = (PVOLUME_DISK_EXTENTS)SpMalloc(Size);
            if (HeapDiskExtents == NULL) {
                SetLastError(ERROR_OUTOFMEMORY);
                goto Exit;
            }
            DiskExtents = HeapDiskExtents;
        } else {
            if (DiskExtents->NumberOfDiskExtents == 0) {
                /* nothing */
            }
            else if (DiskExtents == HeapDiskExtents) {
                ResultDiskExtents = HeapDiskExtents;
                HeapDiskExtents = NULL;
            } else if (DiskExtents == &StackDiskExtents.VolumeDiskExtents) {
                // VOLUME_DISK_EXTENTS includes an array of one DISK_EXTENT at the end.
                ASSERT(BytesReturned == (sizeof(VOLUME_DISK_EXTENTS) + (DiskExtents->NumberOfDiskExtents - 1) * sizeof(DISK_EXTENT)));
                ResultDiskExtents = (PVOLUME_DISK_EXTENTS)SpMalloc(BytesReturned);
                if (ResultDiskExtents == NULL) {
                    SetLastError(ERROR_OUTOFMEMORY);
                    goto Exit;
                }
                ASSERT(BytesReturned <= sizeof(StackDiskExtents));
                CopyMemory(ResultDiskExtents, &StackDiskExtents, BytesReturned);
            } else {
                ASSERT(FALSE && "DiskExtents != HeapDiskExtents, StackDiskExtents");
            }
        }
    }
Exit:
    SP_FREE(HeapDiskExtents);
    return ResultDiskExtents;
}

PTSTR
SpDeviceTypeToString(
    ULONG i,
    PTSTR s
    )
{
    //
    // this is a partial list from public\ddk\inc\devioctl.h
    //
    PCTSTR t = NULL;
    s[0] = 0;
    switch (i)
    {
    case FILE_DEVICE_CD_ROM:                t = TEXT("CDROM"); break;
    case FILE_DEVICE_CD_ROM_FILE_SYSTEM:    t = TEXT("CDROM File System"); break;
    case FILE_DEVICE_CONTROLLER:            t = TEXT("Device Controller"); break;
    case FILE_DEVICE_DFS:                   t = TEXT("Distributed File System"); break;
    case FILE_DEVICE_DISK:                  t = TEXT("Disk"); break;
    case FILE_DEVICE_DISK_FILE_SYSTEM:      t = TEXT("Disk File System"); break;
    case FILE_DEVICE_FILE_SYSTEM:           t = TEXT("File System"); break;
    case FILE_DEVICE_NETWORK_FILE_SYSTEM:   t = TEXT("Network File System"); break;
    case FILE_DEVICE_TAPE:                  t = TEXT("Tape"); break;
    case FILE_DEVICE_TAPE_FILE_SYSTEM:      t = TEXT("Tape File System"); break;
    case FILE_DEVICE_VIRTUAL_DISK:          t = TEXT("Virtual Disk"); break;
    case FILE_DEVICE_NETWORK_REDIRECTOR:    t = TEXT("Network Redirector"); break;
    case FILE_DEVICE_MASS_STORAGE:          t = TEXT("Mass Storage"); break;
    case FILE_DEVICE_SMB:                   t = TEXT("SMB"); break;
    case FILE_DEVICE_CHANGER:               t = TEXT("Changer"); break;
    case FILE_DEVICE_ACPI:                  t = TEXT("ACPI"); break;
    case FILE_DEVICE_DFS_FILE_SYSTEM:       t = TEXT("DFS File System"); break;
    case FILE_DEVICE_DFS_VOLUME:            t = TEXT("DFS Volume"); break;
    default:
        _stprintf(s, TEXT("Other (%ld)"), i);
        break;
    }
    if (t != NULL)
        _tcscpy(s, t);
    return s;
}

VOID
SpGetDeviceNumbersAndType(
    PSP_LOG_HARDWARE    This,
    PCTSTR              DevicePath,
    PSP_DEVICE_NUMBERS  DeviceNumbers,
    PULONG              DeviceType
    )
{
    PVOLUME_DISK_EXTENTS VolumeDiskExtents = NULL;
    STORAGE_DEVICE_NUMBER StorageDeviceNumber = { 0 };
    DWORD Error = 0;
    DWORD DeviceIoControlBytesReturned = 0;
    CONST static TCHAR Function[] = TEXT("SpGetDeviceNumbersAndType");
    HANDLE DeviceFileHandle = INVALID_HANDLE_VALUE;

#if 0
    SpHwDebugLog(
        This,
        TEXT("%1: DeviceIoControl(%2)\n"),
        Function,
        DevicePath
        );
#endif

    DeviceFileHandle =
        CreateFile(
            DevicePath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_READ | SP_FILE_SHARE_DELETE(),
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
    if (DeviceFileHandle == INVALID_HANDLE_VALUE
        ) {
        Error = GetLastError();
        if (Error != ERROR_FILE_NOT_FOUND) {
            SpHwDebugLog(
                This,
                TEXT("%1: CreateFile(%2) warning %3!lu!\r\n"),
                Function,
                DevicePath,
                Error
                );
        }
        goto Exit;
    }

    if (!DeviceIoControl(
        DeviceFileHandle,
        IOCTL_STORAGE_GET_DEVICE_NUMBER,
        NULL,
        0,
        &StorageDeviceNumber,
        sizeof(StorageDeviceNumber),
        &DeviceIoControlBytesReturned,
        NULL
        )) {
        Error = GetLastError();
        if (Error != ERROR_INVALID_FUNCTION
            && Error != ERROR_FILE_NOT_FOUND
            && Error != ERROR_INVALID_PARAMETER // dynamic disk
            )
        {
            SpHwDebugLog(
                This,
                TEXT("%1: DeviceIoControl(%2) warning %3!lu!\r\n"),
                Function,
                DevicePath,
                Error
                );
        }
        if (Error == ERROR_INVALID_PARAMETER)
        {
            // dynamic disk
            *DeviceType = FILE_DEVICE_DISK;
        }
    } else if (DeviceIoControlBytesReturned < sizeof(StorageDeviceNumber)) {
        SpHwDebugLog(
            This,
            TEXT("%1: DeviceIoControl size mismatch (%4!lu!, %5!lu!)"),
            Function,
            (ULONG)DeviceIoControlBytesReturned,
            (ULONG)sizeof(StorageDeviceNumber)
            );
    } else {
        CONST ULONG DeviceNumber = StorageDeviceNumber.DeviceNumber;

#if 0
        {
            TCHAR DeviceTypeString[64];
            SpHwDebugLog(
                This,
                TEXT("%1: DeviceType of %2 is %3 (%4!lu!)\r\n"),
                Function,
                DevicePath,
                SpDeviceTypeToString(StorageDeviceNumber.DeviceType, DeviceTypeString),
                StorageDeviceNumber.DeviceType
                );
        }
#endif
        *DeviceType = StorageDeviceNumber.DeviceType;

        if (DeviceNumber > 63) {
            SpHwDebugLog(
                This,
                TEXT("%1: DeviceNumber out of range (%2!lu!)\r\n"),
                Function,
                StorageDeviceNumber.DeviceNumber
                );
        }
        else {
#if 0
            SpHwDebugLog(
                This,
                TEXT("%1 disk number %2!lu!\r\n"),
                DevicePath,
                DeviceNumber
                );
#endif
            DeviceNumbers->Bitset |= (1ui64 << DeviceNumber);
        }
    }
    VolumeDiskExtents = (PVOLUME_DISK_EXTENTS) SpGetVolumeDiskExtents(DeviceFileHandle);
    if (VolumeDiskExtents != NULL) {
        SIZE_T i;
        CONST SIZE_T VolumeDiskExtents_NumberOfDiskExtents = VolumeDiskExtents->NumberOfDiskExtents;

        for (i = 0 ; i != VolumeDiskExtents_NumberOfDiskExtents ; ++i) {
            CONST SIZE_T DiskNumber = VolumeDiskExtents->Extents[i].DiskNumber;
            if (DiskNumber > 63) {
                SpHwDebugLog(
                    This,
                    TEXT("%1: DiskNumber out of range (%2!lu!)\r\n"),
                    Function,
                    DiskNumber
                    );
            }
            else {
                DeviceNumbers->Bitset |= (1ui64 << DiskNumber);
            }
        }
    }
Exit:
    SP_CLOSE_HANDLE(DeviceFileHandle);
    SpFree(VolumeDiskExtents);
}

VOID
SpCollectVolumeInformation(
    PSP_LOG_HARDWARE    This,
    PSP_VOLUMES         Volumes
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    TCHAR DriveLetter;
    TCHAR GuidVolumeNameBuffer[NUMBER_OF(Volumes->Entries[0].GuidVolumeNameBuffer)];
    CONST static TCHAR Function[] = TEXT("SpCollectVolumeInformation");
    DWORD Error;
    SP_STRING GuidVolumeNameString;

    ZeroMemory(Volumes, sizeof(*Volumes));
    for (DriveLetter = 'C' ; DriveLetter <= 'Z' ; DriveLetter++) {
        CONST PSP_VOLUME Volume = &Volumes->Entries[DriveLetter - 'C'];
        CONST TCHAR DriveLetterPath[] = { DriveLetter, ':', '\\', 0 };
        CONST TCHAR DeviceDriveLetterPath[] = { '\\', '\\', '.', '\\', DriveLetter, ':', 0 };
        /* This looks interesting. WindowsXp only.
        if (GetVolumePathNamesForVolumeName(DriveLetterPath, VolumeName, NUMBER_OF(VolumeName)))
        {
        }
        */

        GuidVolumeNameBuffer[0] = 0;
        if (!This->Linkage->GetVolumeNameForVolumeMountPoint(
            DriveLetterPath, GuidVolumeNameBuffer, NUMBER_OF(GuidVolumeNameBuffer) - 1)
            )
        {
            Error = GetLastError();
            if (Error != ERROR_FILE_NOT_FOUND
                && Error != ERROR_PATH_NOT_FOUND
                ) {
                SpHwDebugLog(
                    This,
                    TEXT("%1: GetVolumeNameForVolumeMountPoint(%2) warning %3!lu!\r\n"),
                    Function,
                    DriveLetterPath,
                    Error
                    );
            }
            continue;
        }

        SpInitString(&GuidVolumeNameString, GuidVolumeNameBuffer);
        SpRemoveTrailingChars(&GuidVolumeNameString, TEXT("\\/"));
        Volume->DriveLetter = DriveLetter;
        CopyMemory(&Volume->GuidVolumeNameBuffer, &GuidVolumeNameBuffer, sizeof(GuidVolumeNameBuffer));
        SpGetDeviceNumbersAndType(
            This,
            Volume->GuidVolumeNameBuffer,
            &Volume->DeviceNumbers,
            &Volume->DeviceType
            );
    }
    qsort(Volumes->Entries, NUMBER_OF(Volumes->Entries), sizeof(Volumes->Entries[0]), SpCompareVolume);
//Exit:
    ;
}

BOOLEAN
SpCollectDeviceProperties(
    PSP_LOG_HARDWARE            This,
    ULONG                       DevInst,
    SIZE_T                      NumberOfProperties,
    PCSP_DEVICE_PROPERTY_CONST  InArray,
    PSP_DEVICE_PROPERTY         OutArray
    )
{
    BOOLEAN Success = FALSE;
    SIZE_T PropertyIndex = 0;
    CONFIGRET ConfigRet = 0;
    CONST static TCHAR Function[] = TEXT("SpCollectDeviceProperties");
    SP_STRING ValueString;
    SP_STRING Whitespace;

    SpInitString(&Whitespace, TEXT("\r\n\v\t "));

    for (PropertyIndex = 0 ; PropertyIndex != NumberOfProperties ; PropertyIndex += 1)
    {
        PCSP_DEVICE_PROPERTY_CONST In = &InArray[PropertyIndex];
        PSP_DEVICE_PROPERTY        Out = &OutArray[PropertyIndex];
        ULONG PropertyBufferSize = sizeof(Out->Value);

        //
        // zero out two chars due to multi_sz
        //
        Out->Value[0] = 0;
        Out->Value[1] = 0;
        ConfigRet =
            This->Linkage->CM_Get_DevNode_Registry_Property_Ex(
                DevInst,
                In->ConfigManagerInteger,
                &Out->Type,
                Out->Value,
                &PropertyBufferSize,
                0,
                This->Machine.Handle
                );
        if (ConfigRet == CR_BUFFER_SMALL)
        {
            //
            // zero out two chars due to multi_sz
            //
            Out->Value[0] = 0;
            Out->Value[1] = 0;
#if DBG
            SpHwDebugLog(
                This,
                TEXT("%1: Buffer too small, property %2\r\n"),
                Function,
                DevicePropertyMetaInfo[PropertyIndex].Name
                );
#endif
        }
#if UNAVAILABLE_VERBOSE
        if (ConfigRet == CR_NO_SUCH_VALUE
            && (DevicePropertyMetaInfo[PropertyIndex].Flags & SP_PROPERTY_QUIET_UNAVAILABLE) == 0
            )
        {
            _tcscpy(Out->Value, TEXT("<unavailable>"));
            ConfigRet = CR_SUCCESS;
        }
#endif
        if (Out->Type == REG_SZ)
        {
            SpInitString(&ValueString, Out->Value);
            SpRemoveTrailingChars(&ValueString, TEXT("\r\n"));
        }
#if QUASH_SIMPLE_PHYSICAL_DEVICE_OBJECT_NAMES
        /* of the form \Device\12345678 */
        if (ConfigRet == CR_SUCCESS
            && In->ConfigManagerInteger == CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME
            )
        {
            CONST static TCHAR SimpleDeviceName[] = TEXT("\\Device\\12345678");
            if (lstrlen(Out->Value) == NUMBER_OF(SimpleDeviceName) - 1)
            {
                SIZE_T i;
                for (i = 0 ; i != NUMBER_OF(SimpleDeviceName) - 1 ; ++i)
                {
                    if (iswdigit(SimpleDeviceName[i]) && iswdigit(Out->Value[i]))
                    {
                        // ok
                    }
                    else if (SimpleDeviceName[i] != Out->Value[i])
                    {
                        break;
                    }
                }
                if (i == NUMBER_OF(SimpleDeviceName) - 1)
                {
                    Out->Value[0] = 0;
                    Out->Value[1] = 0;
                }
            }
        }
#endif
        if (ConfigRet != CR_SUCCESS
            && ConfigRet != CR_NO_SUCH_VALUE
            && ConfigRet != CR_INVALID_PROPERTY
            && ConfigRet != CR_BUFFER_SMALL
            )
            goto Exit;
        Out->Const = In; // connect it back to the meta info
    }
    Success = TRUE;
Exit:;
    return Success;
}

BOOL
SpGrowArray(
    IN OUT PVOID*  Array,
    IN SIZE_T      SizeOfElement,
    IN OUT PSIZE_T NumberOfElements,
    IN OUT PSIZE_T NumberAllocated
    )
{
    ASSERT(*NumberOfElements < *NumberAllocated);
    *NumberOfElements += 1;
    if (*NumberOfElements >= *NumberAllocated) {
        PVOID Next = SpRealloc(*Array, SizeOfElement * *NumberAllocated * 2);
        if (Next == NULL) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        *Array = Next;
        *NumberAllocated *= 2;
    }
    return TRUE;
}

VOID
SpCollectDeviceInformation(
    PSP_LOG_HARDWARE            This,
    PCSP_DEVICE_CLASS           DeviceClasses,
    SIZE_T                      NumberOfDeviceClasses,
    PCSP_DEVICE_PROPERTY_CONST  DevicePropertyMetaInfo, // the size of this is assumed
    PSP_DEVICE*                 OutDevices,
    SIZE_T*                     OutNumberOfDevices
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    CONST static TCHAR Function[] = TEXT("SpCollectDeviceInformation");
    SIZE_T DeviceClassIndex = 0;
    ULONG DeviceInClassIndex = 0;
    SIZE_T NumberOfDevices = 0;
    SIZE_T NumberOfDevicesAllocated = 64;
    HANDLE DeviceInfoHandle = NULL;
    BOOL Success = FALSE;
    SP_DEVICE_INTERFACE_DATA SetupDeviceInterfaceData = { sizeof(SetupDeviceInterfaceData) };
    DWORD Error = 0;
    PSP_DEVICE Devices = NULL;
    ULONG DevInst = 0;
    ULONG ParentIndex = 0;
    SP_STRING String;
    struct
    {
        SP_DEVICE_INTERFACE_DETAIL_DATA Base;
        TCHAR                           Buffer[MAX_PATH];
    } DetailAndBuffer;
    SP_DEVINFO_DATA SetupDeviceInfoData = { sizeof(SetupDeviceInfoData) };
    CONFIGRET ConfigRet = 0;

    if (OutDevices != NULL)
        *OutDevices = NULL;
    if (OutNumberOfDevices != NULL)
        *OutNumberOfDevices = 0;
    if (OutDevices == NULL || OutNumberOfDevices == NULL)
        goto Exit;

    DetailAndBuffer.Base.cbSize = sizeof(DetailAndBuffer.Base);

    Devices = (PSP_DEVICE)SpMalloc(NumberOfDevicesAllocated * sizeof(*Devices));
    if (Devices == NULL)
        goto Exit;
    ZeroMemory(Devices, NumberOfDevicesAllocated * sizeof(*Devices));

    //
    // loop over device class (disk, volume, cdrom, etc.)
    //
    for (DeviceClassIndex = 0 ; DeviceClassIndex != NumberOfDeviceClasses ; ++DeviceClassIndex) {
        DeviceInfoHandle =
            This->Linkage->SetupDiGetClassDevsEx(
                DeviceClasses[DeviceClassIndex].Guid,
                NULL,
                NULL,
                DIGCF_PRESENT | DeviceClasses[DeviceClassIndex].IsInterface,
                NULL,
                This->Machine.Name,
                NULL
                );
        if (DeviceInfoHandle == INVALID_HANDLE_VALUE)
        {
            Error = GetLastError();
            continue;
        }
        //
        // loop over devices in the class
        //
        Success = TRUE;
        for (DeviceInClassIndex = 0 ; Success ; ++DeviceInClassIndex) {

            PSP_DEVICE Device = &Devices[NumberOfDevices];

            Success =
                This->Linkage->SetupDiEnumDeviceInterfaces(
                    DeviceInfoHandle,
                    NULL,//&SetupDeviceInfoData,
                    DeviceClasses[DeviceClassIndex].Guid,
                    DeviceInClassIndex,
                    &SetupDeviceInterfaceData
                    );
            if (!Success)
                Error = GetLastError();
            if (!Success && Error == ERROR_NO_MORE_ITEMS) {
                break;
            }
            if (!Success) {
                break;
            }
            //
            // get the devinst and the device path
            //
            DevInst = SetupDeviceInfoData.DevInst;
            Success =
                This->Linkage->SetupDiGetDeviceInterfaceDetail(
                    DeviceInfoHandle,
                    &SetupDeviceInterfaceData,
                    &DetailAndBuffer.Base,
                    sizeof(DetailAndBuffer),
                    NULL, /* required size */
                    &SetupDeviceInfoData
                    );
            if (!Success) {
                break;
            }

            //Device->IsLeaf = TRUE;
            Device->DevInst = SetupDeviceInfoData.DevInst;
            _tcscpy(Device->DevicePath, DetailAndBuffer.Base.DevicePath);
#if 0
            SpHwDebugLog(
                This,
                TEXT("%1: %2\r\n"),
                Function,
                Device->DevicePath
                );
#endif

#if 1
            SpInitString(&String, Device->DevicePath);
            SpEnsureTrailingChar(&String, '\\');
            if (!This->Linkage->GetVolumeNameForVolumeMountPoint(Device->DevicePath,
                Device->GuidVolumePath, NUMBER_OF(Device->GuidVolumePath) - 1)
                ) {
                Error = GetLastError();
                if (Error != ERROR_FILE_NOT_FOUND
                    && Error != ERROR_PATH_NOT_FOUND
                    && Error != ERROR_NOT_READY
                    && Error != ERROR_INVALID_FUNCTION
                    )
                {
                    SpHwDebugLog(
                        This,
                        TEXT("%1: GetVolumeNameForVolumeMountPoint(%2) warning %3!lu!\r\n"),
                        Function,
                        Device->DevicePath,
                        Error
                        );
                    continue;
                }
            }
            //SpHwDebugLog(This, TEXT("%1: GetVolumeNameForVolumeMountPoint(%2) : %3\r\n"), Function, Device->DevicePath, Device->GuidVolumePath);
            SpRemoveTrailingChars(&String, TEXT("\\/"));
            SpInitString(&String, Device->GuidVolumePath);
            SpRemoveTrailingChars(&String, TEXT("\\/"));
#endif

            //
            // this is how we match up the devices to the drive letters
            //
            SpGetDeviceNumbersAndType(
                This,
                Device->DevicePath,
                &Device->DeviceNumbers,
                &Device->DeviceType
                );

            //
            // get the parent devinsts
            //
            for (
                (ConfigRet = CR_SUCCESS), (ParentIndex = 0);
                (ConfigRet == CR_SUCCESS)
                    && ParentIndex < NUMBER_OF(Device->ParentDevInsts);
                ParentIndex += 1
                )
            {
                ULONG ChildIndex = (ParentIndex == 0 ? Device->DevInst : Device->ParentDevInsts[ParentIndex - 1]);
                ConfigRet =
                    This->Linkage->CM_Get_Parent_Ex(
                        &Device->ParentDevInsts[ParentIndex],
                        ChildIndex,
                        0,
                        This->Machine.Handle
                        );
            }
            // the last one is never interesting, err.. two
            if (ParentIndex != 0)
                ParentIndex -= 1;
            if (ParentIndex != 0)
                ParentIndex -= 1;

            Device->NumberOfParents = ParentIndex;

            //
            // get the properties
            // we should do this here, but not if we don't also get the parent properties
            //
            //SpCollectDeviceProperties(Device, DevicePropertyMetaInfo);

            //
            // grow the array of devices if necessary
            //
            if (!SpGrowArray(&Devices, sizeof(Devices[0]), &NumberOfDevices, &NumberOfDevicesAllocated))
                goto Exit;

            //
            // We should probably the properties of the parents here,
            // but our data structures are not very good, and this would be inefficient
            // We must avoid O(n^2) behavior, because people really do have machines
            // with many disks, like 100.
            //
            // We should keep sorted arrays of devinsts.
            //
        }
    }
    if (!Success) {
        Error = GetLastError();
    }
    //SpChangeParentDevInstsToIndices(Devices, NumberOfDevices);
    *OutDevices = Devices;
    Devices = NULL;
    *OutNumberOfDevices = NumberOfDevices;
Exit:
    SpFree(Devices);
}

VOID
SpFillStaticString(
    PTSTR  s,
    SIZE_T n,
    TCHAR  ch
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONGLONG chch;
    ULONGLONG* pchch;
    SIZE_T i;
    SIZE_T m;

    if (s[n - 2] != 0)
        return;

    if (sizeof(ULONGLONG) <= sizeof(TCHAR))
    {
        for (i = 0 ; i != n - 1 ; i += 1)
        {
            s[i] = ch;
        }
        return;
    }
    chch = 0;
    for (i = 0 ; i != sizeof(ULONGLONG)/sizeof(TCHAR) ; i += 1)
    {
        chch <<= BITS_OF(ch);
        chch |= ch;
    }
    m = (n - 1) / (sizeof(ULONGLONG)/sizeof(TCHAR));
    pchch = (ULONGLONG*)s;
    for (i = 0 ; i < m ; i += 1)
    {
        pchch[i] = chch;
    }
    m *= (sizeof(ULONGLONG)/sizeof(TCHAR));
    for (i = m ; i < n - 1 ; i += 1)
    {
        s[i] = ch;
    }
#if DBG
    for (i = 0 ; i != n - 1 ; i += 1)
    {
        ASSERT(s[i] == ch);
    }
    ASSERT(s[i] == 0);
#endif
}

PCTSTR
SpGetDashesString(
    SIZE_T n
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    static union {
        ULONGLONG Ulonglongs[1 + 128 / (sizeof(ULONGLONG)/sizeof(TCHAR))];
        TCHAR     Tchars[128];
    } u;

    SpFillStaticString(u.Tchars, NUMBER_OF(u.Tchars), '-');
    n *= 2;
    if (n > NUMBER_OF(u.Tchars))
        n = NUMBER_OF(u.Tchars);
    return &u.Tchars[NUMBER_OF(u.Tchars) - n];
}

PCTSTR
SpGetSpacesString(
    SIZE_T n
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    static union {
        ULONGLONG Ulonglongs[1 + 128 / (sizeof(ULONGLONG)/sizeof(TCHAR))];
        TCHAR     Tchars[128];
    } u;

    SpFillStaticString(u.Tchars, NUMBER_OF(u.Tchars), ' ');
    n *= INDENT_FACTOR;
    if (n > NUMBER_OF(u.Tchars))
        n = NUMBER_OF(u.Tchars);
    return &u.Tchars[NUMBER_OF(u.Tchars) - 1 - n];
}

PCTSTR
SpGetFirstMultipleString(
    PCTSTR s
    )
{
    //
    // the first string being empty is odd case
    // it is the only string that can be empty
    //
    if (*s == 0 && *(s + 1) != 0)
        s += 1;
    return s;
}

PCTSTR
SpGetNextMultipleString(
    PCTSTR s
    )
{
    s += lstrlen(s) + 1;
    return s;
}

SIZE_T
SpMultipleStringCount(
    PCTSTR s
    )
{
    SIZE_T i = 0;
    if (*s != 0 || *(s + 1) != 0)
    {
        do
        {
            i += 1;
            s += lstrlen(s) + 1;
        } while (*s != 0);
    }
    return i;
}

VOID
SpLogDeviceProperties(
    PSP_LOG_HARDWARE        This,
    SIZE_T                  NumberOfProperties,
    PCSP_DEVICE_PROPERTY    PropertyData,
    ULONG                   Indent
    )
{
    ULONG PropertyType;
    SIZE_T PropertyIndex;
    //
    // we save away this string, so we that can indent the rest of the lines to account for it
    //
    TCHAR NumberString[BITS_OF(Indent)];

    NumberString[0] = 0;
#if NUMBER_CHILDREN
    _stprintf(NumberString, TEXT("%lu. "), Indent + 1);
#endif
#if ONE_DEVICE_PER_LINE
    SpHwLog(This, TEXT("%1"), SpGetSpacesString(Indent));
#endif
    for (PropertyIndex = 0 ; PropertyIndex != NumberOfProperties ; PropertyIndex += 1)
    {
        PCTSTR Name = PropertyData[PropertyIndex].Const->Name;
        if (PropertyData[PropertyIndex].Value[0] != 0
            && (PropertyIndex == 0
                //
                // friendly name sometimes == description
                // general fix: don't print adjacent equal values,
                //    unless they are both unavailable (which don't generally have anymore)
                //
                || _tcsicmp(PropertyData[PropertyIndex].Value, PropertyData[PropertyIndex - 1].Value) != 0
                || _tcsicmp(PropertyData[PropertyIndex].Value, TEXT("<unavailable>")) == 0
            ))
        {
#if DESCRIPTION_DASH_PHYSICAL_DEVICE_OBJECT
            if (PropertyIndex == PHYSICAL_DEVICE_OBJECT)
            {
                // nothing
            }
            else
#endif
            {
#if NUMBER_CHILDREN
                SpHwLog(This, TEXT("%1"), NumberString);
#endif
#if INDENT_CHILDREN && !ONE_DEVICE_PER_LINE
                SpHwLog(This, TEXT("%1"), SpGetSpacesString(Indent));
#endif
            }
            //
            // only print "PhysicalDeviceObject" if there was no description
            //
#if DESCRIPTION_DASH_PHYSICAL_DEVICE_OBJECT
            if (PropertyIndex == PHYSICAL_DEVICE_OBJECT
                && (
                    PropertyData[DESCRIPTION].Value[0] != 0
                    && _tcsicmp(PropertyData[DESCRIPTION].Value, TEXT("<unavailable>")) != 0)
                )
            {
                // nothing
            }
            else
#endif
            {
                if (Name != NULL && Name[0] != 0)
                {
                    //SpHwLog(This, TEXT("%1 = "), Name);
                    SpHwLog(This, TEXT("%1: "), Name);
                }
            }
            PropertyType = PropertyData[PropertyIndex].Type;
// if one device per line, shrink hardware id to just first item
// also compress its formating if it only contains one element
#if ONE_PROPERTY_PER_LINE
            if (PropertyType == REG_MULTI_SZ
                && SpMultipleStringCount(PropertyData[PropertyIndex].Value) < 2
                )
#endif
            {
                PropertyType = REG_SZ;
            }

            switch (PropertyType)
            {
                case REG_MULTI_SZ:
                    {
                        PCTSTR Value;
                        for (
                            Value = SpGetFirstMultipleString(PropertyData[PropertyIndex].Value);
                            *Value != 0;
                            Value = SpGetNextMultipleString(Value)
                            )
                        {
#if INDENT_CHILDREN
                            SpHwLog(
                                This,
                                TEXT("\r\n%1%2"),
                                SpGetSpacesString(Indent + 2),
                                Value
                                );
#else
                            SpHwLog(
                                This,
                                TEXT("\r\n%1  %2"),
                                NumberString,
                                Value
                                );
#endif
                        }
                    }
                case REG_SZ:
                    SpHwLog(This, TEXT("%1"), PropertyData[PropertyIndex].Value);
                    break;
            }
#if DESCRIPTION_DASH_PHYSICAL_DEVICE_OBJECT
            if (PropertyIndex == DESCRIPTION
                && PropertyData[PHYSICAL_DEVICE_OBJECT].Value[0] != 0
                )
            {
                SpHwLog(This, TEXT(" - "));
            }
            else
#endif
            {
#if ONE_PROPERTY_PER_LINE
                SpHwLog(This, TEXT("\r\n"));
#endif
#if ONE_DEVICE_PER_LINE
                SpHwLog(This, TEXT(" "));
#endif
            }
            if (NumberString[0] != 0 && NumberString[0] != ' ')
            {
                //
                // convert to spaces for the rest of the lines
                //
                SIZE_T i;
                for (i = 0 ; NumberString[i] != 0 ; ++i)
                {
                    NumberString[i] = ' ';
                }
            }
        }
    }
#if ONE_DEVICE_PER_LINE
    SpHwLog(This, TEXT("\r\n"));
#endif
}

VOID
SpLogDeviceTree(
    PSP_LOG_HARDWARE    This,
    PCSP_DEVICE         Device,
    ULONG               Indent
    )
{
    ULONG ParentIndex;
    SP_DEVICE_PROPERTY PropertyData[NUMBER_OF(DevicePropertyMetaInfo)];

    if (!SpCollectDeviceProperties(This, Device->DevInst, NUMBER_OF(PropertyData), DevicePropertyMetaInfo, PropertyData))
        return;
#if NUMBER_CHILDREN
    Indent = 1;
#endif
    SpLogDeviceProperties(This, NUMBER_OF(PropertyData), PropertyData, Indent - 1);
    for (ParentIndex = 0 ; ParentIndex < Device->NumberOfParents ; ParentIndex += 1)
    {
        if (!SpCollectDeviceProperties(This, Device->ParentDevInsts[ParentIndex], NUMBER_OF(PropertyData), DevicePropertyMetaInfo, PropertyData))
            break;
        SpLogDeviceProperties(This, NUMBER_OF(PropertyData), PropertyData, Indent + ParentIndex);
    }
#if NUMBER_CHILDREN
    SpHwLog(This, TEXT("\r\n"));
#endif
}

VOID
SpLogVolumeAndDeviceInformation(
    PSP_LOG_HARDWARE    This,
    PCSP_VOLUMES        Volumes,
    PCSP_DEVICE         Devices,
    SIZE_T              NumberOfDevices
    )
{
    ULONG Indent = 0;
    SIZE_T VolumeIndex = 0;
    SIZE_T DiskNumber = 0;
    SIZE_T DeviceIndex = 0;

    for (DeviceIndex = 0; DeviceIndex != NumberOfDevices ; DeviceIndex += 1)
    {
        PCSP_DEVICE Device = &Devices[DeviceIndex];

        for (DiskNumber = 0 ; DiskNumber != BITS_OF_FIELD(SP_DEVICE_NUMBERS, Bitset); DiskNumber += 1)
        {
            if ((Device->DeviceNumbers.Bitset & (1ui64 << DiskNumber)) != 0)
            {
                ULONG DriveLetters = 0;
                LONG NumberOfDriveLetters = 0;
                for (VolumeIndex = 0 ; VolumeIndex != NUMBER_OF(Volumes->Entries) ; ++VolumeIndex)
                {
                    CONST PCSP_VOLUME Volume = &Volumes->Entries[VolumeIndex];
                    if (Volume->DriveLetter != 0
                        && (Volume->DeviceNumbers.Bitset & (1ui64 << DiskNumber)) != 0
                        && Volume->DeviceType == Device->DeviceType
                        )
                    {
                        DriveLetters |= (1UL << (Volume->DriveLetter - 'C'));
                        NumberOfDriveLetters += 1;
                    }
                }
                if (DriveLetters != 0)
                {
                    SIZE_T i;
                    SpHwLog(
                        This,
                        TEXT("%1"),
                        SpGetSpacesString(Indent)
                        );
                    SpHwLog(
                        This,
                        TEXT("%1: "),
                        (NumberOfDriveLetters == 1)
                            ? TEXT("Volume")
                            : TEXT("Volumes")
                        );
                    for (i = 'C' ; i <= 'Z' ; i += 1)
                    {
                        if ((DriveLetters & (1UL << (i - 'C'))) != 0)
                            SpHwLog(
                                This,
                                TEXT("%1!c!:\\ "),
                                i
                                );
                    }
                    SpHwLog(This, TEXT("%1"), TEXT("\r\n\r\n"));
                }
#if 1
                SpHwLog(
                    This,
                    TEXT("Device Path: %1%2"),
                    Device->DevicePath,
                    TEXT("\r\n\r\n")
                    );
#endif
                //SpHwLog(This, TEXT("\r\n"));
                SpLogDeviceTree(This, Device, Indent + 1);
                //SpHwLog(This, TEXT("\r\n\r\n"));
                SpHwLog(
                    This,
                    TEXT("%1\r\n\r\n"),
                    SpGetDashesString(100)
                    );
            }
        }
    }
}

VOID
SpLogHardware(
    PSP_LOG_HARDWARE_IN In
    )
{
    SP_VOLUMES  Volumes = { 0 };
    PSP_DEVICE  Devices = NULL;
    SIZE_T NumberOfDevices = 0;
    CONFIGRET ConfigRet = 0;
    SP_MACHINE Machine = { 0 };
    SP_LOG_HARDWARE This = { 0 };

    This.Machine.Name = In->MachineName;
    This.LogFile = In->LogFile;
    This.Linkage = &SpLinkage;
    This.SetupLogError = In->SetupLogError;
    This.SetuplogError = In->SetuplogError;

    if (!SpDoDynlink(&This))
    {
        SpHwLog(&This, TEXT("downlevel, deviceinfo not logged\r\n"));
        return;
    }

    ConfigRet = This.Linkage->CM_Connect_Machine(This.Machine.Name, &This.Machine.Handle);
    if (ConfigRet != CR_SUCCESS)
        goto Exit;
    SpCollectVolumeInformation(
        &This,
        &Volumes
        );

    SpCollectDeviceInformation(
        &This,
        DeviceClasses,
        NUMBER_OF(DeviceClasses),
        DevicePropertyMetaInfo,
        &Devices,
        &NumberOfDevices
        );

    if (Devices != NULL && NumberOfDevices != 0)
    {
        SpLogVolumeAndDeviceInformation(
            &This,
            &Volumes,
            Devices,
            NumberOfDevices
            );
        SpFree(Devices);
    }
Exit:
    ;
}

#if STANDALONE

void Main(
    PSP_LOG_HARDWARE_IN Parameters
    )
{
#if STANDALONE == 1
    Parameters->LogFile = (HANDLE)_get_osfhandle(_fileno(stdout));
#elif STANDALONE == 2
    SetupOpenLog(FALSE);
    Parameters->SetupLogError = SetupLogError;
#endif
    SpLogHardware(Parameters);
#if STANDALONE == 2
    SetupCloseLog();
#endif
}

#ifdef UNICODE
int __cdecl _wmain(int argc, WCHAR** argv)
{
    SP_LOG_HARDWARE_IN Parameters = { 0 };
    Parameters.MachineName = (argc > 1) ? argv[1] : NULL;
    Main(&Parameters);
    return 0;
}
#endif

int __cdecl main(int argc, CHAR** argv)
{
    SP_LOG_HARDWARE_IN Parameters = { 0 };
#ifdef UNICODE
    WCHAR** argvw = NULL;
    argvw = CommandLineToArgvW(GetCommandLineW(), &argc);
    Parameters.MachineName = (argc > 1) ? argvw[1] : NULL;
#else
    Parameters.MachineName = (argc > 1) ? argv[1] : NULL;
#endif
    Main(&Parameters);
    return 0;
}

#endif

#else

VOID
SpLogHardware(
    PSP_LOG_HARDWARE_IN In
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\compliance.h ===
#ifndef _COMPLIANCE_H
#define _COMPLIANCE_H

#ifdef __cplusplus
extern "C" {
#endif

#define EVAL_MPC           TEXT("82503")
#define DOTNET_EVAL_MPC    TEXT("69763")
#define SRV_NFR_MPC        TEXT("51883")
#define ASRV_NFR_MPC       TEXT("51882")
#define NT4SRV_NFR_MPC     TEXT("51222")

#ifdef KERNEL_MODE
    #define OEM_INSTALL_RPC    L"OEM"
    #define SELECT_INSTALL_RPC L"270"
    #define MSDN_INSTALL_RPC   L"335"
#endif

#define COMPLIANCE_INSTALLTYPE_UNKNOWN      0x00000000
#define COMPLIANCE_INSTALLTYPE_WIN31        0x00000001
#define COMPLIANCE_INSTALLTYPE_WIN9X        0x00000002
#define COMPLIANCE_INSTALLTYPE_NTW          0x00000004
#define COMPLIANCE_INSTALLTYPE_NTS          0x00000008
#define COMPLIANCE_INSTALLTYPE_NTSE         0x00000010
#define COMPLIANCE_INSTALLTYPE_NTSDTC       0x00000020
//
// this is for the downlevel terminal server edition product, which needs
// to be treated as an install type, not just a product suite. this includes
// nt4 terminal server edition as well as citrix winframe
//
#define COMPLIANCE_INSTALLTYPE_NTSTSE       0x00000040
#define COMPLIANCE_INSTALLTYPE_NTWP         0x00000080
#define COMPLIANCE_INSTALLTYPE_NTSB         0x00000100
#define COMPLIANCE_INSTALLTYPE_NTSBS        0x00000200
//
// Powered Windows uses the same suite as blade and enterprise
// However, we need to have it as a separate type for compliance to work
#define COMPLIANCE_INSTALLTYPE_NTSPOW       0x00000400
#define COMPLIANCE_INSTALLTYPE_ANY          ( COMPLIANCE_INSTALLTYPE_WIN31 | \
                                              COMPLIANCE_INSTALLTYPE_WIN9X | \
                                              COMPLIANCE_INSTALLTYPE_NTW   | \
                                              COMPLIANCE_INSTALLTYPE_NTWP  | \
                                              COMPLIANCE_INSTALLTYPE_NTS   | \
                                              COMPLIANCE_INSTALLTYPE_NTSB  | \
                                              COMPLIANCE_INSTALLTYPE_NTSBS | \
                                              COMPLIANCE_INSTALLTYPE_NTSE  | \
                                              COMPLIANCE_INSTALLTYPE_NTSDTC | \
                                              COMPLIANCE_INSTALLTYPE_NTSTSE | \
                                              COMPLIANCE_INSTALLTYPE_NTSPOW )

#define COMPLIANCE_INSTALLTYPE_NTANY        ( COMPLIANCE_INSTALLTYPE_NTW   | \
                                              COMPLIANCE_INSTALLTYPE_NTWP  | \
                                              COMPLIANCE_INSTALLTYPE_NTS   | \
                                              COMPLIANCE_INSTALLTYPE_NTSB  | \
                                              COMPLIANCE_INSTALLTYPE_NTSBS | \
                                              COMPLIANCE_INSTALLTYPE_NTSE  | \
                                              COMPLIANCE_INSTALLTYPE_NTSDTC | \
                                              COMPLIANCE_INSTALLTYPE_NTSTSE | \
                                              COMPLIANCE_INSTALLTYPE_NTSPOW )


#define COMPLIANCE_INSTALLVAR_UNKNOWN       0x00000000
#define COMPLIANCE_INSTALLVAR_SELECT        0x00000001
#define COMPLIANCE_INSTALLVAR_MSDN          0x00000002
#define COMPLIANCE_INSTALLVAR_OEM           0x00000004
#define COMPLIANCE_INSTALLVAR_CDRETAIL      0x00000008
#define COMPLIANCE_INSTALLVAR_FLOPPYRETAIL  0x00000010 // win95 only!
#define COMPLIANCE_INSTALLVAR_EVAL          0x00000020
#define COMPLIANCE_INSTALLVAR_NFR           0x00000040
#define COMPLIANCE_INSTALLVAR_ANY           ( COMPLIANCE_INSTALLVAR_SELECT   | \
                                              COMPLIANCE_INSTALLVAR_MSDN     | \
                                              COMPLIANCE_INSTALLVAR_OEM      | \
                                              COMPLIANCE_INSTALLVAR_CDRETAIL | \
                                              COMPLIANCE_INSTALLVAR_EVAL     | \
                                              COMPLIANCE_INSTALLVAR_NFR      | \
                                              COMPLIANCE_INSTALLVAR_FLOPPYRETAIL )


#define COMPLIANCE_INSTALLSUITE_UNKNOWN     0x00000000
#define COMPLIANCE_INSTALLSUITE_NONE        0x00000001
#define COMPLIANCE_INSTALLSUITE_SBS         0x00000002
#define COMPLIANCE_INSTALLSUITE_SBSR        0x00000004
#define COMPLIANCE_INSTALLSUITE_ENT         0x00000008
#define COMPLIANCE_INSTALLSUITE_COMM        0x00000010
#define COMPLIANCE_INSTALLSUITE_HYDRA       0x00000020
#define COMPLIANCE_INSTALLSUITE_TERMINAL    COMPLIANCE_INSTALLSUITE_HYDRA
#define COMPLIANCE_INSTALLSUITE_BACK        0x00000040
#define COMPLIANCE_INSTALLSUITE_EMBED       0x00000080
#define COMPLIANCE_INSTALLSUITE_DTC         0x00000100
#define COMPLIANCE_INSTALLSUITE_PER         0x00000200
#define COMPLIANCE_INSTALLSUITE_BLADE       0x00000400
#define COMPLIANCE_INSTALLSUITE_ANY         ( COMPLIANCE_INSTALLSUITE_SBS   | \
                                              COMPLIANCE_INSTALLSUITE_SBSR  | \
                                              COMPLIANCE_INSTALLSUITE_ENT   | \
                                              COMPLIANCE_INSTALLSUITE_COMM  | \
                                              COMPLIANCE_INSTALLSUITE_HYDRA | \
                                              COMPLIANCE_INSTALLSUITE_BACK  | \
                                              COMPLIANCE_INSTALLSUITE_EMBED | \
                                              COMPLIANCE_INSTALLSUITE_DTC   | \
                                              COMPLIANCE_INSTALLSUITE_BLADE | \
                                              COMPLIANCE_INSTALLSUITE_PER )



#define COMPLIANCEERR_NONE                  0x00000000
#define COMPLIANCEERR_VERSION               0x00000001
#define COMPLIANCEERR_SUITE                 0x00000002
#define COMPLIANCEERR_TYPE                  0x00000003
#define COMPLIANCEERR_VARIATION             0x00000004
#define COMPLIANCEERR_UNKNOWNTARGET         0x00000005
#define COMPLIANCEERR_UNKNOWNSOURCE         0x00000006
#define COMPLIANCEERR_SERVICEPACK5          0x00000007
#define COMPLIANCEERR_DTCWARNING            0x00000008
#define COMPLIANCEERR_UNKNOWN               COMPLIANCEERR_UNKNOWNSOURCE

#define COMPLIANCE_SKU_NONE                 0x00000000
#define COMPLIANCE_SKU_NTWFULL              0x00000001
#define COMPLIANCE_SKU_NTW32U               0x00000002
//#define COMPLIANCE_SKU_NTWU                 0x00000003
#define COMPLIANCE_SKU_NTSEFULL             0x00000004
#define COMPLIANCE_SKU_NTSFULL              0x00000005
#define COMPLIANCE_SKU_NTSEU                0x00000006
//#define COMPLIANCE_SKU_NTSSEU               0x00000007
#define COMPLIANCE_SKU_NTSU                 0x00000008
#define COMPLIANCE_SKU_NTSDTC               0x00000009
//#define COMPLIANCE_SKU_NTSDTCU              0x0000000a
#define COMPLIANCE_SKU_NTWPFULL             0x0000000b
#define COMPLIANCE_SKU_NTWPU                0x0000000c
#define COMPLIANCE_SKU_NTSB                 0x0000000d
#define COMPLIANCE_SKU_NTSBU                0x0000000e
#define COMPLIANCE_SKU_NTSBS                0x00000010
#define COMPLIANCE_SKU_NTSBSU               0x00000011
	
#define COMPLIANCE_SKU_STEPUP               0x00010000
#define COMPLIANCE_SKU_STEPUP_WIN9X         0x00020000


typedef struct _COMPLIANCE_DATA {
    DWORD InstallType;                      // mask describing install type
    DWORD InstallVariation;                 // mask describing install variation
    DWORD InstallSuite;                     // mask describing install suite
    BOOL  RequiresValidation;               // do we need to do validation for this SKU?
    DWORD MinimumVersion;                   // expressed as (majorversion.minorversion * 100), i.e., 3.51 == 351, 5.0 == 500, etc...
    DWORD MaximumKnownVersionNt;            // expressed as (majorversion.minorversion * 100), i.e., 3.51 == 351, 5.0 == 500, etc...
    DWORD BuildNumberNt;                    //
    DWORD BuildNumberWin9x;                 //
    DWORD InstallServicePack;                      // Service Pack number
} COMPLIANCE_DATA, *PCOMPLIANCE_DATA;

typedef struct _COMPLIANCE_SRC {
    DWORD InstallType;                      // mask describing install type
    DWORD InstallVariation;                 // mask describing install variation
    DWORD InstallSuite;                     // mask describing install suite
    DWORD Version;                          // expressed as (majorversion.minorversion * 100), i.e., 3.51 == 351, 5.0 == 500, etc...
} COMPLIANCE_SRC, *PCOMPLIANCE_SRC;

//
// The install media object abstraction
//

//
// media object this pointer
//
typedef struct _st_CCMEDIA *PCCMEDIA;

//
// Compliance checking method of media object
//
typedef BOOLEAN (* PCC_CHECK_FUNCTION)(
    IN  PCCMEDIA            This,
    IN  PCOMPLIANCE_DATA    CompData,
    OUT PUINT               FailureReason,
    OUT PBOOL               NoUpgradeAllowed );

//
// install media object
//
typedef struct _st_CCMEDIA {
    DWORD               SourceType;
    DWORD               SourceVariation;
    DWORD               Version;            // major * 100 + minor
    DWORD               BuildNumber;
    BOOLEAN             StepUpMedia;
    PCC_CHECK_FUNCTION  CheckInstall;       // compliance check method
} CCMEDIA;


//
// common prototypes
//
PCCMEDIA
CCMediaCreate(
    IN          DWORD   SourceSKU,
    IN          DWORD   SourceVariation,
    IN OPTIONAL DWORD   Version,
    IN OPTIONAL DWORD   BuildNumber );

BOOLEAN
CCMediaInitialize(
    OUT PCCMEDIA        DestMedia,
    IN          DWORD   Type,
    IN          DWORD   Variation,
    IN          BOOLEAN StepupMedia,
    IN OPTIONAL DWORD   Version,
    IN OPTIONAL DWORD   BuildNumber);

BOOLEAN
CheckCompliance(
    IN DWORD SourceSku,
    IN DWORD SourceVariation,
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PCOMPLIANCE_DATA Destination,
    OUT PUINT Reason,
    OUT PBOOL NoUpgradeAllowed
    );

DWORD
DetermineSourceProduct(
    OUT DWORD *SourceSkuVariation,
    IN  PCOMPLIANCE_DATA pcd
    );

BOOL
GetSourceComplianceData(
    OUT PCOMPLIANCE_DATA pcd,
    IN  PCOMPLIANCE_DATA Target
    );

DWORD
CRC_32(
    LPBYTE pb,
    DWORD cb
    );

BOOL
IsValidStepUpMode(
    CHAR  *StepUpArray,
    ULONG *StepUpMode
    );


//
// kernel mode prototypes
//

#ifdef KERNEL_MODE

BOOLEAN
pSpIsCompliant(
    IN DWORD SourceVersion,
    IN DWORD SourceBuildNum,
    IN PDISK_REGION OsPartRegion,
    IN PWSTR SystemRoot,
    OUT PBOOLEAN UpgradeOnlyCompliant
    );

BOOLEAN
pSpDetermineCurrentInstallation(
    IN PDISK_REGION OsPartRegion,
    IN PWSTR SystemRoot,
    OUT PCOMPLIANCE_DATA pcd
    );

BOOLEAN
pSpGetCurrentInstallVariation(
    IN  PWSTR szPid20,
    OUT LPDWORD CurrentInstallVariation
    );

BOOL
pSpDetermineSourceProduct(
    OUT PCOMPLIANCE_DATA pcd
    );

BOOLEAN
SpGetStepUpMode(
    PWSTR   PidExtraData,
    BOOLEAN *StepUpMode
    );

BOOLEAN
DetermineSourceVersionInfo(
  OUT PDWORD Version,
  OUT PDWORD BuildNumber
  );


#define CCMemAlloc     SpMemAlloc
#define CCMemFree      SpMemFree

#else

//
// user mode prototypes
//

VOID
CCDisableBuildCheck( 
    VOID
    );


BOOL
IsCompliant(
    PBOOL UpgradeOnly,
    PBOOL NoUpgradeAllowed,
    PUINT SrcSku,
    PUINT CurrentInstallType,
    PUINT CurrentInstallBuild,
    PUINT Reason
    );

BOOLEAN
DetermineSourceVersionInfo(
  IN TCHAR *InfPath,
  OUT PDWORD Version,
  OUT PDWORD BuildNumber
  );

BOOL
DetermineCurrentInstallation(
    LPDWORD CurrentInstallType,
    LPDWORD CurrentInstallVariation,
    LPDWORD CurrentInstallVersion,
    LPDWORD CurrentInstallBuildNT,
    LPDWORD CurrentInstallBuildWin9x,
    LPDWORD CurrentInstallSuite,
    LPDWORD CurrentInstallServicePack
    );

BOOL
GetCurrentInstallVariation(
    LPDWORD CurrentInstallVariation,
    IN  DWORD   CurrentInstallType,
    IN  DWORD   CurrentInstallBuildNT,
    IN  DWORD   InstallVersion
    );

BOOL
GetCurrentNtVersion(
    LPDWORD CurrentInstallType,
    LPDWORD CurrentInstallSuite
    );

BOOL
GetCdSourceInstallType(
    LPDWORD SourceInstallType
    );

BOOL
GetSourceInstallVariation(
    LPDWORD SourceInstallVariation
    );

BOOL 
IsWinPEMode(
    VOID
    );
    

#define CCMemAlloc     malloc
#define CCMemFree      free

#endif

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif // _COMPLIANCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\hwdb.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    hwcomp.h

Abstract:

    Module's interface.

Author:

    Ovidiu Temereanca (ovidiut) 04-Jul-2000  Initial implementation

Revision History:

--*/


//
// Interface
//

BOOL
WINAPI
HwdbInitializeA (
    IN      PCSTR TempDir
    );

BOOL
WINAPI
HwdbInitializeW (
    IN      PCWSTR TempDir
    );

VOID
WINAPI
HwdbTerminate (
    VOID
    );

HANDLE
WINAPI
HwdbOpenA (
    IN      PCSTR DatabaseFile
    );

HANDLE
WINAPI
HwdbOpenW (
    IN      PCWSTR DatabaseFile
    );

VOID
WINAPI
HwdbClose (
    IN      HANDLE Hwdb
    );


typedef
BOOL
(*HWDBAPPENDINFSCALLBACKA) (
    IN      PVOID Context,
    IN      PCSTR PnpId,
    IN      PCSTR ActualInfFilename,
    IN      PCSTR SourceDir,
    IN      PCSTR FullInfPath
    );

BOOL
WINAPI
HwdbAppendInfsA (
    IN      HANDLE Hwdb,
    IN      PCSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    );

typedef
BOOL
(*HWDBAPPENDINFSCALLBACKW) (
    IN      PVOID Context,
    IN      PCWSTR PnpId,
    IN      PCWSTR ActualInfFilename,
    IN      PCWSTR SourceDir,
    IN      PCWSTR FullInfPath
    );

BOOL
WINAPI
HwdbAppendInfsW (
    IN      HANDLE Hwdb,
    IN      PCWSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKW Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    );

BOOL
WINAPI
HwdbAppendDatabase (
    IN      HANDLE HwdbTarget,
    IN      HANDLE HwdbSource
    );

BOOL
WINAPI
HwdbFlushA (
    IN      HANDLE Hwdb,
    IN      PCSTR OutputFile
    );

BOOL
WINAPI
HwdbFlushW (
    IN      HANDLE Hwdb,
    IN      PCWSTR OutputFile
    );

BOOL
WINAPI
HwdbHasDriverA (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    );

BOOL
WINAPI
HwdbHasDriverW (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpId,
    OUT     PBOOL Unsupported
    );

BOOL
WINAPI
HwdbHasAnyDriverA (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpIds,
    OUT     PBOOL Unsupported
    );

BOOL
WINAPI
HwdbHasAnyDriverW (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpIds,
    OUT     PBOOL Unsupported
    );

typedef
BOOL
(WINAPI* PHWDBINITIALIZEA) (
    IN      PCSTR TempDir
    );

typedef
BOOL
(WINAPI* PHWDBINITIALIZEW) (
    IN      PCWSTR TempDir
    );

typedef
VOID
(WINAPI* PHWDBTERMINATE) (
    VOID
    );

typedef
HANDLE
(WINAPI* PHWDBOPENA) (
    IN      PCSTR DatabaseFile
    );

typedef
HANDLE
(WINAPI* PHWDBOPENW) (
    IN      PCWSTR DatabaseFile
    );

typedef
VOID
(WINAPI* PHWDBCLOSE) (
    IN      HANDLE Hwdb
    );

typedef
BOOL
(WINAPI* PHWDBAPPENDINFSA) (
    IN      HANDLE Hwdb,
    IN      PCSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKA Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    );

typedef
BOOL
(WINAPI* PHWDBAPPENDINFSW) (
    IN      HANDLE Hwdb,
    IN      PCWSTR SourceDirectory,
    IN      HWDBAPPENDINFSCALLBACKW Callback,       OPTIONAL
    IN      PVOID CallbackContext                   OPTIONAL
    );

typedef
BOOL
(WINAPI* PHWDBAPPENDDATABASE) (
    IN      HANDLE HwdbTarget,
    IN      HANDLE HwdbSource
    );

typedef
BOOL
(WINAPI* PHWDBFLUSHA) (
    IN      HANDLE Hwdb,
    IN      PCSTR OutputFile
    );

typedef
BOOL
(WINAPI* PHWDBFLUSHW) (
    IN      HANDLE Hwdb,
    IN      PCWSTR OutputFile
    );

typedef
BOOL
(WINAPI* PHWDBHASDRIVERA) (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    );

typedef
BOOL
(WINAPI* PHWDBHASDRIVERW) (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpId,
    OUT     PBOOL Unsupported
    );


typedef
BOOL
(WINAPI* PHWDBHASANYDRIVERA) (
    IN      HANDLE Hwdb,
    IN      PCSTR PnpId,
    OUT     PBOOL Unsupported
    );

typedef
BOOL
(WINAPI* PHWDBHASANYDRIVERW) (
    IN      HANDLE Hwdb,
    IN      PCWSTR PnpId,
    OUT     PBOOL Unsupported
    );

#if 0

typedef
BOOL
(WINAPI* PHWDBENUM_CALLBACKA) (
    IN      PVOID UserContext,
    IN      PCSTR PnpId,
    IN      PCSTR InfFileName
    );

typedef
BOOL
(WINAPI* PHWDBENUM_CALLBACKW) (
    IN      PVOID UserContext,
    IN      PCWSTR PnpId,
    IN      PCWSTR InfFileName
    );

BOOL
HwdbEnumeratePnpIdA (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKA EnumCallback,
    IN      PVOID UserContext
    );

BOOL
HwdbEnumeratePnpIdW (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKW EnumCallback,
    IN      PVOID UserContext
    );

typedef
BOOL
(WINAPI* PHWDBENUMERATEPNPIDA) (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKA EnumCallback,
    IN      PVOID UserContext
    );

typedef
BOOL
(WINAPI* PHWDBENUMERATEPNPIDW) (
    IN      HANDLE Hwdb,
    IN      PHWDBENUM_CALLBACKW EnumCallback,
    IN      PVOID UserContext
    );

#endif

typedef struct {
    CHAR InfFile[MAX_PATH];
    PCSTR PnpIds;
    PVOID Internal;
} HWDBINF_ENUMA, *PHWDBINF_ENUMA;

typedef struct {
    PCWSTR InfFile;
    PCWSTR PnpIds;
    PVOID Internal;
} HWDBINF_ENUMW, *PHWDBINF_ENUMW;


BOOL
HwdbEnumFirstInfA (
    OUT     PHWDBINF_ENUMA EnumPtr,
    IN      PCSTR DatabaseFile
    );

BOOL
HwdbEnumFirstInfW (
    OUT     PHWDBINF_ENUMW EnumPtr,
    IN      PCWSTR DatabaseFile
    );

BOOL
HwdbEnumNextInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    );

BOOL
HwdbEnumNextInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    );

VOID
HwdbAbortEnumInfA (
    IN OUT  PHWDBINF_ENUMA EnumPtr
    );

VOID
HwdbAbortEnumInfW (
    IN OUT  PHWDBINF_ENUMW EnumPtr
    );

//
// exported function names
//
#define S_HWDBAPI_HWDBINITIALIZE_A      "HwdbInitializeA"
#define S_HWDBAPI_HWDBINITIALIZE_W      "HwdbInitializeW"
#define S_HWDBAPI_HWDBTERMINATE         "HwdbTerminate"
#define S_HWDBAPI_HWDBOPEN_A            "HwdbOpenA"
#define S_HWDBAPI_HWDBOPEN_W            "HwdbOpenW"
#define S_HWDBAPI_HWDBCLOSE             "HwdbClose"
#define S_HWDBAPI_HWDBAPPENDINFS_A      "HwdbAppendInfsA"
#define S_HWDBAPI_HWDBAPPENDINFS_W      "HwdbAppendInfsW"
#define S_HWDBAPI_HWDBAPPENDDATABASE    "HwdbAppendDatabase"
#define S_HWDBAPI_HWDBFLUSH_A           "HwdbFlushA"
#define S_HWDBAPI_HWDBFLUSH_W           "HwdbFlushW"
#define S_HWDBAPI_HWDBHASDRIVER_A       "HwdbHasDriverA"
#define S_HWDBAPI_HWDBHASDRIVER_W       "HwdbHasDriverW"
#define S_HWDBAPI_HWDBHASANYDRIVER_A    "HwdbHasAnyDriverA"
#define S_HWDBAPI_HWDBHASANYDRIVER_W    "HwdbHasAnyDriverW"

typedef struct {
    PHWDBINITIALIZEA HwdbInitialize;
    PHWDBTERMINATE HwdbTerminate;
    PHWDBOPENA HwdbOpen;
    PHWDBCLOSE HwdbClose;
    PHWDBAPPENDINFSA HwdbAppendInfs;
    PHWDBFLUSHA HwdbFlush;
    PHWDBHASDRIVERA HwdbHasDriver;
    PHWDBHASANYDRIVERA HwdbHasAnyDriver;
} HWDB_ENTRY_POINTSA, *PHWDB_ENTRY_POINTSA;

typedef struct {
    PHWDBINITIALIZEW HwdbInitialize;
    PHWDBTERMINATE HwdbTerminate;
    PHWDBOPENW HwdbOpen;
    PHWDBCLOSE HwdbClose;
    PHWDBAPPENDINFSW HwdbAppendInfs;
    PHWDBFLUSHW HwdbFlush;
    PHWDBHASDRIVERW HwdbHasDriver;
    PHWDBHASANYDRIVERW HwdbHasAnyDriver;
} HWDB_ENTRY_POINTSW, *PHWDB_ENTRY_POINTSW;

#ifdef UNICODE

#define S_HWDBAPI_HWDBINITIALIZE        S_HWDBAPI_HWDBINITIALIZE_W
#define PHWDBINITIALIZE                 PHWDBINITIALIZEW
#define S_HWDBAPI_HWDBOPEN              S_HWDBAPI_HWDBOPEN_W
#define PHWDBOPEN                       PHWDBOPENW
#define S_HWDBAPI_HWDBAPPENDINFS        S_HWDBAPI_HWDBAPPENDINFS_W
#define PHWDBAPPENDINFS                 PHWDBAPPENDINFSW
#define S_HWDBAPI_HWDBFLUSH             S_HWDBAPI_HWDBFLUSH_W
#define PHWDBFLUSH                      PHWDBFLUSHW
#define S_HWDBAPI_HWDBHASDRIVER         S_HWDBAPI_HWDBHASDRIVER_W
#define PHWDBHASDRIVER                  PHWDBHASDRIVERW
#define S_HWDBAPI_HWDBHASANYDRIVER      S_HWDBAPI_HWDBHASANYDRIVER_W
#define PHWDBHASANYDRIVER               PHWDBHASANYDRIVERW
#define HWDBINF_ENUM                    HWDBINF_ENUMW
#define PHWDBINF_ENUM                   PHWDBINF_ENUMW
#define HwdbEnumFirstInf                HwdbEnumFirstInfW
#define HwdbEnumNextInf                 HwdbEnumNextInfW
#define HwdbAbortEnumInf                HwdbAbortEnumInfW
#define HWDB_ENTRY_POINTS               HWDB_ENTRY_POINTSW
#define PHWDB_ENTRY_POINTS              PHWDB_ENTRY_POINTSW
#else

#define S_HWDBAPI_HWDBINITIALIZE        S_HWDBAPI_HWDBINITIALIZE_A
#define PHWDBINITIALIZE                 PHWDBINITIALIZEA
#define S_HWDBAPI_HWDBOPEN              S_HWDBAPI_HWDBOPEN_A
#define PHWDBOPEN                       PHWDBOPENA
#define S_HWDBAPI_HWDBAPPENDINFS        S_HWDBAPI_HWDBAPPENDINFS_A
#define PHWDBAPPENDINFS                 PHWDBAPPENDINFSA
#define S_HWDBAPI_HWDBFLUSH             S_HWDBAPI_HWDBFLUSH_A
#define PHWDBFLUSH                      PHWDBFLUSHA
#define S_HWDBAPI_HWDBHASDRIVER         S_HWDBAPI_HWDBHASDRIVER_A
#define PHWDBHASDRIVER                  PHWDBHASDRIVERA
#define S_HWDBAPI_HWDBHASANYDRIVER      S_HWDBAPI_HWDBHASANYDRIVER_A
#define PHWDBHASANYDRIVER               PHWDBHASANYDRIVERA
#define HWDBINF_ENUM                    HWDBINF_ENUMA
#define PHWDBINF_ENUM                   PHWDBINF_ENUMA
#define HwdbEnumFirstInf                HwdbEnumFirstInfA
#define HwdbEnumNextInf                 HwdbEnumNextInfA
#define HwdbAbortEnumInf                HwdbAbortEnumInfA
#define HWDB_ENTRY_POINTS               HWDB_ENTRY_POINTSA
#define PHWDB_ENTRY_POINTS              PHWDB_ENTRY_POINTSA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\mgdlllib.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    miglib.h

Abstract:

    Public Header file for Miglib functionality.

Author:

    Marc R. Whitten (marcw) 07-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "plugin.h"
#define DBG_FOO     "Foo"

//
// Strings
//

// None

//
// Constants
//

#define GATHERMODE TRUE
#define APPLYMODE FALSE
#define SOURCEOS_WIN9X TRUE
#define SOURCEOS_WINNT FALSE


// None

//
// Macros
//

#define S_REGKEY_MIGRATION_DLLS_WINNT   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\NT Migration DLLs")

#define MIGDLLEXPORT __declspec(dllexport)

//
// Types
//



#define DLLLIST PVOID


typedef struct {

    SIZE_T Size;
    PCSTR StaticProductIdentifier;
    UINT DllVersion;
    PINT CodePageArray;
    UINT SourceOs;
    UINT TargetOs;
    PCSTR * NeededFileList;
    PVENDORINFO VendorInfo;

} MIGRATIONINFOA, *PMIGRATIONINFOA;

typedef struct {

    SIZE_T Size;
    PCWSTR StaticProductIdentifier;
    UINT DllVersion;
    PINT CodePageArray;
    UINT SourceOs;
    UINT TargetOs;
    PCWSTR * NeededFileList;
    PVENDORINFO VendorInfo;

} MIGRATIONINFOW, *PMIGRATIONINFOW;



typedef struct {

    CHAR WorkingDirectory[MAX_PATH];
    CHAR SourceMedia[MAX_PATH];
    CHAR DllPath[MAX_PATH];

    MIGRATIONINFOA Info;

} MIGDLLPROPERTIESA, *PMIGDLLPROPERTIESA;

typedef struct {



    WCHAR WorkingDirectory[MAX_PATH];
    WCHAR SourceMedia[MAX_PATH];
    WCHAR DllPath[MAX_PATH];

    MIGRATIONINFOW Info;

} MIGDLLPROPERTIESW, *PMIGDLLPROPERTIESW;


typedef struct {

    BOOL Isolated;
    BOOL MigrationMode;
    BOOL SourceOs;
    BOOL SrcUnicode;
    BOOL OldStyle;
    HANDLE Library;

    MIGDLLPROPERTIESA Properties;

} MIGRATIONDLLA, *PMIGRATIONDLLA;

typedef struct {

    BOOL Isolated;
    BOOL MigrationMode;
    BOOL SourceOs;
    BOOL SrcUnicode;
    BOOL OldStyle;
    HANDLE Library;

    MIGDLLPROPERTIESW Properties;

} MIGRATIONDLLW, *PMIGRATIONDLLW;



typedef struct {

    PMIGDLLPROPERTIESA Properties;
    INT NextItem;
    DLLLIST List;

} MIGDLLENUMA, *PMIGDLLENUMA;

typedef struct {

    PMIGDLLPROPERTIESW Properties;
    INT NextItem;
    DLLLIST List;

} MIGDLLENUMW, *PMIGDLLENUMW;


typedef enum {

    OS_WINDOWS9X = 0,
    OS_WINDOWSNT4X = 1,
    OS_WINDOWS2000 = 2,
    OS_WINDOWSWHISTLER = 3

} OS_TYPES, *POS_TYPES;


typedef BOOL (* MIGDLLINIT) (VOID);
typedef VOID (* MIGDLLSHUTDOWN) (VOID);
typedef VOID (* MIGDLLCLOSEW) (PMIGRATIONDLLW);
typedef BOOL (* MIGDLLGATHERSYSTEMSETTINGSW) (PMIGRATIONDLLW, PCWSTR, PVOID, DWORD);
typedef BOOL (* MIGDLLINITIALIZESRCW) (PMIGRATIONDLLW, PCWSTR, PCWSTR, PCWSTR, PVOID, DWORD);
typedef BOOL (* MIGDLLOPENW) (PMIGRATIONDLLW, PCWSTR, BOOL, BOOL, BOOL);
typedef VOID (* MIGDLLFREELIST) (DLLLIST);
typedef BOOL (* MIGDLLENUMNEXTW) (PMIGDLLENUMW);
typedef BOOL (* MIGDLLENUMFIRSTW) (DLLLIST, PMIGDLLENUMW);
typedef BOOL (* MIGDLLREMOVEDLLINENUMFROMLISTW) (DLLLIST, PMIGDLLENUMW);
typedef BOOL (* MIGDLLADDDLLTOLISTW) (DLLLIST, PMIGRATIONDLLW);
typedef BOOL (* MIGDLLREMOVEDLLFROMLISTW) (DLLLIST, PCWSTR);
typedef PMIGDLLPROPERTIESW (* MIGDLLFINDDLLINLISTW) (DLLLIST, PCWSTR);
typedef BOOL (* MIGDLLQUERYMIGRATIONINFOW) (PMIGRATIONDLLW, PCWSTR, PMIGRATIONINFOW);
typedef DLLLIST (* MIGDLLCREATELIST) (VOID);
typedef BOOL (* MIGDLLAPPLYSYSTEMSETTINGSW) (PMIGRATIONDLLW, PCWSTR, PCWSTR, PVOID, DWORD);
typedef BOOL (* MIGDLLINITIALIZEDSTW) (PMIGRATIONDLLW, PCWSTR, PCWSTR, PVOID, DWORD);
typedef BOOL (* MIGDLLMOVEDLLLOCALLYW) (PMIGRATIONDLLW, PCWSTR);



//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

BOOL
MigDllQueryMigrationInfoA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDirectory,
    OUT PMIGRATIONINFOA * MigInfo
    );

BOOL
MigDllQueryMigrationInfoW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDirectory,
    OUT PMIGRATIONINFOW * MigInfo
    );

BOOL
MigDllApplySystemSettingsW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDirectory,
    IN PCWSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllApplySystemSettingsA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDirectory,
    IN PCSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    );


BOOL
MigDllApplyUserSettingsW (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR WorkingDir,
    IN      PCWSTR UserKey,
    IN      PCWSTR UserName,
    IN      PCWSTR UserDomain,
    IN      PCWSTR FixedUserName,
    IN      PCWSTR UnattendTxt,
    IN      PCWSTR UserProfilePath,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );

BOOL
MigDllApplyUserSettingsA (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR WorkingDir,
    IN      PCSTR UserKey,
    IN      PCSTR UserName,
    IN      PCSTR UserDomain,
    IN      PCSTR FixedUserName,
    IN      PCSTR UnattendTxt,
    IN      PCSTR UserProfilePath,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );

BOOL
MigDllInitializeDstW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDir,
    IN PCWSTR SourceList,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllInitializeDstA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDir,
    IN PCSTR SourceList,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllGatherSystemSettingsA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllGatherSystemSettingsW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllGatherUserSettingsA (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UserKey,
    IN      PCSTR UserName,
    IN      PCSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );

BOOL
MigDllGatherUserSettingsW (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UserKey,
    IN      PCWSTR UserName,
    IN      PCWSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );

BOOL
MigDllInitializeSrcA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDir,
    IN PCSTR NativeSource,
    IN PCSTR MediaDir,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllInitializeSrcW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDir,
    IN PCWSTR NativeSource,
    IN PCWSTR MediaDir,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
MigDllOpenA (
    OUT PMIGRATIONDLLA DllData,
    IN PCSTR DllPath,
    IN BOOL MigrationMode,
    IN BOOL Isolated,
    IN BOOL SourceOs
    );

BOOL
MigDllOpenW (
    OUT PMIGRATIONDLLW DllData,
    IN PCWSTR DllPath,
    IN BOOL MigrationMode,
    IN BOOL Isolated,
    IN BOOL SourceOs
    );

VOID
MigDllCloseA (
    IN OUT PMIGRATIONDLLA DllData
    );

VOID
MigDllCloseW (
    IN OUT PMIGRATIONDLLW DllData
    );


DLLLIST
MigDllCreateList (
    VOID
    );

VOID
MigDllFreeList (
    DLLLIST List
    );

BOOL
MigDllAddDllToListA (
    IN DLLLIST List,
    IN PMIGRATIONDLLA MigrationDll
    );

BOOL
MigDllAddDllToListW (
    IN DLLLIST List,
    IN PMIGRATIONDLLW MigrationDll
    );


BOOL
MigDllRemoveDllFromListA (
    IN DLLLIST List,
    IN PCSTR ProductId
    );

BOOL
MigDllRemoveDllFromListW (
    IN DLLLIST List,
    IN PCWSTR ProductId
    );


INT
MigDllGetDllCountInList (
    IN DLLLIST List
    );

PMIGDLLPROPERTIESA
MigDllFindDllInListA (
    IN DLLLIST List,
    IN PCSTR ProductId
    );

PMIGDLLPROPERTIESW
MigDllFindDllInListW (
    IN DLLLIST List,
    IN PCWSTR ProductId
    );


BOOL
MigDllEnumNextA (
    IN OUT PMIGDLLENUMA Enum
    );

BOOL
MigDllEnumFirstA (
    OUT PMIGDLLENUMA Enum,
    IN DLLLIST List
    );

BOOL
MigDllRemoveDllInEnumFromListA (
    IN DLLLIST List,
    IN PMIGDLLENUMA Enum
    );

BOOL
MigDllEnumNextW (
    IN OUT PMIGDLLENUMW Enum
    );

BOOL
MigDllEnumFirstW (
    OUT PMIGDLLENUMW Enum,
    IN DLLLIST List
    );

BOOL
MigDllRemoveDllInEnumFromListW (
    IN DLLLIST List,
    IN PMIGDLLENUMW Enum
    );


VOID
MigDllSetMigIsolPathA (
    IN PCSTR Path
    );

VOID
MigDllSetMigIsolPathW (
    IN PCWSTR Path
    );


BOOL
MigDllMoveDllLocallyW (
    IN PMIGRATIONDLLW Dll,
    IN PCWSTR WorkingDirectory
    );


BOOL
MigDllInit (
    VOID
    );

VOID
MigDllShutdown (
    VOID
    );


//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

#ifdef UNICODE
//UNICODE
#define MigDllQueryMigrationInfo MigDllQueryMigrationInfoW
#define MigDllApplySystemSettings MigDllApplySystemSettingsW
#define MigDllApplyUserSettings MigDllApplyUserSettingsW
#define MigDllInitializeDst MigDllInitializeDstW
#define MigDllGatherSystemSettings MigDllGatherSystemSettingsW
#define MigDllGatherUserSettings MigDllGatherUserSettingsW
#define MigDllInitializeSrc MigDllInitializeSrcW
#define MigDllOpen MigDllOpenW
#define MigDllClose MigDllCloseW
#define MigDllAddDllToList MigDllAddDllToListW
#define MigDllRemoveDllFromList MigDllRemoveDllFromListW
#define MigDllFindDllInList MigDllFindDllInListW
#define MigDllEnumNext MigDllEnumNextW
#define MigDllEnumFirst MigDllEnumFirstW
#define MigDllRemoveDllInEnumFromList MigDllRemoveDllInEnumFromListW
#define MigDllSetMigIsolPath MigDllSetMigIsolPathW
#define MigDllMoveDllLocally MigDllMoveDllLocallyW
#define MIGRATIONINFO MIGRATIONINFOW
#define PMIGRATIONINFO PMIGRATIONINFOW
#define MIGDLLPROPERTIES MIGDLLPROPERTIESW
#define PMIGDLLPROPERTIES PMIGDLLPROPERTIESW
#define MIGRATIONDLL MIGRATIONDLLW
#define PMIGRATIONDLL PMIGRATIONDLLW
#define MIGDLLENUM MIGDLLENUMW
#define PMIGDLLENUM PMIGDLLENUMW

#else
//ANSI
#define MigDllQueryMigrationInfo MigDllQueryMigrationInfoA
#define MigDllApplySystemSettings MigDllApplySystemSettingsA
#define MigDllApplyUserSettings MigDllApplyUserSettingsA
#define MigDllInitializeDst MigDllInitializeDstA
#define MigDllGatherSystemSettings MigDllGatherSystemSettingsA
#define MigDllGatherUserSettings MigDllGatherUserSettingsA
#define MigDllInitializeSrc MigDllInitializeSrcA
#define MigDllOpen MigDllOpenA
#define MigDllClose MigDllCloseA
#define MigDllAddDllToList MigDllAddDllToListA
#define MigDllRemoveDllFromList MigDllRemoveDllFromListA
#define MigDllFindDllInList MigDllFindDllInListA
#define MigDllEnumNext MigDllEnumNextA
#define MigDllEnumFirst MigDllEnumFirstA
#define MigDllRemoveDllInEnumFromList MigDllRemoveDllInEnumFromListA
#define MigDllSetMigIsolPath MigDllSetMigIsolPathA
#define MIGRATIONINFO MIGRATIONINFOA
#define PMIGRATIONINFO PMIGRATIONINFOA
#define MIGDLLPROPERTIES MIGDLLPROPERTIESA
#define PMIGDLLPROPERTIES PMIGDLLPROPERTIESA
#define MIGRATIONDLL MIGRATIONDLLA
#define PMIGRATIONDLL PMIGRATIONDLLA
#define MIGDLLENUM MIGDLLENUMA
#define PMIGDLLENUM PMIGDLLENUMA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\n98boot.h ===
typedef
BOOL
(CALLBACK WINNT32_PLUGIN_SETAUTOBOOT_ROUTINE_PROTOTYPE)(
    int
    );

typedef WINNT32_PLUGIN_SETAUTOBOOT_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_SETAUTOBOOT_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 in the case where installation is
    finished all setup proccess..

Arguments:

    int bDrvLetter

Return Value:

    if ERROR, returned FALSE.

--*/

WINNT32_PLUGIN_SETAUTOBOOT_ROUTINE_PROTOTYPE Winnt32SetAutoBoot;


#define WINNT32_PLUGIN_SETAUTOBOOT_NAME     "Winnt32SetAutoBoot"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\pidgen.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    PIDGen.h

Abstract:

    public header

--*/

#ifdef __cplusplus
extern "C" {
#endif

#if defined(WIN32) || defined(_WIN32)

    #ifdef UNICODE
        #define PIDGen        PIDGenW
        #define PIDGenSimp    PIDGenSimpW
        #define PIDGenEx      PIDGenExW
    #else
        #define PIDGen        PIDGenA
        #define PIDGenSimp    PIDGenSimpA
        #define PIDGenEx      PIDGenExA
    #endif // UNICODE

#else

    #include <string.h>
    #include <compobj.h>

    typedef BOOL NEAR *PBOOL;
    typedef BOOL FAR *LPBOOL;

    typedef FILETIME FAR *LPFILETIME;

    #define PIDGenA PIDGen
    #define PIDGenExA PIDGenEx
    #define lstrlenA lstrlen
    #define lstrcpyA lstrcpy
    #define wsprintfA wsprintf

    #define TEXT(s) __T(s)

    #define ZeroMemory(pb, cb) memset(pb, 0, cb)
    #define CopyMemory(pb, ab, cb) memcpy(pb, ab, cb)


#endif // defined(WIN32) || defined(_WIN32)

#define DIGITALPIDMAXLEN 256 // Max length of digital PID 3.0 data blob

#define INVALID_PID 0xFFFFFFFF

// PidGenSimp error code values

enum PidGenError { // pge

    //  Call succeded
    pgeSuccess = 0,

    //  Unable to validate product key.  Most likely causes:
    //      * Product Key was mistyped by user
    //      * Product Key not compatable with this .dll (wrong GroupId)
    pgeProductKeyInvalid = 1,

    //  Product Key's sequence number is not allowed by this .dll.
    //  Most likely causes:
    //      * Using Select or MSDN key with a PidGen/PidCa
    //        that specifically excludes them
    pgeProductKeyExcluded = 2,

    //  NULL was passed in for the required Product Key. (Must
    //  point to valid Product key.)
    pgeProductKeyNull = 3,

    //  Product Key is wrong length.  After removing any dashes, the length
    //  is required to be 25 characters
    pgeProductKeyBadLen = 4,

    //  NULL was passed in for the required SKU. (Must point to
    //  valid SKU.)
    pgeSkuNull = 5,

    //  SKU is wrong length (too long).
    pgeSkuBadLen = 6,


    //  NULL was passed in for the required PID2. (Must
    //  point to buffer for return PID.)
    pgePid2Null = 7,

    //  NULL was passed in for the required DigPid. (Must
    //  point to buffer for generated DigitalPID.)
    pgeDigPidNull = 8,

    //  DigPid is wrong length (too small).
    pgeDigPidBadLen = 9,

    //  NULL was passed in for the required MPC.
    pgeMpcNull = 10,

    //  MPC is wrong length. Must be exactly 5 characters.
    pgeMpcBadLen = 11,

    //  OemId is bad. If passed (it's not required) it must
    //  be 4 characters.
    pgeOemIdBadLen = 12,

    //  Local char set is bad. If provided, must be 24 characters.
    pgeLocalBad = 13,

    // ProductKey Unicode conversion failed
    pgeProductKeyBadUnicode = 14,

    // Mpc Unicode conversion failed
    pgeMpcBadUnicode = 15,

    // SKU Unicode conversion failed
    pgeSkuBadUnicode = 16,

    // OemId Unicode conversion failed
    pgeOemIdBadUnicode = 17,

    // Local Unicode conversion failed
    pgeLocalBadUnicode = 18,

    // Pid2 Unicode conversion failed
    pgePid2BadUnicode = 19,
};


// Original, outdated, interface to PidGen

BOOL STDAPICALLTYPE PIDGenA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPSTR   lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE  lpbPublicKey,       // [IN] pointer to optional public key or NULL
    DWORD   dwcbPublicKey,      // [IN] byte length of optional public key
    DWORD   dwKeyIdx,           // [IN] key pair index optional public key
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS);             // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)


// Simplified interface to PidGen

DWORD STDAPICALLTYPE PIDGenSimpA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number or NULL
    LPBOOL  pfCCP);             // [OUT] ptr to Compliance Checking flag or NULL

// New interfaces added for VL check
BOOL STDAPICALLTYPE PIDGenExA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPSTR   lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE  lpbPublicKey,       // [IN] pointer to optional public key or NULL
    DWORD   dwcbPublicKey,      // [IN] byte length of optional public key
    DWORD   dwKeyIdx,           // [IN] key pair index optional public key
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS,              // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)
    LPBOOL  pfVL);              // [OUT] optional ptr to Volume Licensing flag (can be NULL)

#if defined(WIN32) || defined(_WIN32)


// Original, outdated, interface to PidGen

BOOL STDAPICALLTYPE PIDGenW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCWSTR lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPWSTR  lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE lpbPublicKey,        // [IN] pointer to optional public key or NULL
    DWORD  dwcbPublicKey,       // [IN] byte length of optional public key
    DWORD  dwKeyIdx,            // [IN] key pair index optional public key
    BOOL   fOem,                // [IN] is this an OEM install?

    LPWSTR lpstrPid2,           // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS);             // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)


// Simplified interface to PidGen

DWORD STDAPICALLTYPE PIDGenSimpW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCWSTR lpstrOemId,         // [IN] 4-character OEM ID or NULL
    BOOL    fOem,               // [IN] is this an OEM install?

    LPWSTR  lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number or NULL
    LPBOOL  pfCCP);             // [OUT] ptr to Compliance Checking flag or NULL

BOOL STDAPICALLTYPE PIDGenExW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCWSTR lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPWSTR  lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE lpbPublicKey,        // [IN] pointer to optional public key or NULL
    DWORD  dwcbPublicKey,       // [IN] byte length of optional public key
    DWORD  dwKeyIdx,            // [IN] key pair index optional public key
    BOOL   fOem,                // [IN] is this an OEM install?

    LPWSTR lpstrPid2,           // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS,              // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)
    LPBOOL  pfVL);              // [OUT] optional ptr to Volume Licensing flag (can be NULL)

#endif // defined(WIN32) || defined(_WIN32)

extern HINSTANCE g_hinst;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\digpid.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    digpid.h

Abstract:

--*/

// DigPid.h

#ifdef __cplusplus
extern "C" {
#endif

#define INVALID_PID 0xFFFFFFFF

typedef enum {
    ltFPP,
    ltCCP,
    ltOEM,
    ltSelect,
    ltMLP,
    ltMOLP,
    ltMSDN
} LICENSETYPE;
typedef DWORD DWLICENSETYPE;


// Note: be careful not to alter this definition (or at least it's definition).
// When more fields are needed, create a DIGITALPID2 or similar.  Too much external
// code depends on this header to change it.

typedef struct {
    DWORD dwLength;
    WORD  wVersionMajor;
    WORD  wVersionMinor;
    char  szPid2[24];
    DWORD dwKeyIdx;
    char  szSku[16];
    BYTE  abCdKey[16];
    DWORD dwCloneStatus;
    DWORD dwTime;
    DWORD dwRandom;
    DWLICENSETYPE dwlt;
    DWORD adwLicenseData[2];
    char  szOemId[8];
    DWORD dwBundleId;

    char  aszHardwareIdStatic[8];

    DWORD dwHardwareIdTypeStatic;
    DWORD dwBiosChecksumStatic;
    DWORD dwVolSerStatic;
    DWORD dwTotalRamStatic;
    DWORD dwVideoBiosChecksumStatic;

    char  aszHardwareIdDynamic[8];

    DWORD dwHardwareIdTypeDynamic;
    DWORD dwBiosChecksumDynamic;
    DWORD dwVolSerDynamic;
    DWORD dwTotalRamDynamic;
    DWORD dwVideoBiosChecksumDynamic;

    DWORD dwCrc32;
} DIGITALPID, *PDIGITALPID, FAR *LPDIGITALPID;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\regdiff.h ===
#pragma once

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


typedef PVOID HREGANL;

typedef
HREGANL
(*PFNCREATEREGANALYZER) (
    VOID
    );

HREGANL
CreateRegAnalyzer (
    VOID
    );

typedef
BOOL
(*PFNCLOSEREGANALYZER) (
    IN      HREGANL RegAnalyzer
    );

BOOL
CloseRegAnalyzer (
    IN      HREGANL RegAnalyzer
    );

typedef
BOOL
(PFNADDREGISTRYKEY) (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR RootKeyName,
    IN      PCTSTR SubKeyName
    );

BOOL
AddRegistryKey (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR RootKeyName,
    IN      PCTSTR SubKeyName
    );

typedef
BOOL
(*PFNEXCLUDEREGISTRYKEY) (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR RootKeyName,
    IN      PCTSTR SubKeyName
    );

BOOL
ExcludeRegistryKey (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR RootKeyName,
    IN      PCTSTR SubKeyName
    );

typedef
DWORD
SNAPSHOTPROGRESS (
    IN      PVOID Context,
    IN      DWORD NodesProcessed
    );

typedef SNAPSHOTPROGRESS* PFNSNAPSHOTPROGRESS;

typedef
BOOL
(*PFNTAKESNAPSHOT) (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR SnapshotFile,
    IN      PFNSNAPSHOTPROGRESS ProgressCallback,
    IN      PVOID Context,
    IN      DWORD MaxLevel
    );

BOOL
TakeSnapshot (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR SnapshotFile,
    IN      PFNSNAPSHOTPROGRESS ProgressCallback,
    IN      PVOID Context,
    IN      DWORD MaxLevel,
	IN		HANDLE hEvent);

typedef
BOOL
(*PFNCOMPUTEDIFFERENCES) (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR Snapshot1,
    IN      PCTSTR Snapshot2,
    IN      PCTSTR DiffFile
    );

BOOL
ComputeDifferences (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR Snapshot1,
    IN      PCTSTR Snapshot2,
    IN      PCTSTR DiffFile,
	IN		HANDLE hEvent
    );

typedef
BOOL
(*PFNINSTALLDIFFERENCES) (
    IN      PCTSTR DiffFile,
    IN      PCTSTR UndoFile
    );

BOOL
InstallDifferences (
    IN      PCTSTR DiffFile,
    IN      PCTSTR UndoFile
    );

typedef
BOOL
(*PFNCOUNTREGSUBKEYS) (
    IN      PCTSTR Root,
    IN      PCTSTR SubKey,
    IN      DWORD MaxLevels,
    OUT     PDWORD Nodes
    );

BOOL
CountRegSubkeys (
    IN      PCTSTR Root,
    IN      PCTSTR SubKey,
    IN      DWORD MaxLevels,
    OUT     PDWORD Nodes
    );

typedef
HKEY
(*PFNGETROOTKEY) (
    IN      PCTSTR RootStr
    );

HKEY
GetRootKey (
    IN      PCTSTR RootStr
    );

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\hwlog.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ntsetup\inc\hwlog.h

Abstract:

    Logging some aspects of the hardware configuration to winnt32.log.
    Esp. disk drive by connection, and map drive letters to disk drives.

Author:

    Jay Krell (JayKrell) April 2001, May 2001

Revision History:

Environment:

    winnt32.dll -- Win9x ANSI (down to Win95gold) or NT Unicode
                   libcmt statically linked in, _tcs* ok
                   actually only built for Unicode/NT, and does nothing
                   if run on less than Windows 2000

    setup.exe -newsetup -- guimode setup
--*/

struct _SP_LOG_HARDWARE_IN;

#include "setupapi.h"

typedef struct _SP_LOG_HARDWARE_IN {
    PCTSTR MachineName OPTIONAL;
    HANDLE LogFile OPTIONAL;
    BOOL (WINAPI  * SetupLogError)(PCTSTR MessageString, LogSeverity) OPTIONAL;
    BOOL (__cdecl * SetuplogError)(
        IN  LogSeverity         Severity,
        IN  LPCTSTR             MessageString,
        IN  UINT                MessageId,      OPTIONAL
        ...
        ) OPTIONAL;
} SP_LOG_HARDWARE_IN, *PSP_LOG_HARDWARE_IN;
typedef CONST SP_LOG_HARDWARE_IN* PCSP_LOG_HARDWARE_IN;

VOID
SpLogHardware(
    PSP_LOG_HARDWARE_IN In
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\setupsxs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SetupSxs.h

Abstract:

    Shared declarations for setup's Side by Side support.

Author:

    Jay Krell (a-JayK) May 2000

Revision History:

--*/

/* These strings appear in .inf/.inx files, so you can't just change them
here and rebuild and expect it to work. */
#define SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A (     "AssemblyDirectories" )

/* that's all we need for 16bit winnt.exe and the rest doesn't all compile with it */
#if (_MSC_VER > 800)
#pragma once
#define SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_W (    L"AssemblyDirectories" )
#define SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME   (TEXT("AssemblyDirectories"))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\spidgen.h ===
/*
These routines are used so that syssetup and winnt32 will be able
to call PIDGen with a hardcoded pid for the appropriate select
version.
//marrq want the bottom line?
This header should only be included if pidgen.h was also included
*/

#if defined(WIN32) || defined(_WIN32)

    #ifdef UNICODE
        #define SetupPIDGen   SetupPIDGenW
        #define SetupPIDGenEx SetupPIDGenExW
    #else
        #define SetupPIDGen   SetupPIDGenA
        #define SetupPIDGenEx SetupPIDGenExA
    #endif // UNICODE

#else

    #include <string.h>
    #include <compobj.h>

    typedef BOOL NEAR *PBOOL;
    typedef BOOL FAR *LPBOOL;

    typedef FILETIME FAR *LPFILETIME;

    #define SetupPIDGenA SetupPIDGen
    #define SetupPIDGenExA SetupPIDGenEx
    #define lstrlenA lstrlen
    #define lstrcpyA lstrcpy
    #define wsprintfA wsprintf

    #define TEXT(s) __T(s)

    #define ZeroMemory(pb, cb) memset(pb, 0, cb)
    #define CopyMemory(pb, ab, cb) memcpy(pb, ab, cb)


#endif // defined(WIN32) || defined(_WIN32)


BOOL STDAPICALLTYPE SetupPIDGenW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    BOOL   fOem,                // [IN] is this an OEM install?
    LPWSTR lpstrPid2,           // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPBOOL  pfCCP);              // [OUT] optional ptr to Compliance Checking flag (can be NULL)


BOOL STDAPICALLTYPE SetupPIDGenA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    BOOL    fOem,               // [IN] is this an OEM install?
    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPBOOL  pfCCP);              // [OUT] optional ptr to Compliance Checking flag (can be NULL)

BOOL STDAPICALLTYPE SetupPIDGenExW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    BOOL   fOem,                // [IN] is this an OEM install?
    LPWSTR lpstrPid2,           // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfVL);              // [OUT] optional ptr to Volume Licensing flag (can be NULL)


BOOL STDAPICALLTYPE SetupPIDGenExA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    BOOL    fOem,               // [IN] is this an OEM install?
    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfVL);              // [OUT] optional ptr to Volume Licensing flag (can be NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inc\wsdu.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wsdu.h

Abstract:

    Interface to a Dynamic Update support control for Winnt32.

Author:

    Ovidiu Temereanca (ovidiut) 06-Jul-2000

Revision History:

    <alias>  <date>      <comment>

--*/

BOOL
WINAPI
DuIsSupported (
    VOID
    );

typedef
BOOL
(WINAPI* PDUISSUPPORTED) (
    VOID
    );


#define SETUPQUERYID_PNPID          1

typedef struct {
    BOOL Handled;
    BOOL Unsupported;
} PNPID_INFO, *PPNPID_INFO;

#define SETUPQUERYID_DOWNLOADDRIVER 2

// Dynamic Update Custom Error Codes
#define DU_ERROR_MISSING_DLL        12001L
#define DU_NOT_INITIALIZED          12002L
#define DU_ERROR_ASYNC_FAIL         12003L


typedef BOOL (WINAPI* PWINNT32QUERY) (
    IN      DWORD SetupQueryId,
    IN      PVOID InData,
    IN      DWORD InDataSize,
    IN OUT  PVOID OutData,          OPTIONAL
    IN OUT  PDWORD OutDataSize
    );


HANDLE
WINAPI
DuInitializeA (
    IN      PCSTR BaseDir,
    IN      PCSTR TempDir,
    IN      POSVERSIONINFOEXA TargetOsVersion,
    IN      PCSTR TargetPlatform,                 // "i386", "ia64"
    IN      LCID TargetLCID,
    IN      BOOL Unattend,
    IN      BOOL Upgrade,
    IN      PWINNT32QUERY Winnt32QueryCallback
	);

typedef
HANDLE
(WINAPI* PDUINITIALIZEA) (
    IN      PCSTR BaseDir,
    IN      PCSTR TempDir,
    IN      POSVERSIONINFOEXA TargetOsVersion,
    IN      PCSTR TargetPlatform,                 // "i386", "ia64"
    IN      LCID TargetLCID,
    IN      BOOL Unattend,
    IN      BOOL Upgrade,
    IN      PWINNT32QUERY Winnt32QueryCallback
	);


HANDLE
WINAPI
DuInitializeW (
    IN      PCWSTR BaseDir,
    IN      PCWSTR TempDir,
    IN      POSVERSIONINFOEXW TargetOsVersion,
    IN      PCWSTR TargetPlatform,                 // "i386", "ia64"
    IN      LCID TargetLCID,
    IN      BOOL Unattend,
    IN      BOOL Upgrade,
    IN      PWINNT32QUERY Winnt32QueryCallback
	);

typedef
HANDLE
(WINAPI* PDUINITIALIZEW) (
    IN      PCWSTR BaseDir,
    IN      PCWSTR TempDir,
    IN      POSVERSIONINFOEXW TargetOsVersion,
    IN      PCWSTR TargetPlatform,                 // "i386", "ia64"
    IN      LCID TargetLCID,
    IN      BOOL Unattend,
    IN      BOOL Upgrade,
    IN      PWINNT32QUERY Winnt32QueryCallback
	);

#ifdef UNICODE
#define DuInitialize        DuInitializeW
#define PDUINITIALIZE       PDUINITIALIZEW
#else
#define DuInitialize        DuInitializeA
#define PDUINITIALIZE       PDUINITIALIZEA
#endif


BOOL
WINAPI
DuDoDetection (
    IN      HANDLE hConnection,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

typedef
BOOL
(WINAPI* PDUDODETECTION) (
    IN      HANDLE hConnection,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

BOOL
WINAPI
DuQueryUnsupportedDriversA (
    IN      HANDLE hConnection,
    IN      PCSTR* ListOfUnsupportedDrivers,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

typedef
BOOL
(WINAPI* PDUQUERYUNSUPDRVSA) (
    IN      HANDLE hConnection,
    IN      PCSTR* ListOfUnsupportedDrivers,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

BOOL
WINAPI
DuQueryUnsupportedDriversW (
    IN      HANDLE hConnection,
    IN      PCWSTR* ListOfUnsupportedDrivers,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

typedef
BOOL
(WINAPI* PDUQUERYUNSUPDRVSW) (
    IN      HANDLE hConnection,
    IN      PCWSTR* ListOfUnsupportedDrivers,
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

#ifdef UNICODE
#define DuQueryUnsupportedDrivers   DuQueryUnsupportedDriversW
#define PDUQUERYUNSUPDRVS           PDUQUERYUNSUPDRVSW
#else
#define DuQueryUnsupportedDrivers   DuQueryUnsupportedDriversA
#define PDUQUERYUNSUPDRVS           PDUQUERYUNSUPDRVSA
#endif

BOOL
WINAPI
DuBeginDownload (
    IN      HANDLE hConnection,
    IN      HWND hwndNotify
    );

typedef
BOOL
(WINAPI* PDUBEGINDOWNLOAD) (
    IN      HANDLE hConnection,
    IN      HWND hwndNotify
    );

VOID
WINAPI
DuAbortDownload (
    IN      HANDLE hConnection
    );

typedef
VOID
(WINAPI* PDUABORTDOWNLOAD) (
    IN      HANDLE hConnection
    );

DWORD
WINAPI
DuUninitialize (
    IN      HANDLE hConnection
    );

typedef
DWORD
(WINAPI* PDUUNINITIALIZE) (
    IN      HANDLE hConnection
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\sources.inc ===
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1989


Revision History:

    Terence Kwan (terryk) 13-Aug-1992
	add make_inf

!ENDIF

MAJORCOMP=inf
MINORCOMP=inf

INCLUDES=.

TARGETNAME=inf
TARGETPATH=obj
TARGETEXT=cpl
TARGETTYPE=notarget

SOURCES=

NTTARGETFILE0=make_inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\daytona\makefile.inc ===
# Combine the logical section of the inf files with the file list section
# of the inf file together and put them into newinf directory
#
# Terence Kwan (terryk)         12-Aug-1992     Created


#
# Variables
#
# FILELIST      - file list directory
# NEWINF        - new inf directory
# i386inf       - inf files under inf\beta\i386 which need to add file
#                 list section
# amd64inf      - inf files under inf\beta\amd64 which need to add file list
#                 section
# ia64inf       - inf files under inf\beta\ia64 which need to add file list
#                 section
# betafile      - files under inf\beta which do not need to add file list
#                 section
# betainf       - inf files under inf\beta which need to add file list
#                 section
# mediainf      - inf files which need only a [Source Media Description]
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IFDEF LINKONLY
make_inf:
!ELSE
NTCD=1
LMCD=1
W_DIR  = ntcd\$(TARGET_DIRECTORY)
S_DIR  = lmcd\$(TARGET_DIRECTORY)

FILELIST=..\filelist
NEWINF=..\newinf\daytona
MEDIAINP=$(LANGUAGE)media.inp
BETA=beta

!IFDEF LMCD
LOCATION=\lmcd\i386\$(O)
SOURCE_LOCATION=\lmcd\i386
!INCLUDE "..\inf.mk"
!INCLUDE "..\i386inf.mk"
LOCATION=\lmcd\amd64\$(O)
SOURCE_LOCATION=\lmcd\amd64
!INCLUDE "..\amd64inf.mk"
!INCLUDE "..\inf.mk"
LOCATION=\lmcd\ia64\$(O)
SOURCE_LOCATION=\lmcd\ia64
!INCLUDE "..\ia64inf.mk"
!INCLUDE "..\inf.mk"
!ENDIF

!IFDEF NTCD
LOCATION=\ntcd\i386\$(O)
SOURCE_LOCATION=\ntcd\i386
!INCLUDE "..\inf.mk"
!INCLUDE "..\i386inf.mk"
LOCATION=\ntcd\amd64\$(O)
SOURCE_LOCATION=\ntcd\amd64
!INCLUDE "..\amd64inf.mk"
!INCLUDE "..\inf.mk"
LOCATION=\ntcd\ia64\$(O)
SOURCE_LOCATION=\ntcd\ia64
!INCLUDE "..\ia64inf.mk"
!INCLUDE "..\inf.mk"
!ENDIF

all: make_inf

cleansrc:
        $(_NTDRIVE)
        cd $(PROJECT_ROOT)\ntsetup

        -del /q inf\filelist\ntcd\i386\*.*
        -del /q inf\filelist\lmcd\i386\*.*
        -del /q inf\filelist\ntcd\amd64\*.*
        -del /q inf\filelist\lmcd\amd64\*.*
        -del /q inf\filelist\ntcd\ia64\*.*
        -del /q inf\filelist\lmcd\ia64\*.*

make_inf: make_log localize make_fil

make_log:
        $(_NTDRIVE)
        cd $(PROJECT_ROOT)\ntsetup

        -mkdir inf\filelist\ntcd\i386\$(O)
        -mkdir inf\filelist\lmcd\i386\$(O)
        -mkdir inf\filelist\ntcd\amd64\$(O)
        -mkdir inf\filelist\lmcd\amd64\$(O)
        -mkdir inf\filelist\ntcd\ia64\$(O)
        -mkdir inf\filelist\lmcd\ia64\$(O)

        -mkdir inf\newinf\daytona\ntcd\i386\$(O)
        -mkdir inf\newinf\daytona\lmcd\i386\$(O)
        -mkdir inf\newinf\daytona\ntcd\amd64\$(O)
        -mkdir inf\newinf\daytona\lmcd\amd64\$(O)
        -mkdir inf\newinf\daytona\ntcd\ia64\$(O)
        -mkdir inf\newinf\daytona\lmcd\ia64\$(O)

!IFNDEF MERGEONLY

        cd bom
        -mkdir $(O)
        copy bom.txt $(O)\cdbom.txt
        size $(O)\cdlog.log $(O)\cdbom.txt . . z

        size $(O)\cdlog.log $(O)\cdbom.txt #S+$(LANGUAGE) . z
        size $(O)\cdlog.log $(O)\cdbom.txt #F-* . z

!IF "$(LANGUAGE)" == "FIN"
        size $(O)\cdlog.log $(O)\cdbom.txt #P+FIN . z
!ELSE
        size $(O)\cdlog.log $(O)\cdbom.txt #P-FIN . z
!ENDIF

        size $(O)\cdlog.log $(O)\cdbom.txt #L+$(LANGUAGE) . z

        layout $(O)\cdlog.log $(O)\cdbom.txt $(O)\lay.txt ntcd 500000000
        infs $(O)\cdlog.log $(O)\lay.txt ..\inf\filelist\ntcd

        layout $(O)\cdlog.log $(O)\cdbom.txt $(O)\lay.txt lmcd 500000000
        infs $(O)\cdlog.log $(O)\lay.txt ..\inf\filelist\lmcd
!ENDIF

localize:
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)
        local.exe $(LANGUAGE)_ansi.txt ..\filelist\ntcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_ansi.txt ..\filelist\lmcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_net.txt ..\filelist\ntcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_net.txt ..\filelist\lmcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_dev.txt ..\filelist\ntcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_dev.txt ..\filelist\lmcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_con.txt ..\filelist\ntcd\$(_OBJ_DIR)
        local.exe $(LANGUAGE)_con.txt ..\filelist\lmcd\$(_OBJ_DIR)


make_fil: dobetainf dobetafile dopatchinf doamd64inf doi386inf doia64inf
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)

        copy $(FILELIST)\lmcd\i386\$(MEDIAINP)+$(FILELIST)\lmcd\i386\$(O)\mmdriver.inf $(NEWINF)\lmcd\i386\$(O)\mmdriver.inf /B
        copy $(FILELIST)\ntcd\i386\$(MEDIAINP)+$(FILELIST)\ntcd\i386\$(O)\mmdriver.inf $(NEWINF)\ntcd\i386\$(O)\mmdriver.inf /B
        copy $(FILELIST)\ntcd\amd64\$(MEDIAINP)+$(FILELIST)\ntcd\amd64\$(O)\mmdriver.inf $(NEWINF)\ntcd\amd64\$(O)\mmdriver.inf /B
        copy $(FILELIST)\lmcd\amd64\$(MEDIAINP)+$(FILELIST)\lmcd\amd64\$(O)\mmdriver.inf $(NEWINF)\lmcd\amd64\$(O)\mmdriver.inf /B
        copy $(FILELIST)\ntcd\ia64\$(MEDIAINP)+$(FILELIST)\ntcd\ia64\$(O)\mmdriver.inf $(NEWINF)\ntcd\ia64\$(O)\mmdriver.inf /B
        copy $(FILELIST)\lmcd\ia64\$(MEDIAINP)+$(FILELIST)\lmcd\ia64\$(O)\mmdriver.inf $(NEWINF)\lmcd\ia64\$(O)\mmdriver.inf /B

        copy ipinfo.inf $(NEWINF)\ntcd\i386\$(O)
        copy ipinfo.inf $(NEWINF)\lmcd\i386\$(O)
        copy ipinfo.inf $(NEWINF)\ntcd\amd64\$(O)
        copy ipinfo.inf $(NEWINF)\lmcd\amd64\$(O)
        copy ipinfo.inf $(NEWINF)\ntcd\ia64\$(O)
        copy ipinfo.inf $(NEWINF)\lmcd\ia64\$(O)

        copy ipinfor.inf $(NEWINF)\ntcd\i386\$(O)
        copy ipinfor.inf $(NEWINF)\lmcd\i386\$(O)
        copy ipinfor.inf $(NEWINF)\ntcd\amd64\$(O)
        copy ipinfor.inf $(NEWINF)\lmcd\amd64\$(O)
        copy ipinfor.inf $(NEWINF)\ntcd\ia64\$(O)
        copy ipinfor.inf $(NEWINF)\lmcd\ia64\$(O)

        cd $(NEWINF)

!IFDEF _NTTREE
        binplace -R $(_NTTREE)           $(W_DIR)\$(O)\*.inf
        binplace -R $(_NTTREE) -b srvinf $(S_DIR)\$(O)\*.inf

!if !$(WIN64)
        binplace -R $(_NTTREE)           $(W_DIR)\*.inf
        binplace -R $(_NTTREE) -b srvinf $(S_DIR)\*.inf
!endif

        binplace -R $(_NTTREE)           $(W_DIR)\txtsetup.wdl
        binplace -R $(_NTTREE) -b srvinf $(S_DIR)\txtsetup.wdl
!ENDIF

#
# do each files
#

cdinfbeta:
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)

cdamd64inf:
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)\amd64

cdi386inf:
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)\i386

cdia64inf:
        cd $(PROJECT_ROOT)\ntsetup\inf\$(BETA)\ia64

dobetainf:cdinfbeta doeachbetainf

dobetafile:cdinfbeta doeachbetafile

dopatchinf:cdinfbeta doeachpatchfile

!IFDEF NTCD
doamd64inf:cdamd64inf doeachamd64inf
doia64inf:cdia64inf doeachia64inf
!ELSE
!IFDEF LMCD
doamd64inf:cdamd64inf doeachamd64inf
doia64inf:cdia64inf doeachia64inf
!ELSE
doamd64inf:
doia64inf:
!ENDIF
!ENDIF

doi386inf:cdi386inf doeachi386inf


!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\cabcheck\cabcheck.h ===
#include <stdio.h>
#include <windows.h>
#include <conio.h>
#include <process.h>
#include <tchar.h>
#include <objbase.h>
#include <sputils.h>
#include <inflib.h>
#include <string.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\cabcheck\cabcheck.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cabcheck.c

Abstract:

    Program to access/dump information contained in Layout INFs in a readable
    format. It also supports various forms of querying of the layout INF.

Author:

    Vijesh Shetty (vijeshs)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


// By default process the [SourceDisksFiles] section and not the platform
// specific sections.

DWORD Platform = LAYOUTPLATFORMS_COMMON;


//Make the 3 essential arguments global

TCHAR LayoutFileName[MAX_PATH];
TCHAR SortedList[MAX_PATH];
TCHAR OutputIndexFile[MAX_PATH];


BOOL
FindSingleFile( PLAYOUT_CONTEXT LayoutContext,
                PCTSTR FileName )
{

    BOOL ret=FALSE;
    FILE_LAYOUTINFORMATION LayoutInformation;
    MEDIA_INFO MediaInfo;

    ret = FindFileInLayoutInf( LayoutContext,
                               FileName,
                               &LayoutInformation,
                               NULL,
                               NULL,
                               &MediaInfo);
      

    return( ret );



}





BOOL
ProcessCommandLine( int ArgCount, TCHAR *ArgArray[] )
/*
    Function to process the command line and seperate out options into tokens
*/
{

    int i;
    LPTSTR Arg;
    BOOL ret=TRUE;


    if(ArgCount < 4 )
        return FALSE;

    // First check if we are trying to do the Compare of drvindex files.

    

    // Get the Layout filename

    lstrcpy( LayoutFileName, ArgArray[1] );

    // Get the Sorted List filename

    lstrcpy( SortedList, ArgArray[2] );
    
    // Get the Output Index filename

    lstrcpy( OutputIndexFile, ArgArray[3] );

    for ( i=4;i < ArgCount;i++ ){ //Go through each directive


        Arg = ArgArray[i];

        if( (Arg[0] != TEXT('/')) && (Arg[0] != TEXT('-')))
            continue;

        if(_istlower(Arg[1]))
            Arg[1] = _toupper(Arg[1]);

        switch( Arg[1] ){
        
        case TEXT('?'):
            break;
        
        case TEXT('A'):
            Platform |= LAYOUTPLATFORMS_AMD64;
            break;

        case TEXT('I'):
            Platform |= LAYOUTPLATFORMS_X86;
            break;

        case TEXT('M'):
            Platform |= LAYOUTPLATFORMS_IA64;
            break;

        default:
            break;
        }
        




    }// for

    
    
    return( TRUE );


}


void
VerifyDriverList( 
    PLAYOUT_CONTEXT LayoutContext
)
/*

    This function takes in the sorted list of drivers and crosschecks each file against the layout.inf.
    It also generates a drvindex stle output file based on this.
    
    Arguments :
    
        LayoutContext - Pointer to an already built layout inf context.
        
    Return value:
    
        None.        

*/
{
    FILE *SortedFile, *IndexFile;
    TCHAR PreviousFile[MAX_PATH], FileName[MAX_PATH];
    PTCHAR i;


    //OPen the sorted driver list

    if( !(SortedFile = _tfopen( SortedList, TEXT("r") )) ){
        _ftprintf( stderr, TEXT("ERROR: Could not open %s"), SortedList);
        return;
    }

    if( !(IndexFile = _tfopen( OutputIndexFile, TEXT("w") )) ){
        _ftprintf( stderr, TEXT("ERROR: Could not open %s"), OutputIndexFile);
        fclose(SortedFile);
        return;
    }

    //Write the header info to the file

    _ftprintf( IndexFile, TEXT("[Version]\n"));
    _ftprintf( IndexFile, TEXT("signature=\"$Windows NT$\"\n"));
    _ftprintf( IndexFile, TEXT("CabFiles=driver\n\n\n"));
    _ftprintf( IndexFile, TEXT("[driver]\n"));


    lstrcpy( PreviousFile, TEXT("$$$.#$$") );
     
    // HAck because of bug that doesn't allow the use of _TEOF. Bcoz of the bug
    // fscanf returns EOF but fwscanf returns 0 when it should return 0xffff. So _TEOF
    // is useless and causes us to loop.


    while(TRUE){
    

#ifdef UNICODE

        if( (_ftscanf( SortedFile, TEXT("%s"), FileName )) == 0 )
#else  

        if( (_ftscanf( SortedFile, TEXT("%s"), FileName )) == _TEOF )
#endif 
        break;

        
        if(lstrcmpi( PreviousFile, FileName )){

            // Cross check against layout context

            if (FindFileInLayoutInf( LayoutContext,FileName,NULL,NULL,NULL,NULL)){

                for( i = FileName; i < FileName + lstrlen( FileName ); i++ )   {
                    *i = (TCHAR)towlower( *i );
                }

                // File present - Write it out
                _ftprintf( IndexFile, TEXT("%s\n"), _tcslwr(FileName) );


            }


        }
        
        lstrcpy( PreviousFile, FileName );


    }
    clearerr(SortedFile);
    fflush(SortedFile);
    fclose(SortedFile);

    _ftprintf( IndexFile, TEXT("\n\n\n[Cabs]\n"));
    _ftprintf( IndexFile, TEXT("driver=driver.cab\n"));
    

    _flushall();
    _fcloseall();

    return;
}



void 
CmdLineHelp( )
/*
    This routine displays the CmdLine help.
*/
{

    _putts(TEXT("Program to process a sorted list of drivers and cross-check their existance in layout.inf\n")
           TEXT("This is to be used in the build process to cross-check the driver cab's contents against layout.inf\n\n" )
           TEXT("Usage: Cabcheck <Inf Filename> <Sorted driver list> <Output Index File> [arguments]  \n" )
           TEXT("<Inf Filename> - Path to Layout File to examine (ex.layout.inf)\n")
           TEXT("<Sorted driver file> - File containing sorted list of drivers\n")
           TEXT("<Output Index File> - Output index filename\n\n")
           TEXT("Process Platform specific SourceDisksFiles section. Defaults to the [SourceDisksFiles] section only\n")
           TEXT("/i - Process for Intel i386\n")
           TEXT("/a - Process for AMD AMD64\n")
           TEXT("/m - Process for Intel IA64\n")
           TEXT("\n\n" ));
    return;
}


int
_cdecl _tmain( int argc, TCHAR *argv[ ], char *envp[ ] )
{

    PLAYOUT_CONTEXT LayoutContext;
    LPTSTR CommandLine;
    LPWSTR *CmdlineV;
    int CmdlineC;
    
    if(!pSetupInitializeUtils()) {
        _tprintf(TEXT("Initialize failure\n") );
        return 1;
    }
    
    if( !ProcessCommandLine( argc, argv ) ){
        CmdLineHelp();
        return 1;
    }
    
    _ftprintf( stderr, TEXT("\nParsing Layout file...wait...\n"));
    LayoutContext = BuildLayoutInfContext( LayoutFileName, Platform, 0);
    if( !LayoutContext ){
        _ftprintf(stderr,TEXT("\nError - Could not build Layout Inf context\n"));
        return 1;
    }

    VerifyDriverList( LayoutContext );
        
    CloseLayoutInfContext( LayoutContext );

    pSetupUninitializeUtils();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\cabcheck\precomp.h ===
#include "cabcheck.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\infdump\precomp.h ===
#include "infdump.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\infdump\infdump.h ===
#include <stdio.h>
#include <windows.h>
#include <conio.h>
#include <process.h>
#include <tchar.h>
#include <objbase.h>
#include <inflib.h>
#include <string.h>
#include <sputils.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\inc\inflib.h ===
//
//  Header file for inflib.lib
//



#define MAX_PLATFORMS 5
#define MAX_SOURCEIDWIDTH 3

#define LAYOUTPLATFORMS_ALL    0x0000001F // - (default) - Grovels through all the platform-specific section
#define LAYOUTPLATFORMS_X86    0x00000001 // - Grovels through the SourcedisksFiles.x86 section
#define LAYOUTPLATFORMS_AMD64  0x00000002 // - Grovels through the SourcedisksFiles.amd64 section
#define LAYOUTPLATFORMS_IA64   0x00000004 // - Grovels through the SourcedisksFiles.ia64 section
#define LAYOUTPLATFORMS_FREE   0x00000008 // - Grovels through the SourcedisksFiles.obsolete section
#define LAYOUTPLATFORMS_COMMON 0x00000010 // - Grovels through the SourcedisksFiles section

#define LAYOUTPLATFORMINDEX_X86    0 // - The platform index for x86
#define LAYOUTPLATFORMINDEX_AMD64  1 // - The platform index for AMD64
#define LAYOUTPLATFORMINDEX_IA64   2 // - The platform index for IA64
#define LAYOUTPLATFORMINDEX_FREE   3 // - The platform index for obsolete
#define LAYOUTPLATFORMINDEX_COMMON 4 // - The platform index for Common


// BUGBUG: Should make this opaque at some time

typedef struct _LAYOUT_CONTEXT{

    PVOID Context;
    UINT ExtraDataSize;
    PVOID MediaInfo[MAX_PLATFORMS];


}LAYOUT_CONTEXT, *PLAYOUT_CONTEXT;



typedef struct _FILE_LAYOUTINFORMATION{

    TCHAR TargetFileName[MAX_PATH];
    TCHAR Directory[MAX_PATH];
    ULONG Size;
    int Directory_Code;
    int BootMediaNumber;
    int UpgradeDisposition;
    int CleanInstallDisposition;
    TCHAR Media_tagID[MAX_SOURCEIDWIDTH];
    BOOL Compression;
    UINT SectionIndex;
    int Count;


}FILE_LAYOUTINFORMATION, *PFILE_LAYOUTINFORMATION;


typedef struct _MEDIA_INFO{

    TCHAR MediaName[MAX_PATH];
    TCHAR TagFilename[MAX_PATH];
    TCHAR RootDir[MAX_PATH];

}MEDIA_INFO, *PMEDIA_INFO;

typedef BOOL
(CALLBACK *PLAYOUTENUMCALLBACK) (
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    );


PLAYOUT_CONTEXT
BuildLayoutInfContext(
    IN PCTSTR LayoutInfName,
    IN DWORD PlatformMask,
    IN UINT MaxExtraSize
    );
/*
    Function to generate a internal representation of files listed in a layout INF file.
    It returns an opaque context that can be used with other APIs to
    manipulate/query this representation. The internal representation builds a structure
    associated with each file that lists its attributes.
    
    Arguments :
    
        LayoutInfName - Full path to Layout file.
        
        PlatFormMask - Can be one of the following....
        
            LAYOUTPLATFORMS_ALL (default) - Grovels through all the platform-specific section
            
            LAYOUTPLATFORMS_X86 - Grovels through the SourcedisksFiles.x86 section
            
            LAYOUTPLATFORMS_AMD64 - Grovels through the SourcedisksFiles.amd64 section
            
            LAYOUTPLATFORMS_IA64 - Grovels through the SourcedisksFiles.ia64 section
            
            LAYOUTPLATFORMS_COMMON - Grovels through the SourcedisksFiles section
        
        MaxExtraSize  - Largest possible extra-data size that we may want to associate with
                        each file
                  
    Return value :
    
                 
        An opaque LAYOUT_HANDLE used to access the data structure in other calls.
        Returns NULL if we had a failure.


*/

BOOL
EnumerateLayoutInf(
    IN PLAYOUT_CONTEXT LayoutContext,
    IN PLAYOUTENUMCALLBACK LayoutEnumCallback,
    IN DWORD_PTR Param
    );
/*
  This function calls the specified callback function for each 
  element in the SourceDisksFilesSection associated with the 
  Layout Inf Context specified.
  
    It is required that the user has a LayoutInfContext open from a call to
    BuildLayoutInfContext.
    
    Arguments:
    
        Context - A LAYOUT_CONTEXT returned by BuildLayoutInfContext
        
        LayoutEnumCallback - specifies a callback function called for each file in the SourceDisksFile section

        CallerContext - An opaque context pointer passed on to the callback function
        
        
The callback is of the form:

typedef BOOL
(CALLBACK *PLAYOUTENUMCALLBACK) (
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    );

    where

    Context            - Pointer to open LAYOUT_CONTEXT
    
    FileName           - Specifies the individual filename
                           
                           
    LayoutInformation  - Pointer to Layout Information for this file. User should not modify this directly.
    
    ExtraData          - Pointer to the ExtraData that the caller may have stored. User should not modify this directly.
    
    ExtraDataSize      - Size in bytes of the ExtraData
        
    Param            - the opaque param passed into this function is passed
                           into the callback function        
        
        
   Return value:
   
        TRUE if all the elements were enumerated. If not it returns
        FALSE and GetLastError() returns ERROR_CANCELLED. If the callback 
        returns FALSE then the enumeration stops but this API returns TRUE.

*/


BOOL
FindFileInLayoutInf(
    IN PLAYOUT_CONTEXT LayoutContext,
    IN PCTSTR Filename,
    OUT PFILE_LAYOUTINFORMATION LayoutInformation, OPTIONAL
    OUT PVOID ExtraData,   OPTIONAL
    OUT PUINT ExtraDataSize, OPTIONAL
    OUT PMEDIA_INFO Media_Info OPTIONAL
    );
/*
    This function finds the file information for a given filename inside a 
    built layout context. It returns the layout information as well as the
    extra data (if any) associated with the file.
    
    Arguments:

        Context            - Pointer to open LAYOUT_CONTEXT
    
        Filename           - Specifies the filename to search for
        
        LayoutInformation  - Pointer to Layout Information for this file.  User should not modify this directly.
        
        ExtraData          - Pointer to the ExtraData that the caller may have stored. User should not modify this directly.
        
        ExtraDataSize      - Size in bytes of the ExtraData returned.
        
        Media_Info         - Pointer to MEDIA_INFO structure that will get filled
                             with the file's corresponding Media information.
        
     Return value;
     
        TRUE if the file is found - False otherwise.
        

*/


BOOL
CloseLayoutInfContext(
    IN PLAYOUT_CONTEXT LayoutContext);
/*
    This function closes a Layout Inf Context and frees all memory
    associated with it.
    
    Arguments :
    
        LayoutContext   -  LayoutContext to close
        
    Return values :
    
        TRUE if it succeeds, else FALSE        

*/

VOID
MyConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    );

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

BOOL ValidateTextmodeDirCodesSection( 
    PCTSTR LayoutFile, 
    PCTSTR WinntdirSection 
    );
/*
    Routine to validate the [WinntDirectories] section for a setup layout INF. This checks for errors that maybe encountered
    when people add/remove stuff from this section.
    
    Arguments:
    
    LayoutInf       - Name of setup layout INF that contains the specified section
    
    WinntdirSection - Section that contains dir codes
        
        Checks - 
            1) Looks for duplicate or reused dir codes
            
    Return value: 
        TRUE - Validation succeeded
        FALSE- Validation failed     
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\infdump\infdump.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infdump.c

Abstract:

    Program to access/dump information contained in Layout INFs in a readable
    format. It also supports various forms of querying of the layout INF.

Author:

    Vijesh Shetty (vijeshs)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <wild.c>


#define DIRCODE TEXT("DirCode=")
#define DIRNAME TEXT("DirName=")
#define UPGATTR TEXT("UpgAttr=")
#define CLNATTR TEXT("CleanAttr=")
#define BOOTFIL TEXT("BootFile=")
#define COMPRESS TEXT("Compress=")
#define TARGNAME TEXT("TargetName=")
#define SIZEEQV TEXT("SizeEQ")
#define SIZEGRT TEXT("SizeGT")
#define SIZELESS TEXT("SizeLT")

#define DISPLAY TEXT("Display=")


typedef enum _SCOPE{
    AllFiles, //This means that we do it for every file present
    FileSpec  // This means we do this on every file that matches the filespec (with wildcard matching too)
}SCOPE, *PSCOPE;

typedef enum _QUERYTYPE{
    QUERYON_DIRCODE,
    QUERYON_DIRNAME,
    QUERYON_UPGRADEATTR,
    QUERYON_CLEANINSTALLATTR,
    QUERYON_BOOTFILE,
    QUERYON_COMPRESS,
    QUERYON_TARGETNAME,
    QUERYON_SIZEEQV,
    QUERYON_SIZEGRT,
    QUERYON_SIZELESS
}QUERYTYPE, *PQUERYTYPE;


typedef struct _QUERYPARAM{

    QUERYTYPE QueryType;
    BYTE Param[MAX_PATH];

}QUERYPARAM, *PQUERYPARAM;


typedef enum _DISPLAYOPTIONS{
    Default,
    TagInfo,
    FileOnly
} DISPLAYOPTIONS, *PDISPLAYOPTIONS;

typedef struct _QUERYSET{
    TCHAR LayoutFileName[MAX_PATH];
    TCHAR FileNameSpec[MAX_PATH];
    SCOPE Scope;
    int QueryClauses;
    QUERYPARAM QueryParam[20];
    DISPLAYOPTIONS DisplayOption;

} QUERYSET, *PQUERYSET;

QUERYSET GlobalQuerySet;


void
OutputFileInfo( PFILE_LAYOUTINFORMATION LayoutInformation,
                PCTSTR FileName,
                DISPLAYOPTIONS DispType,
                PMEDIA_INFO Media_Info );


BOOL
CALLBACK
MyCallback(
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    )
{

    PQUERYSET QuerySet;
    int i;
    BOOL Display=TRUE;


    if( GlobalQuerySet.Scope == FileSpec ){

        //Check if it matches wildcard..if not ignore this file

        if(!IsNameInExpressionPrivate(GlobalQuerySet.FileNameSpec, FileName))
            return( TRUE );
    }


    if( Param  ){

        QuerySet = (PQUERYSET)Param;


        //Process each clause

        for( i=0; i<QuerySet->QueryClauses;i++){

            Display=FALSE;
            switch( QuerySet->QueryParam[i].QueryType ){

            case QUERYON_DIRCODE:
                if( LayoutInformation->Directory_Code == (_ttoi((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;

            case QUERYON_DIRNAME:
                if( !_tcsicmp( LayoutInformation->Directory,(PTCHAR)(QuerySet->QueryParam[i].Param)))
                    Display = TRUE;
                break;

            case QUERYON_UPGRADEATTR:
                if( LayoutInformation->UpgradeDisposition == (_ttoi((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;
                break;

            case QUERYON_CLEANINSTALLATTR:
                if( LayoutInformation->CleanInstallDisposition == (_ttoi((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;
                break;

            case QUERYON_BOOTFILE:
                if( LayoutInformation->BootMediaNumber && (LayoutInformation->BootMediaNumber != -1)){
                    if( !_tcsicmp((PTCHAR)(QuerySet->QueryParam[i].Param), TEXT("*")) )
                        Display = TRUE;
                    else if( LayoutInformation->BootMediaNumber == (_ttoi((PTCHAR)(QuerySet->QueryParam[i].Param))))
                        Display = TRUE;
                }
                break;

            case QUERYON_COMPRESS:
                if( !_tcsicmp((PTCHAR)(QuerySet->QueryParam[i].Param), TEXT("YES")) ){
                    if( LayoutInformation->Compression == TRUE )
                        Display = TRUE;
                }else if( !_tcsicmp((PTCHAR)(QuerySet->QueryParam[i].Param), TEXT("NO")) ){
                    if( LayoutInformation->Compression == FALSE )
                        Display = TRUE;
                }

                break;

            case QUERYON_TARGETNAME:
                if( IsNameInExpressionPrivate( (PTCHAR)(QuerySet->QueryParam[i].Param), LayoutInformation->TargetFileName))
                    Display = TRUE;
                break;


                //
                //  Have to fix so that we don't overflow.
                //


            case QUERYON_SIZEEQV:
                if( LayoutInformation->Size == (ULONG)(_ttol((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;
                break;

            case QUERYON_SIZEGRT:
                if( LayoutInformation->Size > (ULONG)(_ttol((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;
                break;

            case QUERYON_SIZELESS:
                if( LayoutInformation->Size < (ULONG)(_ttol((PTCHAR)(QuerySet->QueryParam[i].Param))))
                    Display = TRUE;
                break;


            default:
                Display = FALSE;
                break;

            }

            if( !Display )
                break;


        }

        if( Display  == TRUE ){
            if( QuerySet->DisplayOption == TagInfo ){
    
                BOOL ret=FALSE;
                MEDIA_INFO MediaInfo;
    
    
                ret = FindFileInLayoutInf( Context,
                                   FileName,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &MediaInfo);
                if (ret)
                    OutputFileInfo( LayoutInformation, FileName, QuerySet->DisplayOption, &MediaInfo );
    
    
            }else
                OutputFileInfo( LayoutInformation, FileName, QuerySet->DisplayOption, NULL );
    
        }


    }


    

    return( TRUE );




}



void
FindSingleFile( PLAYOUT_CONTEXT LayoutContext,
                PCTSTR FileName )
{

    BOOL ret=FALSE;
    FILE_LAYOUTINFORMATION LayoutInformation;
    MEDIA_INFO MediaInfo;

    ret = FindFileInLayoutInf( LayoutContext,
                               FileName,
                               &LayoutInformation,
                               NULL,
                               NULL,
                               &MediaInfo);


    if (ret)
        OutputFileInfo( &LayoutInformation, FileName, Default, &MediaInfo );
    else
        _ftprintf(stderr, TEXT("\nError: File Not Found\n"));


    return;



}



void
OutputFileInfo( PFILE_LAYOUTINFORMATION LayoutInformation,
                PCTSTR FileName,
                DISPLAYOPTIONS DispType,
                PMEDIA_INFO Media_Info )
{
    TCHAR Disposition[][50]={ TEXT("Always Copy"),
                             TEXT("Copy if present"),
                             TEXT("Copy if not present"),
                             TEXT("Never copy - Copied via INF")


    };

    if( DispType == FileOnly )
        _tprintf(TEXT("%s\n"),FileName);
    else
        _tprintf(TEXT("Filename         - %s\n"),FileName);

    if( DispType == FileOnly )
        return;

    _tprintf(TEXT("Dir Name         - %s(%d)\n"), LayoutInformation->Directory, LayoutInformation->Directory_Code);


    _tprintf(TEXT("On Upgrade       - %s(%d)\n"), Disposition[LayoutInformation->UpgradeDisposition], LayoutInformation->UpgradeDisposition);
    _tprintf(TEXT("On Clean Install - %s(%d)\n"), Disposition[LayoutInformation->CleanInstallDisposition], LayoutInformation->CleanInstallDisposition);

    _tprintf(TEXT("Media Tag ID     - %s\n"),LayoutInformation->Media_tagID);

    if( *(LayoutInformation->TargetFileName))
        _tprintf(TEXT("Target Filename  - %s\n"),LayoutInformation->TargetFileName);
    if( LayoutInformation->BootMediaNumber && (LayoutInformation->BootMediaNumber != -1))
        _tprintf(TEXT("Boot Media       - %d\n"),LayoutInformation->BootMediaNumber);
    if( !LayoutInformation->Compression )
        _tprintf(TEXT("No Compression\n"));
    if( LayoutInformation->Size > 0 )
        _tprintf(TEXT("Uncompressed Size- %d\n"),LayoutInformation->Size);
    if( LayoutInformation->Count > 1 )
        _tprintf(TEXT("Occurrences      - %d\n"),LayoutInformation->Count);



    if( Media_Info ){

        _tprintf(TEXT("Media Name       - %s\n"),Media_Info->MediaName);
        _tprintf(TEXT("Media Tagfile    - %s\n"),Media_Info->TagFilename);
        _tprintf(TEXT("Media Rootdir    - %s\n"),Media_Info->RootDir);


    }

    if( DispType != FileOnly )
        _tprintf( TEXT("\n"));


    return;

}


BOOL
ProcessCommandLine( int ArgCount, TCHAR *ArgArray[] )
/*
    Function to process the command line and seperate out options into tokens
*/
{

    int i, Next;
    LPTSTR Arg;
    TCHAR Temp[MAX_PATH];
    QUERYTYPE QType;

    ZeroMemory( &GlobalQuerySet, sizeof(QUERYSET));

    GlobalQuerySet.Scope = FileSpec;
    lstrcpy( GlobalQuerySet.FileNameSpec, TEXT("*") );
    GlobalQuerySet.DisplayOption = Default;
    lstrcpy( GlobalQuerySet.LayoutFileName, ArgArray[1] );



    Next = 0;
    for ( i=2;i < ArgCount;i++ ){ //Go through each directive


        Arg = ArgArray[i];

        if( Arg[0] != TEXT('/') )
            continue;

        switch( _toupper(Arg[1]) ){

        case TEXT('A'):
            GlobalQuerySet.Scope = AllFiles;
            break;

        case TEXT('S'):             //Query Clause ?

            //_tprintf(TEXT("S  -- %s"),Arg);

            if( Arg[2] != TEXT(':')) {
                return FALSE;
            }

            //Dir Code case

            if( ! _tcsnicmp( Arg+3, DIRCODE, lstrlen(DIRCODE))){

               lstrcpy( Temp, DIRCODE );
               QType = QUERYON_DIRCODE;
            }

            if( ! _tcsnicmp( Arg+3, DIRNAME, lstrlen(DIRNAME))){

               lstrcpy( Temp, DIRNAME );
               QType = QUERYON_DIRNAME;
            }

            if( ! _tcsnicmp( Arg+3, UPGATTR, lstrlen(UPGATTR))){

               lstrcpy( Temp, UPGATTR );
               QType = QUERYON_UPGRADEATTR;
            }

            if( ! _tcsnicmp( Arg+3, CLNATTR, lstrlen(CLNATTR))){

               lstrcpy( Temp, CLNATTR );
               QType = QUERYON_CLEANINSTALLATTR;
            }

            if( ! _tcsnicmp( Arg+3, BOOTFIL, lstrlen(BOOTFIL))){

               lstrcpy( Temp, BOOTFIL );
               QType = QUERYON_BOOTFILE;
            }

            if( ! _tcsnicmp( Arg+3, COMPRESS, lstrlen(COMPRESS))){

               lstrcpy( Temp, COMPRESS );
               QType = QUERYON_COMPRESS;
            }

            if( ! _tcsnicmp( Arg+3, TARGNAME, lstrlen(TARGNAME))){

               lstrcpy( Temp, TARGNAME );
               QType = QUERYON_TARGETNAME;
            }

            if( ! _tcsnicmp( Arg+3, DIRCODE, lstrlen(DIRCODE))){

               lstrcpy( Temp, DIRCODE );
               QType = QUERYON_DIRCODE;
            }

            if( ! _tcsnicmp( Arg+3, SIZEEQV, lstrlen(SIZEEQV))){
               lstrcpy( Temp, SIZEEQV );
               QType = QUERYON_SIZEEQV;
            }

            if( ! _tcsnicmp( Arg+3, SIZEGRT, lstrlen(SIZEGRT))){
               lstrcpy( Temp, SIZEGRT );
               QType = QUERYON_SIZEGRT;
            }

            if( ! _tcsnicmp( Arg+3, SIZELESS, lstrlen(SIZELESS))){
               lstrcpy( Temp, SIZELESS );
               QType = QUERYON_SIZELESS;
            }

            GlobalQuerySet.QueryParam[Next].QueryType = QType;
            GlobalQuerySet.QueryClauses++;
            if( *(Arg+3+lstrlen(Temp)) == TEXT('\0'))
                return FALSE;
            lstrcpy((LPTSTR)GlobalQuerySet.QueryParam[Next++].Param, Arg+3+lstrlen(Temp));
            break;

        case TEXT('D'):

            //_tprintf(TEXT("D  -- %s"),Arg);

            if( Arg[2] != TEXT(':'))
                return FALSE;


            if( !_tcsicmp( Arg+3, TEXT("DEFAULT")))
                GlobalQuerySet.DisplayOption = Default;
            else if( !_tcsicmp( Arg+3, TEXT("ALL")))
                GlobalQuerySet.DisplayOption = TagInfo;
            else if( !_tcsicmp( Arg+3, TEXT("FILEONLY")))
                GlobalQuerySet.DisplayOption = FileOnly;

            break;

        default:
            break;
        }
    }// for

    if( (GlobalQuerySet.Scope == FileSpec) && (ArgArray[2][0] != TEXT('/'))){
        lstrcpy( GlobalQuerySet.FileNameSpec, ArgArray[2] );
    }

    return( TRUE );
}

_cdecl _tmain( int argc, TCHAR *argv[ ], char *envp[ ] )
{
    PTSTR p;
    PWSTR InfName;
    PLAYOUT_CONTEXT LayoutContext;
    int StrLen;
    TCHAR LayoutFileName[MAX_PATH], FileName[MAX_PATH];
    LPWSTR *CmdlineV;
    int CmdlineC;
    BOOL ans = FALSE;
    int Result = 1;

    if(!pSetupInitializeUtils()) {
        _tprintf(TEXT("Initialize failure\n") );
        return 1;
    }

    //
    // Check Params.
    //
    if( argc < 3 ) {
        _tprintf(
               TEXT("Program to process layout inf file to gather information on file(s)\n\n")
               TEXT("Usage: %s <Inf Filename> [file specifier] [flags] [arguments]  \n")
               TEXT("<Inf Filename> - Layout File to examine\n")
               TEXT("[file specifier] - File name to query (accepts wildcards) - default is *\n")
               TEXT("/a - Enumerates information for all files (overrides file specifier)\n\n" )
               TEXT("/s:<property>=<value> - Query based on a property\n" )
               TEXT("    There could be multiple /s options and they are \"anded\"\n")
               TEXT("    /s:dircode=<value>  Looks for files that match the directory code specified\n")
               TEXT("    /s:dirname=<value>  Looks for files that match the directory path specified\n")
               TEXT("    /s:upgattr=<attr>   Looks for files that match the action attribute in the upgrade case\n")
               TEXT("    /s:cleanattr=<attr> Looks for files that match the action attribute in the clean install case\n")
               TEXT("       Valid <attr> values:\n")
               TEXT("          0 - Always Copy\n")
               TEXT("          1 - Copy if present\n")
               TEXT("          2 - Copy if not present\n")
               TEXT("          3 - Never copy - Copied via INF\n")
               TEXT("    /s:bootfile=<#>         Looks for files that reside on bootdisk # - * for any bootdisk\n")
               TEXT("    /s:compress=<yes/no>    Looks for files that match the compression flag. Default is Yes.\n")
               TEXT("    /s:targetname=<name>    Looks for files are renamed to \"name\" on copy\n\n")
               TEXT("    /s:size{EQ/LT/GT}<value>    Looks for files that satisfy the size condition specified (<= or >= not supported)\n")
               TEXT("                EQ#   - Equal to (No Space around operator)\n")
               TEXT("                LT#   - Lesser than (No Space around operator)\n")
               TEXT("                GT#   - Greater than (No Space around operator)\n")
               TEXT("/d:<display type> - The display format for files that match\n" )
               TEXT("   /d:default   - Display standard fields - no media tag info\n" )
               TEXT("   /d:fileonly  - Display filename only\n" )
               TEXT("   /d:all       - Display standard fields + media tag info\n" )
               TEXT("\n")
               , argv[0] );
        Result = 1;
        goto cleanup;
    }

    if( !ProcessCommandLine( argc, argv ) ) {
        Result = 0;
        goto cleanup;
    }

    _ftprintf( stderr, TEXT("\nParsing Layout file...wait...\n"));
    LayoutContext = BuildLayoutInfContext( GlobalQuerySet.LayoutFileName, LAYOUTPLATFORMS_ALL, 0);
    if( !LayoutContext ){
        _ftprintf(stderr,TEXT("\nError - Could not build Layout Inf context\n"));
        Result = -1;
        goto cleanup;
    }

    if( argc < 3 ){
        //DoMenu( LayoutContext );
        Result = 0;
        goto cleanup;
    }

    EnumerateLayoutInf( LayoutContext, MyCallback, (DWORD_PTR)&GlobalQuerySet );

    CloseLayoutInfContext( LayoutContext );

    Result = 0;

cleanup:

    pSetupUninitializeUtils();

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\escpeinf\escpeinf.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    escpeinf.c

Abstract:

    This module filters an inf for use by the ESCAPE tool. Default file
    security can be set in the inx file using wildcard rules, and this
    program expands them, creating a valid file for ESCAPE. This is
    necessary because ESCAPE does not support wildcards in the file section

    See below for more information.

    Note: ESCAPE was the proposed name of the Security Configuration Engine when this
          was written, but that name too was dropped. They still haven't come up with
          a good name for it.

Author:

    Sandy Coyne (scoyne) February 29, 2000

Revision History:

--*/


/*
    Usage: escpeinf.exe <U|C> <codepage> <input file> <output file> <layout.inf>

    Parameter info is printed when you run the program without all the right arguments

    layout.inf is the system-wide layout.inf, already built for the local
    language, arch., etc.

    The input file to this program consists of an inf, already sent through
    the filters for architecture, language and product. This inf is an input
    file for ESCAPE, with one exception: In the [File Security] section, some
    entries may have wildcards for filenames. Following those lines, if
    desired, is a list of files that should be excluded from matching that
    wildcard. This list is in the form of exception lines.
    Example:
            [File Security]
            "%SystemDirectory%\*",2,"D:P(A;;GRGX;;;BU)(A;;GRGX;;;PU)(A;;GA;;;BA)(A;;GA;;;SY)"
            Exception="*.ini"
            Exception="config.nt"
    This wildcard line will be replaced with an enumeration of all matching files
    that are copied by text-mode setup, as specified by the listing in layout.inf

*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <string.h>
#include <locale.h>
#include <mbctype.h>
#include <inflib.h>
#include <sputils.h>

#include <wild.c>



// Define program result codes (returned from main()).
#define SUCCESS 0
#define FAILURE 1

#define MAX_INF_LINE_LENGTH 260
#define MAX_EXCEPTIONS 256

#define ESCPEINF_VERSION "1.6"

//#define ESCPEINF_DEBUG


enum {
    UPGRADE,
    CLEAN_INSTALL
    } GlobalMode;

typedef struct _EXCEPTIONS {
    TCHAR s[MAX_INF_LINE_LENGTH];
    } EXCEPTIONS;

typedef struct _MYPARAM {
    FILE        *OutputFile;
    EXCEPTIONS  *ExceptionList;
    DWORD       Num;
    PTSTR       WildCard,
                RealPath,
                LayoutPath,
                SecurityString;
    }  MYPARAM, *PMYPARAM;

BOOL ProcessFileSecuritySection(FILE *InputFile, FILE *OutputFile,
                                PLAYOUT_CONTEXT LayoutContexta);
BOOL GetFields(PTSTR InfLine, PTSTR FileName, DWORD *Num, PTSTR SecurityString);
void ExpandWildCard(PTSTR FileName, DWORD Num, PTSTR SecurityString,
                    EXCEPTIONS ExceptionList[], FILE *OutputFile,
                    PLAYOUT_CONTEXT LayoutContext);
void FindExceptions(FILE *InputFile, EXCEPTIONS ExceptionList[]);

void PrintUsage(LPTSTR FileName)
    {
    _ftprintf(stderr, TEXT("ESCAPE Inf file pre-processor, version %s\n"),
              TEXT(ESCPEINF_VERSION));
    _ftprintf(stderr, TEXT("\tFor Microsoft internal use only. "));
    _ftprintf(stderr, TEXT("Contact Sandy Coyne with questions.\n"));
    _ftprintf(stderr,
        TEXT("Usage: %s <U|C> <codepage> <input file> <output file> <layout.inf>\n"),
        FileName);
    _ftprintf(stderr, TEXT("\tU = Upgrade\n"));
    _ftprintf(stderr, TEXT("\tC = Clean Install\n"));
    _ftprintf(stderr, 
        TEXT("\t<codepage> specifies the codepage to use when accessing input and\n"));
    _ftprintf(stderr, 
        TEXT("\t\toutput files. Translation of layout.inf is not affected by\n"));
    _ftprintf(stderr, 
        TEXT("\t\tthis option. You may specify \"none\" to open the input\n"));
    _ftprintf(stderr, 
        TEXT("\t\tand output files as Unicode files with no codepage translation.\n"));
    _ftprintf(stderr, TEXT("\tAll fields are required.\n"));
    }


int __cdecl _tmain(IN int argc, IN LPTSTR argv[])
    {
    FILE    *InputFile,
            *OutputFile;
    LPTSTR  LocaleString;
    TCHAR   InfLine[MAX_INF_LINE_LENGTH],
            CodePage[10];
    PLAYOUT_CONTEXT LayoutContext;
    BOOL    fUnicodeIO;
    int     result = FAILURE;

    if(!pSetupInitializeUtils()) {
        _ftprintf(stderr, TEXT("Initialize failed\n"));
        return FAILURE;
    }

    // Print Usage information
    if (argc != 6)
        {
        PrintUsage(argv[0]);
        goto fail;
        }

    if (_tcsicmp(argv[1], TEXT("U")) == 0)
        {
        GlobalMode = UPGRADE;
        }
    else if (_tcsicmp(argv[1], TEXT("C")) == 0)
        {
        GlobalMode = CLEAN_INSTALL;
        }
    else
        {
        PrintUsage(argv[0]);
        goto fail;
        }

    if (_tcsicmp(argv[2], TEXT("None")) == 0)
        {
        fUnicodeIO = TRUE;
        #ifdef ESCPEINF_DEBUG
        _ftprintf(stderr, TEXT("Using Unicode I/O\n"));
        #endif
        }
    else
        {
        _stprintf(CodePage, TEXT(".%.7s"), argv[2]);
        LocaleString = _tsetlocale(LC_ALL, CodePage);
        if (LocaleString == NULL)
            {
            _ftprintf(stderr, TEXT("Invalid CodePage: \"%s\"\n"), argv[2]);
            #ifdef ESCPEINF_DEBUG
            _ftprintf(stderr, TEXT("Invalid argument to setlocale: \"%s\"\n"), CodePage);
            #endif
            goto fail;
            }
        else
            {
            #ifdef ESCPEINF_DEBUG
            _ftprintf(stderr, TEXT("Locale set to: \"%s\"\n"), LocaleString);
            #endif
            fUnicodeIO = FALSE;
            }
        }

    // Begin to Open Input, Output and Layout files
    if (fUnicodeIO)
        {
        InputFile = _tfopen(argv[3], TEXT("rb"));
        }
    else
        {
        InputFile = _tfopen(argv[3], TEXT("rt"));
        }

    if (InputFile == NULL)
        {
        _ftprintf(stderr, TEXT("Error opening Input file: %s\n"), argv[3]);
        goto fail;
        }
    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("Opened Input file: %s\n"), argv[3]);
    #endif
    rewind(InputFile);

    if (fUnicodeIO)
        {
        OutputFile = _tfopen(argv[4], TEXT("wb"));
        }
    else
        {
        OutputFile = _tfopen(argv[4], TEXT("wt"));
        }

    if (OutputFile == NULL)
        {
        _ftprintf(stderr, TEXT("Error opening Output file: %s\n"), argv[4]);
        fclose(InputFile);
        goto fail;
        }
    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("Opened Output file: %s\n"), argv[4]);
    #endif

    LayoutContext = BuildLayoutInfContext(argv[5], LAYOUTPLATFORMS_ALL, 0);
    if (LayoutContext == NULL)
        {
        _ftprintf(stderr, TEXT("Error opening Layout file: %s\n"), argv[5]);
        _ftprintf(stderr, TEXT("Did you remember to specify a path to the file\n"));
        fclose(InputFile); fclose(OutputFile);
        goto fail;
        }
    else
        {
        #ifdef ESCPEINF_DEBUG
        _ftprintf(stderr, TEXT("Opened Layout file: %s\n"), argv[5]);
        #endif
        }
    // Input, Output and Layout files are open

    while ((_fgetts(InfLine, MAX_INF_LINE_LENGTH, InputFile)) != NULL)
        {
        _fputts(InfLine, OutputFile);
        if (!_tcscmp(InfLine, TEXT("[File Security]\n")))
            if (!ProcessFileSecuritySection(InputFile, OutputFile,
                                            LayoutContext))
                {
                // If this happens, ProcessFileSecuritySection() has already
                // printed an error.
                fclose(InputFile); fclose(OutputFile);
                CloseLayoutInfContext(LayoutContext);
                goto fail;
                }
        }
    if (!feof(InputFile))
        {
        _ftprintf(stderr, TEXT("Error: Did not reach Input EOF.\n"));
        fclose(InputFile); fclose(OutputFile); 
        CloseLayoutInfContext(LayoutContext);
        goto fail;
        }
    fclose(InputFile);
    fclose(OutputFile);
    CloseLayoutInfContext(LayoutContext);
    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("escpeinf.exe completed successfully\n"));
    #endif

    result = SUCCESS;

fail:

    pSetupUninitializeUtils();
    return result;
    }


BOOL CALLBACK MyCallback(IN PLAYOUT_CONTEXT Context,
                         IN PCTSTR FileName,
                         IN PFILE_LAYOUTINFORMATION LayoutInformation,
                         IN PVOID ExtraData,
                         IN UINT ExtraDataSize,
                         IN OUT DWORD_PTR vpParam)
    {
    static PMYPARAM Param;
    static BOOL     fIsException = FALSE;
    static int      i = 0;
    static TCHAR    FileName_l[MAX_PATH],
                    TargetFileName_l[MAX_PATH];

    i = 0;
    fIsException = FALSE;

    if (vpParam)
        Param = (PMYPARAM)vpParam;

    // Quit now if we don't need to worry about this file at all.
    if ((GlobalMode == UPGRADE) &&
        (LayoutInformation->UpgradeDisposition == 3))
        return TRUE;
    if ((GlobalMode == CLEAN_INSTALL) &&
        (LayoutInformation->CleanInstallDisposition == 3))
        return TRUE;

    // Quit now if the names are too long to be processed.
    // This should never happen with layout.inf
    if ((_tcslen(FileName) >= MAX_PATH) ||
        (_tcslen(LayoutInformation->TargetFileName) >= MAX_PATH))
        return TRUE;

    // Make a local copy for lowercasing:
    _tcsncpy(FileName_l, FileName, MAX_PATH);
    _tcsncpy(TargetFileName_l, LayoutInformation->TargetFileName, MAX_PATH);

    // Just to be safe:
    FileName_l[MAX_PATH-1] = TEXT('\0');
    TargetFileName_l[MAX_PATH-1] = TEXT('\0');

    // Since wildcard compares are case sensitive, I lowercase everything
    // before comparing. Wildcard compares happen between the two filename
    // variables modified here, WildCard, and ExceptionList. WildCard and
    // ExceptionList were previouslt lowercased.
    _tcslwr(FileName_l);
    _tcslwr(TargetFileName_l);

    if (_tcslen(TargetFileName_l) > 0) // Do we use the long name?
        {
        if (_tcsicmp(Param->LayoutPath, LayoutInformation->Directory) == 0)
            { // Then it's a file in the right directory
            if (IsNameInExpressionPrivate(Param->WildCard, TargetFileName_l))
                { // Then it matches our wildcard
                while ((_tcslen(Param->ExceptionList[i].s) > 0) && !fIsException)
                    { // Checking to see if it's an exception...
                    if (IsNameInExpressionPrivate(Param->ExceptionList[i].s,
                                                  TargetFileName_l))
                        {
                        fIsException = TRUE; // This must be initialized FALSE
                        }
                    i += 1;
                    }
                if (!fIsException)
                    { // Then we actually want to put it in our output
                    #ifdef ESCPEINF_DEBUG
                    _ftprintf(stderr, TEXT("Match: %s(%s) in %s\n"),
                              FileName, LayoutInformation->TargetFileName,
                              LayoutInformation->Directory);
                    #endif
                    _ftprintf(Param->OutputFile, TEXT("\"%s\\%s\",%d,%s\n"),
                              Param->RealPath,
                              LayoutInformation->TargetFileName, Param->Num,
                              Param->SecurityString);
                    }
                }
            }
        }
    else // We use the short name
        {
        if (_tcsicmp(Param->LayoutPath, LayoutInformation->Directory) == 0)
            { // Then it's a file in the right directory
            if (IsNameInExpressionPrivate(Param->WildCard, FileName_l))
                { // Then it matches our wildcard
                while ((_tcslen(Param->ExceptionList[i].s) > 0) && !fIsException)
                    { // Checking to see if it's an exception...
                    if (IsNameInExpressionPrivate(Param->ExceptionList[i].s,
                                                  FileName_l))
                        {
                        fIsException = TRUE; // This must be initialized FALSE
                        }
                    i += 1;
                    }
                if (!fIsException)
                    { // Then we actually want to put it in our output
                    #ifdef ESCPEINF_DEBUG
                    _ftprintf(stderr, TEXT("Match: %s in %s\n"),
                              FileName, LayoutInformation->Directory);
                    #endif
                    _ftprintf(Param->OutputFile, TEXT("\"%s\\%s\",%d,%s\n"),
                              Param->RealPath, FileName, Param->Num,
                              Param->SecurityString);
                    }
                }
            }
        }

    return TRUE;
    }


BOOL ProcessFileSecuritySection(FILE *InputFile, FILE *OutputFile,
                                PLAYOUT_CONTEXT LayoutContext)
    {
    TCHAR   InfLine[MAX_INF_LINE_LENGTH],
            FileName[MAX_INF_LINE_LENGTH],
            SecurityString[MAX_INF_LINE_LENGTH];
    BOOL    fValidFields;
    DWORD   Num;
    int     i;

    EXCEPTIONS      ExceptionList[MAX_EXCEPTIONS];


    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("Found [File Security] section.\n"));
    #endif

    while ((_fgetts(InfLine, MAX_INF_LINE_LENGTH, InputFile)) != NULL)
        {
        if (GetFields(InfLine, FileName, &Num, SecurityString) &&
            DoesNameContainWildCards(FileName))
            { // We found a line containing proper formatting and a wildcard
              // in the filename
            #ifdef ESCPEINF_DEBUG
            _ftprintf(stderr, TEXT("Wildcard line: %s"), InfLine);
            #endif
            // First find the exceptions to the wildcard
            FindExceptions(InputFile, ExceptionList);
            ExpandWildCard(FileName, Num, SecurityString, ExceptionList,
                           OutputFile, LayoutContext);
            }
        else
            {
            _fputts(InfLine, OutputFile);
            if (_tcsncmp(InfLine, TEXT("["), 1) == 0)
                {
                #ifdef ESCPEINF_DEBUG
                _ftprintf(stderr, TEXT("End of File Security section.\n"));
                #endif
                return TRUE;
                }
            }
        }

    return TRUE; // No Error
    }



// GetFields assumes the input line is in this format:
//      "filename",number,"securitystring"\n
// It extracts the filename and stores it in FileName. The quotes are removed
// from filename. It extracts and stores the number and security string if
// the filename is found. Quotes are not stripped from the security string.
// On error, it sets FileName to zero length, and returns FALSE.
BOOL GetFields(PTSTR InfLine, PTSTR FileName, DWORD *Num, PTSTR SecurityString)
    {
    int i = 0; // Pointer to current location in FileName

    // Leave now if the line does not contain a filename
    if ((InfLine[0] == (TCHAR)'[')  ||
        (InfLine[0] == (TCHAR)'\n') ||
        (InfLine[0] == (TCHAR)';'))
        {
        FileName[0] = (TCHAR)'\0'; // Set the end-of-string NULL marker to clear the string
        return FALSE;
        }

    // Check if line starts with a quotation mark
    if (InfLine[0] == (TCHAR)'\"')
        {
        // Copy everything until the next quotation mark
        while ((InfLine[i+1] != (TCHAR)'\"') && (InfLine[i+1] != (TCHAR)'\0'))
            {
            FileName[i] = InfLine[i+1];
            i += 1;
            }
        FileName[i] = (TCHAR)'\0'; // Set the end-of-string NULL marker
        i += 1; //  So we can use i without the +1 to access InfLine from now on
        }
    else // if the filename is not in quotes
        {
        FileName[0] = (TCHAR)'\0'; // Set the end-of-string NULL marker to clear the string
        return FALSE;
        }

    // It is posible that we left the above while loop because of premature end-of-line condtion.
    // If this is the case, clear the filename string and return.
    if (InfLine[i] == (TCHAR)'\0')
        {
        #ifdef ESCPEINF_DEBUG
        _ftprintf(stderr, TEXT("Reached End-of-Line without finding a filename\n"));
        _ftprintf(stderr, TEXT("Problem line is <%s>\n"), InfLine);
        _ftprintf(stderr, TEXT("Problem filename is <%s>\n"), FileName);
        #endif
        FileName[0] = (TCHAR)'\0'; // Set the end-of-string NULL marker to clear the string
        return FALSE;
        }
    else i++;   // Once we know that we aren't at the end-of-string, we can do this safely.
                // Now, however, we may be pointing to a zero-length string.

    if (_tcslen(FileName) <= 3)
        {
        #ifdef ESCPEINF_DEBUG
        _ftprintf(stderr, TEXT("Unexpected Result: Filename \"%s\" is only %d characters.\n"), FileName, i);
        #endif
        return FALSE;
        }

    #ifdef ESCPEINF_DEBUG
    //_ftprintf(stderr, TEXT("Found filename : %s\n"), FileName);
    #endif

    // Read the other two fields. If we got this far, we must have found a valid filename,
    // so we just assume that the other two are there.
    if (_stscanf(&InfLine[i], TEXT(",%ld,%s"), Num, SecurityString) != 2)
        { // then there was an error
        #ifdef ESCPEINF_DEBUG
        _ftprintf(stderr, TEXT("Error reading Num and Security String from line.\n"));
        _ftprintf(stderr, TEXT("Problem line is: %s\n"), &InfLine[i]);
        #endif
        FileName[0] = (TCHAR)'\0'; // Set the end-of-string NULL marker to clear the string
        return FALSE;
        }

    #ifdef ESCPEINF_DEBUG
    //_ftprintf(stderr, TEXT("Found rest of line : %lu,%s\n"), *Num, SecurityString);
    #endif

    return TRUE;
    }


void ExpandWildCard(PTSTR FileName, DWORD Num, PTSTR SecurityString,
                    EXCEPTIONS ExceptionList[], FILE *OutputFile,
                    PLAYOUT_CONTEXT LayoutContext)
    {
    MYPARAM Param;
    int     PathPos = 0;
    int     NamePos = 0;
    int     LastSlash = 0;
    TCHAR   WildCard[MAX_INF_LINE_LENGTH],
            RealPath[MAX_INF_LINE_LENGTH],
            LayoutPath[MAX_INF_LINE_LENGTH];

    if (_tcslen(FileName) >= MAX_INF_LINE_LENGTH)
        return; // This should never happen, but we're being safe.

    while (FileName[NamePos] != (TCHAR)'\0')
        {
        if (FileName[NamePos] == (TCHAR)'\\')
            {
            LastSlash = NamePos;
            }
        NamePos += 1;
        }

    if (NamePos == (LastSlash + 1))
        return; // What? No filename? This should never happen.

    _tcsncpy(RealPath, FileName, LastSlash);
    RealPath[LastSlash] = (TCHAR)'\0';
    _tcscpy(WildCard, &FileName[LastSlash + 1]);
    _tcslwr(WildCard);

    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("Looking up Wildcard: %s\nin: %s\n"),
              WildCard, RealPath);
    #endif


    if (_tcsnicmp(RealPath, TEXT("%SystemDirectory%"), 17) == 0)
        {
        _tcscpy(LayoutPath, TEXT("System32"));
        _tcscpy(&LayoutPath[8], &RealPath[17]);
        }
    else if (_tcsnicmp(RealPath, TEXT("%SystemDir%"), 11) == 0)
        {
        _tcscpy(LayoutPath, TEXT("System32"));
        _tcscpy(&LayoutPath[8], &RealPath[11]);
        }
    else if (_tcsnicmp(RealPath, TEXT("%SystemRoot%"), 12) == 0)
        {
        if (LastSlash == 12)
            _tcscpy(LayoutPath, TEXT("\\"));
        else
            _tcscpy(LayoutPath, &RealPath[13]);
        }
    else
        {
        _ftprintf(stderr, TEXT("Path is unlikely to be in Layout.inf: %s\n"),
                  RealPath);
        _tcscpy(LayoutPath, RealPath);
        }

    #ifdef ESCPEINF_DEBUG
    _ftprintf(stderr, TEXT("Path in Layout.inf terms is: %s\n"), LayoutPath);
    #endif

    Param.OutputFile    = OutputFile;
    Param.ExceptionList = ExceptionList;
    Param.Num           = Num;
    Param.WildCard      = WildCard;
    Param.RealPath      = RealPath,
    Param.LayoutPath    = LayoutPath;
    Param.SecurityString= SecurityString;

    EnumerateLayoutInf(LayoutContext, MyCallback, (DWORD_PTR)&Param);

    return;
    }


void FindExceptions(FILE *InputFile, EXCEPTIONS ExceptionList[])
    {
    long    FilePosition;
    int     NumExceptions = 0,
            i;
    TCHAR   InfLine[MAX_INF_LINE_LENGTH];

    do
        {
        i = 0;
        FilePosition = ftell(InputFile); // Save file pointer
        if (_fgetts(InfLine, MAX_INF_LINE_LENGTH, InputFile) != NULL)
            {
            if ((_tcsnicmp(InfLine, TEXT("Exception=\""),  11) == 0) ||
                (_tcsnicmp(InfLine, TEXT("Exception:\""),  11) == 0))
                {
                while ((InfLine[i+11] != (TCHAR)'\"') &&
                    (InfLine[i+11] != (TCHAR)'\0'))
                    {
                    ExceptionList[NumExceptions].s[i] = InfLine[i+11];
                    i += 1;
                    }
                ExceptionList[NumExceptions].s[i] = (TCHAR)'\0';
                _tcslwr(ExceptionList[NumExceptions].s);

                #ifdef ESCPEINF_DEBUG
                _ftprintf(stderr, TEXT("Exception found: %s\n"),
                        ExceptionList[NumExceptions].s);
                #endif

                if (InfLine[i+11] == (TCHAR)'\0')
                    { // then we hit end of line without closing our quotes
                    _ftprintf(stderr, TEXT("Warning: Invalid Exception line.\n"));
                    _ftprintf(stderr, TEXT("Problem line is: %s\n"), InfLine);
                    }
                else NumExceptions += 1;
                }
            }
        }
    while ((i > 0) && (NumExceptions < (MAX_EXCEPTIONS - 1)));

    ExceptionList[NumExceptions].s[0] = (TCHAR)'\0';

    if (i != 0)
        { // then we hit our exceptions limit.
        _ftprintf(stderr, TEXT("Too many exceptions listed in source file! "));
        _ftprintf(stderr, TEXT("Destination file may be corrupt!\n"));
        }
    else if (fseek(InputFile, FilePosition, SEEK_SET) != 0) // Restore file pointer
        {
        _ftprintf(stderr, TEXT("Warning: Cannot seek within INF file! "));
        _ftprintf(stderr, TEXT("One line may be lost!\n"));
        }
    // File pointer now points to the first line that is not an Exception line.

    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\inc\wild.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wild.c

Abstract:

    This module implements functions to process wildcard specifiers.

Author:

    Vijesh

Revision History:

--*/





//
//  These following bit values are set in the FsRtlLegalDbcsCharacterArray
//

#define FSRTL_FAT_LEGAL         0x01
#define FSRTL_HPFS_LEGAL        0x02
#define FSRTL_NTFS_LEGAL        0x04
#define FSRTL_WILD_CHARACTER    0x08
#define FSRTL_OLE_LEGAL         0x10
#define FSRTL_NTFS_STREAM_LEGAL (FSRTL_NTFS_LEGAL | FSRTL_OLE_LEGAL)


//
//  The global static legal ANSI character array.  Wild characters
//  are not considered legal, they should be checked seperately if
//  allowed.
//


#define _FAT_  FSRTL_FAT_LEGAL
#define _HPFS_ FSRTL_HPFS_LEGAL
#define _NTFS_ FSRTL_NTFS_LEGAL
#define _OLE_  FSRTL_OLE_LEGAL
#define _WILD_ FSRTL_WILD_CHARACTER

static const UCHAR LocalLegalAnsiCharacterArray[128] = {

    0                                   ,   // 0x00 ^@
                                   _OLE_,   // 0x01 ^A
                                   _OLE_,   // 0x02 ^B
                                   _OLE_,   // 0x03 ^C
                                   _OLE_,   // 0x04 ^D
                                   _OLE_,   // 0x05 ^E
                                   _OLE_,   // 0x06 ^F
                                   _OLE_,   // 0x07 ^G
                                   _OLE_,   // 0x08 ^H
                                   _OLE_,   // 0x09 ^I
                                   _OLE_,   // 0x0A ^J
                                   _OLE_,   // 0x0B ^K
                                   _OLE_,   // 0x0C ^L
                                   _OLE_,   // 0x0D ^M
                                   _OLE_,   // 0x0E ^N
                                   _OLE_,   // 0x0F ^O
                                   _OLE_,   // 0x10 ^P
                                   _OLE_,   // 0x11 ^Q
                                   _OLE_,   // 0x12 ^R
                                   _OLE_,   // 0x13 ^S
                                   _OLE_,   // 0x14 ^T
                                   _OLE_,   // 0x15 ^U
                                   _OLE_,   // 0x16 ^V
                                   _OLE_,   // 0x17 ^W
                                   _OLE_,   // 0x18 ^X
                                   _OLE_,   // 0x19 ^Y
                                   _OLE_,   // 0x1A ^Z
                                   _OLE_,   // 0x1B ESC
                                   _OLE_,   // 0x1C FS
                                   _OLE_,   // 0x1D GS
                                   _OLE_,   // 0x1E RS
                                   _OLE_,   // 0x1F US
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x20 space
    _FAT_ | _HPFS_ | _NTFS_              ,  // 0x21 !
                            _WILD_| _OLE_,  // 0x22 "
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x23 #
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x24 $
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x25 %
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x26 &
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x27 '
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x28 (
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x29 )
                            _WILD_| _OLE_,  // 0x2A *
            _HPFS_ | _NTFS_       | _OLE_,  // 0x2B +
            _HPFS_ | _NTFS_       | _OLE_,  // 0x2C ,
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x2D -
    _FAT_ | _HPFS_ | _NTFS_              ,  // 0x2E .
    0                                    ,  // 0x2F /
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x30 0
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x31 1
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x32 2
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x33 3
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x34 4
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x35 5
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x36 6
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x37 7
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x38 8
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x39 9
                     _NTFS_              ,  // 0x3A :
            _HPFS_ | _NTFS_       | _OLE_,  // 0x3B ;
                            _WILD_| _OLE_,  // 0x3C <
            _HPFS_ | _NTFS_       | _OLE_,  // 0x3D =
                            _WILD_| _OLE_,  // 0x3E >
                            _WILD_| _OLE_,  // 0x3F ?
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x40 @
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x41 A
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x42 B
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x43 C
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x44 D
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x45 E
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x46 F
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x47 G
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x48 H
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x49 I
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4A J
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4B K
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4C L
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4D M
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4E N
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4F O
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x50 P
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x51 Q
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x52 R
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x53 S
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x54 T
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x55 U
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x56 V
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x57 W
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x58 X
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x59 Y
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5A Z
            _HPFS_ | _NTFS_       | _OLE_,  // 0x5B [
    0                                    ,  // 0x5C backslash
            _HPFS_ | _NTFS_       | _OLE_,  // 0x5D ]
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5E ^
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5F _
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x60 `
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x61 a
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x62 b
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x63 c
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x64 d
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x65 e
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x66 f
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x67 g
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x68 h
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x69 i
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6A j
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6B k
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6C l
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6D m
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6E n
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6F o
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x70 p
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x71 q
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x72 r
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x73 s
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x74 t
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x75 u
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x76 v
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x77 w
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x78 x
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x79 y
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7A z
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7B {
    0                             | _OLE_,  // 0x7C |
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7D }
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7E ~
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7F 
};

UCHAR const* const FsRtlLegalAnsiCharacterArray = &LocalLegalAnsiCharacterArray[0];

#define LEGAL_ANSI_CHARACTER_ARRAY        (FsRtlLegalAnsiCharacterArray)

#define  mQueryBits(uFlags, uBits)      ((uFlags) & (uBits))
#define FlagOn(uFlags, uBit)    (mQueryBits(uFlags, uBit) != 0)
#define IsUnicodeCharacterWild(C) (                                \
      (((C) >= 0x40) ? FALSE : FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)], \
                                       FSRTL_WILD_CHARACTER ) )         \
)

typedef struct _UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR  Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;


#define DOS_STAR        TEXT('<')
#define DOS_QM          TEXT('>')
#define DOS_DOT         TEXT('"')


BOOLEAN
DoesNameContainWildCards (
    IN PTSTR Name
    )

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOLEAN - TRUE if one or more wild card characters was found.

--*/
{
    PTCHAR p;

    
    //
    //  Check each character in the name to see if it's a wildcard
    //  character.
    //

    if( lstrlen(Name) ) {
        for( p = Name + lstrlen(Name) - 1;
             p >= Name && *p != TEXT('\\') ;
             p-- ) {

            //
            //  check for a wild card character
            //

            if (IsUnicodeCharacterWild( *p )) {

                //
                //  Tell caller that this name contains wild cards
                //

                return TRUE;
            }
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return FALSE;
}



BOOLEAN
IsNameInExpressionPrivate (
    IN PCTSTR Expression,
    IN PCTSTR Name
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive TRUE.)

    Name - Supplies the input name to check for.

    CaseInsensitive - TRUE if Name should be Upcased before comparing.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    TCHAR NameChar, ExprChar;

    USHORT LocalBuffer[16 * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    ULONG NameLen, ExpressionLen;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    NameLen = lstrlen(Name)*sizeof(TCHAR);
    ExpressionLen = lstrlen(Expression)*sizeof(TCHAR);

    
    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (NameLen == 0) || (ExpressionLen == 0) ) {

        return (BOOLEAN)(!(NameLen + ExpressionLen));
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((ExpressionLen == 2) && (Expression[0] == TEXT('*'))) {

        return TRUE;
    }

    
    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression[0] == TEXT('*')) {

        TCHAR LocalExpression[MAX_PATH];
        ULONG LocalExpressionLen;

        lstrcpy( LocalExpression, Expression+1);
        LocalExpressionLen = lstrlen( LocalExpression )*sizeof(TCHAR);

        
        //
        //  Only special case an expression with a single *
        //

        if ( !DoesNameContainWildCards( LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (NameLen < (USHORT)(ExpressionLen-sizeof(TCHAR))) {

                return FALSE;
            }

            StartingNameOffset = ( NameLen -
                                   LocalExpressionLen )/sizeof(TCHAR);

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

        

            return (BOOLEAN) RtlEqualMemory( LocalExpression,
                                             Name + StartingNameOffset,
                                             LocalExpressionLen );

        
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[16];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(ExpressionLen * 2);

    while ( !NameFinished ) {

        if ( NameOffset < NameLen ) {

            NameChar = Name[NameOffset / sizeof(TCHAR)];

            NameOffset += sizeof(TCHAR);;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( TRUE ) {

                if ( ExprOffset == ExpressionLen ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset += Length;
                Length = sizeof(TCHAR);

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == ExpressionLen ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression[ExprOffset / sizeof(TCHAR)];

        
                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= 16 - 2) &&
                     (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = ExpressionLen / sizeof(TCHAR);

                    AuxBuffer = malloc( (ExpressionChars+1) * sizeof(USHORT)*2*2 );

                    RtlCopyMemory( AuxBuffer,
                                   CurrentMatches,
                                   16 * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    RtlCopyMemory( AuxBuffer + (ExpressionChars+1)*2,
                                   PreviousMatches,
                                   16 * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == TEXT('*')) {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 3;
                    continue;
                }

                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == DOS_STAR) {

                    BOOLEAN ICanEatADot = FALSE;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == TEXT('.')) ) {

                        USHORT Offset;

                        for ( Offset = NameOffset;
                              Offset < NameLen;
                              Offset += Length ) {

                            if (Name[Offset / sizeof(TCHAR)] == TEXT('.')) {

                                ICanEatADot = TRUE;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != TEXT('.')) || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;
                    }
                }

                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(TCHAR) * 2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == DOS_QM ) {

                    if ( NameFinished || (NameChar == TEXT('.')) ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == TEXT('.')) {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == TEXT('?')) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == (TCHAR)(NameChar)) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            if ((SrcCount < MatchesCount) &&
                (PreviousDestCount < DestCount) ) {

                while (PreviousDestCount < DestCount) {

                    while ( PreviousMatches[SrcCount] <
                         CurrentMatches[PreviousDestCount] ) {

                        SrcCount += 1;
                    }

                    PreviousDestCount += 1;
                }
            }
        }

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) { free( AuxBuffer ); }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { free( AuxBuffer ); }


    return (BOOLEAN)(CurrentState == MaxState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\inflib\inflib.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    inflib.c

Abstract:

    Source for inflib.lib that implements functions designed to build a
    layout context given a layout INF file. This sets up an infrastructure
    to build tools that will need to reference a layout inf file.

Author:

    Vijesh Shetty (vijeshs)

Revision History:

--*/

#include <stdio.h>
#include <windows.h>
#include <conio.h>
#include <process.h>
#include <tchar.h>
#include <objbase.h>
#include <io.h>
#include <setupapi.h>
#include <sputils.h>
#include <inflib.h>
#include <string.h>

//#define DEBUG 1

#define LAYOUT_DIR_SECTION TEXT("WinntDirectories")
#define MAX_TEMP 500

//Structure to pass parameters to the enumeration callback

typedef struct _CALLBACK_PACKAGE{

    PLAYOUT_CONTEXT Context;
    PLAYOUTENUMCALLBACK Callback;
    DWORD_PTR Param;


}CALLBACK_PACKAGE, *PCALLBACK_PACKAGE;


//Structure to pass parameters to the enumeration callback

typedef struct _WINNT_DIRCODES{

    TCHAR Dir[MAX_PATH];


}WINNT_DIRCODES, *PWINNT_DIRCODES;


#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(NULL,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    OutputDebugStringA(Msg);

    i = MessageBoxA(
                NULL,
                Msg,
                p,
                MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
                );

    if(i == IDYES) {
        DebugBreak();
    }
}

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

#else

#define MYASSERT( exp )

#endif // DBG



BOOL
InternalEnumRoutine(
    IN PVOID StringTable,
    IN LONG StringId,
    IN PCTSTR String,
    IN PFILE_LAYOUTINFORMATION LayoutInfo,
    IN UINT LayoutInfoSize,
    IN LPARAM Param
    );


BOOL ValidateTextmodeDirCodesSection( 
    PCTSTR LayoutFile, 
    PCTSTR WinntdirSection 
    )
/*
    Routine to validate the [WinntDirectories] section for a setup layout INF. This checks for errors that maybe encountered
    when people add/remove stuff from this section.
    
    Arguments:
    
    LayoutInf       - Name of setup layout INF that contains the specified section
    
    WinntdirSection - Section that contains dir codes
        
        Checks - 
            1) Looks for duplicate or reused dir codes
            
    Return value: 
        TRUE - Validation succeeded
        FALSE- Validation failed     
*/
{

    //OPen up the layout file.

    HINF LayoutInf;
    PVOID StringTable=NULL;
    INFCONTEXT LineContext;
    WINNT_DIRCODES WinntDirs, Buffer;
    BOOL ret = TRUE;
    LONG StrID, Size;
    TCHAR DirCode[4];
    
    LayoutInf = SetupOpenInfFile( LayoutFile, NULL, INF_STYLE_WIN4 | INF_STYLE_CACHE_ENABLE, NULL);

    if( !LayoutInf || (LayoutInf == INVALID_HANDLE_VALUE)){
        _tprintf(TEXT("Error E0000 : Could not open %s\n"), LayoutFile);
        return FALSE;
    }

    //Grovel through the specified section and populate our WINNT_DIRCODES structure

    if( !SetupFindFirstLine(LayoutInf,WinntdirSection,NULL,&LineContext)){
        _tprintf(TEXT("%s : Error E0000 : Can't find section [%s]\n"), LayoutFile, WinntdirSection);
        return(FALSE);
    }
        



    // Create a stringtable for hashing of the SourceDisksNames section.

    if( (StringTable=pSetupStringTableInitializeEx( sizeof(WINNT_DIRCODES), 0 )) == NULL ){
        _tprintf(TEXT("%s : Error E0000 : Internal error processing [%s] section (1)\n"), LayoutFile, WinntdirSection);
        return(FALSE);
    }
    

    do{

        ZeroMemory( &WinntDirs, sizeof(WINNT_DIRCODES));

        if( SetupGetStringField( &LineContext, 0, NULL, 0, &Size) ){
    
    
                if( SetupGetStringField( &LineContext, 0, DirCode, Size, NULL )){
    
                    //
                    //  Add the Filename to the StringTable. Look for its presence so that the Count is updated
                    //

                    if(!SetupGetStringField( &LineContext, 1, WinntDirs.Dir, MAX_PATH, NULL)){
                        _tprintf(TEXT("%s : Error E0000 : Directory missing for Dir ID %s\n"), LayoutFile, DirCode);
                        ret = FALSE;
                        break;

                    }
                        
    
    
                    if( pSetupStringTableLookUpStringEx( StringTable,
                                       DirCode,
                                       STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                       &Buffer,
                                       sizeof(WINNT_DIRCODES)) != -1 ){

                        _tprintf(TEXT("%s : Error E0000 : Duplicate Dir ID found in [%s] section - Dir ID %s reused by %s, %s\n"), LayoutFile, WinntdirSection, DirCode, Buffer.Dir, WinntDirs.Dir);
                        
                    }
                    else{

                        StrID = pSetupStringTableAddString( StringTable, 
                                                            DirCode,
                                                            STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE);
                        
                        if( StrID == -1 ){
                           _tprintf(TEXT("%s : Error E0000 : Internal error processing [%s] section (2)\n"), LayoutFile, WinntdirSection);
                           ret = FALSE;
                           break;
                        }


                        if(!pSetupStringTableSetExtraData( StringTable, StrID, (PVOID)&WinntDirs, sizeof(WINNT_DIRCODES))){
                            _tprintf(TEXT("%s : Error E0000 : Internal error processing [%s] section (3)\n"), LayoutFile, WinntdirSection);
                            ret = FALSE;
                            break;
                        }

                    }
                        
                }else
                    _tprintf(TEXT("%s : Error E0000 : Internal error processing [%s] section (4)\n"), LayoutFile, WinntdirSection);

        }else
            _tprintf(TEXT("%s : Error E0000 : Internal error processing [%s] section (5)\n"), LayoutFile, WinntdirSection);
    }while(SetupFindNextLine(&LineContext, &LineContext));


    // If we are here and ret=TRUE that means we are done and have suceeded.

    if( StringTable )
        pSetupStringTableDestroy( StringTable );

    return ret;



}



DWORD
BuildMediaTagsInformation(
    IN HINF LayoutInf,
    IN LPCTSTR SectionName,
    IN PLAYOUT_CONTEXT LayoutContext,
    IN UINT Platform_Index)

/*
    Function to populate the stringtable given a handle to the inf and the name of the
    SourceDisksFiles Section.

    Arguments :

        LayoutInf - Handle to a layout file that has the SourceDisksNames Section

        SectionName - Name of the SourceDisksNames Section (this is so that we can specify decorated sections)

        LayoutContext - Layout Context that we want to build

        Platform_Index - Index in the MEDIA_INFO Array

*/
{
    DWORD Err = 0;
    INFCONTEXT LineContext;
    MEDIA_INFO Media_Info;
    TCHAR TempStr[500];
    LONG StrID;



    //Grovel through the specified section and populate our MEDIA_TAGS structure

    if( !SetupFindFirstLine(LayoutInf,SectionName,NULL,&LineContext))
        return(ERROR_NOT_ENOUGH_MEMORY);   //BUGBUG - Fix error code



    //StringTableSetConstants( 4096000, 4096000 );



    // Create a stringtable for hashing of the SourceDisksNames section.

    if( (LayoutContext->MediaInfo[Platform_Index]=pSetupStringTableInitializeEx( sizeof(MEDIA_INFO), 0 )) == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);   //BUGBUG - Fix error code


    // Now populate it

    do{

        ZeroMemory( &Media_Info, sizeof(MEDIA_INFO));


        if( SetupGetStringField( &LineContext, 0, TempStr, MAX_TEMP, NULL )){

            StrID = pSetupStringTableAddString( LayoutContext->MediaInfo[Platform_Index],
                                  TempStr,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE);

            if( StrID == -1 ){
               Err = ERROR_NOT_ENOUGH_MEMORY;
               _tprintf(TEXT("\nERROR-Could not add string to table\n"));
               break;
            }
        }else
            return( ERROR_NOT_ENOUGH_MEMORY ); //BUGBUG - Fix error code

        //_tprintf( TEXT("\nTagID - %s\n"), TempStr );


        if( SetupGetStringField( &LineContext, 1, TempStr, MAX_TEMP, NULL) )
            lstrcpy(Media_Info.MediaName, TempStr);

        if( SetupGetStringField( &LineContext, 2, TempStr, MAX_TEMP, NULL) )
            lstrcpy(Media_Info.TagFilename, TempStr);

        if( SetupGetStringField( &LineContext, 4, TempStr, MAX_TEMP, NULL) )
            lstrcpy(Media_Info.RootDir, TempStr);

        /*
        _tprintf( TEXT("\nMediaName - %s\n"), Media_Info.MediaName );
        _tprintf( TEXT("TagFilename - %s\n"), Media_Info.TagFilename );
        _tprintf( TEXT("RootDir - %s\n"), Media_Info.RootDir );
       */

        //
        // Now add the information to the string table.
        //

        if(!pSetupStringTableSetExtraData( LayoutContext->MediaInfo[Platform_Index], StrID, (PVOID)&Media_Info, sizeof(MEDIA_INFO))){

            Err = ERROR_NOT_ENOUGH_MEMORY; //BUGBUG - Fix error code
            _tprintf(TEXT("\nERROR-Could not set extra data for Media Info\n"));
            break;
        }



    }while(SetupFindNextLine(&LineContext, &LineContext));


    return Err;

}





DWORD
BuildStringTableForSection(
    IN HINF LayoutInf,
    IN LPCTSTR SectionName,
    IN PLAYOUT_CONTEXT LayoutContext,
    IN UINT Platform_Index)

/*
    Function to populate the stringtable given a handle to the inf and the name of the
    SourceDisksFiles Section.

    Arguments :

        LayoutInf - Handle to a layout file that has the SourceDisksFiles Section

        SectionName - Name of the SourceDisksFilesSection (this is so that we can specify decorated sections)

        LayoutContext - Layout Context that we want to build



*/
{
    DWORD Err = 0;
    INFCONTEXT LineContext, TempContext;
    DWORD Size;
    int Temp;
    LONG StrID;
    LPTSTR p;
    TCHAR TempString[MAX_PATH];
    FILE_LAYOUTINFORMATION FileInformation;
    TCHAR FileName[MAX_PATH];
    TCHAR Buffer[10];
    PVOID LookupBuffer=NULL;
    PFILE_LAYOUTINFORMATION Lookup;

#ifdef DEBUG

    int count=0;

#endif


    LookupBuffer = pSetupMalloc( LayoutContext->ExtraDataSize );
    if( !LookupBuffer ){
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }


    //Grovel through the specified section and populate our FILE_LAYOUTINFORMATION structure for each file

    if( !SetupFindFirstLine(LayoutInf,SectionName,NULL,&LineContext)){
        Err = ERROR_NOT_ENOUGH_MEMORY;   //BUGBUG - Fix error code
        goto cleanup;
    }



    do{

        ZeroMemory( &FileInformation, sizeof(FILE_LAYOUTINFORMATION));

        FileInformation.Compression = TRUE;

        if( SetupGetStringField( &LineContext, 0, NULL, 0, &Size) ){


            if( SetupGetStringField( &LineContext, 0, FileName, Size, NULL )){

                //
                //  Add the Filename to the StringTable. Look for its presence so that the Count is updated
                //


                if( pSetupStringTableLookUpStringEx( LayoutContext->Context,
                                   FileName,
                                   STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                   LookupBuffer,
                                   LayoutContext->ExtraDataSize) != -1 ){

                    Lookup = (PFILE_LAYOUTINFORMATION)(LookupBuffer);

                    // Check for same platform section

                    if( (Lookup->SectionIndex == Platform_Index) || (Lookup->SectionIndex == LAYOUTPLATFORMINDEX_COMMON))
                        FileInformation.Count = Lookup->Count + 1;

                }
                else
                    FileInformation.Count = 1;

                StrID = pSetupStringTableAddString( LayoutContext->Context,
                                      FileName,
                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE);

                if( StrID == -1 ){
                   Err = ERROR_NOT_ENOUGH_MEMORY;
                   _tprintf(TEXT("\nERROR-Could not add string to table\n"));
                   break;
                }



                //
                //  Now add the other related info for the file as ExtraData
                //

                // Get the directory code

                if( SetupGetIntField( &LineContext, 8, &Temp )){

                    FileInformation.Directory_Code = Temp;

                    _itot( Temp,Buffer, 10);

                    //Now retrieve the directory Information through a lookup of [WinntDirectories]

                    if( Temp && SetupFindFirstLine( LayoutInf, LAYOUT_DIR_SECTION, Buffer, &TempContext) ){

                        if( SetupGetStringField( &TempContext, 1, TempString, MAX_PATH, NULL )){
                            lstrcpy( FileInformation.Directory, TempString );
                        }


                    }

                }

                //
                // Get the Upgrade and Clean Install Dispositions
                //


                FileInformation.UpgradeDisposition = 3;  //Default is don't copy

                if( SetupGetStringField( &LineContext, 9, TempString, MAX_PATH, NULL )){
                
                    if( (TempString[0] >= 48) &&  (TempString[0] <= 57)){
                        Temp = _ttoi( TempString );
                        FileInformation.UpgradeDisposition = Temp;
                    }
                    
                }

                if( (FileInformation.UpgradeDisposition < 0) || (FileInformation.UpgradeDisposition > 3))
                    _ftprintf(stderr, TEXT("%s - Bad Upgrade disposition value - Inf maybe corrupt\n"),FileName);

                FileInformation.CleanInstallDisposition = 3; //Default is don't copy
                if( SetupGetStringField( &LineContext, 10, TempString, MAX_PATH, NULL )){
                    
                    if( (TempString[0] >= 48) &&  (TempString[0] <= 57)){
                        Temp = _ttoi( TempString );
                        FileInformation.CleanInstallDisposition = Temp;
                    }
                    
                }

                if( (FileInformation.CleanInstallDisposition < 0) || (FileInformation.CleanInstallDisposition > 3))
                    _ftprintf(stderr, TEXT("%s - Bad Clean Install disposition value - Inf maybe corrupt\n"),FileName);

                if( SetupGetStringField( &LineContext, 11, TempString, MAX_PATH, NULL )){
                    lstrcpy( FileInformation.TargetFileName, TempString );
                }

                if( SetupGetStringField( &LineContext, 7, TempString, MAX_PATH, NULL )){

                    if( *TempString && !_tcschr(TempString, TEXT('_'))){
                        _ftprintf(stderr, TEXT("\nERROR-Bad Media ID - No _ qualifier - %s\n"), FileName);
                        FileInformation.BootMediaNumber = -1;  //Indicates error
                    }else{


                        // Check for Compression


                        if( TempString[0] == TEXT('_') )
                            FileInformation.Compression = FALSE;

                        // Look for Boot Media Numbers
                        p = TempString;

                        while( (p[0] == TEXT('_')) ){
                            p++;
                        }
                        FileInformation.BootMediaNumber = _ttoi(p);

                    }

                }

                //Add the Media tag information

                if( SetupGetStringField( &LineContext, 1, TempString, MAX_PATH, NULL ))
                    lstrcpy(FileInformation.Media_tagID, TempString);

                FileInformation.SectionIndex = Platform_Index;


                //Get the file sizes if present

                if( SetupGetIntField( &LineContext, 3, &Temp )){
                    FileInformation.Size = (ULONG)Temp;
                }

                //
                // Now add the information to the string table.
                //

                if(!pSetupStringTableSetExtraData( LayoutContext->Context, StrID, (PVOID)&FileInformation, sizeof(FILE_LAYOUTINFORMATION))){

                    Err = ERROR_NOT_ENOUGH_MEMORY; //BUGBUG - Fix error code
                    _tprintf(TEXT("\nERROR-Could not set extra data\n"));
                    break;
                }


                /*

                _tprintf(TEXT("File - %s\n"),FileName);
                _tprintf(TEXT("Dir Code %d - Dir - %s\n"),FileInformation.Directory_Code, FileInformation.Directory);
                _tprintf(TEXT("Upgrade Disposition - %d\n"),FileInformation.UpgradeDisposition);
                _tprintf(TEXT("Textmode Disposition - %d\n"),FileInformation.CleanInstallDisposition);
                _tprintf(TEXT("Media ID - %s\n"),FileInformation.Media_tagID);
                if( *(FileInformation.TargetFileName))
                    _tprintf(TEXT("Target Filename - %s\n"),FileInformation.TargetFileName);
                if( !FileInformation.Compression )
                    _tprintf(TEXT("No Compression\n"));
                if( FileInformation.BootMediaNumber )
                    _tprintf(TEXT("Boot Media - %d\n"),FileInformation.BootMediaNumber);

                */

            }


        }
#ifdef DEBUG
        count++;
        if( (count % 100) == 0)
            _ftprintf(stderr,TEXT("\b\b\b\b\b%5d"),count);
#endif


    }while(SetupFindNextLine(&LineContext, &LineContext));// while


cleanup:

    if( LookupBuffer )
        pSetupFree(LookupBuffer);



    return Err;

}










PLAYOUT_CONTEXT
BuildLayoutInfContext(
    IN PCTSTR LayoutInfName,
    IN DWORD PlatformMask,
    IN UINT MaxExtraSize
    )

/*
    Function to generate a internal representation of files listed in a layout INF file.
    It returns an opaque context that can be used with other APIs to
    manipulate/query this representation. The internal representation builds a structure
    associated with each file that lists its attributes.

    Arguments :

        LayoutInfName - Full path to Layout file.

        PlatFormMask - Can be one of the following....

            LAYOUTPLATFORMS_ALL (default) - Grovels through all the platform-specific section

            LAYOUTPLATFORMS_X86 - Grovels through the SourcedisksFiles.x86 section

            LAYOUTPLATFORMS_AMD64 - Grovels through the SourcedisksFiles.amd64 section

            LAYOUTPLATFORMS_IA64 - Grovels through the SourcedisksFiles.ia64 section

            LAYOUTPLATFORMS_COMMON - Grovels through the SourcedisksFiles section

        MaxExtraSize  - Largest possible extra-data size that we may want to associate with
                        each file

    Return value :


        An opaque LAYOUT_CONTEXT used to access the data structure in other calls.
        Returns NULL if we had a failure.


*/

{

    PLAYOUT_CONTEXT LayoutContext;
    PVOID StringTable;
    HINF LayoutInf;
    DWORD Err;



    // Initialize the string table and set the max extra data size

    if( (StringTable=pSetupStringTableInitializeEx( (MaxExtraSize+sizeof(FILE_LAYOUTINFORMATION)), 0 )) == NULL )
        return NULL;


    //OPen up the layout file.

    LayoutInf = SetupOpenInfFile( LayoutInfName, NULL, INF_STYLE_WIN4 | INF_STYLE_CACHE_ENABLE, NULL);

    if( !LayoutInf || (LayoutInf == INVALID_HANDLE_VALUE)){
        pSetupStringTableDestroy( StringTable );
        return NULL;
    }


    LayoutContext = pSetupMalloc( sizeof(LAYOUT_CONTEXT));
    if( !LayoutContext )
        goto done;

    ZeroMemory( LayoutContext, sizeof(LAYOUT_CONTEXT));



    LayoutContext->Context = StringTable;
    LayoutContext->ExtraDataSize = (MaxExtraSize+sizeof(FILE_LAYOUTINFORMATION));






    //
    //Now we need to grovel throught the [SourceDisksFiles] sections
    //

    //
    // Grovel through the decorated sections first as specfied by PlatformMask
    //

    if(!PlatformMask)
        PlatformMask = LAYOUTPLATFORMS_ALL;

    //
    //
    //



#ifdef DEBUG
    _tprintf( TEXT("\nBuilding x86 section\n"));
#endif
    if( PlatformMask & LAYOUTPLATFORMS_X86 ){


        //
        //  Build up the [SourceDisksNames.x86] Information
        //

        Err = BuildMediaTagsInformation( LayoutInf, TEXT("SourceDisksNames.x86"), LayoutContext, LAYOUTPLATFORMINDEX_X86);


        // Process [SourceDisksFiles.x86]

        Err = BuildStringTableForSection( LayoutInf, TEXT("SourceDisksFiles.x86"), LayoutContext, LAYOUTPLATFORMINDEX_X86 );


    }
#ifdef DEBUG
    _tprintf( TEXT("\nBuilding amd64 section\n"));
#endif
    if( PlatformMask & LAYOUTPLATFORMS_AMD64 ){

        //
        //  Build up the [SourceDisksNames.amd64] Information
        //

        Err = BuildMediaTagsInformation( LayoutInf, TEXT("SourceDisksNames.amd64"), LayoutContext, LAYOUTPLATFORMINDEX_AMD64);


        // Process [SourceDisksFiles.amd64]

        Err = BuildStringTableForSection( LayoutInf, TEXT("SourceDisksFiles.amd64"), LayoutContext, LAYOUTPLATFORMINDEX_AMD64 );


    }
#ifdef DEBUG
    _tprintf( TEXT("\nBuilding ia64 section\n"));
#endif
    if( PlatformMask & LAYOUTPLATFORMS_IA64 ){

        //
        //  Build up the [SourceDisksNames.ia64] Information
        //

        Err = BuildMediaTagsInformation( LayoutInf, TEXT("SourceDisksNames.ia64"), LayoutContext, LAYOUTPLATFORMINDEX_IA64);

        // Process [SourceDisksFiles.ia64]

        Err = BuildStringTableForSection( LayoutInf, TEXT("SourceDisksFiles.ia64"), LayoutContext, LAYOUTPLATFORMINDEX_IA64 );


    }
#ifdef DEBUG
    _tprintf( TEXT("\nBuilding common section\n"));
#endif
    if( PlatformMask & LAYOUTPLATFORMS_COMMON ){

        //
        //  Build up the [SourceDisksNames] Information. In this case we have
        //  currently set it to the same as x86. Should fix this to do something better - BUGBUG
        //

        Err = BuildMediaTagsInformation( LayoutInf, TEXT("SourceDisksNames"), LayoutContext, LAYOUTPLATFORMINDEX_COMMON);

        // Process [SourceDisksFiles]

        Err = BuildStringTableForSection( LayoutInf, TEXT("SourceDisksFiles"), LayoutContext, LAYOUTPLATFORMINDEX_COMMON);


    }




done:

    SetupCloseInfFile( LayoutInf);
    return(LayoutContext) ;


}


BOOL
EnumerateLayoutInf(
    IN PLAYOUT_CONTEXT LayoutContext,
    IN PLAYOUTENUMCALLBACK LayoutEnumCallback,
    IN DWORD_PTR Param
    )
/*
  This function calls the specified callback function for each
  element in the SourceDisksFilesSection associated with the
  Layout Inf Context specified.

    It is required that the user has a LayoutInfContext open from a call to
    BuildLayoutInfContext.

    Arguments:

        Context - A LAYOUT_CONTEXT returned by BuildLayoutInfContext

        LayoutEnumCallback - specifies a callback function called for each file in the SourceDisksFile section

        CallerContext - An opaque context pointer passed on to the callback function


The callback is of the form:

typedef BOOL
(CALLBACK *PLAYOUTENUMCALLBACK) (
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    );

    where

    Context            - Pointer to open LAYOUT_CONTEXT

    FileName           - Specifies the individual filename


    LayoutInformation  - Pointer to Layout Information for this file.  User should not modify this directly.

    ExtraData          - Pointer to the ExtraData that the caller may have stored. User should not modify this directly.

    ExtraDataSize      - Size in bytes of the ExtraData

    Param            - the opaque param passed into this function is passed
                           into the callback function


   Return value:

        TRUE if all the elements were enumerated. If not it returns
        FALSE and GetLastError() returns ERROR_CANCELLED. If the callback
        returns FALSE then the enumeration stops but this API returns TRUE.

*/

{

    PVOID Buffer;
    CALLBACK_PACKAGE Package;
    BOOL ret;


    if( !LayoutContext ||
        !LayoutContext->Context ||
        !LayoutContext->ExtraDataSize ||
        !LayoutEnumCallback){
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }


    Buffer = pSetupMalloc( LayoutContext->ExtraDataSize );

    if( !Buffer ){
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(FALSE);

    }

    //We use Package to send across parameters to the Callback

    Package.Context = LayoutContext;
    Package.Callback = LayoutEnumCallback;
    Package.Param = Param;

    ret = pSetupStringTableEnum( LayoutContext->Context,
                           Buffer,
                           LayoutContext->ExtraDataSize,
                           InternalEnumRoutine,
                           (LPARAM) &Package);

    pSetupFree( Buffer );

    return( ret );



}




BOOL
InternalEnumRoutine(
    IN PVOID StringTable,
    IN LONG StringId,
    IN PCTSTR String,
    IN PFILE_LAYOUTINFORMATION LayoutInfo,
    IN UINT LayoutInfoSize,
    IN LPARAM Param
    )
/*

    This is the enum callback routine that we provide to setupapi. We
    in turn have to call the callers callback routine each time we are called.
    The callback routine of the caller is in Package.

    For now, we don't care about the StringID and don't tell the caller
    about it.

    */

{

    PVOID ExtraData;
    UINT  ExtraDataSize;
    PCALLBACK_PACKAGE Package = (PCALLBACK_PACKAGE)Param;
    BOOL ret;

    MYASSERT( Package->Callback );


    ExtraData = LayoutInfo+sizeof(FILE_LAYOUTINFORMATION);
    ExtraDataSize = LayoutInfoSize-(sizeof(FILE_LAYOUTINFORMATION));

    //BUGBUG :  Should probably put this in a try/except block

    ret = Package->Callback( Package->Context,
                             String,
                             LayoutInfo,
                             ExtraData,
                             ExtraDataSize,
                             Package->Param );


    //
    // If the user's callback returns false we stop enumeration. However the
    // toplevel EnumerateLayoutInf function still returns TRUE as it was not an
    // error in itself.
    //

    if( !ret ){
        SetLastError(ERROR_INVALID_PARAMETER);
        return( FALSE );
    }



    return( TRUE );



}



BOOL
FindFileInLayoutInf(
    IN PLAYOUT_CONTEXT LayoutContext,
    IN PCTSTR Filename,
    OUT PFILE_LAYOUTINFORMATION LayoutInformation, OPTIONAL
    OUT PVOID ExtraData,   OPTIONAL
    OUT PUINT ExtraDataSize, OPTIONAL
    OUT PMEDIA_INFO Media_Info OPTIONAL
    )
/*
    This function finds the file information for a given filename inside a
    built layout context. It returns the layout information as well as the
    extra data (if any) associated with the file.

    Arguments:

        Context            - Pointer to open LAYOUT_CONTEXT

        Filename           - Specifies the filename to search for

        LayoutInformation  - Pointer to caller supplied buffer that gets Layout Information for this file.

        ExtraData          - Pointer to the a caller supplied buffer that gets ExtraData that the caller may have stored. 

        ExtraDataSize      - Size in bytes of the ExtraData returned.

        Media_Info         - Pointer to MEDIA_INFO structure that will get filled
                             with the file's corresponding Media information.

     Return value;

        TRUE if the file is found - False otherwise.


*/
{
    PVOID Buffer;
    MEDIA_INFO TagInfo;
    PFILE_LAYOUTINFORMATION Temp;
    BOOL Err = TRUE;
    TCHAR filename[MAX_PATH];


    if( !LayoutContext ||
        !LayoutContext->Context ||
        !LayoutContext->ExtraDataSize ||
        !Filename){
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    lstrcpy( filename, Filename ); //To get around constness problem

    Buffer = pSetupMalloc( LayoutContext->ExtraDataSize );

    if( !Buffer ){
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(FALSE);

    }

    if( pSetupStringTableLookUpStringEx( LayoutContext->Context,
                                   filename,
                                   STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                   Buffer,
                                   LayoutContext->ExtraDataSize) == -1 ){
        Err = FALSE;
        goto cleanup;
    }

    if( LayoutInformation )
        CopyMemory( LayoutInformation, Buffer, sizeof(FILE_LAYOUTINFORMATION));

    if( ExtraData ){

        CopyMemory( ExtraData,
                    ((PFILE_LAYOUTINFORMATION)Buffer+sizeof(FILE_LAYOUTINFORMATION)),
                    ((LayoutContext->ExtraDataSize)-(sizeof(FILE_LAYOUTINFORMATION))) );
    }

    if( ExtraDataSize )
        *ExtraDataSize = (LayoutContext->ExtraDataSize)-(sizeof(FILE_LAYOUTINFORMATION));


    //
    // Now get the Media Information for the file if needed
    //


    if( Media_Info ){

        Temp = (PFILE_LAYOUTINFORMATION)Buffer;

        if( pSetupStringTableLookUpStringEx( LayoutContext->MediaInfo[Temp->SectionIndex],
                                   Temp->Media_tagID,
                                   STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                   Media_Info,
                                   sizeof(MEDIA_INFO)) == -1 ){

            _tprintf( TEXT("\nError - Could not get Media Info for tag %s\n"), Temp->Media_tagID);

        }


    }


cleanup:

    if( Buffer )
        pSetupFree( Buffer );

    return Err;


}


BOOL
CloseLayoutInfContext(
    IN PLAYOUT_CONTEXT LayoutContext)
/*
    This function closes a Layout Inf Context and frees all memory
    associated with it.

    Arguments :

        LayoutContext   -  LayoutContext to close

    Return values :

        TRUE if it succeeds, else FALSE

*/
{
    int i;

    if( !LayoutContext ){
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }else{

        if( LayoutContext->Context )
            pSetupStringTableDestroy( LayoutContext->Context );

        for( i=0; i<MAX_PLATFORMS; i++ ){
            if( LayoutContext->MediaInfo[i] )
                pSetupStringTableDestroy( LayoutContext->MediaInfo[i] );
        }


        pSetupFree( LayoutContext );

    }

    return TRUE;

}




VOID
MyConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

{
    BOOL NeedBackslash = TRUE;
    DWORD l;

    if(!Path1)
        return;

    l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(Path2 && ((l+lstrlen(Path2)) < BufferSizeChars)) {
        lstrcat(Path1,Path2);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\infmerge\infmerge.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    infmerge.c

Abstract:

    This module implements a program that merge two inf files
    to one inf file.

    See below for more information.

Author:

    Katsumi Yokomichi (Katsumiy) 22-May-2000

Revision History:

--*/


/*
*/


#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <shellapi.h>

#include <setupapi.h>
#include <spapip.h>


CHAR Buffer[1024];
CHAR Buffer2[1024];
CHAR Section[1024];
CHAR Section2[1024];
FILE    *InFile1;
FILE    *InFile2;
FILE    *OutFile;
CHAR PrevSection[1024];

/* Extract Section name (inside of []) from Line text. */

BOOL GetSection(CHAR *p, CHAR *SectionName, INT SectionSize)
{
    CHAR *cp;
    CHAR *sp1;
    CHAR *sp2;
    CHAR *q1;
    CHAR *q2 = 0;

    cp = strchr(p, ';');
    sp1 = strchr(p, '[');
    sp2 = strchr(p, ']');
    q1  = strchr(p, '"');
    if ( q1 ) {
      q2 = strchr(q1+1, '"');
    }

    if ((sp1 == NULL)            ||
        (sp2 == NULL)            ||
        (sp1 > sp2)              ||
        (cp != NULL && cp < sp1) ||
        (q1 < sp1 && q2 > sp1))  {
        return FALSE;
    }

    strncpy(SectionName, sp1, max(SectionSize, sp2 - sp1));
    return TRUE;
}

/* Read 1 section from 2nd file and merge into Output file. */

VOID Merge(VOID)
{
    BOOL InSection2;

    fseek(InFile2, 0, SEEK_SET);
    InSection2 = FALSE;
    while (fgets(Buffer2, sizeof(Buffer2), InFile2)) {
        if (GetSection(Buffer2,Section2, sizeof(Section2))) {
            if (InSection2) {
                break;
            } else {
                if (0 == strcmp(Section2, PrevSection)) {
                    InSection2 = TRUE;
                    continue;
                }
            }
        }
        if (InSection2) {
            fputs(Buffer2, OutFile);
        }
    }
}

int
__cdecl
main(
    IN int   argc,
    IN CHAR *argv[]
    )
{
    BOOL InSection;

    if (argc != 4) {
        goto ErrorExit;
    }

    if ((InFile1 = fopen(argv[1], "r")) == NULL) {
        fprintf(stderr, "Can't open %s.\n", argv[1]);
        goto ErrorExit;
    }

    if ((InFile2 = fopen(argv[2], "r")) == NULL) {
        fprintf(stderr, "Can't open %s.\n", argv[2]);
        goto ErrorExit;
    }

    if ((OutFile = fopen(argv[3], "w")) == NULL) {
        fprintf(stderr, "Can't open %s.\n", argv[3]);
        goto ErrorExit;
    }

    InSection = FALSE;
    while (fgets(Buffer, sizeof(Buffer), InFile1)) {
        if (GetSection(Buffer,Section, sizeof(Section))) {
            if (InSection) {
                Merge();
                strcpy(PrevSection, Section);
            } else {
                InSection = TRUE;
                strcpy(PrevSection, Section);
            }
        }
        fputs(Buffer, OutFile);
    }

    if (InSection) {
        Merge();
    }

    return 0;

ErrorExit:
    fprintf(stderr, "Usage: %s InputFile1 InputFile2 OutputFile.\n", argv[0]);
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\inftest\inftest.h ===
#include <stdio.h>
#include <windows.h>
#include <conio.h>
#include <process.h>
#include <tchar.h>
#include <objbase.h>
#include <inflib.h>
#include <string.h>
#include <sputils.h>

#define NOSPEW 0
#define BRIEF 1
#define DETAIL 2

#define WINNT32_PHASE 1
#define LOADER_PHASE 2
#define TEXTMODE_PHASE 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\inftest\precomp.h ===
#include "inftest.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\inftest\inftest.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    myapp.c

Abstract:

    This module implements functions to access the parsed INF.

Author:

    Vijesh Shetty (vijeshs)

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <wild.c>

#define PRINT( msg, param ) \
    {  _tprintf( TEXT(msg), param ); \
       if(g_Display == Default ){ \
            _tprintf( TEXT("\n")); \
       }else if(g_Display == FileOnly ){ \
            _tprintf( TEXT(" - ")); }\
    }


#define ERROROUT  \
        { g_Pass = FALSE; \
        OutputFileInfo( LayoutInformation, FileName, g_Display ); \
        return TRUE;}
        
#define MAX_BOOTFLOPPY 7
extern BOOL Verbose;

extern DWORD
LoadInfFile(
   IN  LPCTSTR Filename,
   IN  BOOL    OemCodepage,
   OUT PVOID  *InfHandle,
   DWORD      Phase
   );

BOOL
CALLBACK
MyCallback(
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    );

typedef enum _DISPLAYOPTIONS{
    Default,
    FileOnly
} DISPLAYOPTIONS, *PDISPLAYOPTIONS;

typedef enum _CHECKSUITE{
    Deflt,
    Build
} CHECKSUITE, *PCHECKSUITE;

DISPLAYOPTIONS g_Display = Default;
CHECKSUITE g_CheckSuite = Deflt;
TCHAR g_LayoutFileName[MAX_PATH];
DWORD g_Platform=LAYOUTPLATFORMS_COMMON;
BOOLEAN g_Warning = FALSE;
BOOLEAN g_Pass = TRUE;
DWORD g_Phase = TEXTMODE_PHASE;
PLAYOUTENUMCALLBACK g_Callback = (PLAYOUTENUMCALLBACK) MyCallback;

BOOLEAN
IsNameInExpressionPrivate (
    IN PCTSTR Expression,
    IN PCTSTR Name
    );

void
OutputFileInfo( PFILE_LAYOUTINFORMATION LayoutInformation,
                PCTSTR FileName,
                DISPLAYOPTIONS DispType );



/*******************************************************************************/

//  Validation Check Functions
//



BOOL
Validate8Dot3(
    IN PCTSTR FileName )
/*
    Function to check if a file satisfies 8.3
    
    Arguments:
    
        FileName - Filename to validate
        
    Return value:
        
        TRUE  - Passes validation
        FALSE - Fails validation        
  
*/
{

    //
    //  Check for 8.3 validation
    //


    if( (g_Platform & LAYOUTPLATFORMS_IA64) ||
        (g_Platform & LAYOUTPLATFORMS_AMD64) )
        return TRUE;

    if( FileName && (lstrlen(FileName) > 12)){
        PRINT( "%s : Error E0000 : !!! - Filename too long (8.3 required)", g_LayoutFileName );
        return FALSE;
    }

    return TRUE;


}


BOOL
ValidateMissingDirCodes(
    IN PFILE_LAYOUTINFORMATION LayoutInformation )
/*
    Function to check if a file is missing Directory Information when it is needed by textmode
    
    Arguments:
    
        LayoutInformation - Pointer to PFILE_LAYOUTINFORMATION structure for file
        
    Return value:
        
        TRUE  - Passes validation
        FALSE - Fails validation        
  
*/
{

    //
    //  Check for Directory codes
    //

    if( ((LayoutInformation->CleanInstallDisposition <= 2) || (LayoutInformation->UpgradeDisposition <= 2))
        && !(*LayoutInformation->Directory)){
        PRINT( "%s : Error E0000 : !!! - Missing directory for textmode setup", g_LayoutFileName );
        return FALSE;
    }

    return TRUE;

}

BOOL
ValidateBootMediaFields(
    IN PFILE_LAYOUTINFORMATION LayoutInformation )
/*
    Function to check if the Boot Media fields are set right
    
    Arguments:
    
        LayoutInformation - Pointer to PFILE_LAYOUTINFORMATION structure for file
        
    Return value:
        
        TRUE  - Passes validation
        FALSE - Fails validation        
  
*/
{

    if( (LayoutInformation->BootMediaNumber < 0) || (LayoutInformation->BootMediaNumber > MAX_BOOTFLOPPY)
        || (LayoutInformation->BootMediaNumber == -1) ){

        PRINT( "%s : Error E0000 : !!! - Bad Boot media number", g_LayoutFileName );
        return FALSE;
    }

    return TRUE;


}


BOOL
ValidateSingleInstance(
    IN PFILE_LAYOUTINFORMATION LayoutInformation )
/*
    Function to check if there is only a single instance of this file
    
    Arguments:
    
        LayoutInformation - Pointer to PFILE_LAYOUTINFORMATION structure for file
        
    Return value:
        
        TRUE  - Passes validation
        FALSE - Fails validation        
  
*/
{

    if( LayoutInformation->Count > 1 ){
        PRINT( "%s : Error E0000 : !!! - Filename present in more than one place", g_LayoutFileName );
        return FALSE;
    }

    return TRUE;

}


BOOL
CheckForTurdDirCodes(
    IN PFILE_LAYOUTINFORMATION LayoutInformation )
/*
    Function to check if the dir code is present but doesn't make sense with respect to dispositions
    
    Arguments:
    
        LayoutInformation - Pointer to PFILE_LAYOUTINFORMATION structure for file
        
    Return value:
        
        TRUE  - Not a Turd
        FALSE - Presence of a turd
  
*/
{

    if( ((LayoutInformation->CleanInstallDisposition == 3) && (LayoutInformation->UpgradeDisposition == 3)) \
            && (*LayoutInformation->Directory)){
            PRINT( "%s : Warning W0000 : !!! - Directory code specified but not used", g_LayoutFileName );
            return FALSE;
    }

    return TRUE;
            

}


/***********End Validation Check Functions*****************************************/

/***********Callback Routines*************************************/

BOOL
CALLBACK
MyCallback(
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    )
{
    BOOL Error=FALSE;



    //  Check for missing filename

    if( !FileName || !(*FileName) ){
        PRINT( "%s : Error E0000 :!!! - Line missing filename\n", FileName );
        ERROROUT;
    }
        

    
    //
    //  Check for 8.3 validation
    //

    if( !Validate8Dot3( FileName ))
        ERROROUT;

    //
    //  Check for Directory codes
    //

    if( !ValidateMissingDirCodes( LayoutInformation))
        ERROROUT;

    //
    //  Check for Boot Media validity
    //

    if (!ValidateBootMediaFields( LayoutInformation))
        ERROROUT;

    //
    // Check for duplicates
    //


    if (!ValidateSingleInstance( LayoutInformation ))
        ERROROUT;

    
    
    if( g_Warning ){            
        if( !CheckForTurdDirCodes( LayoutInformation ))
            OutputFileInfo( LayoutInformation, FileName, g_Display );

    }


    return( TRUE );




}

CALLBACK
BuildCheckCallback(
    IN PLAYOUT_CONTEXT Context,
    IN PCTSTR FileName,
    IN PFILE_LAYOUTINFORMATION LayoutInformation,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN OUT DWORD_PTR Param
    )
{
    BOOL Error=FALSE;



    //  Check for missing filename

    if( !FileName || !(*FileName) ){
        PRINT( "%s : Error E0000 :!!! - Line missing filename\n", FileName );
        ERROROUT;
    }
        

    
    //
    //  Check for 8.3 validation
    //

    if( !Validate8Dot3( FileName ))
        ERROROUT;

    //
    //  Check for Directory codes
    //

    if( !ValidateMissingDirCodes( LayoutInformation))
        ERROROUT;

    //
    //  Check for Boot Media validity
    //

    if (!ValidateBootMediaFields( LayoutInformation))
        ERROROUT;

    //
    // Check for duplicates
    //


    if (!ValidateSingleInstance( LayoutInformation ))
        ERROROUT;

    
    
    if( g_Warning ){            
        if( !CheckForTurdDirCodes( LayoutInformation ))
            OutputFileInfo( LayoutInformation, FileName, g_Display );

    }


    return( TRUE );




}


/******************End Callback Routines**********************************************/



void
FindSingleFile( PLAYOUT_CONTEXT LayoutContext,
                PCTSTR FileName )
{

    BOOL ret=FALSE;
    FILE_LAYOUTINFORMATION LayoutInformation;
    MEDIA_INFO MediaInfo;

    ret = FindFileInLayoutInf( LayoutContext,
                               FileName,
                               &LayoutInformation,
                               NULL,
                               NULL,
                               &MediaInfo);


    if (ret)
        OutputFileInfo( &LayoutInformation, FileName, Default );
    else
        _ftprintf(stderr, TEXT("\nError: File Not Found\n"));


    return;



}



void
OutputFileInfo( PFILE_LAYOUTINFORMATION LayoutInformation,
                PCTSTR FileName,
                DISPLAYOPTIONS DispType
                )
{
    TCHAR Disposition[][50]={ TEXT("Always Copy"),
                             TEXT("Copy if present"),
                             TEXT("Copy if not present"),
                             TEXT("Never copy - Copied via INF")


    };

    if( DispType == FileOnly )
        _tprintf(TEXT("%s\n"),FileName);
    else
        _tprintf(TEXT("Filename         - %s\n"),FileName);

    if( DispType == FileOnly )
        return;

    _tprintf(TEXT("Dir Name         - %s(%d)\n"), LayoutInformation->Directory, LayoutInformation->Directory_Code);


    _tprintf(TEXT("On Upgrade       - %s(%d)\n"), Disposition[LayoutInformation->UpgradeDisposition], LayoutInformation->UpgradeDisposition);
    _tprintf(TEXT("On Clean Install - %s(%d)\n"), Disposition[LayoutInformation->CleanInstallDisposition], LayoutInformation->CleanInstallDisposition);

    _tprintf(TEXT("Media Tag ID     - %s\n"),LayoutInformation->Media_tagID);

    if( *(LayoutInformation->TargetFileName))
        _tprintf(TEXT("Target Filename  - %s\n"),LayoutInformation->TargetFileName);
    if( LayoutInformation->BootMediaNumber && (LayoutInformation->BootMediaNumber != -1))
        _tprintf(TEXT("Boot Media       - %d\n"),LayoutInformation->BootMediaNumber);
    if( !LayoutInformation->Compression )
        _tprintf(TEXT("No Compression\n"));


    if( DispType != FileOnly )
        _tprintf( TEXT("\n"));


    return;

}


BOOL
ProcessCommandLine( int ArgCount, TCHAR *ArgArray[] )
/*
    Function to process the command line and seperate out options into tokens
*/
{

    int i;
    LPTSTR Arg;

    if( ArgCount >= 1)
        lstrcpy( g_LayoutFileName, ArgArray[1] );

    if( !_tcsrchr( g_LayoutFileName, TEXT('\\'))){
        GetCurrentDirectory( MAX_PATH, g_LayoutFileName );
        MyConcatenatePaths(g_LayoutFileName,ArgArray[1],MAX_PATH);

    }


    for ( i=2;i < ArgCount;i++ ){ //Go through each directive


        Arg = ArgArray[i];

        if( (Arg[0] != TEXT('/')) && (Arg[0] != TEXT('-')))
            continue;

        if(_istlower(Arg[1]))
            Arg[1] = _toupper(Arg[1]);

        switch( Arg[1] ){

        case TEXT('F'):
            g_Display = FileOnly;
            break;

        case TEXT('A'):
            g_Platform |= LAYOUTPLATFORMS_AMD64;
            break;

        case TEXT('I'):
            g_Platform |= LAYOUTPLATFORMS_X86;
            break;

        case TEXT('M'):
            g_Platform |= LAYOUTPLATFORMS_IA64;
            break;

        case TEXT('W'):
            g_Warning = TRUE;
            break;

        case TEXT('V'):
            if( _ttoi(Arg+2) == BRIEF )
                Verbose = BRIEF;
            else if(_ttoi(Arg+2) == DETAIL )
                Verbose = DETAIL;
            else
                Verbose = BRIEF;
            break;

        case TEXT('D'):
            g_Phase = WINNT32_PHASE;
            break;

        case TEXT('L'):
            g_Phase = LOADER_PHASE;
            break;

        case TEXT('T'):
            g_Phase = TEXTMODE_PHASE;
            break;

        case TEXT('B'):
            g_CheckSuite = Build;
            break;



        default:
            break;
        }





    }// for

    return( TRUE );


}



void 
BuildValidations( void )
/*

    Main processing routine while using the /B - Build switch
    Runs the suite of validations for this situation

*/
{
    BOOL LayoutInf = FALSE;
    PLAYOUT_CONTEXT LayoutContext;
    PVOID InfHandle;
    DWORD Error;

    // Set the globals accordingly

    g_Display = FileOnly;


    // We set LayoutInf if we are validating it. In the build case
    // we only validate layout info for layout.inf. All others should be only
    // syntax checks.

    if(_tcsstr( g_LayoutFileName, TEXT("layout.inf")))          
        LayoutInf = TRUE;

    
    // Run the sematic validation tests only for layout.inf in the build case

    if( LayoutInf ){

        g_Phase = 0;
    
        LayoutContext = BuildLayoutInfContext( g_LayoutFileName, g_Platform, 0);
        if( !LayoutContext ){
            g_Pass = FALSE;
            _tprintf(TEXT("%s : Error E0000 : Could not build Layout Inf context\n"), g_LayoutFileName);
            return;
        }

        
    
        //Callback will set the right value of g_pass on error.
    
        EnumerateLayoutInf( LayoutContext, BuildCheckCallback, 0 );
    
        CloseLayoutInfContext( LayoutContext );

        if(!ValidateTextmodeDirCodesSection( g_LayoutFileName, TEXT("WinntDirectories") ))
            g_Pass = FALSE;

    }
    
    if (g_Phase & TEXTMODE_PHASE){

        _tprintf( TEXT("Checking %s for compliance with the textmode setup INF parser\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,TEXTMODE_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Error E0000 : Not compliant with Textmode Setup's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Textmode Setup's Parser\n"), Error );
    }
    if (g_Phase & LOADER_PHASE){

        _tprintf( TEXT("Checking %s for compliance with the Loader's INF parser\n\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,LOADER_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Error E0000 : Not compliant with Loader's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Loader's Parser\n"), Error );

    }
        
    if (g_Phase & WINNT32_PHASE) {

        _tprintf( TEXT("Checking %s for compliance with the Winnt32 INF parser\n\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,WINNT32_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Error E0000 : Not compliant with Winnt32's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Winnt32's Parser\n"), Error );

    }
        

    





}



void 
DefaultValidations( void )
/*

    Main processing routine while using the /B - Build switch
    Runs the suite of validations for this situation

*/
{
    BOOL TxtSetupSif = FALSE;
    PLAYOUT_CONTEXT LayoutContext;
    PVOID InfHandle;
    DWORD Error;


    // We set TxtSetupSif if we are validating it. That is the only case where we need to 
    // do syntax checks with loader and textmode along with Layout validation.

    if(_tcsstr( g_LayoutFileName, TEXT("txtsetup.sif")) 
       || _tcsstr( g_LayoutFileName, TEXT("layout.inf"))){
        TxtSetupSif = TRUE;
    }
        



    if( TxtSetupSif ){
    
        // Run the semantic validation tests
    
        LayoutContext = BuildLayoutInfContext( g_LayoutFileName, g_Platform, 0);
        if( !LayoutContext ){
            g_Pass = FALSE;
            _tprintf(TEXT("\nError - Could not build Layout Inf context\n"));
            return;
        }
    
        //Callback will set the right value of g_pass on error.
    
        EnumerateLayoutInf( LayoutContext, MyCallback, 0 );
    
        CloseLayoutInfContext( LayoutContext );

        if(!ValidateTextmodeDirCodesSection( g_LayoutFileName, TEXT("WinntDirectories") ))
            g_Pass = FALSE;

    }
    

    


    if ((g_Phase & TEXTMODE_PHASE) || TxtSetupSif){

        _ftprintf( stderr, TEXT("\nChecking %s for compliance with the textmode setup INF parser\n\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,TEXTMODE_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Not compliant with Textmode Setup's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Textmode Setup's Parser\n"), Error );
    }
    if (g_Phase & LOADER_PHASE  || TxtSetupSif){

        _ftprintf( stderr, TEXT("\nChecking %s for compliance with the Loader's INF parser\n\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,LOADER_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Not compliant with Loader's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Loader's Parser\n"), Error );

    }
        
    if (g_Phase & WINNT32_PHASE) {

        _ftprintf( stderr, TEXT("\nChecking %s for compliance with the Winnt32 INF parser\n\n"),g_LayoutFileName);
        if( (Error=LoadInfFile(g_LayoutFileName,FALSE,&InfHandle,WINNT32_PHASE)) != NO_ERROR ){
            _tprintf( TEXT("%s : Not compliant with Winnt32's parser - %i\n"), g_LayoutFileName, Error );
            g_Pass = FALSE;
        }else
            _tprintf( TEXT("Compliant with Winnt32's Parser\n"), Error );

    }



    

}

_cdecl _tmain( int argc, TCHAR *argv[ ], char *envp[ ] )
{
    LPWSTR *CmdlineV;
    int CmdlineC;

    if(!pSetupInitializeUtils()) {
        return 1;
    }

    //
    // Check Params.
    //
    if( (argc < 2) || !_tcscmp(argv[1],TEXT("/?")) ) {
        _tprintf(TEXT("Program to validate/verify the given layout inf file\n\n")
                 TEXT("Usage: %s <Inf Filename> [options]\n")
                 TEXT("<Inf Filename> - Layout File to examine\n")
                 TEXT("Options for layout.inf and txtsetup.sif (automatically checks loader and textmode syntax):-\n")
                 TEXT("/W - Enable warnings too\n\n")
                 TEXT("Checking of Platform specific SourceDisksFiles section\n")
                 TEXT("/F - Display only filenames\n")
                 TEXT("/I - Process for Intel i386\n")
                 TEXT("/A - Process for AMD AMD64\n")
                 TEXT("/M - Process for Intel IA64\n")
                 TEXT("By default the parser will check for compliance with the textmode setup parser\n\n")
                 TEXT("The below checks only perform a syntax check and don't check semantics.\n")
                 TEXT("/D - Checks for compliance with winnt32 parser - use with dosnet.inf,mblclean.inf etc.\n")
                 TEXT("/L - Checks for compliance with the loader - use for infs used by loader - biosinfo.inf, migrate.inf etc.\n")
                 TEXT("/T - Checks for compliance with the textmode setup - use for hive*.inf etc.\n\n")
                 TEXT("/B - Does the layout information checks for setup infs and uses build.exe compliant error reporting\n\n")
                  , argv[0] );
        goto cleanup;
    }

    if( !ProcessCommandLine( argc, argv ) ) {
        g_Pass = FALSE;
        goto cleanup;
    }

    switch( g_CheckSuite ){
    
    
    case Build:
        BuildValidations();
        break;

    case Deflt:
        DefaultValidations();
        break;

    default:
        //Shouldn't get here as g_CheckSuite is initialized to Default
        _tprintf( TEXT("\nUnexpected error \n"));
        g_Pass=FALSE;
        break;


    }

    if( g_Pass )
        _tprintf( TEXT("\nNo problems found with %s\n"), g_LayoutFileName);
    else
        _tprintf( TEXT("\nErrors were encountered with %s.\n"), g_LayoutFileName);
    
cleanup:

    pSetupUninitializeUtils();

    return (g_Pass ? 0:1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\ocinf\ocinf.c ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <crt\string.h>
#include <sputils.h>
#include <tchar.h>

/*
============================================================================

Compute the disk space requirements for all OC components.

============================================================================
*/

//
// String Macros
//
#define AS(x)           ( sizeof(x) / sizeof(x[0]) )
#define LSTRCPY(x,y)    ( lstrcpyn(x, y, AS(x)) )
#define LSTRCAT(x,y)    ( lstrcpyn(x + lstrlen(x), y, AS(x) - lstrlen(x)) )

//
// Handle to the inf we're operating on.
//
HINF    hInputinf;
HINF    hLayoutinf;


//
// Initialize input parameters.
//
BOOL    Verbose     = FALSE;
TCHAR   InfPath[MAX_PATH];
PCWSTR  InputInf    = NULL;
PCWSTR  LayoutPath  = NULL;

//
// backward-compatible SetupGetInfSections
//
#undef SetupGetInfSections
BOOL
SetupGetInfSections (
    IN  HINF        InfHandle,
    OUT PTSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    );



//
// ============================================================================
//
// Find out what the user wants us to do.
//
// ============================================================================
//
BOOL GetParams(
    int argc,
    char *argv[ ]
    )
{
char    *p;
int     i;
PTSTR   tstr_ptr = NULL;


    for( i = 0; i < argc; i++ ) {
        if( *argv[i] == '-' ) {
            p = argv[i];


            //
            // Verbose?
            //
            if( !_strcmpi( p, "-v" ) ) {
                Verbose = TRUE;
                continue;
            }


            //
            // Inf file?
            //
            if( !_strnicmp( p, "-inf:", 5 ) ) {
                p = p + 5;
                InputInf = pSetupAnsiToUnicode(p);

                //
                // Now extract the path for this inf.
                //
                lstrcpy( InfPath, InputInf );
                tstr_ptr = wcsrchr( InfPath, TEXT( '\\' ) );
                if( tstr_ptr ) {
                    *tstr_ptr = 0;
                }

                continue;
            }



            //
            // Files location location?
            //
            if( !_strnicmp( p, "-layout:", 8 ) ) {
                p = p + 8;
                LayoutPath = pSetupAnsiToUnicode(p);
                continue;
            }

        }
    }

    //
    // Check Params.
    //
    if( InfPath == NULL ) {
        return FALSE;
    }


    if( LayoutPath == NULL ) {
        return FALSE;
    }


    return TRUE;
}

//
// ============================================================================
//
// Tell the user how to use us.
//
// ============================================================================
//
void Usage( )
{
    printf( "Compute disk space requirements for files listed in an inf\n" );
    printf( "\n" );
    printf( "\n" );
    printf( "    -inf:<path>   This is the path to the inf (including the\n" );
    printf( "                  inf file name).  E.g. -inf:c:\\dosnet.inf\n" );
    printf( "\n" );
    printf( "    -layout:<path> This is the path to layout.inf (including the\n" );
    printf( "                  inf file name).  E.g. -inf:c:\\layout.inf\n" );
    printf( "\n" );
    printf( "    -v            Run in verbose mode.\n" );
    printf( "\n" );
    printf( "\n" );
}




//
// ============================================================================
//
// Process a single section in the inf.
//
// ============================================================================
//
VOID
ProcessInf(
    HINF    hInputinf,
    PTSTR   TargetInfPath
    )
/*

    Process the inf.  Look at each section and ask SetupApi to give us the
    disk space requirements for installing this section.  If we get input
    back from setupapi, then update the SizeApproximation entry in this
    section.

*/
{


DWORD       SizeNeeded = 0;
PTSTR       Sections,CurrentSection;
HDSKSPC     hDiskSpace;
BOOL        b;
TCHAR       CurrentDrive[MAX_PATH];
LONGLONG    SpaceRequired;
DWORD       dwError;


    //
    // get a list of all the sections in this inf.
    //
    if( !SetupGetInfSections(hInputinf, NULL, 0, &SizeNeeded) ) {
        fprintf( stderr, "Unable to get section names, ec=0x%08x\n", GetLastError());
        return;
    }

    if( SizeNeeded == 0 ) {
        fprintf( stderr, "There are no sections in this file.\n");
        return;
    }

    Sections = pSetupMalloc (SizeNeeded + 1);
    if (!Sections) {
        fprintf( stderr, "Unable to allocate memory, ec=0x%08x\n", GetLastError());
        return;
    }

    if(!SetupGetInfSections(hInputinf, Sections, SizeNeeded, NULL) ) {
        fprintf( stderr, "Unable to get section names, ec=0x%08x\n", GetLastError());
        return;
    }


    if( Verbose ) {
        fprintf( stderr, "\nProcessing inf file: %ws.\n", TargetInfPath );
    }

    //
    // Now process each section.
    //
    CurrentSection = Sections;
    while( *CurrentSection ) {


        if( Verbose ) {
            fprintf( stderr, "\tProcessing Section: %ws.\n", CurrentSection );
        }



        //
        // Get a diskspace structure.
        //
        hDiskSpace = SetupCreateDiskSpaceList( NULL, 0, SPDSL_IGNORE_DISK );

        if( !hDiskSpace ) {
            fprintf( stderr, "\t\tUnable to allocate a DiskSpace structure. ec=0x%08x\n", GetLastError());
            continue;
        }


        b = SetupAddInstallSectionToDiskSpaceList( hDiskSpace,
                                                   hInputinf,
                                                   hLayoutinf,
                                                   CurrentSection,
                                                   0,
                                                   0 );



        if( b ) {

            //
            // There must have been a copyfile section and we got some info.
            //


            //
            // Figure out which drive we're running on.  we're going to
            // assume that this disk has a reasonable cluster-size and just
            // use it.
            //
            if( !GetWindowsDirectory( CurrentDrive, MAX_PATH ) ) {
                fprintf( stderr, "\t\tUnable to retrieve current directory. ec=0x%08x\n", GetLastError());
                continue;
            }

            CurrentDrive[2] = 0;

            if( Verbose ) {
                fprintf( stderr, "\t\tChecking space requirements on drive %ws.\n", CurrentDrive );
            }


            //
            // Now query the disk space requirements against this drive.
            //
            SpaceRequired = 0;
            b = SetupQuerySpaceRequiredOnDrive( hDiskSpace,
                                                CurrentDrive,
                                                &SpaceRequired,
                                                NULL,
                                                0 );


            if( !b ) {
                //
                // This probably happened because there was no CopyFiles section.
                //
                dwError = GetLastError();
                if( dwError != ERROR_INVALID_DRIVE ) {
                    fprintf( stderr, "\t\tUnable to query space requirements. ec=0x%08x\n", GetLastError());
                } else {
                    if( Verbose ) {
                        fprintf( stderr, "\t\tI don't think this section has a CopyFiles entry.\n");
                    }
                }
            }


            //
            // We got the space requirements.  now all we have to do is spew them into the inf.
            //

            if( Verbose ) {
                fprintf( stderr, "\t\tRequired space: %I64d\n", SpaceRequired );
            }


            if( SpaceRequired > 0 ) {

                swprintf( CurrentDrive, TEXT("%I64d"), SpaceRequired );

                b = WritePrivateProfileString( CurrentSection,
                                               TEXT("SizeApproximation"),
                                               CurrentDrive,
                                               TargetInfPath );

                if( !b ) {
                    fprintf( stderr, "\t\tUnable to write space requirements to %ws. ec=0x%08x\n", InfPath, GetLastError());
                    continue;
                }
            }
        }

        //
        // Free that diskspace structure.
        //
        SetupDestroyDiskSpaceList( hDiskSpace );

        CurrentSection += lstrlen(CurrentSection) + 1;

    }

    pSetupFree( Sections );

}


int
__cdecl
main( int argc, char *argv[ ], char *envp[ ] )
{
INFCONTEXT  InputContext;
LONG        i, LineCount;
BOOL        b;
TCHAR       TargetInfPath[MAX_PATH];
TCHAR       FileName[MAX_INF_STRING_LENGTH];
HINF        hTargetInf;
int         Result = 1;

    //
    // Check Params.
    //
    if(!pSetupInitializeUtils()) {
        fprintf( stderr, "Initialization failed\n" );
        return 1;
    }

    if( !GetParams( argc, argv ) ) {
        Usage();
        Result = 1;
        goto cleanup;
    }

    //
    // Open the inf file.
    //
    hInputinf = SetupOpenInfFileW( InputInf, NULL, INF_STYLE_WIN4, NULL );
    if( hInputinf == INVALID_HANDLE_VALUE ) {
        if( Verbose ) {
            fprintf( stderr, "The file %ws was not opened!\n", InputInf );
        }
        Result = 1;
        goto cleanup;
    }

    //
    // Open the specified layout.inf file.
    //
    hLayoutinf = SetupOpenInfFileW( LayoutPath, NULL, INF_STYLE_WIN4, NULL );
    if( hLayoutinf == INVALID_HANDLE_VALUE ) {
        if( Verbose ) {
           fprintf( stderr, "The file %ws was not opened!\n", LayoutPath );
        }
        Result = 1;
        goto cleanup;
    }


    //
    // Now loop through all the entries in the "components"
    // section and process their infs.
    //
    LineCount = SetupGetLineCount( hInputinf,
                                   TEXT("Components") );

    for( i = 0; i < LineCount; i++ ) {

        //
        // Get this line.
        //
        b = SetupGetLineByIndex( hInputinf,
                                 TEXT("Components"),
                                 i,
                                 &InputContext );

        if( b ) {
            //
            // got it.  Get the inf name for this component (there
            // may not be one).
            //
            if(SetupGetStringField(&InputContext, 3,FileName,MAX_INF_STRING_LENGTH,NULL) &&
                FileName[0] != TEXT('\0')) {

                //
                // Yep, there's an inf that we need to look at.
                // Build a path to it and open a handle to it.
                //
                LSTRCPY( TargetInfPath, InfPath );
                LSTRCAT( TargetInfPath, TEXT("\\") );
                LSTRCAT( TargetInfPath, FileName );

                hTargetInf = SetupOpenInfFileW( TargetInfPath, NULL, INF_STYLE_WIN4, NULL );
                if( hTargetInf == INVALID_HANDLE_VALUE ) {
                    if( Verbose ) {
                        fprintf( stderr, "The file %ws was not opened!\n", TargetInfPath );
                    }
                    continue;
                }

                //
                // Now process it.
                //
                ProcessInf( hTargetInf, TargetInfPath );

            } else {
                //
                // There must not have been an inf in this
                // line.
                //
                if( Verbose ) {
                    fprintf( stderr, "I didn't find an inf entry on this line.\n");
                }
            }
        }
    }

    SetupCloseInfFile( hInputinf );
    SetupCloseInfFile( hLayoutinf );

    Result = 0;

cleanup:

    pSetupUninitializeUtils();

    return Result;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\prodfilt\prodfilt.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    prodfilt.c

Abstract:

    This module implements a program that filters text files
    to produce a product-specific output file.

    See below for more information.

Author:

    Ted Miller (tedm) 20-May-1995

Revision History:

--*/


/*
    The input file to this program consists of a series of lines.
    Each line may be prefixed with one or more directives that
    indicate which product the line is a part of. Lines that are
    not prefixed are part of all products.

    The command line is as follows:

    prodfilt <input file> <output file> +tag

    For example,

    [Files]
    @w:wksprog1.exe
    @w:wksprog2.exe
    @s:srvprog1.exe
    @s:srvprog2.exe
    comprog1.exe
    @@:comprog2.exe


    The files wksprog1.exe and wksprog2.exe are part of product w
    and the files srvprog1.exe and srvprog2.exe are part of product s.
    Comprpg1.exe and comprog2.exe are part of both products.

    Specifying +w on the command line produces

    [Files]
    wksprog1.exe
    wksprog2.exe
    comprog1.ee
    comprog2.exe

    in the output.
*/


#include <windows.h>
#include <stdio.h>
#include <tchar.h>

//
// Define program result codes (returned from main()).
//
#define SUCCESS 0
#define FAILURE 1

//
// Tag definitions.
//
LPCTSTR TagPrefixStr = TEXT("@");
TCHAR   TagPrefix    = TEXT('@');
TCHAR   EndTag       = TEXT(':');
TCHAR   ExcludeTag   = TEXT('!');
TCHAR   IncAllTag    = TEXT('@');
TCHAR   NoIncTag     = TEXT('*');

#define TAG_PREFIX_LENGTH       1
#define MIN_TAG_LEN             3
#define EXCLUDE_PREFIX_LENGTH   2               // ! Prefix Length (!n)

//
// Here is the translation for the character symbols used in IncludeTag
// and SynonymTag.
//
//      products:
//          @w -> wks
//          @s -> srv
//          @p -> personal (NOT professional)
//          @t -> tablet
//          @b -> blade server
//	        @l -> small business server
//          @e -> enterprise
//          @d -> datacenter
//
//      architectures:
//          @i -> intel (i386)
//          @n -> intel (nec98)
//          @m -> intel (ia64)
//          @a -> AMD64 (amd64)
//
//      Note that @n is a subset of @i.  If @i is specified then you also
//          get the file include for @n unless you explicitly exclude them
//          with a token like @i!n
//
//          @3 -> 32 bit  (i386+?)
//          @6 -> 64 bit  (ia64+amd64)
//
TCHAR IncludeTag[][3] =   {
    { TEXT('i'), TEXT('n'), 0},   // @i -> i or n, @i!n -> only i
    { TEXT('s'), TEXT('e'), 0},   // @s -> s or e, @s!e -> only s
    { TEXT('s'), TEXT('b'), 0},   // @s -> s or b, @s!b -> only s
    { TEXT('s'), TEXT('d'), 0},
    { TEXT('s'), TEXT('l'), 0},
    { TEXT('e'), TEXT('d'), 0},
    { TEXT('w'), TEXT('p'), 0},
    { TEXT('w'), TEXT('t'), 0},
    { 0        , 0        , 0}
};


TCHAR SynonymTag[][2]   = {
    { TEXT('3'), TEXT('i')},
    { TEXT('6'), TEXT('a')},
    { TEXT('6'), TEXT('m')},
    { 0, 0}
};

LPCTSTR InName,OutName;
TCHAR Filter;

BOOL
FileExists(
          IN  PCTSTR           FileName,
          OUT PWIN32_FIND_DATA FindData   OPTIONAL
          )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if (FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

void
StripCommentsFromLine(
                     TCHAR *Line
                     )
/*

Routine Description:

    Strips comments (; Comment) from a line respecting ; inside quotes

Arguments:

    Line - POinter to Line to process


*/
{
    PWSTR p;

    BOOL Done = FALSE, InQuotes = FALSE;

    //
    // we need to insert a  NULL at the first ';' we find,
    // thereby stripping the comments
    //

    p = Line;

    if ( !p )
        return;

    while (*p && !Done) {

        switch (*p) {
            case TEXT(';'):
                if ( !InQuotes ) {
                    *p=L'\r';
                    *(p+1)=L'\n';
                    *(p+2)=L'\0';
                    Done = TRUE;
                }
                break;

            case TEXT('\"'):
                if ( *(p+1) && (*(p+1) == TEXT('\"'))) // Ignore double-quoting as inside quotes
                    p++;
                else
                    InQuotes = !InQuotes;

            default:
                ;

        }

        p++;


    }// while

    return;

}




DWORD
MakeSurePathExists(
                  IN PCTSTR FullFilespec
                  )

/*++

Routine Description:

    This routine ensures that a multi-level path exists by creating individual
    levels one at a time. It is assumed that the caller will pass in a *filename*
    whose path needs to exist. Some examples:

    c:\x                        - C:\ is assumes to always exist.

    c:\x\y\z                    - Ensure that c:\x\y exists.

    \x\y\z                      - \x\y on current drive

    x\y                         - x in current directory

    d:x\y                       - d:x

    \\server\share\p\file       - \\server\share\p

Arguments:

    FullFilespec - supplies the *filename* of a file that the caller wants to
        create. This routine creates the *path* to that file, in other words,
        the final component is assumed to be a filename, and is not a
        directory name. (This routine doesn't actually create this file.)
        If this is invalid, then the results are undefined (for example,
        passing \\server\share, C:\, or C:).

Return Value:

    Win32 error code indicating outcome. If FullFilespec is invalid,
    *may* return ERROR_INVALID_NAME.

--*/

{
    TCHAR Buffer[MAX_PATH];
    PTCHAR p,q;
    BOOL Done;
    DWORD d;
    WIN32_FIND_DATA FindData;

    //
    // The first thing we do is locate and strip off the final component,
    // which is assumed to be the filename. If there are no path separator
    // chars then assume we have a filename in the current directory and
    // that we have nothing to do.
    //
    // Note that if the caller passed an invalid FullFilespec then this might
    // hose us up. For example, \\x\y will result in \\x. We rely on logic
    // in the rest of the routine to catch this.
    //
    lstrcpyn(Buffer,FullFilespec,MAX_PATH);
    if (Buffer[0] && (p = _tcsrchr(Buffer,TEXT('\\'))) && (p != Buffer)) {
        *p = 0;
    } else {
        return (NO_ERROR);
    }

    if (Buffer[0] == TEXT('\\')) {
        if (Buffer[1] == TEXT('\\')) {
            //
            // UNC. Locate the second component, which is the share name.
            // If there's no share name then the original FullFilespec
            // was invalid. Finally locate the first path-sep char in the
            // drive-relative part of the name. Note that there might not
            // be such a char (when the file is in the root). Then skip
            // the path-sep char.
            //
            if (!Buffer[2] || (Buffer[2] == TEXT('\\'))) {
                return (ERROR_INVALID_NAME);
            }
            p = _tcschr(&Buffer[3],TEXT('\\'));
            if (!p || (p[1] == 0) || (p[1] == TEXT('\\'))) {
                return (ERROR_INVALID_NAME);
            }
            if (q = _tcschr(p+2,TEXT('\\'))) {
                q++;
            } else {
                return (NO_ERROR);
            }
        } else {
            //
            // Assume it's a local root-based local path like \x\y.
            //
            q = Buffer+1;
        }
    } else {
        if (Buffer[1] == TEXT(':')) {
            //
            // Assume c:x\y or maybe c:\x\y
            //
            q = (Buffer[2] == TEXT('\\')) ? &Buffer[3] : &Buffer[2];
        } else {
            //
            // Assume path like x\y\z
            //
            q = Buffer;
        }
    }

    //
    // Ignore drive roots.
    //
    if (*q == 0) {
        return (NO_ERROR);
    }

    //
    // If it already exists do nothing.
    //
    if (FileExists(Buffer,&FindData)) {
        return ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? NO_ERROR : ERROR_DIRECTORY);
    }

    Done = FALSE;
    do {
        //
        // Locate the next path sep char. If there is none then
        // this is the deepest level of the path.
        //
        if (p = _tcschr(q,TEXT('\\'))) {
            *p = 0;
        } else {
            Done = TRUE;
        }

        //
        // Create this portion of the path.
        //
        if (CreateDirectory(Buffer,NULL)) {
            d = NO_ERROR;
        } else {
            d = GetLastError();
            if (d == ERROR_ALREADY_EXISTS) {
                d = NO_ERROR;
            }
        }

        if (d == NO_ERROR) {
            //
            // Put back the path sep and move to the next component.
            //
            if (!Done) {
                *p = TEXT('\\');
                q = p+1;
            }
        } else {
            Done = TRUE;
        }

    } while (!Done);

    return (d);
}

BOOL
ParseArgs(
         IN  int   argc,
         IN  TCHAR *argv[],
         OUT BOOL  *Unicode,
         OUT BOOL  *StripComments
         )
{
    int argoffset = 0;
    int loopcount;

    *Unicode = FALSE;
    *StripComments = FALSE;

    if (argc == 5) {
        //
        // 1 switch possible
        //
        argoffset = 1;
        loopcount = 1;
    } else if (argc == 6) {
        //
        // 2 switches possible
        //
        argoffset = 2;
        loopcount = 2;
    } else if (argc != 4) {
        return (FALSE);
    } else {
        argoffset = 0;
    }

    if ((argc == 5) || (argc == 6)) {
        int i;
        for (i=0; i< loopcount; i++) {
            if (!_tcsicmp(argv[i+1],TEXT("/u")) || !_tcsicmp(argv[i+1],TEXT("-u"))) {
                *Unicode = TRUE;
            }

            if (!_tcsicmp(argv[i+1],TEXT("/s")) || !_tcsicmp(argv[i+1],TEXT("-s"))) {
                *StripComments = TRUE;
            }
        }

    }

    InName = argv[1+argoffset];
    OutName = argv[2+argoffset];
    Filter = argv[3+argoffset][1];

    if (argv[3+argoffset][0] != TEXT('+')) {
        return (FALSE);
    }

    return (TRUE);
}


BOOL
DoTagsMatch(
           IN TCHAR LineChar,
           IN TCHAR Tag
           )
{
    int     i, j;
    BOOL    ReturnValue = FALSE;
    BOOL    TagIsInList = FALSE;
    BOOL    LineCharIsInList = FALSE;

    //
    // If they match, we're done.
    //
    if ( LineChar == Tag ) {
        ReturnValue = TRUE;
    } else {

        //
        // Nope.  See if we can match a synonym tag.
        //
        i = 0;
        while ( SynonymTag[i][0] ) {

            TagIsInList = FALSE;
            LineCharIsInList = FALSE;

            for ( j = 0; j < 2; j++ ) {
                if ( Tag == SynonymTag[i][j] ) {
                    TagIsInList = TRUE;
                }

                if ( LineChar == SynonymTag[i][j] ) {
                    LineCharIsInList = TRUE;
                }
            }

            if ( TagIsInList && LineCharIsInList ) {
                ReturnValue = TRUE;
            }

            i++;
        }
    }

    return ReturnValue;
}

BOOL
DoFilter(
        IN FILE *InputFile,
        IN FILE *OutputFile,
        IN TCHAR  Tag,
        IN BOOL UnicodeFileIO,
        IN BOOL StripComments
        )
{
    TCHAR Line[1024];
    TCHAR *OutputLine;
    BOOL  FirstLine=TRUE;
    BOOL  WriteUnicodeHeader = TRUE;

    while (!feof(InputFile)) {
        //
        // read a line of data.  if we're doing unicode IO, we just read the
        // data and use it otherwise we need to read the data and
        //
        if (UnicodeFileIO) {
            if (!fgetws(Line,sizeof(Line)/sizeof(Line[0]),InputFile)) {
                if (ferror(InputFile)) {
                    _ftprintf(stderr,TEXT("Error reading from input file\n"));
                    return (FALSE);
                } else {
                    return (TRUE);
                }
            }

            //
            // Skip byte order mark if present
            //
            if (FirstLine) {
                if (Line[0] == 0xfeff) {
                    MoveMemory(Line,Line+1,sizeof(Line)-sizeof(TCHAR));
                }
            }

        } else {
            char LineA[1024];
            if (!fgets(LineA,sizeof(LineA),InputFile)) {
                if (ferror(InputFile)) {
                    _ftprintf(stderr,TEXT("Error reading from input file\n"));
                    return (FALSE);
                } else {
                    return (TRUE);
                }
            }

            if (!MultiByteToWideChar(
                                    CP_ACP,
                                    MB_PRECOMPOSED,
                                    LineA,
                                    -1,
                                    Line,
                                    sizeof(Line)/sizeof(WCHAR)
                                    )) {
                _ftprintf(stderr,TEXT("Error reading input file\n"));
                return (FALSE);
            }

        }

        //
        // ok, we've retreived the line.  now let's see if we want to output
        // the line.
        //
        OutputLine = Line;

        //
        // if the line is too short, then we just want to include it no matter
        // what.
        //
        if (_tcslen(Line) >= MIN_TAG_LEN) {

            int i;

            //
            // if the line starts with our tag, then we need to look further
            // to see if it should be filtered.
            //
            if (!_tcsncmp(Line,TagPrefixStr,TAG_PREFIX_LENGTH)) {

                //
                // is the symbol string an @<char>: combination?
                //
                if (Line[TAG_PREFIX_LENGTH+1] == EndTag) {

                    OutputLine = NULL;

                    //
                    // Do we have @@: or @<char>:, where <char> matches the tag
                    // prodfilt was invoked with?
                    //
                    if ( (Line[TAG_PREFIX_LENGTH] == IncAllTag)  ||
                         DoTagsMatch(Line[TAG_PREFIX_LENGTH],Tag) ||
                         (Tag == IncAllTag &&
                          (Line[TAG_PREFIX_LENGTH] != NoIncTag)) ) {

                        //
                        // Yes.  Include this line.
                        //

                        OutputLine = Line+MIN_TAG_LEN;
                    } else {

                        //
                        // we don't have an explicit match, so let's look to
                        // see if we have a match by virtue of another tag
                        // including our tag
                        //
                        // To do this, we look at the include tag list to see
                        // if the line matches the head of an include tag
                        // entry.  If we have a match, then we check if we have
                        // a match in the specified inclusion entry for our tag
                        // (or one if it's synonyms)
                        //
                        //
                        int j;
                        i = 0;
                        while (IncludeTag[i][0] && !OutputLine) {
                            j = 1;
                            if (DoTagsMatch(Line[TAG_PREFIX_LENGTH],
                                            IncludeTag[i][0])) {
                                //
                                // we found a match at the start of an include
                                // entry.
                                //
                                while (IncludeTag[i][j]) {
                                    if (DoTagsMatch(
                                                   IncludeTag[i][j],
                                                   Tag)) {
                                        //
                                        // We found an included match for our
                                        // tag.  Include this line.
                                        //

                                        OutputLine = Line+MIN_TAG_LEN;
                                        break;
                                    }

                                    j++;

                                }
                            }
                            i++;
                        }
                    }

                    //
                    // is the line long enough to have an @<char>!<char> sequence?
                    //
                } else if (_tcslen(Line) >=
                           (MIN_TAG_LEN+EXCLUDE_PREFIX_LENGTH)) {

                    //
                    // Does the line have @<char>!<char> syntax?
                    //
                    if (Line[TAG_PREFIX_LENGTH+1] == ExcludeTag) {
                        TCHAR *  tmpPtr = &Line[TAG_PREFIX_LENGTH+1];

                        OutputLine = NULL;
                        //
                        // We have @<char_a>!<char_b> syntax.  We first need to
                        // see if the line is included by virtue of <char_a>.
                        //
                        // If that succeeds, then we proceed onto reading the
                        // !<char>!<char> block, looking for another hit.
                        //

                        //
                        // do we have an explicit match?
                        //
                        if ( Line[TAG_PREFIX_LENGTH] == IncAllTag ||
                             DoTagsMatch(Line[TAG_PREFIX_LENGTH],Tag) ||
                             (Tag == IncAllTag &&
                              Line[TAG_PREFIX_LENGTH] != NoIncTag) ) {

                            //
                            // Yes, we have an explicit match.  Remember this
                            // so we can parse the !<char> sequence.
                            //

                            OutputLine = Line+MIN_TAG_LEN;
                        } else {

                            //
                            // we don't have an explicit match, so let's look to
                            // see if we have a match by virtue of another tag
                            // including our tag
                            //
                            // To do this, we look at the include tag list to
                            // see if the line matches the head of an include
                            // tag entry.  If we have a match, then we check if
                            // we have a match in the specified inclusion entry
                            // for our tag (or one if it's synonyms)
                            //
                            //
                            int j;
                            i = 0;
                            while (IncludeTag[i][0] && !OutputLine) {
                                j = 1;
                                if (DoTagsMatch(Line[TAG_PREFIX_LENGTH],
                                                IncludeTag[i][0])) {
                                    //
                                    // we found a match at the start of an
                                    // include entry.
                                    //
                                    while (IncludeTag[i][j]) {
                                        if (DoTagsMatch(
                                                       IncludeTag[i][j],
                                                       Tag)) {
                                            //
                                            // We found an included match for
                                            // our tag.  Include this line.
                                            //

                                            OutputLine = Line+MIN_TAG_LEN;
                                            break;
                                        }

                                        j++;

                                    }
                                }
                                i++;
                            }
                        }


                        if (!OutputLine) {
                            //
                            // We didn't match teh initial @<char> sequence, so
                            // there is no need to check further.  goto the
                            // next line.
                            //
                            goto ProcessNextLine;

                        }


                        //
                        // The line has !<char>[!<char>] combination
                        // Loop through the chain of exclude chars and see if
                        // we have any hits.  if we do, then we go onto the
                        // next line.
                        //
                        while (tmpPtr[0] == ExcludeTag) {

                            //
                            // do we have an explicit match?
                            //
                            if ( (tmpPtr[TAG_PREFIX_LENGTH] == IncAllTag) ||
                                 DoTagsMatch(tmpPtr[TAG_PREFIX_LENGTH],Tag) ) {

                                //
                                // We have an explicit match, so we know we
                                // do not want to include this line.
                                //
                                //
                                OutputLine = NULL;
                                goto ProcessNextLine;
                            } else {

                                //
                                // we don't have an explicit match, so let's
                                // look to see if we have a match by virtue
                                // of another tag including our tag
                                //
                                // To do this, we look at the include tag list
                                // to see if the line matches the head of an
                                // include tag entry.  If we have a match, then
                                // we check if we have a match in the specified
                                // inclusion entry for our tag (or one if it's
                                // synonyms)
                                //
                                //
                                int j;
                                i = 0;
                                while (IncludeTag[i][0]) {
                                    j = 1;
                                    if (DoTagsMatch(
                                                   tmpPtr[TAG_PREFIX_LENGTH],
                                                   IncludeTag[i][0])) {
                                        //
                                        // we found a match at the start of an
                                        // include entry.
                                        //
                                        while (IncludeTag[i][j]) {

                                            if (DoTagsMatch(
                                                           IncludeTag[i][j],
                                                           Tag)) {
                                                //
                                                // We found an included match
                                                // for our tag, so we know we
                                                // do not want to include this
                                                // line.
                                                //

                                                OutputLine = NULL;
                                                goto ProcessNextLine;
                                            }

                                            j++;

                                        }
                                    }
                                    i++;
                                }
                            }

                            tmpPtr += 2;

                        }

                        //
                        // Done parsing the @<char>!<char>!<char>!... tokens.
                        // Look for the terminator
                        //

                        if (tmpPtr[0] != EndTag) {

                            //
                            // Malformed tokens.  Let's error on the
                            // conservative side and include the whole line.
                            //

                            OutputLine = Line;

                        } else {

                            //
                            // Didn't find any exclusions, so include the tag.
                            //

                            OutputLine = &tmpPtr[1];
                        }
                    }
                }
            }
        }

        ProcessNextLine:

        //
        // write out the line if we're supposed to.  for unicode io we just
        // write the file.  for ansi i/o we have to convert back to ansi
        //
        if (OutputLine) {

            if (StripComments) {
                StripCommentsFromLine( OutputLine );
            }

            if (UnicodeFileIO) {

                if (WriteUnicodeHeader) {
                    fputwc(0xfeff,OutputFile);
                    WriteUnicodeHeader = FALSE;
                }

                if (fputws(OutputLine,OutputFile) == EOF) {
                    _ftprintf(stderr,TEXT("Error writing to output file\n"));
                    return (FALSE);
                }
            } else {
                CHAR OutputLineA[1024];

                if (!WideCharToMultiByte(
                                        CP_ACP,
                                        0,
                                        OutputLine,
                                        -1,
                                        OutputLineA,
                                        sizeof(OutputLineA)/sizeof(CHAR),
                                        NULL,
                                        NULL)) {
                    _ftprintf(
                             stderr,
                             TEXT("Error translating string for output file\n") );
                    return (FALSE);
                }

                if (!fputs(OutputLineA,OutputFile) == EOF) {
                    _ftprintf(stderr,TEXT("Error writing to output file\n"));
                    return (FALSE);
                }

            }

        }
    }

    if (ferror(InputFile)) {
        _ftprintf(stderr,TEXT("Error reading from input file\n"));
        return (FALSE);
    }

    return (TRUE);
}

int
__cdecl
_tmain(
      IN int   argc,
      IN TCHAR *argv[]
      )
{
    FILE *InputFile;
    FILE *OutputFile;
    BOOL b;
    BOOL Unicode,StripComments;

    //
    // Assume failure.
    //
    b = FALSE;

    if (ParseArgs(argc,argv,&Unicode,&StripComments)) {

        //
        // Open the files. Have to open in binary mode or else
        // CRT converts unicode text to mbcs on way in and out.
        //
        if (InputFile = _tfopen(InName,TEXT("rb"))) {

            if (MakeSurePathExists(OutName) == NO_ERROR) {

                if (OutputFile = _tfopen(OutName,TEXT("wb"))) {

                    //
                    // Do the filtering operation.
                    //
                    _ftprintf(stdout,
                              TEXT("%s: filtering %s to %s\n"),
                              argv[0],
                              InName,
                              OutName);

                    b = DoFilter(InputFile,
                                 OutputFile,
                                 Filter,
                                 Unicode,
                                 StripComments);

                    fclose(OutputFile);

                } else {
                    _ftprintf(stderr,
                              TEXT("%s: Unable to create output file %s\n"),
                              argv[0],
                              OutName);
                }

            } else {
                _ftprintf(stderr,
                          TEXT("%s: Unable to create output path %s\n"),
                          argv[0],
                          OutName);
            }

            fclose(InputFile);

        } else {
            _ftprintf(stderr,
                      TEXT("%s: Unable to open input file %s\n"),
                      argv[0],
                      InName);
        }
    } else {
        _ftprintf(stderr,
                  TEXT("Usage: %s [-u (unicode IO)] [-s (strip comments)] <input file> <output file> +<prodtag>\n"),
                  argv[0]);
    }

    return (b ? SUCCESS : FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\recab\recab.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    recab.c

Abstract:

    This module implements a program that determines the files in an INF that
    are newer than the a given file and writes these into a file.

    The input consists of a target inf (drvindex.inf), and a target file;
    the output consists of an inf file.

Author:

    Andrew Ritz (andrewr) 2-Feb-1999

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <setupapi.h>
#define PULONGLONG PDWORDLONG
#include <sputils.h>


//
// Define program result codes (returned from main()).
//
#define SUCCESS 0
#define FAILURE 1


//
// Keep statistics...
//
INT     ProcessedLines = 0;

BOOL
ParseArgs(
    IN int   argc,
    IN char *argv[]
    )
{
    return(argc == 5);
}


BOOL
IsFileNewer(
    IN PCWSTR SourceName,
    IN PWIN32_FIND_DATAW TargetFileData
    )
{
    WIN32_FIND_DATAW SourceFileData;
    HANDLE SourceHandle;
    LARGE_INTEGER SourceFileTime,TargetFileTime;

    SourceHandle = FindFirstFileW( SourceName, &SourceFileData );
    if (SourceHandle == INVALID_HANDLE_VALUE) {
    fprintf(stderr, TEXT("Error finding file %ws (%d)\n"), SourceName, GetLastError() );
        return(FALSE);
    }

    SourceFileTime.LowPart  = SourceFileData.ftLastWriteTime.dwLowDateTime;
    SourceFileTime.HighPart = SourceFileData.ftLastWriteTime.dwHighDateTime;
    TargetFileTime.LowPart  = TargetFileData->ftLastWriteTime.dwLowDateTime;
    TargetFileTime.HighPart = TargetFileData->ftLastWriteTime.dwHighDateTime;

    FindClose(SourceHandle);

    return (SourceFileTime.QuadPart > TargetFileTime.QuadPart) ;

}



BOOL
DoSection(
    IN HINF    hInputInf,
    IN PCWSTR  InputSectionName,
    IN FILE   *OutFile,
    IN PWIN32_FIND_DATAW TargetFileData
    )
{
    DWORD SectionCount, i;
    INFCONTEXT InputContext;
    UCHAR      line[4096];
    WCHAR      SourceFileName[MAX_PATH];

    SectionCount = SetupGetLineCountW(hInputInf,InputSectionName);

    for (i = 0; i < SectionCount; i++) {
        if (SetupGetLineByIndexW(hInputInf, InputSectionName, i, &InputContext)) {
            if(SetupGetStringFieldW(&InputContext,0,SourceFileName,MAX_PATH,NULL)) {
                if (IsFileNewer(SourceFileName,TargetFileData)) {
                    WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        SourceFileName,
                        -1,
                        line,
                        sizeof(line),
                        NULL,
                        NULL
                        );

                    fprintf(OutFile, TEXT("%s\n"),line);
                 } else if (GetLastError() != NO_ERROR) {
                    fprintf(stderr, TEXT("IsFileNewer failed\n"));
                    return(FALSE);
                 }
             } else {
                 fprintf(stderr, TEXT("SetupGetStringField failed, ec = %d\n"), GetLastError());
                 return(FALSE);
             }
        } else {
            fprintf(stderr, TEXT("SetupGetLineByIndex failed, ec = %d\n"), GetLastError());
            return(FALSE);
        }
        ProcessedLines += 1;
    }

    return(TRUE);
}

BOOL
DoIt(
    IN char *InfName,
    IN char *TargetFileNameA,
    IN char *cwd,
    IN FILE *OutFile
    )
{
    PCWSTR infFilename;
    PCWSTR TargetFileName;
    HINF hInputinf;
    BOOL b;
    WCHAR sectionName[256];
    PWSTR p;
    INFCONTEXT InfContext;
    WIN32_FIND_DATAW TargetFileData;
    HANDLE TargetHandle;

    b = FALSE;

    infFilename = pSetupAnsiToUnicode(InfName);
    TargetFileName = pSetupAnsiToUnicode(TargetFileNameA);

    //
    // Only proceed if we've got a file to work with.
    //
    if( infFilename ) {
        hInputinf = SetupOpenInfFileW(infFilename,NULL,INF_STYLE_WIN4,NULL);
        if(hInputinf != INVALID_HANDLE_VALUE) {

            SetCurrentDirectory(cwd);

            TargetHandle = FindFirstFileW( TargetFileName, &TargetFileData );
            if ( TargetHandle == INVALID_HANDLE_VALUE ) {
                fprintf( stderr, TEXT(" couldn't findfirstfile %ws, %d\n "),TargetFileName,GetLastError());
                    SetupCloseInfFile(hInputinf);
                return(FALSE);
            }

        fprintf(OutFile,"[Version]\n");
        fprintf(OutFile,"signature=\"$Windows NT$\"\n\n");
                fprintf(OutFile,"[Files]\n");
        p = wcsrchr( TargetFileName, L'\\' );
        if (!p) {
            p = (PWSTR)TargetFileName;
        } else {
            p++;
        }
        wcscpy(sectionName,p);
        p=wcsrchr(sectionName,L'.');
        if (p) {
           *p = 0;
        }

                b = DoSection( hInputinf,
                               sectionName,
                               OutFile,
                               &TargetFileData );

                //
                // Print Statistics...
                //
                fprintf( stderr, "                               Total lines processed: %6d\n", ProcessedLines );

                //
                // Close up our inf handles.
                //
                SetupCloseInfFile(hInputinf);

            } else {
                fprintf(stderr,"Unable to open inf file %ws %d\n",infFilename, GetLastError());
            }

        } else {
            fprintf(stderr,"Unable to convert filename %s to Unicode %d\n",InfName, GetLastError());
        }
        pSetupFree(infFilename);

    return(b);
}


int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    FILE *OutputFile;
    BOOL b;

    //
    // Assume failure.
    //
    b = FALSE;

    if(!pSetupInitializeUtils()) {
        return FAILURE;
    }

    if(ParseArgs(argc,argv)) {

        //
        // Open the output file.
        //
        OutputFile = fopen(argv[4],"wt");
        if(OutputFile) {

            fprintf(stdout,"%s: creating %s from %s and %s\n",argv[0],argv[4],argv[1],argv[2]);
            b = DoIt( argv[1],
                      argv[2],
                      argv[3],
                      OutputFile
                    );

            fclose(OutputFile);

        } else {
            fprintf(stderr,"%s: Unable to create output file %s\n",argv[0],argv[3]);
        }
    } else {
        fprintf( stderr,"generate file with newer dependencies.  Usage:\n" );
        fprintf( stderr,"%s  <inf file> <file> <directory> <output file>\n", argv[0] );
        fprintf( stderr,"\n" );
        fprintf( stderr,"  <inf file>    - inf containing list of dependencies\n" );
        fprintf( stderr,"  <file>        - contains the file to compare against.\n" );
        fprintf( stderr,"  <directory>   - directory where the files live.\n" );
        fprintf( stderr,"  <output file> - output inf with newer dependencies\n" );
        fprintf( stderr,"\n" );
        fprintf( stderr,"\n" );

    }

    pSetupUninitializeUtils();

    return(b ? SUCCESS : FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\inftest\syntax.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    inf.c

Abstract:

    This module implements functions to access the INF using the same
    parser as the loader and textmode setup.

Author:

    Vijesh Shetty

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
//#include <string.h>
//#include <ctype.h>

#define ISSPACE(x)          (((x) == TEXT(' ')) || ((x) == TEXT('\t')) || ((x) == TEXT('\r')))
#define STRNCPY(s1,s2,n)    CopyMemory((s1),(s2),(n)*sizeof(WCHAR))



//
//   EXPORTED BY THE PARSER AND USED BY BOTH THE PARSER AND
//   THE INF HANDLING COMPONENTS
//


// typedefs exported
//

DWORD Verbose=NOSPEW;



PTCHAR EmptyValue;

typedef struct _value {
    struct _value *pNext;
    PTSTR  pName;
    BOOL   IsStringId;
} XVALUE, *PXVALUE;

typedef struct _line {
    struct _line *pNext;
    PTSTR   pName;
    PXVALUE  pValue;
} LINE, *PLINE;

typedef struct _section {
    struct _section *pNext;
    PTSTR    pName;
    PLINE    pLine;
} SECTION, *PSECTION;

typedef struct _inf {
    PSECTION pSection;
} INF, *PINF;


DWORD
ParseInfBuffer(
    PTSTR Buffer,
    DWORD Size,
    PVOID *Handle,
    DWORD Phase
    );

//
// DEFINES USED FOR THE PARSER INTERNALLY
//
//
// typedefs used
//

typedef enum _tokentype {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_STRING_ID,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
    } TOKENTYPE, *PTOKENTTYPE;

//
// We often need an empty string while processing the inf files.  Rather
// than incur the overhead of allocating memory for an empty string, we'll
// just point to this empty string for all cases.
//
PTSTR  CommonStrings[11] =
    { (PTSTR)(TEXT("0")),
      (PTSTR)(TEXT("1")),
      (PTSTR)(TEXT("2")),
      (PTSTR)(TEXT("3")),
      (PTSTR)(TEXT("4")),
      (PTSTR)(TEXT("5")),
      (PTSTR)(TEXT("6")),
      (PTSTR)(TEXT("7")),
      (PTSTR)(TEXT("8")),
      (PTSTR)(TEXT("9")),
      (PTSTR)(TEXT(""))
    };



typedef struct _token {
    TOKENTYPE Type;
    PTSTR     pValue;
    } TOKEN, *PTOKEN;


//
// Routine defines
//

DWORD
DnAppendSection(
    IN PTSTR pSectionName
    );

DWORD
DnAppendLine(
    IN PTSTR pLineKey
    );

DWORD
DnAppendValue(
    IN PTSTR pValueString,
    IN BOOL IsStringId
    );

TOKEN
DnGetToken(
    IN OUT PTSTR *Stream,
    IN PTSTR     MaxStream,
    IN DWORD      Phase
    );

BOOL
IsStringTerminator(
   IN TCHAR ch
   );

BOOL
IsQStringTerminator(
   IN TCHAR ch,
   IN TCHAR term
   );

// what follows was alinf.c

//
// Internal Routine Declarations for freeing inf structure members
//

VOID
FreeSectionList (
   IN PSECTION pSection
   );

VOID
FreeLineList (
   IN PLINE pLine
   );

VOID
FreeValueList (
   IN PXVALUE pValue
   );


//
// Internal Routine declarations for searching in the INF structures
//


PXVALUE
SearchValueInLine(
   IN PLINE pLine,
   IN unsigned ValueIndex
   );

PLINE
SearchLineInSectionByKey(
   IN PSECTION pSection,
   IN LPCTSTR  Key
   );

PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN unsigned    LineIndex
   );

PSECTION
SearchSectionByName(
   IN PINF    pINF,
   IN LPCTSTR SectionName
   );

BOOL
ProcessStringSection(
    PINF pINF
    );

LPTSTR
DupString(
    IN LPCTSTR String
    );



DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    );

DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );




DWORD
LoadInfFile(
   IN  LPCTSTR Filename,
   IN  BOOL    OemCodepage,
   OUT PVOID  *InfHandle,
   IN  DWORD Phase
   )

/*++

Routine Description:

Arguments:

    Filename - supplies win32 filename of inf file to be loaded.

    OemCodepage - if TRUE amd the file named by Filename is not
        Unicode text, then the file is assumed to be in the OEM
        codepage (otherwise it's in the ANSI codepage).

    InfHandle - if successful, receives a handle to be used with
        subsequent inf operations.

Return Value:

    ERROR_FILE_NOT_FOUND - file does not exist or error opening it.
    ERROR_INVALID_DATA - syntax error in inf file.
    ERROR_READ_FAULT - unable to read file.
    ERROR_NOT_ENOUGH_MEMORY - mem alloc failed
    NO_ERROR - file read and parsed.

--*/

{
    DWORD err;
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID BaseAddress;
    BOOL IsUnicode;

    DWORD ParseCount;
    PVOID ParseBuffer;

    //
    // Open and map the inf file.
    //
    err = MapFileForRead(Filename,&FileSize,&FileHandle,&MappingHandle,&BaseAddress);
    if(err != NO_ERROR) {
        err = ERROR_FILE_NOT_FOUND;
        goto c0;
    }

    //
    // Determine whether the file is unicode. If it's got the byte order mark
    // then it's unicode, otherwise call the IsTextUnicode API. We do it this way
    // because IsTextUnicode always returns FALSE on Win95 so we need to break out
    // the BOM to detect Unicode files on Win95.
    //
    if((FileSize >= sizeof(WCHAR)) && (*(PWCHAR)BaseAddress == 0xfeff)) {
        IsUnicode = 2;
    } else {
        IsUnicode = IsTextUnicode(BaseAddress,FileSize,NULL) ? 1 : 0;
    }

#ifdef UNICODE
    if(IsUnicode) {
        //
        // Copy into local buffer, skipping BOM if necessary.
        //
        ParseBuffer = malloc(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {

            CopyMemory(
                ParseBuffer,
                (PTCHAR)BaseAddress + ((IsUnicode == 2) ? sizeof(WCHAR) : 0),
                FileSize - ((IsUnicode == 2) ? sizeof(WCHAR) : 0)
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }

        ParseCount = (FileSize / sizeof(WCHAR)) - ((IsUnicode == 2) ? 1 : 0);

    } else {
        //
        // Convert to Unicode.
        //
        // Allocate a buffer large enough to hold the maximum sized unicode
        // equivalent of the multibyte text.  This size occurs when all chars
        // in the file are single-byte and thus double in size when converted.
        //
        ParseBuffer = malloc(FileSize * sizeof(WCHAR));
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            ParseCount = MultiByteToWideChar(
                            OemCodepage ? CP_OEMCP : CP_ACP,
                            MB_PRECOMPOSED,
                            BaseAddress,
                            FileSize,
                            ParseBuffer,
                            FileSize
                            );

            if(!ParseCount) {
                //
                // Assume inpage i/o error
                //
                err = ERROR_READ_FAULT;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }
    }
#else
    if(IsUnicode) {
        //
        // Text is unicode but internal routines want ansi. Convert here.
        //
        // Maximum required buffer is when each unicode char ends up as
        // a double-byte char.
        //
        ParseBuffer = malloc(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            ParseCount = WideCharToMultiByte(
                            CP_ACP,
                            0,
                            (PWCHAR)BaseAddress + ((IsUnicode == 2) ? 1 : 0),
                            (FileSize / sizeof(WCHAR)) - ((IsUnicode == 2) ? 1 : 0),
                            ParseBuffer,
                            FileSize,
                            NULL,
                            NULL
                            );

            if(!ParseCount) {
                //
                // Assume inpage i/o error
                //
                err = ERROR_READ_FAULT;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }
    } else {
        //
        // Text is not unicode. It might be OEM though and could thus still
        // require translation.
        //
        ParseCount = FileSize;
        ParseBuffer = malloc(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            CopyMemory(ParseBuffer,BaseAddress,FileSize);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }

        if(err != NO_ERROR) {
            goto c2;
        }

        if(OemCodepage && (GetOEMCP() != GetACP())) {
            OemToCharBuff(ParseBuffer,ParseBuffer,ParseCount);
        }
    }
#endif

    if(err != NO_ERROR) {
        goto c2;
    }

    /*_tprintf(TEXT("\nCalling ParseInfBuffer..\n"));*/
    err = ParseInfBuffer(ParseBuffer,ParseCount,InfHandle,Phase);

    /*_tprintf(TEXT("\nErr=%d\n"),err);*/

    

c2:
    free(ParseBuffer);
c1:
    UnmapFile(MappingHandle,BaseAddress);
    CloseHandle(FileHandle);
c0:
    return(err);
}


VOID
UnloadInfFile(
   IN PVOID InfHandle
   )

/*++

Routine Description:

    Unload a file previously loaded by LoadInfFile().

Arguments:

    InfHandle - supplies a habdle previously returned by a successful
        call to LoadInfFile().

Return Value:

    None.

--*/

{
   PINF pINF;

   pINF = InfHandle;

   FreeSectionList(pINF->pSection);
   free(pINF);
}


VOID
FreeSectionList (
   IN PSECTION pSection
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PSECTION Next;

    while(pSection) {
        Next = pSection->pNext;
        FreeLineList(pSection->pLine);
        if(pSection->pName) {
            free(pSection->pName);
        }
        free(pSection);
        pSection = Next;
    }
}


VOID
FreeLineList(
   IN PLINE pLine
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PLINE Next;

    while(pLine) {
        Next = pLine->pNext;
        FreeValueList(pLine->pValue);
        if(pLine->pName) {
            free(pLine->pName);
        }
        free(pLine);
        pLine = Next;
    }
}

VOID
FreeValueList (
   IN PXVALUE pValue
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PXVALUE Next;

    while(pValue) {
        Next = pValue->pNext;
        if(pValue->pName) {
            free(pValue->pName);
        }
        free(pValue);
        pValue = Next;
    }
}


//
// searches for the existance of a particular section,
// returns line count (-1 if not found)
//
LONG
InfGetSectionLineCount(
   IN PVOID INFHandle,
   IN PTSTR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE pLine;
   LONG count;

   //
   // if search for section fails return failure
   //
   if ((pSection = SearchSectionByName(INFHandle,SectionName)) == NULL) {
       return(-1);
   }

   for(count=0,pLine=pSection->pLine; pLine; pLine=pLine->pNext) {
       count++;
   }

   return(count);
}




//
// given section name, line number and index return the value.
//
LPCTSTR
InfGetFieldByIndex(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN unsigned LineIndex,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PXVALUE   pValue;

   if((pSection = SearchSectionByName(
                    (PINF)INFHandle,
                    SectionName
                    ))
                == NULL)
        return(NULL);

   if((pLine = SearchLineInSectionByIndex(
                    pSection,
                    LineIndex
                    ))
                == NULL)
        return(NULL);

   if((pValue = SearchValueInLine(
                    pLine,
                    ValueIndex
                    ))
                == NULL)
        return(NULL);

   return (pValue->pName);
}


BOOL
InfDoesLineExistInSection(
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   if((pSection = SearchSectionByName(
              (PINF)INFHandle,
              SectionName
              ))
              == NULL) {
       return( FALSE );
   }

   if (SearchLineInSectionByKey(pSection, Key) == NULL) {
       return( FALSE );
   }

   return( TRUE );
}


LPCTSTR
InfGetLineKeyName(
    IN PVOID    INFHandle,
    IN LPCTSTR  SectionName,
    IN unsigned LineIndex
    )
{
    PSECTION pSection;
    PLINE    pLine;

    pSection = SearchSectionByName((PINF)INFHandle,SectionName);
    if(pSection == NULL) {
        return(NULL);
    }

    pLine = SearchLineInSectionByIndex(pSection,LineIndex);
    if(pLine == NULL) {
        return(NULL);
    }

    return(pLine->pName);
}



//
// given section name, key and index return the value
//
LPCTSTR
InfGetFieldByKey(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN LPCTSTR  Key,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PXVALUE   pValue;

   if((pSection = SearchSectionByName(
              (PINF)INFHandle,
              SectionName
              ))
              == NULL)
       return(NULL);

   if((pLine = SearchLineInSectionByKey(
              pSection,
              Key
              ))
              == NULL)
       return(NULL);

   if((pValue = SearchValueInLine(
              pLine,
              ValueIndex
              ))
              == NULL)
       return(NULL);

   return (pValue->pName);

}




PXVALUE
SearchValueInLine(
   IN PLINE pLine,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PXVALUE pValue;
   unsigned  i;

   if (pLine == NULL)
       return (NULL);

   pValue = pLine->pValue;
   for (i = 0; (i < ValueIndex) && (pValue = pValue->pNext); i++)
      ;

   return pValue;

}

PLINE
SearchLineInSectionByKey(
   IN PSECTION pSection,
   IN LPCTSTR  Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;

   if (pSection == NULL || Key == NULL) {
       return (NULL);
   }

   pLine = pSection->pLine;
   while(pLine && ((pLine->pName == NULL) || lstrcmpi(pLine->pName, Key))) {
       pLine = pLine->pNext;
   }

   return pLine;

}


PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN unsigned    LineIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;
   unsigned  i;

   //
   // Validate the parameters passed in
   //

   if(pSection == NULL) {
       return (NULL);
   }

   //
   // find the start of the line list in the section passed in
   //

   pLine = pSection->pLine;

   //
   // traverse down the current line list to the LineIndex th line
   //

   for (i = 0; (i < LineIndex) && (pLine = pLine->pNext); i++) {
      ;
   }

   //
   // return the Line found
   //

   return pLine;

}


PSECTION
SearchSectionByName(
   IN PINF    pINF,
   IN LPCTSTR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   //
   // validate the parameters passed in
   //

   if (pINF == NULL || SectionName == NULL) {
       return (NULL);
   }

   //
   // find the section list
   //
   pSection = pINF->pSection;

   //
   // traverse down the section list searching each section for the section
   // name mentioned
   //

   while (pSection && lstrcmpi(pSection->pName, SectionName)) {
       pSection = pSection->pNext;
   }

   //
   // return the section at which we stopped (either NULL or the section
   // which was found
   //

   return pSection;

}


// what follows was alparse.c


//
//  Globals used to make building the lists easier
//

PINF     pINF;
PSECTION pSectionRecord;
PLINE    pLineRecord;
PXVALUE  pValueRecord;


//
// Globals used by the token parser
//

// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below

TCHAR  StringTerminators[] = {  TEXT('['),
                                TEXT(']'),
                                TEXT('='),
                                TEXT(','),
                                TEXT('\"'),
                                TEXT(' '),
                                TEXT('\t'),
                                TEXT('\n'),
                                TEXT('\f'),
                                TEXT('\v'),
                                TEXT('\r'),
                                TEXT('\032')
                             };

unsigned NumberOfTerminators = sizeof(StringTerminators)/sizeof(TCHAR);


// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below - For the loader and textmode

TCHAR  LStringTerminators[] = {  TEXT('['),
                                TEXT(']'),
                                TEXT('='),
                                TEXT(','),
                                TEXT('\"'),
                                TEXT(' '),
                                TEXT('\t'),
                                TEXT('\n'),
                                TEXT('\f'),
                                TEXT('\v'),
                                TEXT('\r')
                             };


//
// quoted string terminators allow some of the regular terminators to
// appear as characters

TCHAR  QStringTerminators[] = { TEXT('\n'),
                                TEXT('\f'),
                                TEXT('\v'),
                                TEXT('\r'),
                                TEXT('\032')
                              };

unsigned QNumberOfTerminators = sizeof(QStringTerminators)/sizeof(TCHAR);

//
// quoted string terminators allow some of the regular terminators to
// appear as characters - This is for the Loader & Textmode

TCHAR  LQStringTerminators[] = { TEXT('\"'),
                                 TEXT('\n'),
                                 TEXT('\f'),
                                 TEXT('\v'),
                                 TEXT('\r')
                               };


//
// Main parser routine
//

DWORD
ParseInfBuffer(
    PTSTR Buffer,
    DWORD Size,
    PVOID *Handle,
    DWORD Phase
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

   If this module is compiler for unicode, the input is assumed to be
   a bufferful of unicode characters.

Arguments:

   Buffer - contains to ptr to a buffer containing the INF file

   Size - contains the size of the buffer in characters.

   Handle - receives INF handle ptr to be used in subsequent INF calls.

Return Value:

   Win32 error code indicating outcome. One of NO_ERROR, ERROR_INVALID_DATA,
   or ERROR_NOT_ENOUGH_MEMORY.

--*/

{
    LPTSTR Stream, MaxStream, pchSectionName, pchValue;
    unsigned State, InfLine;
    TOKEN Token;
    BOOL Done;
    BOOL Error;
    DWORD ErrorCode;
    BOOL IsStringId;
    PTSTR NearestValue=NULL;

    //
    // Initialise the globals
    //
    pINF            = NULL;
    pSectionRecord  = NULL;
    pLineRecord     = NULL;
    pValueRecord    = NULL;

    //
    // Need EmptyValue to point at a nul character
    //
    EmptyValue = StringTerminators + lstrlen(StringTerminators);

    //
    // Get INF record
    //
    pINF = malloc(sizeof(INF));
    if(!pINF) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    pINF->pSection = NULL;

    //
    // Set initial state
    //
    State      = 1;
    InfLine    = 1;
    Stream     = Buffer;
    MaxStream  = Buffer + Size;
    Done       = FALSE;
    Error      = FALSE;
    ErrorCode  = NO_ERROR;
    IsStringId = FALSE;

    pchSectionName = NULL;
    pchValue = NULL;

    //
    // Enter token processing loop
    //

    while (!Done)       {

       Token = DnGetToken(&Stream, MaxStream, Phase);

       if(Token.pValue){
           NearestValue = Token.pValue;
           if( Verbose >= DETAIL)
            _tprintf(TEXT("Token - %s\n"), Token.pValue);
       }

       

       switch (State) {
       //
       // STATE1: Start of file, this state remains till first
       //         section is found
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
       //

       case 1:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting a section left brace\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting End of line, End of File or Left Brace - \nSTATE1: Start of file, this state remains until first section is found\n"));
                  break;
           }
           break;

       //
       // STATE 2: Section LBRACE has been received, expecting STRING
       //
       // Valid Tokens: TOK_STRING
       //
       case 2:
           switch (Token.Type) {
              case TOK_STRING:
                  State = 3;
                  pchSectionName = Token.pValue;
                  break;

              case TOK_RBRACE:
                  if( Phase == TEXTMODE_PHASE){
                      State = 4;
                      pchSectionName = CommonStrings[10];
                      break;
                  }
                  

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting the section name\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting String - \nSTATE 2: Section LBRACE has been received, expecting STRING\n"));
                  break;

           }
           break;

       //
       // STATE 3: Section Name received, expecting RBRACE
       //
       // Valid Tokens: TOK_RBRACE
       //
       case 3:
           switch (Token.Type) {
              case TOK_RBRACE:
                State = 4;
                break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting a section right Brace after Section Name\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting Right Brace - \nSTATE 3: Section Name received, expecting RBRACE\n"));
                  break;
           }
           break;
       //
       // STATE 4: Section Definition Complete, expecting EOL
       //
       // Valid Tokens: TOK_EOL, TOK_EOF
       //
       case 4:
           switch (Token.Type) {
              case TOK_EOL:
                  //_tprintf(TEXT("pchSectionName - %s\n"), pchSectionName);
                  if ((ErrorCode = DnAppendSection(pchSectionName)) != NO_ERROR)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    State = 5;
                  }
                  break;

              case TOK_EOF:
                  _tprintf(TEXT("pchSectionName - %s\n"), pchSectionName);
                  if ((ErrorCode = DnAppendSection(pchSectionName)) != NO_ERROR)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    Done = TRUE;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting End of line after Section Definition\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting End of line or End of File - \nSTATE 4: Section Definition Complete, expecting EOL\n"));
                  break;
           }
           break;

       //
       // STATE 5: Expecting Section Lines
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
       //
       case 5:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_STRING_ID:
                  if( Phase == WINNT32_PHASE )
                    IsStringId = TRUE;
              case TOK_STRING:
                  pchValue = Token.pValue;
                  State = 6;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting Section lines - Did not find End of line, End of File, String/StringID, or Left Brace\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting End of line, End of File, String/StringID, or Left Brace - \nSTATE 5: Expecting Section Lines\n"));
                  break;
           }
           break;

       //
       // STATE 6: String returned, not sure whether it is key or value
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
       //
       case 6:
           switch (Token.Type) {
              case TOK_EOL:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      Done = TRUE;
                  }
                  break;

              case TOK_COMMA:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      State = 7;
                  }
                  break;

              case TOK_EQUAL:
                  if ( (ErrorCode = DnAppendLine(pchValue)) !=NO_ERROR)
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 8;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Processing a section line - Expecting End of line, End of File, Comma or Equals\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting End of line, End of File, Comma or Equals - \nSTATE 6: String returned, not sure whether it is key or value\n"));  

                  break;
           }
           if( Phase == WINNT32_PHASE )
                IsStringId = FALSE;
           break;

       //
       // STATE 7: Comma received, Expecting another string
       //
       // Valid Tokens: TOK_STRING
       //
       case 7:
           switch (Token.Type) {
              case TOK_COMMA:
                  Token.pValue = EmptyValue;
                  ErrorCode = DnAppendValue(Token.pValue,FALSE);
                  if(ErrorCode != NO_ERROR) {
                      Error = Done = TRUE;
                  }
                  break;

              case TOK_STRING_ID:
                  if( Phase == WINNT32_PHASE )
                        IsStringId = TRUE;
              case TOK_STRING:
                  if ((ErrorCode = DnAppendValue(Token.pValue,IsStringId)) != NO_ERROR) {
                      Error = Done = TRUE;
                  } else {
                     State = 9;
                  }
                  if(Phase == WINNT32_PHASE)
                    IsStringId = FALSE;
                  break;

              case TOK_EOL:
              case TOK_EOF:
                  Token.pValue = EmptyValue;
                  if ((ErrorCode = DnAppendValue(Token.pValue, IsStringId)) != NO_ERROR)
                      Error = Done = TRUE;
                  else
                     State = 9;

                  break;


              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Comma received on section line  - Expecting Comma, String/StringID, End of Line or End of File\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting Comma or String/StringID - \nSTATE 7: Comma received, Expecting another string\n"));

                  break;
           }
           break;
       //
       // STATE 8: Equal received, Expecting another string
       //
       // Valid Tokens: TOK_STRING TOK_EOL, TOK_EOF
       //
       case 8:
           switch (Token.Type) {
              case TOK_STRING_ID:
                  if(Phase == WINNT32_PHASE)
                    IsStringId = TRUE;
              case TOK_STRING:
                  if ((ErrorCode = DnAppendValue(Token.pValue,IsStringId)) != NO_ERROR) {
                      Error = Done = TRUE;
                  } else {
                      State = 9;
                  }
                  if(Phase == WINNT32_PHASE)
                    IsStringId = FALSE;
                  break;

              case TOK_EOF:
                  if( Phase != WINNT32_PHASE){
                      Token.pValue = EmptyValue;
                      if ((ErrorCode = DnAppendValue(Token.pValue,FALSE)) != NO_ERROR) {
                          Error = TRUE;
                      }
                      Done = TRUE;
                      break;
                  }
              case TOK_EOL:   
                  Token.pValue = EmptyValue;
                  if ((ErrorCode = DnAppendValue(Token.pValue,FALSE)) != NO_ERROR) {
                      Error = Done = TRUE;
                  } else {
                      State = 5;
                  }
                  if(Phase == WINNT32_PHASE)
                    IsStringId = FALSE;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s - %d\n"), InfLine, NearestValue, Token.Type);
                  _tprintf(TEXT("Syntax Error - Equals received on Section line - Expecting String/StringID, End of line or End of File\n\n"));
                  if(Verbose >= BRIEF)
                      _tprintf(TEXT("Expecting String/StringID, End of line or End of File - \nSTATE 8: Equal received, Expecting another string\n"));
                  break;
           }
           break;
       //
       // STATE 9: String received after equal, value string
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 9:
           switch (Token.Type) {
              case TOK_EOL:
                  State = 5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Recieved string on line - Expecting End of line, End of File or Comma\n"));
                  if(Verbose >= BRIEF)
                    _tprintf(TEXT("Expecting End of line, End of File or Comma - \nSTATE 9: String received after equal, value string\n"));
                  break;
           }
           break;
       //
       // STATE 10: Value string definitely received
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 10:
           _tprintf(TEXT("Was Here\n"));
           switch (Token.Type) {
              case TOK_EOL:
                  State =5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
                  _tprintf(TEXT("Syntax Error - Expecting End of line, End of File or Comma - \nSTATE 10: Value string definitely received\n"));
                  if(Verbose >= BRIEF)
                      _tprintf(TEXT("Expecting End of line, End of File or Comma - \nSTATE 10: Value string definitely received\n"));
                  break;
           }
           break;

       default:
           Error = Done = TRUE;
           ErrorCode = ERROR_INVALID_DATA;
           _tprintf(TEXT("Error in line %i, Nearest string - %s\n"), InfLine, NearestValue);
           break;

       } // end switch(State)


       if (Error) {

           UnloadInfFile(pINF);
           if(pchSectionName) {
               free(pchSectionName);
           }

           if(pchValue) {
               free(pchValue);
           }

           pINF = NULL;
       }
       else {

          //
          // Keep track of line numbers so that we can display Errors
          //

          if (Token.Type == TOK_EOL)
              InfLine++;
       }

    } // End while

    if(!Error && (Phase == WINNT32_PHASE)) {
        ProcessStringSection( pINF );
        *Handle = pINF;
    }
    
    return(Error ? ErrorCode : NO_ERROR);
}



DWORD
DnAppendSection(
    IN PTSTR pSectionName
    )

/*++

Routine Description:

    This appends a new section to the section list in the current INF.
    All further lines and values pertain to this new section, so it resets
    the line list and value lists too.

Arguments:

    pSectionName - Name of the new section. ( [SectionName] )

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or the INF buffer not
               initialised

--*/

{
    PSECTION pNewSection;

    //
    // See if we already have a section by this name. If so we want
    // to merge sections.
    //
    for(pNewSection=pINF->pSection; pNewSection; pNewSection=pNewSection->pNext) {
        if(pNewSection->pName && !lstrcmpi(pNewSection->pName,pSectionName)) {
            break;
        }
    }
    if(pNewSection) {
        //
        // Set pLineRecord to point to the list line currently in the section.
        //
        for(pLineRecord = pNewSection->pLine;
            pLineRecord && pLineRecord->pNext;
            pLineRecord = pLineRecord->pNext)
            ;
    } else {

        //
        // Allocate memory for the new section
        //

        pNewSection = malloc(sizeof(SECTION));
        if(!pNewSection) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // initialise the new section
        //
        pNewSection->pNext = NULL;
        pNewSection->pLine = NULL;
        pNewSection->pName = pSectionName;

        //
        // link it in
        //
        pNewSection->pNext = pINF->pSection;
        pINF->pSection = pNewSection;

        //
        // reset the current line record
        //
        pLineRecord = NULL;
    }

    pSectionRecord = pNewSection;
    pValueRecord   = NULL;

    return NO_ERROR;

}


DWORD
DnAppendLine(
    IN PTSTR pLineKey
    )

/*++

Routine Description:

    This appends a new line to the line list in the current section.
    All further values pertain to this new line, so it resets
    the value list too.

Arguments:

    pLineKey - Key to be used for the current line, this could be NULL.

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or current section not
               initialised


--*/


{
    PLINE pNewLine;

    //
    // Allocate memory for the new Line
    //
    pNewLine = malloc(sizeof(LINE));
    if(!pNewLine) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Link it in
    //
    pNewLine->pNext  = NULL;
    pNewLine->pValue = NULL;
    pNewLine->pName  = pLineKey;

    if (pLineRecord == NULL) {
        pSectionRecord->pLine = pNewLine;
    }
    else {
        pLineRecord->pNext = pNewLine;
    }

    pLineRecord  = pNewLine;

    //
    // Reset the current value record
    //

    pValueRecord = NULL;

    return NO_ERROR;
}



DWORD
DnAppendValue(
    IN PTSTR pValueString,
    IN BOOL IsStringId
    )

/*++

Routine Description:

    This appends a new value to the value list in the current line.

Arguments:

    pValueString - The value string to be added.

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or current line not
               initialised.

--*/

{
    PXVALUE pNewValue;

    //
    // Allocate memory for the new value record
    //
    pNewValue = malloc(sizeof(XVALUE));
    if(!pNewValue) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Link it in.
    //

    pNewValue->pNext       = NULL;
    pNewValue->pName       = pValueString;
    pNewValue->IsStringId  = IsStringId;

    if (pValueRecord == NULL)
        pLineRecord->pValue = pNewValue;
    else
        pValueRecord->pNext = pNewValue;

    pValueRecord = pNewValue;
    return NO_ERROR;
}

TOKEN
DnGetToken(
    IN OUT PTSTR *Stream,
    IN PTSTR      MaxStream,
    IN DWORD      Phase
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    TOKEN - Returns the next token

--*/

{

    PTSTR pch, pchStart, pchNew;
    unsigned  Length, QuotedQuotes;
    TOKEN Token;

    //
    //  Skip whitespace (except for eol)
    //

    pch = *Stream;
    while (pch < MaxStream && *pch != TEXT('\n') && (ISSPACE(*pch) || (*pch == TEXT('\032'))))
        pch++;


    //
    // Check for comments and remove them
    //

    if (pch < MaxStream &&
        ((*pch == TEXT(';')) || (*pch == TEXT('#'))
            || (*pch == TEXT('/') && pch+1 < MaxStream && *(pch+1) == TEXT('/'))))
        while (pch < MaxStream && *pch != TEXT('\n'))
            pch++;

    //
    // Check to see if EOF has been reached, set the token to the right
    // value
    //

    if (( pch >= MaxStream ) || 
        (!(Phase == WINNT32_PHASE) && 
           (*pch == 26)) ){
        *Stream = pch;
        Token.Type  = TOK_EOF;
        Token.pValue = NULL;
        return Token;
    }


    switch (*pch) {

    case TEXT('[') :
        pch++;
        Token.Type  = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case TEXT(']') :
        pch++;
        Token.Type  = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case TEXT('=') :
        pch++;
        Token.Type  = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case TEXT(',') :
        pch++;
        Token.Type  = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case TEXT('\n') :
        pch++;
        Token.Type  = TOK_EOL;
        Token.pValue = NULL;
        break;

    case TEXT('\"'):
        pch++;
        //
        // determine quoted string
        //
        pchStart = pch;
        QuotedQuotes = 0;

morequotedstring:

        if(Phase == WINNT32_PHASE){
            while (pch < MaxStream && *pch && !IsQStringTerminator(*pch,TEXT('\"'))) {
                pch++;
            }
        }else{
            while (pch < MaxStream && (_tcschr(LQStringTerminators,*pch) == NULL)) {
                pch++;
            }
        }

        if(Phase == TEXTMODE_PHASE){
            if(((pch+1) < MaxStream) && (*pch == TEXT('\"')) && ((*(pch+1)) == TEXT('\"'))) {
                QuotedQuotes++;
                //_tprintf( TEXT("Quoted Quotes found - %d\n"), QuotedQuotes);
                pch += 2;
                goto morequotedstring;
            }
        }
    
        if (pch >=MaxStream || (*pch && (*pch != TEXT('\"')))) {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            
            if(Phase == LOADER_PHASE){

                //
                // We require a quoted string to end with a double-quote.
                // (If the string ended with anything else, the if() above
                // would not have let us into the else clause.) The quote
                // character is irrelevent, however, and can be overwritten.
                // So we'll save some heap and use the string in-place.
                // No need to make a copy.
                //
                // Note that this alters the image of txtsetup.sif we pass
                // to setupdd.sys. Thus the inf parser in setupdd.sys must
                // be able to treat a nul character as if it were a terminating
                // double quote. In this tool we call this function with LOADER_PHASE
                // before we call it with TEXTMODE_PHASE.
                //
                *pch++ = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchStart;
    
            }else if( Phase == TEXTMODE_PHASE ){

                Length = (unsigned)(pch - pchStart);
                //_tprintf( TEXT("L - %d pch %x pchstart %x - Q - %d\n"), Length, pch, pchStart, QuotedQuotes);
                if ((pchNew = malloc(((Length + 1) - QuotedQuotes) * sizeof(TCHAR) )) == NULL) {
                    Token.Type = TOK_ERRNOMEM;
                    Token.pValue = NULL;
                } else{
                    if(Length) {    // Null quoted strings are allowed
                        if(QuotedQuotes) {
                            for(Length=0; pchStart<pch; pchStart++) {
                                if((pchNew[Length++] = *pchStart) == TEXT('\"')) {
                                    //
                                    // The only way this could happen is if there's
                                    // another double-quote char after this one, since
                                    // otherwise this would have terminated the string.
                                    //
                                    pchStart++;
                                }
                            }
                        } else {
                            _tcsncpy(pchNew,pchStart,Length);
                        }
                    }
                    pchNew[Length] = 0;
                    Token.Type = TOK_STRING;
                    Token.pValue = pchNew;
                }
                pch++;   // advance past the quote
            }else if( Phase == WINNT32_PHASE ){
            

                Length = (unsigned)(pch - pchStart);
                if (pchNew = malloc((Length + 1) * sizeof(TCHAR))){
                    _tcsncpy(pchNew,pchStart,Length);
                    pchNew[Length] = 0;
                    Token.Type = TOK_STRING;
                    Token.pValue = pchNew;
                    pch++;   // advance past the quote
                }else{
                    Token.Type   = TOK_ERRNOMEM;
                    Token.pValue = NULL;
                }   

            }
        }
        break;


    case TEXT('%'):
        if(Phase == WINNT32_PHASE){
            pch++;
            //
            // determine percented string
            //
            pchStart = pch;
            while (pch < MaxStream && !IsQStringTerminator(*pch,TEXT('%'))) {
                pch++;
            }
    
            if (pch >=MaxStream || *pch != TEXT('%')) {
                Token.Type   = TOK_ERRPARSE;
                Token.pValue = NULL;
            }
            else {
                Length = (unsigned)(pch - pchStart);
                if( pchNew = malloc((Length+1) * sizeof(TCHAR))){
                    _tcsncpy(pchNew,pchStart,Length);
                    pchNew[Length] = 0;
                    Token.Type = TOK_STRING_ID;
                    Token.pValue = pchNew;
                    pch++;   // advance past the percent
                }else{
                    Token.Type   = TOK_ERRNOMEM;
                    Token.pValue = NULL;
                }
    
            }
            break;
        }// if not WINNT32_PHASE go on with default processing


    default:

        pchStart = pch;
        
        /*  -- We don't implement line continuation checks for now.
        if(Phase == TEXTMODE_PHASE ){

            //
            // Check to see if we have a line continuation,
            // which is \ followed by only whitespace on the line
            //

            if((*pch == L'\\')) {
                pch++;
                //
                // Keep skipping until we hit the end of the file,
                // or the newline, or a non-space character.
                //
                while((pch < MaxStream) && (*pch != L'\n') && ISSPACE(*pch)) {
                    pch++;
                }
            
                if(*pch == L'\n') {
                    //
                    // No non-space chars between the \ and the end of the line.
                    // Ignore the newline.
                    //
                    pch++;
                    *LineNumber = *LineNumber + 1;
                    goto restart;
                } else {
                    if(pch < MaxStream) {
                        //
                        // Not line continuation.
                        // Reset the input to the start of the field.
                        //
                        pch = pchStart;
                    }
                }
            }

        } */



        //
        // determine regular string
        //
        pchStart = pch;
        if( Phase == WINNT32_PHASE ){
            while (pch < MaxStream && !IsStringTerminator(*pch))
                pch++;    
        }else{
            while (pch < MaxStream && (_tcschr(LStringTerminators,*pch) == NULL)) {
                pch++;
            }
        }

        if (pch == pchStart) {
            pch++;
            Token.Type  = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {

            Length = (unsigned)((pch - pchStart));
            //_tprintf( TEXT("L - %d pch %x pchstart %x\n"), Length, pch, pchStart);
            if( (Phase == WINNT32_PHASE) || (Phase == LOADER_PHASE)){
                if(pchNew = malloc((Length + 1) * sizeof(TCHAR))){
                    _tcsncpy(pchNew,pchStart,Length);
                    pchNew[Length] = 0;
                    Token.Type = TOK_STRING;
                    Token.pValue = pchNew;
                }else{
                    Token.Type   = TOK_ERRNOMEM;
                    Token.pValue = NULL;
                }
            }else if (Phase == TEXTMODE_PHASE) {
                ULONG i;
                //
                // Check for a common string...
                //
                for( i = 0; i < sizeof(CommonStrings)/sizeof(PTSTR); i++ ) {
                    if( !_tcsnicmp( pchStart, CommonStrings[i], Length) ) {
                        break;
                    }
                }
                if( i < sizeof(CommonStrings)/sizeof(PTSTR) ) {
                    //
                    // Hit...
                    //
                    Token.Type = TOK_STRING;
                    Token.pValue = CommonStrings[i];
                } else if((pchNew = malloc((Length + 1) * sizeof(TCHAR))) == NULL) {
                    Token.Type = TOK_ERRNOMEM;
                    Token.pValue = NULL;
                }
                else {
                    _tcsncpy(pchNew, pchStart, Length);
                    pchNew[Length] = 0;
                    //_tprintf( TEXT("Token2 - %s\n"), pchNew);
                    Token.Type = TOK_STRING;
                    Token.pValue = pchNew;
                }


            }

  
        }
        break;
    }

    *Stream = pch;
    return (Token);
}



BOOL
IsStringTerminator(
    TCHAR ch
    )
/*++

Routine Description:

    This routine tests whether the given character terminates a quoted
    string.

Arguments:

    ch - The current character.

Return Value:

    TRUE if the character is a quoted string terminator, FALSE otherwise.

--*/

{
    unsigned i;

    //
    // one of the string terminator array
    //

    for (i = 0; i < NumberOfTerminators; i++) {
        if (ch == StringTerminators[i]) {
            return (TRUE);
        }
    }

    return FALSE;
}



BOOL
IsQStringTerminator(
    TCHAR ch,
    TCHAR term
    )

/*++

Routine Description:

    This routine tests whether the given character terminates a quoted
    string.

Arguments:

    ch - The current character.


Return Value:

    TRUE if the character is a quoted string terminator, FALSE otherwise.


--*/


{
    unsigned i;
    //
    // one of quoted string terminators array
    //
    for (i = 0; i < QNumberOfTerminators; i++) {

        if (ch == QStringTerminators[i] || ch == term) {
            return (TRUE);
        }
    }

    return FALSE;
}


typedef struct _STRING_ENTRY {
    LPCTSTR     StringId;
    LPCTSTR     StringValue;
} STRING_ENTRY, *PSTRING_ENTRY;

BOOL
ProcessStringSection(
    PINF pINF
    )

/*++

Routine Description:

    This routine processes the strings sections on the
    specified inf file.  The processing scans all values
    in the inf and replaces any string ids that are
    referenced.

Arguments:

    pINF - pointer to the specified inf structure

Return Value:

    TRUE if the strings section is processed properly

--*/

{
    PSTRING_ENTRY StringTable;
    DWORD StringTableCount;
    DWORD LineCount;
    DWORD i;
    LPCTSTR StringId;
    LPCTSTR StringValue;
    PSECTION pSection;
    PLINE pLine;
    PXVALUE pValue;


    LineCount = InfGetSectionLineCount( pINF, TEXT("Strings") );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        _tprintf(TEXT("Warning - No strings section\n"));
        return FALSE;
    }

    StringTable = (PSTRING_ENTRY) malloc( LineCount * sizeof(STRING_ENTRY) );
    if (StringTable == NULL) {
        _tprintf(TEXT("Error - Out of Memory processing Strings section\n"));
        return FALSE;
    }

    StringTableCount = 0;

    for (i=0; i<LineCount; i++) {
        StringId = InfGetLineKeyName( pINF, TEXT("Strings"), i );
        StringValue = InfGetFieldByIndex( pINF, TEXT("Strings"), i, 0 );
        if (StringId && StringValue) {
            StringTable[i].StringId = StringId;
            StringTable[i].StringValue = StringValue;
            StringTableCount += 1;
        }
    }

    pSection = pINF->pSection;
    while(pSection) {
        pLine = pSection->pLine;
        while(pLine) {
            pValue = pLine->pValue;
            while(pValue) {
                if (pValue->IsStringId) {
                    for (i=0; i<StringTableCount; i++) {
                        if (_tcsicmp( StringTable[i].StringId, pValue->pName ) == 0) {
                            free(pValue->pName);
                            pValue->pName = DupString( (PTSTR)StringTable[i].StringValue );
                            break;
                        }
                    }
                }
                pValue = pValue->pNext;
            }
            pLine = pLine->pNext;
        }
        pSection = pSection->pNext;
    }

    free( StringTable );

    return TRUE;
}






DWORD
MapFileForRead(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map an entire file for read access. The file must
    not be 0-length or the routine fails.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.  This value is
        undefined if the file being opened is 0 length.

    BaseAddress - receives the address where the file is mapped.  This
        value is undefined if the file being opened is 0 length.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with UnmapFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else {
        //
        // Get the size of the file.
        //
        *FileSize = GetFileSize(*FileHandle,NULL);
        if(*FileSize == (DWORD)(-1)) {
            rc = GetLastError();
        } else {
            //
            // Create file mapping for the whole file.
            //
            *MappingHandle = CreateFileMapping(
                                *FileHandle,
                                NULL,
                                PAGE_READONLY,
                                0,
                                *FileSize,
                                NULL
                                );

            if(*MappingHandle) {

                //
                // Map the whole file.
                //
                *BaseAddress = MapViewOfFile(
                                    *MappingHandle,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    *FileSize
                                    );

                if(*BaseAddress) {
                    return(NO_ERROR);
                }

                rc = GetLastError();
                CloseHandle(*MappingHandle);
            } else {
                rc = GetLastError();
            }
        }

        CloseHandle(*FileHandle);
    }

    return(rc);
}



DWORD
UnmapFile(
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    )

/*++

Routine Description:

    Unmap and close a file.

Arguments:

    MappingHandle - supplies the win32 handle for the open file mapping
        object.

    BaseAddress - supplies the address where the file is mapped.

Return Value:

    NO_ERROR if the file was unmapped successfully.

    Win32 error code if the file was not successfully unmapped.

--*/

{
    DWORD rc;

    rc = UnmapViewOfFile(BaseAddress) ? NO_ERROR : GetLastError();

    if(!CloseHandle(MappingHandle)) {
        if(rc == NO_ERROR) {
            rc = GetLastError();
        }
    }

    return(rc);
}

LPTSTR
DupString(
    IN LPCTSTR String
    )

/*++

Routine Description:

    Make a duplicate of a nul-terminated string.

Arguments:

    String - supplies pointer to nul-terminated string to copy.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    LPTSTR p;

    if(p = malloc((lstrlen(String)+1)*sizeof(TCHAR))) {
        lstrcpy(p,String);
    }

    return(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\sizes\sizes.c ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <crt\string.h>
#define PULONGLONG PDWORDLONG
#include <spapip.h>

/*
============================================================================

Compute the disk space requirements for the product.

The program runs in 2 modes:
1. Compute disk space requirements to the %windir% (run with -w)
   Computed by adding up the sizes for all files in layout.inf.  Note
   that the files should be uncompressed.

2. Compute disk space requirements for the local source (run with -l)
   Computed by adding up the sizes for all the files in dosnet.inf.  Note
   that the files should be compressed.

For each of these modes, the various size requirements for cluster size
are generated.

============================================================================
*/


//
// Initialize final space requirements.
//
ULONG   Running_RawSize = 0;
ULONG   Running_512 = 0;
ULONG   Running_1K = 0;
ULONG   Running_2K = 0;
ULONG   Running_4K = 0;
ULONG   Running_8K = 0;
ULONG   Running_16K = 0;
ULONG   Running_32K = 0;
ULONG   Running_64K = 0;
ULONG   Running_128K = 0;
ULONG   Running_256K = 0;

ULONG   LineCount = 0;
ULONG   MissedFiles = 0;

//
// This structure will be used to hold link lists
// of file names, section names, or whatever.  It's
// just a linked list of strings.
//
typedef struct _NAMES {
    struct _NAMES   *Next;
    PCWSTR          String;
} NAMES;


//
// Initialize input parameters.
//
BOOL    LocalSource = FALSE;
BOOL    Windir      = FALSE;
BOOL    Verbose     = FALSE;
PCWSTR  InfPath    = NULL;
NAMES   SectionNames;
NAMES   FilePath;
ULONG   Slop = 0;



//
// ============================================================================
//
// Add a string to the end of our NAMES linked list.
//
// ============================================================================
//
BOOL AddName(
    char *IncomingString,
    NAMES   *NamesStruct
    )
{
NAMES   *Names = NamesStruct;

    //
    // The very first entry may be free.
    //
    if( Names->String ) {
        //
        // Get to the end of the list.
        //
        while( Names->Next != NULL ) {
            Names = Names->Next;
        }

        //
        // make room for a new entry.
        //
        Names->Next = MyMalloc(sizeof(NAMES));
        if( Names->Next == NULL ) {
            printf( "AddName - Out of memory!\n" );
            return FALSE;
        }

        Names = Names->Next;
    }

    //
    // Assign
    //
    Names->Next = NULL;
    Names->String = AnsiToUnicode(IncomingString);

    return TRUE;
}

//
// ============================================================================
//
// Find out what the user wants us to do.
//
// ============================================================================
//
BOOL GetParams(
    int argc,
    char *argv[ ]
    )
{
char    *p;
int     i;


    for( i = 0; i < argc; i++ ) {
        if( *argv[i] == '-' ) {
            p = argv[i];

            //
            // local source?
            //
            if( !_strcmpi( p, "-l" ) ) {
                LocalSource = TRUE;

                if( Windir ) {
                    return FALSE;
                }
                continue;
            }

            //
            // windir?
            //
            if( !_strcmpi( p, "-w" ) ) {
                Windir = TRUE;

                if( LocalSource ) {
                    return FALSE;
                }
                continue;
            }

            //
            // Verbose?
            //
            if( !_strcmpi( p, "-v" ) ) {
                Verbose = TRUE;
                continue;
            }

            //
            // Slop (in Mbytes)?
            //
            if( !_strnicmp( p, "-slop:", 6 ) ) {
                p = p + 6;
                Slop = atoi(p);
                Slop = Slop * (1024*1024);
                continue;
            }

            //
            // Inf file?
            //
            if( !_strnicmp( p, "-inf:", 5 ) ) {
                p = p + 5;
                InfPath = AnsiToUnicode(p);
                continue;
            }

            //
            // Inf section?
            //
            if( !_strnicmp( p, "-section:", 9 ) ) {
                p = p + 9;
                if( AddName( p, &SectionNames ) ) {
                    continue;
                } else {
                    return FALSE;
                }
            }

            //
            // Files location location?
            //
            if( !_strnicmp( p, "-files:", 7 ) ) {
                p = p + 7;
                if( AddName( p, &FilePath ) ) {
                    continue;
                } else {
                    return FALSE;
                }
            }

        }
    }

    //
    // Check Params.
    //
    if( !(LocalSource || Windir) ){
        return FALSE;
    }

    if( InfPath == NULL ) {
        return FALSE;
    }

    if( SectionNames.String == NULL ) {
        return FALSE;
    }

    if( FilePath.String == NULL ) {
        return FALSE;
    }

    return TRUE;
}

//
// ============================================================================
//
// Tell the user how to use us.
//
// ============================================================================
//
void Usage( )
{
    printf( "Compute disk space requirements for files listed in an inf\n" );
    printf( "\n" );
    printf( "    -[l|w]        l indicates we're computing space requirements\n" );
    printf( "                    for the local source directory, inwhich case\n" );
    printf( "                    we'll be processing dosnet.inf and computing\n" );
    printf( "                    file sizes for compressed files.\n" );
    printf( "                  w indicates we're computing space requirements\n" );
    printf( "                    for the %windir%, inwhich case we'll be\n" );
    printf( "                    processing layout.inf and computing file\n" );
    printf( "                    sizes for uncompressed files.\n" );
    printf( "\n" );
    printf( "    -v            Execute in Verbose mode.\n" );
    printf( "\n" );
    printf( "    -slop:<num>   This is the error (in Mb) that should be added onto\n" );
    printf( "                  the final disk space requirements.\n" );
    printf( "\n" );
    printf( "    -inf:<path>   This is the path to the inf (including the\n" );
    printf( "                  inf file name).  E.g. -inf:c:\\dosnet.inf\n" );
    printf( "\n" );
    printf( "    -section:<inf_section_name> This is the section name in the inf\n" );
    printf( "                  that needs to be processed.  The user may specify\n" );
    printf( "                  this parameter multiple times inorder to have multiple\n" );
    printf( "                  sections processed.\n" );
    printf( "\n" );
    printf( "    -files:<path> Path to the source files (e.g. install sharepoint or\n" );
    printf( "                  CD).  The user may specify multiple paths here, and\n" );
    printf( "                  they will be checked in the order given.\n" );
    printf( "\n" );
    printf( "\n" );
}


//
// ============================================================================
//
// Round to the nearest clustersize.
//
// ============================================================================
//
ULONG
RoundIt(
    ULONG FileSize,
    ULONG ClusterSize
    )
{

    if( FileSize <= ClusterSize ) {
        return( ClusterSize );
    } else {
        return( ClusterSize * ((FileSize / ClusterSize) + 1) );
    }
}


//
// ============================================================================
//
// Compute file sizes.  Note that we keep track of how much space
// the file will require for a variety of different clusters.
//
// ============================================================================
//
VOID
ComputeSizes(
    PCWSTR FileName,
    ULONG FileSize
    )
{
    
    Running_RawSize += FileSize;
    Running_512     += RoundIt( FileSize, 512 );
    Running_1K      += RoundIt( FileSize, (1   * 1024) );
    Running_2K      += RoundIt( FileSize, (2   * 1024) );
    Running_4K      += RoundIt( FileSize, (4   * 1024) );
    Running_8K      += RoundIt( FileSize, (8   * 1024) );
    Running_16K     += RoundIt( FileSize, (16  * 1024) );
    Running_32K     += RoundIt( FileSize, (32  * 1024) );
    Running_64K     += RoundIt( FileSize, (64  * 1024) );
    Running_128K    += RoundIt( FileSize, (128 * 1024) );
    Running_256K    += RoundIt( FileSize, (256 * 1024) );

    //
    // HACK.
    //
    // If the file is an inf, then we'll be creating an .pnf file
    // during gui-mode setup.  The .pnf file is going to take about
    // 2X the original file size, so we need to fudge this
    //
    if( wcsstr( FileName, L".inf" ) && Windir ) {
        //
        // It's an inf.  Add in size for .pnf file too.
        //
        Running_RawSize += FileSize;
        Running_512     += RoundIt( FileSize*2, 512 );
        Running_1K      += RoundIt( FileSize*2, (1   * 1024) );
        Running_2K      += RoundIt( FileSize*2, (2   * 1024) );
        Running_4K      += RoundIt( FileSize*2, (4   * 1024) );
        Running_8K      += RoundIt( FileSize*2, (8   * 1024) );
        Running_16K     += RoundIt( FileSize*2, (16  * 1024) );
        Running_32K     += RoundIt( FileSize*2, (32  * 1024) );
        Running_64K     += RoundIt( FileSize*2, (64  * 1024) );
        Running_128K    += RoundIt( FileSize*2, (128 * 1024) );
        Running_256K    += RoundIt( FileSize*2, (256 * 1024) );
    }

    if( Verbose ) {
        //
        // Print data for each file.
        //
        printf( "%15ws    %10d    %10d    %10d    %10d    %10d    %10d    %10d    %10d    %10d    %10d    %10d\n",
                FileName,
                FileSize,
                RoundIt( FileSize, 512 ),
                RoundIt( FileSize, (1   * 1024) ),
                RoundIt( FileSize, (2   * 1024) ),
                RoundIt( FileSize, (4   * 1024) ),
                RoundIt( FileSize, (8   * 1024) ),
                RoundIt( FileSize, (16  * 1024) ),
                RoundIt( FileSize, (32  * 1024) ),
                RoundIt( FileSize, (64  * 1024) ),
                RoundIt( FileSize, (128 * 1024) ),
                RoundIt( FileSize, (256 * 1024) ) );
    }

}


//
// ============================================================================
//
// Process a single section in the inf.
//
// ============================================================================
//
DoSection(
    HINF     hInputinf,
    PCWSTR   SectionName
    )
{
#define     GOT_IT() {                                                      \
                        ComputeSizes( FileName, FindData.nFileSizeLow );    \
                        FindClose( tmpHandle );                             \
                        Found = TRUE;                                       \
                     }

INFCONTEXT  InputContext;
PCWSTR      Inputval = NULL;
BOOL        Found;
NAMES       *FileLocations;
WCHAR       CompleteFilePath[MAX_PATH*2];
PCWSTR      FileName;
WCHAR       LastChar;
WIN32_FIND_DATAW FindData;
HANDLE      tmpHandle;

    if( SetupFindFirstLineW( hInputinf, SectionName, NULL, &InputContext ) ) {

        do {

            LineCount++;
            fprintf( stderr, "\b\b\b\b\b%5d", LineCount );

            //
            // Cast the return value from pSetupGetField to PCWSTR, since we're linking
            // with the UNICODE version of the Setup APIs, but this app doesn't have
            // UNICODE defined (thus the PCTSTR return value becomes a PCSTR).
            //
            // Note that if we're doing LocalSource, then we're processing
            // dosnet, which means we want the second field.  If we're doing
            // windir, then we're processing layout, which means we want the 1st
            // field.
            //
            if(FileName = (PCWSTR)pSetupGetField(&InputContext, LocalSource ? 2 : 0)) {

                //
                // We're ready to actually look for the file.
                // Look in each path specified.
                //
                Found = FALSE;
                FileLocations = &FilePath;
                while( FileLocations && !Found ) {
                    wcscpy( CompleteFilePath, FileLocations->String );
                    wcscat( CompleteFilePath, L"\\" );
                    wcscat( CompleteFilePath, FileName );

                    //
                    // Try compressed name first.
                    //
                    LastChar = CompleteFilePath[lstrlenW(CompleteFilePath)-1];
                    CompleteFilePath[lstrlenW(CompleteFilePath)-1] = L'_';

                    tmpHandle = FindFirstFileW(CompleteFilePath, &FindData);
                    if( tmpHandle != INVALID_HANDLE_VALUE ) {

                        GOT_IT();
                    } else {
                        //
                        // We missed.  Try the uncompressed name.
                        //
                        CompleteFilePath[wcslen(CompleteFilePath)-1] = LastChar;
                        tmpHandle = FindFirstFileW(CompleteFilePath, &FindData);
                        if( tmpHandle != INVALID_HANDLE_VALUE ) {

                            GOT_IT();
                        } else {
                            //
                            // Missed again.  This may be a file with a funky
                            // extension (not 8.3).
                            //

                            //
                            // Try and find entries that are of the form
                            // 8.<less-than-3>
                            //
                            wcscat( CompleteFilePath, L"_" );
                            tmpHandle = FindFirstFileW(CompleteFilePath, &FindData);
                            if( tmpHandle != INVALID_HANDLE_VALUE ) {

                                GOT_IT();
                            } else {
                                //
                                // Try and find entries with no extension.
                                //
                                CompleteFilePath[wcslen(CompleteFilePath)-1] = 0;
                                wcscat( CompleteFilePath, L"._" );
                                tmpHandle = FindFirstFileW(CompleteFilePath, &FindData);
                                if( tmpHandle != INVALID_HANDLE_VALUE ) {

                                    GOT_IT();
                                } else {
                                    //
                                    // Give up...
                                    //
                                }
                            }                        
                        }
                    }

                    if( Verbose ) {
                        if( Found ) {
                            printf( "Processed file: %ws\n", CompleteFilePath );
                        } else {
                            printf( "Couldn't find %ws in path %s\n", FileName, FileLocations->String );
                        }
                    }

                    FileLocations = FileLocations->Next;

                } // while( FileLocations && !Found )

                if( Found == FALSE ) {
                    //
                    // We missed the file!  Error.
                    //
                    printf( " ERROR: Couldn't find %ws\n", FileName );
                    MissedFiles++;
                }

            }

        } while( SetupFindNextLine(&InputContext, &InputContext) );

    } else {
        fprintf(stderr,"Section %ws is empty or missing\n", SectionName);
        return(FALSE);
    }

    return(TRUE);





}


int
__cdecl
main( int argc, char *argv[ ], char *envp[ ] )
{
NAMES   *Sections = &SectionNames;
char    *char_ptr;
HINF    hInputinf;
ULONG   i;

    //
    // Check Params.
    //
    if( !GetParams( argc, argv ) ) {
        Usage();
        return 1;
    }

    LineCount = 0;
    fprintf( stderr, "Files processed:      " );

    //
    // Open the inf file.
    //
    hInputinf = SetupOpenInfFileW( InfPath, NULL, INF_STYLE_WIN4, NULL );
    if( hInputinf == INVALID_HANDLE_VALUE ) {
        printf( "The file %s was not opened!\n", InfPath );
        return 1;
    }

    //
    // For each section the user specified...
    //
    while( Sections ) {



        DoSection( hInputinf, Sections->String );

        //
        // Now process the next section.
        //
        Sections = Sect