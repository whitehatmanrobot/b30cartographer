e
                    // Inf directory.
                    //
                    // NOTE: We should never see an issue where we need to
                    // prompt user about their trust of an Authenticode
                    // publisher, since the presence of the INF and CAT are
                    // sufficient here (trust was confirmed when queue
                    // committal occurred).
                    //
                    Err = GLE_FN_CALL(FALSE,
                                      _SetupCopyOEMInf(
                                          szInfFileName,
                                          NULL, // default source location to where INF presently is
                                          (DevInfoElem->SelectedDriver->Flags & DNF_INET_DRIVER)
                                              ? SPOST_URL : SPOST_PATH,
                                          SP_COPY_REPLACEONLY,
                                          szNewName,
                                          SIZECHARS(szNewName),
                                          NULL,
                                          NULL,
                                          (DifferentOriginalName
                                              ? OriginalInfName
                                              : pSetupGetFileTitle(szInfFileName)),
                                          TempString,
                                          hwndParent,
                                          pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                                   DevInfoElem->SelectedDriver->DrvDescription),
                                          PolicyToUse,
                                          SCOI_TRY_UPDATE_PNF // not fatal if existing PNF locked
                                              | SCOI_NO_UI_ON_SIGFAIL,
                                          NULL,
                                          ValidationPlatform,
                                          NULL,
                                          CatalogFilenameOnSystem,
                                          LogContext,
                                          NULL,
                                          NULL)
                                     );

                    if(Err != NO_ERROR) {

                        if(Err == ERROR_FILE_EXISTS) {
                            //
                            // We couldn't copy the legacy INF because it
                            // already exists in the %windir%\Inf directory.
                            // Since it probably has better source path
                            // information than we do, it's best to leave the
                            // PNF alone.  We also need this information about
                            // the INF's existence to that we know whether or
                            // not to blow away the INF later in case we hit a
                            // failure.
                            //
                            Err = NO_ERROR;
                        } else {
                            //
                            // SetupCopyOEMInf failed for some reason other than
                            // file-already-exists (most likely, because we were
                            // dealing with a new-style device INF that didn't
                            // already exist in the Inf directory).  Bail now.
                            //
                            goto clean0;
                        }
                    }
                }

            } else {
                //
                // If the DI_NOVCP flag is set, then just queue up the file
                // copy/rename/delete operations.  Otherwise, perform the
                // actions.
                //
                if(DevInfoElem->InstallParamBlock.Flags & DI_NOVCP) {
                    //
                    // We must have a user-supplied file queue.
                    //
                    MYASSERT(DevInfoElem->InstallParamBlock.UserFileQ);
                    UserFileQ = DevInfoElem->InstallParamBlock.UserFileQ;
                } else {
                    //
                    // Since we may need to check the queued files to determine
                    // whether file copy is necessary, we have to open our own
                    // queue, and commit it ourselves.
                    //
                    if((UserFileQ = SetupOpenFileQueue()) != INVALID_HANDLE_VALUE) {
                        CloseUserFileQ = TRUE;
                    } else {
                        //
                        // SetupOpenFileQueue sets actual error
                        //
                        Err = GetLastError();
                        goto clean0;
                    }
                }
                //
                // Maybe replace the file queue's log context with the Inf's
                //
                if (LogContext) {
                    InheritLogContext(LogContext,
                        &((PSP_FILE_QUEUE) UserFileQ)->LogContext);
                }

                if(slot_section == 0) {
                    //
                    // we haven't done anything about logging section yet...
                    //
                    slot_section = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_VERBOSE,FALSE);
                    //
                    // Say what section is about to be installed.
                    //
                    WriteLogEntry(LogContext,
                        slot_section,
                        MSG_LOG_INSTALLING_SECTION_FROM,
                        NULL,
                        InfSectionWithExt,
                        szInfFileName);
                }

                //
                // DI_FLAGSEX_PREINSTALLBACKUP has precedence over DI_FLAGSEX_BACKUPONREPLACE
                //
                if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_PREINSTALLBACKUP) {
                    BackupFlags |= SP_BKFLG_PREBACKUP | SP_BKFLG_CALLBACK;
                } else if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_BACKUPONREPLACE) {
                    BackupFlags |= SP_BKFLG_LATEBACKUP | SP_BKFLG_CALLBACK;
                }

                if(BackupFlags != 0) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_BEGIN_PREP_BACKUP_TIME,
                        NULL);       // text message

                    pSetupGetBackupQueue(DeviceFullID, UserFileQ, BackupFlags);
                    //
                    // We don't care about errors here
                    //
                }

                ASSERT_HEAP_IS_VALID();

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_TIME,
                    MSG_LOG_BEGIN_INSTALL_FROM_INF_TIME,
                    NULL);       // text message

                Err = InstallFromInfSectionAndNeededSections(NULL,
                                                             hDeviceInf,
                                                             InfSectionWithExt,
                                                             SPINST_FILES,
                                                             NULL,
                                                             NULL,
                                                             SP_COPY_NEWER_OR_SAME | SP_COPY_LANGUAGEAWARE |
                                                                 ((DevInfoElem->InstallParamBlock.Flags & DI_NOBROWSE) ? SP_COPY_NOBROWSE : 0),
                                                             NULL,
                                                             NULL,
                                                             INVALID_HANDLE_VALUE,
                                                             NULL,
                                                             UserFileQ
                                                            );

                //
                // If we're not doing a full install (i.e., file copy-only), then we also want to
                // queue up any file operations for co-installer registration and device interface
                // installation.
                //
                if(!DoFullInstall && (Err == NO_ERROR)) {

                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_BEGIN_CO_INSTALLER_COPY_TIME,
                        NULL);       // text message

                    if(!_SetupDiRegisterCoDeviceInstallers(DeviceInfoSet, DeviceInfoData, FALSE, hDeviceInf, UserFileQ) ||
                       !_SetupDiInstallDeviceInterfaces(DeviceInfoSet, DeviceInfoData, FALSE, hDeviceInf, UserFileQ)) {

                        Err = GetLastError();
                    }
                }

                //
                // Mark the queue as a device install queue (and make sure
                // there's a catalog node representing our device INF in the
                // queue).
                //
                Err = MarkQueueForDeviceInstall(UserFileQ,
                                                hDeviceInf,
                                                pStringTableStringFromId(
                                                    pDeviceInfoSet->StringTable,
                                                    DevInfoElem->SelectedDriver->DrvDescription)
                                               );

                if(CloseUserFileQ) {

                    if(Err == NO_ERROR) {
                        //
                        // If the parameter block contains an install message handler, then use it,
                        // otherwise, initialize our default one.
                        //
                        if(DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                            MsgHandler = DevInfoElem->InstallParamBlock.InstallMsgHandler;
                            MsgHandlerContext = DevInfoElem->InstallParamBlock.InstallMsgHandlerContext;
                            MsgHandlerIsNativeCharWidth = DevInfoElem->InstallParamBlock.InstallMsgHandlerIsNativeCharWidth;
                        } else {

                            NoProgressUI = (GuiSetupInProgress || (DevInfoElem->InstallParamBlock.Flags & DI_QUIETINSTALL));

                            MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                                    hwndParent,
                                                    (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                                                    0,
                                                    0,
                                                    NULL
                                                   );

                            if(MsgHandlerContext) {
                                FreeMsgHandlerContext = TRUE;
                                MsgHandler = SetupDefaultQueueCallback;
                                MsgHandlerIsNativeCharWidth = TRUE;
                            } else {
                                Err = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }

                        //
                        // Call _SetupVerifyQueuedCatalogs separately (i.e.,
                        // don't let it happen automatically as a result of
                        // scanning/committing the queue that happens below).
                        // We do this beforehand so that we know what unique
                        // name was generated when an OEM INF was installed into
                        // %windir%\Inf (in case we need to delete the
                        // INF/PNF/CAT files later if we encounter an error).
                        //
                        if(Err == NO_ERROR) {
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_TIME,
                                MSG_LOG_BEGIN_VERIFY_CAT_TIME,
                                NULL);       // text message

                            Err = _SetupVerifyQueuedCatalogs(
                                      hwndParent,
                                      UserFileQ,
                                      (VERCAT_INSTALL_INF_AND_CAT |
                                       ((DevInfoElem->SelectedDriver->Flags & DNF_INET_DRIVER) ? VERCAT_PRIMARY_DEVICE_INF_FROM_INET : 0)),
                                      szNewName,
                                      &OemInfFileToCopy
                                     );

                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_TIME,
                                MSG_LOG_END_VERIFY_CAT_TIME,
                                NULL);       // text message
                        }

                        ASSERT_HEAP_IS_VALID();

                        if (Err == NO_ERROR) {

                            //
                            // We successfully queued up the file operations and
                            // we have a message handler to use--now we need to
                            // commit the queue.  First off, though, we should
                            // check to see if the files are already there.
                            //
                            // ScanQueueResult can have 1 of 3 values:
                            //
                            // 0: Some files were missing or not valid--must
                            //    commit queue.
                            //
                            // 1: All files to be copied are already present and
                            //    valid, and the queue is empty--skip committing
                            //    queue.
                            //
                            // 2: All files to be copied are present and valid,
                            //    but del/ren/backup queues not empty--must
                            //    commit queue. The copy queue will have been
                            //    emptied, so only del/ren/backup functions will
                            //    be performed.
                            //
                            // (jamiehun) If DI_FLAGSEX_PREINSTALLBACKUP is
                            // specified and there are items to be backed up, it
                            // is covered in (2) the inf file will have already
                            // been backed up
                            //
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_TIME,
                                MSG_LOG_BEGIN_PRESCAN_TIME,
                                NULL);       // text message

                            if(!SetupScanFileQueue(UserFileQ,
                                                   SPQ_SCAN_FILE_VALIDITY |
                                                   SPQ_SCAN_PRUNE_COPY_QUEUE,
                                                   hwndParent,
                                                   NULL,
                                                   NULL,
                                                   &ScanQueueResult)) {
                                //
                                // SetupScanFileQueue should really never
                                // fail when you don't ask it to call a
                                // callback routine, but if it does, just
                                // go ahead and commit the queue.
                                //
                                ScanQueueResult = 0;
                            }

                            if(ScanQueueResult != 1) {
                                //
                                // Copy enqueued files.
                                //
                                WriteLogEntry(
                                    LogContext,
                                    DRIVER_LOG_TIME,
                                    MSG_LOG_BEGIN_COMMIT_TIME,
                                    NULL);       // text message

                                if(_SetupCommitFileQueue(hwndParent,
                                                         UserFileQ,
                                                         MsgHandler,
                                                         MsgHandlerContext,
                                                         MsgHandlerIsNativeCharWidth
                                                         )) {
                                    //
                                    // Check to see whether a reboot is required
                                    // as a result of committing the queue (i.e.,
                                    // because files were in use, or the INF
                                    // requested a reboot).
                                    //
                                    FileQueueNeedsReboot = SetupPromptReboot(UserFileQ, NULL, TRUE);
                                    //
                                    // This should never fail...
                                    //
                                    MYASSERT(FileQueueNeedsReboot != -1);

                                    if(FileQueueNeedsReboot) {
                                        SetDevnodeNeedsRebootProblem(DevInfoElem, pDeviceInfoSet, MSG_LOG_REBOOT_REASON_INUSE);
                                    }

                                } else {
                                    Err = GetLastError();
                                }
                            }

                            //
                            // If no files were modified as a result of commiting
                            // the file queue, then set the DI_FLAGSEX_RESTART_DEVICE_ONLY
                            // flag so that we only restart this one device, as opposed
                            // to restarting this device and all other device that
                            // are sharing a driver or filter with this device.
                            //
                            if (SetupGetFileQueueFlags(UserFileQ, &FileQueueFlags) &&
                                !(FileQueueFlags & SPQ_FLAG_FILES_MODIFIED)) {

                                DevInfoElem->InstallParamBlock.FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;
                            }

                            //
                            // Terminate the default queue callback, if it was created.
                            //
                            if(FreeMsgHandlerContext) {
                                SetupTermDefaultQueueCallback(MsgHandlerContext);
                                FreeMsgHandlerContext = FALSE;
                            }
                        }
                    }

                    //
                    // Close our file queue handle.
                    //
                    SetupCloseFileQueue(UserFileQ);
                    CloseUserFileQ = FALSE;
                }

                if(Err != NO_ERROR) {
                    goto clean0;
                }
            }

            //
            // If the copy succeeded (or in setup's case was queued), then
            // it's time to update the registry and ini files.
            //
            if(Err == NO_ERROR) {
                //
                // We've got some registry modifications to do, but we don't want to
                // do them if this is a copy-only installation.
                //
                if(DoFullInstall) {
                    //
                    // Skip installation of basic log configs if this is an
                    // enumerated device.
                    //
                    if((CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) != CR_SUCCESS) ||
                       (ulStatus & DN_ROOT_ENUMERATED)) {

                        LOG_CONF LogConf;

                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_TIME,
                            MSG_LOG_BEGIN_WRITE_BASIC_CFGS_TIME,
                            NULL);       // text message

                        //
                        // Clean out all existing BASIC_LOG_CONF LogConfigs before writing out new ones from
                        // the INF.
                        //
                        while(CM_Get_First_Log_Conf_Ex(&LogConf, DevInfoElem->DevInst, BASIC_LOG_CONF,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                            CM_Free_Log_Conf(LogConf, 0);
                            CM_Free_Log_Conf_Handle(LogConf);
                        }

                        //
                        // Now write out the new basic log configs.
                        //
                        Err = InstallFromInfSectionAndNeededSections(NULL,
                                                                     hDeviceInf,
                                                                     InfSectionWithExt,
                                                                     SPINST_LOGCONFIG,
                                                                     NULL,
                                                                     NULL,
                                                                     0,
                                                                     NULL,
                                                                     NULL,
                                                                     DeviceInfoSet,
                                                                     DeviceInfoData,
                                                                     NULL
                                                                    );

                    } else {
                        //
                        // For non-root-enumerated devices, check to see if there's an [<InstallSec>.LogConfigOverride]
                        // section, and if so, run it.
                        //
                        if(MYVERIFY(SUCCEEDED(StringCchCopy(&(InfSectionWithExt[InfSectionWithExtLength - 1]),
                                                SIZECHARS(InfSectionWithExt)-(InfSectionWithExtLength - 1),
                                                pszLogConfigOverrideSectionSuffix)))) {

                            if(SetupFindFirstLine(hDeviceInf, InfSectionWithExt, NULL, &InfContext)) {

                                LOG_CONF LogConf;

                                WriteLogEntry(
                                    LogContext,
                                    DRIVER_LOG_TIME,
                                    MSG_LOG_BEGIN_WRITE_OVERRIDE_CFGS_TIME,
                                    NULL);       // text message

                                //
                                // Clean out all existing OVERRIDE_LOG_CONF LogConfigs before writing out new ones from
                                // the INF.
                                //
                                while(CM_Get_First_Log_Conf_Ex(&LogConf, DevInfoElem->DevInst,
                                                               OVERRIDE_LOG_CONF,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                                    CM_Free_Log_Conf(LogConf, 0);
                                    CM_Free_Log_Conf_Handle(LogConf);
                                }

                                //
                                // Now write out the new override log configs.
                                //
                                Err = InstallFromInfSectionAndNeededSections(NULL,
                                                                             hDeviceInf,
                                                                             InfSectionWithExt,
                                                                             SPINST_LOGCONFIG | SPINST_LOGCONFIGS_ARE_OVERRIDES,
                                                                             NULL,
                                                                             NULL,
                                                                             0,
                                                                             NULL,
                                                                             NULL,
                                                                             DeviceInfoSet,
                                                                             DeviceInfoData,
                                                                             NULL
                                                                            );
                            }
                        }
                        //
                        // Make sure we strip off the ".LogConfigOverride" we added above.
                        //
                        InfSectionWithExt[InfSectionWithExtLength - 1] = TEXT('\0');
                    }

                    if((Err == NO_ERROR) && !(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NO_DRVREG_MODIFY)) {
                        //
                        // (Don't pass devinfo set and element here, because we're writing
                        // to the _driver_ key, not the _device_ key.)
                        //
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_TIME,
                            MSG_LOG_BEGIN_INSTALL_REG_TIME,
                            NULL);       // text message

                        Err = InstallFromInfSectionAndNeededSections(NULL,
                                                                     hDeviceInf,
                                                                     InfSectionWithExt,
                                                                     SPINST_INIFILES
                                                                     | SPINST_REGISTRY
                                                                     | SPINST_INI2REG
                                                                     | SPINST_BITREG
                                                                     | SPINST_REGSVR
                                                                     | SPINST_UNREGSVR
                                                                     | SPINST_PROFILEITEMS,
                                                                     hkDrv,
                                                                     NULL,
                                                                     0,
                                                                     NULL,
                                                                     NULL,
                                                                     INVALID_HANDLE_VALUE,
                                                                     NULL,
                                                                     NULL
                                                                    );
                        if(Err == NO_ERROR) {
                            //
                            // Install extra HardWare registry section (if any).
                            //
                            Err = InstallHW(DeviceInfoSet,
                                            DeviceInfoData,
                                            hDeviceInf,
                                            InfSectionWithExt,
                                            &DeleteDevKey
                                           );
                        }
                    }

                    //
                    //  Set appropriate flags if we need to reboot or restart after
                    //  this installation.
                    //
                    if(SetupFindFirstLine(hDeviceInf, InfSectionWithExt, pszReboot, &InfContext)) {
                        SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,pDeviceInfoSet,
                                                             MSG_LOG_REBOOT_REASON_KEY,
                                                             (ULONG_PTR)pszReboot,
                                                             (ULONG_PTR)InfSectionWithExt);
                    } else if(SetupFindFirstLine(hDeviceInf, InfSectionWithExt, pszRestart, &InfContext)) {
                        //
                        // NOTE: This behavior is taken from setupx.  In both "Reboot"
                        // and "Restart" cases, it sets the DI_NEEDREBOOT flag.
                        //
                        SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,pDeviceInfoSet,
                                                             MSG_LOG_REBOOT_REASON_KEY,
                                                             (ULONG_PTR)pszRestart,
                                                             (ULONG_PTR)InfSectionWithExt);
                    }

                    //
                    // Set the value to write for the config flags, only if there
                    // are no config flags yet.  If they exist, i.e., we are updating
                    // an existing device, just clear the re-install flag.
                    //
                    dwConfigFlags = GetDevInstConfigFlags(
                                        DevInfoElem->DevInst,
                                        (DevInfoElem->InstallParamBlock.Flags & DI_INSTALLDISABLED)
                                            ? CONFIGFLAG_DISABLED
                                            : 0,
                                        pDeviceInfoSet->hMachine
                                       );

                    //
                    // Always clear the REINSTALL bit and the FAILEDINSTALL bit
                    // when installing a device.
                    // (Also, clear the CONFIGFLAG_FINISH_INSTALL bit, which is used for
                    // Raw and driver-detected devnodes.)
                    //
                    dwConfigFlags &= ~(CONFIGFLAG_REINSTALL | CONFIGFLAG_FAILEDINSTALL | CONFIGFLAG_FINISH_INSTALL);
                }

                //
                // If we're doing a copy-only installation, then we're done.
                //
                if(!DoFullInstall) {
                    goto clean0;
                }

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_TIME,
                    MSG_LOG_BEGIN_WRITE_REG_TIME,
                    NULL);       // text message

                //
                // Insert Driver Specific strings into the registry.
                //
                if(InfFromOemPath = pSetupInfIsFromOemLocation(szInfFileName, TRUE)) {
                    TempString = pSetupGetFileTitle(szNewName);
                } else {
                    TempString = pSetupGetFileTitle(szInfFileName);
                }

                RegSetValueEx(hkDrv,
                              pszInfPath,
                              0,
                              REG_SZ,
                              (PBYTE)TempString,
                              (lstrlen(TempString) + 1) * sizeof(TCHAR)
                             );

                RegSetValueEx(hkDrv,
                              pszInfSection,
                              0,
                              REG_SZ,
                              (PBYTE)szInfSectionName,
                              (lstrlen(szInfSectionName) + 1) * sizeof(TCHAR)
                             );

                if(szInfSectionExt) {

                    RegSetValueEx(hkDrv,
                                  pszInfSectionExt,
                                  0,
                                  REG_SZ,
                                  (PBYTE)szInfSectionExt,
                                  (lstrlen(szInfSectionExt) + 1) * sizeof(TCHAR)
                                 );
                } else {
                    //
                    // This wasn't an OS/architecture-specific install section, _or_ we are
                    // installing from a legacy INF.  Make sure there's no value hanging
                    // around from a previous installation.
                    //
                    RegDeleteValue(hkDrv, pszInfSectionExt);
                }

                if(DevInfoElem->SelectedDriver->ProviderDisplayName == -1) {
                    //
                    // No provider specified--delete any previously existing value entry.
                    //
                    RegDeleteValue(hkDrv, pszProviderName);

                } else {
                    //
                    // Retrieve the Provider name, and store it in the driver key.
                    //
                    TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                          DevInfoElem->SelectedDriver->ProviderDisplayName
                                                         );
                    RegSetValueEx(hkDrv,
                                  pszProviderName,
                                  0,
                                  REG_SZ,
                                  (PBYTE)TempString,
                                  (lstrlen(TempString) + 1) * sizeof(TCHAR)
                                 );
                }

                if (DevInfoElem->SelectedDriver->DriverDate.dwLowDateTime != 0 ||
                    DevInfoElem->SelectedDriver->DriverDate.dwHighDateTime != 0) {

                    SYSTEMTIME SystemTime;
                    TCHAR Date[20];

                    //
                    // Save the driver date in binary (FILETIME) format in the registry
                    // so it can be localized by other components.
                    //
                    RegSetValueEx(hkDrv,
                                  pszDriverDateData,
                                  0,
                                  REG_BINARY,
                                  (LPBYTE)&DevInfoElem->SelectedDriver->DriverDate,
                                  sizeof(DevInfoElem->SelectedDriver->DriverDate)
                                  );

                    //
                    // Save the driver date in string format for compatibility.
                    //
                    if (FileTimeToSystemTime(&(DevInfoElem->SelectedDriver->DriverDate), &SystemTime)) {

                        MYVERIFY(SUCCEEDED(StringCchPrintf(Date,
                                                           SIZECHARS(Date),
                                                           TEXT("%d-%d-%d"),
                                                           SystemTime.wMonth,
                                                           SystemTime.wDay,
                                                           SystemTime.wYear)));

                        RegSetValueEx(hkDrv,
                                      pszDriverDate,
                                      0,
                                      REG_SZ,
                                      (PBYTE)Date,
                                      (lstrlen(Date) + 1) * sizeof(TCHAR)
                                      );
                    }

                } else {
                    //
                    //No driver date for this driver--delete any previously existing value entry.
                    //
                    RegDeleteValue(hkDrv, pszDriverDateData);
                    RegDeleteValue(hkDrv, pszDriverDate);
                }

                if (DevInfoElem->SelectedDriver->DriverVersion != 0) {

                    ULARGE_INTEGER Version;
                    TCHAR VersionString[LINE_LEN];

                    Version.QuadPart = DevInfoElem->SelectedDriver->DriverVersion;

                    MYVERIFY(SUCCEEDED(StringCchPrintf(VersionString,
                                                       SIZECHARS(VersionString),
                                                       TEXT("%0d.%0d.%0d.%0d"),
                                                       HIWORD(Version.HighPart),
                                                       LOWORD(Version.HighPart),
                                                       HIWORD(Version.LowPart),
                                                       LOWORD(Version.LowPart))));

                    RegSetValueEx(hkDrv,
                                  pszDriverVersion,
                                  0,
                                  REG_SZ,
                                  (PBYTE)VersionString,
                                  (lstrlen(VersionString) + 1) * sizeof(TCHAR)
                                  );

                } else {
                    //
                    //No driver version for this driver--delete any previously existing value entry.
                    //
                    RegDeleteValue(hkDrv, pszDriverVersion);
                }

                //
                // Set the Class property for this device.
                //
                SetupDiClassNameFromGuid(&DevInfoElem->ClassGuid, className, MAX_CLASS_NAME_LEN, NULL);
                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_CLASS,
                                                 className,
                                                 (lstrlen(className) + 1) * sizeof(TCHAR),
                                                 0,
                                                 pDeviceInfoSet->hMachine);

                //
                // Set the MFG device registry property.
                //
                TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                      DevInfoElem->SelectedDriver->MfgDisplayName
                                                     );

                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_MFG,
                                                 TempString,
                                                 (lstrlen(TempString) + 1) * sizeof(TCHAR),
                                                 0,
                                                 pDeviceInfoSet->hMachine);

                //
                // Add hardware and compatible IDs to the hardware key if they exist
                // in the driver node and don't already exist in the registry.  This
                // sets up an ID for manually installed devices.
                //
                if(!(DevInfoElem->InstallParamBlock.Flags & DI_NOWRITE_IDS) &&     // Want IDs written?
                   (DevInfoElem->SelectedDriver->HardwareId != -1))                // ID in driver node?
                {
                    //
                    // Don't write IDs if either Hardware or Compatible IDs already
                    // exist in the registry.  Note that I use cbData as an IN/OUT parameter
                    // to both CM calls.  This is OK, however, since cbSize will not be modified
                    // on a CR_NO_SUCH_VALUE return, and I won't try to re-use it otherwise.
                    //
                    cbData = 0;
                    if((DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALWAYSWRITEIDS) ||
                       ((CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                          CM_DRP_HARDWAREID,
                                                          NULL,
                                                          NULL,
                                                          &cbData,
                                                          0,
                                                          pDeviceInfoSet->hMachine) == CR_NO_SUCH_VALUE) &&
                        (CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                          CM_DRP_COMPATIBLEIDS,
                                                          NULL,
                                                          NULL,
                                                          &cbData,
                                                          0,
                                                          pDeviceInfoSet->hMachine) == CR_NO_SUCH_VALUE)))
                    {
                        DWORD CurStringLen, TotalStringLen, DevIdBufferLen, i;

                        //
                        // Compute the maximum buffer size needed to hold our REG_MULTI_SZ
                        // ID lists.
                        //
                        DevIdBufferLen = (((DevInfoElem->SelectedDriver->NumCompatIds) ?
                                            DevInfoElem->SelectedDriver->NumCompatIds  : 1)
                                            * MAX_DEVICE_ID_LEN) + 1;

                        if(!(DevIdBuffer = MyMalloc(DevIdBufferLen * sizeof(TCHAR)))) {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                            goto clean0;
                        }

                        //
                        // Build a multi-sz list of the (single) HardwareID, and set it.
                        //
                        TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                              DevInfoElem->SelectedDriver->HardwareId
                                                             );

                        TotalStringLen = lstrlen(TempString) + 1;

                        MYVERIFY(SUCCEEDED(StringCchCopy(DevIdBuffer,
                                                         DevIdBufferLen,
                                                         TempString)));

                        DevIdBuffer[TotalStringLen++] = TEXT('\0');  // Add extra terminating NULL;

                        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                         CM_DRP_HARDWAREID,
                                                         DevIdBuffer,
                                                         TotalStringLen * sizeof(TCHAR),
                                                         0,
                                                         pDeviceInfoSet->hMachine );

                        //
                        // Build a multi-sz list of the zero or more CompatibleIDs, and set it
                        //
                        TotalStringLen = 0;
                        for(i = 0; i < DevInfoElem->SelectedDriver->NumCompatIds; i++) {

                            TempString = pStringTableStringFromId(
                                            pDeviceInfoSet->StringTable,
                                            DevInfoElem->SelectedDriver->CompatIdList[i]);

                            CurStringLen = lstrlen(TempString) + 1;

                            MYVERIFY(SUCCEEDED(StringCchCopy(DevIdBuffer+TotalStringLen,
                                                             DevIdBufferLen-TotalStringLen,
                                                             TempString)));

                            TotalStringLen += CurStringLen;
                        }

                        if(TotalStringLen) {

                            DevIdBuffer[TotalStringLen++] = TEXT('\0');  // Add extra terminating NULL;

                            CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                             CM_DRP_COMPATIBLEIDS,
                                                             DevIdBuffer,
                                                             TotalStringLen * sizeof(TCHAR),
                                                             0,
                                                             pDeviceInfoSet->hMachine);
                        }
                    }
                }

                //
                // Write out the 'MatchingDeviceId' value entry to the driver key that indicates which
                // device ID (hardware or compatible) was used to pick this driver.  For a compatible
                // driver, this is the device ID that the compatible match was based on.  For a class
                // driver, this is the driver node's HardwareId (if present), or best CompatibleId.  If
                // the class driver node didn't specify a hardware or compatible IDs, then this value
                // will not be written (we'll actually delete it to make sure it doesn't exist from a
                // previous driver installation).
                //
                TempString = NULL;
                if(DevInfoElem->SelectedDriverType == SPDIT_COMPATDRIVER) {

                    if(DevInfoElem->SelectedDriver->MatchingDeviceId == -1) {
                        //
                        // We have a HardwareID match.
                        //
                        TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                              DevInfoElem->SelectedDriver->HardwareId
                                                             );
                    } else {
                        //
                        // We have a CompatibleID match.
                        //
                        MYASSERT((DevInfoElem->SelectedDriver->MatchingDeviceId >= 0) &&
                                 ((DWORD)(DevInfoElem->SelectedDriver->MatchingDeviceId) < DevInfoElem->SelectedDriver->NumCompatIds));

                        TempString = pStringTableStringFromId(
                                         pDeviceInfoSet->StringTable,
                                         DevInfoElem->SelectedDriver->CompatIdList[DevInfoElem->SelectedDriver->MatchingDeviceId]
                                        );
                    }

                } else if(DevInfoElem->SelectedDriver->HardwareId != -1) {
                    //
                    // There's no notion of compatibility for class drivers--pick the device ID with the
                    // highest order of preference.
                    //
                    TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                          DevInfoElem->SelectedDriver->HardwareId
                                                         );
                    if(!(*TempString)) {
                        //
                        // The HardwareID was an empty string--use the first CompatibleID.
                        //
                        if(DevInfoElem->SelectedDriver->NumCompatIds) {
                            TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                                  DevInfoElem->SelectedDriver->CompatIdList[0]
                                                                 );
                        } else {
                            TempString = NULL;
                        }
                    }
                }

                if(TempString) {
                    RegSetValueEx(hkDrv,
                                  pszMatchingDeviceId,
                                  0,
                                  REG_SZ,
                                  (PBYTE)TempString,
                                  (lstrlen(TempString) + 1) * sizeof(TCHAR)
                                 );
                } else {
                    //
                    // We have an override situation where the user picked a class driver that didn't
                    // specify any hardware or compatible IDs.  Make sure there's no value hanging
                    // around from a previous installation.
                    //
                    RegDeleteValue(hkDrv, pszMatchingDeviceId);
                }

                //
                // If we're running under Windows NT, and we've successfully installed the device instance,
                // then we need to install any required services.
                //
                if((Err == NO_ERROR) && (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {

                    PTSTR pServiceInstallSection;

                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_BEGIN_SERVICE_TIME,
                        NULL);       // text message

                    //
                    // The install section name is of the form:
                    //
                    //     <InfSectionWithExt>.Services
                    //
                    MYVERIFY(SUCCEEDED(StringCchCopy(&(InfSectionWithExt[InfSectionWithExtLength - 1]),
                                                     SIZECHARS(InfSectionWithExt)-(InfSectionWithExtLength - 1),
                                                     pszServicesSectionSuffix)));
                    pServiceInstallSection = InfSectionWithExt;

                    Err = InstallNtService(DevInfoElem,
                                           hDeviceInf,
                                           szInfFileName,
                                           pServiceInstallSection,
                                           &DeleteServiceList,
                                           0,
                                           &NullDriverInstall
                                          );
                }
                if((Err == NO_ERROR) && DoFullInstall) {

                    InfSectionWithExt[InfSectionWithExtLength - 1] = TEXT('\0');
                    pSetupCopyRelatedInfs(hDeviceInf,
                                          szInfFileName,
                                          InfSectionWithExt,
                                          (DevInfoElem->SelectedDriver->Flags & DNF_INET_DRIVER)
                                              ? SPOST_URL : SPOST_PATH,
                                          LogContext);

                    if(SUCCEEDED(StringCchCopy(&(InfSectionWithExt[InfSectionWithExtLength - 1]),
                                               SIZECHARS(InfSectionWithExt)-(InfSectionWithExtLength-1),
                                               pszWmiSectionSuffix))) {
                        //
                        // InfSectionWithExt refers to DDInstall.WMI
                        //
                        if(!SetupConfigureWmiFromInfSection(hDeviceInf,
                                                            InfSectionWithExt,
                                                            0)) {
                            Err = GetLastError();
                        }
                    }


                }
            }

        } else {
            //
            // Installing the NULL driver.
            // This means to set the Config flags, and nothing else.
            // Config Flags get set to enabled in this case, so the device
            // gets assigned the correct config. (Win95 bug 26320)
            //

            WriteLogEntry(
                LogContext,
                DRIVER_LOG_INFO,
                MSG_LOG_INSTALL_NULL,
                NULL,       // text message
                DeviceFullID);

            NullDriverInstall = TRUE;

            if(DoFullInstall) {

                BOOL NullDrvInstallOK = FALSE;

                //
                // Check to see if the devnode is raw-capable, or if it already has a controlling
                // service.  If neither of those conditions are met, then we should fail this call
                // unless the caller has explicitly passed us the DI_FLAGSEX_SETFAILEDINSTALL flag.
                //
                cbData = sizeof(DevInstCapabilities);
                if(CR_SUCCESS == CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                                  CM_DRP_CAPABILITIES,
                                                                  NULL,
                                                                  &DevInstCapabilities,
                                                                  &cbData,
                                                                  0,
                                                                  pDeviceInfoSet->hMachine))
                {
                    NullDrvInstallOK = (DevInstCapabilities & CM_DEVCAP_RAWDEVICEOK);
                }

                if(!NullDrvInstallOK) {
                    //
                    // The devnode isn't raw-capable.  Check to see if it already has a
                    // controlling service (e.g., because it was created as a result of
                    // a driver's call to IoReportDetectedDevice).
                    //
                    cbData = 0;
                    if(CR_BUFFER_SMALL == CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                                           CM_DRP_SERVICE,
                                                                           NULL,
                                                                           NULL,
                                                                           &cbData,
                                                                           0,
                                                                           pDeviceInfoSet->hMachine))
                    {
                        NullDrvInstallOK = TRUE;
                    }
                }

                if(!NullDrvInstallOK &&
                   !(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_SETFAILEDINSTALL)) {

                    Err = ERROR_NO_ASSOCIATED_SERVICE;

                } else {

                    dwConfigFlags = GetDevInstConfigFlags(DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) &
                                        ~(CONFIGFLAG_DISABLED | CONFIGFLAG_REINSTALL | CONFIGFLAG_FINISH_INSTALL);

                    //
                    // Delete all driver (software) keys associated with the
                    // device (this will automatically reset the "Driver"
                    // registry property.
                    //
                    SetupDiDeleteDevRegKey(DeviceInfoSet,
                                           DeviceInfoData,
                                           DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGGENERAL,
                                           0,
                                           DIREG_DRV
                                          );

                    //
                    // Delete the controlling (FDO) Service property, as well as the UpperFilters and
                    // LowerFilters properties.  Only do this if the devnode is not root-enumerated,
                    // however, since NT can have root-enumerated devnodes reported by drivers via
                    // IoReportDetectedDevice for which there's no corresponding INF (hence, the user
                    // must do a null-driver install in order to silence the "New Hardware Found" popups
                    // for these devices.
                    //
                    if((CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevInfoElem->DevInst,
                                                 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                       !(ulStatus & DN_ROOT_ENUMERATED)) {

                        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst, CM_DRP_SERVICE,
                                                            NULL, 0, 0,pDeviceInfoSet->hMachine);
                        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst, CM_DRP_UPPERFILTERS,
                                                            NULL, 0, 0,pDeviceInfoSet->hMachine);
                        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst, CM_DRP_LOWERFILTERS,
                                                            NULL, 0, 0,pDeviceInfoSet->hMachine);
                    }
                }

            } else {
                //
                // It is an error to not have a selected driver in the copy-only case.
                //
                Err = ERROR_NO_DRIVER_SELECTED;
            }
        }

        //
        // If all went well above, then write some configflags, and re-enumerate
        // the parent device instance if necessary
        //
        if(Err == NO_ERROR) {
            //
            // Write the Driver Description to the Registry, if there
            // is an lpSelectedDriver, and the Device Description also
            //
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_BEGIN_WRITE_REG2_TIME,
                NULL);       // text message

            if(DevInfoElem->SelectedDriver) {

                TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                      DevInfoElem->SelectedDriver->DrvDescription
                                                     );

                RegSetValueEx(hkDrv,
                              pszDrvDesc,
                              0,
                              REG_SZ,
                              (PBYTE)TempString,
                              (lstrlen(TempString) + 1) * sizeof(TCHAR)
                             );

                //
                // (setupx BUG 12721) always update the DevDesc in the registry with the
                // value from the INF (ie only do this if we have a SELECTED driver)
                // The semantics are weird, but the SelectedDriver NODE contains the
                // INF Device description, and DRV description
                //
                TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                      DevInfoElem->SelectedDriver->DevDescriptionDisplayName
                                                     );

                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_DEVICEDESC,
                                                 TempString,
                                                 (lstrlen(TempString) + 1) * sizeof(TCHAR),
                                                 0,
                                                 pDeviceInfoSet->hMachine);
            } else {
                //
                // No driver is selected, so use the description stored with the device
                // information element itself for the device description.  However, only set this
                // if it isn't already present.
                //
                cbData = 0;
                if(CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                    CM_DRP_DEVICEDESC,
                                                    NULL,
                                                    NULL,
                                                    &cbData,
                                                    0,
                                                    pDeviceInfoSet->hMachine) == CR_NO_SUCH_VALUE) {

                    if(DevInfoElem->DeviceDescriptionDisplayName != -1) {

                        TempString = pStringTableStringFromId(
                                         pDeviceInfoSet->StringTable,
                                         DevInfoElem->DeviceDescriptionDisplayName
                                        );

                        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                         CM_DRP_DEVICEDESC,
                                                         TempString,
                                                         (lstrlen(TempString) + 1) * sizeof(TCHAR),
                                                         0,
                                                         pDeviceInfoSet->hMachine);
                    }
                }
            }

            //
            // Unless the caller explicitly requested that this device be installed disabled, clear
            // the CONFIGFLAG_DISABLED bit.
            //
            if(!(DevInfoElem->InstallParamBlock.Flags & DI_INSTALLDISABLED)) {
                dwConfigFlags &= ~CONFIGFLAG_DISABLED;
            }

            //
            // Write the config flags. If no selected driver means we should mark the install
            // as a failure, then do so.
            //
            if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_SETFAILEDINSTALL) {
                dwConfigFlags |= CONFIGFLAG_FAILEDINSTALL;
            }

            //
            // NTRAID#700056-2002/09/05-LonnyM check return codes from CM_Set_DevInst_Registry_Property.
            //
            // Only stop/start the device if we can set the ConfigFlags on the
            // device.  Otherwise we can get stuck in an infinite loop where
            // the CONFIGFLAG_REINSTALL is not cleared and when the device is
            // restarted we try to install it all over again.
            // In the future we need to check all return codes from the
            // CM_Set_DevInst_Registry_Property APIs and fail/exit appropriately.
            //
            if (CR_SUCCESS == CM_Set_DevInst_Registry_Property_Ex(
                                            DevInfoElem->DevInst,
                                            CM_DRP_CONFIGFLAGS,
                                            &dwConfigFlags,
                                            sizeof(dwConfigFlags),
                                            0,
                                            pDeviceInfoSet->hMachine)) {

                if(!(DevInfoElem->InstallParamBlock.Flags & (DI_DONOTCALLCONFIGMG | DI_NEEDREBOOT | DI_NEEDRESTART))) {

                    if (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_RESTART_DEVICE_ONLY) {
                        //
                        // Restart this device only.
                        //
                        // This should only be done if no files were copied during
                        // DIF_INSTALLDEVICEFILES.
                        //
                        RestartSingleDevice(DevInfoElem,
                                            pDeviceInfoSet,
                                            NullDriverInstall,
                                            LogContext);
                    } else {
                        //
                        // Restart this device as well as any other device that is
                        // using one of the same drivers as this device. This
                        // includes the function driver as well as the device and
                        // class upper and lower filter drivers.
                        //
                        // This only needs to be used if files were copied during
                        // DIF_INSTALLDEVICEFILES.
                        //
                        RestartAllDevicesUsingDrivers(DevInfoElem,
                                                      pDeviceInfoSet,
                                                      NullDriverInstall,
                                                      LogContext);
                    }
                }
            }
        }

        if((Err == NO_ERROR) && !GuiSetupInProgress) {

            MYASSERT(DoFullInstall);

            //
            // Kick off RunOnce.
            //
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_BEGIN_INSTALLSTOP_TIME,
                NULL);       // text message

            Err = pSetupInstallStopEx(TRUE, INSTALLSTOP_NO_GRPCONV, LogContext);
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If our exception was an AV, then use Win32 invalid param error,
        // otherwise, assume it was an inpage error dealing with a mapped-in
        // file.
        //
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;

        if(FreeMsgHandlerContext) {
            SetupTermDefaultQueueCallback(MsgHandlerContext);
        }
        if(CloseUserFileQ) {
            SetupCloseFileQueue(UserFileQ);
        }

        //
        // Access the following variables so that the compiler will respect our
        // statement ordering w.r.t. these values.  Otherwise, we may not be
        // able to know with certainty whether or not we should release their
        // corresponding resources.
        //
        DevInfoElem = DevInfoElem;
        hDeviceInf = hDeviceInf;
        hkDrv = hkDrv;
        DevIdBuffer = DevIdBuffer;
        DeleteServiceList = DeleteServiceList;
        OemInfFileToCopy = OemInfFileToCopy;
    }

    //
    // Clean up the registry if the install didn't go well.  Along with other
    // error paths, this handles the case where the user cancels the install
    // while copying files
    //
    if(Err != NO_ERROR) {

        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_BEGIN_CLEANUP_TIME,
            NULL);       // text message

        if(DevInfoElem && DoFullInstall) {
            //
            // Disable the device if the error wasn't a user cancel.
            //
            if(Err != ERROR_CANCELLED) {

                DWORD dwConfigFlagsSize;

                //
                // The device is in an unknown state.  Disable it by setting the
                // CONFIGFLAG_DISABLED config flag.
                //
                dwConfigFlagsSize = sizeof(DWORD);
                if(CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                    CM_DRP_CONFIGFLAGS,
                                                    NULL,
                                                    &dwConfigFlags,
                                                    &dwConfigFlagsSize,
                                                    0,
                                                    pDeviceInfoSet->hMachine) == CR_SUCCESS) {

                    dwConfigFlags |= (CONFIGFLAG_DISABLED | CONFIGFLAG_REINSTALL);
                    //
                    // Also, make sure we clear the finish-install flag.
                    //
                    dwConfigFlags &= ~CONFIGFLAG_FINISH_INSTALL;

                } else {
                    dwConfigFlags = CONFIGFLAG_DISABLED;
                }

                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_CONFIGFLAGS,
                                                 &dwConfigFlags,
                                                 sizeof(dwConfigFlags),
                                                 0,
                                                 pDeviceInfoSet->hMachine);
                //
                // Delete the driver key (as well as the device key, if it
                // didn't previously exist).
                //
                if(DevInfoElem->SelectedDriver) {

                    SetupDiDeleteDevRegKey(DeviceInfoSet,
                                           DeviceInfoData,
                                           DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGGENERAL,
                                           0,
                                           (DeleteDevKey ? DIREG_BOTH : DIREG_DRV)
                                          );
                }

                //
                // If necessary, delete any service entries created for this device instance.
                //
                if(DeleteServiceList) {
                    DeleteServicesInList(DeleteServiceList,LogContext);
                }
            }
        }

        //
        // If we copied the OEM INF into the INF directory under a
        // newly-generated name, delete it now.
        //
        if(OemInfFileToCopy) {
            pSetupUninstallOEMInf(szNewName, LogContext, SUOI_FORCEDELETE, NULL);
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(hDeviceInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hDeviceInf);
    }
    if(hkDrv != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkDrv);
    }
    if(DevIdBuffer) {
        MyFree(DevIdBuffer);
    }
    if(ValidationPlatform) {
        MyFree(ValidationPlatform);
    }
    if(DeleteServiceList) {

        PSVCNAME_NODE TmpSvcNode;

        for(TmpSvcNode = DeleteServiceList; TmpSvcNode; TmpSvcNode = DeleteServiceList) {
            DeleteServiceList = DeleteServiceList->Next;
            MyFree(TmpSvcNode);
        }
    }

    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of install
        // if copy install, only do in Verbose-Logging, else do for standard Info-Logging
        //
        WriteLogEntry(
            LogContext,
            DoFullInstall?DRIVER_LOG_INFO:DRIVER_LOG_VERBOSE,
            MSG_LOG_INSTALLED,
            NULL,
            DeviceFullID);
    } else {
        //
        // indicate install failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_INSTALL_ERROR_ENCOUNTERED,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
    }

    if (slot_deviceID) {
        ReleaseLogInfoSlot(LogContext,slot_deviceID);
    }
    if (slot_section) {
        ReleaseLogInfoSlot(LogContext,slot_section);
    }
    WriteLogEntry(
        LogContext,
        DRIVER_LOG_TIME,
        MSG_LOG_END_INSTALL_TIME,
        NULL);       // text message
    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiInstallDriverFiles(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_INSTALLDEVICEFILES

    This routine is similiar to a combination of SetupDiRegisterCoDeviceInstallers,
    SetupDiInstallDeviceInterfaces, and SetupDiInstallDevice, but it only performs
    the file copy commands in the install sections, and will not attempt to
    configure the device in any way.  This API is useful for pre-copying a device's
    driver files.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a device information element to be installed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for which
        a driver is to be installed.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    A driver must be selected for the specified device information element before
    calling this API.

--*/

{
    return _SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData, FALSE);
}


BOOL
WINAPI
SetupDiRemoveDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_REMOVE

    This routine removes a device from the system.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        device is to be removed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for
        which a device is to be removed.  This is an IN OUT parameter, since the
        DevInst field of the structure may be updated with a new handle value upon
        return.  (If this is a global removal, or the last hardware profile-specific
        removal, then all traces of the devinst are removed from the registry, and
        the handle becomes NULL at that point.)

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This routine will remove the device from the system, deleting both of its
    registry keys, and dynamically stopping the device if its DevInst is 'live'.
    If the device cannot be dynamically stopped, then flags will be set in the
    install parameter block that will eventually cause the user to be prompted
    to shut the system down.  The removal is either global to all hardware
    profiles, or specific to one hardware profile depending on the contents of
    the ClassInstallParams field.

    ** This API cannot be called for a remote HDEVINFO set **

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, ConfigFlags;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    PSP_REMOVEDEVICE_PARAMS RemoveDevParams;
    BOOL IsCurrentHwProfile = FALSE;
    ULONG HwProfFlags;
    DWORD HwProfileToRemove;
    HWPROFILEINFO HwProfileInfo;
    BOOL RemoveDevInst = FALSE, NukeDevInst = FALSE;
    BOOL RemoveGlobally;
    DEVINST DevNodeRemoved = 0;
    DWORD i;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;
    CONFIGRET cr;
    ULONG ulStatus;
    ULONG ulProblem;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD slot_deviceID = 0;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }

    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;

    try {
        //
        // This operation isn't supported for a remote HDEVINFO...
        //
        if(pDeviceInfoSet->hMachine) {
            Err = ERROR_REMOTE_REQUEST_UNSUPPORTED;
            goto clean0;
        }

        //
        // Locate the devinfo element to be removed.
        //
        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                   DeviceInfoData,
                                                   NULL)) {

            dipb = &(DevInfoElem->InstallParamBlock);
            LogContext = dipb->LogContext;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't be called if non-native drivers are involved.
        // (Note: while presently this doesn't matter, it's possible that in
        // the future uninstall will involve running one or more INF "uninstall"
        // sections, and I don't want to limit that possibility by introducing
        // the complication of non-native driver nodes.)
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        if(CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) == CR_SUCCESS &&
           (ulStatus & DN_ROOT_ENUMERATED) &&
            !(ulStatus & DN_DISABLEABLE)) {
           //
           // we cannot remove a root enumerated non-disableable device
           //
           Err = ERROR_NOT_DISABLEABLE;
           goto clean0;
        }

        //
        // Retrieve the name of the device instance.  This is necessary, because
        // we're about to remove the DEVINST, but we need to be able to locate it
        // again, as a phantom.  This should never fail.
        //
        if(CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                               DeviceInstanceId,
                               SIZECHARS(DeviceInstanceId),
                               0,
                               pDeviceInfoSet->hMachine) != CR_SUCCESS) {
            MYASSERT(!CR_SUCCESS);
            Err = ERROR_INVALID_DATA;
            goto clean0;
        }

        if(slot_deviceID == 0) {
            slot_deviceID = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_INFO,FALSE);
        }
        WriteLogEntry(
            LogContext,
            slot_deviceID,
            MSG_LOG_DO_REMOVE,
            NULL,       // text message
            DeviceInstanceId);

        //
        // See if there's a SP_REMOVEDEVICE_PARAMS structure we need to pay
        // attention to.
        //
        if((dipb->Flags & DI_CLASSINSTALLPARAMS) &&
           (dipb->ClassInstallHeader->InstallFunction == DIF_REMOVE)) {

            RemoveDevParams = (PSP_REMOVEDEVICE_PARAMS)(dipb->ClassInstallHeader);

            if(RemoveGlobally = (RemoveDevParams->Scope == DI_REMOVEDEVICE_GLOBAL)) {
                //
                // We are doing a global removal.  We still want to set CSCONFIGFLAG_DO_NOT_CREATE
                // for this device in the current hardware profile, so that someone else happening
                // to do an enumeration won't turn this guy back on before we get a chance to
                // remove it.
                //
                HwProfileToRemove = 0;

            } else {
                //
                // Remove device from a particular hardware profile.
                //
                HwProfileToRemove = RemoveDevParams->HwProfile;

                //
                // Set the CSCONFIGFLAG_DO_NOT_CREATE flag for the specified hardware profile.
                //
                if(CM_Get_HW_Prof_Flags_Ex(DeviceInstanceId,
                                        HwProfileToRemove,
                                        &HwProfFlags,
                                        0,
                                        pDeviceInfoSet->hMachine) == CR_SUCCESS) {

                    HwProfFlags |= CSCONFIGFLAG_DO_NOT_CREATE;
                } else {
                    HwProfFlags = CSCONFIGFLAG_DO_NOT_CREATE;
                }

                Err = MapCrToSpError(
                          CM_Set_HW_Prof_Flags_Ex(DeviceInstanceId, HwProfileToRemove,
                                                  HwProfFlags, 0,pDeviceInfoSet->hMachine),
                          ERROR_INVALID_DATA
                          );

                if(Err != NO_ERROR) {
                    goto clean0;
                }

                //
                // Determine if we are deleting the device from the current hw profile.
                //
                if((HwProfileToRemove == 0) ||
                   ((CM_Get_Hardware_Profile_Info_Ex((ULONG)-1, &HwProfileInfo,
                                                      0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                    (HwProfileInfo.HWPI_ulHWProfile == HwProfileToRemove))) {

                    IsCurrentHwProfile = TRUE;
                }

            }

            //
            // Is this the current hardware profile or a global removal AND
            // is there a present device?
            //
            if((IsCurrentHwProfile || RemoveGlobally) &&
               !(DevInfoElem->DiElemFlags & DIE_IS_PHANTOM) &&
               !(dipb->Flags & DI_DONOTCALLCONFIGMG)) {

                RemoveDevInst = TRUE;
            }

        } else {
            //
            // No device removal params given, so do a global removal.
            //
            RemoveGlobally = TRUE;
            HwProfileToRemove = 0;

            if(!(dipb->Flags & DI_DONOTCALLCONFIGMG)) {
                RemoveDevInst = TRUE;
            }
        }

        //
        // If this is a global removal, or the last hardware profile-specific one, then clean up
        // the registry.
        //
        if(RemoveGlobally || IsDevRemovedFromAllHwProfiles(DeviceInstanceId,pDeviceInfoSet->hMachine)) {
            NukeDevInst = TRUE;
        }

        if(RemoveDevInst) {

            TCHAR VetoName[MAX_PATH];
            PNP_VETO_TYPE VetoType;

            cr = CM_Query_And_Remove_SubTree_Ex(DevInfoElem->DevInst,
                                                &VetoType,
                                                VetoName,
                                                SIZECHARS(VetoName),
                                                CM_REMOVE_NO_RESTART |
                                                ((DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                    ? CM_REMOVE_UI_NOT_OK
                                                    : CM_REMOVE_UI_OK),
                                                pDeviceInfoSet->hMachine
                                               );

            if(cr == CR_SUCCESS) {
                //
                // Device instance successfully removed--now locate it as a phantom.
                //
                CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                  (DEVINSTID)DeviceInstanceId,
                                  CM_LOCATE_DEVINST_PHANTOM,
                                  pDeviceInfoSet->hMachine);

                DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;

                //
                // Set the DevNodeRemoved DevNode so that we know we need to
                // call CM_Setup_DevInst with the CM_SETUP_DEVNODE_RESET flag
                // to allow this devnode to come back online on the next
                // enumeration.
                //
                DevNodeRemoved = DevInfoElem->DevInst;

            } else {
                //
                // If the failure was due to a veto, then log information about
                // who vetoed us.
                //
                // SPLOG--write out an entry with real logging.
                //
                if(cr == CR_REMOVE_VETOED) {
                    //
                    // get the LogContext from dipb which should be a pointer
                    // to the appropriate DevInstallParamBlock
                    //
                    _WriteVetoLogEntry(
                        dipb->LogContext,
                        DRIVER_LOG_WARNING,
                        MSG_LOG_REMOVE_VETOED_IN_UNINSTALL,
                        DeviceInstanceId,
                        VetoName,
                        VetoType);
                }

                if (cr != CR_INVALID_DEVNODE) {
                    SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,
                                                         pDeviceInfoSet,
                                                         MSG_LOG_REBOOT_REASON_QR_VETOED_UNINSTALL,
                                                         cr,
                                                         (ULONG_PTR)_MapCmRetToString(cr)
                                                         );
                }
            }
        }

        if(NukeDevInst) {

            //
            // Remove all traces of this device from the registry.
            //
            pSetupDeleteDevRegKeys(DevInfoElem->DevInst,
                                   DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGSPECIFIC,
                                   (DWORD)-1,
                                   DIREG_BOTH,
                                   TRUE,
                                   pDeviceInfoSet->hMachine  // must be NULL
                                  );

            cr = CM_Uninstall_DevInst_Ex(DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine);
            if (cr != CR_SUCCESS) {
                //
                // we try to catch this earlier
                //
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                goto clean0;
            }

            //
            // The above API will also remove all device interfaces associated with this
            // device instance.  Now we need to mark every device interface node that we
            // are tracking for this devinfo element to indicate that they have been removed.
            //
            for(i = 0; i < DevInfoElem->InterfaceClassListSize; i++) {

                for(DeviceInterfaceNode = DevInfoElem->InterfaceClassList[i].DeviceInterfaceNode;
                    DeviceInterfaceNode;
                    DeviceInterfaceNode = DeviceInterfaceNode->Next) {

                    DeviceInterfaceNode->Flags |= SPINT_REMOVED;
                }
            }

            //
            // Mark this device information element as unregistered, and set its
            // devinst handle to NULL.
            //
            DevInfoElem->DiElemFlags &= ~DIE_IS_REGISTERED;
            DevInfoElem->DevInst = (DEVINST)0;
        }

        //
        // Now update the DevInst field of the DeviceInfoData structure with the new
        // value of the devinst handle (possibly NULL).
        //
        DeviceInfoData->DevInst = DevInfoElem->DevInst;

clean0: ;   // nothing to do.

    //
    // If the DevNode was really removed then we need to call CM_Setup_DevInst
    // with the CM_SETUP_DEVNODE_RESET flag to allow the devnode to come back
    // on the next enumeration.
    //
    if (DevNodeRemoved) {
        CM_Setup_DevInst_Ex(DevNodeRemoved,
                            CM_SETUP_DEVNODE_RESET,
                            pDeviceInfoSet->hMachine
                            );
    }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

clean1:
    if (slot_deviceID) {
        if (Err == NO_ERROR) {
            //
            // give a +ve affirmation of remove
            //
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_INFO,
                MSG_LOG_REMOVED,
                NULL);
        } else {
            //
            // indicate remove failed, display error
            //
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                MSG_LOG_REMOVE_ERROR,
                NULL);
            WriteLogError(
                LogContext,
                DRIVER_LOG_ERROR,
                Err);
        }
        ReleaseLogInfoSlot(LogContext,slot_deviceID);
    }
    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiUnremoveDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_UNREMOVE

    This routine unremoves a device from the system.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        device is to be unremoved.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for
        which a device is to be unremoved.  This is an IN OUT parameter, since the
        DevInst field of the structure may be updated with a new handle value upon
        return.

        This device must contain class install parameters for DIF_UNREMOVE
        or the API will fail with ERROR_NO_CLASSINSTALL_PARAMS.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This function will unremove the the device on the system, dynamically starting
    the device if possible.  If the device cannot be dynamically started, then flags
    will be set in the device install parameters that will eventually cause the user
    to be prompted to shut the system down.

    The unremoval is specific to one configuration, specified in the HwProfile field
    of the SP_UNREMOVEDEVICE_PARAMS class install parameters associated with this
    device information element.  (The Scope field of this structure must be set to
    DI_UNREMOVEDEVICE_CONFIGSPECIFIC.)

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    PSP_UNREMOVEDEVICE_PARAMS UnremoveDevParams;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    ULONG HwProfFlags;
    HWPROFILEINFO HwProfileInfo;
    DEVINST dnRoot;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    CONFIGRET cr;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }
    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;

    try {
        //
        // Locate the devinfo element to be unremoved.
        //
        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                   DeviceInfoData,
                                                   NULL)) {

            dipb = &(DevInfoElem->InstallParamBlock);
            LogContext = dipb->LogContext;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't be called if non-native drivers are involved.
        // (Note: while presently this doesn't matter, it's possible that in
        // the future this operation could involve running one or more INF
        // sections, and I don't want to limit that possibility by introducing
        // the complication of non-native driver nodes.)
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        //
        // We'd better have DIF_UNREMOVE class install params
        //
        if(!(dipb->Flags & DI_CLASSINSTALLPARAMS) ||
           (dipb->ClassInstallHeader->InstallFunction != DIF_UNREMOVE)) {

            Err = ERROR_NO_CLASSINSTALL_PARAMS;
            goto clean0;
        }

        UnremoveDevParams = (PSP_UNREMOVEDEVICE_PARAMS)(dipb->ClassInstallHeader);

        //
        // This only works in a hardware profile-specific manner.
        //
        MYASSERT(UnremoveDevParams->Scope == DI_UNREMOVEDEVICE_CONFIGSPECIFIC);

        //
        // Retrieve the name of the device instance.  We need to do this because
        // accessing hardware profile-specific config flags is done via name instead
        // of devnode handle.  (Also, we'll need this later after re-enumerating
        // this device's parent.)
        //
        if((cr = CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                                     DeviceInstanceId,
                                     SIZECHARS(DeviceInstanceId),
                                     0,
                                     pDeviceInfoSet->hMachine)) != CR_SUCCESS) {

            Err = MapCrToSpError(cr,ERROR_INVALID_DATA);
            goto clean0;
        }
        if(CM_Get_HW_Prof_Flags_Ex(DeviceInstanceId,
                                   UnremoveDevParams->HwProfile,
                                   &HwProfFlags,
                                   0,
                                   pDeviceInfoSet->hMachine) == CR_SUCCESS) {

            HwProfFlags &= ~CSCONFIGFLAG_DO_NOT_CREATE;

            Err = MapCrToSpError(
                      CM_Set_HW_Prof_Flags_Ex(DeviceInstanceId, UnremoveDevParams->HwProfile,
                                              HwProfFlags, 0,pDeviceInfoSet->hMachine),
                      ERROR_INVALID_DATA
                      );

            if(Err != NO_ERROR) {
                goto clean0;
            }
        }

        //
        // Determine if we are trying to un-remove the device in the current
        // hardware profile.
        //
        if((UnremoveDevParams->HwProfile == 0) ||
           ((CM_Get_Hardware_Profile_Info_Ex((ULONG)-1, &HwProfileInfo,
                                             0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
            (HwProfileInfo.HWPI_ulHWProfile == UnremoveDevParams->HwProfile))) {
            //
            // Make sure the device has started correctly.
            //
            if(CM_Locate_DevInst_Ex(&dnRoot, NULL, CM_LOCATE_DEVINST_NORMAL,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                //
                // Try to get this device enumerated
                //
                CM_Reenumerate_DevInst_Ex(dnRoot, CM_REENUMERATE_SYNCHRONOUS,pDeviceInfoSet->hMachine);

                if(CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                     (DEVINSTID)DeviceInstanceId,
                                     CM_LOCATE_DEVINST_NORMAL,
                                     pDeviceInfoSet->hMachine) == CR_SUCCESS) {

                    CheckIfDevStarted(DevInfoElem, pDeviceInfoSet);

                } else {
                    //
                    // We couldn't locate the devnode.  We don't need to
                    // request a reboot, because if the devnode ever shows up
                    // again, we should be able to bring it back on-line just
                    // fine.
                    //
                    // Retrieve the devnode as a phantom
                    //
                    CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                         (DEVINSTID)DeviceInstanceId,
                                         CM_LOCATE_DEVINST_PHANTOM,
                                         pDeviceInfoSet->hMachine
                                        );

                    DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;
                }

                //
                // Update the caller's buffer to reflect the new device instance handle
                //
                DeviceInfoData->DevInst = DevInfoElem->DevInst;

            } else {
                //
                // We couldn't locate the root of the hardware tree!  This should never happen...
                //
                Err = ERROR_INVALID_DATA;
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

clean1:
    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of unremove
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_INFO,
            MSG_LOG_UNREMOVED,
            NULL);
    } else {
        //
        // indicate unremove failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_UNREMOVE_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiMoveDuplicateDevice(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DestinationDeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_MOVEDEVICE.  This routine (and DIF code) has been
    deprecated.

Arguments:

    DeviceInfoSet - Supplied a handle to the device information set for which
        a device was to be moved.

    DestinationDeviceInfoData - Supplied the address of a SP_DEVINFO_DATA
        structure for the device instance that was the destination of the move.

Return Value:

    This function always returns FALSE, with GetLastError returning
    ERROR_DI_FUNCTION_OBSOLETE.

--*/

{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DestinationDeviceInfoData);

    SetLastError(ERROR_DI_FUNCTION_OBSOLETE);
    return FALSE;
}


BOOL
WINAPI
SetupDiChangeState(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_PROPERTYCHANGE

    This routine is used to change the state of an installed device.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        device's state is to be changed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure identifying
        the device whose state is to be changed.  This is an IN OUT parameter, since
        the DevInst field of the structure may be updated with a new handle value upon
        return.

Return Value:

    If the function succeeds, and there are files to be copied, the return value is TRUE.
    If the function fails, the return value is FALSE, and GetLastError returns the cause
    of failure.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb = NULL;
    DWORD   dwConfigFlags;
    HKEY    hk;
    DEVINST dnToReenum;
    DWORD   dwStateChange = 0;
    DWORD   dwFlags = 0;
    ULONG   lParam = 0;
    TCHAR   szDevID[MAX_DEVICE_ID_LEN];
    DWORD   dwHWProfFlags;
    HWPROFILEINFO HwProfileInfo;
    CONFIGRET cr;
    DWORD   slot_deviceID = 0;
    DWORD   action = MSG_LOG_PROPERTYCHANGE_ERROR;
    DWORD   actionerr = MSG_LOG_PROPERTYCHANGE_ERROR;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Locate the devinfo element whose state is to be changed.
        //
        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                   DeviceInfoData,
                                                   NULL)) {

            dipb = &(DevInfoElem->InstallParamBlock);
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        if((cr = CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                         szDevID,
                         SIZECHARS(szDevID),
                         0,
                         pDeviceInfoSet->hMachine)) != CR_SUCCESS) {
            //
            // this should never fail
            //
            MYASSERT(!CR_SUCCESS);
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }
        slot_deviceID = AllocLogInfoSlotOrLevel(dipb->LogContext,DRIVER_LOG_INFO,FALSE);
        if(slot_deviceID) {
            WriteLogEntry(
                dipb->LogContext,
                slot_deviceID,
                MSG_LOG_DO_PROPERTYCHANGE,
                NULL,       // text message
                szDevID);
        }

        //
        // This routine can't be called if non-native drivers are involved.
        // (Note: while presently this doesn't matter, it's possible that in
        // the future this operation could involve running one or more INF
        // sections, and I don't want to limit that possibility by introducing
        // the complication of non-native driver nodes.)
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        if(!(dipb->Flags & DI_CLASSINSTALLPARAMS) ||
           (dipb->ClassInstallHeader->InstallFunction != DIF_PROPERTYCHANGE)) {
            //
            // Don't have any class install parameters to tell us what needs to be done!
            //
            Err = ERROR_NO_CLASSINSTALL_PARAMS;
            goto clean0;
        }

        if(!DevInfoElem->DevInst) {
            Err = ERROR_NO_SUCH_DEVINST;
            goto clean0;
        }

        dwStateChange = ((PSP_PROPCHANGE_PARAMS)(dipb->ClassInstallHeader))->StateChange;
        dwFlags       = ((PSP_PROPCHANGE_PARAMS)(dipb->ClassInstallHeader))->Scope;
        lParam        = ((PSP_PROPCHANGE_PARAMS)(dipb->ClassInstallHeader))->HwProfile;

        //
        // DICS_FLAG_CONFIGGENERAL is allowed below and is ignored
        // people are relying on this broken behaviour
        //

        switch(dwStateChange) {

            case DICS_ENABLE:

                if(dwFlags == DICS_FLAG_GLOBAL) {
                    action = MSG_LOG_PROPERTYCHANGE_ENABLE_GLOBAL;
                    actionerr = MSG_LOG_PROPERTYCHANGE_ENABLE_GLOBAL_ERR;

                    //
                    // Clear the Disabled config flag, and attempt to enumerate the
                    // device.  Presumably it has a device node, it is just dormant (ie
                    // prob 80000001).
                    //
                    dwConfigFlags = GetDevInstConfigFlags(DevInfoElem->DevInst,
                                                          0,pDeviceInfoSet->hMachine) & ~CONFIGFLAG_DISABLED;

                    //
                    // Set the New config flags value
                    //
                    CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                     CM_DRP_CONFIGFLAGS,
                                                     &dwConfigFlags,
                                                     sizeof(dwConfigFlags),
                                                     0,
                                                     pDeviceInfoSet->hMachine);

                    if(!(dipb->Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {

                        if(CM_Enable_DevNode_Ex(DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                            //
                            // Find the parent of this devnode and reenumerate it to bring this devnode online.
                            //
                            if (CM_Get_Parent_Ex(&dnToReenum, DevInfoElem->DevInst, 0, pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                                //
                                // Process this devnode now.
                                //
                                CM_Reenumerate_DevNode_Ex(dnToReenum, CM_REENUMERATE_SYNCHRONOUS,pDeviceInfoSet->hMachine);
                            }

                            //
                            // See if we sucessfully started dynamically.
                            //
                            CheckIfDevStarted(DevInfoElem, pDeviceInfoSet);

                        } else {
                            //
                            // We could not enable so we should restart
                            //
                            SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                         MSG_LOG_REBOOT_REASON_ENABLE_FAILED);
                        }
                    }

                } else {
                    action = MSG_LOG_PROPERTYCHANGE_ENABLE_PROFILE;
                    actionerr = MSG_LOG_PROPERTYCHANGE_ENABLE_PROFILE_ERR;

                    //
                    // Get the hardware profile-specific flags
                    //
                    if(CM_Get_HW_Prof_Flags_Ex(szDevID, lParam, &dwHWProfFlags, 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                        //
                        // Clear the Disabled bit.
                        //
                        dwHWProfFlags &= ~CSCONFIGFLAG_DISABLED;
                    } else {
                        dwHWProfFlags = 0;
                    }

                    //
                    // Set the profile Flags for this device to Enabled.  Setting the flags will
                    // also bring the devnode on-line, if we're modifying the current hardware
                    // profile.
                    //
                    cr = CM_Set_HW_Prof_Flags_Ex(szDevID, lParam, dwHWProfFlags, 0, pDeviceInfoSet->hMachine);

                    if(cr == CR_NEED_RESTART) {

                        SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                     MSG_LOG_REBOOT_REASON_HW_PROF_ENABLE_FAILED);

                    } else if(cr != CR_SUCCESS) {

                        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        goto clean0;
                    }
                }
                break;

            case DICS_DISABLE:

                if(dwFlags == DICS_FLAG_GLOBAL) {

                    BOOL disabled = FALSE;

                    action = MSG_LOG_PROPERTYCHANGE_DISABLE_GLOBAL;
                    actionerr = MSG_LOG_PROPERTYCHANGE_DISABLE_GLOBAL_ERR;

                    //
                    // we try to dynamically disable a device
                    // if it fails with anything but CR_NOT_DISABLEABLE
                    // then we set flag to try to disable it on reboot
                    //

                    if(!(dipb->Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {

                        cr = CM_Disable_DevNode_Ex(DevInfoElem->DevInst,
                                                   CM_DISABLE_POLITE | CM_DISABLE_UI_NOT_OK,
                                                   pDeviceInfoSet->hMachine
                                                   );

                        if (cr == CR_SUCCESS) {

                            //
                            // we managed to disable it immediately
                            //
                            disabled = TRUE;

                        } else if (cr == CR_NOT_DISABLEABLE) {

                            //
                            // we couldn't and shouldn't try to disable it
                            //
                            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                            goto clean0;

                        } else {

                            //
                            // set flag to indicate a reboot is required to disable this
                            //
                            SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                         MSG_LOG_REBOOT_REASON_DISABLE_FAILED);
                        }
                    }

                    //
                    // Note: There is a case where reboot-disabled device becomes non-disableable
                    // nothing we can do about this!
                    //
                    // Try and set the Disabled config flag if not already set, even if we managed to disable it
                    //
                    dwConfigFlags = GetDevInstConfigFlags(DevInfoElem->DevInst,
                                                          0,pDeviceInfoSet->hMachine);


                    if ((dwConfigFlags & CONFIGFLAG_DISABLED) == 0) {
                        dwConfigFlags |= CONFIGFLAG_DISABLED;
                        //
                        // Set the New config flags value
                        //

                        cr = CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                         CM_DRP_CONFIGFLAGS,
                                                         &dwConfigFlags,
                                                         sizeof(dwConfigFlags),
                                                         0,
                                                         pDeviceInfoSet->hMachine);

                        if (cr != CR_SUCCESS) {
                            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                            goto clean0;
                        }
                    }

                    if (disabled) {
                        //
                        // We don't want DICS_DISABLE to increment the disable
                        // ref count, so if we disabled the device then we
                        // always want to enable it.  Note, however, that if we
                        // were successful in setting the CONFIGFLAG_DISABLED
                        // then the device won't come back when we enable it.
                        //
                        CM_Enable_DevNode_Ex(DevInfoElem->DevInst,
                                             0,
                                             pDeviceInfoSet->hMachine);
                    }

                } else {
                    action = MSG_LOG_PROPERTYCHANGE_DISABLE_PROFILE;
                    actionerr = MSG_LOG_PROPERTYCHANGE_DISABLE_PROFILE_ERR;

                    //
                    // Get the hardware profile-specific flags
                    //
                    if(CM_Get_HW_Prof_Flags_Ex(szDevID, lParam,
                                               &dwHWProfFlags, 0,pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                        dwHWProfFlags = 0;
                    }

                    //
                    // Set the Disabled bit.
                    //
                    dwHWProfFlags |= CSCONFIGFLAG_DISABLED;

                    //
                    // Set the profile Flags for this device to Disabled.  Setting this
                    // flag will also take this device off-line, if we're modifying the
                    // current hardware profile.
                    //
                    cr = CM_Set_HW_Prof_Flags_Ex(szDevID,
                                                 lParam,
                                                 dwHWProfFlags,
                                                 CM_SET_HW_PROF_FLAGS_UI_NOT_OK,
                                                 pDeviceInfoSet->hMachine
                                                 );

                    if(cr == CR_NEED_RESTART) {

                        SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                     MSG_LOG_REBOOT_REASON_HW_PROF_DISABLE_FAILED);

                    } else if(cr != CR_SUCCESS) {

                        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        goto clean0;
                    }
                }
                break;

            case DICS_PROPCHANGE:
                //
                // Properties have changed, so we need to remove the Devnode, and
                // re-enumerate its parent.
                //
                // Don't remove/reenumerate if reboot/restart is required, or if DI_DONOTCALLCONFIGMG
                // is set (the device may implement some form of 'non-stop' property change mechanism).
                //
                if(dipb->Flags & (DI_DONOTCALLCONFIGMG | DI_NEEDREBOOT | DI_NEEDRESTART)) {
                    action = MSG_LOG_PROPERTYCHANGE_NORESTART;
                } else {
                    TCHAR VetoName[MAX_PATH];
                    PNP_VETO_TYPE VetoType;

                    action = MSG_LOG_PROPERTYCHANGE_RESTART;
                    actionerr = MSG_LOG_PROPERTYCHANGE_RESTART_ERR;

                    CM_Get_Parent_Ex(&dnToReenum, DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine);

                    cr = CM_Query_And_Remove_SubTree_Ex(DevInfoElem->DevInst,
                                                        &VetoType,
                                                        VetoName,
                                                        SIZECHARS(VetoName),
                                                        (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                            ? CM_REMOVE_UI_NOT_OK
                                                            : CM_REMOVE_UI_OK,
                                                        pDeviceInfoSet->hMachine
                                                       );

                    if(cr == CR_SUCCESS) {

                        CM_Reenumerate_DevInst_Ex(dnToReenum, CM_REENUMERATE_SYNCHRONOUS,pDeviceInfoSet->hMachine);
                        DevInfoElem->DevInst = 0;

                        if(CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                                (DEVINSTID)szDevID,
                                                CM_LOCATE_DEVINST_NORMAL,
                                                pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                            //
                            // Make sure the device instance started OK
                            //
                            if(!CheckIfDevStarted(DevInfoElem,pDeviceInfoSet)) {
                                action = MSG_LOG_PROPERTYCHANGE_RESTART_FAILED;
                            }

                        } else {
                            //
                            // We couldn't locate the devnode.  We don't need
                            // to request a reboot, because if the devnode ever
                            // shows up again, we should be able to bring it
                            // back on-line just fine.
                            //
                            // Retrieve the devnode as a phantom
                            //
                            CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                                 (DEVINSTID)szDevID,
                                                 CM_LOCATE_DEVINST_PHANTOM,
                                                 pDeviceInfoSet->hMachine
                                                );

                            DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;
                        }

                        //
                        // Update the caller's buffer to reflect the new device instance handle
                        //
                        DeviceInfoData->DevInst = DevInfoElem->DevInst;


                    } else {
                        //
                        // If the failure was due to a veto, then log
                        // information about who vetoed us.
                        //
                        // SPLOG--write a log entry
                        //
                        if(cr == CR_REMOVE_VETOED) {
                            //
                            // get the LogContext from dipb which should be a pointer
                            // to the appropriate DevInstallParamBlock
                            //
                            _WriteVetoLogEntry(
                                dipb->LogContext,
                                DRIVER_LOG_WARNING,
                                MSG_LOG_REMOVE_VETOED_IN_PROPCHANGE,
                                szDevID,
                                VetoName,
                                VetoType);
                        }

                        SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                     MSG_LOG_REBOOT_VETOED_IN_PROPCHANGE);
                        action = MSG_LOG_PROPERTYCHANGE_RESTART_FAILED;
                    }
                }
                break;

            case DICS_START:
                action = MSG_LOG_PROPERTYCHANGE_START;
                actionerr = MSG_LOG_PROPERTYCHANGE_START_ERR;

                //
                // DICS_START is always config specific (we enforce this in SetupDiSetClassInstallParams).
                //
                MYASSERT(dwFlags == DICS_FLAG_CONFIGSPECIFIC);

                //
                // Get the Profile Flags.
                //
                if(CM_Get_HW_Prof_Flags_Ex(szDevID, lParam, &dwHWProfFlags, 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                    //
                    // Clear the "don't start" bit.
                    //
                    dwHWProfFlags &= ~CSCONFIGFLAG_DO_NOT_START;
                } else {
                    dwHWProfFlags = 0;
                }

                cr = CM_Set_HW_Prof_Flags_Ex(szDevID, lParam, dwHWProfFlags, 0, pDeviceInfoSet->hMachine);

                if(cr == CR_NEED_RESTART) {
                    //
                    // Since setting/clearing the CSCONFIGFLAG_DO_NOT_START doesn't
                    // automatically effect a change, we should never get here.
                    //
                    SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                 MSG_LOG_REBOOT_REASON_CLEAR_CSCONFIGFLAG_DO_NOT_START);
                    action = MSG_LOG_PROPERTYCHANGE_START_FAILED;

                } else if(cr != CR_SUCCESS) {

                    Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                    goto clean0;
                }

                //
                // Start the device instance if this is for the current config (ie dwConfigID/lparam == 0)
                //
                if((lParam == 0) ||
                   ((CM_Get_Hardware_Profile_Info_Ex((ULONG)-1, &HwProfileInfo,
                                                      0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                    (HwProfileInfo.HWPI_ulHWProfile == lParam)))
                {
                    //
                    // Try to start the devnode.
                    //
                    if(!(dipb->Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {
                        CM_Setup_DevNode_Ex(DevInfoElem->DevInst, CM_SETUP_DEVNODE_READY,pDeviceInfoSet->hMachine);
                        if(!CheckIfDevStarted(DevInfoElem, pDeviceInfoSet)) {
                            action = MSG_LOG_PROPERTYCHANGE_START_FAILED;
                        }
                    } else {
                        action = MSG_LOG_PROPERTYCHANGE_START_FAILED;
                    }
                }
                break;

            case DICS_STOP:
                action = MSG_LOG_PROPERTYCHANGE_STOP;
                actionerr = MSG_LOG_PROPERTYCHANGE_STOP_ERR;

                //
                // DICS_STOP is always config specific (we enforce this in SetupDiSetClassInstallParams).
                //
                MYASSERT(dwFlags == DICS_FLAG_CONFIGSPECIFIC);

                //
                // Get the Profile Flags.
                //
                if(CM_Get_HW_Prof_Flags_Ex(szDevID, lParam, &dwHWProfFlags,
                                           0,pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                    dwHWProfFlags = 0;
                }

                //
                // Set the "don't start" bit.
                //
                dwHWProfFlags |= CSCONFIGFLAG_DO_NOT_START;

                cr = CM_Set_HW_Prof_Flags_Ex(szDevID,
                                             lParam,
                                             dwHWProfFlags,
                                             CM_SET_HW_PROF_FLAGS_UI_NOT_OK,
                                             pDeviceInfoSet->hMachine
                                             );

                if(cr == CR_NEED_RESTART) {
                    //
                    // Since setting/clearing the CSCONFIGFLAG_DO_NOT_START doesn't
                    // automatically effect a change, we should never get here.
                    //
                    SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                 MSG_LOG_REBOOT_REASON_SET_CSCONFIGFLAG_DO_NOT_START);
                    action = MSG_LOG_PROPERTYCHANGE_STOP_FAILED;

                } else if(cr != CR_SUCCESS) {

                    Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                    goto clean0;
                }

                //
                // Stop the device instance if this is for the current config (ie dwConfigID/lparam == 0)
                //
                if((lParam == 0) ||
                   ((CM_Get_Hardware_Profile_Info_Ex((ULONG)-1, &HwProfileInfo,
                                                     0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                    (HwProfileInfo.HWPI_ulHWProfile == lParam)))
                {
                    //
                    // Try to stop the devnode.
                    //
                    if(!(dipb->Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {

                        TCHAR VetoName[MAX_PATH];
                        PNP_VETO_TYPE VetoType;

                        //
                        // Remove the device instance in order to stop the device.
                        //
                        cr = CM_Query_And_Remove_SubTree_Ex(DevInfoElem->DevInst,
                                                            &VetoType,
                                                            VetoName,
                                                            SIZECHARS(VetoName),
                                                            (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                                ? CM_REMOVE_UI_NOT_OK
                                                                : CM_REMOVE_UI_OK,
                                                            pDeviceInfoSet->hMachine
                                                           );

                        if(cr == CR_SUCCESS) {
                            //
                            // Device instance successfully removed--now locate it as a phantom.
                            //
                            CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                              (DEVINSTID)szDevID,
                                              CM_LOCATE_DEVINST_PHANTOM,
                                              pDeviceInfoSet->hMachine);

                            DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;
                            //
                            // Update the caller's buffer to reflect the new device instance handle.
                            //
                            DeviceInfoData->DevInst = DevInfoElem->DevInst;

                        } else {
                            //
                            // If the failure was due to a veto, then log
                            // information about who vetoed us.
                            //
                            // SPLOG--write out a real log entry
                            //
                            if(cr == CR_REMOVE_VETOED) {
                                //
                                // get the LogContext from dipb which should be a pointer
                                // to the appropriate DevInstallParamBlock
                                //
                                _WriteVetoLogEntry(
                                    dipb->LogContext,
                                    DRIVER_LOG_WARNING,
                                    MSG_LOG_REMOVE_VETOED_IN_STOP,
                                    szDevID,
                                    VetoName,
                                    VetoType);
                            }

                            SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,
                                                                 pDeviceInfoSet,
                                                                 MSG_LOG_REBOOT_QR_VETOED_IN_STOP,
                                                                 cr,
                                                                 (ULONG_PTR)_MapCmRetToString(cr)
                                                                 );
                        }
                    } else {
                        action = MSG_LOG_PROPERTYCHANGE_STOP_FAILED;
                    }
                }
                break;

            default:
                action = actionerr = MSG_LOG_PROPERTYCHANGE_UNKNOWN;
                Err = ERROR_DI_DO_DEFAULT;
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if(slot_deviceID) {
        if ((Err == NO_ERROR) || (Err == ERROR_DI_DO_DEFAULT)) {
            //
            // give a +ve affirmation of property change
            //
            WriteLogEntry(
                dipb->LogContext,
                Err ? DRIVER_LOG_ERROR : DRIVER_LOG_INFO,
                action,
                NULL,
                dwStateChange,
                dwFlags,
                lParam
                );
        } else {
            //
            // indicate property change failed, display error
            //
            WriteLogEntry(
                dipb->LogContext,
                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                actionerr,
                NULL,
                dwStateChange,
                dwFlags,
                lParam
                );
            WriteLogError(
                dipb->LogContext,
                DRIVER_LOG_ERROR,
                Err);
        }
        ReleaseLogInfoSlot(dipb->LogContext,slot_deviceID);
    }
    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


DWORD
GetNewInfName(
    IN     HWND                    Owner,                     OPTIONAL
    IN     PCTSTR                  OemInfName,
    IN     PCTSTR                  OemInfOriginalName,
    IN     PCTSTR                  OemInfCatName,             OPTIONAL
    OUT    PTSTR                   NewInfName,
    IN     DWORD                   NewInfNameSize,
    OUT    PDWORD                  RequiredSize,
    OUT    PNEWINF_COPYTYPE        CopyNeeded,
    IN     BOOL                    ReplaceOnly,
    IN     PCTSTR                  DeviceDesc,                OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   Flags,
    IN     PCTSTR                  AltCatalogFile,            OPTIONAL
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,           OPTIONAL
    OUT    PDWORD                  DriverSigningError,        OPTIONAL
    OUT    PTSTR                   CatalogFilenameOnSystem,
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT PVERIFY_CONTEXT         VerifyContext,             OPTIONAL
    OUT    HANDLE                 *hWVTStateData              OPTIONAL
    )
/*++

Routine Description:

    This routine finds a unique INF name of the form "<systemroot>\Inf\OEM<n>.INF",
    and returns it in the supplied buffer.  It leaves an (empty) file of that
    name in the INF directory, so that anyone else who attempts to generate a
    unique filename won't pick the same name.

    NOTE:  We will search the INF directory to determine if the specified INF is
    already present there based on the criteria outlined for SetupCopyOEMInf.
    If so, then we will return the existing name.  This name may be an
    OEM<n>.INF form, or it may be the same name as the source INF.

Arguments:

    Owner - supplies window to own any signature verification problem dialogs
        that must be displayed.

    OemInfName - Supplies the full pathname of the OEM INF that needs to be
        copied into the Inf directory (under a unique name).

    OemInfOriginalName - Supplies the original (simple) filename of the INF, to
        be used for digital signature verification (i.e., the INF is only known
        to the catalog under its original name).

    OemInfCatName - Optionally, supplies the simple filename of the catalog file
        specified by the OEM INF via a CatalogFile= entry in its [Version]
        section.

    NewInfName - supplies the address of a character buffer to store the unique
        name in.

    NewInfNameSize - Specifies the size, in characters, of the NewInfName buffer.

    RequiredSize - supplies the address of a variable that receives the size, in
        characters, required to store the full new filename.

    CopyNeeded - Supplies the address of an enum variable that is set upon
        successful return to indicate whether or not the OEM INF actually needs
        to be copied (and whether or not the previously-existing INF, if found,
        is zero-length.  This variable will be set to one of the following
        values:

        NewInfCopyNo         - no need to copy--INF already present in destination
        NewInfCopyYes,       - new INF placeholder created--need to copy real INF
        NewInfCopyZeroLength - previously-existing zero-length INF match found

    ReplaceOnly - If this flag is set, then this routine will fail if it doesn't
        find that the INF/CAT is already installed.

    DeviceDesc - Optionally, supplies the device description to be used in the
        digital signature verification error dialogs that may be popped up.

    DriverSigningPolicy - supplies the driver signing policy currently in
        effect.  Used when determining whether we can validate via an
        Authenticode catalog, and to control behavior of
        _HandleFailedVerification, if necessary.

    Flags - supplies flags which alter the behavior of the routine.  May be a
        combination of the following values:

        SCOI_NO_UI_ON_SIGFAIL - indicates whether user should be prompted (per
                                DriverSigningPolicy) if a digital signature
                                failure is encountered.  Used when calling
                                _HandleFailedVerification, if necessary.

        SCOI_NO_ERRLOG_ON_MISSING_CATALOG - if there's a signature verification
                                            failure due to the INF lacking a
                                            CatalogFile= entry, then that error
                                            will be ignored if this flag is set
                                            (no UI will be given, and no log
                                            entry will be generated).

        SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES - Install the INF and CAT under
                                               their original (current) names
                                               (i.e., don't generate a unique
                                               oem<n>.inf/cat name).  Used only
                                               for exception INFs.

        SCOI_ABORT_IF_UNSIGNED - If the INF is unsigned (and user wants to copy
                                 it anyway, or policy is Ignore), then _don't_
                                 copy the INF and instead return the error
                                 ERROR_SET_SYSTEM_RESTORE_POINT.  This gives
                                 the caller a chance to set a system restore
                                 point prior to installing the unsigned package.

        SCOI_TRY_UPDATE_PNF    - If an existing PNF cannot be updated, don't
                                 consider it fatal.

    AltCatalogFile - Optionally, supplies the full pathname of a catalog file to
        be installed and used for verification of the INF in cases where the INF
        doesn't specify a CatalogFile= entry (i.e., when the OemInfCatName
        parameter is not specified.

        If this parameter is specified (and OemInfCatName isn't specified), then
        this catalog will be used to validate the INF, and if successful, the
        catalog will be installed into the system using its current name (thus
        overwriting any existing catalog having that name).  Nothing more will
        be done with the INF--we won't even create a zero-length placeholder for
        it in this case.

    AltPlatformInfo - Optionally, supplies alternate platform information to be
        used in digital signature verification instead of the default (native)
        platform info.

    DriverSigningError - Optionally, supplies the address of a variable that
        receives the error encountered when attempting to verify the digital
        signature of either the INF or associated catalog.  If no digital
        signature problems were encountered, this is set to NO_ERROR.  (Note
        that this value can come back as NO_ERROR, yet GetNewInfName still
        failed for some other reason).

    CatalogFilenameOnSystem - receives the fully-qualified path of the catalog
        file within the catalog store where this INF's catalog file was
        installed to. This buffer should be at least MAX_PATH bytes (ANSI
        version) or chars (Unicode version).

    LogContext - supplies a LogContext to be used throughout the function.

    VerifyContext - optionally, supplies the address of a structure that caches
        various verification context handles.  These handles may be NULL (if
        not previously acquired, and they may be filled in upon return (in
        either success or failure) if they were acquired during the processing
        of this verification request.  It is the caller's responsibility to
        free these various context handles when they are no longer needed by
        calling pSetupFreeVerifyContextMembers.

    hWVTStateData - if supplied, this parameter points to a buffer that
        receives a handle to WinVerifyTrust state data.  This handle will be
        returned only when validation was successfully performed using
        Authenticode policy.  This handle may be used, for example, to retrieve
        signer info when prompting the user about whether they trust the
        publisher.  (The status code returned will indicate whether or not this
        is necessary, see "Return Value" section below.)

        This parameter *must* be supplied if the DRIVERSIGN_ALLOW_AUTHENTICODE
        bit is set in the caller-specified DriverSigningPolicy.  If the
        routine fails, then this handle will be set to NULL.

        It is the caller's responsibility to close this handle when they're
        finished with it by calling pSetupCloseWVTStateData().

Return Value:

    If the routine is successful, and the INF was successfully validated via
    driver signing policy, then the return value is NO_ERROR.

    If the routine is successful, the INF was successfully validated via
    Authenticode policy, and the publisher was in the TrustedPublisher store,
    then the return value is ERROR_AUTHENTICODE_TRUSTED_PUBLISHER.

    If the routine was successful, the INF was successfully validated via
    Authenticode policy, and the publisher was _not_ in the TrustedPublisher
    store (hence we must prompt the user to establish their trust of the
    publisher), then the return value is
    ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED.

    If a failure occurred, the return value is a Win32 error code indicating
    the cause of the failure.

--*/
{
    INT i;
    HANDLE h;
    DWORD Err, SavedErr;
    DWORD AuthenticodeErr = NO_ERROR;
    DWORD CpyErr;
    TCHAR szNewName[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    PTSTR FilenamePart;
    PTSTR FilenamePartCatFile;
    DWORD OemInfFileSize, CatalogFileSize;
    HANDLE OemInfFileHandle, OemInfMappingHandle;
    HANDLE CatalogFileHandle, CatalogMappingHandle;
    PVOID OemInfBaseAddress, CatalogBaseAddress;
    DWORD CurInfFileSize;
    HANDLE CurInfFileHandle, CurInfMappingHandle;
    PVOID CurInfBaseAddress;
    BOOL FileOfSameNameExists, MoreInfsToCheck;
    WIN32_FILE_ATTRIBUTE_DATA FileAttribData;
    BOOL FoundMatchingInf;
    TCHAR PathBuffer[MAX_PATH];
    TCHAR CatalogName[MAX_PATH];
    SetupapiVerifyProblem Problem = SetupapiVerifyNoProblem;
    PCTSTR ProblemFile;
    DWORD NumCatalogsConsidered;
    PTSTR LastResortInf;
    BOOL FileNewlyCreated;

    //
    // Initially, assume that the specified INF isn't already present in the
    // Inf directory.
    //
    *CopyNeeded = NewInfCopyYes;

    //
    // Initialize the driver signing error output parameter to success, and set
    // the CatalogFilenameOnSystem character buffer to an empty string.
    //
    if(DriverSigningError) {
        *DriverSigningError = NO_ERROR;
    }
    *CatalogFilenameOnSystem = TEXT('\0');

    //
    // This output parameter would get initialized if we ended up calling
    // _VerifyFile, but we might not do that, so make sure it starts out as
    // NULL (i.e., no user prompting for Authenticode publisher trust
    // verification necessary)
    //
    if(hWVTStateData) {
        *hWVTStateData = NULL;
    }

    //
    // If the caller requested that we allow for verification via Authenticode
    // policy, then they must also supply us with an output buffer in which to
    // store the resultant handle for the WinVerifyTrust state data.
    //
    MYASSERT(!(DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE) || hWVTStateData);

    if(OemInfCatName || !AltCatalogFile) {
        //
        // The INF has a CatalogFile= entry, or we don't have an override.  This
        // means we want to do the 'normal' behavior of looking for an existing
        // match in the INF directory, using default rules for which catalog
        // files we'll consider during validation, etc.
        //
        // Examine all the existing OEM INFs in the Inf directory, to see if
        // this INF already exists there.  If so, we'll just return the name of
        // the  previously-existing file.
        //
        MYVERIFY(SUCCEEDED(StringCchCopy(szNewName,SIZECHARS(szNewName),InfDirectory)));
        pSetupConcatenatePaths(szNewName, pszOemInfWildcard, SIZECHARS(szNewName), NULL);

        //
        // If we're supposed to install the INF and CAT under their original
        // names, then we don't want to look at any of the oem<n>.inf files.
        //
        if(Flags & SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES) {

            FindHandle = INVALID_HANDLE_VALUE;

            //
            // We'd better not have a policy that says it's acceptable to
            // validate via Authenticode!
            //
            MYASSERT(!(DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE));

        } else {
            FindHandle = FindFirstFile(szNewName, &FindData);
        }

        //
        // Now reuse our buffer to look for an INF in the Inf directory having
        // the same name as our OEM INF's original name.
        //
        FilenamePart = (PTSTR)pSetupGetFileTitle(szNewName);
        MYVERIFY(SUCCEEDED(StringCchCopy(FilenamePart,
                                         SIZECHARS(szNewName)-(FilenamePart-szNewName),
                                         OemInfOriginalName)));

        FileOfSameNameExists = GetFileAttributesEx(szNewName, GetFileExInfoStandard, &FileAttribData);

        if(FileOfSameNameExists && !OemInfCatName) {
            //
            // We can try to match up an OEM INF with a system INF having the
            // same name even if the INF doesn't specify a CatalogFile= entry,
            // but _not_ if the system INF is zero-length!
            //
            if(!FileAttribData.nFileSizeLow) {
                FileOfSameNameExists = FALSE;
            }
        }

        if((FindHandle != INVALID_HANDLE_VALUE) || FileOfSameNameExists) {
            //
            // We have at least one INF to compare against, so open our source
            // INF in preparation.
            //
            if(pSetupOpenAndMapFileForRead(OemInfName,
                                           &OemInfFileSize,
                                           &OemInfFileHandle,
                                           &OemInfMappingHandle,
                                           &OemInfBaseAddress) == NO_ERROR) {

                if(OemInfCatName) {
                    //
                    // INF has an associated catalog--map it into memory for
                    // subsequent comparisons with existing installed catalogs.
                    //
                    MYVERIFY(SUCCEEDED(StringCchCopy(CatalogName,
                                                     SIZECHARS(CatalogName),
                                                     OemInfName)));

                    FilenamePartCatFile = (PTSTR)pSetupGetFileTitle(CatalogName);
                    MYVERIFY(SUCCEEDED(StringCchCopy(FilenamePartCatFile,
                                                     SIZECHARS(CatalogName)-(FilenamePartCatFile-CatalogName),
                                                     OemInfCatName)));

                    if(NO_ERROR != pSetupOpenAndMapFileForRead(
                                       CatalogName,
                                       &CatalogFileSize,
                                       &CatalogFileHandle,
                                       &CatalogMappingHandle,
                                       &CatalogBaseAddress)) {
                        //
                        // Act as if the INF specified no CatalogFile.  This
                        // will allow us to match up with any OEM<n>.INF that
                        // binary-compares with this one.  We will consider
                        // this a digital signature verification failure,
                        // however.  (Refer to code below that explicitly fails
                        // OEM<n>.INF files that don't have a CatalogFile
                        // entry.)
                        //
                        // Note, also, in this case we don't want to consider
                        // a previously-existing INF in the Inf directory that
                        // has this OEM INF's original name.  That's because
                        // this would trip us up later because we'd believe we
                        // could do global validation on it (i.e., we'd think
                        // it was a system INF).
                        //

                        CatalogBaseAddress = NULL; // don't try to unmap and close later

                        if(FindHandle == INVALID_HANDLE_VALUE) {
                            //
                            // There are no OEM<n>.INF files to check--go ahead
                            // and bail.
                            //
                            goto FinishedCheckingOemInfs;
                        }

                        //
                        // There are some OEM<n>.INF files to check--make sure
                        // we _don't_ consider the originally-named file in
                        // %windir%\Inf, if it happens to exist.
                        //
                        FileOfSameNameExists = FALSE;

                        //
                        // Now make it look like the INF had no CatalogFile=
                        // entry in the first place.
                        //
                        OemInfCatName = NULL;
                        CatalogFileSize = 0;
                    }

                } else {
                    //
                    // INF didn't have a CatalogFile= entry in its version
                    // section.  This means we'll do global validation if we
                    // find an existing INF having this name that binary-compares
                    // identical.  If the verification succeeds, then we'll consider
                    // this a match.  Basically, this means you'll be able to
                    // re-install from system INFs, even if you point at them
                    // elsewhere (e.g., you point back at system.inf on the
                    // distribution media, but system.inf is already installed in
                    // your %windir%\Inf directory).
                    //
                    // If our INF doesn't specify a CatalogFile= entry, then
                    // we'll drop back to our pre-driver-signing behavior where
                    // we'll simply check to see if the INF's binary compare.
                    // If they do, then we know that there is no INF installed
                    // based on that matching INF's OEM name, thus we'll just
                    // drop out of the search loop and consider this a driver
                    // signing failure (which it is).
                    //
                    CatalogBaseAddress = NULL;
                    CatalogFileSize = 0;
                }

                LastResortInf = NULL;

                do {
                    if(FileOfSameNameExists) {
                        if(FileAttribData.nFileSizeHigh) {
                            goto CheckNextOemInf;
                        }
                        if(FileAttribData.nFileSizeLow &&
                           (FileAttribData.nFileSizeLow != OemInfFileSize)) {

                            goto CheckNextOemInf;
                        }
                        //
                        // Note:  We will consider a zero-length system INF
                        // that has the same name as our OEM INF, even if our
                        // OEM INF doesn't have a CatalogFile= entry in its
                        // version section.  This allows us to re-use this name
                        // as long as we find our catalog is already installed.
                        //
                        CurInfFileSize = FileAttribData.nFileSizeLow;

                    } else {
                        if(FindData.nFileSizeHigh) {
                            goto CheckNextOemInf;
                        }
                        if(FindData.nFileSizeLow &&
                           (FindData.nFileSizeLow != OemInfFileSize)) {

                            goto CheckNextOemInf;
                        }
                        CurInfFileSize = FindData.nFileSizeLow;

                        //
                        // Build the fully-qualified path to the INF being
                        // compared.
                        //
                        MYVERIFY(SUCCEEDED(StringCchCopy(FilenamePart,
                                                         SIZECHARS(szNewName)-(FilenamePart-szNewName),
                                                         FindData.cFileName)));
                    }

                    //
                    // If the INF isn't zero-length, then map it into memory to
                    // see if it matches our OEM INF.
                    //
                    if(CurInfFileSize) {

                        if(NO_ERROR == pSetupOpenAndMapFileForRead(
                                           szNewName,
                                           &CurInfFileSize,
                                           &CurInfFileHandle,
                                           &CurInfMappingHandle,
                                           &CurInfBaseAddress)) {

                            //
                            // Surround the following in try/except, in case we
                            // get an inpage error.
                            //
                            try {
                                //
                                // We've found a potential match.
                                //
                                FoundMatchingInf = !memcmp(OemInfBaseAddress,
                                                           CurInfBaseAddress,
                                                           OemInfFileSize
                                                          );

                            } except(EXCEPTION_EXECUTE_HANDLER) {
                                FoundMatchingInf = FALSE;
                            }

                            pSetupUnmapAndCloseFile(CurInfFileHandle,
                                                    CurInfMappingHandle,
                                                    CurInfBaseAddress
                                                   );
                        } else {
                            FoundMatchingInf = FALSE;
                        }

                        if(!FoundMatchingInf) {
                            goto CheckNextOemInf;
                        }

                        //
                        // If this is an OEM*.INF name and the INF has no
                        // CatalogFile= entry, then we've found our match.  Set
                        // up our driver signing problem variables to indicate
                        // that there was an INF failure (since there was no
                        // catalog.
                        //
                        if(!OemInfCatName && !FileOfSameNameExists) {
                            *CopyNeeded = NewInfCopyNo;
                            Problem = SetupapiVerifyInfProblem;
                            ProblemFile = OemInfName;
                            Err = ERROR_NO_CATALOG_FOR_OEM_INF;
                            //
                            // go to end of loop (we'll drop out since we've
                            // found a match).
                            //
                            goto CheckNextOemInf;
                        }

                    } else {
                        //
                        // The current INF we're considering for a match is
                        // zero-length.  This won't work for us if the INF
                        // we're searching for doesn't have a CatalogFile=
                        // entry, and this isn't an INF having the same name.
                        //
                        if(!OemInfCatName && !FileOfSameNameExists) {
                            goto CheckNextOemInf;
                        }
                    }

                    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
                        //
                        // We aren't using crypto, so if the file we found
                        // isn't zero-length, we've found our match.
                        //
                        if(CurInfFileSize) {
                            Err = NO_ERROR;
                        } else {
                            //
                            // File is zero-length.  Keep looking.
                            //
                            goto CheckNextOemInf;
                        }

                    } else {
                        //
                        // OK, the files binary compare OK (unless the one
                        // we're currently examining is zero length!), but
                        // we're not out of the woods yet!  If the INF we're
                        // examining had a CatalogFile= entry, then generate
                        // the catalog name to be used for verification (based
                        // on the filename of the INF we're examining).
                        //
                        if(OemInfCatName) {
                            if(MYVERIFY(SUCCEEDED(StringCchCopy(
                                                      CatalogName,
                                                      SIZECHARS(CatalogName),
                                                      FilenamePart)))) {

                                PTSTR DotPart;
                                DotPart = _tcsrchr(CatalogName, TEXT('.'));
                                if(MYVERIFY(DotPart!=NULL)) {
                                    MYVERIFY(SUCCEEDED(StringCchCopy(
                                                           DotPart,
                                                           SIZECHARS(CatalogName)-(DotPart-CatalogName),
                                                           pszCatSuffix)));
                                }
                            }
                        }

                        //
                        // Now verify the INF's signature against the specified
                        // catalog (or globally if the INF doesn't specify a
                        // catalog).
                        //
                        Err = _VerifyFile(LogContext,
                                          VerifyContext,
                                          (OemInfCatName ? CatalogName : NULL),
                                          CatalogBaseAddress,
                                          CatalogFileSize,
                                          OemInfOriginalName,
                                          OemInfName,
                                          &Problem,
                                          PathBuffer,
                                          FALSE,
                                          AltPlatformInfo,
                                          (VERIFY_FILE_IGNORE_SELFSIGNED
                                           | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                          CatalogFilenameOnSystem,
                                          &NumCatalogsConsidered,
                                          NULL,
                                          NULL,
                                          NULL
                                         );

                        if((Err != NO_ERROR) && (Err != ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH) &&
                           OemInfCatName &&
                           (DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE)) {
                            //
                            // If we failed to validate via standard OS code-
                            // signing policy (for some reason other than an
                            // osattibute mismatch), and we're allowed to
                            // attempt validation via an Authenticode-signed
                            // catalog, then try again.
                            //
                            MYASSERT(!(*CatalogFilenameOnSystem));

                            AuthenticodeErr = _VerifyFile(
                                                  LogContext,
                                                  VerifyContext,
                                                  CatalogName,
                                                  CatalogBaseAddress,
                                                  CatalogFileSize,
                                                  OemInfOriginalName,
                                                  OemInfName,
                                                  &Problem,
                                                  PathBuffer,
                                                  FALSE,
                                                  AltPlatformInfo,
                                                  (VERIFY_FILE_IGNORE_SELFSIGNED
                                                   | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK
                                                   | VERIFY_FILE_USE_AUTHENTICODE_CATALOG),
                                                  CatalogFilenameOnSystem,
                                                  &NumCatalogsConsidered,
                                                  NULL,
                                                  NULL,
                                                  hWVTStateData
                                                 );

                            if((AuthenticodeErr == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                               (AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                                //
                                // The catalog validated via Authenticode
                                // policy--reset the error (previously
                                // received during the failed attempt at
                                // validation via driversigning policy).
                                //
                                Err = NO_ERROR;

                            } else {
                                //
                                // Transfer Authenticode error over to be
                                // the "official" failure.  We always want
                                // the Authenticode error to be NO_ERROR
                                // unless it's one of the two "special"
                                // values.
                                //
                                MYASSERT(AuthenticodeErr != NO_ERROR);

                                Err = AuthenticodeErr;
                                AuthenticodeErr = NO_ERROR;
                            }
                        }
                    }

                    if(Err == NO_ERROR) {
                        //
                        // We've found this INF/CAT combination already
                        // installed, and the signatures check out!
                        //
                        *CopyNeeded = CurInfFileSize ? NewInfCopyNo
                                                     : NewInfCopyZeroLength;

                        Problem = SetupapiVerifyNoProblem;

                    } else if(CurInfFileSize &&
                              (Err == ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH)) {
                        //
                        // We found this INF/CAT combination already installed,
                        // but it's no longer valid.  This could happen, for
                        // example, if a driver WHQL-signed for a given version
                        // of the OS was installed on that version of the OS.
                        // Then, the OS was subsequently upgraded, and backward
                        // compatibility was not maintained for the device's
                        // class.  Thus, while the INF and CAT were valid at
                        // the time of install, they no longer are valid (even
                        // though there's been no tampering with the INF/CAT).
                        //
                        // We still want to use this INF, but we also want to
                        // warn the user that it's not validly signed.
                        //
                        MYASSERT(Problem == SetupapiVerifyFileProblem);
                        MYASSERT(*CatalogFilenameOnSystem);

                        ProblemFile = PathBuffer;
                        *CopyNeeded = NewInfCopyNo;

                    } else {
                        //
                        // We should never see SetupapiVerifyCatalogProblem
                        // reported, since we're validating against a set of
                        // catalogs, and a match might be found in several
                        // (though, none turn out to successfully validate).
                        // It therefore makes no sense to "blame" any
                        // particular catalog.
                        //
                        MYASSERT(Problem != SetupapiVerifyCatalogProblem);

                        if((Problem == SetupapiVerifyFileProblem) &&
                           !(*CatalogFilenameOnSystem)) {
                            //
                            // We didn't find a catalog match--move on to the
                            // next INF (note: there still might be a match
                            // later on, because if the INF specified a
                            // CatalogFile= entry, we must match on _both_ the
                            // catalog filename _and_ the catalog's image.
                            //
                            // However, if the number of catalogs we considered
                            // when examining this INF/CAT combination was
                            // zero, that means that there is no installed
                            // catalog for this INF, thus we can use it if we
                            // don't find anything better.  The reason why we'd
                            // rather not use this INF is that it obviously
                            // wasn't properly installed, hence the original
                            // source name and location info is almost
                            // certainly bogus.  (One more thing--make sure the
                            // catalog isn't zero length.  If it is, then that
                            // definitely implies that this was being used as a
                            // placeholder by setupapi, and we don't want to
                            // touch it!)
                            //
                            if(!NumCatalogsConsidered &&
                               !LastResortInf &&
                               CurInfFileSize)
                            {
                                LastResortInf = DuplicateString(szNewName);
                                SavedErr = Err;
                            }
                            goto CheckNextOemInf;
                        }

                        //
                        // We want to fall on through and proceed with
                        // examining other INFs for a potential match--this one
                        // ain't it!
                        //
                    }

CheckNextOemInf:

                    if(FileOfSameNameExists) {
                        FileOfSameNameExists = FALSE;
                        MoreInfsToCheck = (FindHandle != INVALID_HANDLE_VALUE);
                    } else {
                        MoreInfsToCheck = FindNextFile(FindHandle, &FindData);
                    }

                } while((*CopyNeeded == NewInfCopyYes) && MoreInfsToCheck);

                if(LastResortInf) {

                    if(*CopyNeeded == NewInfCopyYes) {
                        //
                        // We didn't find any better INF, so we'll try to use
                        // the incorrectly-installed INF.
                        //
                        // If this INF doesn't specify a CatalogFile= entry,
                        // then we'll just automatically set up the digital
                        // signature verification failure parameters, because
                        // that's the state we're in.
                        //
                        if(!OemInfCatName) {
                            Err = SavedErr;
                            Problem = SetupapiVerifyInfProblem;
                            MYVERIFY(SUCCEEDED(StringCchCopy(PathBuffer,
                                                             SIZECHARS(PathBuffer),
                                                             OemInfName)));
                            ProblemFile = PathBuffer;
                        } else {
                            //
                            // Attempt to verify our OEM INF's catalog, and if
                            // it verifies, then install it.  We clear the
                            // problem set earlier, since we really don't have
                            // a problem (yet).  If we do encounter a failure
                            // below, we'll set the failure as appropriate.
                            //
                            Problem = SetupapiVerifyNoProblem;

                            MYVERIFY(SUCCEEDED(StringCchCopy(CatalogName,
                                                             SIZECHARS(CatalogName),
                                                             OemInfName)));
                            *((PTSTR)pSetupGetFileTitle(CatalogName)) = TEXT('\0');
                            pSetupConcatenatePaths(CatalogName,
                                                   OemInfCatName,
                                                   SIZECHARS(CatalogName),
                                                   NULL
                                                  );

                            Err = _VerifyFile(LogContext,
                                              VerifyContext,
                                              CatalogName,
                                              NULL,
                                              0,
                                              OemInfOriginalName,
                                              OemInfName,
                                              &Problem,
                                              PathBuffer,
                                              FALSE,
                                              AltPlatformInfo,
                                              (VERIFY_FILE_IGNORE_SELFSIGNED
                                               | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL
                                             );

                            if((Err != NO_ERROR) &&
                               (Err != ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH) &&
                               (DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE)) {
                                //
                                // If we failed to validate via standard OS
                                // code-signing policy (due to some problem
                                // other than osattribute mismatch), and we're
                                // allowed to attempt validation via an
                                // Authenticode signed catalog, then try again.
                                //
                                AuthenticodeErr = _VerifyFile(
                                                      LogContext,
                                                      VerifyContext,
                                                      CatalogName,
                                                      NULL,
                                                      0,
                                                      OemInfOriginalName,
                                                      OemInfName,
                                                      &Problem,
                                                      PathBuffer,
                                                      FALSE,
                                                      AltPlatformInfo,
                                                      (VERIFY_FILE_IGNORE_SELFSIGNED
                                                       | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK
                                                       | VERIFY_FILE_USE_AUTHENTICODE_CATALOG),
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      hWVTStateData
                                                     );

                                if((AuthenticodeErr == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                                   (AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                                    //
                                    // The catalog validated via
                                    // Authenticode policy--reset the error
                                    // (previously received during the
                                    // failed attempt at validation via
                                    // driversigning policy).
                                    //
                                    Err = NO_ERROR;

                                } else {
                                    //
                                    // Transfer Authenticode error over to
                                    // be the "official" failure.  We
                                    // always want the Authenticode error
                                    // to be NO_ERROR unless it's one of
                                    // the two "special" values.
                                    //
                                    MYASSERT(AuthenticodeErr != NO_ERROR);

                                    Err = AuthenticodeErr;
                                    AuthenticodeErr = NO_ERROR;
                                }
                            }

                            if(Err != NO_ERROR) {

                                if(Problem != SetupapiVerifyCatalogProblem) {

                                    MYASSERT(Problem != SetupapiVerifyNoProblem);
                                    //
                                    // If the problem was not a catalog problem,
                                    // then it's an INF problem (the _VerifyFile
                                    // routine doesn't know the file we passed
                                    // it is an INF).
                                    //
                                    Problem = SetupapiVerifyInfProblem;
                                }
                                ProblemFile = PathBuffer;

                            } else {
                                //
                                // Make sure we aren't remembering any residual
                                // intermediate problems...
                                //
                                Problem = SetupapiVerifyNoProblem;

                                //
                                // Only attempt to install a catalog if we're
                                // not running in "minimal embedded" mode...
                                //
                                if(!(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED)) {
                                    //
                                    // Take the INF's new, unique name and
                                    // generate a unique catalog filename under
                                    // setupapi's namespace by simply replacing
                                    // ".INF" with ".CAT".
                                    //
                                    if(MYVERIFY(SUCCEEDED(StringCchCopy(
                                                              PathBuffer,
                                                              SIZECHARS(PathBuffer),
                                                              pSetupGetFileTitle(LastResortInf))))) {

                                        PTSTR DotPart = _tcsrchr(PathBuffer, TEXT('.'));
                                        if(MYVERIFY(DotPart != NULL)) {

                                            MYVERIFY(SUCCEEDED(StringCchCopy(
                                                                   DotPart,
                                                                   SIZECHARS(PathBuffer)-(DotPart-PathBuffer),
                                                                   pszCatSuffix)));
                                        }
                                    }

                                    //
                                    // At this point, PathBuffer contains the
                                    // basename to be used for the catalog on
                                    // the system, and CatalogName is the
                                    // fully-qualified path of the catalog file
                                    // in the oem location.
                                    //
                                    Err = pSetupInstallCatalog(
                                              CatalogName,
                                              PathBuffer,
                                              CatalogFilenameOnSystem
                                              );

                                    if(Err != NO_ERROR) {
                                        Problem = SetupapiVerifyCatalogProblem;
                                        ProblemFile = CatalogName;
                                    }
                                }
                            }
                        }

                        MYVERIFY(SUCCEEDED(StringCchCopy(szNewName,
                                                         SIZECHARS(szNewName),
                                                         LastResortInf)));

                        //
                        // We will never consider a zero-length INF as a last-
                        // resort candidate, thus if we get here we know the
                        // previously-existing INF wasn't zero-length.
                        //
                        *CopyNeeded = NewInfCopyNo;
                    }
                    MyFree(LastResortInf);
                }

FinishedCheckingOemInfs:
                if(CatalogBaseAddress) {
                    pSetupUnmapAndCloseFile(CatalogFileHandle, CatalogMappingHandle, CatalogBaseAddress);
                }
                pSetupUnmapAndCloseFile(OemInfFileHandle, OemInfMappingHandle, OemInfBaseAddress);
            }

            if(FindHandle != INVALID_HANDLE_VALUE) {
                FindClose(FindHandle);
            }
        }

    } else {
        //
        // The INF has no CatalogFile= entry, and we have an alternate catalog
        // to use.  Validate our INF using the specified alternate catalog.
        //
        // We don't bother trying to "fall back" to an Authenticode signature,
        // since it's invalid for an INF to validate via an Authenticode
        // catalog unless that INF explicitly references the catalog.
        //
        Err = _VerifyFile(LogContext,
                          VerifyContext,
                          AltCatalogFile,
                          NULL,
                          0,
                          OemInfOriginalName,
                          OemInfName,
                          &Problem,
                          PathBuffer,
                          FALSE,
                          AltPlatformInfo,
                          (VERIFY_FILE_IGNORE_SELFSIGNED
                           | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL
                         );

        if(Err != NO_ERROR) {

            if(Problem != SetupapiVerifyCatalogProblem) {

                MYASSERT(Problem != SetupapiVerifyNoProblem);
                //
                // If the problem was not a catalog problem,
                // then it's an INF problem (the _VerifyFile
                // routine doesn't know the file we passed
                // it is an INF).
                //
                Problem = SetupapiVerifyInfProblem;
            }
            ProblemFile = PathBuffer;

        } else {
            //
            // Make sure we aren't remembering any residual intermediate
            // problems...
            //
            Problem = SetupapiVerifyNoProblem;

            //
            // Only attempt to install a catalog if we're not running in
            // "minimal embedded" mode...
            //
            if(!(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED)) {

                Err = pSetupInstallCatalog(
                          AltCatalogFile,
                          pSetupGetFileTitle(AltCatalogFile),
                          CatalogFilenameOnSystem
                          );

                if(Err != NO_ERROR) {
                    Problem = SetupapiVerifyCatalogProblem;
                    ProblemFile = AltCatalogFile;
                }
            }
        }

        //
        // An INF copy is never needed when we're using an alternate catalog.
        //
        *CopyNeeded = NewInfCopyNo;

        //
        // Setup szNewName to be the same as the INF's present full pathname.
        // Since we didn't copy this into the INF directory (or even create a
        // zero-length placeholder), the only reasonable path to return is the
        // INF's current full pathname.
        //
        MYVERIFY(SUCCEEDED(StringCchCopy(szNewName,
                                         SIZECHARS(szNewName),
                                         OemInfName)));
    }

    if(*CopyNeeded != NewInfCopyYes) {

        MYASSERT(((Problem == SetupapiVerifyNoProblem) && (Err == NO_ERROR)) ||
                 ((Problem != SetupapiVerifyNoProblem) && (Err != NO_ERROR)));

        //
        // Then this INF already exists in the Inf directory (or at least its
        // zero-length placeholder does), and its associated catalog (if it has
        // one) is already installed, too.  If either of these files had a
        // signature verification problem (or we need to establish the user's
        // trust of an Authenticode signature publisher), then inform the user
        // now (based on policy).
        //
        if((Problem != SetupapiVerifyNoProblem) ||
           (AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {

            BOOL result;

            MYASSERT((Err != NO_ERROR) || (hWVTStateData && *hWVTStateData));

            //
            // If we're here to ask the user whether they trust an Authenticode
            // publisher, then we'd better not have encountered a verification
            // error...
            //
            MYASSERT((AuthenticodeErr != ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) ||
                     (Err == NO_ERROR));

            if(DriverSigningError) {
                *DriverSigningError = Err;
            }

            if(((Err == ERROR_NO_CATALOG_FOR_OEM_INF) && (Flags & SCOI_NO_ERRLOG_ON_MISSING_CATALOG)) ||
               (Flags & SCOI_NO_ERRLOG_IF_INF_ALREADY_PRESENT)) {
                //
                // We shouldn't do any UI/logging because of one of the two
                // following reasons:
                //
                // 1.  This may be a valid INF after all (i.e., if it uses
                //     layout.inf for source media info, or doesn't copy any
                //     files at all).
                //
                // 2.  We were asked not to.  The public API, SetupCopyOEMInf
                //     doesn't want/need anything to happen here, because the
                //     INF is already present, and we haven't really done
                //     anything (except potentially update the source path
                //     information contained in the PNF), thus there's no
                //     reason to make noise about this.
                //
                result = TRUE;

            } else {
                result = _HandleFailedVerification(
                             Owner,
                             ((AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)
                                 ? SetupapiVerifyCatalogProblem
                                 : Problem),
                             ((AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)
                                 ? CatalogName
                                 : ProblemFile),
                             DeviceDesc,
                             DriverSigningPolicy,
                             (Flags & SCOI_NO_UI_ON_SIGFAIL),
                             ((Err == NO_ERROR) ? AuthenticodeErr : Err),
                             LogContext,
                             NULL,
                             NULL,
                             (hWVTStateData ? *hWVTStateData : NULL)
                            );

                if(result) {
                    //
                    // The user wants to proceed with the unsigned/untrusted
                    // installation (or policy is Ignore, so they weren't even
                    // informed).  If we were able to confirm with the user
                    // that they trust the Authenticode publisher, then set our
                    // error to indicate this.
                    //
                    if(AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) {

                        MYASSERT(DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE);
                        MYASSERT((DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                                 != DRIVERSIGN_BLOCKING);

                        if((DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                           != DRIVERSIGN_NONE) {

                            AuthenticodeErr = ERROR_AUTHENTICODE_TRUSTED_PUBLISHER;
                        }

                    } else {
                        //
                        // If the caller wants a chance to set a system restore
                        // point prior to doing any unsigned installations, then we
                        // abort now with a "special" error code that tells them
                        // what to do...
                        //
                        if(Flags & SCOI_ABORT_IF_UNSIGNED) {

                            if(hWVTStateData && *hWVTStateData) {
                                pSetupCloseWVTStateData(*hWVTStateData);
                                *hWVTStateData = NULL;
                            }

                            return ERROR_SET_SYSTEM_RESTORE_POINT;
                        }
                    }
                }
            }

            if(!result) {

                if(hWVTStateData && *hWVTStateData) {

                    pSetupCloseWVTStateData(*hWVTStateData);
                    *hWVTStateData = NULL;

                    MYASSERT(Err == NO_ERROR);

                    //
                    // Need to report some error, since the user indicated they
                    // don't want to trust the publisher of this Authenticode-
                    // signed package (unless policy was block, in which case
                    // they didn't have a choice).
                    //
                    MYASSERT(DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE);

                    Err = ERROR_AUTHENTICODE_PUBLISHER_NOT_TRUSTED;
                }

                return Err;
            }
        }

        //
        // There was no problem, or the user elected to install in spite of a
        // problem, so return the INF name we found.
        //
        *RequiredSize = lstrlen(szNewName) + 1;

        if(*RequiredSize < NewInfNameSize) {

            MYVERIFY(SUCCEEDED(StringCchCopy(NewInfName, *RequiredSize, szNewName)));

            //
            // If Authenticode verification was done, then we'll return one of
            // the two errors appropriate to that.  Otherwise, we'll return
            // NO_ERROR (that's what we initialized our AuthenticodeErr
            // variable to at the beginning of this routine).
            //
            MYASSERT((AuthenticodeErr == NO_ERROR) ||
                     (AuthenticodeErr == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                     (AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED));

            return AuthenticodeErr;

        } else {
            //
            // So close, yet so far. :-(  Free the WinVerifyTrust state data,
            // if any, since the caller won't be expecting it when a failure is
            // encountered due to insufficient buffer.
            //
            if(hWVTStateData && *hWVTStateData) {
                pSetupCloseWVTStateData(*hWVTStateData);
                *hWVTStateData = NULL;
            }

            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    //
    // If we're in 'replace only' mode, then the fact that we didn't find the
    // INF/CAT already installed above means we should fail with
    // ERROR_FILE_NOT_FOUND.
    //
    if(ReplaceOnly) {

        if(hWVTStateData && *hWVTStateData) {
            pSetupCloseWVTStateData(*hWVTStateData);
            *hWVTStateData = NULL;
        }

        return ERROR_FILE_NOT_FOUND;
    }

    //
    // OK, so the INF isn't presently in the Inf directory--find a unique name
    // for it.  (Note: We'll go into the loop below even if we're meant to be
    // installing the INF and CAT under their original names.  We'll just skip
    // the auto-generation part, and then we'll break out of the loop once
    // we've made the attempt at INF/CAT installation.)
    //
    for(i = 0; i < 100000; i++) {

        if(Flags & SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES) {
            MYVERIFY(SUCCEEDED(StringCchCopy(szNewName,
                                             SIZECHARS(szNewName),
                                             InfDirectory)));
            pSetupConcatenatePaths(szNewName, OemInfOriginalName, SIZECHARS(szNewName), NULL);
        } else {
            MYVERIFY(SUCCEEDED(StringCchPrintf(szNewName,
                                               SIZECHARS(szNewName),
                                               pszOemInfGenerate,
                                               InfDirectory,
                                               i)));
        }

        Err = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                          h = CreateFile(szNewName,
                                         GENERIC_READ | GENERIC_WRITE,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL)
                         );

        if(Err == NO_ERROR) {
            //
            // We either opened an existing file (that we need to leave alone,
            // unless we're replacing it with a new exception INF), or we
            // created a new file (in which case, we've found our unique name).
            //
            // CreateFile actually sets last error upon success to indicate if
            // the file was already in existence...
            //
            Err = GetLastError();

            //
            // Before we decide what to do, close the file handle.
            //
            CloseHandle(h);

            FileNewlyCreated = (Err != ERROR_ALREADY_EXISTS);

            if(FileNewlyCreated || (Flags & SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES)) {
                //
                // We've either (a) created a new file, or (b) found that we
                // can replace an existing exception INF.  Determine whether
                // the filename fits in the caller-supplied buffer.
                //
                *RequiredSize = lstrlen(szNewName) + 1;

                if(*RequiredSize < NewInfNameSize) {
                    //
                    // OK, we have a unique filename, and the caller-
                    // supplied buffer is large enough to hold that name.
                    //
                    // get LastKnownGood in on the loop
                    // if this is a newly created file, it will get deleted on revert
                    //

                    pSetupDoLastKnownGoodBackup(NULL,
                                                szNewName,
                                                SP_LKG_FLAG_FORCECOPY|SP_LKG_FLAG_DELETEIFNEW|(FileNewlyCreated?SP_LKG_FLAG_DELETEEXISTING:0),
                                                LogContext);

                    //
                    // Now we need to verify the INF and its associated CAT.
                    //
                    if(!OemInfCatName) {
                        //
                        // An OEM INF without a CatalogFile= entry is
                        // automatically a digital signature failure!
                        //
                        Err = ERROR_NO_CATALOG_FOR_OEM_INF;
                        Problem = SetupapiVerifyInfProblem;
                        ProblemFile = OemInfName;
                    } else {
                        //
                        // Now verify the catalog file and INF, which must
                        // both be in the same directory.
                        //
                        MYVERIFY(SUCCEEDED(StringCchCopy(CatalogName,
                                                         SIZECHARS(CatalogName),
                                                         OemInfName)));
                        *((PTSTR)pSetupGetFileTitle(CatalogName)) = TEXT('\0');
                        pSetupConcatenatePaths(CatalogName, OemInfCatName, SIZECHARS(CatalogName), NULL);

                        Err = _VerifyFile(LogContext,
                                          VerifyContext,
                                          CatalogName,
                                          NULL,
                                          0,
                                          OemInfOriginalName,
                                          OemInfName,
                                          &Problem,
                                          PathBuffer,
                                          FALSE,
                                          AltPlatformInfo,
                                          (VERIFY_FILE_IGNORE_SELFSIGNED
                                           | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL
                                         );

                        if(Err != NO_ERROR) {

                            if(Problem != SetupapiVerifyCatalogProblem) {

                                MYASSERT(Problem != SetupapiVerifyNoProblem);
                                //
                                // If the problem was not a catalog problem,
                                // then it's an INF problem (the _VerifyFile
                                // routine doesn't know the file we passed
                                // it is an INF).
                                //
                                Problem = SetupapiVerifyInfProblem;
                            }

                            ProblemFile = PathBuffer;

                            if((Err != ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH) &&
                               (DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE)) {
                                //
                                // If we failed to validate via standard OS
                                // code-signing policy (due to some reason
                                // other than osattribute mismatch), and we're
                                // allowed to attempt validation via an
                                // Authenticode-signed catalog, then try again.
                                //
                                AuthenticodeErr = _VerifyFile(
                                                      LogContext,
                                                      VerifyContext,
                                                      CatalogName,
                                                      NULL,
                                                      0,
                                                      OemInfOriginalName,
                                                      OemInfName,
                                                      &Problem,
                                                      PathBuffer,
                                                      FALSE,
                                                      AltPlatformInfo,
                                                      (VERIFY_FILE_IGNORE_SELFSIGNED
                                                       | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK
                                                       | VERIFY_FILE_USE_AUTHENTICODE_CATALOG),
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      hWVTStateData
                                                      );

                                if((AuthenticodeErr == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                                   (AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                                    //
                                    // The catalog validated via
                                    // Authenticode policy--reset the error
                                    // (previously received during the
                                    // failed attempt at validation via
                                    // driversigning policy).
                                    //
                                    Err = NO_ERROR;

                                } else {
                                    //
                                    // Transfer Authenticode error over to
                                    // be the "official" failure.  We
                                    // always want the Authenticode error
                                    // to be NO_ERROR unless it's one of
                                    // the two "special" values.
                                    //
                                    MYASSERT(AuthenticodeErr != NO_ERROR);

                                    Err = AuthenticodeErr;
                                    AuthenticodeErr = NO_ERROR;
                                }
                            }
                        }

                        if(Err == NO_ERROR) {
                            //
                            // Make sure we aren't remembering any residual
                            // intermediate problems...
                            //
                            Problem = SetupapiVerifyNoProblem;

                            //
                            // Only attempt to install a catalog if we're not
                            // running in "minimal embedded" mode...
                            //
                            if(!(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED)) {
                                //
                                // Take the INF's new, unique name and generate
                                // a unique catalog filename under setupapi's
                                // namespace by simply replacing ".INF" with
                                // ".CAT".
                                //
                                if(MYVERIFY(SUCCEEDED(StringCchCopy(
                                                          PathBuffer,
                                                          SIZECHARS(PathBuffer),
                                                          pSetupGetFileTitle(szNewName))))) {

                                    PTSTR DotPart = _tcsrchr(PathBuffer, TEXT('.'));
                                    if(MYVERIFY(DotPart != NULL)) {
                                        MYVERIFY(SUCCEEDED(StringCchCopy(
                                                               DotPart,
                                                               SIZECHARS(PathBuffer)-(DotPart-PathBuffer),
                                                               pszCatSuffix)));
                                    }
                                }

                                //
                                // At this point, PathBuffer contains the
                                // basename to be used for the catalog on the
                                // system, and CatalogName is the fully-
                                // qualified path of the catalog file in the oem
                                // location.
                                //
                                Err = pSetupInstallCatalog(
                                          CatalogName,
                                          PathBuffer,
                                          CatalogFilenameOnSystem
                                          );

                                if(Err != NO_ERROR) {
                                    Problem = SetupapiVerifyCatalogProblem;
                                    ProblemFile = CatalogName;

                                    //
                                    // If this was au Authenticode-signed
                                    // catalog that required user confirmation
                                    // to establish publisher trust, then we
                                    // need to free the WinVerifyTrust data
                                    // now, since we've encountered an error.
                                    //
                                    if(hWVTStateData && *hWVTStateData) {
                                        pSetupCloseWVTStateData(hWVTStateData);
                                        *hWVTStateData = NULL;
                                    }
                                }
                            }
                        }
                    }

                    MYASSERT(((Problem == SetupapiVerifyNoProblem) && (Err == NO_ERROR)) ||
                             ((Problem != SetupapiVerifyNoProblem) && (Err != NO_ERROR)));

                    //
                    // If we encountered a signature verification failure, were
                    // unable to install the catalog, or need to establish the
                    // user's trust for this Authenticode publisher, then
                    // prompt the user (based on policy) about what they want
                    // to do.
                    //
                    if((Problem != SetupapiVerifyNoProblem) ||
                       (AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {

                        MYASSERT((Err != NO_ERROR) || (hWVTStateData && *hWVTStateData));

                        //
                        // If we're here to ask the user whether they trust an
                        // Authenticode publisher, then we'd better not have
                        // encountered a verification error...
                        //
                        MYASSERT((AuthenticodeErr != ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) ||
                                 (Err == NO_ERROR));

                        if(DriverSigningError) {
                            *DriverSigningError = Err;
                        }

                        //
                        // Unless the error was due to missing CatalogFile=
                        // entry in the INF (and we were instructed to ignore
                        // such errors), then we need to handle the
                        // verification failure.
                        //
                        if((Err != ERROR_NO_CATALOG_FOR_OEM_INF) ||
                           !(Flags & SCOI_NO_ERRLOG_ON_MISSING_CATALOG)) {

                            if(_HandleFailedVerification(
                                   Owner,
                                   ((AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)
                                       ? SetupapiVerifyCatalogProblem
                                       : Problem),
                                   ((AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)
                                       ? CatalogName
                                       : ProblemFile),
                                   DeviceDesc,
                                   DriverSigningPolicy,
                                   (Flags & SCOI_NO_UI_ON_SIGFAIL),
                                   ((Err == NO_ERROR) ? AuthenticodeErr
                                                      : Err),
                                   LogContext,
                                   NULL,
                                   NULL,
                                   (hWVTStateData ? *hWVTStateData : NULL))) {
                                //
                                // The user wants to proceed with the unsigned/
                                // untrusted installation (or policy is Ignore,
                                // so they weren't even informed).  If we were
                                // able to confirm with the user that they
                                // trust the Authenticode publisher, then set
                                // our error to indicate this.
                                //
                                if(AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) {

                                    MYASSERT(DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE);
                                    MYASSERT((DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                                             != DRIVERSIGN_BLOCKING);

                                    if((DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                                       != DRIVERSIGN_NONE) {

                                        AuthenticodeErr = ERROR_AUTHENTICODE_TRUSTED_PUBLISHER;
                                    }
                                }

                            } else {
                                //
                                // Failed verification should be treated as
                                // fatal.
                                //
                                if(FileNewlyCreated) {
                                    //
                                    // Delete the INF (and PNF and CAT, if they
                                    // exist).
                                    //
                                    pSetupUninstallOEMInf(szNewName,
                                                          LogContext,
                                                          SUOI_FORCEDELETE,
                                                          NULL
                                                         );
                                }

                                if(hWVTStateData && *hWVTStateData) {

                                    pSetupCloseWVTStateData(*hWVTStateData);
                                    *hWVTStateData = NULL;

                                    MYASSERT(Err == NO_ERROR);

                                    //
                                    // Need to report some error, since the
                                    // user indicated they don't want to trust
                                    // the publisher of this Authenticode-
                                    // signed package (unless policy was block,
                                    // in which case they didn't have a
                                    // choice).
                                    //
                                    MYASSERT(DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE);

                                    Err = ERROR_AUTHENTICODE_PUBLISHER_NOT_TRUSTED;
                                }

                                return Err;
                            }

                            //
                            // The user wants to proceed with the installation
                            // (or policy is Ignore, so they weren't even
                            // informed).  If the caller wants a chance to set
                            // a system restore point prior to doing any
                            // unsigned installations, then we abort now with a
                            // "special" error code that tells them what to
                            // do.  (Note: if the user indicated that they
                            // trust the publisher of an Authenticode signed
                            // catalog, then we treat that as "signed", and
                            // thus don't bail out in this case.
                            //
                            if((Err != NO_ERROR) &&
                               (Flags & SCOI_ABORT_IF_UNSIGNED)) {

                                if(FileNewlyCreated) {
                                    //
                                    // Delete the INF (and PNF and CAT, if they
                                    // exist)--we don't want these files to be
                                    // present when the system restore point is
                                    // created.
                                    //
                                    pSetupUninstallOEMInf(szNewName,
                                                          LogContext,
                                                          SUOI_FORCEDELETE,
                                                          NULL
                                                         );
                                }

                                if(hWVTStateData && *hWVTStateData) {
                                    pSetupCloseWVTStateData(*hWVTStateData);
                                    *hWVTStateData = NULL;
                                }

                                return ERROR_SET_SYSTEM_RESTORE_POINT;
                            }
                        }
                    }

                    MYVERIFY(SUCCEEDED(StringCchCopy(NewInfName, *RequiredSize, szNewName)));

                    //
                    // If we're installing an unsigned INF, then clean out any
                    // existing CAT that might've previously been installed.
                    //
                    if(Err != NO_ERROR) {
                        PTSTR DotPart = _tcsrchr(szNewName, TEXT('.'));
                        if(MYVERIFY(DotPart != NULL)) {
                            MYVERIFY(SUCCEEDED(StringCchCopy(DotPart,
                                                             SIZECHARS(szNewName)-(DotPart-szNewName),
                                                             pszCatSuffix)));
                        }
                        pSetupUninstallCatalog(pSetupGetFileTitle(szNewName));
                    }

                    //
                    // If Authenticode verification was done, then we'll return
                    // one of the two errors appropriate to that.  Otherwise,
                    // we'll return NO_ERROR (that's what we initialized our
                    // AuthenticodeErr variable to at the beginning of this
                    // routine).
                    //
                    MYASSERT((AuthenticodeErr == NO_ERROR) ||
                             (AuthenticodeErr == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                             (AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED));

                    return AuthenticodeErr;

                } else {
                    //
                    // The caller's buffer isn't large enough.  We have to
                    // delete the file we created.  We don't want to delete the
                    // file, however, if it already existed (i.e., for the
                    // exception INF case).
                    //
                    if(FileNewlyCreated) {
                        pSetupUninstallOEMInf(szNewName, LogContext, SUOI_FORCEDELETE, NULL);
                    }

                    //
                    // So close, yet so far. :-(  Free the WinVerifyTrust state
                    // data, if any, since the caller won't be expecting it
                    // when a failure is encountered due to insufficient
                    // buffer.
                    //
                    if(hWVTStateData && *hWVTStateData) {
                        pSetupCloseWVTStateData(*hWVTStateData);
                        *hWVTStateData = NULL;
                    }

                    return ERROR_INSUFFICIENT_BUFFER;
                }
            }

        } else {

            MYASSERT(!hWVTStateData || !*hWVTStateData);

            //
            // We failed to open/create this oem inf.  Check to see if the
            // failure was access-denied.  If so, then it's possible that the
            // INF directory is ACL'ed such that we can't write to it.  We want
            // to bail in this case, otherwise we're going to spend a bunch of
            // time trying all 100,000 oem<n>.inf filenames (with each one
            // failing) before we give up.
            //
            // We check for this case by seeing if the file we were trying to
            // create/open already exists.  If so, then we want to keep going
            // (e.g., maybe the individual file was ACL'ed, etc.).  If, however,
            // the file doesn't exist, then this indicates that we can't create
            // files in the directory, and we should bail now.
            //
            if(Flags & SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES) {
                //
                // If we're installing an exception INF, we don't care what the
                // error is--we gotta bail.
                //
                return Err;

            } else if((Err == ERROR_ACCESS_DENIED) && !FileExists(szNewName, NULL)) {

                return ERROR_ACCESS_DENIED;
            }
        }
    }

    //
    // We didn't find a unique OEM INF name to use!
    //
    MYASSERT(!hWVTStateData || !*hWVTStateData);

    return ERROR_FILE_NOT_FOUND;
}


DWORD
InstallHW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  HINF             hDeviceInf,
    IN  PCTSTR           szSectionName,
    OUT PBOOL            DeleteDevKey
    )
/*++

Routine Description:

    This routine appends a ".Hw" to the end of the install section name for the
    specified device, and attempts to find that section name in the specified INF.
    If found, it does a performs a registry installation against it.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set to call
        SetupInstallFromInfSection for.

    DeviceInfoData - Supplies the address of a device information element structure
        for which the installation action is to be performed.

    hDeviceInf - Supplies a handle to the opened INF containing the device install
        section.

    szSectionName - Supplies the address of a string specifying the install section
        name for this device.  This string will be appended with ".Hw" to create
        the corresponding hardware section name.

    DeleteDevKey - Supplies the address of a variable that receives a boolean value
        indicating whether or not a user-accessible device key was created as a
        result of calling this routine.  This output may be used to indicate whether
        or not the key should be destroyed if the caller encounters some error later
        on that requires clean-up.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise it is an
    ERROR_* code.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    HKEY hKey;
    DWORD Err;
    TCHAR szHwSection[MAX_SECT_NAME_LEN];
    INFCONTEXT InfContext;
    PTSTR szInfFileName;
    PTSTR NeedsSectionList, CurInstallSection;
    BOOL b;
    REGMOD_CONTEXT RegContext;

    //
    // Initially, assume the device key is already there, and therefore shouldn't be
    // deleted during error clean-up.
    //
    *DeleteDevKey = FALSE;

    //
    // Form the hardware INF section name, and see if that section exists in the INF.
    //
    MYVERIFY(SUCCEEDED(StringCchPrintf(szHwSection,
                                       SIZECHARS(szHwSection),
                                       pszHwSectionFormat,
                                       szSectionName)));

    if(!SetupFindFirstLine(hDeviceInf, szHwSection, NULL, &InfContext)) {
        return NO_ERROR;
    }

    if((hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DEV,
                                    KEY_ALL_ACCESS)) == INVALID_HANDLE_VALUE) {
        //
        // Open failed--try create.
        //
        if((hKey = SetupDiCreateDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DEV,
                                          NULL,
                                          NULL)) == INVALID_HANDLE_VALUE) {
            return GetLastError();

        } else {
            *DeleteDevKey = TRUE;
        }
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {

        MYASSERT(pDeviceInfoSet);
        RegCloseKey(hKey);
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;
    NeedsSectionList = NULL;

    try {

        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

                szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                 DevInfoElem->SelectedDriver->InfFileName
                                                     );

        //
        // Append-load any included INFs specified in an "include=" line in our
        // ".Hw" section.
        //
        AppendLoadIncludedInfs(hDeviceInf, szInfFileName, szHwSection, FALSE);

        NeedsSectionList = GetMultiSzFromInf(hDeviceInf, szHwSection, TEXT("needs"), &b);

        if(!NeedsSectionList && b) {
            //
            // Out of memory!
            //
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        ZeroMemory(&RegContext, sizeof(RegContext));
        RegContext.Flags = INF_PFLAG_DEVPROP;
        RegContext.UserRootKey = hKey;
        RegContext.DevInst = DeviceInfoData->DevInst;

        //
        // Process the registry lines ("AddReg" and "DelReg") in this section, as well as
        // those contained with any sections referenced in the "needs=" entry in this section.
        //
        for(CurInstallSection = szHwSection;
            (CurInstallSection && *CurInstallSection);
            CurInstallSection = (CurInstallSection == szHwSection)
                                ? NeedsSectionList
                                : (CurInstallSection + lstrlen(CurInstallSection) + 1))
        {
            if((Err = pSetupInstallRegistry(hDeviceInf, CurInstallSection, &RegContext)) != NO_ERROR) {
                //
                //Stop if we encounter an error while processing one of the section's registry entries
                //
                break;
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If our exception was an AV, then use Win32 invalid param error, otherwise, assume it was
        // an inpage error dealing with a mapped-in file.
        //
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    RegCloseKey(hKey);

    if(NeedsSectionList) {
        MyFree(NeedsSectionList);
    }

    return Err;
}


BOOL
CheckIfDevStarted(
    IN PDEVINFO_ELEM DevInfoElem,
    IN PDEVICE_INFO_SET pDeviceInfoSet
    )
/*++

Routine Description:

    This routine calls CM_Get_DevInst_Status to see if the specified device
    instance has been started.  If the device hasn't been started, and it has
    either the CM_PROB_NEED_RESTART or CM_PROB_NORMAL_CONFLICT problem codes,
    the DI_NEEDREBOOT flag is set in the device information element.  We also
    set the CM_PROB_NEED_RESTART problem on the devnode.

Arguments:

    DevInfoElem - Supplies the address of the device information element to
        check.

    pDeviceInfoSet - Supplies the address of the device info set

    LogContext - Supplies a log context for logging the reason if a reboot is
        needed.

Return Value:

    None.

--*/
{
    ULONG ulStatus, ulProblem;
    BOOL restarted = FALSE;

    if(CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) {

        if(ulStatus & DN_STARTED) {
            restarted = TRUE;
        } else {
            if (ulStatus & DN_HAS_PROBLEM) {
                if((ulProblem == CM_PROB_NEED_RESTART) ||
                   (ulProblem == CM_PROB_NORMAL_CONFLICT) ||
                   (ulProblem == CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD) ||
                   (ulProblem == CM_PROB_HELD_FOR_EJECT)) {
                    //
                    // The device either has the problem CM_PROB_NEED_RESTART or
                    // CM_PROB_NORMAL_CONFLICT. - change into need reboot
                    // and log what problem code was
                    //
                    SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,
                                                         pDeviceInfoSet,
                                                         MSG_LOG_REBOOT_REASON_DEVHASPROBLEM,
                                                         (DWORD)ulProblem,
                                                         (ULONG_PTR)_MapCmProbToString((DWORD)ulProblem)
                                                         );
                } else {
                    //
                    // The device has some other problem so we won't prompt for a reboot
                    // however these are interesting things to log
                    //
                    WriteLogEntry(
                        DevInfoElem->InstallParamBlock.LogContext,
                        DRIVER_LOG_INFO,  // not worth a warning
                        MSG_LOG_NOTSTARTED_REASON_DEVHASPROBLEM,
                        NULL,
                        (DWORD)ulProblem,
                        _MapCmProbToString((DWORD)ulProblem)
                        );
                }
            } else if (ulStatus & DN_PRIVATE_PROBLEM) {
                //
                // some private problem, change into need reboot
                // and log private problem
                //
                SetDevnodeNeedsRebootProblem(DevInfoElem, pDeviceInfoSet,
                                             MSG_LOG_REBOOT_REASON_PRIVATEPROBLEM);
            } else {
                //
                // not started for some other reason
                // indicate reboot required and log this issue
                //
                SetDevnodeNeedsRebootProblem(DevInfoElem, pDeviceInfoSet,
                                             MSG_LOG_REBOOT_REASON_NOTSTARTED);
            }
        }
    }
    return restarted;
}


DWORD
InstallNtService(
    IN  PDEVINFO_ELEM    DevInfoElem,        OPTIONAL
    IN  HINF             hDeviceInf,
    IN  PCTSTR           InfFileName,            OPTIONAL
    IN  PCTSTR           szSectionName,      OPTIONAL
    OUT PSVCNAME_NODE   *ServicesToDelete,   OPTIONAL
    IN  DWORD            Flags,
    OUT PBOOL            NullDriverInstalled
    )
/*++

Routine Description:

    This routine looks for the specified INF section, and if found, it deletes
    any services specified in "DelService" entries, then installs any services
    specified in "AddService" entries.  These entries have the following form:

    AddService = [<ServiceName>], [<Flags>], <ServiceInstallSection>[, <EventLogInstallSection>[, [<EventLogType>] [, <EventName>]]]
    DelService = <ServiceName>[, [<flags>] [, [<EventLogType>] [, <EventName>]]]

    (<ServiceName> is only optional for an AddService entry if the
    SPSVCINST_ASSOCSERVICE flag is set.  This indicates that we're explicitly
    installing a NULL driver for this device, even though the underlying bus
    didn't report the device as being raw-capable.  This is used for device such
    as the BIOS-reported PIC, DMA controller, etc. devnodes that don't need a
    driver (since the HAL runs them), yet need to have a NULL driver installed
    so that they don't show up as yellow-banged in Device Manager.)

    A linked list is built of newly-created services, and optionally returned to the
    caller (in case a subsequent installation failure requires all modifications to
    be undone).

    After all service modifications are complete, this routine checks to see if we're
    in the context of a device installation.  If so, then it checks to see if the device
    instance specifies a valid controlling service, and that the service is not disabled
    (disabled services are assumed to be uninstalled).  If the device's 'RawDeviceOK'
    capability bit is set, then a device with no controlling service will be allowed.

Arguments:

    DevInfoElem - Optionally, supplies the device information element for whom the
        service installation is being performed.  If this parameter is not specified,
        then the service is not being installed in relation to a device instance.

    hDeviceInf - Supplies a handle to the opened INF containing the service install
        section.

        InfFileName - Optionally, supplies the full path of the INF file containing the
                service install section.  If this parameter is NULL, the no Include= or Needs=
                values will be processed in this section.

    szSectionName - Optionally, supplies the name of the service install section in a
        Win95-style device INF.  If this parameter is NULL, then no AddService or
        DelService lines will be processed.

    ServicesToDelete - Optionally, supplies the address of a linked list head pointer,
        that receives a list of services that were newly-created by this routine, and
        as such, should be deleted if the installation fails later on.  The caller must
        free the memory allocated for the nodes in this list by calling MyFree() on each
        one.

    Flags - Supplies flags controlling how the services are to be installed.  May be a
        combination of the following values:

        SPSVCINST_TAGTOFRONT - For every kernel or filesystem driver installed (that
            has an associated LoadOrderGroup), always move this service's tag to the
            front of the ordering list.

        SPSVCINST_ASSOCSERVICE - This flag may only be specified if a device information
            element is specified.  If set, this flag specifies that the service being
            installed is the owning service (i.e., function driver) for this device instance.

        SPSVCINST_DELETEEVENTLOGENTRY - For every service specified in a DelService entry,
            delete the associated event log entry (if there is one).

        SPSVCINST_NOCLOBBER_DISPLAYNAME - If this flag is specified, then we will
            not overwrite the service's display name, if it already exists.

        SPSVCINST_NOCLOBBER_STARTTYPE - If this flag is specified, then we will
            not overwrite the service's start type if the service already exists.

        SPSVCINST_NOCLOBBER_ERRORCONTROL - If this flag is specified, then we
            will not overwrite the service's error control value if the service
            already exists.

        SPSVCINST_NOCLOBBER_LOADORDERGROUP - If this flag is specified, then we
            will not overwrite the service's load order group if it already
            exists.

        SPSVCINST_NOCLOBBER_DEPENDENCIES - If this flag is specified, then we
            will not overwrite the service's dependencies list if it already
            exists.

        SPSVCINST_NO_DEVINST_CHECK - If this flag is specified, then we will not check
            to ensure that a function driver is installed for the specified devinfo
            element after running the service install section.  This is a private flag
            used only by SetupInstallServicesFromInfSection(Ex) and InstallHinfSection.

        SPSVCINST_STOPSERVICE - If this flag is specified, then we will stop the service
            before removing the service.

        SPSVCINST_CLOBBER_SECURITY - If this flag is specified, security may be
            overridden.

    NullDriverInstalled - Supplies the address of a boolean variable that
        indicates whether or not an explicit null driver installation was done
        for this device.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise it is an
    ERROR_* code.
    If NO_ERROR is returned, GetLastError may return ERROR_SUCCESS_REBOOT_REQUIRED

--*/
{
    CONFIGRET cr;
    TCHAR ServiceName[MAX_SERVICE_NAME_LEN];
    ULONG ServiceNameSize;
    DWORD Err = NO_ERROR, i;
    SC_HANDLE SCMHandle, ServiceHandle, FilterServiceHandle;
    LPQUERY_SERVICE_CONFIG ServiceConfig, FilterServiceConfig;
    DWORD ServiceConfigSize;
    PCTSTR Key;
    INFCONTEXT LineContext;
    PSVCNAME_NODE SvcListHead = NULL;
    PSVCNAME_NODE TmpSvcNode;
    SC_LOCK SCLock;
    DWORD NewTag;
    BOOL AssociatedService;
    DWORD DevInstCapabilities;
    ULONG DevInstCapabilitiesSize;
    PTSTR FilterDrivers, CurFilterDriver;
    BOOL FilterNeedsTag;
    BOOL NullFunctionDriverAdded;
    PTSTR NeedsSectionList, CurInstallSection;
    BOOL b;
    BOOL NeedsReboot;
    DWORD slot_section = 0;
    PSETUP_LOG_CONTEXT LogContext;

    try {
        LogContext = ((PLOADED_INF) hDeviceInf)->LogContext;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogContext = NULL;
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
        goto FinalClean0;
    }

    //
    // Initially, assume this is not a null driver install.
    //
    *NullDriverInstalled = FALSE;
    NeedsReboot = FALSE;

    if(szSectionName) {
        //
        // Surround the following in try/except, in case we get an inpage error.
        //
        try {

            NeedsSectionList = NULL;

            if (InfFileName) {

                AppendLoadIncludedInfs(hDeviceInf, InfFileName, szSectionName, FALSE);

                NeedsSectionList = GetMultiSzFromInf(hDeviceInf, szSectionName, TEXT("needs"), &b);

                if(!NeedsSectionList && b) {
                    //
                    // Out of memory!
                    //
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            }

            if (slot_section == 0) {
                slot_section = AllocLogInfoSlot(LogContext,FALSE);
            }

            //
            // Make two passes through the section--once for deletions, and a
            // second time for additions.
            //
            for(i = 0; i < 2; i++) {
                //
                // Find the relevent line (if there is one) in the given install section.
                //
                Key = (i) ? pszAddService : pszDelService;

                //
                // Process the service lines in this section, as well as
                // those contained with any sections referenced in the "needs=" entry in this section.
                //
                for(CurInstallSection = (PTSTR)szSectionName;
                    (CurInstallSection && *CurInstallSection);
                    CurInstallSection = (CurInstallSection == szSectionName)
                                        ? NeedsSectionList
                                        : (CurInstallSection + lstrlen(CurInstallSection) + 1))
                {

                    if(!SetupFindFirstLine(hDeviceInf, CurInstallSection, Key, &LineContext)) {
                        continue;
                    }
                    //
                    // Log which section we're installing if we log anything else
                    //
                    WriteLogEntry(
                        LogContext,
                        slot_section,
                        MSG_LOG_PROCESS_SERVICE_SECTION,
                        NULL,
                        CurInstallSection);


                    do {
                        //
                        // We have a line to act upon.
                        //
                        Err = (i) ? pSetupAddService(&LineContext,
                                                     &SvcListHead,
                                                     Flags,
                                                     (DevInfoElem ? DevInfoElem->DevInst : 0),
                                                     &NullFunctionDriverAdded,
                                                     LogContext)
                                  : pSetupDeleteService(&LineContext,
                                                        Flags,
                                                        LogContext);

                        if(Err != NO_ERROR) {
                            //
                            // Log that an error occurred
                            //
                            WriteLogError(
                                LogContext,
                                // we don't know if it's a driver or not,
                                // so just allow both to work
                                SETUP_LOG_ERROR | DRIVER_LOG_ERROR,
                                Err);

                            goto clean0;
                        } else if(i) {
                            //
                            // We're processing AddService entries, so check to see
                            // if we just installed a null service (thus having no
                            // function driver on a non-raw-capable PDO should be
                            // allowed).
                            //
                            *NullDriverInstalled |= NullFunctionDriverAdded;
                            if (GetLastError() == ERROR_SUCCESS_REBOOT_REQUIRED) {
                                NeedsReboot |= TRUE;
                            }
                        }

                    } while(SetupFindNextMatchLine(&LineContext, Key, &LineContext));
                }
            }

clean0: ; // nothing to do

        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // If our exception was an AV, then use Win32 invalid param error, otherwise, assume it was
            // an inpage error dealing with a mapped-in file.
            //
            Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
        }

        if (NeedsSectionList) {
            MyFree(NeedsSectionList);
        }

        if((Err != NO_ERROR) || (Flags & SPSVCINST_NO_DEVINST_CHECK)) {
            goto FinalClean0;
        }
    }

    MYASSERT(DevInfoElem);

    //
    // Find out if the device instance already has an associated service.
    //
    ServiceNameSize = sizeof(ServiceName);
    if(CR_SUCCESS == (cr = CM_Get_DevInst_Registry_Property(DevInfoElem->DevInst,
                                                            CM_DRP_SERVICE,
                                                            NULL,
                                                            ServiceName,
                                                            &ServiceNameSize,
                                                            0)))
    {
        AssociatedService = TRUE;
        //
        // Make sure that the NullDriverInstalled output parameter is still FALSE.
        // It typically would be, but might not be in the case where there are
        // multiple AddService entries that specify SPSVCINST_ASSOCSERVICE (e.g.,
        // when additional service install sections are pulled in via include=/needs=.
        //
        *NullDriverInstalled = FALSE;

    } else {
        //
        // For the moment, there is no associated service.
        //
        AssociatedService = FALSE;

        //
        // Either the device instance has gone sour (in which case we return an error),
        // or we couldn't retrieve an associated service name.  In the latter case, we
        // will make the association based on the default service for the class.
        //
        if(cr == CR_INVALID_DEVINST) {

            Err = ERROR_NO_SUCH_DEVINST;

        } else if(!*NullDriverInstalled) {

            ServiceNameSize = sizeof(ServiceName);
            AssociatedService = AssociateDevInstWithDefaultService(DevInfoElem,
                                                                   ServiceName,
                                                                   &ServiceNameSize
                                                                  );
            if(!AssociatedService) {
                //
                // If the device's capabilities report that it can be driven 'raw', then
                // not having a function driver is OK.  Otherwise, we have an error.
                //
                DevInstCapabilitiesSize = sizeof(DevInstCapabilities);
                if(CR_SUCCESS != CM_Get_DevInst_Registry_Property(DevInfoElem->DevInst,
                                                                  CM_DRP_CAPABILITIES,
                                                                  NULL,
                                                                  &DevInstCapabilities,
                                                                  &DevInstCapabilitiesSize,
                                                                  0))
                {
                    DevInstCapabilities = 0;
                }

                if(!(DevInstCapabilities & CM_DEVCAP_RAWDEVICEOK)) {
                    Err = ERROR_NO_ASSOCIATED_SERVICE;
                }
            }
        }

        if(!AssociatedService) {
            //
            // Either we hit an error, or the device can be driven 'raw'.  In either case, we
            // can skip the service controller checks that lie ahead.
            //
            goto FinalClean0;
        }
    }

    //
    // At this point, we have the name of the service with which the device instance is
    // associated.  Attempt to locate this service in the SCM database.
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        Err = GetLastError();
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_INSTSERVSCM_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
        goto FinalClean0;
    }

    if(!(ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS))) {
        //
        // We couldn't access the service--either because it doesn't exist, or because
        // this is a detected device reported by a 'disembodied' driver object (e.g., the
        // one the HAL creates for its driver object it got via IoCreateDriver).
        //
        // The former case is an error, the latter case is just fine.
        //
        Err = GetLastError();
        if((lstrlen(ServiceName) > CSTRLEN(pszDriverObjectPathPrefix)) &&
           CharUpper(ServiceName) &&
           !memcmp(ServiceName, pszDriverObjectPathPrefix, CSTRLEN(pszDriverObjectPathPrefix)))
        {
            //
            // The "service name" is actually a driver name (e.g., "\Driver\PCI_HAL"), so it's OK.
            //
            Err = NO_ERROR;
        }
        if(Err) {
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                MSG_LOG_INSTSERVOPEN_ERROR,
                NULL,
                ServiceName
                );
            WriteLogError(
                LogContext,
                DRIVER_LOG_ERROR,
                Err);
        }
        goto FinalClean1;
    }

    //
    // The service exists.  Make sure that it's not disabled.
    //
    if((Err = pSetupRetrieveServiceConfig(ServiceHandle, &ServiceConfig)) == NO_ERROR) {

        if(ServiceConfig->dwStartType == SERVICE_DISABLED) {
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR,
                MSG_LOG_INSTSERV_DISABLED,
                NULL,
                ServiceName
                );

            Err = ERROR_SERVICE_DISABLED;
        } else {
            //
            // If this service has a load order group, and is a kernel or filesystem
            // driver, then make sure that it has a tag.
            //
            // NOTE: We have to do this here, even though we ensure that all new services we install
            // have their tags set up properly in pSetupAddService().  The reason is that the device may
            // using an existing service that wasn't installed via a Win95-style INF.
            //
            if(ServiceConfig->lpLoadOrderGroup && *(ServiceConfig->lpLoadOrderGroup) &&
               (ServiceConfig->dwServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER))) {
                //
                // This service needs a tag--does it have one???
                //
                if(!(NewTag = ServiceConfig->dwTagId)) {
                    //
                    // Attempt to lock the service database before generating a tag.  We'll go ahead
                    // and make the change, even if this fails.
                    //
                    pAcquireSCMLock(SCMHandle, &SCLock, LogContext);

                    if(!ChangeServiceConfig(ServiceHandle,
                                            SERVICE_NO_CHANGE,
                                            SERVICE_NO_CHANGE,
                                            SERVICE_NO_CHANGE,
                                            NULL,
                                            ServiceConfig->lpLoadOrderGroup,  // have to specify this to generate new tag.
                                            &NewTag,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL)) {
                        DWORD LastErr = GetLastError();
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_WARNING | SETUP_LOG_BUFFER,
                            MSG_LOG_INSTSERVTAG_WARN,
                            NULL,
                            ServiceName
                            );
                        WriteLogError(
                            LogContext,
                            DRIVER_LOG_WARNING,
                            LastErr);

                        NewTag = 0;
                    }

                    if(SCLock) {
                        UnlockServiceDatabase(SCLock);
                    }
                }

                //
                // Make sure that the tag exists in the service's corresponding GroupOrderList entry.
                //
                if(NewTag) {
                    pSetupAddTagToGroupOrderListEntry(ServiceConfig->lpLoadOrderGroup,
                                                NewTag,
                                                Flags & SPSVCINST_TAGTOFRONT
                                               );
                }
            }

            //
            // If the function driver is marked as boot-start, then make sure that all
            // associated upper- and lower-filters (both class- and device-specific) are
            // also boot-start drivers.
            //
            if((ServiceConfig->dwStartType == SERVICE_BOOT_START) &&
               RetrieveAllDriversForDevice(DevInfoElem, &FilterDrivers,RADFD_FLAG_ALL_FILTERS,NULL)) {
                //
                // If FilterDrivers is NULL, then we hit an out-of-memory error.
                //
                if(!FilterDrivers) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_VERBOSE,
                        MSG_LOG_INSTSERV_BOOT,
                        NULL,
                        ServiceName
                        );

                    //
                    // Check each filter driver.
                    //
                    for(CurFilterDriver = FilterDrivers;
                        *CurFilterDriver;
                        CurFilterDriver += (lstrlen(CurFilterDriver) + 1)) {

                        if(!(FilterServiceHandle = OpenService(SCMHandle, CurFilterDriver, SERVICE_ALL_ACCESS))) {
                            //
                            // We couldn't access the service--probably because it doesn't exist.
                            // Bail now.
                            //
                            Err = GetLastError();
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                MSG_LOG_BOOTFILTSERVOPEN_ERROR,
                                NULL,
                                CurFilterDriver);
                            WriteLogError(
                                LogContext,
                                DRIVER_LOG_ERROR,
                                Err);
                            break;
                        }

                        //
                        // The service exists.  Make sure that it's not disabled.
                        //
                        Err = pSetupRetrieveServiceConfig(FilterServiceHandle, &FilterServiceConfig);
                        if(Err != NO_ERROR) {
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                MSG_LOG_BOOTFILTSERVCONFIG_ERROR,
                                NULL,
                                CurFilterDriver);
                            WriteLogError(
                                LogContext,
                                DRIVER_LOG_ERROR,
                                Err);
                            goto CloseFilterSvcAndContinue;
                        }

                        if(FilterServiceConfig->dwStartType == SERVICE_DISABLED) {
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_ERROR,
                                MSG_LOG_BOOTFILTSERV_DISABLED,
                                NULL,
                                CurFilterDriver);
                            Err = ERROR_SERVICE_DISABLED;
                        } else {
                            //
                            // Ensure that this service is a boot-start kernel driver, and that it has
                            // a tag if necessary.
                            //
                            if(FilterServiceConfig->dwServiceType & SERVICE_KERNEL_DRIVER) {

                                if(FilterServiceConfig->lpLoadOrderGroup &&
                                   *(FilterServiceConfig->lpLoadOrderGroup)) {

                                    FilterNeedsTag = TRUE;
                                    NewTag = FilterServiceConfig->dwTagId;
                                }

                                if((FilterNeedsTag && !NewTag) ||
                                   (FilterServiceConfig->dwStartType != SERVICE_BOOT_START)) {
                                    //
                                    // Lock the service database before modifying this service.
                                    //
                                    Err = pAcquireSCMLock(SCMHandle, &SCLock, LogContext);

                                    if(Err == NO_ERROR) {
                                        //
                                        // Make the modifications to the service (NOTE:  Because the
                                        // service controller is really bad when it comes to driver paths,
                                        // we must explicitly pass the lpBinaryPathName in, even though we
                                        // aren't changing it.  Otherwise, the service controller will complain
                                        // because it thinks all paths have to begin with \SystemRoot\.)
                                        //
                                        if(!ChangeServiceConfig(FilterServiceHandle,
                                                                SERVICE_NO_CHANGE,
                                                                (FilterServiceConfig->dwStartType != SERVICE_BOOT_START)
                                                                    ? SERVICE_BOOT_START
                                                                    : SERVICE_NO_CHANGE,
                                                                SERVICE_NO_CHANGE,
                                                                (FilterServiceConfig->dwStartType != SERVICE_BOOT_START)
                                                                    ? FilterServiceConfig->lpBinaryPathName
                                                                    : NULL,
                                                                (FilterNeedsTag && !NewTag)
                                                                    ? FilterServiceConfig->lpLoadOrderGroup
                                                                    : NULL,
                                                                (FilterNeedsTag && !NewTag)
                                                                    ? &NewTag
                                                                    : NULL,
                                                                NULL,
                                                                NULL,
                                                                NULL,
                                                                NULL)) {

                                            Err = GetLastError();

                                            WriteLogEntry(
                                                LogContext,
                                                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                                MSG_LOG_BOOTFILTSERVCHANGE_ERROR,
                                                NULL,
                                                CurFilterDriver);
                                            WriteLogError(
                                                LogContext,
                                                DRIVER_LOG_ERROR,
                                                Err);

                                        } else {
                                            WriteLogEntry(
                                                LogContext,
                                                DRIVER_LOG_VERBOSE,
                                                MSG_LOG_BOOTFILTSERVCHANGE_OK,
                                                NULL,
                                                CurFilterDriver);
                                        }

                                        UnlockServiceDatabase(SCLock);
                                    } else {
                                        WriteLogEntry(
                                            LogContext,
                                            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                            MSG_LOG_BOOTFILTSERVSCM_ERROR,
                                            NULL,
                                            CurFilterDriver);
                                        WriteLogError(
                                            LogContext,
                                            DRIVER_LOG_ERROR,
                                            Err);
                                    }

                                    if((Err == NO_ERROR) && FilterNeedsTag) {
                                        //
                                        // Make sure that the tag exists in the service's corresponding GroupOrderList entry.
                                        //
                                        MYASSERT(NewTag);
                                        pSetupAddTagToGroupOrderListEntry(FilterServiceConfig->lpLoadOrderGroup,
                                                                    NewTag,
                                                                    FALSE
                                                                   );
                                    }
                                }

                            } else {
                                //
                                // This is not a kernel driver.  This is an error.
                                //
                                WriteLogEntry(
                                    LogContext,
                                    DRIVER_LOG_ERROR,
                                    MSG_LOG_BOOTFILTSERV_KERN,
                                    NULL,
                                    CurFilterDriver);
                                Err = ERROR_INVALID_FILTER_DRIVER;
                            }
                        }
                        MyFree(FilterServiceConfig);

CloseFilterSvcAndContinue:
                        CloseServiceHandle(FilterServiceHandle);

                        if(Err) {
                            break;
                        }
                    }
                    MyFree(FilterDrivers);
                }
            }
        }

        MyFree(ServiceConfig);
    } else {
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_INSTSERVCONFIG_ERROR,
            NULL,
            ServiceName
            );
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
    }

    CloseServiceHandle(ServiceHandle);

FinalClean1:
    CloseServiceHandle(SCMHandle);

FinalClean0:
    if(Err == NO_ERROR) {
        //
        // If requested, store the linked-list of newly-created service nodes in the output
        // parameter, otherwise, delete the list.
        //
        if(ServicesToDelete) {
            *ServicesToDelete = SvcListHead;
        } else {
            for(TmpSvcNode = SvcListHead; TmpSvcNode; TmpSvcNode = SvcListHead) {
                SvcListHead = SvcListHead->Next;
                MyFree(TmpSvcNode);
            }
        }

        if (NeedsReboot) {
            //
            // this is intentional - return NO_ERROR but GetLastError = ERROR_SUCCESS_REBOOT_REQUIRED
            //
            SetLastError(ERROR_SUCCESS_REBOOT_REQUIRED);
        }
    } else {
        //
        // Something failed along the way, so we need to clean up any newly-created
        // services.
        //
        if(Err && LogContext) {
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                MSG_LOG_INSTSERV_ERROR,
                NULL
                );
            WriteLogError(
                LogContext,
                DRIVER_LOG_ERROR,
                Err);
        }
        if(SvcListHead) {
            DeleteServicesInList(SvcListHead,LogContext);
            for(TmpSvcNode = SvcListHead; TmpSvcNode; TmpSvcNode = SvcListHead) {
                SvcListHead = SvcListHead->Next;
                MyFree(TmpSvcNode);
            }
        }
    }

    if (slot_section != 0) {
        ReleaseLogInfoSlot(LogContext,slot_section);
    }

    return Err;
}


BOOL
AssociateDevInstWithDefaultService(
    IN     PDEVINFO_ELEM DevInfoElem,
    OUT    PTSTR         ServiceName,
    IN OUT PDWORD        ServiceNameSize
    )
/*++

Routine Description:

    This routine attempts to find out the default service with which to associate
    the specified device.  The default service (if there is one) is associated with
    the device's class.  If a default is found, the device instance is associated
    with that service.

Arguments:

    DeviceInfoData - Specifies the device information element to create a default
        service association for.

    ServiceName - Supplies the address of a character buffer that receives the name
        of the service with which the device instance was associated (if this routine
        is successful).

    ServiceNameSize - Supplies the address of a variable containing the size, in bytes,
        of the ServiceName buffer.  On output, this variable receives the number of
        bytes actually stored in ServiceName.

Return Value:

    If the function succeeds, the return value is TRUE, otherwise it is FALSE.

--*/
{
    HKEY hClassKey;
    DWORD RegDataType;
    BOOL Success;

    //
    // Open up the class key for this device's class.
    //
    if((hClassKey = SetupDiOpenClassRegKey(&(DevInfoElem->ClassGuid),
                                           KEY_READ)) == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    Success = FALSE; // assume failure

    try {
        //
        // Retrieve the "Default Service" value from the class key.  If present, this value entry
        // indicates what service to associate the device with, when one isn't specified during
        // installation.
        //
        if (RegQueryValueEx(hClassKey,
                            pszDefaultService,
                            NULL,
                            &RegDataType,
                            (PBYTE)ServiceName,
                            ServiceNameSize) != ERROR_SUCCESS) {
            goto clean0;
        }

        *ServiceNameSize = (lstrlen(ServiceName) + 1) * sizeof(TCHAR);
        if((RegDataType != REG_SZ) || (*ServiceNameSize < sizeof(TCHAR)) || !(*ServiceName)) {
            goto clean0;
        }

        //
        // We have successfully retrieved the default service name to be associated with this
        // device instance.  Perform the association now by setting the Service device registry
        // property.
        //
        if(CM_Set_DevInst_Registry_Property(DevInfoElem->DevInst,
                                            CM_DRP_SERVICE,
                                            ServiceName,
                                            *ServiceNameSize,
                                            0) == CR_SUCCESS) {
            Success = TRUE;
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Success = FALSE;
    }

    RegCloseKey(hClassKey);

    return Success;
}


DWORD
DeleteServicesInList(
    IN PSVCNAME_NODE ServicesToDelete,
    IN PSETUP_LOG_CONTEXT  LogContext
    )
/*++

Routine Description:

    This routine deletes each service entry in the supplied linked list. This is
    typically called to clean up if something goes wrong during a device's installation.
    If the 'DeleteEventLog' flag for a particular node is TRUE, then the corresponding
    event log entry under HKLM\System\CurrentControlSet\Services\EventLog\<EventLogType> is
    also deleted.

Arguments:

    ServicesToDelete - supplies a pointer to the head of a linked list of service names
        to be deleted.

    LogContext - context for logging failures

Return Value:

    Error if we could not open service manager or acquire lock.
    Note that we do not return error for individual services.

--*/
{
    SC_HANDLE SCMHandle, ServiceHandle;
    SC_LOCK SCLock;
    HKEY hKeyEventLog = NULL, hKeyEventLogType;
    TCHAR RegistryPath[SIZECHARS(REGSTR_PATH_SERVICES) + SIZECHARS(DISTR_EVENTLOG) + (2 * 256)];
    DWORD Result = NO_ERROR;
    DWORD LastErr;

    if(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)) {

        Result = pAcquireSCMLock(SCMHandle, &SCLock, LogContext);
        if(Result == NO_ERROR) {

            for(; ServicesToDelete; ServicesToDelete = ServicesToDelete->Next) {

                LastErr = NO_ERROR;

                if(ServiceHandle = OpenService(SCMHandle,
                                               ServicesToDelete->Name,
                                               SERVICE_ALL_ACCESS)) {

                    //
                    // stop the service first if we're supposed to
                    //  wait awhile for the service to stop before deleting the
                    //  service, since we don't want the service to be in use when
                    //  delete the service or the service binaries
                    if (ServicesToDelete->Flags & SPSVCINST_STOPSERVICE) {
                        SERVICE_STATUS ssStatus;

                        if (ControlService( ServiceHandle,
                                            SERVICE_CONTROL_STOP ,
                                            &ssStatus)
                            || (LastErr = GetLastError()) == ERROR_SERVICE_NOT_ACTIVE) {

                            #define SLEEP_TIME 4000
                            #define LOOP_COUNT 30
                            DWORD loopCount = 0;
                            do {

                                BOOL b;

                                b = QueryServiceStatus( ServiceHandle, &ssStatus);
                                if ( !b ) {
                                    LastErr = GetLastError();
                                    //
                                    // query failed for some reason, but let's
                                    // just delete the service anyway
                                    //
                                    WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                        MSG_LOG_DELSERVSTAT_ERROR,
                                        NULL,
                                        ServicesToDelete->Name
                                        );
                                    WriteLogError(
                                        LogContext,
                                        DRIVER_LOG_ERROR,
                                        LastErr);
                                    break;
                                }
                                if (ssStatus.dwCurrentState == SERVICE_STOP_PENDING) {

                                    if ( loopCount++ == LOOP_COUNT ) {
                                        // still pending after LOOP_COUNT iterations...
                                        // just delete the service anyway
                                        //
                                        WriteLogEntry(
                                            LogContext,
                                            DRIVER_LOG_ERROR,
                                            MSG_LOG_DELSERVPEND_ERROR,
                                            NULL,
                                            ServicesToDelete->Name
                                            );
                                        break;
                                    }
                                    Sleep( SLEEP_TIME );
                                } else {
                                    loopCount++;
                                }
                            } while ( ssStatus.dwCurrentState != SERVICE_STOPPED
                                      && loopCount < LOOP_COUNT );
                        } else {
                            // control service failed for some reason...
                            // let's just continue on and try to delete the
                            // service anyway
                            //
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                MSG_LOG_DELSERVCTRL_ERROR,
                                NULL,
                                ServicesToDelete->Name
                                );
                            WriteLogError(
                                LogContext,
                                DRIVER_LOG_ERROR,
                                LastErr);
                        }
                    }
                    if(DeleteService(ServiceHandle) ||
                        ((LastErr = GetLastError()) == ERROR_SERVICE_MARKED_FOR_DELETE)) {
                        //
                        // Delete succeeded, or we don't care
                        //
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_VERBOSE,
                            MSG_LOG_DELSERV_OK,
                            NULL,
                            ServicesToDelete->Name
                            );

                    } else {
                        // delete service failed for some reason...
                        //
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                            MSG_LOG_DELSERV_ERROR,
                            NULL,
                            ServicesToDelete->Name
                            );
                        WriteLogError(
                            LogContext,
                            DRIVER_LOG_ERROR,
                            LastErr);
                    }
                    CloseServiceHandle(ServiceHandle);
                } else {
                    LastErr = GetLastError();
                    if(LastErr == ERROR_SERVICE_DOES_NOT_EXIST) {
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_VERBOSE,
                            MSG_LOG_DELSERVNOSERV,
                            NULL,
                            ServicesToDelete->Name
                            );
                    } else {
                        //
                        // open service failed for some reason
                        //
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                            MSG_LOG_DELSERVOPEN_ERROR,
                            NULL,
                            ServicesToDelete->Name
                            );
                        WriteLogError(
                            LogContext,
                            DRIVER_LOG_ERROR,
                            LastErr);
                    }
                }

                //
                // Delete the event log entry (if required) if either (a) we succeeded in deleting
                // the service, or (b) the service didn't exist.
                //
                if(ServicesToDelete->DeleteEventLog) {

                    if(ServiceHandle || (LastErr == ERROR_SERVICE_DOES_NOT_EXIST)) {
                        //
                        // We need to delete the associated event log for this service.
                        //
                        if(!hKeyEventLog) {
                            //
                            // We haven't opened up the EventLog registry key yet, so do that now.
                            //
                            PTSTR EndPtr;
                            size_t EndCount;
                            if(MYVERIFY(SUCCEEDED(StringCchCopyEx(RegistryPath,
                                                                  SIZECHARS(RegistryPath),
                                                                  pszServicesRegPath,
                                                                  &EndPtr,
                                                                  &EndCount,
                                                                  0)))) {
                                MYVERIFY(SUCCEEDED(StringCchCopy(EndPtr,
                                                                 EndCount,
                                                                 pszEventLog)));
                            }

                            if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                            RegistryPath,
                                            0,
                                            KEY_READ,
                                            &hKeyEventLog) != ERROR_SUCCESS) {

                                hKeyEventLog = NULL; // make sure this value is still NULL!
                                continue;
                            }
                        }

                        //
                        // Now open up the event log type key.
                        //
                        if(RegOpenKeyEx(hKeyEventLog,
                                        ServicesToDelete->EventLogType,
                                        0,
                                        KEY_READ | KEY_WRITE,
                                        &hKeyEventLogType) == ERROR_SUCCESS) {

                            pSetupRegistryDelnode(hKeyEventLogType, ServicesToDelete->EventLogName);
                            RegCloseKey(hKeyEventLogType);
                        }
                    }
                }
            }

            if(hKeyEventLog) {
                RegCloseKey(hKeyEventLog);
            }
            UnlockServiceDatabase(SCLock);
        }

        CloseServiceHandle(SCMHandle);
    } else {
        Result = GetLastError();
    }

    if (Result != NO_ERROR) {
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_DELSERVSCM_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Result);
    }
    return Result;
}


BOOL
IsDevRemovedFromAllHwProfiles(
    IN PCTSTR DeviceInstanceId,
    IN HMACHINE hMachine
    )
/*++

Routine Description:

    This routine determines whether the specified device instance has been removed from
    every hardware profile.  The device has been removed from a particular profile if
    its corresponding CsConfigFlags has the CSCONFIGFLAG_DO_NOT_CREATE bit set.

Arguments:

    DeviceInstanceId - Supplies the name of the device instance to check.

Return Value:

    If the device exists in only the specified profile, the return value is TRUE,
    otherwise, it is FALSE.

--*/
{
    CONFIGRET cr;
    ULONG i = 0;
    HWPROFILEINFO HwProfileInfo;
    ULONG HwProfFlags;

    //
    // Enumerate all the hardware profiles.
    //
    do {

        if((cr = CM_Get_Hardware_Profile_Info_Ex(i, &HwProfileInfo, 0,hMachine)) == CR_SUCCESS) {

            if((CM_Get_HW_Prof_Flags_Ex((DEVINSTID)DeviceInstanceId,
                                     HwProfileInfo.HWPI_ulHWProfile,
                                     &HwProfFlags,
                                     0,
                                     hMachine) != CR_SUCCESS) ||
               !(HwProfFlags & CSCONFIGFLAG_DO_NOT_CREATE))
            {
                //
                // If we couldn't retrieve the CSConfigFlags, or if the
                // CSCONFIGFLAG_DO_NOT_CREATE bit was not set, then we've found
                // a profile where the device still exists, so we can bail here.
                //
                return FALSE;
            }
        }

        i++;

    } while(cr != CR_NO_MORE_HW_PROFILES);

    //
    // We didn't find any hardware profile where the device wasn't removed.
    //
    return TRUE;
}


DWORD
GetDevInstConfigFlags(
    IN DEVINST DevInst,
    IN DWORD   Default,
    IN HMACHINE hMachine
    )
/*++

Routine Description:

    This routine retrieves the ConfigFlags for the specified device instance.  If the
    value can not be retrieved, the specified default is returned.

Arguments:

    DevInst - Supplies the handle of the device instance for which the ConfigFlags value
        is to be retrieved.

    Default - Supplies the default value that should be returned if for some reason the
        ConfigFlags cannot be retrieved.

Return Value:

    The ConfigFlags value for the specified device instance.

Notes:
        This is used for device install, and doesn't need to be remotable for 5.0

--*/
{
    DWORD ConfigFlags;
    ULONG ConfigFlagsSize = sizeof(ConfigFlags);

    if(CM_Get_DevInst_Registry_Property_Ex(DevInst,
                                        CM_DRP_CONFIGFLAGS,
                                        NULL,
                                        &ConfigFlags,
                                        &ConfigFlagsSize,
                                        0,
                                        hMachine) != CR_SUCCESS) {
        ConfigFlags = Default;
    }

    return ConfigFlags;
}


DWORD
pSetupDeleteService(
    IN PINFCONTEXT LineContext,
    IN DWORD       Flags,
    IN PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    This routine processes the specified DelService line in an INF's Service
    install section.  The line has the form:

    DelService = <ServiceName>[, [<flags>] [, [<EventLogType>] [, <EventName>]]]

    Flags :

        SPSVCINST_DELETEEVENTLOGENTRY - delete the associated event log entry
                                        for this service (if there is one).
                                        If the EventLogType field isn't specified,
                                        then it is assumed to be "System".  If
                                        the EventName field isn't specified, then
                                        it is assumed to be the same as the service
                                        name.

        SPSVCINST_DELETEEVENTLOGENTRY - stop the service before deleting it

Arguments:

    LineContext - Supplies the context of the DelService line to be processed.

    Flags - specifies one or more SPSVCINST_* flags

    LogContext - Supplies a pointer to a log context to be used for logging.

Return Value:

    If field 1 on the specified line could not be retrieved, then an error
    is returned.  Otherwise, the routine returns NO_ERROR (i.e., the routine
    is considered successful regardless of whether the service to delete
    actually existed).

--*/
{
    SVCNAME_NODE TempSvcNode;
    DWORD DelServiceFlags;
    PCTSTR EventLogType, EventLogName;
    BOOL DeleteEventLogEntry;
    DWORD Result = NO_ERROR;

    //
    // Initialize a service name node for a call to DeleteServicesInList.
    //
    if(!SetupGetStringField(LineContext,
                            1,
                            TempSvcNode.Name,
                            SIZECHARS(TempSvcNode.Name),
                            NULL)) {
        return GetLastError();
    }

    //
    // Get the flags field.
    //
    if(!SetupGetIntField(LineContext, 2, (PINT)&DelServiceFlags)) {
        DelServiceFlags = 0;
    }

    DeleteEventLogEntry = (Flags & SPSVCINST_DELETEEVENTLOGENTRY);

    //
    // If the caller specified that the associated event log entry should be
    // deleted, then make sure that flag is set.
    //
    if(DeleteEventLogEntry) {
        DelServiceFlags |= SPSVCINST_DELETEEVENTLOGENTRY;
    }

    if(TempSvcNode.DeleteEventLog = (DelServiceFlags & SPSVCINST_DELETEEVENTLOGENTRY)) {
        //
        // Retrieve the event log type (default is "System") and the event log name
        // (default is the service name).
        //
        if(!(EventLogType = pSetupGetField(LineContext, 3)) || !(*EventLogType)) {
            EventLogType = pszSystem;
        }

        if(!(EventLogName = pSetupGetField(LineContext, 4)) || !(*EventLogName)) {
            EventLogName = TempSvcNode.Name;
        }

        MYVERIFY(SUCCEEDED(StringCchCopy(TempSvcNode.EventLogType,
                                         SIZECHARS(TempSvcNode.EventLogType),
                                         EventLogType)));
        MYVERIFY(SUCCEEDED(StringCchCopy(TempSvcNode.EventLogName,
                                         SIZECHARS(TempSvcNode.EventLogName),
                                         EventLogName)));
    }

    TempSvcNode.Next = NULL;
    TempSvcNode.Flags = DelServiceFlags | Flags;

    Result = DeleteServicesInList(&TempSvcNode,LogContext);

    return Result;
}

BOOL
IsNativeDriver(
    PCTSTR FullPath
    )
/*++

Routine Description:

    determines if a kernel-mode driver binary is valid
    helps avoid bugchecks and catch problems earlier

Arguments:

    FullPath - Fully qualified path to the binary to be processed


Return Value:

    TRUE indicates that the file is a native driver

--*/
{
    LOADED_IMAGE LoadedImage;
    BOOL RetVal = FALSE;
    PSTR FullPathCopy;
    WORD WantedImage;
    BOOL locked = FALSE;

#if defined(_IA64_)
    WantedImage = IMAGE_FILE_MACHINE_IA64;
#elif defined(_AMD64_)
    WantedImage = IMAGE_FILE_MACHINE_AMD64;
#elif defined(_X86_)
    if(IsWow64) {
        //
        // we don't support installing drivers if in Wow64
        //
        return FALSE;
    }
    WantedImage = IMAGE_FILE_MACHINE_I386;
#else
#error Unknown platform
#endif
    //
    // imagehlp takes a non-const ANSI string, so convert it.
    //
    FullPathCopy = pSetupUnicodeToMultiByte(FullPath, CP_ACP);

    if (!FullPathCopy) {
        return(FALSE);
    }

    ZeroMemory(&LoadedImage,sizeof(LoadedImage));

    //
    // get the image headers
    //
    try {
        EnterCriticalSection(&ImageHlpMutex);
        locked = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    if(!locked) {
        MyFree(FullPathCopy);
        return FALSE;
    }
    if (MapAndLoad(
            FullPathCopy,
            NULL,
            &LoadedImage,
            FALSE, // assume it's an exe if there isn't any file extension
            TRUE /* read only */ )) {


        if ((LoadedImage.FileHeader->Signature == IMAGE_NT_SIGNATURE)
            && (LoadedImage.FileHeader->FileHeader.Machine == WantedImage)
            && (LoadedImage.FileHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)) {
            RetVal = TRUE;
        }

        UnMapAndLoad(&LoadedImage);
    }
    LeaveCriticalSection(&ImageHlpMutex);

    MyFree(FullPathCopy);

    return(RetVal);
}

DWORD
pSetupAddService(
    IN  PINFCONTEXT    LineContext,
    OUT PSVCNAME_NODE *SvcListHead,
    IN  DWORD          Flags,
    IN  DEVINST        DevInst,            OPTIONAL
    OUT PBOOL          NullDriverInstalled,
    IN  PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    This routine processes the specified AddService line in an INF's Service
    install section.  The line has the form:

    AddService = <ServiceName>, [<Flags>], <ServiceInstallSection>[, <EventLogInstallSection>[, [<EventLogType>] [, <EventName>]]]

    Currently, the following flags are defined:

        SPSVCINST_TAGTOFRONT   (0x1) - Move the tag for this service to the front of its
                                       group order list

        SPSVCINST_ASSOCSERVICE (0x2) - Associate this service with the device instance
                                       being installed (only used if DevInst is non-zero)

        SPSVCINST_NOCLOBBER_DISPLAYNAME     (0x8) - If this flag is specified, then
                                                    we will not overwrite the service's
                                                    display name, if it already exists.

        SPSVCINST_NOCLOBBER_STARTTYPE      (0x10) - If this flag is specified, then
                                                    we will not overwrite the service's
                                                    start type if the service already exists.

        SPSVCINST_NOCLOBBER_ERRORCONTROL   (0x20) - If this flag is specified, then
                                                    we will not overwrite the service's
                                                    error control value if the service
                                                    already exists.

        SPSVCINST_NOCLOBBER_LOADORDERGROUP (0x40) - If this flag is specified, then
                                                    we will not overwrite the service's
                                                    load order group if it already
                                                    exists.

        SPSVCINST_NOCLOBBER_DEPENDENCIES   (0x80) - If this flag is specified, then
                                                    we will not overwrite the service's
                                                    dependencies list if it already
                                                    exists.

        SPSVCINST_CLOBBER_SECURITY        (0x400) - If this flag is specified, then
                                                    security may be overridden.

    A service with the name <ServiceName> is created.  The parameters used in the
    call to CreateService are retrieved from the <ServiceInstallSection>, and are
    in the following format (lines not marked as optional must be present or the
    routine will fail):

    DisplayName    = <string>                  ; (optional) 'Friendly name' for the service
    ServiceType    = <number>                  ; one of the SERVICE_* type codes
    StartType      = <number>                  ; one of the SERVICE_* start codes
    ErrorControl   = <number>                  ; one of the SERVICE_ERROR_* error control codes
    ServiceBinary  = <string>                  ; path to binary
    LoadOrderGroup = <string>                  ; (optional) group to which this service belongs
    Dependencies   = <string>[[, <string>]...] ; (optional) list of groups (prefixed with '+')
                                               ; and services this service depends on
    StartName      = <string>                  ; (optional) driver object name used to load the
                                               ; driver--only used for drivers & filesystems
    Security       = <string>                  ; (optional) SDS specifying security

    SetupInstallFromInfSection is then called for the <ServiceInstallSection>, which may
    also contain registry modifications (SPINST_REGISTRY is the only flag used).  HKR is
    the service entry key.

    Finally, if <EventLogInstallSection> is specified, then a key for this service is
    created under HKLM\System\CurrentControlSet\Services\EventLog, and SetupInstallFromInfSection
    is invoked to do registry modifications specified in that section, with HKR being the event log
    entry (again, only SPINST_REGISTRY is used).  By default, the event log type is "System" and the
    event log name is the same as the service name.

Arguments:

    LineContext - Supplies the context of the AddService line to be processed.

    SvcListHead - Supplies the address of the linked-list head containing a list of
        all services newly created as a result of the current installation.  This
        routine first checks for the presence of the service, and if it already exists,
        then it simply modifies the existing one.  If the service doesn't already exist,
        then this routine creates a new SVCNAME_NODE, and fills it in with the name of
        the newly-created service.  Likewise, if an EventLog entry is given, then the
        presence of an existing one is checked first, and the service node's
        'DeleteEventLog' field is set to TRUE only if the event log entry didn't
        previously exist.  This list is kept to allow for proper clean-up in case
        of a later failure.

    Flags - Specifies how the service should be installed.  These flags are basically
        overrides of what the AddService flags field specifies, as described above.

    DevInst - If specified (i.e., non-zero), and if the SPSVCINST_ASSOCSERVICE flag is
        set in either the Flags parameter or the AddService flags INF field, then we will
        store this service name in the device instance's 'Service' registry property.

    NullDriverInstalled - Supplies a pointer to a boolean variable that is set
        upon successful return to indicate whether or not the service install
        specified a null service (i.e., the service name field in the INF AddService
        entry was empty).

    LogContext - Supplies a pointer to a log context so that info may be logged.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

Remarks:

    Note that we don't do anything special for SERVICE_ADAPTER and SERVICE_RECOGNIZER_DRIVER
    service types.  These types are invalid as far as the service contoller is concerned, so
    we just let the create/change service APIs do the validation on them.

--*/
{
    PCTSTR ServiceName, InstallSection, EventLogType, EventLogName;
    HINF hInf;
    INFCONTEXT InstallSectionContext;
    DWORD ServiceType, StartType, ErrorControl, ServiceInstallFlags;
    PCTSTR ServiceBinary;
    PCTSTR ActualBinary = NULL;
    TCHAR ServiceBinaryBuffer[MAX_PATH];
    PCTSTR DisplayName = NULL, LoadOrderGroup = NULL,
           StartName = NULL, Security = NULL, Description = NULL;
    PTSTR DependenciesBuffer;
    DWORD TagId;
    PDWORD NewTag;
    DWORD Err;
    SC_HANDLE SCMHandle, ServiceHandle;
    SC_LOCK SCLock;
    HKEY hKeyService, hKeyEventLog;
    TCHAR RegistryPath[SIZECHARS(REGSTR_PATH_SERVICES) + SIZECHARS(DISTR_EVENTLOG) + (2 * 256)];
    DWORD EventLogKeyDisposition;
    SVCNAME_NODE NewSvcNameNode;
    PSVCNAME_NODE TmpNode;
    BOOL NewService;
    INT PathLen;
    BOOL b, BinaryInSysRoot, ServiceHasTag;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    REGMOD_CONTEXT RegContext;
    BOOL NeedsReboot;

    //
    // Initially, assume we're not doing a null service install.
    //
    *NullDriverInstalled = FALSE;
    NeedsReboot = FALSE;

    //
    // Get the AddService flags.
    //
    if(!SetupGetIntField(LineContext, 2, (PINT)&ServiceInstallFlags)) {
        ServiceInstallFlags = 0;
    }

    //
    // Allow the caller-supplied flags to override the INF.
    //
    ServiceInstallFlags |= Flags;

    //
    // Now get the service name.
    //
    if(!(ServiceName = pSetupGetField(LineContext, 1)) || !(*ServiceName)) {
        //
        // This is only allowed if the SPSVCINST_ASSOCSERVICE flag is set.  That
        // indicates to PnP that a null driver installation is allowed, even
        // though the underlying bus didn't report the device as raw-capable.
        //
        if(ServiceInstallFlags & SPSVCINST_ASSOCSERVICE) {

            if(DevInst) {

                CM_Set_DevInst_Registry_Property(DevInst,
                                                 CM_DRP_SERVICE,
                                                 NULL,
                                                 0,
                                                 0
                                                );
            }

            *NullDriverInstalled = TRUE;
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_VERBOSE,
                MSG_LOG_ADDSERV_NULL,
                NULL);
            return NO_ERROR;

        } else {
            return GetLastError();
        }
    }

    //
    // Next, get the name of the install section.
    //
    if(!(InstallSection = pSetupGetField(LineContext, 3))) {
        return GetLastError();
    }

    //
    // Locate the service install section.
    //
    hInf = LineContext->Inf;

    //
    // Retrieve the required values from this section.  Don't do validation on them--leave
    // that up to the Service Control Manager.
    //
    if(!SetupFindFirstLine(hInf, InstallSection, pszServiceType, &InstallSectionContext) ||
       !SetupGetIntField(&InstallSectionContext, 1, (PINT)&ServiceType)) {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }

    if(!SetupFindFirstLine(hInf, InstallSection, pszStartType, &InstallSectionContext) ||
       !SetupGetIntField(&InstallSectionContext, 1, (PINT)&StartType)) {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }

    if(!SetupFindFirstLine(hInf, InstallSection, pszErrorControl, &InstallSectionContext) ||
       !SetupGetIntField(&InstallSectionContext, 1, (PINT)&ErrorControl)) {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }

    BinaryInSysRoot = FALSE;
    if(SetupFindFirstLine(hInf, InstallSection, pszServiceBinary, &InstallSectionContext) &&
       (ServiceBinary = pSetupGetField(&InstallSectionContext, 1)) && *ServiceBinary) {
        //
        // Compare the initial part of this path with the WindowsDirectory path.  If they're
        // the same, then we strip off that part (including the dividing backslash), and use
        // the rest of the path for the subsequent calls to SCM.  This allows SCM to assign
        // the special path to the binary, that is accessible, at any time (i.e, boot-loader on).
        //
        ActualBinary = ServiceBinary;

        PathLen = lstrlen(WindowsDirectory);
        MYASSERT(PathLen);

        //
        // Make sure that the it is possible for the WindowsDirectory to fit in the ServiceBinary
        // path string.
        //
        if(PathLen < lstrlen(ServiceBinary)) {
            //
            // There will never be a trailing backslash in the WindowsDirectory path, unless the
            // installation is at the root of a drive (e.g., C:\).  Check this, just to be
            // on the safe side.
            //
            // DBCS-unfriendly code ahead.  This isn't a problem in the ANSI version of
            // setupapi presently, because there's no such thing as service installation on Win9x.
            //
            b = (WindowsDirectory[PathLen - 1] == TEXT('\\'));

            if(b || (ServiceBinary[PathLen] == TEXT('\\'))) {
                //
                // The path prefix is in the right format--now we need to see if the two
                // paths actually match. Copy just the prefix part to another buffer, so
                // that we can do the comparison.
                //
                MYVERIFY(SUCCEEDED(StringCchCopy(ServiceBinaryBuffer,
                                   SIZECHARS(ServiceBinaryBuffer),
                                   ServiceBinary)));
                ServiceBinaryBuffer[PathLen] = TEXT('\0');

                if(!lstrcmpi(WindowsDirectory, ServiceBinaryBuffer)) {
                    //
                    // We have a match--take the relative part of the path (relative to SystemRoot),
                    // and do one of the following:
                    //
                    // 1. If it's a driver, simply use the relative part (no preceding backslash).
                    // This tells the bootloader/NtLoadDriver that the path is relative to the
                    // SystemRoot, so the driver can be loaded no matter what phase it's loaded in.
                    //
                    // 2. If it's a Win32 service, prepend a %SystemRoot%, so that the service will
                    // still be able to start if the drive letter mappings change.
                    //
                    ServiceBinary += PathLen;
                    if(!b) {
                        ServiceBinary++;
                    }

                    if(ServiceType & SERVICE_WIN32) {
                        PTSTR EndPtr;
                        size_t EndCount;

                        if(MYVERIFY(SUCCEEDED(StringCchCopyEx(ServiceBinaryBuffer,
                                                              SIZECHARS(ServiceBinaryBuffer),
                                                              pszSystemRoot,
                                                              &EndPtr,
                                                              &EndCount,
                                                              0)))) {
                            MYVERIFY(SUCCEEDED(StringCchCopy(EndPtr,EndCount,ServiceBinary)));
                        }
                        ServiceBinary = ServiceBinaryBuffer;
                    }

                    BinaryInSysRoot = TRUE;
                }
            }
        }

    } else {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }

    //
    // If this is a driver, then it has to be located under SystemRoot.
    //
    if(ServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER)) {
        if(!BinaryInSysRoot) {
            //
            // service install section is wrong, driver path is bad
            //
            return ERROR_BAD_SERVICE_INSTALLSECT;
        }
        if(DevInst) {
            if(!FileExists(ActualBinary,NULL)) {
                //
                // service install section is wrong, it doesn't point to existing
                // binary
                //
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    MSG_LOG_MISSING_DRIVER,
                    NULL,
                    ServiceName,
                    ActualBinary
                    );
                return ERROR_BAD_SERVICE_INSTALLSECT;
            }
            if(!IsNativeDriver(ActualBinary)) {
                //
                // oh oh, we've come this far, only to find that we're going to try and use
                // a non-native or bad driver
                //
                // we might be able to revert original binary if there was one
                //
                if(pSetupRestoreLastKnownGoodFile(ActualBinary,0,LogContext)
                   && IsNativeDriver(ActualBinary)) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_ERROR,
                        MSG_LOG_REVERTED_BAD_DRIVER,
                        NULL,
                        ServiceName,
                        ActualBinary
                        );
                } else {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_ERROR,
                        MSG_LOG_HAVE_BAD_DRIVER,
                        NULL,
                        ServiceName,
                        ActualBinary
                        );
                }
                return ERROR_DRIVER_NONNATIVE;
            }
        }
    }
    //
    // if this is a boot start driver, we need a reboot for it to start running
    //
    if (StartType == SERVICE_BOOT_START) {
        NeedsReboot = TRUE;
    }

    //
    // Now check for the other, optional, parameters.
    //
    if(SetupFindFirstLine(hInf, InstallSection, pszDisplayName, &InstallSectionContext)) {
        if((DisplayName = pSetupGetField(&InstallSectionContext, 1)) && !(*DisplayName)) {
            DisplayName = NULL;
        }
    }

    if(SetupFindFirstLine(hInf, InstallSection, pszLoadOrderGroup, &InstallSectionContext)) {
        if((LoadOrderGroup = pSetupGetField(&InstallSectionContext, 1)) && !(*LoadOrderGroup)) {
            LoadOrderGroup = NULL;
        }
    }

    if(SetupFindFirstLine(hInf, InstallSection, pszSecurity, &InstallSectionContext)) {
        if((Security = pSetupGetField(&InstallSectionContext, 1)) && !(*Security)) {
            Security = NULL;
        }
    }

    if(SetupFindFirstLine(hInf, InstallSection, pszDescription, &InstallSectionContext)) {
        if((Description = pSetupGetField(&InstallSectionContext, 1)) && !(*Description)) {
            Description = NULL;
        }
    }

    //
    // Only retrieve the StartName parameter for kernel-mode drivers and win32 services.
    //
    if(ServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER | SERVICE_WIN32)) {

        if(SetupFindFirstLine(hInf, InstallSection, pszStartName, &InstallSectionContext)) {
            if((StartName = pSetupGetField(&InstallSectionContext, 1)) &&
               !(*StartName)) {

                StartName = NULL;
            }
        }
    }

    //
    // We now need to retrieve the multi-sz list of dependencies.  This requires memory allocation,
    // so we include everything from here on out in try/except, so that we can do proper clean-up
    // in case we encounter an inpage error.
    //
    DependenciesBuffer = NULL;
    SCMHandle = ServiceHandle = NULL;
    SCLock = NULL;
    hKeyService = hKeyEventLog = NULL;
    Err = NO_ERROR;
    NewService = FALSE;
    ServiceConfig = NULL;
    try {

        if(!(DependenciesBuffer = GetMultiSzFromInf(hInf, InstallSection, pszDependencies, &b)) && b) {
            //
            // Then we failed to retrieve a dependencies list because of an out-of-memory error.
            //
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // We've now retrieved all parameters necessary to create a service.
        //
        if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
            Err = GetLastError();
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                MSG_LOG_ADDSERVSCM_ERROR,
                NULL);
            WriteLogError(
                LogContext,
                DRIVER_LOG_ERROR,
                Err);
            goto clean0;
        }

        //
        // Only generate a tag for this service if it has a load order group, and is a kernel or
        // filesystem driver.
        //
        ServiceHasTag = (LoadOrderGroup &&
                         (ServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER)));

        NewTag = ServiceHasTag ? &TagId : NULL;

        ServiceHandle = CreateService(SCMHandle,
                                      ServiceName,
                                      DisplayName,
                                      SERVICE_CHANGE_CONFIG,
                                      ServiceType,
                                      StartType,
                                      ErrorControl,
                                      ServiceBinary,
                                      LoadOrderGroup,
                                      NewTag,
                                      DependenciesBuffer,
                                      StartName,
                                      NULL
                                     );
        if(ServiceHandle) {
            NewService = TRUE;
            NewSvcNameNode.Next = NULL;
            NewSvcNameNode.DeleteEventLog = FALSE;
            MYVERIFY(SUCCEEDED(StringCchCopy(NewSvcNameNode.Name,
                                             SIZECHARS(NewSvcNameNode.Name),
                                             ServiceName)));

            if( Security ){
                //
                // Log security being set.
                //
                if( NO_ERROR != (Err = pSetupCallSCE( ST_SCE_SERVICES, ServiceName, NULL, Security, StartType, NULL )) ) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                        MSG_LOG_ADDSERVSECURE_ERROR,
                        NULL,
                        ServiceName
                        );
                    WriteLogError(
                        LogContext,
                        DRIVER_LOG_ERROR,
                        Err);

                    goto clean0;
                }
            }

            WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_VERBOSE,
                        MSG_LOG_ADDSERVCREATE_OK,
                        NULL,
                        ServiceName
                        );

        } else {
            //
            // If we were unable to create the service, then check to see if the service already
            // exists.  If so, all we need to do is change the configuration parameters in the
            // service.
            //
            if((Err = GetLastError()) != ERROR_SERVICE_EXISTS) {

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_ADDSERVCREATE_ERROR,
                    NULL,
                    ServiceName
                    );
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);

                goto clean0;
            }

            //
            // Lock the service database.
            //
            if(NO_ERROR != (Err = pAcquireSCMLock(SCMHandle, &SCLock, LogContext))) {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_ADDSERVLOCK_ERROR,
                    NULL
                    );
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
                goto clean0;
            }

            if(!(ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS))) {
                Err = GetLastError();
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_ADDSERVOPEN_ERROR,
                    NULL,
                    ServiceName
                    );
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
                goto clean0;
            }

            if((Err = pSetupRetrieveServiceConfig(ServiceHandle, &ServiceConfig)) != NO_ERROR) {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_ADDSERVCONFIG_ERROR,
                    NULL,
                    ServiceName
                    );
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
                //
                // Make sure our ServiceConfig pointer is still NULL.
                //
                ServiceConfig = NULL;
                goto clean0;
            }

            //
            // Since this is an existing driver, then it may already have a perfectly good tag.  If
            // so, we don't want to disturb it.
            //
            if(ServiceHasTag) {

                if(ServiceConfig->lpLoadOrderGroup && *(ServiceConfig->lpLoadOrderGroup)) {
                    //
                    // The service already has a load order group specified.
                    // Check to see whether the load order group 'noclobber'
                    // flag is set.
                    //
                    if(ServiceInstallFlags & SPSVCINST_NOCLOBBER_LOADORDERGROUP) {
                        //
                        // We should leave the existing load order group as-is.
                        // We do this by replacing the INF-specified one with the
                        // previously-existing one.  That way, our code below will
                        // still generate a tag if necessary.
                        //
                        LoadOrderGroup = ServiceConfig->lpLoadOrderGroup;
                    }

                    if(!lstrcmpi(ServiceConfig->lpLoadOrderGroup, LoadOrderGroup) && ServiceConfig->dwTagId) {
                        //
                        // The load order group hasn't changed, and there's already a tag assigned, so
                        // leave it alone.
                        //
                        NewTag = NULL;
                        TagId = ServiceConfig->dwTagId;
                    }
                }
            }

            if(ServiceInstallFlags & SPSVCINST_NOCLOBBER_DISPLAYNAME) {
                //
                // If the service already has a display name, then we don't want
                // to overwrite it.
                //
                if(ServiceConfig->lpDisplayName && *(ServiceConfig->lpDisplayName)) {
                    DisplayName = NULL;

                }
            }

            if(ServiceInstallFlags & SPSVCINST_NOCLOBBER_DEPENDENCIES) {
                //
                // If the service already has a dependencies list, then we don't
                // want to overwrite it.
                //
                if(ServiceConfig->lpDependencies && *(ServiceConfig->lpDependencies)) {
                    MyFree(DependenciesBuffer);
                    DependenciesBuffer = NULL;
                }
            }

            if(!ChangeServiceConfig(ServiceHandle,
                                    ServiceType,
                                    (ServiceInstallFlags & SPSVCINST_NOCLOBBER_STARTTYPE)
                                        ? SERVICE_NO_CHANGE : StartType,
                                    (ServiceInstallFlags & SPSVCINST_NOCLOBBER_ERRORCONTROL)
                                        ? SERVICE_NO_CHANGE : ErrorControl,
                                    ServiceBinary,
                                    LoadOrderGroup,
                                    NewTag,
                                    DependenciesBuffer,
                                    StartName,
                                    TEXT(""),
                                    DisplayName)) {

                Err = GetLastError();
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_ADDSERVCHANGE_ERROR,
                    NULL,
                    ServiceName
                    );
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
                goto clean0;
            } else {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_VERBOSE,
                    MSG_LOG_ADDSERVCHANGE_OK,
                    NULL,
                    ServiceName
                    );

            }
            if( Security && (ServiceInstallFlags & SPSVCINST_CLOBBER_SECURITY)){
                //
                // Set/log security
                // in this scenario, service was already running
                // so don't fail if we can't change security
                //
                if( NO_ERROR != (Err = pSetupCallSCE( ST_SCE_SERVICES,
                                                        ServiceName,
                                                        NULL,
                                                        Security,
                                                        (ServiceInstallFlags & SPSVCINST_NOCLOBBER_STARTTYPE)
                                                           ? ServiceConfig->dwStartType
                                                           : StartType,
                                                        NULL )) ) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                        MSG_LOG_ADDSERVSECURE_ERROR,
                        NULL,
                        ServiceName
                        );
                    WriteLogError(
                        LogContext,
                        DRIVER_LOG_ERROR,
                        Err);

                    //goto clean0;
                }
            }

        }

        //
        // we've added/updated the service, now handle the description, which is an oddball
        // parameter since it's a new parameter and isn't present in the prior calls.
        //
        //
        // we ignore failure at this point since this won't effect operation of the service.
        //
        if ((NewService && Description) || ((ServiceInstallFlags & SPSVCINST_NOCLOBBER_DESCRIPTION) == 0)) {
            SERVICE_DESCRIPTION ServiceDescription;

            ServiceDescription.lpDescription = (LPTSTR)Description;
            ChangeServiceConfig2(ServiceHandle, SERVICE_CONFIG_DESCRIPTION,&ServiceDescription);

        }

        //
        // We've successfully created/updated the service.  If this service has a load order group
        // tag, then make sure it's in the appropriate GroupOrderList entry.
        //
        // (We ignore failure here, since the service should still work just fine without this.)
        //
        if(ServiceHasTag) {
            pSetupAddTagToGroupOrderListEntry(LoadOrderGroup,
                                        TagId,
                                        ServiceInstallFlags & SPSVCINST_TAGTOFRONT);
        }

        //
        // Now process any AddReg and DelReg entries found in this service install section.
        //
        MYVERIFY(SUCCEEDED(StringCchCopy(RegistryPath,
                                         SIZECHARS(RegistryPath),
                                         pszServicesRegPath)));

        MYVERIFY(pSetupConcatenatePaths(RegistryPath,
                                        ServiceName,
                                        SIZECHARS(RegistryPath),
                                        NULL
                                        ));
        if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               RegistryPath,
                               0,
                               KEY_READ | KEY_WRITE,
                               &hKeyService)) != ERROR_SUCCESS) {
            goto clean0;
        }

        ZeroMemory(&RegContext, sizeof(RegContext));
        RegContext.UserRootKey = hKeyService;

        if((Err = pSetupInstallRegistry(hInf, InstallSection, &RegContext)) != NO_ERROR) {
            goto clean0;
        }

        //
        // Now, see if the INF also specifies an EventLog installation section.  If so, create a
        // key under HKLM\System\CurrentControlSet\Services\EventLog\System for that service, and
        // run the registry modification lines in the specified install section.
        //
        if((InstallSection = pSetupGetField(LineContext, 4)) && *InstallSection) {
            //
            // Get the (optional) event log type and event log name strings.
            //
            if(!(EventLogType = pSetupGetField(LineContext, 5)) || !(*EventLogType)) {
                EventLogType = pszSystem;
            }

            if(!(EventLogName = pSetupGetField(LineContext, 6)) || !(*EventLogName)) {
                EventLogName = ServiceName;
            }

            //
            // We already have the services database registry path in our registry path buffer.  All
            // we need to do is add the \EventLog\<EventLogType>\<EventLogName> part.
            //
            MYVERIFY(SUCCEEDED(StringCchCopy(RegistryPath + CSTRLEN(REGSTR_PATH_SERVICES),
                                             SIZECHARS(RegistryPath)-CSTRLEN(REGSTR_PATH_SERVICES),
                                             pszEventLog)));

            MYVERIFY(pSetupConcatenatePaths(RegistryPath,
                                            EventLogType,
                                            SIZECHARS(RegistryPath),
                                            NULL
                                            ));
            MYVERIFY(pSetupConcatenatePaths(RegistryPath,
                                            EventLogName,
                                            SIZECHARS(RegistryPath),
                                            NULL
                                            ));

            if((Err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                     RegistryPath,
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     &hKeyEventLog,
                                     &EventLogKeyDisposition)) != ERROR_SUCCESS) {
                goto clean0;
            }

            if(EventLogKeyDisposition == REG_CREATED_NEW_KEY) {
                NewSvcNameNode.DeleteEventLog = TRUE;
                MYVERIFY(SUCCEEDED(StringCchCopy(NewSvcNameNode.EventLogType,
                                                 SIZECHARS(NewSvcNameNode.EventLogType),
                                                 EventLogType)));
                MYVERIFY(SUCCEEDED(StringCchCopy(NewSvcNameNode.EventLogName,
                                                 SIZECHARS(NewSvcNameNode.EventLogName),
                                                 EventLogName)));
            }

            ZeroMemory(&RegContext, sizeof(RegContext));
            RegContext.UserRootKey = hKeyEventLog;

            if((Err = pSetupInstallRegistry(hInf, InstallSection, &RegContext)) != NO_ERROR) {
                goto clean0;
            }
        }

        //
        // Service entry (and optional EventLog entry) were successfully installed.  If the
        // AddService flags field in the INF included the SPSVCINST_ASSOCSERVICE flag, _and_
        // the caller supplied us with a non-zero DevInst handle, then we need to set the
        // device instance's 'Service' property to indicate that it is associated with this
        // service.
        //
        if(DevInst && (ServiceInstallFlags & SPSVCINST_ASSOCSERVICE)) {

            CM_Set_DevInst_Registry_Property(DevInst,
                                             CM_DRP_SERVICE,
                                             ServiceName,
                                             (lstrlen(ServiceName) + 1) * sizeof(TCHAR),
                                             0
                                            );
        }

        //
        // If a new service was created, then link a new service name node into the list we
        // were passed in.  Don't fret about the case where we can't allocate a node--it just
        // means we won't know about this new service in case clean-up is required later.
        //
        if(NewService) {

            if(TmpNode = MyMalloc(sizeof(SVCNAME_NODE))) {

                MYVERIFY(SUCCEEDED(StringCchCopy(TmpNode->Name,
                                                 SIZECHARS(TmpNode->Name),
                                                 NewSvcNameNode.Name)));
                if(TmpNode->DeleteEventLog = NewSvcNameNode.DeleteEventLog) {
                    MYVERIFY(SUCCEEDED(StringCchCopy(TmpNode->EventLogType,
                                                     SIZECHARS(TmpNode->EventLogType),
                                                     NewSvcNameNode.EventLogType)));
                    MYVERIFY(SUCCEEDED(StringCchCopy(TmpNode->EventLogName,
                                                     SIZECHARS(TmpNode->EventLogName),
                                                     NewSvcNameNode.EventLogName)));
                }

                TmpNode->Next = *SvcListHead;
                *SvcListHead = TmpNode;
            }
        }

clean0: ; // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If our exception was an AV, then use Win32 invalid param error, otherwise, assume it was
        // an inpage error dealing with a mapped-in file.
        //
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;

        //
        // Access the following variables so that the compiler will respect our statement ordering
        // w.r.t. these values.  Otherwise, we can't be sure that we know whether or not their
        // corresponding resources should be freed.
        //
        DependenciesBuffer = DependenciesBuffer;
        hKeyService = hKeyService;
        hKeyEventLog = hKeyEventLog;
        ServiceHandle = ServiceHandle;
        SCLock = SCLock;
        SCMHandle = SCMHandle;
        NewService = NewService;
        ServiceConfig = ServiceConfig;
    }

    if(ServiceConfig) {
        MyFree(ServiceConfig);
    }
    if(DependenciesBuffer) {
        MyFree(DependenciesBuffer);
    }
    if(hKeyService) {
        RegCloseKey(hKeyService);
    }
    if(hKeyEventLog) {
        RegCloseKey(hKeyEventLog);
    }
    if(ServiceHandle) {
        CloseServiceHandle(ServiceHandle);
    }
    if(SCLock) {
        UnlockServiceDatabase(SCLock);
    }
    if(SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }


    if (Err != NO_ERROR) {
        if (NewService) {
            //
            // Then we failed part-way through, and need to clean up the service (and
            // possibly event log entry) we created.
            //
            DeleteServicesInList(&NewSvcNameNode,LogContext);
        }
    } else {
        if (NeedsReboot) {
            SetLastError(ERROR_SUCCESS_REBOOT_REQUIRED);
        }
    }

    return Err;
}


DWORD
pSetupRetrieveServiceConfig(
    IN  SC_HANDLE               ServiceHandle,
    OUT LPQUERY_SERVICE_CONFIG *ServiceConfig
    )
/*++

Routine Description:

    This routine allocates a buffer for the specified service's configuration parameters,
    and retrieves those parameters into the buffer.  The caller is responsible for freeing
    the buffer.

Arguments:

    ServiceHandle - supplies a handle to the service being queried

    ServiceConfig - supplies the address of a QUERY_SERVICE_CONFIG pointer that receives
        the address of the allocated buffer containing the requested information.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

Remarks:

    The pointer whose address is contained in ServiceConfig is guaranteed to be NULL upon
    return if any error occurred.

--*/
{
    DWORD ServiceConfigSize = 0, Err;

    MYASSERT(ServiceConfig);
    *ServiceConfig = NULL;

    while(TRUE) {

        if(QueryServiceConfig(ServiceHandle, *ServiceConfig, ServiceConfigSize, &ServiceConfigSize)) {
            MYASSERT(*ServiceConfig);
            return NO_ERROR;
        } else {

            Err = GetLastError();

            if(*ServiceConfig) {
                MyFree(*ServiceConfig);
            }

            if(Err == ERROR_INSUFFICIENT_BUFFER) {
                //
                // Allocate a larger buffer, and try again.
                //
                if(!(*ServiceConfig = MyMalloc(ServiceConfigSize))) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                *ServiceConfig = NULL;
                return Err;
            }
        }
    }
}

DWORD
RetrieveServiceConfig2(
    IN  SC_HANDLE               ServiceHandle,
    IN  DWORD                   Level,
    OUT LPBYTE                  *Buffer
    )
/*++

Routine Description:

    This routine allocates a buffer for the specified service's configuration parameters,
    and retrieves those parameters into the buffer.  The caller is responsible for freeing
    the buffer.

Arguments:

    ServiceHandle - supplies a handle to the service being queried

    Level         - specifies the information to query

    Buffer        - supplies the address of an opaque address to the buffer containing the info.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

Remarks:

    The pointer whose address is contained in Buffer is guaranteed to be NULL upon
    return if any error occurred.

--*/
{

    DWORD ServiceConfigSize = 0, Err;

    *Buffer = NULL;

    while(TRUE) {

        if(QueryServiceConfig2(ServiceHandle, Level, *Buffer, ServiceConfigSize, &ServiceConfigSize)) {
            MYASSERT(*Buffer);
            return NO_ERROR;
        } else {

            Err = GetLastError();

            if(*Buffer) {
                MyFree(*Buffer);
            }

            if(Err == ERROR_INSUFFICIENT_BUFFER) {
                //
                // Allocate a larger buffer, and try again.
                //
                if(!(*Buffer = MyMalloc(ServiceConfigSize))) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                *Buffer = NULL;
                return Err;
            }
        }
    }
}


DWORD
pSetupAddTagToGroupOrderListEntry(
    IN PCTSTR LoadOrderGroup,
    IN DWORD  TagId,
    IN BOOL   MoveToFront
    )
/*++

Routine Description:

    This routine first creates the specified LoadOrderGroup value entry under

        HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\GroupOrderList

    if the value doesn't already exist.  The routine then inserts the specified
    tag into the list.  If MoveToFront is TRUE, the tag is inserted at the front
    of the list (or moved to the front of the list if it was already present in
    the list).  If MoveToFront is FALSE, then the new tag is inserted at the end
    of the list, or left where it is if it already exists in the list.

Arguments:

    LoadOrderGroup - Specifies the name of the LoadOrderGroup to insert this new
        tag into.

    TagId - Specifies the tag ID to be inserted into the list.

    MoveToFront - If TRUE, place the tag at the front of the list.  If FALSE, then
        append the tag to the end of the list, unless it was already there, in which
        case it is left where it was.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

--*/
{
    DWORD Err;
    HKEY hKey;
    PDWORD GroupOrderList, p;
    DWORD GroupOrderListSize, DataType, ExtraBytes, i, NumElements;

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           pszGroupOrderListPath,
                           0,
                           KEY_ALL_ACCESS,
                           &hKey)) != ERROR_SUCCESS) {
        return Err;
    }

    Err = QueryRegistryValue(hKey,
                             LoadOrderGroup,
                             (PVOID)(&GroupOrderList),
                             &DataType,
                             &GroupOrderListSize
                            );

    if(Err == NO_ERROR) {
        //
        // Validate the list, and fix it if it's broken.
        //
        if(GroupOrderListSize < sizeof(DWORD)) {
            if(GroupOrderList) {
                MyFree(GroupOrderList);
            }

            if(GroupOrderList = MyMalloc(sizeof(DWORD))) {
                *GroupOrderList = 0;
                GroupOrderListSize = sizeof(DWORD);
            } else {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
        } else {
            if(ExtraBytes = GroupOrderListSize % sizeof(DWORD)) {
                if(p = MyRealloc(GroupOrderList, GroupOrderListSize + (sizeof(DWORD) - ExtraBytes))) {
                    GroupOrderList = p;
                    ZeroMemory((PBYTE)GroupOrderList + GroupOrderListSize, ExtraBytes);
                    GroupOrderListSize += ExtraBytes;
                } else {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean1;
                }
            }
        }

        MYASSERT(!(GroupOrderListSize % sizeof(DWORD)));

        //
        // We now have a list that's at least in the correct format.  Now validate the list count,
        // and adjust if necessary.
        //
        NumElements = (GroupOrderListSize / sizeof(DWORD)) - 1;

        if(*GroupOrderList != NumElements) {
            if(*GroupOrderList > NumElements) {
                *GroupOrderList = NumElements;
            } else {
                NumElements = *GroupOrderList;
                GroupOrderListSize = (NumElements + 1) * sizeof(DWORD);
            }
        }

    } else {
        //
        // If we ran out of memory, then bail, otherwise, just assume
        // there wasn't a list to retrieve.
        //
        if(Err == ERROR_NOT_ENOUGH_MEMORY) {
            goto clean0;
        } else {
            //
            // Allocate a list containing no tags.
            //
            if(GroupOrderList = MyMalloc(sizeof(DWORD))) {
                *GroupOrderList = 0;
                GroupOrderListSize = sizeof(DWORD);
            } else {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
        }
    }

    //
    // Now we have a valid group order list to manipulate.
    //
    for(i = 0; i < *GroupOrderList; i++) {
        if(GroupOrderList[i + 1] == TagId) {
            //
            // Tag already exists in the list.
            //
            break;
        }
    }

    if(i == *GroupOrderList) {
        //
        // Then we didn't find the tag in the list.  Add it either to the front, or
        // the end, depending on the 'MoveToFront' flag.
        //
        if(p = MyRealloc(GroupOrderList, GroupOrderListSize + sizeof(DWORD))) {
            GroupOrderList = p;
            GroupOrderListSize += sizeof(DWORD);
        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;

        }

        if(MoveToFront) {
            MoveMemory(&(GroupOrderList[2]), &(GroupOrderList[1]), *GroupOrderList * sizeof(DWORD));
            GroupOrderList[1] = TagId;
        } else {
            GroupOrderList[*GroupOrderList + 1] = TagId;
        }

        (*GroupOrderList)++;

    } else if(MoveToFront && i) {
        MoveMemory(&(GroupOrderList[2]), &(GroupOrderList[1]), i * sizeof(DWORD));
        GroupOrderList[1] = TagId;
    }

    //
    // Now write the value back to the registry.
    //
    Err = RegSetValueEx(hKey,
                        LoadOrderGroup,
                        0,
                        REG_BINARY,
                        (PBYTE)GroupOrderList,
                        GroupOrderListSize
                       );

clean1:
    MyFree(GroupOrderList);

clean0:
    RegCloseKey(hKey);

    return Err;
}


PTSTR
pSetupCmdLineAppendString(
    IN OUT PTSTR  CmdLine,
    IN     PCTSTR Key,
    IN     PCTSTR Value,   OPTIONAL
    IN OUT PUINT  StrLen,
    IN OUT PUINT  BufSize
    )

/*++

Routine Description:

    Forms a new (multi-sz) command line by appending a list of arguments to
    the current command line. For example:

        CmdLine = SpSetupCmdLineAppendString(
                    CmdLine,
                    "STF_PRODUCT",
                    "NTWKSTA"
                    );

    would append "STF_PRODUCT\0NTWKSTA\0\0" to CmdLine.

Arguments:

    CmdLine - Original CmdLine, to be appended to.  THIS BUFFER MUST CONTAIN
        AT LEAST A SINGLE NULL CHARACTER!

    Key - Key identifier

    Value - Value of Key

    StrLen - How long the current string in -- save on strlens

    BufSize - Size of Current Buffer

Returns:

    Pointer to the new string, or NULL if out-of-memory (in that case, the
    original CmdLine buffer is freed).

--*/

{
    PTSTR Ptr;
    UINT NewLen;

    //
    // Handle special cases so we don't end up with empty strings.
    //
    if(!Value || !(*Value)) {
        Value = TEXT("\"\"");
    }

    //
    // "\0" -> 1 chars
    // "\0\0" -> 2 char
    // but we have to back up 1 character...
    //
    NewLen = (*StrLen + 2 + lstrlen(Key) + lstrlen(Value));

    //
    // Allocate more space if necessary.
    //
    if(NewLen >= *BufSize) {
        //
        // Grow the current buffer
        //
        *BufSize += 1024;

        if(Ptr = MyRealloc(CmdLine, (*BufSize) * sizeof(TCHAR))) {
            CmdLine = Ptr;
        } else {
            //
            // Free the memory here so the caller doesn't have to worry about it.
            //
            MyFree(CmdLine);
            return NULL;
        }
    }


    Ptr = &(CmdLine[*StrLen-1]);
    MYVERIFY(SUCCEEDED(StringCchCopy(Ptr,
                                     *BufSize-(Ptr-CmdLine),
                                     Key)));
    Ptr = &(CmdLine[*StrLen+lstrlen(Key)]);
    MYVERIFY(SUCCEEDED(StringCchCopy(Ptr,
                                     *BufSize-(Ptr-CmdLine),
                                     Value)));
    CmdLine[NewLen-1] = TEXT('\0');

    //
    // Update the length of the buffer that we are using
    //
    *StrLen = NewLen;

    return CmdLine;
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetActualSectionToInstallA(
    IN  HINF    InfHandle,
    IN  PCSTR   InfSectionName,
    OUT PSTR    InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PSTR   *Extension              OPTIONAL
    )
{
    return SetupDiGetActualSectionToInstallExA(InfHandle,
                                               InfSectionName,
                                               NULL,
                                               InfSectionWithExt,
                                               InfSectionWithExtSize,
                                               RequiredSize,
                                               Extension,
                                               NULL
                                              );
}

BOOL
WINAPI
SetupDiGetActualSectionToInstall(
    IN  HINF    InfHandle,
    IN  PCTSTR  InfSectionName,
    OUT PTSTR   InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PTSTR  *Extension              OPTIONAL
    )

/*++

Routine Description:

    (See description of SetupDiGetActualSectionToInstallEx)

--*/

{
    return SetupDiGetActualSectionToInstallEx(InfHandle,
                                              InfSectionName,
                                              NULL,
                                              InfSectionWithExt,
                                              InfSectionWithExtSize,
                                              RequiredSize,
                                              Extension,
                                              NULL
                                             );
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetActualSectionToInstallExA(
    IN  HINF                    InfHandle,
    IN  PCSTR                   InfSectionName,
    IN  PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo, OPTIONAL
    OUT PSTR                    InfSectionWithExt,     OPTIONAL
    IN  DWORD                   InfSectionWithExtSize,
    OUT PDWORD                  RequiredSize,          OPTIONAL
    OUT PSTR                   *Extension,             OPTIONAL
    IN  PVOID                   Reserved
    )
{
    PWSTR infsectionname;
    DWORD rc;
    BOOL b;
    PWSTR extension;
    UINT CharOffset,i;
    PSTR p;
    DWORD requiredsize;
    WCHAR newsection[MAX_SECT_NAME_LEN];
    PSTR ansi;

    rc = pSetupCaptureAndConvertAnsiArg(InfSectionName,&infsectionname);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = SetupDiGetActualSectionToInstallExW(
            InfHandle,
            infsectionname,
            AlternatePlatformInfo,
            newsection,
            MAX_SECT_NAME_LEN,
            &requiredsize,
            &extension,
            Reserved
            );

    rc = GetLastError();

    if(b) {

        if(ansi = pSetupUnicodeToAnsi(newsection)) {

            requiredsize = lstrlenA(ansi)+1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    rc = ERROR_INVALID_PARAMETER;
                    b = FALSE;
                }
            }

            if(b && InfSectionWithExt) {

                if(requiredsize <= InfSectionWithExtSize) {

                    if(FAILED(StringCchCopyA(InfSectionWithExt,
                                             InfSectionWithExtSize,
                                             ansi))) {
                        //
                        // lstrcpy faulted, so InfSectionWithExt must be bad
                        //
                        rc = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }
                } else {
                    rc = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                }
            }

            if(b && Extension) {

                if(extension && InfSectionWithExt) {
                    //
                    // We need to figure out where the extension is
                    // in the converted string. To be DBCS safe we will
                    // count characters forward to find it.
                    //
                    CharOffset = (UINT)(extension - newsection);
                    p = InfSectionWithExt;
                    for(i=0; i<CharOffset; i++) {
                        p = CharNextA(p);
                    }
                } else {
                    p = NULL;
                }

                try {
                    *Extension = p;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    b = FALSE;
                    rc = ERROR_INVALID_PARAMETER;
                }
            }

            MyFree(ansi);

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
        }
    }

    MyFree(infsectionname);
    SetLastError(rc);
    return(b);
}

BOOL
WINAPI
SetupDiGetActualSectionToInstallEx(
    IN  HINF                    InfHandle,
    IN  PCTSTR                  InfSectionName,
    IN  PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo, OPTIONAL
    OUT PTSTR                   InfSectionWithExt,     OPTIONAL
    IN  DWORD                   InfSectionWithExtSize,
    OUT PDWORD                  RequiredSize,          OPTIONAL
    OUT PTSTR                  *Extension,             OPTIONAL
    IN  PVOID                   Reserved
    )
/*++

Routine Description:

    This API finds the appropriate install section to be used when installing
    a device from a Win95-style device INF.  Refer to the documentation for
    SetupDiInstallDevice for details on how this determination is made.

Arguments:

    InfHandle - Supplies the handle of the INF to be installed from.

    InfSectionName - Supplies the name of the install section, as specified by
        the driver node being installed.

    AlternatePlatformInfo - Optionally, supplies alternate platform information
        to be used in selecting the section.  Presently, only the Platform and
        ProcessorArchitecture fields are used in formulating the section
        decoration.  (NOTE: caller may actually pass in a V1 struct instead--
        this is fine, as the fields we care about are shared in common between
        the V1 and V2 structs.)

    InfSectionWithExt - Optionally, supplies the address of a character buffer
        that receives the actual install section name that should be used
        during installation.  If this parameter is NULL, then
        InfSectionWithExtSize must be zero.  In that case, the caller is only
        interested in retrieving the required buffer size, so the API will
        return TRUE, and RequiredSize (if supplied), will be set to the size,
        in characters, necessary to store the actual install section name.

    InfSectionWithExtSize - Supplies the size, in characters, of the
        InfSectionWithExt buffer.

    RequiredSize - Optionally, supplies the address of a variable that receives
        the size, in characters, required to store the actual install section
        name (including terminating NULL).

    Extension - Optionally, supplies the address of a variable that receives a
        pointer to the extension (including '.'), or NULL if no extension is to
        be used.  The pointer points to the extension within the caller-
        supplied buffer.  If the InfSectionWithExt buffer is not supplied, then
        this variable will not be filled in.

    Reserved - Must be NULL.

Returns:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    Presently, the only possible failures are ERROR_INVALID_PARAMETER
    (bad caller-supplied pointers), and ERROR_INSUFFICIENT_BUFFER (if the
    caller-supplied buffer isn't large enough).  If we fall back to the
    baseline (i.e., non-decorated) section name, then we simply return it,
    without verifying that the section actually exists.

--*/
{
    TCHAR TempInfSectionName[MAX_SECT_NAME_LEN];
    DWORD SectionNameLen = (DWORD)lstrlen(InfSectionName);
    DWORD ExtBufferLen;
    BOOL ExtFound = TRUE;
    DWORD Err = NO_ERROR;
    DWORD Platform;
    PCTSTR NtArchSuffix;
    DWORD  NtArchSuffixSize;

    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(SectionNameLen >= MAX_SECT_NAME_LEN) {
        SetLastError(ERROR_SECTION_NAME_TOO_LONG);
        return FALSE;
    }

    //
    // Both V1 and V2 SP_ALTPLATFORM_INFO structures share a common layout for
    // the first 6 fields (including Platform and ProcessorArchitecture, which
    // are the ones we're interested in here).  Thus, all we need to do is
    // verify that the cbSize field is one of the two valid values.
    //
    if(AlternatePlatformInfo) {

        if((AlternatePlatformInfo->cbSize != sizeof(SP_ALTPLATFORM_INFO_V2)) &&
           (AlternatePlatformInfo->cbSize != sizeof(SP_ALTPLATFORM_INFO_V1))) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    MYVERIFY(SUCCEEDED(StringCchCopy(TempInfSectionName,
                                     SIZECHARS(TempInfSectionName),
                                     InfSectionName)));

    Platform = AlternatePlatformInfo ? AlternatePlatformInfo->Platform
                                     : OSVersionInfo.dwPlatformId;

    if(Platform == VER_PLATFORM_WIN32_NT) {
        //
        // We're running on NT, so first try the NT architecture-specific
        // extension, then the generic NT extension.
        //
        if(AlternatePlatformInfo) {

            switch(AlternatePlatformInfo->ProcessorArchitecture) {

                case PROCESSOR_ARCHITECTURE_INTEL :
                    NtArchSuffix = pszNtX86Suffix;
                    NtArchSuffixSize = sizeof(pszNtX86Suffix);
                    break;

                case PROCESSOR_ARCHITECTURE_IA64 :
                    NtArchSuffix = pszNtIA64Suffix;
                    NtArchSuffixSize = sizeof(pszNtIA64Suffix);
                    break;

                case PROCESSOR_ARCHITECTURE_AMD64 :
                    NtArchSuffix = pszNtAMD64Suffix;
                    NtArchSuffixSize = sizeof(pszNtAMD64Suffix);
                    break;

                default:
                    //
                    // Unknown/invalid architecture
                    //
                    SetLastError(ERROR_INVALID_PARAMETER);
                    return FALSE;
            }

        } else {
            NtArchSuffix = pszNtPlatformSuffix;
            NtArchSuffixSize = sizeof(pszNtPlatformSuffix);
        }

        if(NtArchSuffixSize <=
               sizeof(TempInfSectionName) - (SectionNameLen * sizeof(TCHAR))) {

            MYVERIFY(SUCCEEDED(StringCchCopy(&(TempInfSectionName[SectionNameLen]),
                                             SIZECHARS(TempInfSectionName)-SectionNameLen,
                                             NtArchSuffix)));

            if(SetupGetLineCount(InfHandle, TempInfSectionName) != -1) {
                goto clean0;
            }

            //
            // We know the ".NT" suffix is always guaranteed to be shorter than
            // any of the ".NT<architecture>" suffixes, thus we know this will
            // fit in our MAX_SECT_NAME_LEN buffer.  (Note: if the OS/arch.
            // decoration is too big, then we won't even try the simple OS
            // decoration.  To do otherwise might be misleading, as we'd select
            // a "<reallylongsectionname>.NT" section, even though the INF
            // (erroneously) contains a "<reallylongsectionname>.NTx86" section
            // that doesn't fit.)
            //
            MYVERIFY(SUCCEEDED(StringCchCopy(&(TempInfSectionName[SectionNameLen]),
                                             SIZECHARS(TempInfSectionName)-SectionNameLen,
                                             pszNtSuffix)));

            if(SetupGetLineCount(InfHandle, TempInfSectionName) != -1) {
                goto clean0;
            }
        }

    } else {
        //
        // We're running on Windows 95, so try the Windows-specific extension
        //
        if(sizeof(pszWinSuffix) <=
               sizeof(TempInfSectionName) - (SectionNameLen * sizeof(TCHAR))) {

            MYVERIFY(SUCCEEDED(StringCchCopy(&(TempInfSectionName[SectionNameLen]),
                                             SIZECHARS(TempInfSectionName)-SectionNameLen,
                                             pszWinSuffix)));

            if(SetupGetLineCount(InfHandle, TempInfSectionName) != -1) {
                goto clean0;
            }
        }
    }

    //
    // If we get to here, then we found no applicable extensions.  We'll just use
    // the install section specified.
    //
    TempInfSectionName[SectionNameLen] = TEXT('\0');
    ExtFound = FALSE;

clean0:
    //
    // Now, determine whether the caller-supplied buffer is large enough to contain
    // the section name.
    //
    ExtBufferLen = lstrlen(TempInfSectionName) + 1;

    //
    // Guard the rest of the routine in try/except, since we're dealing with caller-supplied
    // memory.
    //
    try {
        if(RequiredSize) {
            *RequiredSize = ExtBufferLen;
        }
        if(InfSectionWithExt) {
            if(ExtBufferLen > InfSectionWithExtSize) {
                Err = ERROR_INSUFFICIENT_BUFFER;
            } else {
                MYVERIFY(SUCCEEDED(StringCchCopy(InfSectionWithExt,
                                                 InfSectionWithExtSize,
                                                 TempInfSectionName)));
                if(Extension) {
                    *Extension = ExtFound ? InfSectionWithExt + SectionNameLen : NULL;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
pSetupInfIsFromOemLocation(
    IN PCTSTR InfFileName,
    IN BOOL   InfDirectoryOnly
    )
/*++

Routine Description:

    This routine determines whether the specified INF came from one of the directories
    in our INF search path list.  This list can also be limited to just the %windir%\Inf
    directory.

Arguments:

    InfFileName - Supplies the fully-qualified path of the INF file.

    InfDirectoryOnly - If TRUE, then consider the INF to be from an OEM location if it is
        not in the %windir%\Inf directory (i.e., ignore any other directories in the INF
        search path).

Returns:

    If the file is from an OEM location (i.e., _not_ in our INF search path list), then
    the return value is TRUE.  Otherwise, it is FALSE.

--*/
{
    PCTSTR CharPos, DirTruncPos;
    INT DirectoryPathLen, CurSearchPathLen;

    //
    // First, retrieve just the directory path part of the specified filename.
    //
    CharPos = pSetupGetFileTitle(InfFileName);
    DirTruncPos = CharPrev(InfFileName, CharPos);

    //
    // (We know pSetupGetFileTitle will never return a pointer to a path separator character,
    // so the following check is valid.)
    //
    if(*DirTruncPos == TEXT('\\')) {
        //
        // If this is in a root directory (e.g., "A:\"), then we don't want to strip off
        // the trailing backslash.
        //
        if(((DirTruncPos - InfFileName) != 2) || (*CharNext(InfFileName) != TEXT(':'))) {
            CharPos = DirTruncPos;
        }
    }

    DirectoryPathLen = (int)(CharPos - InfFileName);

    //
    // Now, see if this directory matches any of the ones in our search path list.
    //
    if(InfDirectoryOnly) {
        CharPos = InfDirectory;
    } else {
        CharPos = InfSearchPaths;
    }

    do {
        //
        // If the current search path ends in a backslash, we want to strip it off.
        //
        CurSearchPathLen = lstrlen(CharPos);

        if((DirectoryPathLen == CurSearchPathLen) &&
           !_tcsnicmp(CharPos, InfFileName, CurSearchPathLen)) {
            //
            // We've found this directory in our list--we can return.
            //
            return FALSE;
        }

        if(InfDirectoryOnly) {
            //
            // We're only supposed to consider the %windir%\Inf directory--that failed,
            // so we're done.
            //
            break;
        } else {
            //
            // Move on to next component of INF search path.
            //
            CharPos += (CurSearchPathLen + 1);
        }

    } while(*CharPos);

    //
    // If we get to here, then we didn't find the directory in our search path list.
    // Therefore, it's from an OEM location.
    //
    return TRUE;
}

BOOL
WINAPI
SetupDiInstallDeviceInterfaces(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_INSTALLINTERFACES.

    This routine will install any device interface specified in an
    [<InstallSec>.Interfaces] section, where <InstallSec> is the install
    section name for the selected driver node, potentially decorated with
    an OS/architecture-specific extension (e.g., "InstallSec.NTAmd64.Interfaces").

    Presently, only "AddInterface" lines in this section are processed.  Their
    format is as follows:

        AddInterface = <InterfaceClassGuid> [, [<RefString>] [, [<InstallSection>] [, <Flags>]]]

    (There are currently no flags defined for the <Flags> field--must be zero.)

    If the interface class specified by <InterfaceClassGuid> is not already
    installed in the system, we will install it.  An INF can optionally specify
    installation actions to be done when this interface class is installed (just
    like it can do for class installers via a [ClassInstall32] section.  It does
    this by including an [InterfaceInstall32] section with an entry for the
    interface class to be installed.  This section name does not allow os/architecture-
    specific decoration.  Instead, the install sections referenced by lines within
    this section are processed with decoration rules.  Thus, it is possible to have
    an install entry for interface class <x> that applies to both Win9x and NT, and
    have another install entry for interface class <y> that behaves differently
    depending on whether we're running on Win9x or NT.

    The format of an entry in the [InterfaceInstall32] section is as follows:

        <InterfaceClassGuid> = <InstallSection> [, <Flags>]

    (There are currently no flags defined for the <Flags> field--must be zero.)

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a device information element whose device interfaces are to be installed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for which
        device interfaces are to be installed.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If no driver is selected (i.e., this is a null-driver installation), then
    this routine does nothing.

--*/

{
    return _SetupDiInstallDeviceInterfaces(DeviceInfoSet,
                                           DeviceInfoData,
                                           TRUE,
                                           INVALID_HANDLE_VALUE,
                                           INVALID_HANDLE_VALUE
                                          );
}


BOOL
_SetupDiInstallDeviceInterfaces(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOL             DoFullInstall,
    IN HINF             hDeviceInf,     OPTIONAL
    IN HSPFILEQ         UserFileQ       OPTIONAL
    )
/*++

Routine Description:

    Worker routine for both SetupDiInstallDeviceInterfaces and SetupDiInstallDriverFiles.

    See the description of SetupDiInstallDeviceInterfaces for more information.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a device information element whose device interfaces are to be installed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for which
        device interfaces are to be installed.

    DoFullInstall - If TRUE, then the device interfaces will be fully installed.
        Otherwise, only the required files are copied.

    hDeviceInf - Optionally, supplies a handle to the INF for which installation
        is being performed.  If this handle is not supplied, the INF specified in
        the selected driver node will be opened.  If this handle is not supplied,
        this parameter must be set to INVALID_HANDLE_VALUE.

    UserFileQ - Optionally, supplies a file queue where file operations should be added.
        If this handle is not supplied, then the queue associated with this devinfo
        element will be used (if the DI_NOVCP flag is set), or one will be automatically
        generated and committed.  If this handle is not supplied, this parameter must
        be set to INVALID_HANDLE_VALUE.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    During GUI-mode setup on Windows NT, quiet-install behavior is always
    employed in the absence of a user-supplied file queue, regardless of
    whether the device information element has the DI_QUIETINSTALL flag set.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, ScanQueueResult;
    PDEVINFO_ELEM DevInfoElem;
    HWND hwndParent;
    PTSTR szInfFileName, szInfSectionName;
    TCHAR InfSectionWithExt[MAX_SECT_NAME_LEN];
    DWORD InfSectionWithExtLength;
    INFCONTEXT DeviceInterfaceInstallLine, InterfaceClassInstallLine;
    TCHAR InterfaceGuidString[GUID_STRING_LEN];
    DWORD InstallFlags;
    GUID InterfaceGuid;
    HKEY hKeyInterfaceClass, hKeyDeviceClassesRoot, hKeyDeviceInterface;
    PINTERFACE_CLASS_TO_INSTALL InterfacesToInstall, InterfaceInstallNode, CurInterfaceInstallNode;
    DWORD RegDisposition;
    BOOL NeedToInstallInterfaceClass;
    TCHAR InterfaceInstallSection[MAX_SECT_NAME_LEN];
    BOOL DoFileCopying;
    BOOL CloseUserFileQ;
    BOOL FreeMsgHandlerContext;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL MsgHandlerIsNativeCharWidth;
    TCHAR RefString[MAX_PATH];
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    PCTSTR UndecoratedInstallSection;
    BOOL CloseInfHandle;
    PTSTR NeedsSectionList, CurInstallSection;
    BOOL b;
    INT FileQueueNeedsReboot;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    BOOL NoProgressUI;
    DWORD slot_section = 0;
    TCHAR szNewName[MAX_PATH];
    BOOL OemInfFileToCopy = FALSE;

    //
    // A device information element must be specified.
    //
    if(!DeviceInfoData) {
        Err = ERROR_INVALID_PARAMETER;
        goto clean1;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }

    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;
    hKeyDeviceClassesRoot = hKeyInterfaceClass = hKeyDeviceInterface = INVALID_HANDLE_VALUE;
    InterfacesToInstall = InterfaceInstallNode = NULL;
    CloseUserFileQ = FALSE;
    FreeMsgHandlerContext = FALSE;
    CloseInfHandle = FALSE;
    NeedsSectionList = NULL;

    try {

        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't install a non-native driver
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        //
        // set the LogContext for this function
        //
        LogContext = DevInfoElem->InstallParamBlock.LogContext;

        //
        // If there's no driver selected (i.e., this is a null driver install)
        // then there's nothing for us to do.
        //
        if(!DevInfoElem->SelectedDriver) {
            goto clean0;
        }

        //
        // Make sure we only use the devinfo element's window if it's valid.
        //
        if(hwndParent = DevInfoElem->InstallParamBlock.hwndParent) {
           if(!IsWindow(hwndParent)) {
                hwndParent = NULL;
           }
        }

        //
        // Ignore the DI_NOFILECOPY flag if we're doing a copy-only installation--that's
        // what setupx does.
        //
        if(DoFileCopying = (!(DevInfoElem->InstallParamBlock.Flags & DI_NOFILECOPY) || !DoFullInstall)) {

            if(UserFileQ == INVALID_HANDLE_VALUE) {

                if(DevInfoElem->InstallParamBlock.Flags & DI_NOVCP) {
                    //
                    // We must have a user-supplied file queue.
                    //
                    MYASSERT(DevInfoElem->InstallParamBlock.UserFileQ);
                    UserFileQ = DevInfoElem->InstallParamBlock.UserFileQ;
                } else {
                    //
                    // Create our own queue.
                    //
                    if((UserFileQ = SetupOpenFileQueue()) != INVALID_HANDLE_VALUE) {
                        CloseUserFileQ = TRUE;

                    } else {
                        //
                        // SetupOpenFileQueue sets actual error
                        //
                        Err = GetLastError();
                        goto clean0;
                    }
                }
                //
                // Maybe replace the file queue's log context with the DevInfoElem's
                //
                InheritLogContext(LogContext,
                    &((PSP_FILE_QUEUE) UserFileQ)->LogContext);

            }
        }

        szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                 DevInfoElem->SelectedDriver->InfFileName
                                                );

        szInfSectionName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                    DevInfoElem->SelectedDriver->InfSectionName
                                                   );

        if(hDeviceInf == INVALID_HANDLE_VALUE) {

            if((hDeviceInf = SetupOpenInfFile(szInfFileName,
                                              NULL,
                                              INF_STYLE_WIN4,
                                              NULL)) == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                goto clean0;
            }

            CloseInfHandle = TRUE;
        }

        //
        // Find out the 'real' install section we should be using (i.e., the potentially
        // OS/architecture-specific one.
        //
        if(!SetupDiGetActualSectionToInstall(hDeviceInf,
                                             szInfSectionName,
                                             InfSectionWithExt,
                                             SIZECHARS(InfSectionWithExt),
                                             &InfSectionWithExtLength,
                                             NULL
                                             )) {
            Err = GetLastError();
            goto clean0;
        }

        //
        // Now append the ".Interfaces" extension to the install section name to find
        // the interface install section to run.
        //
        MYVERIFY(SUCCEEDED(StringCchCopy(&(InfSectionWithExt[InfSectionWithExtLength - 1]),
                                         SIZECHARS(InfSectionWithExt)-(InfSectionWithExtLength - 1),
                                         pszInterfacesSectionSuffix)));

        if(slot_section == 0) {
            //
            // we haven't done anything about logging section yet...
            //
            slot_section = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_VERBOSE,FALSE);
            //
            // Say what section is about to be installed.
            //
            WriteLogEntry(LogContext,
                slot_section,
                MSG_LOG_INSTALLING_SECTION_FROM,
                NULL,
                InfSectionWithExt,
                szInfFileName);
        }

        //
        // Append the layout INF, if necessary.
        //
        if(DoFileCopying) {
            SetupOpenAppendInfFile(NULL, hDeviceInf, NULL);
        }

        //
        // Append-load any included INFs specified in an "include=" line in our
        // install section.
        //
        AppendLoadIncludedInfs(hDeviceInf, szInfFileName, InfSectionWithExt, DoFileCopying);

        NeedsSectionList = GetMultiSzFromInf(hDeviceInf, InfSectionWithExt, TEXT("needs"), &b);

        if(!NeedsSectionList && b) {
            //
            // Out of memory!
            //
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Process the "AddInterface" lines in this section, as well as those contained with any
        // sections referenced in the "needs=" entry in this section.
        //
        for(CurInstallSection = InfSectionWithExt;
            (CurInstallSection && *CurInstallSection);
            CurInstallSection = (CurInstallSection == InfSectionWithExt)
                                ? NeedsSectionList
                                : (CurInstallSection + lstrlen(CurInstallSection) + 1))
        {
            if(SetupFindFirstLine(hDeviceInf, CurInstallSection, pszAddInterface, &DeviceInterfaceInstallLine)) {

                do {
                    //
                    // Retrieve the interface class GUID for this device interface.
                    //
                    if(!SetupGetStringField(&DeviceInterfaceInstallLine,
                                            1,
                                            InterfaceGuidString,
                                            SIZECHARS(InterfaceGuidString),
                                            NULL))
                    {
                        Err = ERROR_BAD_INTERFACE_INSTALLSECT;
                        goto clean0;
                    }

                    if(NO_ERROR != pSetupGuidFromString(InterfaceGuidString, &InterfaceGuid)) {
                        Err = ERROR_BAD_INTERFACE_INSTALLSECT;
                        goto clean0;
                    }

                    //
                    // Next, we need to check and see if the specified interface class is already present.
                    // If not, we'll need to install it, too.
                    //
                    NeedToInstallInterfaceClass = FALSE;

                    hKeyInterfaceClass = SetupDiOpenClassRegKeyEx(&InterfaceGuid,
                                                                  KEY_READ,
                                                                  DIOCR_INTERFACE,
                                                                  NULL,
                                                                  NULL
                                                                 );

                    if(hKeyInterfaceClass != INVALID_HANDLE_VALUE) {
                        //
                        // OK, this interface class already exists.  We don't need to install it.
                        //
                        RegCloseKey(hKeyInterfaceClass);
                        hKeyInterfaceClass = INVALID_HANDLE_VALUE;

                    } else {
                        //
                        // This interface class isn't currently installed.  Check to see if we've
                        // already encountered this class (and added it to our list of interface
                        // classes to install).
                        //
                        for(CurInterfaceInstallNode = InterfacesToInstall;
                            CurInterfaceInstallNode;
                            CurInterfaceInstallNode = CurInterfaceInstallNode->Next)
                        {
                            if(IsEqualGUID(&InterfaceGuid, &(CurInterfaceInstallNode->InterfaceGuid))) {
                                //
                                // The installation of this interface class is already in our
                                // 'to do' list.
                                //
                                break;
                            }
                        }

                        if(!CurInterfaceInstallNode) {
                            NeedToInstallInterfaceClass = TRUE;
                        }
                    }

                    if(NeedToInstallInterfaceClass) {
                        //
                        // Look for this interface class GUID in the INF's [InterfaceInstall32] section
                        // (if present).
                        //
                        if(SetupFindFirstLine(hDeviceInf,
                                              pszInterfaceInstall32,
                                              InterfaceGuidString,
                                              &InterfaceClassInstallLine)) {
                            //
                            // Get the name of the install section for this interface class.
                            //
                            if((UndecoratedInstallSection = pSetupGetField(&InterfaceClassInstallLine, 1))
                               && !(*UndecoratedInstallSection))
                            {
                                UndecoratedInstallSection = NULL;
                            }

                            if(!UndecoratedInstallSection) {
                                *InterfaceInstallSection = TEXT('\0');
                            } else {
                                //
                                // Get the (potentially) os/architecture-specific install section.
                                //
                                PTSTR SectionExtension;

                                if(!SetupDiGetActualSectionToInstall(hDeviceInf,
                                                                 UndecoratedInstallSection,
                                                                 InterfaceInstallSection,
                                                                 SIZECHARS(InterfaceInstallSection),
                                                                 NULL,
                                                                 &SectionExtension
                                                                 )) {
                                    Err = GetLastError();
                                    goto clean0;
                                }
                                //
                                // If this is the undecorated name, then make sure that the section actually exists.
                                //
                                if(!SectionExtension && (SetupGetLineCount(hDeviceInf, InterfaceInstallSection) == -1)) {
                                    WriteLogEntry(LogContext,
                                        DRIVER_LOG_ERROR,
                                        MSG_LOG_NOSECTION,
                                        NULL,
                                        InterfaceInstallSection);
                                    Err = ERROR_SECTION_NOT_FOUND;
                                    goto clean0;
                                }
                            }

                            if(!SetupGetIntField(&InterfaceClassInstallLine, 2, (PINT)&InstallFlags)) {
                                InstallFlags = 0;
                            }

                        } else {
                            *InterfaceInstallSection = TEXT('\0');
                            InstallFlags = 0;
                        }

                        //
                        // At this point, we just want to queue up any file operations required.
                        //
                        if(DoFileCopying && *InterfaceInstallSection) {

                            Err = pSetupInstallFiles(hDeviceInf,
                                                     NULL,
                                                     InterfaceInstallSection,
                                                     NULL,
                                                     NULL,
                                                     NULL,
                                                     SP_COPY_NEWER_OR_SAME | SP_COPY_LANGUAGEAWARE |
                                                         ((DevInfoElem->InstallParamBlock.Flags & DI_NOBROWSE) ? SP_COPY_NOBROWSE : 0),
                                                     NULL,
                                                     UserFileQ,
                                                     TRUE
                                                    );

                            if(Err != NO_ERROR) {
                                goto clean0;
                            }
                        }

                        //
                        // Now add a node onto our 'to do' list of interface classes to install.
                        //
                        if(InterfaceInstallNode = MyMalloc(sizeof(INTERFACE_CLASS_TO_INSTALL))) {

                            InterfaceInstallNode->InterfaceGuid = InterfaceGuid;

                            MYVERIFY(SUCCEEDED(StringCchCopy(InterfaceInstallNode->InstallSection,
                                                             SIZECHARS(InterfaceInstallNode->InstallSection),
                                                             InterfaceInstallSection)));

                            InterfaceInstallNode->Flags = InstallFlags;

                            InterfaceInstallNode->Next = InterfacesToInstall;
                            InterfacesToInstall = InterfaceInstallNode;

                            //
                            // Now set newly allocated node pointer to NULL, so we won't try
                            // to free it if we hit an exception.
                            //
                            InterfaceInstallNode = NULL;

                        } else {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                            goto clean0;
                        }
                    }

                    //
                    // Now queue up any file operations for this particular device interface.
                    //
                    if(DoFileCopying
                       && SetupGetStringField(&DeviceInterfaceInstallLine,
                                           3,
                                           InterfaceInstallSection,
                                           SIZECHARS(InterfaceInstallSection),
                                           NULL)
                       && *InterfaceInstallSection)
                    {
                        Err = pSetupInstallFiles(hDeviceInf,
                                                 NULL,
                                                 InterfaceInstallSection,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 SP_COPY_NEWER_OR_SAME | SP_COPY_LANGUAGEAWARE |
                                                     ((DevInfoElem->InstallParamBlock.Flags & DI_NOBROWSE)? SP_COPY_NOBROWSE : 0),
                                                 NULL,
                                                 UserFileQ,
                                                 TRUE
                                                );

                        if(Err != NO_ERROR) {
                            goto clean0;
                        }
                    }

                } while(SetupFindNextMatchLine(&DeviceInterfaceInstallLine, pszAddInterface, &DeviceInterfaceInstallLine));
            }
        }

        //
        // Mark the queue as a device install queue (and make sure there's a
        // catalog node representing our device INF in the queue).
        //
        if(DoFileCopying) {
            MYASSERT(UserFileQ && (UserFileQ != INVALID_HANDLE_VALUE));
            Err = MarkQueueForDeviceInstall(UserFileQ,
                                            hDeviceInf,
                                            pStringTableStringFromId(
                                                pDeviceInfoSet->StringTable,
                                                DevInfoElem->SelectedDriver->DrvDescription)
                                           );
        }

        //
        // At this point, we have queued up all the files that need to be
        // copied.  If we weren't given a user-supplied queue, then commit our
        // queue now.
        //
        if(CloseUserFileQ) {

            if(Err == NO_ERROR) {
                //
                // Determine whether the queue actually needs to be committed.
                //
                // ScanQueueResult can have 1 of 3 values:
                //
                // 0: Some files were missing--must commit queue.
                //
                // 1: All files to be copied are already present and valid,
                //    and the queue is empty--skip committing queue.
                //
                // 2: All files to be copied are present/valid, but
                //    del/ren/backup queues not empty--must commit queue.
                //    The copy queue will have been emptied, so only
                //    del/ren/backup functions will be performed.
                //
                // (jamiehun) see previous case of SetupScanFileQueue for a
                // discussion of DI_FLAGSEX_PREINSTALLBACKUP handling.
                //
                if(!SetupScanFileQueue(UserFileQ,
                                       SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                                       hwndParent,
                                       NULL,
                                       NULL,
                                       &ScanQueueResult)) {
                    //
                    // SetupScanFileQueue should really never fail when you
                    // don't ask it to call a callback routine, but if it does,
                    // just go ahead and commit the queue.
                    //
                    ScanQueueResult = 0;
                }
            }

            if((Err == NO_ERROR) && (ScanQueueResult != 1)) {
                //
                // We need to commit this file queue.  Figure out what message
                // handler to use.
                //
                if(DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                    MsgHandler = DevInfoElem->InstallParamBlock.InstallMsgHandler;
                    MsgHandlerContext = DevInfoElem->InstallParamBlock.InstallMsgHandlerContext;
                    MsgHandlerIsNativeCharWidth = DevInfoElem->InstallParamBlock.InstallMsgHandlerIsNativeCharWidth;
                } else {

                    NoProgressUI = (GuiSetupInProgress || (DevInfoElem->InstallParamBlock.Flags & DI_QUIETINSTALL));

                    if(MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                              hwndParent,
                                              (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                                              0,
                                              0,
                                              NULL))
                    {
                        FreeMsgHandlerContext = TRUE;
                        MsgHandler = SetupDefaultQueueCallback;
                        MsgHandlerIsNativeCharWidth = TRUE;
                    } else {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                //
                // Copy enqueued files.
                //
                if(Err == NO_ERROR) {

                    //
                    // Call _SetupVerifyQueuedCatalogs separately (i.e., don't
                    // let it happen automatically as a result of committing
                    // the queue that happens below).  We do this beforehand so
                    // that we know what unique name was generated when an OEM
                    // INF was installed into %windir%\Inf (in case we need to
                    // delete the INF/PNF/CAT files later if we encounter an
                    // error).
                    //
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_BEGIN_INTFC_VERIFY_CAT_TIME,
                        NULL);       // text message

                    Err = _SetupVerifyQueuedCatalogs(
                              hwndParent,
                              UserFileQ,
                              (VERCAT_INSTALL_INF_AND_CAT |
                               ((DevInfoElem->SelectedDriver->Flags & DNF_INET_DRIVER)
                                    ? VERCAT_PRIMARY_DEVICE_INF_FROM_INET : 0)),
                              szNewName,
                              &OemInfFileToCopy
                             );

                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_END_INTFC_VERIFY_CAT_TIME,
                        NULL);       // text message

                    if(Err == NO_ERROR) {

                        if(_SetupCommitFileQueue(hwndParent,
                                                 UserFileQ,
                                                 MsgHandler,
                                                 MsgHandlerContext,
                                                 MsgHandlerIsNativeCharWidth
                                                 )) {
                            //
                            // Check to see whether a reboot is required as a
                            // result of committing the queue (i.e., because files
                            // were in use, or the INF requested a reboot).
                            //
                            FileQueueNeedsReboot = SetupPromptReboot(UserFileQ, NULL, TRUE);
                            //
                            // This should never fail...
                            //
                            MYASSERT(FileQueueNeedsReboot != -1);

                            if(FileQueueNeedsReboot) {
                                SetDevnodeNeedsRebootProblem(DevInfoElem, pDeviceInfoSet,
                                                             MSG_LOG_REBOOT_REASON_INUSE);
                            }

                        } else {
                            Err = GetLastError();
                        }
                    }
                }
            }

            //
            // Close our file queue handle.
            //
            SetupCloseFileQueue(UserFileQ);
            CloseUserFileQ = FALSE;

            //
            // Terminate the default queue callback, if it was created.
            //
            if(FreeMsgHandlerContext) {
                SetupTermDefaultQueueCallback(MsgHandlerContext);
                FreeMsgHandlerContext = FALSE;
            }

            if(Err != NO_ERROR) {
                goto clean0;
            }
        }

        //
        // If all we were asked to do was copy files, then we're done.
        //
        if(!DoFullInstall) {
            goto clean0;
        }

        //
        // Now go through our list of interface classes to install, and install
        // each one.
        //
        if(CurInterfaceInstallNode = InterfacesToInstall) {
            //
            // Open a handle to the root of the DeviceClasses registry branch.
            //
            hKeyDeviceClassesRoot = SetupDiOpenClassRegKeyEx(NULL,
                                                             KEY_ALL_ACCESS,
                                                             DIOCR_INTERFACE,
                                                             NULL,
                                                             NULL
                                                            );

            if(hKeyDeviceClassesRoot == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                goto clean0;
            }

            do {
                //
                // Presently, the flags field, if present, must be zero.
                //
                if(CurInterfaceInstallNode->Flags) {
                    Err = ERROR_INVALID_FLAGS;
                    goto clean0;
                }

                pSetupStringFromGuid(&(CurInterfaceInstallNode->InterfaceGuid),
                                     InterfaceGuidString,
                                     SIZECHARS(InterfaceGuidString)
                                    );

                Err = RegCreateKeyEx(hKeyDeviceClassesRoot,
                                     InterfaceGuidString,
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &hKeyInterfaceClass,
                                     &RegDisposition
                                    );

                if(Err != ERROR_SUCCESS) {
                    //
                    // Ensure that the registry handle is still invalid, so we won't try
                    // to close it.
                    //
                    hKeyInterfaceClass = INVALID_HANDLE_VALUE;
                    goto clean0;
                }

                //
                // Now run the INF section for this newly-created key.
                //
                if(!SetupInstallFromInfSection(NULL,
                                               hDeviceInf,
                                               CurInterfaceInstallNode->InstallSection,
                                               SPINST_INIFILES
                                               | SPINST_REGISTRY
                                               | SPINST_INI2REG
                                               | SPINST_BITREG
                                               | SPINST_REGSVR
                                               | SPINST_UNREGSVR
                                               | SPINST_PROFILEITEMS,
                                               hKeyInterfaceClass,
                                               NULL,
                                               0,
                                               NULL,
                                               NULL,
                                               INVALID_HANDLE_VALUE,
                                               NULL))
                {
                    Err = GetLastError();
                    //
                    // Normally, we would want to clean up this newly-created key.
                    // However, the kernel-mode IoRegisterDeviceClassAssociation API
                    // will quite happily create the class key if it doesn't exist.
                    // Thus, a driver might have registered a device while we were
                    // trying to run the INF, and if we deleted the key that might
                    // really mess things up.  Thus, we'll leave this alone.  Since
                    // we should never see a failure with this call, this isn't a big
                    // deal anyway.
                    //
                }

                RegCloseKey(hKeyInterfaceClass);
                hKeyInterfaceClass = INVALID_HANDLE_VALUE;

                if(Err != NO_ERROR) {
                    goto clean0;
                }

                CurInterfaceInstallNode = CurInterfaceInstallNode->Next;

            } while(CurInterfaceInstallNode);
        }

        //
        // At this point, we've done everything except for actually registering the
        // device interfaces and (potentially) running INFs against their registry keys.
        // Do that now...
        //
        DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        for(CurInstallSection = InfSectionWithExt;
            (CurInstallSection && *CurInstallSection);
            CurInstallSection = (CurInstallSection == InfSectionWithExt)
                                ? NeedsSectionList
                                : (CurInstallSection + lstrlen(CurInstallSection) + 1))
        {
            if(SetupFindFirstLine(hDeviceInf, CurInstallSection, pszAddInterface, &DeviceInterfaceInstallLine)) {

                do {
                    //
                    // Retrieve the interface class GUID for this device interface.  (There's
                    // no need to check the return status of these two calls, since we've already
                    // done this once, and they were fine.
                    //
                    SetupGetStringField(&DeviceInterfaceInstallLine,
                                        1,
                                        InterfaceGuidString,
                                        SIZECHARS(InterfaceGuidString),
                                        NULL
                                       );
                    pSetupGuidFromString(InterfaceGuidString, &InterfaceGuid);

                    if(!SetupGetStringField(&DeviceInterfaceInstallLine,
                                            2,
                                            RefString,
                                            SIZECHARS(RefString),
                                            NULL))
                    {
                        *RefString = TEXT('\0');
                    }

                    if(!SetupGetStringField(&DeviceInterfaceInstallLine,
                                            3,
                                            InterfaceInstallSection,
                                            SIZECHARS(InterfaceInstallSection),
                                            NULL))
                    {
                        *InterfaceInstallSection = TEXT('\0');
                    }

                    if(!SetupGetIntField(&DeviceInterfaceInstallLine, 4, (PINT)&InstallFlags)) {
                        InstallFlags = 0;
                    }

                    //
                    // (Presently, no flags are defined--field, if present, must be zero.
                    //
                    if(InstallFlags) {
                        Err = ERROR_INVALID_FLAGS;
                        goto clean0;
                    }

                    //
                    // OK, we have all the information we need to create this device interface.
                    //
                    if(!SetupDiCreateDeviceInterface(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     &InterfaceGuid,
                                                     (*RefString) ? RefString : NULL,
                                                     0,
                                                     &DeviceInterfaceData)) {
                        Err = GetLastError();
                        goto clean0;
                    }

                    if(*InterfaceInstallSection) {
                        //
                        // Run the INF against this device interface's registry key.
                        //
                        hKeyDeviceInterface = SetupDiCreateDeviceInterfaceRegKey(DeviceInfoSet,
                                                                                 &DeviceInterfaceData,
                                                                                 0,
                                                                                 KEY_ALL_ACCESS,
                                                                                 INVALID_HANDLE_VALUE,
                                                                                 NULL
                                                                                );

                        if(hKeyDeviceInterface == INVALID_HANDLE_VALUE) {
                            Err = GetLastError();
                            goto clean0;
                        }

                        //
                        // Now run the INF section for this newly-created key.
                        //
                        if(!SetupInstallFromInfSection(NULL,
                                                       hDeviceInf,
                                                       InterfaceInstallSection,
                                                       SPINST_INIFILES
                                                       | SPINST_REGISTRY
                                                       | SPINST_INI2REG
                                                       | SPINST_BITREG
                                                       | SPINST_REGSVR
                                                       | SPINST_UNREGSVR
                                                       | SPINST_PROFILEITEMS,
                                                       hKeyDeviceInterface,
                                                       NULL,
                                                       0,
                                                       NULL,
                                                       NULL,
                                                       INVALID_HANDLE_VALUE,
                                                       NULL))
                        {
                            Err = GetLastError();
                        }

                        RegCloseKey(hKeyDeviceInterface);
                        hKeyDeviceInterface = INVALID_HANDLE_VALUE;

                        if(Err != NO_ERROR) {
                            goto clean0;
                        }
                    }

                } while(SetupFindNextMatchLine(&DeviceInterfaceInstallLine, pszAddInterface, &DeviceInterfaceInstallLine));
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(hKeyInterfaceClass != INVALID_HANDLE_VALUE) {
            RegCloseKey(hKeyInterfaceClass);
        }

        if(hKeyDeviceInterface != INVALID_HANDLE_VALUE) {
            RegCloseKey(hKeyDeviceInterface);
        }

        if(InterfaceInstallNode) {
            MyFree(InterfaceInstallNode);
        }

        if(FreeMsgHandlerContext) {
            SetupTermDefaultQueueCallback(MsgHandlerContext);
        }
        if(CloseUserFileQ) {
            SetupCloseFileQueue(UserFileQ);
        }

        //
        // Reference the following variables so the compiler will respect statement
        // ordering w.r.t. assignment.
        //
        InterfacesToInstall = InterfacesToInstall;
        CloseInfHandle = CloseInfHandle;
        NeedsSectionList = NeedsSectionList;
        OemInfFileToCopy = OemInfFileToCopy;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    for(CurInterfaceInstallNode = InterfacesToInstall;
        CurInterfaceInstallNode;
        CurInterfaceInstallNode = InterfacesToInstall) {

        InterfacesToInstall = CurInterfaceInstallNode->Next;
        MyFree(CurInterfaceInstallNode);
    }

    if(hKeyDeviceClassesRoot != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyDeviceClassesRoot);
    }

    if(CloseInfHandle) {
        MYASSERT(hDeviceInf != INVALID_HANDLE_VALUE);
        SetupCloseInfFile(hDeviceInf);
    }

    if(NeedsSectionList) {
        MyFree(NeedsSectionList);
    }

clean1:
    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of Success
        //
        WriteLogEntry(
            LogContext,
            DoFullInstall ? DRIVER_LOG_INFO : DRIVER_LOG_VERBOSE,
            MSG_LOG_INSTALLEDINTERFACES,
            NULL);
    } else {
        //
        // indicate failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_INSTALLINTERFACES_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);

        //
        // If we copied the OEM INF into the INF directory under a newly-
        // generated name, delete it now.
        //
        if(OemInfFileToCopy) {
            pSetupUninstallOEMInf(szNewName, LogContext, SUOI_FORCEDELETE, NULL);
        }
    }

    if (slot_section) {
        ReleaseLogInfoSlot(LogContext,slot_section);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}

BOOL
pSetupGetSourceMediaTypeFromPnf(
    PCTSTR InfName,
    PDWORD SourceMediaType
    )

/*++

Routine Description:

    This function will get the Source Media Type from the PNF for a given INF
    file.  If the INF does not have a PNF file then the API will fail.

Arguments:

    InfFileName - Supplies the full path of the INF that we will get the source
        media type from it's PNF.


    SourceMediaType - Supplies a pointer that will be filled in the the source
        media type from the PNF.

Return Value:

    TRUE if the INF has a PNF and we are able to get a valid source media type
    FALSE if their is no PNF for this INF.

Remarks:


--*/

{
    PLOADED_INF Inf;
    BOOL PnfWasUsed;
    WIN32_FIND_DATA  InfFileData;
    UINT ErrorLineNumber;
    BOOL bReturn = FALSE;

    if (FileExists(InfName, &InfFileData)) {

        if(LoadInfFile(InfName,
                   &InfFileData,
                   INF_STYLE_WIN4,
                   LDINF_FLAG_IGNORE_VOLATILE_DIRIDS,
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   &Inf,
                   &ErrorLineNumber,
                   &PnfWasUsed) == NO_ERROR) {

            if (PnfWasUsed) {

                //
                // We were able to open the INF with a PNF.  Now get the
                // InfSourceMediaType.
                //
                LockInf(Inf);
                *SourceMediaType = Inf->InfSourceMediaType;
                UnlockInf(Inf);

                bReturn = TRUE;
            }

            FreeInfFile(Inf);
        }
    }

    return bReturn;
}

//
// ANSI version
//
BOOL
WINAPI
SetupCopyOEMInfA(
    IN  PCSTR   SourceInfFileName,
    IN  PCSTR   OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PSTR    DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PSTR   *DestinationInfFileNameComponent OPTIONAL
    )
{
    PWSTR UnicodeSourceInfFileName, UnicodeOEMSourceMediaLocation, UnicodeFileNameComponent;
    WCHAR UnicodeDestinationInfFileName[MAX_PATH];
    PSTR AnsiDestinationInfFileName;
    DWORD AnsiRequiredSize;
    DWORD rc;
    DWORD CharOffset, i;
    PSTR p;
    WCHAR SourceInfCatalogName[MAX_PATH];
    WCHAR CatalogFilenameOnSystem[MAX_PATH];
    BOOL DifferentOriginalName;
    TCHAR OriginalInfName[MAX_PATH];
    HINF hInf;
    DWORD CodeSigningPolicy;
    BOOL UseOriginalInfName;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;

    rc = pSetupCaptureAndConvertAnsiArg(SourceInfFileName,
                                        &UnicodeSourceInfFileName
                                       );
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }

    //
    // Open the specified INF.
    //
    hInf = SetupOpenInfFile(UnicodeSourceInfFileName,
                            NULL,
                            INF_STYLE_OLDNT | INF_STYLE_WIN4,
                            NULL
                           );

    if(hInf == INVALID_HANDLE_VALUE) {
        rc = GetLastError();
        MyFree(UnicodeSourceInfFileName);
        SetLastError(rc);
        return FALSE;
    }

    ValidationPlatform = NULL;

    //
    // GetCodeSigningPolicyForInf() presently can generate an unhandled
    // exception, so guard the code below in try/except to protect ourselves...
    //
    try {

        if(NO_ERROR != InheritLogContext(((PLOADED_INF)hInf)->LogContext,
                                         &LogContext)) {
            LogContext = NULL;
        }

        //
        // Retrieve the CatalogFile entry (if present) from this INF's version
        // section.
        //
        rc = pGetInfOriginalNameAndCatalogFile(
                 (PLOADED_INF)hInf,
                 NULL,
                 &DifferentOriginalName,
                 OriginalInfName,
                 SIZECHARS(OriginalInfName),
                 SourceInfCatalogName,
                 SIZECHARS(SourceInfCatalogName),
                 NULL // always native OS/arch (ver doesn't matter for CatalogFile=)
                );

        if(rc == NO_ERROR) {
            CodeSigningPolicy = GetCodeSigningPolicyForInf(LogContext,
                                                           hInf,
                                                           &ValidationPlatform,
                                                           &UseOriginalInfName
                                                          );

            if(UseOriginalInfName) {
                //
                // If we're looking at an exception INF, make sure it's under its
                // original name.
                //
                if(DifferentOriginalName) {
                    rc = ERROR_INVALID_CLASS;
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume
        // an inpage error when dealing with a mapped-in file (e.g., in the
        // call to GetCodeSigningPolicyForInf).
        //
        rc = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
    }

    //
    // We're done with the INF handle
    //
    SetupCloseInfFile(hInf);

    if(rc == NO_ERROR) {
        if(OEMSourceMediaLocation) {
            rc = pSetupCaptureAndConvertAnsiArg(OEMSourceMediaLocation,
                                                &UnicodeOEMSourceMediaLocation
                                               );
        } else {
            UnicodeOEMSourceMediaLocation = NULL;
        }
    }

    if(rc != NO_ERROR) {
        MyFree(UnicodeSourceInfFileName);
        if(ValidationPlatform) {
            MyFree(ValidationPlatform);
        }
        SetLastError(rc);
        return FALSE;
    }

    rc = GLE_FN_CALL(FALSE,
                     _SetupCopyOEMInf(
                         UnicodeSourceInfFileName,
                         UnicodeOEMSourceMediaLocation,
                         OEMSourceMediaType,
                         CopyStyle,
                         UnicodeDestinationInfFileName,
                         SIZECHARS(UnicodeDestinationInfFileName),
                         NULL,
                         &UnicodeFileNameComponent,
                         (DifferentOriginalName ? OriginalInfName
                                                : pSetupGetFileTitle(UnicodeSourceInfFileName)),
                         (*SourceInfCatalogName ? SourceInfCatalogName : NULL),
                         NULL,  // no HWND for UI!
                         NULL,
                         CodeSigningPolicy,
                         SCOI_NO_ERRLOG_IF_INF_ALREADY_PRESENT |
                          (UseOriginalInfName ? SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES : 0),
                         NULL,
                         ValidationPlatform,
                         NULL,
                         CatalogFilenameOnSystem,
                         LogContext, // either made-up or thread log context
                         NULL,
                         NULL)
                    );

    if((rc == NO_ERROR) || (rc == ERROR_FILE_EXISTS)) {

        if(DestinationInfFileName || RequiredSize) {

            if(AnsiDestinationInfFileName = pSetupUnicodeToAnsi(UnicodeDestinationInfFileName)) {

                AnsiRequiredSize = lstrlenA(AnsiDestinationInfFileName) + 1;

                if(RequiredSize) {
                    try {
                        *RequiredSize = AnsiRequiredSize;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        rc = ERROR_INVALID_PARAMETER;
                    }
                }

                if(((rc == NO_ERROR) || (rc == ERROR_FILE_EXISTS))
                   && DestinationInfFileName) {

                    if(AnsiRequiredSize <= DestinationInfFileNameSize) {

                        if(FAILED(StringCchCopyA(DestinationInfFileName,
                                                 DestinationInfFileNameSize,
                                                 AnsiDestinationInfFileName))) {

                            rc = ERROR_INVALID_PARAMETER;

                        } else if(DestinationInfFileNameComponent) {
                            //
                            // We need to figure out where the extension is
                            // in the converted string. To be DBCS safe we will
                            // count characters forward to find it.
                            //
                            CharOffset = (DWORD)(UnicodeFileNameComponent - UnicodeDestinationInfFileName);
                            p = DestinationInfFileName;
                            for(i = 0; i < CharOffset; i++) {
                                p = CharNextA(p);
                            }

                            try {
                                *DestinationInfFileNameComponent = p;
                            } except(EXCEPTION_EXECUTE_HANDLER) {
                                rc = ERROR_INVALID_PARAMETER;
                            }
                        }

                    } else {
                        rc = ERROR_INSUFFICIENT_BUFFER;
                    }
                }

                MyFree(AnsiDestinationInfFileName);

            } else {
                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {
            //
            // It would be dumb to request the filename part of the destination
            // INF path when the path itself wasn't requested, but let's make
            // sure we set this to NULL if that happens.
            //
            if(DestinationInfFileNameComponent) {
                try {
                    *DestinationInfFileNameComponent = NULL;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    rc = ERROR_INVALID_PARAMETER;
                }
            }
        }
    }

    MyFree(UnicodeSourceInfFileName);
    if(UnicodeOEMSourceMediaLocation) {
        MyFree(UnicodeOEMSourceMediaLocation);
    }
    if(ValidationPlatform) {
        MyFree(ValidationPlatform);
    }
    DeleteLogContext(LogContext);

    SetLastError(rc);
    return (rc == NO_ERROR);
}


BOOL
WINAPI
SetupCopyOEMInf(
    IN  PCTSTR  SourceInfFileName,
    IN  PCTSTR  OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PTSTR   DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PTSTR  *DestinationInfFileNameComponent OPTIONAL
    )
/*++

Routine Description:

    This API copies an INF into %windir%\Inf, giving it a unique name if it
    doesn't already exist there.  We determine whether the INF already exists
    in the INF directory as follows:

    1.  All INFs of the form "OEM*.INF" are enumerated, and any that have the
        same file size as that of our INF are binary-compared with it.

    2.  We also look for the INF using its source filename.  If a file of the
        same name exists, and is the same size as that of our INF, we
        binary-compare the two to see if they are identical.

    If the INF already exists (by either of the two criteria described above),
    then we will further check to see if the INF specifies a CatalogFile= entry
    in its version section.  If so, we will see if that catalog is already
    installed (using the INF's %windir%\Inf primary filename with a ".CAT"
    extension).  If there is a catalog installed, but it isn't the same as the
    catalog associated with the source INF, then we won't consider that INF to
    be a match, and we'll keep enumerating looking for a match.  This means
    it's possible to have multiple identical INFs contained in %windir%\Inf,
    each having its own unique catalog.  (In general, this shouldn't happen,
    since driver package updates should also update the DriverVer information
    in the INF, thus you wouldn't get identical INFs in the first place.)  If
    we don't find an existing match (i.e., both INF and CAT), then we'll
    install the INF and CAT under a new, unique name.

    OEM INFs that don't specify a CatalogFile= entry are considered invalid
    w.r.t. digital signature verification.

    In cases where the INF must be copied to %windir%\Inf (i.e., it wasn't
    already there), we'll report any digital signature verification failures
    (based on applicable policy).

    If we decide that the INF/CAT files already exist, then we will use that
    name, and our replacement behavior is based on the caller-specified
    CopyStyle flags.  (NOTE: Replacement behavior here refers solely to the
    source media information stored in the PNF.  We will not blow away existing
    INFs/PNFs/CATs under any circumstances.)

Arguments:

    SourceInfFileName - Specifies the full path to the INF to be copied.

    OEMSourceMediaLocation - Specifies source location information to be stored
        in the precompiled INF (.PNF), thus allowing the system to go to the
        correct location for files when installing from this INF.  This location
        information is specific to the source media type specified.

    OEMSourceMediaType - Specifies the type of source media that the location
        information references.  May be one of the following values:

        SPOST_NONE - No source media information should be stored in the PNF
                     file.  (OEMSourceMediaLocation is ignored in this case.)

        SPOST_PATH - OEMSourceMediaLocation contains a path to the source media.
                     For example, if the media is on a floppy, this path might
                     be "A:\". If OEMSourceMediaLocation is NULL, then the path
                     is assumed to be the path where the INF is located (unless
                     the INF has a corresponding PNF in that location, in which
                     case that PNF's source media information will be
                     transferred to the destination PNF).

        SPOST_URL  - OEMSourceMediaLocation contains a URL indicating the
                     internet location where the INF/driver files were retrieved
                     from.  If OEMSourceMediaLocation is NULL, then it is
                     assumed that the default Code Download Manager location was
                     used.

    CopyStyle - Specifies flags that control how the INF is copied into the INF
        directory.  May be a combination of the following flags (all other
        SP_COPY_* flags are ignored).

        SP_COPY_DELETESOURCE - Delete source file on successful copy.

        SP_COPY_REPLACEONLY  - Copy only if this file already exists in the INF
                               directory.  This could be used to update the
                               source location information for an existing INF.

        SP_COPY_NOOVERWRITE  - Copy only if this files doesn't already exist in
                               the INF directory.  If the INF _does_ already
                               exist, this API will fail with GetLastError
                               returning ERROR_FILE_EXISTS.  In this case, the
                               destination INF file information output buffers
                               will be filled in for the existing INF's filename.

        SP_COPY_OEMINF_CATALOG_ONLY - Don't copy the INF into %windir%\Inf--just
                                      install its corresponding catalog file.
                                      If this flag is specified, then the
                                      destination filename information will only
                                      be filled out upon successful return if
                                      the INF is already in the Inf directory.

        SP_COPY_OEM_F6_INF - The Inf was installed by the user during textmode
                             setup using F6.

    DestinationInfFileName - Optionally, supplies a character buffer that
        receives the name that the INF was assigned when it was copied into the
        INF directory.  If the SP_COPY_NOOVERWRITE flag is specified, and the
        API fails with ERROR_FILE_EXISTS, then this buffer will contain the name
        of the existing INF.

        If the SP_COPY_OEMINF_CATALOG_ONLY flag was specified, then this buffer
        will only be filled in with a destination INF filename if the INF is
        already in the INF directory.  Otherwise, this buffer will be set to the
        empty string.

    DestinationInfFileNameSize - Specifies the size, in characters, of the
        DestinationInfFileName buffer, or zero if the buffer is not specified.
        If DestinationInfFileName is specified, and this buffer size is less
        than the size required to return the destination INF name (including
        full path), then this API will fail, and GetLastError will return
        ERROR_INSUFFICIENT_BUFFER.

    RequiredSize - Optionally, supplies the address of a variable that receives
        the size (in characters) required to store the destination INF file name
        (including terminating NULL.

        If the SP_COPY_OEMINF_CATALOG_ONLY flag was specified, then this
        variable will only receive a string length if the INF is already in the
        INF directory.  Otherwise, this variable will be set to zero.

    DestinationInfFileNameComponent - Optionally, supplies the address of a
        character pointer that is set, upon successful return (or
        ERROR_FILE_EXISTS), to point to the beginning of the filename component
        of the path stored in DestinationInfFileName.

        If the SP_COPY_OEMINF_CATALOG_ONLY flag was specified, then the
        DestinationInfFileName may be an empty string (see above).  In that case
        this character pointer will be set to NULL upon successful return.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    TCHAR SourceInfCatalogName[MAX_PATH];
    TCHAR CatalogFilenameOnSystem[MAX_PATH];
    DWORD rc;
    BOOL DifferentOriginalName;
    TCHAR OriginalInfName[MAX_PATH];
    HINF hInf;
    DWORD CodeSigningPolicy;
    BOOL UseOriginalInfName;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;

    //
    // Open the specified INF.
    //
    hInf = SetupOpenInfFile(SourceInfFileName,
                            NULL,
                            INF_STYLE_OLDNT | INF_STYLE_WIN4,
                            NULL
                           );

    if(hInf == INVALID_HANDLE_VALUE) {
        //
        // last error already set.
        //
        return FALSE;
    }

    ValidationPlatform = NULL;

    //
    // GetCodeSigningPolicyForInf() presently can generate an unhandled
    // exception, so guard the code below in try/except to protect ourselves...
    //
    try {

        if(NO_ERROR != InheritLogContext(((PLOADED_INF)hInf)->LogContext,
                                         &LogContext)) {
            LogContext = NULL;
        }

        //
        // Retrieve the CatalogFile entry (if present) from this INF's version
        // section.
        //
        rc = pGetInfOriginalNameAndCatalogFile(
                 NULL,
                 SourceInfFileName,
                 &DifferentOriginalName,
                 OriginalInfName,
                 SIZECHARS(OriginalInfName),
                 SourceInfCatalogName,
                 SIZECHARS(SourceInfCatalogName),
                 NULL // always native OS/arch (ver doesn't matter for CatalogFile=)
                );

        if(rc == NO_ERROR) {
            CodeSigningPolicy = GetCodeSigningPolicyForInf(LogContext,
                                                           hInf,
                                                           &ValidationPlatform,
                                                           &UseOriginalInfName
                                                          );

            if(UseOriginalInfName) {
                //
                // If we're looking at an exception INF, make sure it's under its
                // original name.
                //
                if(DifferentOriginalName) {
                    rc = ERROR_INVALID_CLASS;
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume
        // an inpage error when dealing with a mapped-in file (e.g., in the
        // call to GetCodeSigningPolicyForInf).
        //
        rc = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
    }

    //
    // We're done with the INF handle
    //
    SetupCloseInfFile(hInf);

    if(rc != NO_ERROR) {
        goto final;
    }

    rc = GLE_FN_CALL(FALSE,
                     _SetupCopyOEMInf(
                         SourceInfFileName,
                         OEMSourceMediaLocation,
                         OEMSourceMediaType,
                         CopyStyle,
                         DestinationInfFileName,
                         DestinationInfFileNameSize,
                         RequiredSize,
                         DestinationInfFileNameComponent,
                         (DifferentOriginalName ? OriginalInfName
                                                : pSetupGetFileTitle(SourceInfFileName)),
                         (*SourceInfCatalogName ? SourceInfCatalogName : NULL),
                         NULL,    // no HWND for UI!
                         NULL,
                         CodeSigningPolicy,
                         SCOI_NO_ERRLOG_IF_INF_ALREADY_PRESENT |
                          (UseOriginalInfName ? SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES : 0),
                         NULL,
                         ValidationPlatform,
                         NULL,
                         CatalogFilenameOnSystem,
                         LogContext, // either made-up or thread log context
                         NULL,
                         NULL)
                    );

final:

    if(ValidationPlatform) {
        MyFree(ValidationPlatform);
    }
    DeleteLogContext(LogContext);

    SetLastError(rc);
    return (rc == NO_ERROR);
}


BOOL
_SetupCopyOEMInf(
    IN     PCTSTR                  SourceInfFileName,
    IN     PCTSTR                  OEMSourceMediaLocation,          OPTIONAL
    IN     DWORD                   OEMSourceMediaType,
    IN     DWORD                   CopyStyle,
    OUT    PTSTR                   DestinationInfFileName,          OPTIONAL
    IN     DWORD                   DestinationInfFileNameSize,
    OUT    PDWORD                  RequiredSize,                    OPTIONAL
    OUT    PTSTR                  *DestinationInfFileNameComponent, OPTIONAL
    IN     PCTSTR                  SourceInfOriginalName,
    IN     PCTSTR                  SourceInfCatalogName,            OPTIONAL
    IN     HWND                    Owner,
    IN     PCTSTR                  DeviceDesc,                      OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   Flags,
    IN     PCTSTR                  AltCatalogFile,                  OPTIONAL
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,                 OPTIONAL
    OUT    PDWORD                  DriverSigningError,              OPTIONAL
    OUT    PTSTR                   CatalogFilenameOnSystem,
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT PVERIFY_CONTEXT         VerifyContext,                   OPTIONAL
    OUT    HANDLE                 *hWVTStateData                    OPTIONAL
    )
/*++

Routine Description:

    (See SetupCopyOEMInf)

Arguments:

    (See SetupCopyOEMInf)

    SourceInfOriginalName - supplies the simple filename (no path) that this INF
        originally had.  This will typically be the same as its current name,
        except in cases where there's a valid PNF for that INF, and the PNF
        specifies a different original name.

    SourceInfCatalogName - Optionally, supplies the simple filename of the
        catalog file specified by the OEM INF via a CatalogFile= entry in its
        [Version] section.  If this parameter is not specified, then the INF
        doesn't specify an associated catalog.  (NOTE: One may still be used if
        the AltCatalogFile parameter is specified.

    Owner - supplies window handle to be used for any UI related to digital
        signature verification failures.

    DeviceDesc - Optionally, supplies the device description to be used in the
        digital signature verification error dialogs that may be popped up.

    DriverSigningPolicy - supplies the driver signing policy currently in
        effect.  Used when determining whether we can validate via an
        Authenticode catalog, and to control behavior of
        _HandleFailedVerification, if necessary.

    Flags - supplies flags which alter the behavior of the routine.  May be a
        combination of the following values:

        SCOI_NO_UI_ON_SIGFAIL - indicates whether user should be prompted (per
                                DriverSigningPolicy) if a digital signature
                                failure is encountered.  Used when calling
                                _HandleFailedVerification, if necessary.

        SCOI_NO_ERRLOG_ON_MISSING_CATALOG - if there's a signature verification
                                            failure due to the INF lacking a
                                            CatalogFile= entry, then that error
                                            will be ignored if this flag is set
                                            (no UI will be given, and no log
                                            entry will be generated).

        SCOI_NO_ERRLOG_IF_INF_ALREADY_PRESENT - If we discover that the INF
                                                already exists in %windir%\Inf,
                                                then don't popup any UI and
                                                don't even generate an error
                                                log entry.

        SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES - Install the INF and CAT under
                                               their original (current) names
                                               (i.e., don't generate a unique
                                               oem<n>.inf/cat name).  Used only
                                               for exception INFs.

        SCOI_ABORT_IF_UNSIGNED - If the INF is unsigned (and user wants to copy
                                 it anyway, or policy is Ignore), then _don't_
                                 copy the INF and instead return the error
                                 ERROR_SET_SYSTEM_RESTORE_POINT.  This gives
                                 the caller a chance to set a system restore
                                 point prior to installing the unsigned package.

        SCOI_TRY_UPDATE_PNF    - If an existing PNF cannot be updated, don't
                                 consider it fatal.

    AltCatalogFile - Optionally, supplies the name of a catalog file to be
        installed and used for verification of the INF in cases where the INF
        doesn't specify a CatalogFile= entry (i.e., when the
        SourceInfCatalogName parameter is not specified.

    AltPlatformInfo - Optionally, supplies alternate platform information to be
        used in digital signature verification instead of the default (native)
        platform info.

    DriverSigningError - Optionally, supplies the address of a variable that
        receives the error encountered when attempting to verify the digital
        signature of either the INF or associated catalog.  If no digital
        signature problems were encountered, this is set to NO_ERROR.  (Note
        that this value can come back as NO_ERROR, yet _SetupCopyOEMInf still
        failed for some other reason).

        If the INF was successfully validated via Authenticode policy, and the
        publisher was in the TrustedPublisher store, then this value will be
        set to ERROR_AUTHENTICODE_TRUSTED_PUBLISHER upon return.

        If the INF was successfully validated via Authenticode policy, and the
        publisher was not in the TrustedPublisher store (hence we must prompt
        the user to establish their trust of the publisher), then this value
        will be set to ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED upon return.

    CatalogFilenameOnSystem - Receives the fully-qualified path of the catalog
        file within the catalog store where this INF's catalog file was
        installed to. This buffer should be at least MAX_PATH bytes (ANSI
        version) or chars (Unicode version).

    LogContext - supplies a LogContext to be passed to GetNewInfName.

    VerifyContext - optionally, supplies the address of a structure that caches
        various verification context handles.  These handles may be NULL (if
        not previously acquired, and they may be filled in upon return (in
        either success or failure) if they were acquired during the processing
        of this verification request.  It is the caller's responsibility to
        free these various context handles when they are no longer needed by
        calling pSetupFreeVerifyContextMembers.

    hWVTStateData - if supplied, this parameter points to a buffer that
        receives a handle to WinVerifyTrust state data.  This handle will be
        returned only when validation was successfully performed using
        Authenticode policy.  This handle may be used, for example, to retrieve
        signer info when prompting the user about whether they trust the
        publisher.  (The status code returned in the DriverSigningError output
        parameter will indicate whether or not this is necessary.)

        This parameter should only be supplied if the
        DRIVERSIGN_ALLOW_AUTHENTICODE bit is set in the caller-specified
        DriverSigningPolicy.  If the routine fails, then this handle will be
        set to NULL.

        It is the caller's responsibility to close this handle when they're
        finished with it by calling pSetupCloseWVTStateData().

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    TCHAR NewName[MAX_PATH];
    DWORD TempRequiredSize, Err;
    NEWINF_COPYTYPE CopyNeeded;
    WIN32_FIND_DATA FindData;
    PLOADED_INF PrecompiledNewInf;
    UINT ErrorLineNumber;
    TCHAR TempOemSourceMediaLocation[MAX_PATH];
    PTSTR TempCharPtr;
    BOOL AlternateCatInstalled;
    DWORD TempDriverSigningError;
    DWORD DefaultSourceMediaType;
    HINF hInf;
    HANDLE LocalhWVTStateData = NULL;

    if(DriverSigningError) {
        *DriverSigningError = NO_ERROR;
    }

    //
    // Initialize the output handle for WinVerifyTrust state data.
    //
    if(hWVTStateData) {
        *hWVTStateData = NULL;
    }

    //
    // If the DestinationInfFileName buffer is NULL, the size had better be
    // zero.  Also, make sure the caller passed us a valid OEMSourceMediaType.
    //
    if((!DestinationInfFileName && DestinationInfFileNameSize) ||
       (OEMSourceMediaType >= SPOST_MAX))
    {
        MYASSERT(!DriverSigningError);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If we're installing an exception INF, it's illegal to request that we
    // not copy the INF.
    //
    if((Flags & SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES) &&
       (CopyStyle & SP_COPY_OEMINF_CATALOG_ONLY))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Err = NO_ERROR;
    CopyNeeded = NewInfCopyNo;
    AlternateCatInstalled = FALSE;
    TempCharPtr = NULL;
    hInf = INVALID_HANDLE_VALUE;

    try {
        //
        // Check to see if the INF is already in the %windir%\Inf directory,
        // and create a uniquely-named, zero-length placeholder file if it
        // isn't.
        //
        Err = GetNewInfName(Owner,
                            SourceInfFileName,
                            SourceInfOriginalName,
                            SourceInfCatalogName,
                            NewName,
                            SIZECHARS(NewName),
                            &TempRequiredSize,
                            &CopyNeeded,
                            CopyStyle & SP_COPY_REPLACEONLY,
                            DeviceDesc,
                            DriverSigningPolicy,
                            Flags,
                            AltCatalogFile,
                            AltPlatformInfo,
                            &TempDriverSigningError,
                            CatalogFilenameOnSystem,
                            LogContext,
                            VerifyContext,
                            &LocalhWVTStateData
                           );

        if((Err == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
           (Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {

            MYASSERT(TempDriverSigningError == NO_ERROR);
            MYASSERT(LocalhWVTStateData);

            if(hWVTStateData) {
                *hWVTStateData = LocalhWVTStateData;
            } else {
                pSetupCloseWVTStateData(LocalhWVTStateData);
            }

            //
            // We want to return Authenticode signature status to the caller
            // via the DriverSigningError output parameter.  We can't use a
            // return of FALSE (with GetLastError), since we also need to
            // report ERROR_FILE_EXISTS (which isn't really an error, and needs
            // to be communicated in tandem with the Authenticode status).
            //
            TempDriverSigningError = Err;
            Err = NO_ERROR;

        } else {
            MYASSERT(!LocalhWVTStateData);
        }

        if(DriverSigningError) {
            *DriverSigningError = TempDriverSigningError;
        }

        if(Err != NO_ERROR) {
            //
            // Value of CopyNeeded parameter is undefined upon error, but we do
            // know that no clean-up will be necessary if GetNewInfName fails.
            //
            CopyNeeded = NewInfCopyNo;

            //
            // If we were only trying to get the catalog installed, and the
            // failure was for some reason _other_ than a digital signature
            // verification failure (e.g., we couldn't create the placeholder
            // INF in %windir%\Inf), then we want to treat this as if it were
            // a signature verification failure.  Since we aren't trying to
            // install the full INF, this implies that we aren't doing a device
            // install, thus the policy is going to be non-driver-signing
            // policy.  This has the default of "Ignore", which is fortunate,
            // since the dialog complains about an unsigned driver package when
            // in fact we don't really know whether or not the package is
            // unsigned--all we know is that we couldn't install its catalog,
            // even if it had one.
            //
            // Note: if the user clicks the "More Info..." button, we will tell
            // them that the catalog installation failed, and what a possible
            // cause might be (e.g., no write access to Windows directory).
            //
            if((CopyStyle & SP_COPY_OEMINF_CATALOG_ONLY) &&
               (TempDriverSigningError == NO_ERROR)) {

                if(SourceInfCatalogName) {
                    //
                    // Typical case (INF specified a catalog), give the user
                    // some indication (via codesigning popup based on policy)
                    // about what went wrong...
                    //
                    if(_HandleFailedVerification(
                           Owner,
                           SetupapiVerifyCatalogInstallProblem,
                           SourceInfCatalogName,
                           DeviceDesc,
                           DriverSigningPolicy,
                           (Flags & SCOI_NO_UI_ON_SIGFAIL),
                           Err,
                           LogContext,
                           NULL,
                           NULL,
                           NULL)) {

                        TempDriverSigningError = Err;
                        if(DriverSigningError) {
                            *DriverSigningError = TempDriverSigningError;
                        }

                        //
                        // The user wants to proceed with the unsigned
                        // installation (or policy is Ignore, so they weren't
                        // even informed).  If the caller wants a chance to set
                        // a system restore point prior to doing any unsigned
                        // installations, then we abort now with a "special"
                        // error code that tells them what to do...
                        //
                        if(Flags & SCOI_ABORT_IF_UNSIGNED) {
                            Err = ERROR_SET_SYSTEM_RESTORE_POINT;
                        } else {
                            //
                            // We should consider the operation a success, even
                            // though we couldn't install the catalog.
                            //
                            Err = NO_ERROR;
                        }
                    }

                } else {
                    //
                    // Unlikely scenario (INF didn't specify a catalog, yet we
                    // were called with SP_COPY_OEMINF_CATALOG_ONLY???), just
                    // ignore the issue, generate a setupapi.log entry, and
                    // proceed...
                    //
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                  MSG_LOG_FAILED_INF_INSTALL,
                                  NULL,
                                  SourceInfFileName
                                 );

                    WriteLogError(LogContext,
                                  SETUP_LOG_ERROR,
                                  Err
                                 );

                    TempDriverSigningError = Err;
                    if(DriverSigningError) {
                        *DriverSigningError = TempDriverSigningError;
                    }

                    Err = NO_ERROR;
                }

                if(Err == NO_ERROR) {
                    //
                    // In this case, we don't have a filename to return to the
                    // caller.
                    //
                    if(RequiredSize) {
                        *RequiredSize = 0;
                    }
                    if(DestinationInfFileName && DestinationInfFileNameSize) {
                        *DestinationInfFileName = TEXT('\0');
                    }
                    if(DestinationInfFileNameComponent) {
                        *DestinationInfFileNameComponent = NULL;
                    }
                }
            }

            leave;
        }

        //
        // OK, we have a filename to copy to, now copy the file (if necessary),
        // unless the caller doesn't want to overwrite the existing file.
        //
        if(CopyNeeded != NewInfCopyNo) {
            //
            // We either created a new zero-length placeholder file ourselves,
            // or we found an existing placeholder that we could use.
            //
            // Copy our INF over the top of this placeholder file, unless the
            // caller specified the SP_COPY_OEMINF_CATALOG_ONLY flag, in which
            // case we want to leave the zero-length file as-is (and mark it
            // hidden), so that no other OEM INFs can subsequently get this name
            // (hence causing namespace collisions for the catalog files).
            //
            if(!(CopyStyle & SP_COPY_OEMINF_CATALOG_ONLY)) {

                SetFileAttributes(NewName, FILE_ATTRIBUTE_NORMAL);

                Err = GLE_FN_CALL(FALSE,
                                  InfCacheAwareCopyFile(SourceInfFileName, NewName)
                                 );

                if(Err != NO_ERROR) {
                    //
                    // Hopefully, this didn't return ERROR_FILE_EXISTS, as that
                    // return code means something special for SetupCopyOEMInf.
                    //
                    MYASSERT(Err != ERROR_FILE_EXISTS);
                    if(Err == ERROR_FILE_EXISTS) {
                        Err = ERROR_INVALID_DATA;  // just pick something else!
                    }

                    leave;
                }

            } else {
                //
                // If we didn't encounter a driver signing error, or if the
                // zero-length file was already present, then just make sure
                // it's marked as hidden.
                //
                if((TempDriverSigningError == NO_ERROR) ||
                   (TempDriverSigningError == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                   (TempDriverSigningError == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) ||
                   (CopyNeeded == NewInfCopyZeroLength)) {
                    //
                    // Mark the zero-length file as hidden.
                    //
                    SetFileAttributes(NewName, FILE_ATTRIBUTE_HIDDEN);
                } else {
                    //
                    // Delete the newly-created zero-length placeholder INF,
                    // because it serves no purpose.
                    //
                    SetFileAttributes(NewName, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(NewName);
                }

                //
                // Since we only have a zero-length placeholder (or possibly,
                // no placeholder at all if catalog installation failed), we
                // shouldn't return a filename to the caller.
                //
                if(RequiredSize) {
                    *RequiredSize = 0;
                }
                if(DestinationInfFileName && DestinationInfFileNameSize) {
                    *DestinationInfFileName = TEXT('\0');
                }
                if(DestinationInfFileNameComponent) {
                    *DestinationInfFileNameComponent = NULL;
                }
                //
                // We're done!
                //
                leave;
            }

        } else {
            //
            // If the original INF name and the new INF name are different,
            // then we know this wasn't an alternate catalog-only install.
            //
            AlternateCatInstalled = !lstrcmpi(SourceInfFileName, NewName);

            if((CopyStyle & SP_COPY_NOOVERWRITE) && !AlternateCatInstalled) {
                //
                // OK, the INF already exists in the INF directory, and the
                // caller has specified that they _do not_ want to wipe out the
                // existing PNF.  We may need to return back the name of the
                // existing INF if they requested it, however.
                //
                // NOTE: It's OK to return the WinVerifyTrust state data handle
                // in this case, since this isn't "really" an error (and both
                // pieces of info need to be returned to caller).
                //
                Err = ERROR_FILE_EXISTS;
            }
        }

        //
        // If we get to here, then the INF exists in %windir%\Inf, and we
        // either have no error, or ERROR_FILE_EXISTS.  Next, we need to store
        // the name of the INF in the caller's buffer (if supplied).
        //
        if(RequiredSize) {
            *RequiredSize = TempRequiredSize;
        }

        if(DestinationInfFileName) {
            if(DestinationInfFileNameSize >= TempRequiredSize) {
                MYVERIFY(SUCCEEDED(StringCchCopy(DestinationInfFileName,
                                                 DestinationInfFileNameSize,
                                                 NewName)));
                //
                // If requested by the caller, return a pointer to the filename
                // part of this path.
                //
                if(DestinationInfFileNameComponent) {
                    *DestinationInfFileNameComponent = (PTSTR)pSetupGetFileTitle(DestinationInfFileName);
                }
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
        } else {
            //
            // Nobody should be requesting a pointer to the filename component
            // of the path when they don't supply us a buffer to store the full
            // path.  If anyone does do this, make sure we set the pointer to
            // NULL.
            //
            if(DestinationInfFileNameComponent) {
                *DestinationInfFileNameComponent = NULL;
            }
        }

        if((Err != NO_ERROR) || AlternateCatInstalled) {
            leave;
        }

        //
        // If the code calling this API claims that this INF is from the
        // Internet we first want to check if there is a PNF for this INF and
        // that the PNF agrees that this INF is from the Internet.  If the PNF
        // says the INF is from a location other than the Internet then we will
        // change the OEMSourceMediaType to this other media type.  We will
        // also set the OEMSourceMediaLocation to NULL.  This has the desired
        // affect of us falling through the next if statement which will read
        // the SourceMediaLocation from the PNF instead of the current INF
        // location.  If there is no PNF for the given INF then we just leave
        // OEMSourceMediaType alone.
        //
        if(OEMSourceMediaType == SPOST_URL) {

            if(pSetupGetSourceMediaTypeFromPnf(SourceInfFileName, &DefaultSourceMediaType) &&
               (DefaultSourceMediaType != SPOST_URL)) {

                OEMSourceMediaType = DefaultSourceMediaType;
                OEMSourceMediaLocation = NULL;
            }
        }

        if(!OEMSourceMediaLocation && (OEMSourceMediaType == SPOST_PATH)) {
            //
            // The caller wants to store the OEM source path, but they didn't
            // provide us with one to use.  Thus, we'll use the path where the
            // INF existed (unless there's a valid PNF there, in which case
            // we'll use its SPOST_PATH information, if it has any).
            // pSetupGetDefaultSourcePath() does just what we want.
            //
            Err = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                              hInf = SetupOpenInfFile(SourceInfFileName,
                                                      NULL,
                                                      INF_STYLE_WIN4 | INF_STYLE_OLDNT,
                                                      NULL)
                             );

            if(Err != NO_ERROR) {
                //
                // Hopefully, this didn't return ERROR_FILE_EXISTS, as that
                // return code means something special for SetupCopyOEMInf.
                //
                MYASSERT(Err != ERROR_FILE_EXISTS);
                if(Err == ERROR_FILE_EXISTS) {
                    Err = ERROR_INVALID_DATA;  // just pick something else!
                }

                leave;
            }

            Err = GLE_FN_CALL(NULL,
                              TempCharPtr = pSetupGetDefaultSourcePath(
                                                hInf,
                                                SRCPATH_USEINFLOCATION,
                                                &DefaultSourceMediaType)
                             );

            //
            // We don't need the INF handle anymore.
            //
            SetupCloseInfFile(hInf);
            hInf = INVALID_HANDLE_VALUE;

            MYASSERT(DefaultSourceMediaType == SPOST_PATH);

            if(Err != NO_ERROR) {
                //
                // Hopefully, this didn't return ERROR_FILE_EXISTS, as that
                // return code means something special for SetupCopyOEMInf.
                //
                MYASSERT(Err != ERROR_FILE_EXISTS);
                if(Err == ERROR_FILE_EXISTS) {
                    Err = ERROR_INVALID_DATA;  // just pick something else!
                }

                leave;
            }

            MYVERIFY(SUCCEEDED(StringCchCopy(TempOemSourceMediaLocation,
                                             SIZECHARS(TempOemSourceMediaLocation),
                                             TempCharPtr)));
            OEMSourceMediaLocation = TempOemSourceMediaLocation;
            //
            // We no longer need the buffer allocated for us by
            // pSetupGetDefaultSourcePath.
            //
            MyFree(TempCharPtr);
            //
            // Reset this pointer so we won't try to free it should we
            // subsequently encounter an exception.
            //
            TempCharPtr = NULL;
        }

        Err = GLE_FN_CALL(FALSE, FileExists(NewName, &FindData));

        if(Err != NO_ERROR) {
            //
            // Hopefully, this didn't return ERROR_FILE_EXISTS, as that
            // return code means something special for SetupCopyOEMInf.
            //
            MYASSERT(Err != ERROR_FILE_EXISTS);
            if(Err == ERROR_FILE_EXISTS) {
                Err = ERROR_INVALID_DATA;  // just pick something else!
            }

            leave;
        }

        Err = LoadInfFile(NewName,
                          &FindData,
                          INF_STYLE_WIN4 | INF_STYLE_OLDNT,
                          LDINF_FLAG_ALWAYS_TRY_PNF
                          | LDINF_FLAG_REGENERATE_PNF
                          | ((Flags & SCOI_TRY_UPDATE_PNF) ? LDINF_FLAG_ALLOW_PNF_SHARING_LOCK : 0)
                          | ((OEMSourceMediaType == SPOST_URL) ? LDINF_FLAG_SRCPATH_IS_URL : 0)
                          | ((CopyStyle & SP_COPY_OEM_F6_INF) ? LDINF_FLAG_OEM_F6_INF : 0),
                          NULL,
                          (OEMSourceMediaType == SPOST_NONE) ? NULL : OEMSourceMediaLocation,
                          (lstrcmpi(SourceInfOriginalName, pSetupGetFileTitle(NewName))
                              ? SourceInfOriginalName
                              : NULL),
                          NULL,
                          LogContext,
                          &PrecompiledNewInf,
                          &ErrorLineNumber,
                          NULL
                         );

        if(Err != NO_ERROR) {
            //
            // Hopefully, this didn't return ERROR_FILE_EXISTS, as that
            // return code means something special for SetupCopyOEMInf.
            //
            MYASSERT(Err != ERROR_FILE_EXISTS);
            if(Err == ERROR_FILE_EXISTS) {
                Err = ERROR_INVALID_DATA;  // just pick something else!
            }

            leave;
        }

        //
        // The INF was successfully precompiled.
        //
        FreeInfFile(PrecompiledNewInf);

        //
        // Finally, delete the source INF file if the caller requested it.
        //
        if(CopyStyle & SP_COPY_DELETESOURCE) {
            DeleteFile(SourceInfFileName);
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {

        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);

        MYASSERT(Err != ERROR_FILE_EXISTS);

        if(TempCharPtr) {
            MyFree(TempCharPtr);
        }

        if(hInf != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile(hInf);
        }
    }

    if(Err != NO_ERROR) {
        //
        // For any error other than ERROR_FILE_EXISTS (which doesn't really
        // indicate a problem), we need to ensure that no WinVerifyTrust state
        // data is being returned to the caller.
        //
        if((Err != ERROR_FILE_EXISTS) && hWVTStateData && *hWVTStateData) {
            pSetupCloseWVTStateData(*hWVTStateData);
            *hWVTStateData = NULL;
        }

        if(CopyNeeded == NewInfCopyYes) {
            //
            // We encountered an error, after GetNewInfName created a new,
            // unique INF for us.  Delete it now.
            //
            // (Note: we don't do clean-up when GetNewInfName found an
            // existing, zero-length file for us to use, even if we may have
            // subsequently copied the 'real' INF over the top of it.  Since we
            // believed the existing file to be a duplicate of our OEM INF,
            // this should be OK--the worst that's going to happen is that an
            // INF that was once zero-length is now a full-blown INF after
            // SetupCopyOEMInf encountered an error.)
            //
            pSetupUninstallOEMInf(NewName, LogContext, SUOI_FORCEDELETE, NULL);

            //
            // NTRAID#256075-2000/08/18-JamieHun Handle Rollback of INF/PNF/CAT files
            //
            // If we were installing an exception INF and encountered an error,
            // we may have already blown away a previous INF/CAT.  In the
            // future, we might want to look into doing a backup on the old
            // INF/CAT before installing the new INF/CAT over the top of them.
            //
        }
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupUninstallOEMInfA(
    IN PCSTR InfFileName,
    IN DWORD Flags,
    IN PVOID Reserved
    )
{
    DWORD Err;
    PCWSTR UnicodeInfFileName;
    BOOL b;

    Err = pSetupCaptureAndConvertAnsiArg(InfFileName, &UnicodeInfFileName);

    if(Err != NO_ERROR) {
        SetLastError(Err);
        return FALSE;
    }

    b = SetupUninstallOEMInfW(UnicodeInfFileName, Flags, Reserved);
    Err = GetLastError();

    MyFree(UnicodeInfFileName);

    SetLastError(Err);
    return b;
}


BOOL
WINAPI
SetupUninstallOEMInf(
    IN PCTSTR InfFileName,
    IN DWORD  Flags,
    IN PVOID  Reserved
    )

/*++

Routine Description:

    This API uninstalls the specified INF file, and deletes the associated
    .PNF and .CAT files, if they exist.

    The default behavior of this API is to first verify that there are no
    other devices, live or phantom, that are using this INF.  If another
    device is using this INF then it will not be uninstalled. This behavior
    can be overwritten by the SUOI_FORCEDELETE flag.

Arguments:

    InfFileName - Supplies the simple filename (no path) of the INF to be
        uninstalled.

    Flags - Supplies flags that alter the behavior of this API.
        SUOI_FORCEDELETE - forces the INF, PNF, and CAT to be uninstalled, even
        if another device is using this INF.

    Reserved - Reserved for future use.  Must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err;
    TCHAR InfFullPath[MAX_PATH];

    if(Flags & ~(SUOI_FORCEDELETE)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    try {
        //
        // INF filename must not contain path
        //
        if(InfFileName != pSetupGetFileTitle(InfFileName)) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Look for specified INF in %windir%\Inf...
        //
        if(MYVERIFY(SUCCEEDED(StringCchCopy(InfFullPath,
                                            SIZECHARS(InfFullPath),
                                            InfDirectory)))) {

            MYVERIFY(pSetupConcatenatePaths(InfFullPath,
                                            InfFileName,
                                            SIZECHARS(InfFullPath),
                                            NULL
                                            ));
        }

        if(!FileExists(InfFullPath, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        pSetupUninstallOEMInf(InfFullPath, NULL, Flags, &Err);

clean0:
        ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiRegisterCoDeviceInstallers(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

Routine Description:

    Default handler for DIF_REGISTER_COINSTALLERS

    This routine will install any (device-specific) co-installers specified
    in an [<InstallSec>.CoInstallers] section, where <InstallSec> is the install
    section name for the selected driver node, potentially decorated with
    an OS/architecture-specific extension (e.g., "InstallSec.NTAmd64.CoInstallers").

    AddReg entries listed in a CoInstallers section use the device's driver key
    for their HKR.  To register a device-specific co-installer, a REG_MULTI_SZ entry
    titled "CoInstallers32" must be written to the driver key.  Each entry in this list
    has the following format:

        dll[,procname]

    where dll is the name of the module to load and procname is an optional entry
    point name.  If procname is not specified, then the entry point name
    "CoDeviceInstall" will be used.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a device information element for whom co-installers are to be registered.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for whom
        co-installers are to be registered.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If no driver is selected (i.e., this is a null-driver installation), then
    this routine does nothing.

--*/

{
    return _SetupDiRegisterCoDeviceInstallers(DeviceInfoSet,
                                              DeviceInfoData,
                                              TRUE,
                                              INVALID_HANDLE_VALUE,
                                              INVALID_HANDLE_VALUE
                                             );
}


BOOL
_SetupDiRegisterCoDeviceInstallers(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOL             DoFullInstall,
    IN HINF             hDeviceInf,     OPTIONAL
    IN HSPFILEQ         UserFileQ       OPTIONAL
    )
/*++

Routine Description:

    Worker routine for both SetupDiRegisterCoDeviceInstallers and SetupDiInstallDriverFiles.

    See the description of SetupDiRegisterCoDeviceInstallers for more information.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a device information element for whom co-installers are to be registered.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for whom
        co-installers are to be registered.

    DoFullInstall - If TRUE (non-zero), then the co-installers are completely registered,
        otherwise, only files are copied.

    hDeviceInf - Optionally, supplies a handle to the INF for which installation
        is being performed.  If this handle is not supplied, the INF specified in
        the selected driver node will be opened.  If this handle is not supplied,
        this parameter must be set to INVALID_HANDLE_VALUE.

    UserFileQ - Optionally, supplies a file queue where file operations should be added.
        If this handle is not supplied, then the queue associated with this devinfo
        element will be used (if the DI_NOVCP flag is set), or one will be automatically
        generated and committed.  If this handle is not supplied, this parameter must
        be set to INVALID_HANDLE_VALUE.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    During GUI-mode setup on Windows NT, quiet-install behavior is always
    employed in the absence of a user-supplied file queue, regardless of
    whether the device information element has the DI_QUIETINSTALL flag set.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err, ScanQueueResult;
    PDEVINFO_ELEM DevInfoElem;
    HWND hwndParent;
    BOOL CloseUserFileQ;
    PTSTR szInfFileName, szInfSectionName;
    TCHAR InfSectionWithExt[MAX_SECT_NAME_LEN];
    DWORD InfSectionWithExtLength;
    BOOL FreeMsgHandlerContext;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL MsgHandlerIsNativeCharWidth, DeleteDrvRegKey;
    HKEY hkDrv;
    BOOL CloseInfHandle;
    BOOL DoFileCopying;
    INT FileQueueNeedsReboot;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD slot_section = 0;
    BOOL NoProgressUI;
    TCHAR szNewName[MAX_PATH];
    BOOL OemInfFileToCopy = FALSE;

    //
    // A device information element must be specified.
    //
    if(!DeviceInfoData) {
        Err = ERROR_INVALID_PARAMETER;
        goto clean1;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }

    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;
    hDeviceInf = INVALID_HANDLE_VALUE;
    CloseUserFileQ = FALSE;
    FreeMsgHandlerContext = FALSE;
    hkDrv = INVALID_HANDLE_VALUE;
    DeleteDrvRegKey = FALSE;
    CloseInfHandle = FALSE;

    try {

        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't install a non-native driver
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        //
        // set the LogContext for this function
        //
        LogContext = DevInfoElem->InstallParamBlock.LogContext;

        //
        // If there's no driver selected (i.e., this is a null driver install)
        // then there's nothing for us to do.
        //
        if(!DevInfoElem->SelectedDriver) {
            goto clean0;
        }

        //
        // Make sure we only use the devinfo element's window if it's valid.
        //
        if(hwndParent = DevInfoElem->InstallParamBlock.hwndParent) {
           if(!IsWindow(hwndParent)) {
                hwndParent = NULL;
           }
        }

        szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                 DevInfoElem->SelectedDriver->InfFileName
                                                );

        szInfSectionName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                    DevInfoElem->SelectedDriver->InfSectionName
                                                   );

        if(hDeviceInf == INVALID_HANDLE_VALUE) {

            if((hDeviceInf = SetupOpenInfFile(szInfFileName,
                                              NULL,
                                              INF_STYLE_WIN4,
                                              NULL)) == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                goto clean0;
            }

            CloseInfHandle = TRUE;
        }
        //
        // see if we should give the INF the same LogContext as the DevInfoElem
        //
        InheritLogContext(LogContext,
            &((PLOADED_INF) hDeviceInf)->LogContext);

        slot_section = AllocLogInfoSlot(LogContext,FALSE);

        //
        // Find out the 'real' install section we should be using (i.e., the potentially
        // OS/architecture-specific one.
        //
        if(!SetupDiGetActualSectionToInstall(hDeviceInf,
                                             szInfSectionName,
                                             InfSectionWithExt,
                                             SIZECHARS(InfSectionWithExt),
                                             &InfSectionWithExtLength,
                                             NULL
                                             )) {
            Err = GetLastError();
            goto clean0;
        }

        //
        // Now append the ".CoInstallers" extension to the install section name to find
        // the co-installer INF section to run.
        //
        MYVERIFY(SUCCEEDED(StringCchCopy(&(InfSectionWithExt[InfSectionWithExtLength - 1]),
                                         SIZECHARS(InfSectionWithExt)-(InfSectionWithExtLength - 1),
                                         pszCoInstallersSectionSuffix)));

        //
        // Figure out whether we need to do file copying.  (Ignore the DI_NOFILECOPY
        // flag if we're doing a copy-only installation--that's what setupx does.)
        //
        DoFileCopying = (!(DevInfoElem->InstallParamBlock.Flags & DI_NOFILECOPY) || !DoFullInstall);

        //
        // Append the layout INF, if necessary.
        //
        if(DoFileCopying) {
            SetupOpenAppendInfFile(NULL, hDeviceInf, NULL);
        }

        //
        // Append-load any included INFs specified in an "include=" line in our
        // install section.
        //
        AppendLoadIncludedInfs(hDeviceInf, szInfFileName, InfSectionWithExt, DoFileCopying);

        //
        // Now copy the files, if necessary.
        //
        if(DoFileCopying) {

            if(UserFileQ == INVALID_HANDLE_VALUE) {
                //
                // If the DI_NOVCP flag is set, then just queue up the file
                // copy/rename/delete operations.  Otherwise, perform the
                // actions.
                //
                if(DevInfoElem->InstallParamBlock.Flags & DI_NOVCP) {
                    //
                    // We must have a user-supplied file queue.
                    //
                    MYASSERT(DevInfoElem->InstallParamBlock.UserFileQ);
                    UserFileQ = DevInfoElem->InstallParamBlock.UserFileQ;
                } else {
                    //
                    // Since we may need to check the queued files to determine whether file copy
                    // is necessary, we have to open our own queue, and commit it ourselves.
                    //
                    if((UserFileQ = SetupOpenFileQueue()) != INVALID_HANDLE_VALUE) {
                        CloseUserFileQ = TRUE;

                    } else {
                        //
                        // SetupOpenFileQueue sets actual error
                        //
                        Err = GetLastError();
                        goto clean0;
                    }
                }
            }
            //
            // See if we should replace the file queue's log context with the
            // DevInfoElem's
            //
            InheritLogContext(LogContext,
                &((PSP_FILE_QUEUE) UserFileQ)->LogContext);

            WriteLogEntry(LogContext,
                slot_section,
                MSG_LOG_COINSTALLER_REGISTRATION,
                NULL,
                InfSectionWithExt);

            Err = InstallFromInfSectionAndNeededSections(NULL,
                                                         hDeviceInf,
                                                         InfSectionWithExt,
                                                         SPINST_FILES,
                                                         NULL,
                                                         NULL,
                                                         SP_COPY_NEWER_OR_SAME | SP_COPY_LANGUAGEAWARE |
                                                             ((DevInfoElem->InstallParamBlock.Flags & DI_NOBROWSE) ? SP_COPY_NOBROWSE : 0),
                                                         NULL,
                                                         NULL,
                                                         INVALID_HANDLE_VALUE,
                                                         NULL,
                                                         UserFileQ
                                                        );

            //
            // Mark the queue as a device install queue (and make sure there's a
            // catalog node representing our device INF in the queue).
            //
            Err = MarkQueueForDeviceInstall(UserFileQ,
                                            hDeviceInf,
                                            pStringTableStringFromId(
                                                pDeviceInfoSet->StringTable,
                                                DevInfoElem->SelectedDriver->DrvDescription)
                                           );

            //
            // At this point, we have queued up all the files that need to be copied.  If
            // we weren't given a user-supplied queue, then commit our queue now.
            //
            if(CloseUserFileQ) {

                if(Err == NO_ERROR) {
                    //
                    // Determine whether the queue actually needs to be
                    // committed.
                    //
                    // ScanQueueResult can have 1 of 3 values:
                    //
                    // 0: Some files were missing--must commit queue.
                    //
                    // 1: All files to be copied are already present and
                    //    queue is empty--skip committing queue.
                    //
                    // 2: All files to be copied are present, but
                    //    del/ren/backup queues not empty--must commit
                    //    queue. The copy queue will have been emptied, so
                    //    only del/ren/backup functions will be performed.
                    //
                    // (jamiehun) see previous case of SetupScanFileQueue
                    // for a discussion of DI_FLAGSEX_PREINSTALLBACKUP
                    // handling.
                    //
                    if(!SetupScanFileQueue(UserFileQ,
                                           SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                                           hwndParent,
                                           NULL,
                                           NULL,
                                           &ScanQueueResult)) {
                        //
                        // SetupScanFileQueue should really never fail when
                        // you don't ask it to call a callback routine, but
                        // if it  does, just go ahead and commit the queue.
                        //
                        ScanQueueResult = 0;
                    }
                }

                if((Err == NO_ERROR) && (ScanQueueResult != 1)) {
                    //
                    // We need to commit this file queue.  Figure out what
                    // message handler to use.
                    //
                    if(DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                        MsgHandler = DevInfoElem->InstallParamBlock.InstallMsgHandler;
                        MsgHandlerContext = DevInfoElem->InstallParamBlock.InstallMsgHandlerContext;
                        MsgHandlerIsNativeCharWidth = DevInfoElem->InstallParamBlock.InstallMsgHandlerIsNativeCharWidth;
                    } else {

                        NoProgressUI = (GuiSetupInProgress || (DevInfoElem->InstallParamBlock.Flags & DI_QUIETINSTALL));

                        if(MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                                  hwndParent,
                                                  (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                                                  0,
                                                  0,
                                                  NULL))
                        {
                            FreeMsgHandlerContext = TRUE;
                            MsgHandler = SetupDefaultQueueCallback;
                            MsgHandlerIsNativeCharWidth = TRUE;
                        } else {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    //
                    // Copy enqueued files.
                    //
                    if(Err == NO_ERROR) {
                        //
                        // Call _SetupVerifyQueuedCatalogs separately (i.e.,
                        // don't let it happen automatically as a result of
                        // committing the queue that happens below).  We do
                        // this beforehand so that we know what unique name was
                        // generated when an OEM INF was installed into
                        // %windir%\Inf (in case we need to delete the
                        // INF/PNF/CAT files later if we encounter an error).
                        //
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_TIME,
                            MSG_LOG_BEGIN_COINST_VERIFY_CAT_TIME,
                            NULL);       // text message

                        Err = _SetupVerifyQueuedCatalogs(
                                  hwndParent,
                                  UserFileQ,
                                  (VERCAT_INSTALL_INF_AND_CAT |
                                   ((DevInfoElem->SelectedDriver->Flags & DNF_INET_DRIVER)
                                        ? VERCAT_PRIMARY_DEVICE_INF_FROM_INET : 0)),
                                  szNewName,
                                  &OemInfFileToCopy
                                 );

                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_TIME,
                            MSG_LOG_END_COINST_VERIFY_CAT_TIME,
                            NULL);       // text message

                        if(Err == NO_ERROR) {

                            if(_SetupCommitFileQueue(hwndParent,
                                                     UserFileQ,
                                                     MsgHandler,
                                                     MsgHandlerContext,
                                                     MsgHandlerIsNativeCharWidth
                                                     )) {
                                //
                                // Check to see whether a reboot is required as a
                                // result of committing the queue (i.e., because
                                // files were in use, or the INF requested a reboot).
                                //
                                FileQueueNeedsReboot = SetupPromptReboot(UserFileQ, NULL, TRUE);
                                //
                                // This should never fail...
                                //
                                MYASSERT(FileQueueNeedsReboot != -1);

                                if(FileQueueNeedsReboot) {
                                    SetDevnodeNeedsRebootProblem(DevInfoElem, pDeviceInfoSet,
                                                                 MSG_LOG_REBOOT_REASON_INUSE);
                                }

                            } else {
                                Err = GetLastError();
                            }
                        }
                    }
                }

                //
                // Close our file queue handle.
                //
                SetupCloseFileQueue(UserFileQ);
                CloseUserFileQ = FALSE;

                //
                // Terminate the default queue callback, if it was created.
                //
                if(FreeMsgHandlerContext) {
                    SetupTermDefaultQueueCallback(MsgHandlerContext);
                    FreeMsgHandlerContext = FALSE;
                }

                if(Err != NO_ERROR) {
                    goto clean0;
                }
            }
        }

        //
        // If all we were asked to do was copy files, then we're done.
        //
        if(!DoFullInstall ||
           (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NO_DRVREG_MODIFY)) {

            goto clean0;
        }

        //
        // Open/create the Driver Reg Key.
        //
        if((hkDrv = SetupDiOpenDevRegKey(DeviceInfoSet,
                                         DeviceInfoData,
                                         DICS_FLAG_GLOBAL,
                                         0,
                                         DIREG_DRV,
                                         KEY_READ | KEY_WRITE)) == INVALID_HANDLE_VALUE) {
            //
            // Assume the driver key doesn't already exist--try to create it.
            //
            if((hkDrv = SetupDiCreateDevRegKey(DeviceInfoSet,
                                               DeviceInfoData,
                                               DICS_FLAG_GLOBAL,
                                               0,
                                               DIREG_DRV,
                                               NULL,
                                               NULL)) != INVALID_HANDLE_VALUE) {
                //
                // We successfully created the driver key.  Set a flag so we'll know
                // to delete it in case we hit an error and need to clean up.
                //
                DeleteDrvRegKey = TRUE;
            } else {
                Err = GetLastError();
                goto clean0;
            }
        }

        //
        // We don't pass a msg handler so no need to worry about ansi
        // vs. unicode issues here.
        //
        Err = InstallFromInfSectionAndNeededSections(NULL,
                                                     hDeviceInf,
                                                     InfSectionWithExt,
                                                     SPINST_INIFILES
                                                     | SPINST_REGISTRY
                                                     | SPINST_INI2REG
                                                     | SPINST_BITREG
                                                     | SPINST_REGSVR
                                                     | SPINST_UNREGSVR
                                                     | SPINST_PROFILEITEMS,
                                                     hkDrv,
                                                     NULL,
                                                     0,
                                                     NULL,
                                                     NULL,
                                                     INVALID_HANDLE_VALUE,
                                                     NULL,
                                                     NULL
                                                    );
        if(Err == NO_ERROR) {
            //
            // Registering co-installers invalidates our existing co-installer
            // list.  Reset this list (migrating the module handles to the devinfo
            // set's list of "things to clean up later".
            // (NOTE: SetupDiCallClassInstaller also does this when its handling
            // DIF_REGISTER_COINSTALLERS, but since we can't be guaranteed we're
            // being called in the context of SetupDiCallClassInstaller, we have
            // to do this ourselves as well.)
            //
            Err = InvalidateHelperModules(DeviceInfoSet,
                                          DeviceInfoData,
                                          IHM_COINSTALLERS_ONLY
                                         );
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(FreeMsgHandlerContext) {
            SetupTermDefaultQueueCallback(MsgHandlerContext);
        }
        if(CloseUserFileQ) {
            SetupCloseFileQueue(UserFileQ);
        }
        //
        // Reference the following variables so the compiler will respect our statement
        // ordering w.r.t. assignment.
        //
        DeleteDrvRegKey = DeleteDrvRegKey;
        CloseInfHandle = CloseInfHandle;
        OemInfFileToCopy = OemInfFileToCopy;
    }


    if(hkDrv != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkDrv);
        if((Err != NO_ERROR) && DeleteDrvRegKey) {
            SetupDiDeleteDevRegKey(DeviceInfoSet,
                                   DeviceInfoData,
                                   DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGGENERAL,
                                   0,
                                   DIREG_DRV
                                  );
        }
    }

    if(CloseInfHandle) {
        MYASSERT(hDeviceInf != INVALID_HANDLE_VALUE);
        SetupCloseInfFile(hDeviceInf);
    }

clean1:
    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of Success
        //
        WriteLogEntry(
            LogContext,
            DoFullInstall ? DRIVER_LOG_INFO : DRIVER_LOG_VERBOSE,
            MSG_LOG_REGISTEREDCOINSTALLERS,
            NULL);
    } else {
        //
        // indicate failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_REGISTERCOINSTALLERS_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);

        //
        // If we copied the OEM INF into the INF directory under a newly-
        // generated name, delete it now.
        //
        if(OemInfFileToCopy) {
            pSetupUninstallOEMInf(szNewName, LogContext, SUOI_FORCEDELETE, NULL);
        }
    }

    if (slot_section) {
        ReleaseLogInfoSlot(LogContext,slot_section);
    }

    if (pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiSelectBestCompatDrv(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_SELECTBESTCOMPATDRV

    This routine will select the best driver from the device information element's
    compatible driver list.

    This function will enumerate through all of the drivers and find the one with
    the Best Rank (this is the lowest Rank number).  If there are multiple drivers
    with the same Best Rank then we will take the driver with the newest DriverDate.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the element for which the best compatible driver is to be selected.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for
        which the best compatible driver is to be selected.  This element must
        already have a (non-empty) compatible driver list built for it, or this
        API will fail and GetLastError will return ERROR_NO_COMPAT_DRIVERS.

        This is an IN OUT parameter because the class GUID for the device will be
        updated to reflect the class of the selected driver.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    DWORD BestRank, BasicBestRank;
    DWORDLONG BestDriverVersion, BasicBestDriverVersion;
    DWORD MemberIndex;
    INT BestMemberIndex, BasicBestMemberIndex;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err = NO_ERROR;
    PDEVINFO_ELEM DevInfoElem = NULL;
    FILETIME BestDriverDate, BasicBestDriverDate;

    BestRank = BasicBestRank = RANK_NO_MATCH;
    BestMemberIndex = BasicBestMemberIndex = -1;
    BestDriverVersion = BasicBestDriverVersion = 0;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }

    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    if(DeviceInfoData
       && (DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))!=NULL) {
        LogContext = DevInfoElem->InstallParamBlock.LogContext;
    }

    //
    //Enumerate through all of the drivers and find the Best Rank
    //
    MemberIndex = 0;

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    while (SetupDiEnumDriverInfo(DeviceInfoSet,
                                 DeviceInfoData,
                                 SPDIT_COMPATDRIVER,
                                 MemberIndex,
                                 &DriverInfoData)) {

        DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);

        if ((SetupDiGetDriverInstallParams(DeviceInfoSet,
                                           DeviceInfoData,
                                           &DriverInfoData,
                                           &DriverInstallParams))) {

            if(DriverInstallParams.Flags & DNF_BAD_DRIVER) {
                //
                // This driver was marked as bad--we don't want to use it, but
                // we should log an informational message as to why it wasn't
                // considered.
                //
                SP_DRVINFO_DETAIL_DATA Data;
                Data.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

                if(SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                              DeviceInfoData,
                                              &DriverInfoData,
                                              &Data,
                                              Data.cbSize,
                                              NULL) ||
                        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_INFO,
                        MSG_LOG_SELECTBEST_BAD_DRIVER,
                        NULL,
                        Data.DrvDescription,
                        Data.InfFileName,
                        Data.SectionName
                        );
                }

            } else if(DriverInstallParams.Flags & DNF_BASIC_DRIVER) {
                //
                // This driver is flagged as a "basic functionality" driver.
                // We'll keep track of the best such driver we encounter, but
                // we'll only use a basic driver if there exists no non-basic
                // signed drivers.
                //
                if(DriverInstallParams.Rank <= BasicBestRank) {

                    if(BasicBestMemberIndex == -1) {
                        //
                        // This is the first acceptable basic driver we've
                        // encountered...
                        //
                        BasicBestDriverDate = DriverInfoData.DriverDate;
                        BasicBestMemberIndex = (INT)MemberIndex;
                        BasicBestDriverVersion = DriverInfoData.DriverVersion;

                    } else {

                        if((DriverInstallParams.Rank < BasicBestRank) ||
                           (CompareFileTime(&BasicBestDriverDate, &(DriverInfoData.DriverDate)) == -1)) {
                            //
                            // If this new driver has a better (smaller) Rank than
                            // the current Best Driver or it has a newer date then
                            // make it the Best Driver.
                            //
                            BasicBestDriverDate = DriverInfoData.DriverDate;
                            BasicBestMemberIndex = (INT)MemberIndex;
                            BasicBestDriverVersion = DriverInfoData.DriverVersion;
                        } else if ((DriverInstallParams.Rank == BasicBestRank) &&
                                   (CompareFileTime(&BasicBestDriverDate, &(DriverInfoData.DriverDate)) == 0) &&
                                   (DriverInfoData.DriverVersion > BasicBestDriverVersion)) {
                            //
                            // If the Rank and DriverDate of the new driver
                            // are identical to the current Best driver,
                            // then check if the new driver has a newer
                            // DriverVersion and if so make it the Best Driver.
                            //
                            BasicBestDriverDate = DriverInfoData.DriverDate;
                            BasicBestMemberIndex = (INT)MemberIndex;
                            BasicBestDriverVersion = DriverInfoData.DriverVersion;
                        }
                    }

                    BasicBestRank = DriverInstallParams.Rank;
                }

            } else {
                //
                // This isn't a basic driver.  If it's the best one we've seen,
                // remember it.
                //
                if(DriverInstallParams.Rank <= BestRank) {

                    if(BestMemberIndex == -1) {
                        //
                        // This is the first acceptable non-basic driver we've
                        // encountered...
                        //
                        BestDriverDate = DriverInfoData.DriverDate;
                        BestMemberIndex = (INT)MemberIndex;
                        BestDriverVersion = DriverInfoData.DriverVersion;

                    } else {
                        //
                        // If this new driver has a better (smaller) Rank than
                        // the current Best Driver or it has a newer date then
                        // make it the Best Driver.
                        //
                        if((DriverInstallParams.Rank < BestRank) ||
                           (CompareFileTime(&BestDriverDate, &(DriverInfoData.DriverDate)) == -1)) {

                            BestDriverDate = DriverInfoData.DriverDate;
                            BestMemberIndex = (INT)MemberIndex;
                            BestDriverVersion = DriverInfoData.DriverVersion;
                        } else if ((DriverInstallParams.Rank == BestRank) &&
                                   (CompareFileTime(&BestDriverDate, &(DriverInfoData.DriverDate)) == 0) &&
                                   (DriverInfoData.DriverVersion > BestDriverVersion)) {
                            //
                            // If the Rank and DriverDate of the new driver
                            // are identical to the current Best driver,
                            // then check if the new driver has a newer
                            // DriverVersion and if so make it the Best Driver.
                            //
                            BestDriverDate = DriverInfoData.DriverDate;
                            BestMemberIndex = (INT)MemberIndex;
                            BestDriverVersion = DriverInfoData.DriverVersion;
                        }
                    }

                    BestRank = DriverInstallParams.Rank;
                }
            }
        }

        MemberIndex++;
    }

    //
    // If BestRank and BasicBestRank still equal RANK_NO_MATCH then we don't
    // have any compatible drivers
    //
    if((BestRank == RANK_NO_MATCH) && (BasicBestRank == RANK_NO_MATCH)) {
        Err = ERROR_NO_COMPAT_DRIVERS;
        goto clean1;
    }

    //
    // Select best driver from among basic and full-featured offerings as
    // follows:
    //
    // 1.  Full-featured, signed driver
    // 2.  Basic signed driver
    // 3.  Best rank/newest date between full-featured and basic unsigned
    //     driver (note: it will be rare that we encounter a basic unsigned
    //     driver since this will typically be used only for our in-box
    //     offerings, which are always signed)
    //
    if(BestRank < DRIVER_UNTRUSTED_RANK) {
        MemberIndex = (DWORD)BestMemberIndex;
    } else if(BasicBestRank < DRIVER_UNTRUSTED_RANK) {
        MemberIndex = (DWORD)BasicBestMemberIndex;
    } else {

        if(BestRank < BasicBestRank) {
            MemberIndex = (DWORD)BestMemberIndex;
        } else if(BasicBestRank < BestRank) {
            MemberIndex = (DWORD)BasicBestMemberIndex;
        } else {
            //
            // We have both a basic driver and full-featured one, both of which
            // are unsigned, and both of which are equivalently ranked.  Pick
            // the newer one.  In the unlikely event that they're the same
            // date, pick the full-featured one.
            //
            // We have both a basic driver and full-featured one, both of which
            // are unsigned, and both of which are equivalently ranked. If the
            // driver dates are the same,  then pick the one with the newer
            // driver version, otherwise pick the one with the newest date.
            // In the unlikely event that the DriverDate and DriverVersion are
            // the same, pick the full-featured one.
            //
            if (CompareFileTime(&BestDriverDate, &BasicBestDriverDate) == 0) {
                //
                // Driver dates are the same, so take the one with the newest
                // driver version.
                //
                if (BasicBestDriverVersion > BestDriverVersion) {
                    MemberIndex = (DWORD)BasicBestMemberIndex;
                } else {
                    MemberIndex = (DWORD)BestMemberIndex;
                }
            } else if(CompareFileTime(&BestDriverDate, &BasicBestDriverDate) == -1) {
                MemberIndex = (DWORD)BasicBestMemberIndex;
            } else {
                MemberIndex = (DWORD)BestMemberIndex;
            }
        }
    }

    //
    // (Re-)retrieve the driver info data for the best driver we found.
    //
    if(!SetupDiEnumDriverInfo(DeviceInfoSet,
                              DeviceInfoData,
                              SPDIT_COMPATDRIVER,
                              MemberIndex,
                              &DriverInfoData)) {
        //
        // We should never see this error, since we retrieved this driver node
        // just moments ago, and we have the HDEVINFO locked, so no one could
        // have deleted it out from under us.
        //
        Err = GetLastError();
        goto clean1;
    }

    if(!SetupDiSetSelectedDriver(DeviceInfoSet,
                                 DeviceInfoData,
                                 &DriverInfoData)) {
        Err = GetLastError();
    }

clean1:

    if(Err == NO_ERROR) {
        //
        // give a +ve affirmation of Success
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_INFO,
            MSG_LOG_SELECTEDBEST,
            NULL);

        //
        // If we had a basic driver but didn't use it, log an information entry
        //
        if((BasicBestMemberIndex != -1) &&
           (BasicBestMemberIndex != (INT)MemberIndex)) {

            if(SetupDiEnumDriverInfo(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDIT_COMPATDRIVER,
                                     (DWORD)BasicBestMemberIndex,
                                     &DriverInfoData)) {

                SP_DRVINFO_DETAIL_DATA Data;
                Data.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

                if(SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                              DeviceInfoData,
                                              &DriverInfoData,
                                              &Data,
                                              Data.cbSize,
                                              NULL) ||
                        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_INFO,
                        MSG_LOG_SELECTBEST_BASIC_DRIVER_SKIPPED,
                        NULL,
                        Data.DrvDescription,
                        Data.InfFileName,
                        Data.SectionName
                        );
                }
            }
        }

    } else {
        //
        // indicate failed, display error
        //
        WriteLogEntry(
            LogContext,
            ((Err == ERROR_NO_COMPAT_DRIVERS) ?
                DRIVER_LOG_WARNING :
                DRIVER_LOG_ERROR)
             | SETUP_LOG_BUFFER,
            MSG_LOG_SELECTBEST_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            ((Err == ERROR_NO_COMPAT_DRIVERS) ?
                DRIVER_LOG_WARNING :
                DRIVER_LOG_ERROR),
            Err);
    }

    if (pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);

}


BOOL
RetrieveAllDriversForDevice(
    IN  PDEVINFO_ELEM  DevInfoElem,
    OUT PTSTR          *DriverList,
    IN  DWORD          Flags,
    IN  HMACHINE       hMachine
    )
/*++

Routine Description:

    This routine returns a multi-sz list of all filter drivers (both upper and
    lower, class-specific and device-specific) for the specified device information
    element.

Arguments:

    DevInfoElem - Specifies the device information element whose list of filter
        drivers are to be retrieved.

    DriverList - If this routine returns TRUE (i.e., there was at least one
        filter driver for this device), then this pointer is filled in to point
        to a newly-allocated buffer containing a multi-sz list of all filters
        associated with this device.  If we encountered an out-of-memory error,
        this pointer will be set to NULL.

    Flags - can be one of the following:

        RADFD_FLAG_FUNCTION_DRIVER - include the function driver in the
            DriverList return value.

        RADFD_FLAG_DEVICE_UPPER_FILTERS - include the device upper filters in
            the DriverList return value.

        RADFD_FLAG_DEVICE_LOWER_FILTERS - include the device lower filters in
            the DriverList return value.

        RADFD_FLAG_CLASS_UPPER_FILTERS - include the class upper filters in the
            DriverList return value.

        RADFD_FLAG_CLASS_LOWER_FILTERS - include the class lower filters in the
            DriverList return value.

        RADFD_FLAG_DEVICE_FILTERS - include both the device upper and lower
            filters in the DriverList return value.

        RADFD_FLAG_CLASS_FILTERS include both the class upper and lower filters
            in the DriverList return value.


Return Value:

    If there is at least one filter driver for the specified device (or we couldn't
    tell because we ran out of memory), the return value is TRUE.
    Otherwise, it is FALSE.

--*/
{
    PTSTR Buffer, NewBuffer, CurPos, EndPos, p;
    DWORD BufferSize, UsedSize, RequiredSize;
    DWORD i, NumLists, Err;
    CONFIGRET cr;
    DWORD RegDataType;
    HKEY hk;
    ULONG ulProperty;
    DWORD Gap = sizeof(TCHAR)*2; // extra space at end of buffer for nulls

    *DriverList = NULL;

    BufferSize = 1024 * sizeof(TCHAR);  // start out with a reasonably-sized buffer.
    Buffer = MyMalloc(BufferSize+Gap);
    if(Buffer) {
        UsedSize = 0;
        CurPos = Buffer;
    } else {
        //
        // We really don't know whether there were any filters for this device, but
        // if we return TRUE, the NULL DriverList OUT parameter will signal to the
        // caller that we encountered an out-of-memory condition.
        //
        return TRUE;
    }

    //
    // Attempt to open the class key so we can retrieve the class-specific filter lists.
    //
    hk = SetupDiOpenClassRegKey(&(DevInfoElem->ClassGuid), KEY_READ);
    NumLists = (hk == INVALID_HANDLE_VALUE) ? 3 : 5;

    //
    // First, retrieve the UpperFilters and LowerFilters device properties (i.e.,
    // the device-specific filters).
    //
    for(i = 0; i < NumLists; i++) {

        RequiredSize = Gap;

        while(TRUE) {
            //
            // Do we need a larger buffer?
            //
            if((BufferSize<UsedSize) || (RequiredSize > (BufferSize - UsedSize))) {
                BufferSize = UsedSize + RequiredSize;
                NewBuffer = MyRealloc(Buffer, BufferSize+Gap);
                if(NewBuffer) {
                    //
                    // Adjust our current position pointer.
                    //
                    CurPos = NewBuffer + (CurPos - Buffer);
                    Buffer = NewBuffer;
                } else {
                    MyFree(Buffer);
                    if(hk != INVALID_HANDLE_VALUE) {
                        RegCloseKey(hk);
                    }
                    return TRUE;
                }
            } else {
                RequiredSize = BufferSize - UsedSize;
            }

            if(i < 3) {
                //
                // Then we're retrieving the device-specific lists.
                //
                if (i == 0) {
                    //
                    // Check to see if we need to include the function driver
                    //
                    if (!(Flags & RADFD_FLAG_FUNCTION_DRIVER)) {
                        //
                        // Skip the function driver.
                        //
                        break;
                    }
                    ulProperty = CM_DRP_SERVICE;
                } else if (i == 1) {
                    //
                    // Check to see if we need to include the device lower filters.
                    //
                    if (!(Flags & RADFD_FLAG_DEVICE_LOWER_FILTERS)) {
                        //
                        // Skip the device lower filters.
                        //
                        break;
                    }
                    ulProperty = CM_DRP_LOWERFILTERS;
                } else {
                    //
                    // Check to see if we need to include the device upper filters.
                    //
                    if (!(Flags & RADFD_FLAG_DEVICE_UPPER_FILTERS)) {
                        //
                        // Skip the device upper filters.
                        //
                        break;
                    }
                    ulProperty = CM_DRP_UPPERFILTERS;
                }

                cr = CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                         ulProperty,
                                                         NULL,
                                                         CurPos,
                                                         &RequiredSize,
                                                         0,
                                                         hMachine
                                                        );
                //
                // Map the CONFIGRET code to Win32 error codes that mimic the
                // behavior of the registry APIs.  This way, we can have common
                // handling of the error codes down below...
                //
                switch(cr) {
                    case CR_SUCCESS :
                        Err = ERROR_SUCCESS;
                        break;

                    case CR_BUFFER_SMALL :
                        Err = ERROR_MORE_DATA;
                        break;

                    default :
                        Err = ERROR_INVALID_DATA; // any old error will do.
                        break;
                }

            } else {
                //
                // We're retrieving the class-specific lists.
                //
                if (i == 3) {
                    //
                    // Check to see if we need to include the class lower filters
                    //
                    if (!(Flags & RADFD_FLAG_CLASS_LOWER_FILTERS)) {
                        //
                        // Skip the class lower filters.
                        //
                        break;
                    }
                } else {
                    //
                    // Check to see if we need to include the class upper filters.
                    //
                    if (!(Flags & RADFD_FLAG_CLASS_UPPER_FILTERS)) {
                        //
                        // Skip the class upper filters.
                        //
                        break;
                    }
                }

                Err = RegQueryValueEx(hk,
                                      ((i == 3) ? pszLowerFilters : pszUpperFilters),
                                      NULL,
                                      &RegDataType,
                                      (PBYTE)CurPos,
                                      &RequiredSize
                                      );
            }

            if(Err == ERROR_SUCCESS) {
                //
                // Walk through the service names in the multi-sz list we just retrieved to find
                // the end (just in case someone screwed up when saving out this list and didn't
                // size it properly, etc.)
                //
                // we made sure we have space for a couple of extra nulls (Gap)
                // so add them here
                // this covers all the bad string termination cases
                // it also covers the case where we're given a REG_SZ instead
                // of REG_MULTI_SZ
                //
                p = CurPos;
                EndPos = CurPos+(RequiredSize/sizeof(TCHAR));
                ZeroMemory(EndPos,Gap);

                try {

                    while(*CurPos) {

                        CurPos += _tcslen(CurPos)+1;
                        p = CurPos;
                    }

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    MYASSERT(CurPos != p);
                    CurPos = p;
                    *CurPos = TEXT('\0');
                }

                UsedSize = (DWORD)((PBYTE)CurPos - (PBYTE)Buffer) + sizeof(TCHAR);

                MYASSERT(UsedSize <= (BufferSize+Gap));

                break;

            } else if(Err != ERROR_MORE_DATA) {
                //
                // We failed for some reason other than buffer-too-small.  Move
                // on to the next filter driver list.
                //
                break;
            }
        }
    }

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    if(UsedSize) {
        //
        // We retrieved a list of services to return to the caller.
        //
        *DriverList = Buffer;
        return TRUE;
    }

    MYASSERT(Buffer);
    MyFree(Buffer);

    return FALSE;
}


BOOL
RetrieveAllDevNodesSharingDriversWithDevice(
    IN  PDEVINFO_ELEM  DevInfoElem,
    OUT PTSTR          *Drivers,
    OUT PDEVNODE       *DevNodes,
    OUT ULONG          *NumberOfDevNodes,
    IN  HMACHINE       hMachine
    )
/*++

Routine Description:

    This routine returns a multi-sz list of all the devnodes that share a
    driver with the specified device. This includes the device's function driver
    and all filter drivers (both upper and lower, class-specific and device-
    specific).

    This routine returns a multi-sz list of all filter drivers (both upper and
    lower device-specific) for the specified device information
    element.

Arguments:

    DevInfoElem - Specifies the device information element.

    Drivers -

    DevNodes -

    NumberOfDevNodes -

Return Value:

    TRUE unless there is an unexpected error such as out of memory.

--*/
{
    DWORD Err = ERROR_SUCCESS;
    PTSTR p, Buffer = NULL;
    ULONG BufferSize = 1024;
    PTSTR DriversList = NULL, CurDriver;
    DEVNODE DevNode;
    PDEVNODE NewBuffer, ArrayOfDevNodes;
    ULONG DevNodeArraySize = 10;
    ULONG i;
    CONFIGRET cr;

    *NumberOfDevNodes = 0;

    try {
        //
        // Allocate an array of devnodes.  Start with 10 and we will grow it below
        // if we have more.
        //
        if ((ArrayOfDevNodes = MyMalloc(DevNodeArraySize * sizeof(DEVNODE))) == NULL) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Always include the devnode that was passed in.
        //
        ArrayOfDevNodes[*NumberOfDevNodes] = DevInfoElem->DevInst;
        (*NumberOfDevNodes)++;

        //
        // Now get a list of all the filter drivers (both upper and lower
        // device-specific) that this device is using and
        // then add any devnode using one of these services to our list.
        //
        if (RetrieveAllDriversForDevice(DevInfoElem,
                                        &DriversList,
                                        RADFD_FLAG_FUNCTION_DRIVER | RADFD_FLAG_DEVICE_FILTERS,
                                        hMachine)) {
            //
            // We need a buffer when we call CM_Get_Device_ID_list_Ex, we will
            // start with a 1024 buffer and grow it as needed.
            //
            Buffer = MyMalloc(BufferSize * sizeof(TCHAR));
            if (!Buffer) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            //
            // Enumerate through all the filters and build up a list of drivers
            // they are using.
            //
            for (CurDriver=DriversList; *CurDriver; CurDriver+=(lstrlen(CurDriver)+1)) {
                while ((cr = CM_Get_Device_ID_List_Ex(
                                            CurDriver,
                                            Buffer,
                                            BufferSize,
                                            CM_GETIDLIST_FILTER_SERVICE |
                                            CM_GETIDLIST_DONOTGENERATE,
                                            hMachine
                                            )) == CR_BUFFER_SMALL) {
                    //
                    // If the buffer is too small then we need to reallocate a
                    // larger one.
                    //
                    PTSTR TempBuffer;

                    CM_Get_Device_ID_List_Size_Ex(&BufferSize,
                                                  CurDriver,
                                                  CM_GETIDLIST_FILTER_SERVICE,
                                                  hMachine);

                    TempBuffer = MyRealloc(Buffer, BufferSize * sizeof(TCHAR));

                    if (TempBuffer) {
                        Buffer = TempBuffer;
                    } else {
                        //
                        // We couldn't create a larger buffer!
                        //
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
                }

                if (cr == CR_SUCCESS) {
                    //
                    // Enumerate through all the device instance Ids and add them
                    // to the list of devnodes.
                    //
                    for (p=Buffer; *p; p+=(lstrlen(p)+1)) {
                        if (CM_Locate_DevInst_Ex(&DevNode,
                                                 p,
                                                 0,
                                                 hMachine
                                                 ) == CR_SUCCESS) {
                            //
                            // Check to see if this devnode already exists in
                            // our list.
                            //
                            for (i=0; i<*NumberOfDevNodes; i++) {
                                if (ArrayOfDevNodes[i] == DevNode) {
                                    break;
                                }
                            }

                            if (i == *NumberOfDevNodes) {
                                //
                                // Check to see if we need to increase our devnode array.
                                //
                                if (DevNodeArraySize <= *NumberOfDevNodes) {
                                    DevNodeArraySize += 10;
                                    NewBuffer = MyRealloc(ArrayOfDevNodes, DevNodeArraySize * sizeof(DEVNODE));

                                    if (NewBuffer) {
                                        ArrayOfDevNodes = NewBuffer;
                                    } else {
                                        Err = ERROR_NOT_ENOUGH_MEMORY;
                                        goto clean0;
                                    }
                                }

                                ArrayOfDevNodes[*NumberOfDevNodes] = DevNode;
                                (*NumberOfDevNodes)++;
                            }
                        }
                    }
                } else {
                    //
                    // We got another error back so we will fail.
                    //
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        //
        // Access the following variables, so that the compiler will respect our
        // statement ordering w.r.t. their assignment.
        //
        Buffer = Buffer;
        ArrayOfDevNodes = ArrayOfDevNodes;
        DriversList = DriversList;
    }

clean0:

    if (Buffer) {
        MyFree(Buffer);
    }

    if (Err == ERROR_SUCCESS) {
        *DevNodes = ArrayOfDevNodes;
        *Drivers = DriversList;
    } else {
        //
        // If we failed then free all the memory and set the pointers
        // to NULL.
        //
        if (ArrayOfDevNodes) {
            MyFree(ArrayOfDevNodes);
            *DevNodes = NULL;
        }

        if (DriversList) {
            MyFree(DriversList);
            *Drivers = NULL;
        }
    }

    return (Err == ERROR_SUCCESS);
}


BOOL
AnyServicesLoaded(
    IN  PCTSTR              ServiceNameList,
    OUT PTSTR               LoadedService,      OPTIONAL
    IN  ULONG               LoadedServiceSize
    )
/*++

Routine Description:

    This routine will determine if any of the services passed in our currently
    loaded.

Arguments:

    ServiceNameList - multi-sz list of service names.

    LoadedService - buffer that will receive the service the first service in
        the list that is still loaded into memory. This value is only valid
        if the API returns TRUE.

    LoadedServiceSize - size of the LoadedService buffer.

Return Value:

    TRUE if any of the services in the list are loaded, FALSE if none of them
    are currently loaded.

--*/
{
    NTSTATUS Status;
    BOOL bObjectIsLoaded = FALSE;
    DWORD BufSize = 1024;
    PUCHAR Buffer = NULL;
    UNICODE_STRING UnicodeStringDriver;
    UNICODE_STRING UnicodeStringService;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle = INVALID_HANDLE_VALUE;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    ULONG Context = 0;
    ULONG ReturnedLength;
    PTSTR CurServiceName;

    try {

        if (LoadedService) {
            LoadedService[0] = TEXT('\0');
        }

        //
        // If no services were passed in then just leave.
        //
        if (!ServiceNameList) {
            goto clean0;
        }

        Buffer = MyMalloc(BufSize);

        if (!Buffer) {
            goto clean0;
        }

        ZeroMemory(Buffer, BufSize);

        RtlInitUnicodeString(&UnicodeStringDriver, TEXT("\\Driver"));

        InitializeObjectAttributes(&Attributes,
                                   &UnicodeStringDriver,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                   );

        Status = NtOpenDirectoryObject(&DirectoryHandle,
                                       DIRECTORY_QUERY,
                                       &Attributes
                                       );

        if (!NT_SUCCESS(Status)) {
            goto clean0;
        }

        //
        // Get the actual name of the object directory object.
        //
        NameInfo = (POBJECT_NAME_INFORMATION)Buffer;
        if (!NT_SUCCESS(Status = NtQueryObject(DirectoryHandle,
                                               ObjectNameInformation,
                                               NameInfo,
                                               BufSize,
                                               (PULONG)NULL))) {
            goto clean0;
        }

        //
        // Grab the driver objects in chuncks instead of one at a time.
        //
        for (Status = NtQueryDirectoryObject(DirectoryHandle,
                                             Buffer,
                                             BufSize,
                                             FALSE,
                                             FALSE,
                                             &Context,
                                             &ReturnedLength
                                             );
             NT_SUCCESS(Status) && !bObjectIsLoaded;
             Status = NtQueryDirectoryObject(DirectoryHandle,
                                             Buffer,
                                             BufSize,
                                             FALSE,
                                             FALSE,
                                             &Context,
                                             &ReturnedLength
                                             )) {
            if (!NT_SUCCESS(Status)) {
                break;
            }

            DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

            while (TRUE) {
                //
                // Check if there is another record. If there isn't, then get out
                // of the loop now.
                //
                if (DirInfo->Name.Length == 0) {
                    break;
                }

                for (CurServiceName=(PTSTR)ServiceNameList;
                     *CurServiceName;
                     CurServiceName+=(lstrlen(CurServiceName)+1)) {

                    RtlInitUnicodeString(&UnicodeStringService, CurServiceName);

                    if (RtlCompareUnicodeString(&UnicodeStringService, &(DirInfo->Name), TRUE) == 0) {
                        bObjectIsLoaded = TRUE;

                        if (LoadedService) {
                            MYVERIFY(SUCCEEDED(StringCchCopy(LoadedService,
                                                             LoadedServiceSize,
                                                             CurServiceName)));
                        }

                        break;
                    }
                }

                //
                // If one of the drivers is loaded then just stop now.
                //
                if (bObjectIsLoaded) {
                    break;
                }

                DirInfo = (POBJECT_DIRECTORY_INFORMATION)(((PUCHAR)DirInfo) +
                                                          sizeof(OBJECT_DIRECTORY_INFORMATION));
            }

            ZeroMemory(Buffer, BufSize);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        bObjectIsLoaded = TRUE;

        //
        // Access the following variables, so that the compiler will respect our
        // statement ordering w.r.t. their assignment.
        //
        Buffer = Buffer;
    }

clean0:
    if (DirectoryHandle != INVALID_HANDLE_VALUE) {
        NtClose(DirectoryHandle);
    }

    if (Buffer) {
        MyFree(Buffer);
    }

    return bObjectIsLoaded;
}

VOID
RestartSingleDevice(
    IN  PDEVINFO_ELEM       DevInfoElem,
    IN  PDEVICE_INFO_SET    pDeviceInfoSet,
    IN  BOOL                NullDriverInstall,
    IN  PSETUP_LOG_CONTEXT  LogContext
    )
/*++

Routine Description:


Arguments:

    DevInfoElem -

    pDeviceInfoSet -

    NullDriverInstall -

    LogContext -

Return Value:


--*/
{
    DWORD DevInstCapabilities;
    ULONG cbData;
    ULONG ulStatus, ulProblem;
    TCHAR DeviceFullID[MAX_DEVICE_ID_LEN];

    //
    // Retrieve the device's capabilities.  We need to know whether the device is
    // capable of being driven 'raw' (i.e., without a function driver).
    //
    cbData = sizeof(DevInstCapabilities);
    if(CR_SUCCESS != CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                      CM_DRP_CAPABILITIES,
                                                      NULL,
                                                      &DevInstCapabilities,
                                                      &cbData,
                                                      0,
                                                      pDeviceInfoSet->hMachine))
    {
        DevInstCapabilities = 0;
    }

    //
    // If the device instance has a problem but is not disabled. Just
    // restart it. This should be 90% of the cases.
    //
    if((CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevInfoElem->DevInst,
                                 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
       ((ulStatus & DN_HAS_PROBLEM) || !(ulStatus & DN_DRIVER_LOADED))) {

        //
        // Poke at Config Manager to make it load the driver.
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_BEGIN_RESTART_TIME,
            NULL);       // text message

        CM_Setup_DevInst_Ex(DevInfoElem->DevInst, CM_SETUP_DEVINST_READY, pDeviceInfoSet->hMachine);

        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_END_RESTART_TIME,
            NULL);       // text message

        //
        // If we're installing a 'real' driver (i.e., not null), or if the device is
        // raw-capable, then we want to check and see if the device actually started as
        // a result of CM_Setup_DevInst.  If not, a reboot is in order.  (There's no need
        // to check when we're doing a null driver install for a non-raw devnode.  We know
        // it can't start, and we definitely don't want to generate a 'need reboot' popup
        // in this case!)
        //
        if(!NullDriverInstall || (DevInstCapabilities & CM_DEVCAP_RAWDEVICEOK)) {
            CheckIfDevStarted(DevInfoElem, pDeviceInfoSet);
        }

    } else {

        CONFIGRET cr;
        TCHAR VetoName[MAX_PATH];
        PNP_VETO_TYPE VetoType;

        //
        // If there is a device instance with no problem, then we
        // should remove it (to unload the current drivers off of
        // it), and then call CM_Setup_DevInst on it.  If the
        // device instance refuses to remove, then set the flags
        // that say we need to reboot.
        //
        // NOTE:  In Win9x, virtual removal of a devnode (e.g., to
        // unload the driver(s) for it), resulted in the devnode's
        // deletion.  Thus, on Win9x, it was necessary to
        // re-enumerate the devnode's parent to cause the devnode
        // to be re-created (and subsequently started).  This is
        // inefficient, especially if we're dealing with a root-
        // enumerated device (hence requiring a reenumeration of
        // the entire tree).  Since the device installer
        // functionality of setupapi will apparently never be used
        // on Win9x, we can optimize this such that we just call
        // CM_Setup_DevInst on this devnode.  We know it didn't
        // actually go away, because devnodes only go away on NT
        // when their underlying hardware is physically removed.
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_BEGIN_REMOVE_TIME,
            NULL);       // text message

        cr = CM_Query_And_Remove_SubTree_Ex(DevInfoElem->DevInst,
                                            &VetoType,
                                            VetoName,
                                            SIZECHARS(VetoName),
                                            (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                ? CM_REMOVE_UI_NOT_OK
                                                : CM_REMOVE_UI_OK,
                                            pDeviceInfoSet->hMachine
                                           );


        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_END_REMOVE_TIME,
            NULL);       // text message

        if(cr == CR_SUCCESS) {
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_BEGIN_RESTART_TIME,
                NULL);       // text message

            CM_Setup_DevInst_Ex(DevInfoElem->DevInst,
                                CM_SETUP_DEVINST_READY,
                                pDeviceInfoSet->hMachine
                               );

            WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_END_RESTART_TIME,
                NULL);       // text message


            //
            // If we're installing a 'real' driver (i.e., not null),
            // or if the device is raw-capable, then we want to
            // check and see if the device actually started as a
            // result of CM_Setup_DevInst.  If not, a reboot is in
            // order.  (There's no need to check when we're doing a
            // null driver install for a non-raw devnode.  We know
            // it can't start, and we definitely don't want to
            // generate a 'need reboot' popup in this case!)
            //
            if(!NullDriverInstall || (DevInstCapabilities & CM_DEVCAP_RAWDEVICEOK)) {

                CheckIfDevStarted(DevInfoElem,pDeviceInfoSet);
            }
        } else {
            //
            // If the failure was due to a veto, then log
            // information about who vetoed us.
            //
            // SPLOG-- write out a log entry
            //
            if(cr == CR_REMOVE_VETOED) {
                if( CM_Get_Device_ID(DevInfoElem->DevInst,
                                 DeviceFullID,
                                 SIZECHARS(DeviceFullID),
                                 0
                                ) == CR_SUCCESS ) {
                    _WriteVetoLogEntry(
                        LogContext,
                        DRIVER_LOG_WARNING,
                        MSG_LOG_REMOVE_VETOED_IN_INSTALL,
                        DeviceFullID,
                        VetoName,
                        VetoType);
                }
            }

            //
            // If the failure was due to the device not being there,
            // then prompting for reboot isn't going to help
            // anything (plus, you can't set a problem on a non-
            // existent devnode anyway).  This could happen, for
            // example, if the user plugged in a USB mouse, then
            // unplugged it again before we got a chance to
            // complete the device installation.  In this case,
            // we'll just ignore the failure and continue on.
            //
            if(cr != CR_INVALID_DEVNODE) {

                SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,
                                                     pDeviceInfoSet,
                                                     MSG_LOG_REBOOT_REASON_QR_VETOED,
                                                     cr,
                                                     (ULONG_PTR)_MapCmRetToString(cr)
                                                     );
            }
        }
    }
}


VOID
RestartAllDevicesUsingDrivers(
    IN  PDEVINFO_ELEM       DevInfoElem,
    IN  PDEVICE_INFO_SET    pDeviceInfoSet,
    IN  BOOL                NullDriverInstall,
    IN  PSETUP_LOG_CONTEXT  LogContext
    )
/*++

Routine Description:


Arguments:

    DevInfoElem -

    pDeviceInfoSet -

    NullDriverInstall -

    LogContext -

Return Value:


--*/
{
    BOOL bNeedReboot = FALSE;
    PTSTR CurDriver, DriverList = NULL;
    PDEVNODE DevNodeList = NULL;
    ULONG NumberOfDevNodes, LastDevNodeStopped, i;
    ULONG ulStatus, ulProblem;
    PBOOL DevNodeStartedList = NULL;
    TCHAR DeviceFullID[MAX_DEVICE_ID_LEN];
    TCHAR LoadedService[MAX_SERVICE_NAME_LEN];
    CONFIGRET cr;

    try {
        if (RetrieveAllDevNodesSharingDriversWithDevice(DevInfoElem,
                                                        &DriverList,
                                                        &DevNodeList,
                                                        &NumberOfDevNodes,
                                                        pDeviceInfoSet->hMachine)) {
            //
            // Allocate an array of BOOLs so we can remember if each devnode was
            // started before we tried to unload all of the drivers.
            //
            if (NumberOfDevNodes) {
                DevNodeStartedList = MyMalloc(NumberOfDevNodes * sizeof(BOOL));
                if (!DevNodeStartedList) {
                    bNeedReboot = TRUE;
                    goto clean0;
                }
            }

            //
            // First we will enumerate through all of the devices and remember
            // if they were started before we remove/restart them all.  We need
            // to do this step first since we don't have any devnode dependency
            // information so stopping the first one could affect one of the
            // others in the list.
            //
            for (i=0; i<NumberOfDevNodes; i++) {
                if((CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevNodeList[i],
                                             0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                   (!(ulStatus & DN_HAS_PROBLEM) && (ulStatus & DN_DRIVER_LOADED))) {

                    DevNodeStartedList[i] = TRUE;
                } else {
                    DevNodeStartedList[i] = FALSE;
                }
            }

            //
            // Next stop all of the devnodes that are using one of the drivers
            // associated with our new device.
            //
            for (i=0; i<NumberOfDevNodes; i++) {
                //
                // Remember the last devnode that we tried to stop.
                //
                LastDevNodeStopped = i;

                if(CM_Get_Device_ID(DevNodeList[i],
                                    DeviceFullID,
                                    SIZECHARS(DeviceFullID),
                                    0
                                    ) != CR_SUCCESS ) {
                    DeviceFullID[0] = TEXT('\0');
                }

                //
                // Only attempt to stop the device if it is currently started.
                //
                if((CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevNodeList[i],
                                             0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                   (!(ulStatus & DN_HAS_PROBLEM) && (ulStatus & DN_DRIVER_LOADED))) {
                    //
                    // Since the devnode is started we need to query remove it.
                    //
                    TCHAR VetoName[MAX_PATH];
                    PNP_VETO_TYPE VetoType;

                    //
                    // Remove the devnode (to unload the current drivers off of
                    // it).  If the device instance refuses to remove, then set
                    // the flags that say we need to reboot.
                    //
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_BEGIN_REMOVE_TIME_DEVICE,
                        NULL,
                        DeviceFullID);

                    cr = CM_Query_And_Remove_SubTree_Ex(DevNodeList[i],
                                                        &VetoType,
                                                        VetoName,
                                                        SIZECHARS(VetoName),
                                                        CM_REMOVE_NO_RESTART |
                                                        ((DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                            ? CM_REMOVE_UI_NOT_OK
                                                            : CM_REMOVE_UI_OK),
                                                        pDeviceInfoSet->hMachine
                                                       );


                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_END_REMOVE_TIME_DEVICE,
                        NULL,
                        DeviceFullID);

                    if(cr != CR_SUCCESS) {
                        //
                        // If the failure was due to a veto, then log
                        // information about who vetoed us.
                        //
                        // SPLOG-- write out a log entry
                        //
                        if(cr == CR_REMOVE_VETOED) {
                            _WriteVetoLogEntry(
                                LogContext,
                                DRIVER_LOG_WARNING,
                                MSG_LOG_REMOVE_VETOED_IN_INSTALL,
                                DeviceFullID,
                                VetoName,
                                VetoType);
                        }

                        //
                        // If the failure was due to the device not being there,
                        // then prompting for reboot isn't going to help
                        // anything (plus, you can't set a problem on a non-
                        // existent devnode anyway).  This could happen, for
                        // example, if the user plugged in a USB mouse, then
                        // unplugged it again before we got a chance to
                        // complete the device installation.  In this case,
                        // we'll just ignore the failure and continue on.
                        //
                        if(cr != CR_INVALID_DEVNODE) {

                            bNeedReboot = TRUE;

                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_WARNING,  // should this be a warning?
                                MSG_LOG_REBOOT_REASON_QR_VETOED,
                                NULL,
                                cr,
                                (ULONG_PTR)_MapCmRetToString(cr),
                                DeviceFullID);
                        }
                    }
                }

                //
                // Don't bother stopping the rest of the drivers if we need a reboot
                //
                if (bNeedReboot) {
                    break;
                }
            }

            if (!bNeedReboot) {
                //
                // Verify that all of the drivers have unloaded.  If just one did not
                // unload then we need to prompt for a reboot.
                //
                if (AnyServicesLoaded(DriverList, LoadedService, SIZECHARS(LoadedService))) {
                    bNeedReboot = TRUE;

                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_WARNING,
                        MSG_LOG_REBOOT_REASON_DRIVER_LOADED,
                        NULL,
                        LoadedService);
                }
            }

            //
            // Now start up all the devices that we stopped.
            //
            for (i=0; i<=LastDevNodeStopped; i++) {
                if(CM_Get_Device_ID(DevNodeList[i],
                                    DeviceFullID,
                                    SIZECHARS(DeviceFullID),
                                    0
                                    ) != CR_SUCCESS ) {
                    DeviceFullID[0] = TEXT('\0');
                }

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_TIME,
                    MSG_LOG_BEGIN_RESTART_TIME_DEVICE,
                    NULL,
                    DeviceFullID);

                CM_Setup_DevInst_Ex(DevNodeList[i],
                                    CM_SETUP_DEVNODE_READY,
                                    pDeviceInfoSet->hMachine);

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_TIME,
                    MSG_LOG_END_RESTART_TIME_DEVICE,
                    NULL,
                    DeviceFullID);
            }

            //
            // Finally make one last pass through all the devnodes and verify
            // that the ones that were started initially are started now.
            // If the devnode wasn't started initially then it is OK that it
            // isn't started now.
            //
            // This last pass can be skipped if we already need a reboot, since
            // it is simply a verification pass.
            //
            if (!bNeedReboot) {
                for (i=0; i<NumberOfDevNodes; i++) {
                    if (DevNodeStartedList[i]) {
                        if(CM_Get_Device_ID(DevNodeList[i],
                                            DeviceFullID,
                                            SIZECHARS(DeviceFullID),
                                            0
                                            ) != CR_SUCCESS ) {
                            DeviceFullID[0] = TEXT('\0');
                        }

                        if ((cr = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem, DevNodeList[i],
                                                      0, pDeviceInfoSet->hMachine)) == CR_SUCCESS) {
                            if (!(ulStatus & DN_STARTED)) {
                                //
                                // This device was started before and now it isn't started,
                                // so a reboot is needed.
                                //
                                bNeedReboot = TRUE;

                                if (ulStatus & DN_HAS_PROBLEM) {
                                    //
                                    // The device now has a problem when it was
                                    // working fine before.  Log the problem.
                                    //
                                    WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_WARNING,
                                        MSG_LOG_REBOOT_REASON_DEVHASPROBLEM,
                                        NULL,
                                        (DWORD)ulProblem,
                                        _MapCmProbToString((DWORD)ulProblem),
                                        DeviceFullID);
                                } else if (ulStatus & DN_PRIVATE_PROBLEM) {
                                    //
                                    // some private problem, change into need reboot
                                    // and log private problem
                                    //
                                    WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_WARNING,
                                        MSG_LOG_REBOOT_REASON_PRIVATEPROBLEM,
                                        NULL,
                                        NULL,
                                        NULL,
                                        DeviceFullID);
                                } else {
                                    //
                                    // not started for some other reason
                                    // indicate reboot required and log this issue
                                    //
                                    WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_WARNING,
                                        MSG_LOG_REBOOT_REASON_NOTSTARTED,
                                        NULL,
                                        NULL,
                                        NULL,
                                        DeviceFullID);
                                }
                            }
                        } else {
                            bNeedReboot = TRUE;

                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_WARNING,
                                MSG_LOG_REBOOT_REASON_DEVHASPROBLEM,
                                NULL,
                                cr,
                                (ULONG_PTR)_MapCmRetToString(cr),
                                DeviceFullID);
                        }
                    }
                }
            }
        } else {
            //
            // If we can't get the list of drivers for some reason then just
            // set the needs reboot flag.
            //
            bNeedReboot = TRUE;
        }

        if (!bNeedReboot) {
            //
            // At this point we need to check that the device that we just installed
            // is actually started, unless it is a NULL driver install.
            //
            DWORD DevInstCapabilities;
            ULONG cbData;

            cbData = sizeof(DevInstCapabilities);
            if(CR_SUCCESS != CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                              CM_DRP_CAPABILITIES,
                                                              NULL,
                                                              &DevInstCapabilities,
                                                              &cbData,
                                                              0,
                                                              pDeviceInfoSet->hMachine))
            {
                DevInstCapabilities = 0;
            }

            if(!NullDriverInstall || (DevInstCapabilities & CM_DEVCAP_RAWDEVICEOK)) {

                CheckIfDevStarted(DevInfoElem,pDeviceInfoSet);
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        bNeedReboot = TRUE;

        //
        // Access the following variables, so that the compiler will respect our
        // statement ordering w.r.t. their assignment.
        //
        DriverList = DriverList;
        DevNodeList = DevNodeList;
        DevNodeStartedList = DevNodeStartedList;
    }

clean0:



    if (DriverList) {
        MyFree(DriverList);
    }

    if (DevNodeList) {
        MyFree(DevNodeList);
    }

    if (DevNodeStartedList) {
        MyFree(DevNodeStartedList);
    }

    if (bNeedReboot) {
        CM_Set_DevInst_Problem_Ex(DevInfoElem->DevInst,
                                  CM_PROB_NEED_RESTART,
                                  CM_SET_DEVINST_PROBLEM_OVERRIDE,
                                  pDeviceInfoSet->hMachine);
    }
}



VOID
AppendLoadIncludedInfs(
    IN HINF   hDeviceInf,
    IN PCTSTR InfFileName,
    IN PCTSTR InfSectionName,
    IN BOOL   AppendLayoutInfs
    )
/*++

Routine Description:

    This routine processes the "include=" line in the specified section of the
    specified INF.  For each filename entry on this line, it attempts to append-load
    that file to the supplied INF (first, from the location where the original INF
    was located, and if that fails, then using the default INF search path).

Arguments:

    hDeviceInf - supplies a handle to the INF containing the section specified by
        InfSectionName.  Upon return, this INF handle will also contain any additional
        INFs that were append-loaded based on INFs listed in the "include=" entry of
        the InfSectionName section.

    InfFileName - supplies the full path of the INF whose handle was supplied in
        the hDeviceInf parameter.  The path component is used in an attempt to first
        locate the specified included INFs in the same location as that of the original
        INF.

    InfSectionName - supplies the name of the section containing an "include=" line
        whose fields are simply filenames of INFs to be append loaded to the original
        INF whose handle is supplied in the hDeviceInf parameter.

    AppendLayoutInfs - if non-zero (TRUE), then we will attempt to append-load the
        corresponding layout INF for each included INF.

Return Value:

    none.

--*/
{
    TCHAR DefaultInfPath[MAX_PATH];
    PTSTR FileNamePos;
    INFCONTEXT InfContext;
    DWORD FieldIndex;
    BOOL b;

    //
    // Store the full directory path to where the supplied INF is located, so we
    // can first attempt to append-load the included INFs from that same directory.
    //
    MYVERIFY(SUCCEEDED(StringCchCopy(DefaultInfPath,
                                     SIZECHARS(DefaultInfPath),
                                     InfFileName)));
    FileNamePos = (PTSTR)pSetupGetFileTitle(DefaultInfPath);

    if(SetupFindFirstLine(hDeviceInf, InfSectionName, TEXT("include"), &InfContext)) {

        for(FieldIndex = 1;
            SetupGetStringField(&InfContext,
                                FieldIndex,
                                FileNamePos,
                                (DWORD)((DefaultInfPath + SIZECHARS(DefaultInfPath)) - FileNamePos),
                                NULL);
            FieldIndex++)
        {
            //
            // Try full path and if that fails just use the inf name
            // and let the open routine try to locate the inf.
            // Ignore errors. We'll catch them later, during the install phases.
            //
            b = SetupOpenAppendInfFile(DefaultInfPath, hDeviceInf, NULL);
            if(!b) {
                b = SetupOpenAppendInfFile(FileNamePos, hDeviceInf, NULL);
            }

            //
            // If we successfully append-loaded the included INF, and if we're also
            // supposed to be append-loading any associated layout INFs, then do that
            // now.
            //
            if(b && AppendLayoutInfs) {
                SetupOpenAppendInfFile(NULL, hDeviceInf, NULL);
            }
        }
    }
}


DWORD
InstallFromInfSectionAndNeededSections(
    IN HWND              Owner,             OPTIONAL
    IN HINF              InfHandle,
    IN PCTSTR            SectionName,
    IN UINT              Flags,
    IN HKEY              RelativeKeyRoot,   OPTIONAL
    IN PCTSTR            SourceRootPath,    OPTIONAL
    IN UINT              CopyFlags,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID             Context,           OPTIONAL
    IN HDEVINFO          DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA  DeviceInfoData,    OPTIONAL
    IN HSPFILEQ          UserFileQ          OPTIONAL
    )
/*++

Routine Description:

    This routine calls SetupInstallFromInfSection for the specified install section,
    as well as for any additional sections specified in a "needs=" line contained in
    that section.

Arguments:

    Same as for SetupInstallFromInfSection, except for UserFileQ.  If UserFileQ is
    non-NULL, then we will only install files (via pSetupInstallFiles) using this
    file queue.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code
    indicating the cause of the failure.

--*/
{
    DWORD FieldIndex, Err;
    INFCONTEXT InfContext;
    BOOL NeedsEntriesToProcess;
    TCHAR SectionToInstall[MAX_SECT_NAME_LEN];

    MYVERIFY(SUCCEEDED(StringCchCopy(SectionToInstall,
                                     SIZECHARS(SectionToInstall),
                                     SectionName)));

    NeedsEntriesToProcess = SetupFindFirstLine(InfHandle,
                                               SectionName,
                                               TEXT("needs"),
                                               &InfContext
                                              );

    Err = NO_ERROR;

    for(FieldIndex = 0; (!FieldIndex || NeedsEntriesToProcess); FieldIndex++) {

        if(FieldIndex) {
            //
            // Get next section name on "needs=" line to be processed.
            //
            if(!SetupGetStringField(&InfContext,
                                    FieldIndex,
                                    SectionToInstall,
                                    SIZECHARS(SectionToInstall),
                                    NULL)) {
                //
                // We've exhausted all the extra sections we needed to install.
                //
                break;
            }
        }

        if(UserFileQ) {
            //
            // The caller supplied their own file queue, so all we can do is copy
            // files.  Make sure that file copying is all they want, and that they
            // gave us a valid file queue handle.
            //
            MYASSERT(Flags == SPINST_FILES);
            MYASSERT(UserFileQ != INVALID_HANDLE_VALUE);

            Err = pSetupInstallFiles(InfHandle,
                                     NULL,
                                     SectionToInstall,
                                     SourceRootPath,
                                     MsgHandler,
                                     Context,
                                     CopyFlags,
                                     Owner,
                                     UserFileQ,
                                     TRUE
                                    );

        } else {
            //
            // The caller didn't supply their own file queue, so we can just use
            // SetupInstallFromInfSection.
            //
            if(!_SetupInstallFromInfSection(Owner,
                                            InfHandle,
                                            SectionToInstall,
                                            Flags,
                                            RelativeKeyRoot,
                                            SourceRootPath,
                                            CopyFlags,
                                            MsgHandler,
                                            Context,
                                            DeviceInfoSet,
                                            DeviceInfoData,
                                            TRUE,
                                            NULL)) {
                Err = GetLastError();
                break;
            }
        }
    }

    return Err;
}

DWORD
pSetupCopyRelatedInfs(
    IN HINF   hInf,
    IN PCTSTR InfFileName,                  OPTIONAL
    IN PCTSTR InfSectionName,
    IN DWORD  OEMSourceMediaType,
    IN PSETUP_LOG_CONTEXT LogContext        OPTIONAL
    )
/*++

Routine Description:

    This routine processes "CopyINF" directives in the DDInstall section of the
    primary INF.
    CopyINF is not processed under following cases:
        Primary INF is in driver search path
        The CopyINF is specified in an included section.

Arguments:

    hInf - supplies a handle to the INF containing the section specified by
        InfSectionName.

    InfFileName - supplies the full path of the INF whose handle was supplied in
        the hDeviceInf parameter.  The path component is used in an attempt to
        locate the specified INFs. If not specified, we try to get this from hInf

    InfSectionName - supplies the name of the section containing "CopyINF=" lines.

    OEMSourceMediaType - Specifies the type of source media that the location
        information references.  May be one of the following values:

        SPOST_NONE - No source media information should be stored in the PNF
                     file.  (OEMSourceMediaLocation is ignored in this case.)

        SPOST_PATH - OEMSourceMediaLocation contains a path to the source media.
                     For example, if the media is on a floppy, this path might
                     be "A:\". If OEMSourceMediaLocation is NULL, then the path
                     is assumed to be the path where the INF is located (unless
                     the INF has a corresponding PNF in that location, in which
                     case that PNF's source media information will be
                     transferred to the destination PNF).

        SPOST_URL  - OEMSourceMediaLocation contains a URL indicating the
                     internet location where the INF/driver files were retrieved
                     from.  If OEMSourceMediaLocation is NULL, then it is
                     assumed that the default Code Download Manager location was
                     used.

    LogContext - used for logging. If not specified, we get this from hInf

Return Value:

    none.

--*/
{
    INFCONTEXT CopyInfLineContext;
    TCHAR CombinedPath[MAX_PATH*2];
    TCHAR FullSourcePath[MAX_PATH];
    PTSTR Title;
    PCTSTR Field;
    PCTSTR SourcePath;
    DWORD Status;
    DWORD FieldCount;
    DWORD FieldIndex;
    DWORD RetVal;
    PLOADED_INF pInf = NULL;

    if(hInf == NULL || InfSectionName == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    pInf = (PLOADED_INF)hInf;
    if(!LockInf(pInf)) {
        return ERROR_INVALID_HANDLE;
    }
    if(!LogContext) {
        LogContext = pInf->LogContext;
    }
    if(!InfFileName) {
        InfFileName = pInf->VersionBlock.Filename;
    }
    //
    // if primary INF is from OEM location, then process CopyINF directives
    // note that if the INF is in search path, we ignore CopyINF
    // we also ignore CopyINF's pulled in from other INF's (ie, don't process
    // Include/Needs).
    //
    if(!pSetupInfIsFromOemLocation(InfFileName, FALSE)) {
        //
        // Primary INF is on search path, ignore CopyINF directives
        //
        Status = NO_ERROR;
        goto final;
    }

    MYVERIFY(SUCCEEDED(StringCchCopy(CombinedPath,MAX_PATH,InfFileName)));

    Title = (PTSTR)pSetupGetFileTitle(CombinedPath);
    if (!Title) {
        //
        // shouldn't happen
        //
        MYASSERT(Title);
        Status = ERROR_INVALID_PARAMETER;
        goto final;
    }

    //
    // we look for keyword "CopyInf" in the install section
    //
    if (SetupFindFirstLine(hInf,
                           InfSectionName,
                           SZ_KEY_COPYINF,
                           &CopyInfLineContext)) {

        PSETUP_LOG_CONTEXT SavedLogContext = NULL;
        BOOL ChangedThreadLogContext = SetThreadLogContext(LogContext,&SavedLogContext);
        //
        // we've pushed log context so SetupCopyOemInf will log correctly
        //

        do {
            //
            // CopyInf = a.inf,b.inf,c.inf...
            // a.inf will be at index 1.
            //
            FieldCount = SetupGetFieldCount(&CopyInfLineContext);
            for(FieldIndex = 1;FieldIndex<=FieldCount;FieldIndex++) {

                Status = NO_ERROR;

                Field = pSetupGetField(&CopyInfLineContext,FieldIndex);
                MYVERIFY(SUCCEEDED(StringCchCopy(Title,
                                                 SIZECHARS(CombinedPath)-(Title-CombinedPath),
                                                 Field)));

                //
                // we have a listed INF, obtain canonical pathname
                // for this INF
                // (note that we assume the INF is relative
                //  to original INF and is typically just a filename)
                //
                RetVal = GetFullPathName(CombinedPath,
                                         MAX_PATH,
                                         FullSourcePath,
                                         NULL);
                if (RetVal == 0 || RetVal > MAX_PATH) {
                    SourcePath = CombinedPath;
                } else {
                    SourcePath = FullSourcePath;
                }
                if(!SetupCopyOEMInf(FullSourcePath,
                                NULL,
                                OEMSourceMediaType,
                                0,
                                NULL,
                                0,
                                NULL,
                                NULL)) {
                    Status = GetLastError();
                }

                if (Status != NO_ERROR) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                        MSG_LOG_COPYINF_ERROR,
                        NULL,
                        FullSourcePath);
                    WriteLogError(
                        LogContext,
                        DRIVER_LOG_ERROR,
                        Status);

                } else {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_INFO,
                        MSG_LOG_COPYINF_OK,
                        NULL,
                        FullSourcePath);
                }
            }

        } while (SetupFindNextMatchLine(&CopyInfLineContext,
                                        SZ_KEY_COPYINF,
                                        &CopyInfLineContext));

        if (ChangedThreadLogContext) {
            //
            // restore thread log context
            //
            SetThreadLogContext(SavedLogContext,NULL);
        }
    }
    Status = NO_ERROR;

final:
    if(pInf) {
        UnlockInf(pInf);
    }
    return Status;
}

VOID
SetDevnodeNeedsRebootProblemWithArg2(
    IN PDEVINFO_ELEM DevInfoElem,
    IN PDEVICE_INFO_SET pDevInfoSet,
    IN DWORD    Reason,                  OPTIONAL
    IN ULONG_PTR Arg1,                   OPTIONAL
    IN ULONG_PTR Arg2                    OPTIONAL
    )
/*++

Routine Description:

    This routine sets DI_NEEDREBOOT,
     sets the problem of the specified devnode to be CM_PROB_NEED_RESTART
     and logs information about why we did this

Arguments:

    DevInfoElem  )_ identify the devnode with the problem
    DevInfoSet   )

    Reason - Supplies a string resource ID for logging the reason a reboot is
        required.  If this is 0, nothing will be logged.

    Arg1/Arg2 - optional arguments %1 and %2 of the logged message


Return Value:

    none.

--*/
{
    TCHAR   szDevID[MAX_DEVICE_ID_LEN];
    CONFIGRET cr;

    DevInfoElem->InstallParamBlock.Flags |= DI_NEEDREBOOT;

    if((cr = CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                     szDevID,
                     SIZECHARS(szDevID),
                     0,
                     pDevInfoSet->hMachine)) != CR_SUCCESS) {
        szDevID[0] = TEXT('\0');
    }

    CM_Set_DevInst_Problem_Ex(DevInfoElem->DevInst,
                              CM_PROB_NEED_RESTART,
                              CM_SET_DEVINST_PROBLEM_OVERRIDE,
                              pDevInfoSet->hMachine);

    if (Reason) {
        //
        // if the caller gave a reason, log why a reboot is required
        //
        WriteLogEntry(
            DevInfoElem->InstallParamBlock.LogContext,
            DRIVER_LOG_WARNING,  // should this be a warning?
            Reason,
            NULL,
            Arg1,
            Arg2,
            szDevID);
    }
}


DWORD
MarkQueueForDeviceInstall(
    IN HSPFILEQ QueueHandle,
    IN HINF     DeviceInfHandle,
    IN PCTSTR   DeviceDesc       OPTIONAL
    )
/*++

Routine Description:

    This routine adds catalog info entries (if not already present) into a file
    queue for the INFs represented by the supplied INF handle.  It also marks
    the first INF's catalog entry (whether newly-created or not) with a flag
    indicating that this is the 'primary' device INF for this installation.  It
    then sets a flag in the queue indicating that the behavior when subsequently
    calling _SetupVerifyQueuedCatalogs should be to copy the INF into the
    %windir%\Inf directory (as opposed to merely creating a zero-length file
    there of the correct name so that the catfile's name is guaranteed unique).
    Finally, it retrieves the driver signing policy and associates it with the
    queue (up until this point, the queue has associated with it the non-driver
    signing policy).

Arguments:

    QueueHandle - supplies a handle to the file queue to be marked as a device
        install file queue.

    DeviceInfHandle - supplies a handle to the device INF upon which this
        installation is based.  In addition to the "primary" device INF, this
        handle may also contain one or more append-loaded INFs.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error
    code indicating the cause of the failure.

--*/
{
    PSP_FILE_QUEUE Queue;
    TCHAR TempBuffer[MAX_PATH];
    LONG InfStringId, CatStringId, OriginalInfStringId;
    PLOADED_INF pInf;
    DWORD Err;
    PTSTR InfDeviceDesc;
    PSPQ_CATALOG_INFO CatalogNode, PrevCatalogNode, NewCatalogNode;
    BOOL DifferentOriginalName;
    TCHAR OriginalInfName[MAX_PATH];
    BOOL UnlockInf;
    BOOL UseOriginalInfName;

    //
    // Queue handle is actually a pointer to the queue structure.
    //
    Queue = (PSP_FILE_QUEUE)QueueHandle;

    NewCatalogNode = NULL;
    Err = NO_ERROR;
    InfDeviceDesc = NULL;
    UnlockInf = FALSE;

    try {

        if(LockInf((PLOADED_INF)DeviceInfHandle)) {
            UnlockInf = TRUE;
        } else {
            Err = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        //
        // We want to process each INF in the LOADED_INF list...
        //
        for(pInf = (PLOADED_INF)DeviceInfHandle; pInf; pInf = pInf->Next) {
            //
            // First, get the (potentially decorated) CatalogFile= entry from
            // the version block of this INF member, as well as the INF's
            // original name (if different from the INF's current name).
            //
            Err = pGetInfOriginalNameAndCatalogFile(
                      pInf,
                      NULL,
                      &DifferentOriginalName,
                      OriginalInfName,
                      SIZECHARS(OriginalInfName),
                      TempBuffer,
                      SIZECHARS(TempBuffer),
                      NULL // always native OS/arch (ver doesn't matter for CatalogFile=)
                     );

            if(Err != NO_ERROR) {
                goto clean0;
            }

            if(DifferentOriginalName) {
                //
                // Add the INF's original (simple) filename to our string table.
                //
                OriginalInfStringId = pSetupStringTableAddString(
                                          Queue->StringTable,
                                          OriginalInfName,
                                          STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                         );

                if(OriginalInfStringId == -1) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }

            } else {
                //
                // INF's original name is the same as its present name.
                //
                OriginalInfStringId = -1;
            }

            if(*TempBuffer) {

                CatStringId = pSetupStringTableAddString(Queue->StringTable,
                                                   TempBuffer,
                                                   STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                  );
                if(CatStringId == -1) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            } else {
                //
                // This INF doesn't have a CatalogFile= entry.
                //
                CatStringId = -1;
            }

            //
            // Now, get the INF's full path.
            //
            MYVERIFY(SUCCEEDED(StringCchCopy(TempBuffer,
                                             SIZECHARS(TempBuffer),
                                             pInf->VersionBlock.Filename)));

            InfStringId = pSetupStringTableAddString(Queue->StringTable,
                                               TempBuffer,
                                               STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                              );
            if(InfStringId == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            //
            // Now search for an existing catalog node (there'll typically be
            // one unless the device INF doesn't copy any files, such as a
            // modem INF).
            //
            for(PrevCatalogNode=NULL, CatalogNode=Queue->CatalogList;
                CatalogNode;
                CatalogNode=CatalogNode->Next) {

                if(CatalogNode->InfFullPath == InfStringId) {
                    //
                    // Already in there. No need to create a new node.
                    // Break out here, with CatalogNode pointing at the
                    // proper node for this catalog file.
                    //
                    // In this case, PrevCatalogNode should not be used later,
                    // but it shouldn't need to be used, since we won't be
                    // adding anything new onto the list of catalog nodes.
                    //
                    // NOTE: Our alternate catalog should be correct because
                    // either (a) the altplatform info was in effect when the
                    // INF was added, or (b) the altplatform info was applied
                    // after the INF's addition, and it was updated at that
                    // time.
                    //
                    MYASSERT(CatalogNode->CatalogFileFromInf == CatStringId);
                    MYASSERT(CatalogNode->InfOriginalName == OriginalInfStringId);
                    break;
                }

                //
                // PrevCatalogNode will end up pointing to the final node
                // currently in the linked list, in the case where we need
                // to allocate a new node. This is useful so we don't have to
                // traverse the list again later when we add the new catalog
                // node to the list for this queue.
                //
                PrevCatalogNode = CatalogNode;
            }

            //
            // If we didn't find an existing catalog node, then add one now.
            //
            if(!CatalogNode) {
                //
                // Need to create a new catalog node.
                //
                NewCatalogNode = MyMalloc(sizeof(SPQ_CATALOG_INFO));
                if(!NewCatalogNode) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
                ZeroMemory(NewCatalogNode, sizeof(SPQ_CATALOG_INFO));
                NewCatalogNode->CatalogFileFromInf = CatStringId;
                NewCatalogNode->InfOriginalName = OriginalInfStringId;
                NewCatalogNode->InfFullPath = InfStringId;
                NewCatalogNode->InfFinalPath = -1;
                NewCatalogNode->AltCatalogFileFromInfPending = -1;

                //
                // If this queue has alternate platform info associated with
                // it, then we need to retrieve the alternate catalog to be
                // used for digital signature verification.
                //
                if(Queue->Flags & FQF_USE_ALT_PLATFORM) {

                    if(pSetupGetCatalogFileValue(&(pInf->VersionBlock),
                                                 TempBuffer,
                                                 SIZECHARS(TempBuffer),
                                                 &(Queue->AltPlatformInfo))) {

                        NewCatalogNode->AltCatalogFileFromInf =
                            pSetupStringTableAddString(Queue->StringTable,
                                                       TempBuffer,
                                                       STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                      );
                        if(NewCatalogNode->AltCatalogFileFromInf == -1) {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                            goto clean0;
                        }

                    } else {
                        //
                        // This INF doesn't have a CatalogFile= entry.
                        //
                        NewCatalogNode->AltCatalogFileFromInf = -1;
                    }

                } else {
                    //
                    // No alternate platform info associated with the queue at
                    // this time.
                    //
                    NewCatalogNode->AltCatalogFileFromInf = -1;
                }

                if(Queue->CatalogList) {
                    PrevCatalogNode->Next = NewCatalogNode;
                } else {
                    Queue->CatalogList = NewCatalogNode;
                }
                //
                // Reset NewCatalogNode so we won't try to free it in case we
                // encounter a subsequent error.
                //
                CatalogNode = NewCatalogNode;
                NewCatalogNode = NULL;

                //
                // We've successfully added a new, as yet unvalidated, catalog
                // node.  We must therefore reset the  the "catalog
                // verifications done" flags so that we'll redo them later.
                //
                Queue->Flags &= ~(FQF_DID_CATALOGS_OK | FQF_DID_CATALOGS_FAILED);
            }

            if(pInf == (PLOADED_INF)DeviceInfHandle) {
                //
                // At this point, CatalogNode points to the node representing
                // the device INF upon which this device installation is based.
                // Mark this node as such, so that _SetupVerifyQueuedCatalogs
                // can return the INF's new name if it's an OEM INF.
                //
                CatalogNode->Flags |= CATINFO_FLAG_PRIMARY_DEVICE_INF;
            }
        }

        if(!(Queue->Flags & FQF_DEVICE_INSTALL)) {
            //
            // This queue wasn't previously known to be a device install queue,
            // so it's possible the catalog nodes have already been verified
            // subject to non-driver signing policy.  Further, it's possible
            // (albeit unlikely) that a non-device INF was passed into this
            // routine, and that a catalog node for that INF already existed in
            // our catalog list.  In that case, one of our "catalog
            // verifications done" flags would be set, but would not have been
            // cleared above since we didn't add any catalog nodes.  All of
            // this discussion simply to justify that we really do need to
            // clear the bits here too...  :-(
            //
            Queue->Flags &= ~(FQF_DID_CATALOGS_OK | FQF_DID_CATALOGS_FAILED);

            //
            // Note:  We don't clear the CATINFO_FLAG_NEWLY_COPIED flags for any
            // of the catalog nodes, because we want to make sure we re-use
            // those same names when re-doing verification (e.g., maybe the
            // first time around the INF was installed into %windir%\Inf as a
            // zero-length file--we want to re-use the same filename to now hold
            // our INF).
            //

            //
            // Since we previously didn't know this was a device install queue,
            // we shouldn't have a ValidationPlatform.  Make sure that's the
            // case, because the call below would blow away any we had (thus
            // causing a memory leak).
            //
            MYASSERT(!(Queue->ValidationPlatform));

            //
            // Retrieve the codesigning policy in effect for this device (thus
            // replacing the default non-driver signing policy that was
            // associated with the queue when it was originally created).
            //
            IsInfForDeviceInstall(Queue->LogContext,
                                  NULL,
                                  (PLOADED_INF)DeviceInfHandle,
                                  (DeviceDesc ? NULL : &InfDeviceDesc),
                                  &(Queue->ValidationPlatform),
                                  &(Queue->DriverSigningPolicy),
                                  &UseOriginalInfName,
                                  FALSE
                                 );

            if(UseOriginalInfName) {
                Queue->Flags |= FQF_KEEP_INF_AND_CAT_ORIGINAL_NAMES;
            }

            //
            // If the caller supplied us with a device description (or we got
            // one from IsInfForDeviceInstall), attempt to add that string to
            // the queue's string table in case we need to give a digital
            // signature verification failure popup for this queue.
            //
            //
            // NOTE: When adding the following string to the string table, we
            // cast away its CONST-ness to avoid a compiler warning.  Since we
            // are adding it case-sensitively, we are guaranteed it will not be
            // modified.
            //
            if(DeviceDesc) {
                Queue->DeviceDescStringId = pSetupStringTableAddString(Queue->StringTable,
                                                                 (PTSTR)DeviceDesc,
                                                                 STRTAB_CASE_SENSITIVE
                                                                );
            } else if(InfDeviceDesc) {
                //
                // Use the more generic description based on the device's class
                //
                Queue->DeviceDescStringId = pSetupStringTableAddString(Queue->StringTable,
                                                                 InfDeviceDesc,
                                                                 STRTAB_CASE_SENSITIVE
                                                                );
            }

            //
            // Set a flag in the queue that indicates this is for a device
            // installation.  If we're doing a native platform installation
            // (i.e., the FQF_USE_ALT_PLATFORM isn't set), then this also
            // causes us to copy the INF into %windir%\Inf instead of merely
            // creating a zero-length placeholder file there upon which the
            // corresponding CAT file's installation is based.
            //
            Queue->Flags |= FQF_DEVICE_INSTALL;

        } else {
            //
            // This queue has previously been marked as a device install queue.
            // However, we still want to update the device description, if the
            // caller supplied one.
            //
            if(DeviceDesc) {
                Queue->DeviceDescStringId = pSetupStringTableAddString(Queue->StringTable,
                                                                 (PTSTR)DeviceDesc,
                                                                 STRTAB_CASE_SENSITIVE
                                                                );
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume
        // an inpage error when dealing with a mapped-in file.
        //
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
              ? ERROR_INVALID_PARAMETER
              : ERROR_READ_FAULT;

        //
        // Access the following variables, so that the compiler will respect our
        // statement ordering w.r.t. their assignment.
        //
        UnlockInf = UnlockInf;
        NewCatalogNode = NewCatalogNode;
    }

    if(UnlockInf) {
        UnlockInf((PLOADED_INF)DeviceInfHandle);
    }

    if(NewCatalogNode) {
        MyFree(NewCatalogNode);
    }

    if(InfDeviceDesc) {
        MyFree(InfDeviceDesc);
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devoem.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devoem.c

Abstract:

    Device Installer functions for dealing with OEM drivers.

Author:

    Lonny McMichael (lonnym) 10-Aug-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


BOOL
WINAPI
SetupDiAskForOEMDisk(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This routine displays a dialog asking for the path to an OEM install disk.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device being installed.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for the device being installed.  If this parameter is not
        specified, then the driver being installed is associated with the
        global class driver list of the device information set itself.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the user cancels the dialog, the return value is FALSE, and GetLastError
    will return ERROR_CANCELLED.
    If the function fails, the return value is FALSE, and GetLastError returns
    a Win32 error code indicating the cause of the failure.

Remarks:

    This routine will allow browsing of local and network drives for OEM 
    install files.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    TCHAR Title[MAX_TITLE_LEN];
    PDEVINSTALL_PARAM_BLOCK dipb;
    TCHAR PathBuffer[MAX_PATH];
    UINT PromptResult;
    LONG DriverPathId;

    //
    // Make sure we're running interactively.
    //
    try {

        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            Err = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
            leave;
        }

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        if(DeviceInfoData) {
            //
            // Then we are to prompt for an OEM driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }
            dipb = &(DevInfoElem->InstallParamBlock);
        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        if(!LoadString(MyDllModuleHandle,
                       IDS_OEMTITLE,
                       Title,
                       SIZECHARS(Title))) {
            Title[0] = TEXT('\0');
        }

        PromptResult = SetupPromptForDisk(dipb->hwndParent,
                                          (*Title) ? Title : NULL,
                                          NULL,
                                          pszOemInfDefaultPath,
                                          pszInfWildcard,
                                          NULL,
                                          IDF_OEMDISK | IDF_NOCOMPRESSED | IDF_NOSKIP,
                                          PathBuffer,
                                          SIZECHARS(PathBuffer),
                                          NULL
                                         );

        if(PromptResult == DPROMPT_CANCEL) {
            Err = ERROR_CANCELLED;
        } else if(PromptResult == DPROMPT_OUTOFMEMORY) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            //
            // A choice was made--replace old path with new one.
            //
            if((DriverPathId = pStringTableAddString(
                                   pDeviceInfoSet->StringTable,
                                   PathBuffer,
                                   STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                   NULL,0)) == -1) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {
                dipb->DriverPath = DriverPathId;
                Err = NO_ERROR;
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiSelectOEMDrv(
    IN     HWND             hwndParent,    OPTIONAL
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This routine selects a driver for a device using an OEM path supplied by
    the user.

Arguments:

    hwndParent - Optionally, supplies a window handle that will be the parent
        of any dialogs created during this routine.  This parameter may be
        used to override the hwndParent field in the install parameters block
        of the specified device information set or element.

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device being installed.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for the device being installed.  If this parameter is not
        specified, then the driver being installed is associated with the
        global class driver list of the device information set itself.

        This is an IN OUT parameter because the class GUID of this device
        information element will be updated upon return to reflect the class
        of the most-compatible driver found, if a compatible driver list was
        built.

Return Value:

    If the function succeeds (i.e., a driver is selected successfully), the
    return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This routine will first ask the user for the OEM path, and will then call
    the class installer to select a driver from that OEM path.

--*/

{
    DWORD Err;

    try {
        //
        // Make sure we're running interactively.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            Err = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
            leave;
        }

        Err = SelectOEMDriver(hwndParent, DeviceInfoSet, DeviceInfoData, FALSE);

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
SelectOEMDriver(
    IN     HWND             hwndParent,     OPTIONAL
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN     BOOL             IsWizard
    )
/*++

Routine Description:

    This is the worker routine that actually allows for the selection of an OEM 
    driver.

Arguments:

    hwndParent - Optionally, supplies the window handle that is to be the 
        parent for any selection UI.  If this parameter is not supplied, then 
        the hwndParent field of the devinfo set or element will be used.

    DeviceInfoSet - Supplies the handle of the device info set for which an 
        OEM driver selection is to be performed.

    DeviceInfoData - Optionally, supplies the address of the device information 
        element to select a driver for.  If this parameter is not supplied, 
        then an OEM driver for the global class driver list will be selected.

        If a compatible driver was found for this device, the device 
        information element will have its class GUID updated upon return to
        reflect the device's new class.

    IsWizard - Specifies whether this routine is being called in the context of 
        a select device wizard page.

Return Value:

    If successful, the return value is NO_ERROR.  Otherwise, it is a Win32
    error code indicating the cause of failure.
    
    Note that it is possible to get an error code of ERROR_DI_DO_DEFAULT.  This
    will happen more often for the wizard case, where we suppress invocation of
    the default handler for DIF_SELECTDEVICE.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PDEVINSTALL_PARAM_BLOCK dipb;
    DWORD Err = NO_ERROR;
    HWND hwndSave;
    LONG DriverPathSave;
    DWORD DriverPathFlagsSave;
    BOOL bRestoreHwnd = FALSE, bRestoreDriverPath = FALSE, bUnlockDevInfoElem = FALSE;
    BOOL bDontSave = FALSE;
    UINT NewClassDriverCount;
    UINT NewCompatDriverCount;
    BOOL bAskAgain = TRUE;
    TCHAR Title[MAX_TITLE_LEN];
    DWORD SavedFlags;
    HCURSOR hOldCursor;

    PDRIVER_NODE lpOrgCompat;
    PDRIVER_NODE lpOrgCompatTail;
    UINT         OrgCompatCount;
    PDRIVER_NODE lpOrgClass;
    PDRIVER_NODE lpOrgClassTail;
    UINT         OrgClassCount;
    PDRIVER_NODE lpOrgSel;
    DWORD        dwOrgSelType;
    DWORD        dwOrgFlags;
    DWORD        dwOrgFlagsEx;
    BOOL         bRestoreDeviceInfo = FALSE;

    try {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        if(DeviceInfoData) {
            //
            // Then we're working with a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }

            //
            // If the DevInfoElem isn't already locked, then lock it now, because
            // we're going to be calling the class installer, and we don't want to
            // allow it to delete this element!
            //
            if(!(DevInfoElem->DiElemFlags & DIE_IS_LOCKED)) {
                DevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
                bUnlockDevInfoElem = TRUE;
            }

            dipb = &(DevInfoElem->InstallParamBlock);

        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        //
        // Make this selection window the parent window for OEM stuff
        //
        if(hwndParent) {
            hwndSave = dipb->hwndParent;
            dipb->hwndParent = hwndParent;
            bRestoreHwnd = TRUE;
        }

        //
        // Don't assume there is no old OEM path.  Save old one and
        // pretend there is no old one in case of cancel.
        //
        DriverPathSave = dipb->DriverPath;
        dipb->DriverPath = -1;

        //
        // Clear the DI_ENUMSINGLEINF flag, because we're going to be getting
        // a path to a directory, _not_ to an individual INF.  Also, clear the
        // DI_COMPAT_FROM_CLASS flag, because we don't want to build the compatible
        // driver list based on any class driver list.
        //
        DriverPathFlagsSave = dipb->Flags & (DI_ENUMSINGLEINF | DI_COMPAT_FROM_CLASS);
        dipb->Flags &= ~(DI_ENUMSINGLEINF | DI_COMPAT_FROM_CLASS);
        bRestoreDriverPath = TRUE;

        while(bAskAgain && 
              (NO_ERROR == (Err = GLE_FN_CALL(FALSE, SetupDiAskForOEMDisk(
                                                         DeviceInfoSet, 
                                                         DeviceInfoData))))) 
        {
            bAskAgain = FALSE;

            //
            // Save the Original List info, in case we get
            // an empty list on the user's selected path.
            //
            // (Note: we don't attempt to save/restore our driver enumeration
            // hints.)
            //
            if(!bDontSave) {

                if(DevInfoElem) {
                    lpOrgCompat     = DevInfoElem->CompatDriverHead;
                    lpOrgCompatTail = DevInfoElem->CompatDriverTail;
                    OrgCompatCount  = DevInfoElem->CompatDriverCount;

                    lpOrgClass      = DevInfoElem->ClassDriverHead;
                    lpOrgClassTail  = DevInfoElem->ClassDriverTail;
                    OrgClassCount   = DevInfoElem->ClassDriverCount;

                    lpOrgSel        = DevInfoElem->SelectedDriver;
                    dwOrgSelType    = DevInfoElem->SelectedDriverType;
                } else {
                    lpOrgClass      = pDeviceInfoSet->ClassDriverHead;
                    lpOrgClassTail  = pDeviceInfoSet->ClassDriverTail;
                    OrgClassCount   = pDeviceInfoSet->ClassDriverCount;

                    lpOrgSel        = pDeviceInfoSet->SelectedClassDriver;
                    dwOrgSelType    = lpOrgSel ? SPDIT_CLASSDRIVER : SPDIT_NODRIVER;
                }

                dwOrgFlags = dipb->Flags;
                dwOrgFlagsEx = dipb->FlagsEx;

                bRestoreDeviceInfo = TRUE;
            }

            if(DevInfoElem) {
                DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                DevInfoElem->CompatDriverCount = 0;
                DevInfoElem->CompatDriverEnumHint = NULL;
                DevInfoElem->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;

                DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                DevInfoElem->ClassDriverCount = 0;
                DevInfoElem->ClassDriverEnumHint = NULL;
                DevInfoElem->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

                DevInfoElem->SelectedDriver = NULL;
                DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
            } else {
                lpOrgCompat     = NULL; // just so we won't ever try to free this list.

                pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
                pDeviceInfoSet->ClassDriverCount = 0;
                pDeviceInfoSet->ClassDriverEnumHint = NULL;
                pDeviceInfoSet->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

                pDeviceInfoSet->SelectedClassDriver = NULL;
            }

            SavedFlags = dipb->Flags & (DI_SHOWOEM | DI_NODI_DEFAULTACTION);

            dipb->Flags   &= ~(DI_DIDCOMPAT | DI_DIDCLASS | DI_MULTMFGS | DI_SHOWOEM);
            dipb->FlagsEx &= ~(DI_FLAGSEX_DIDINFOLIST | DI_FLAGSEX_DIDCOMPATINFO);

            if(IsWizard) {
                //
                // We don't want default action taken in the wizard case.
                //
                dipb->Flags |= DI_NODI_DEFAULTACTION;
            }

            //
            // Unlock the HDEVINFO before handling the Select Device.  
            // Otherwise, our multi-threaded dialog will deadlock!
            //
            UnlockDeviceInfoSet(pDeviceInfoSet);
            pDeviceInfoSet = NULL;

            Err = _SetupDiCallClassInstaller(
                      DIF_SELECTDEVICE,
                      DeviceInfoSet,
                      DeviceInfoData,
                      CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS
                      );

            //
            // Now, re-acquire the lock on our device information set.
            //
            if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
                //
                // we should never get here - could be indicative of
                // class/co-installer messing up
                //
                MYASSERT(pDeviceInfoSet);
                if(Err == NO_ERROR) {
                    Err = ERROR_INVALID_HANDLE;
                }
                leave;
            }

            //
            // Restore the saved flags.
            //
            dipb->Flags = (dipb->Flags & ~(DI_SHOWOEM | DI_NODI_DEFAULTACTION)) | SavedFlags;

            //
            // If the class installer returned ERROR_DI_DO_DEFAULT, then
            // they either did not process the DIF_SELECTDEVICE, or they
            // have setup our device info structure with an OEM INF.
            //
            switch(Err) {

                case ERROR_DI_DO_DEFAULT :
                    //
                    // This case is only handled if we're in a wizard.  
                    // Otherwise, send it down for default processing.
                    //
                    if(!IsWizard) {
                        goto DefaultHandling;
                    }

                    //
                    // This will be the most likely return, since we are not 
                    // allowing the default handler to be called.  So we will
                    // build a new class Drv list If it is empty we will ask
                    // again, otherwise we will accept the new selection and go
                    // on.
                    //
                    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    SetupDiBuildDriverInfoList(DeviceInfoSet,
                                               DeviceInfoData,
                                               SPDIT_CLASSDRIVER
                                              );

                    SetupDiBuildDriverInfoList(DeviceInfoSet,
                                               DeviceInfoData,
                                               SPDIT_COMPATDRIVER
                                              );

                    SetCursor(hOldCursor);

                    if(DevInfoElem) {
                        NewClassDriverCount = DevInfoElem->ClassDriverCount;
                        NewCompatDriverCount = DevInfoElem->CompatDriverCount;
                    } else {
                        NewClassDriverCount = pDeviceInfoSet->ClassDriverCount;
                        NewCompatDriverCount = 0;
                    }

                    if(!NewClassDriverCount && !NewCompatDriverCount) {
                        //
                        // Error.
                        //
                        if(!LoadString(MyDllModuleHandle,
                                       IDS_SELECT_DEVICE,
                                       Title,
                                       SIZECHARS(Title))) {
                            *Title = TEXT('\0');
                        }

                        FormatMessageBox(MyDllModuleHandle,
                                         NULL,
                                         MSG_NO_DEVICEINFO_ERROR,
                                         Title,
                                         MB_OK | MB_TASKMODAL
                                        );

                        bDontSave = TRUE;

                        //
                        // Clean up anything that happened to get put in here.
                        //
                        if(DevInfoElem &&
                           (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDCOMPATINFO)) {
                            //
                            // The class installer built a compatible driver list--kill it here.
                            //
                            DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);

                            DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                            DevInfoElem->CompatDriverCount = 0;
                            DevInfoElem->InstallParamBlock.Flags   &= ~DI_DIDCOMPAT;
                            DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDCOMPATINFO;

                            DevInfoElem->SelectedDriver = NULL;
                            DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
                        }
                        dipb->DriverPath = -1;

                        bAskAgain = TRUE;
                        break;
                    }

                    //
                    // Successfully retrieved one or more class and/or compat
                    // drivers.  Drop on through into processing of NO_ERROR 
                    // case...
                    //

                case NO_ERROR :
                    //
                    // Destroy the original lists
                    //
                    if(bRestoreDeviceInfo) {
                        DestroyDriverNodes(lpOrgCompat, pDeviceInfoSet);
                        DereferenceClassDriverList(pDeviceInfoSet, lpOrgClass);

                        bRestoreDeviceInfo = FALSE;
                    }

                    bRestoreDriverPath = FALSE;
                    break;

                case ERROR_DI_BAD_PATH :
                    //
                    // Pop up an error messagebox, then go try again.
                    //
                    if(!LoadString(MyDllModuleHandle,
                                   IDS_SELECT_DEVICE,
                                   Title,
                                   SIZECHARS(Title))) {
                        *Title = TEXT('\0');
                    }

                    FormatMessageBox(MyDllModuleHandle,
                                     NULL,
                                     MSG_NO_DEVICEINFO_ERROR,
                                     Title,
                                     MB_OK | MB_TASKMODAL
                                    );

                    bDontSave = TRUE;
                    dipb->DriverPath = -1;
                    bAskAgain = TRUE;

                    //
                    // Allow to fall through to default processing to delete 
                    // the current driver list(s).
                    //

                default :
DefaultHandling:
                    //
                    // Destroy the current driver list(s).
                    //
                    if(DevInfoElem) {

                        DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);
                        DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                        DevInfoElem->CompatDriverCount = 0;

                        DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                        DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                        DevInfoElem->ClassDriverCount = 0;

                        DevInfoElem->SelectedDriver = NULL;
                        DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;

                    } else if(pDeviceInfoSet) {

                        DereferenceClassDriverList(pDeviceInfoSet, pDeviceInfoSet->ClassDriverHead);
                        pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
                        pDeviceInfoSet->ClassDriverCount = 0;

                        pDeviceInfoSet->SelectedClassDriver = NULL;
                    }
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    //
    // If we need to restore any state, then we must make sure that we have the
    // HDEVINFO locked.
    //
    try {

        if(bRestoreDeviceInfo || bUnlockDevInfoElem || bRestoreHwnd || bRestoreDriverPath) {

            if(!pDeviceInfoSet && !(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
                //
                // shouldn't get here, indicative of class/co-installer messing 
                // up
                //
                MYASSERT(pDeviceInfoSet);
                if(Err == NO_ERROR) {
                    Err = ERROR_INVALID_HANDLE;
                }

                leave;

            } else {
                //
                // If we locked the DevInfoElem just for this API, then unlock 
                // it now.
                //
                if(bUnlockDevInfoElem) {
                    MYASSERT(DevInfoElem);
                    DevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
                }

                //
                // If the install param block needs its parent hwnd restored, 
                // do so now.
                //
                if(bRestoreHwnd) {
                    dipb->hwndParent = hwndSave;
                }

                //
                // Likewise, restore the old driver path if necessary.
                //
                if(bRestoreDriverPath) {
                    dipb->DriverPath = DriverPathSave;
                    dipb->Flags |= DriverPathFlagsSave;
                }

                //
                // If necessary, restore the original list(s).
                //
                if(bRestoreDeviceInfo) {

                    if(DevInfoElem) {

                        DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);
                        DevInfoElem->CompatDriverHead = lpOrgCompat;
                        DevInfoElem->CompatDriverTail = lpOrgCompatTail;
                        DevInfoElem->CompatDriverCount = OrgCompatCount;
                        lpOrgCompat = NULL;

                        DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                        DevInfoElem->ClassDriverHead = lpOrgClass;
                        DevInfoElem->ClassDriverTail = lpOrgClassTail;
                        DevInfoElem->ClassDriverCount = OrgClassCount;
                        lpOrgClass = NULL;

                        DevInfoElem->SelectedDriver = lpOrgSel;
                        DevInfoElem->SelectedDriverType = dwOrgSelType;

                    } else {

                        DereferenceClassDriverList(pDeviceInfoSet, pDeviceInfoSet->ClassDriverHead);
                        pDeviceInfoSet->ClassDriverHead = lpOrgClass;
                        pDeviceInfoSet->ClassDriverTail = lpOrgClassTail;
                        pDeviceInfoSet->ClassDriverCount = OrgClassCount;
                        lpOrgClass = NULL;

                        pDeviceInfoSet->SelectedClassDriver = lpOrgSel;
                    }

                    dipb->Flags = dwOrgFlags;
                    dipb->FlagsEx = dwOrgFlagsEx;
                }
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {

        pSetupExceptionHandler(GetExceptionCode(), 
                               ERROR_INVALID_PARAMETER, 
                               (Err == NO_ERROR) ? &Err : NULL
                              );

        if(pDeviceInfoSet && bRestoreDeviceInfo) {
            //
            // If we hit an exception before we got a chance to restore any of 
            // our stored-away driver lists, then clean those up here.
            //
            if(DevInfoElem) {
                if(lpOrgCompat) {
                    DestroyDriverNodes(lpOrgCompat, pDeviceInfoSet);
                }
                if(lpOrgClass) {
                    DereferenceClassDriverList(pDeviceInfoSet, lpOrgClass);
                }
            } else {
                if(lpOrgClass) {
                    DereferenceClassDriverList(pDeviceInfoSet, lpOrgClass);
                }
            }
        }
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devreg.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devreg.c

Abstract:

    Device Installer routines for registry storage/retrieval.

Author:

    Lonny McMichael (lonnym) 1-July-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Private function prototypes
//
DWORD
pSetupOpenOrCreateDevRegKey(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PDEVINFO_ELEM    DevInfoElem,
    IN  DWORD            Scope,
    IN  DWORD            HwProfile,
    IN  DWORD            KeyType,
    IN  BOOL             Create,
    IN  REGSAM           samDesired,
    OUT PHKEY            hDevRegKey,
    OUT PDWORD           KeyDisposition OPTIONAL
    );

BOOL
pSetupFindUniqueKey(
    IN HKEY   hkRoot,
    IN LPTSTR SubKey,
    IN size_t SubKeySize
    );

DWORD
pSetupOpenOrCreateDeviceInterfaceRegKey(
    IN  HKEY                      hInterfaceClassKey,
    IN  PDEVICE_INFO_SET          DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN  BOOL                      Create,
    IN  REGSAM                    samDesired,
    OUT PHKEY                     hDeviceInterfaceKey,
    OUT PDWORD                    KeyDisposition       OPTIONAL
    );

DWORD
pSetupDeleteDeviceInterfaceKey(
    IN HKEY                      hInterfaceClassKey,
    IN PDEVICE_INFO_SET          DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );


HKEY
WINAPI
SetupDiOpenClassRegKey(
    IN CONST GUID *ClassGuid, OPTIONAL
    IN REGSAM      samDesired
    )
/*++

Routine Description:

    This API opens the installer class registry key or a specific class
    installer's subkey.

Arguments:

    ClassGuid - Optionally, supplies a pointer to the GUID of the class whose
        key is to be opened.  If this parameter is NULL, then the root of the
        class tree will be opened.

    samDesired - Specifies the access you require for this key.

Return Value:

    If the function succeeds, the return value is a handle to an opened registry
    key.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    This API _will not_ create a registry key if it doesn't already exist.

    The handle returned from this API must be closed by calling RegCloseKey.

    To get at the interface class (DeviceClasses) branch, or to access the
    registry on a remote machine, use SetupDiOpenClassRegKeyEx.

--*/
{
    DWORD Err;
    HKEY hKey = INVALID_HANDLE_VALUE;

    try {

        Err = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                          hKey = SetupDiOpenClassRegKeyEx(ClassGuid,
                                                          samDesired,
                                                          DIOCR_INSTALLER,
                                                          NULL,
                                                          NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return hKey;
}


//
// ANSI version
//
HKEY
WINAPI
SetupDiOpenClassRegKeyExA(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN REGSAM      samDesired,
    IN DWORD       Flags,
    IN PCSTR       MachineName, OPTIONAL
    IN PVOID       Reserved
    )
{
    PCWSTR UnicodeMachineName = NULL;
    HKEY hk = INVALID_HANDLE_VALUE;
    DWORD rc;

    try {

        if(MachineName) {
            rc = pSetupCaptureAndConvertAnsiArg(MachineName,
                                                &UnicodeMachineName
                                               );
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                         hk = SetupDiOpenClassRegKeyExW(ClassGuid,
                                                        samDesired,
                                                        Flags,
                                                        UnicodeMachineName,
                                                        Reserved)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return hk;
}


HKEY
WINAPI
SetupDiOpenClassRegKeyEx(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN REGSAM      samDesired,
    IN DWORD       Flags,
    IN PCTSTR      MachineName, OPTIONAL
    IN PVOID       Reserved
    )
/*++

Routine Description:

    This API opens the root of either the installer or the interface class
    registry branch, or a specified class subkey under one of these branches.

    If the root key is requested, it will be created if not already present
    (i.e., you're always guaranteed to get a handle to the root unless a
    registry error occurs).

    If a particular class subkey is requested, it will be returned if present.
    Otherwise, this API will return ERROR_INVALID_CLASS.

Arguments:

    ClassGuid - Optionally, supplies a pointer to the GUID of the class whose
        key is to be opened.  If this parameter is NULL, then the root of the
        class tree will be opened.  This GUID is either an installer class or
        an interface class depending on the Flags argument.

    samDesired - Specifies the access you require for this key.

    Flags - Specifies which registry branch the key is to be opened for.  May
        be one of the following values:

        DIOCR_INSTALLER - Open the class installer (Class) branch.
        DIOCR_INTERFACE - Open the interface class (DeviceClasses) branch.

    MachineName - If specified, this value indicates the remote machine where
        the key is to be opened.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is a handle to an opened
    registry key.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    The handle returned from this API must be closed by calling RegCloseKey.

--*/
{
    HKEY hk = INVALID_HANDLE_VALUE;
    CONFIGRET cr;
    DWORD Err = NO_ERROR;
    HMACHINE hMachine = NULL;

    try {
        //
        // Make sure the user didn't pass us anything in the Reserved parameter.
        //
        if(Reserved) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // Validate the flags (really, just an enum for now, but treated as
        // flags for future extensibility).
        //
        if((Flags & ~(DIOCR_INSTALLER | DIOCR_INTERFACE)) ||
           ((Flags != DIOCR_INSTALLER) && (Flags != DIOCR_INTERFACE))) {

            Err = ERROR_INVALID_FLAGS;
            leave;
        }

        if(MachineName) {

            if(CR_SUCCESS != (cr = CM_Connect_Machine(MachineName, &hMachine))) {
                //
                // Make sure machine handle is still invalid, so we won't
                // try to disconnect later.
                //
                hMachine = NULL;
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                leave;
            }
        }

        if((cr = CM_Open_Class_Key_Ex((LPGUID)ClassGuid,
                                      NULL,
                                      samDesired,
                                      ClassGuid ? RegDisposition_OpenExisting
                                                : RegDisposition_OpenAlways,
                                      &hk,
                                      (Flags & DIOCR_INSTALLER) ? CM_OPEN_CLASS_KEY_INSTALLER
                                                                : CM_OPEN_CLASS_KEY_INTERFACE,
                                      hMachine)) != CR_SUCCESS)
        {
            hk = INVALID_HANDLE_VALUE;

            if(cr == CR_NO_SUCH_REGISTRY_KEY) {
                Err = ERROR_INVALID_CLASS;
            } else {
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return hk;
}


//
// ANSI version
//
HKEY
WINAPI
SetupDiCreateDevRegKeyA(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCSTR            InfSectionName  OPTIONAL
    )
{
    DWORD rc;
    PWSTR name = NULL;
    HKEY h = INVALID_HANDLE_VALUE;

    try {

        if(InfSectionName) {
            rc = pSetupCaptureAndConvertAnsiArg(InfSectionName, &name);
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                         h = SetupDiCreateDevRegKeyW(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     Scope,
                                                     HwProfile,
                                                     KeyType,
                                                     InfHandle,
                                                     name)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(name) {
        MyFree(name);
    }

    SetLastError(rc);
    return h;
}


HKEY
WINAPI
SetupDiCreateDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCTSTR           InfSectionName  OPTIONAL
    )
/*++

Routine Description:

    This routine creates a registry storage key for device-specific
    configuration information, and returns a handle to the key.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        information about the device instance whose registry configuration
        storage key is to be created.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure
        indicating the device instance to create the registry key for.

    Scope - Specifies the scope of the registry key to be created.  This
        determines where the information is actually stored--the key created
        may be one that is global (i.e., constant regardless of current
        hardware profile) or hardware profile-specific.  May be one of the
        following values:

        DICS_FLAG_GLOBAL - Create a key to store global configuration
                           information.

        DICS_FLAG_CONFIGSPECIFIC - Create a key to store hardware profile-
                                   specific information.

    HwProfile - Specifies the hardware profile to create a key for, if the
        Scope parameter is set to DICS_FLAG_CONFIGSPECIFIC.  If this parameter
        is 0, then the key for the current hardware profile should be created
        (i.e., in the Class branch under HKEY_CURRENT_CONFIG).  If Scope is
        DICS_FLAG_GLOBAL, then this parameter is ignored.

    KeyType - Specifies the type of registry storage key to be created.  May be
        one of the following values:

        DIREG_DEV - Create a hardware registry key for the device.  This is the
            key for storage of driver-independent configuration information.
            (This key is in the device instance key in the Enum branch.

        DIREG_DRV - Create a software, or driver, registry key for the device.
            (This key is located in the class branch.)

    InfHandle - Optionally, supplies the handle of an opened INF file
        containing an install section to be executed for the newly-created key.
        If this parameter is specified, then InfSectionName must be specified
        as well.

        NOTE: INF-based installation is not supported for remoted device
        information sets (e.g., as created by passing a non-NULL MachineName in
        to SetupDiCreateDeviceInfoListEx).  This routine will fail with
        ERROR_REMOTE_REQUEST_UNSUPPORTED in those cases.

    InfSectionName - Optionally, supplies the name of an install section in the
        INF file specified by InfHandle.  This section will be executed for the
        newly created key. If this parameter is specified, then InfHandle must
        be specified as well.

Return Value:

    If the function succeeds, the return value is a handle to a newly-created
    registry key where private configuration data pertaining to this device
    instance may be stored/retrieved.  This handle will have KEY_READ and
    KEY_WRITE access.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    The handle returned from this routine must be closed by calling
    RegCloseKey.

    If a driver key is being created (i.e., KeyType is DIREG_DRV), then the
    specified device instance must have been previously registered.  In other
    words, if the device information element was created by calling
    SetupDiCreateDeviceInfo, then SetupDiRegisterDeviceInfo must have been
    subsequently called (typically, as part of DIF_REGISTERDEVICE processing).

    During GUI-mode setup on Windows NT, quiet-install behavior is always
    employed in the absence of a user-supplied file queue, regardless of
    whether the device information element has the DI_QUIETINSTALL flag set.

--*/

{
    HKEY hk = INVALID_HANDLE_VALUE;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL FreeMsgHandlerContext = FALSE;
    BOOL MsgHandlerIsNativeCharWidth;
    BOOL NoProgressUI;
    DWORD KeyDisposition;

    try {
        //
        // Make sure that either both InfHandle and InfSectionName are
        // specified, or neither are...
        //
        if(InfHandle && (InfHandle != INVALID_HANDLE_VALUE)) {
            if(!InfSectionName) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }
        } else {
            if(InfSectionName) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            } else {
                //
                // Let's stick with _one_ value to indicate that the INF handle
                // wasn't suplied (the official one)...
                //
                InfHandle = INVALID_HANDLE_VALUE;
            }
        }

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        //
        // We don't support installation remotely.
        //
        if((pDeviceInfoSet->hMachine) && (InfHandle != INVALID_HANDLE_VALUE)) {
            Err = ERROR_REMOTE_REQUEST_UNSUPPORTED;
            leave;
        }

        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // First try to open the requested registry storage key, and if that
        // fails, then try to create it.  We do this so we can keep track of
        // whether or not the key was newly-created (in case we need to do
        // clean-up later upon encountering a subsequent error).
        //
        Err = pSetupOpenOrCreateDevRegKey(pDeviceInfoSet,
                                          DevInfoElem,
                                          Scope,
                                          HwProfile,
                                          KeyType,
                                          TRUE,
                                          KEY_READ | KEY_WRITE,
                                          &hk,
                                          &KeyDisposition
                                         );

        if(Err != NO_ERROR) {
            //
            // Make sure hk is still invalid so we won't try to close it
            // later.
            //
            hk = INVALID_HANDLE_VALUE;
            leave;
        }

        //
        // We successfully created the storage key, now run an INF install
        // section against it (if specified).
        //
        if(InfHandle != INVALID_HANDLE_VALUE) {
            //
            // If a copy msg handler and context haven't been specified, then
            // use the default one.
            //
            if(DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                MsgHandler        = DevInfoElem->InstallParamBlock.InstallMsgHandler;
                MsgHandlerContext = DevInfoElem->InstallParamBlock.InstallMsgHandlerContext;
                MsgHandlerIsNativeCharWidth = DevInfoElem->InstallParamBlock.InstallMsgHandlerIsNativeCharWidth;
            } else {

                NoProgressUI = (GuiSetupInProgress || (DevInfoElem->InstallParamBlock.Flags & DI_QUIETINSTALL));

                if(!(MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                             DevInfoElem->InstallParamBlock.hwndParent,
                                             (NoProgressUI ? INVALID_HANDLE_VALUE
                                                           : NULL),
                                             0,
                                             0,
                                             NULL))) {

                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    leave;
                }

                FreeMsgHandlerContext = TRUE;
                MsgHandler = SetupDefaultQueueCallback;
                MsgHandlerIsNativeCharWidth = TRUE;
            }

            Err = GLE_FN_CALL(FALSE,
                              _SetupInstallFromInfSection(
                                  DevInfoElem->InstallParamBlock.hwndParent,
                                  InfHandle,
                                  InfSectionName,
                                  SPINST_ALL,
                                  hk,
                                  NULL,
                                  0,
                                  MsgHandler,
                                  MsgHandlerContext,
                                  ((KeyType == DIREG_DEV) ? DeviceInfoSet
                                                          : INVALID_HANDLE_VALUE),
                                  ((KeyType == DIREG_DEV) ? DeviceInfoData
                                                          : NULL),
                                  MsgHandlerIsNativeCharWidth,
                                  NULL)
                             );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(FreeMsgHandlerContext) {
        SetupTermDefaultQueueCallback(MsgHandlerContext);
    }

    if(Err != NO_ERROR) {
        //
        // Close registry handle, if necessary, and delete key (if newly-
        // created).  We do this prior to unlocking the devinfo set so that at
        // least no one using this HDEVINFO can get at this half-finished key.
        //
        if(hk != INVALID_HANDLE_VALUE) {

            RegCloseKey(hk);
            hk = INVALID_HANDLE_VALUE;

            //
            // If the key was newly-created, then we want to delete it.
            //
            if(KeyDisposition == REG_CREATED_NEW_KEY) {

                pSetupDeleteDevRegKeys(DevInfoElem->DevInst,
                                       Scope,
                                       HwProfile,
                                       KeyType,
                                       FALSE,
                                       pDeviceInfoSet->hMachine
                                      );
            }
        }
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return hk;
}


HKEY
WINAPI
SetupDiOpenDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN REGSAM           samDesired
    )
/*++

Routine Description:

    This routine opens a registry storage key for device-specific configuration
    information, and returns a handle to the key.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        information about the device instance whose registry configuration
        storage key is to be opened.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure
        indicating the device instance to open the registry key for.

    Scope - Specifies the scope of the registry key to be opened.  This
        determines where the information is actually stored--the key opened may
        be one that is global (i.e., constant regardless of current hardware
        profile) or hardware profile-specific.  May be one of the following
        values:

        DICS_FLAG_GLOBAL - Open a key to store global configuration
                           information.

        DICS_FLAG_CONFIGSPECIFIC - Open a key to store hardware profile-
                                   specific information.

    HwProfile - Specifies the hardware profile to open a key for, if the Scope
        parameter is set to DICS_FLAG_CONFIGSPECIFIC.  If this parameter is 0,
        then the key for the current hardware profile should be opened (e.g.,
        in the Enum or Class branch under HKEY_CURRENT_CONFIG).  If Scope is
        SPDICS_FLAG_GLOBAL, then this parameter is ignored.

    KeyType - Specifies the type of registry storage key to be opened.  May be
        one of the following values:

        DIREG_DEV - Open a hardware registry key for the device.  This is the
            key for storage of driver-independent configuration information.
            (This key is in the device instance key in the Enum branch.

        DIREG_DRV - Open a software (i.e., driver) registry key for the device.
            (This key is located in the class branch.)

    samDesired - Specifies the access you require for this key.

Return Value:

    If the function succeeds, the return value is a handle to an opened
    registry key where private configuration data pertaining to this device
    instance may be stored/retrieved.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    The handle returned from this routine must be closed by calling
    RegCloseKey.

    If a driver key is being opened (i.e., KeyType is DIREG_DRV), then the
    specified device instance must have been previously registered.  In other
    words, if the device information element was created by calling
    SetupDiCreateDeviceInfo, then SetupDiRegisterDeviceInfo must have been
    subsequently called (typically, as part of DIF_REGISTERDEVICE processing).

--*/

{
    HKEY hk = INVALID_HANDLE_VALUE;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    try {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                   DeviceInfoData,
                                                   NULL)) {
            //
            // Open the requested registry storage key.
            //
            Err = pSetupOpenOrCreateDevRegKey(pDeviceInfoSet,
                                              DevInfoElem,
                                              Scope,
                                              HwProfile,
                                              KeyType,
                                              FALSE,
                                              samDesired,
                                              &hk,
                                              NULL
                                             );
            if(Err != NO_ERROR) {
                //
                // Make sure hk is still invalid so we won't try to close it
                // later.
                //
                hk = INVALID_HANDLE_VALUE;
            }
        } else {
            Err = ERROR_INVALID_PARAMETER;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return hk;
}


DWORD
pSetupOpenOrCreateDevRegKey(
    IN  PDEVICE_INFO_SET pDeviceInfoSet,
    IN  PDEVINFO_ELEM    DevInfoElem,
    IN  DWORD            Scope,
    IN  DWORD            HwProfile,
    IN  DWORD            KeyType,
    IN  BOOL             Create,
    IN  REGSAM           samDesired,
    OUT PHKEY            hDevRegKey,
    OUT PDWORD           KeyDisposition
    )
/*++

Routine Description:

    This routine creates or opens a registry storage key for the specified
    device information element, and returns a handle to the opened key.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set containing
        the element for which a registry storage key is to be created/opened.

    DevInfoElem - Supplies a pointer to the device information element for
        which a registry storage key is to be created/opened.

    Scope - Specifies the scope of the registry key to be created/opened.  This
        determines where the information is actually stored--the key created
        may be one that is global (i.e., constant regardless of current
        hardware profile) or hardware profile-specific.  May be one of the
        following values:

        DICS_FLAG_GLOBAL - Create/open a key to store global configuration
                           information.

        DICS_FLAG_CONFIGSPECIFIC - Create/open a key to store hardware profile-
                                   specific information.

    HwProfile - Specifies the hardware profile to create/open a key for, if the
        Scope parameter is set to DICS_FLAG_CONFIGSPECIFIC.  If this parameter
        is 0, then the key for the current hardware profile should be created/
        opened (i.e., in the Class branch under HKEY_CURRENT_CONFIG).  If Scope
        is SPDICS_FLAG_GLOBAL, then this parameter is ignored.

    KeyType - Specifies the type of registry storage key to be created/opened.
        May be one of the following values:

        DIREG_DEV - Create/open a hardware registry key for the device.  This
            is the key for storage of driver-independent configuration
            information.  (This key is in the device instance key in the Enum
            branch.

        DIREG_DRV - Create/open a software, or driver, registry key for the
            device.  (This key is located in the class branch.)

    Create - Specifies whether the key should be created if doesn't already
        exist.

    samDesired - Specifies the access you require for this key.

    hDevRegKey - Supplies the address of a variable that receives a handle to
        the requested registry key.  (This variable will only be written to if
        the handle is successfully opened.)

    KeyDisposition - Optionally, supplies the address of a variable that
        receives the status of the returned key handle.  Can be either:

        REG_CREATED_NEW_KEY - The key did not exist and was created.

        REG_OPENED_EXISTING_KEY - The key existed and was simply opened without
                                  being changed.  (This will always be the case
                                  if the Create parameter is FALSE.)

Return Value:

    If the function is successful, the return value is NO_ERROR, otherwise, it
    is the ERROR_* code indicating the error that occurred.

Remarks:

    If a software key is requested (DIREG_DRV), and there isn't already a
    'Driver' value entry, then one will be created.  This entry is of the form:

        <ClassGUID>\<instance>

    where <instance> is a base-10, 4-digit number that is unique within that
    class.

--*/

{
    ULONG RegistryBranch;
    CONFIGRET cr;
    DWORD Err = NO_ERROR;
    DWORD Disposition = REG_OPENED_EXISTING_KEY;
    HKEY hk, hkClass;
    TCHAR DriverKey[GUID_STRING_LEN + 5];   // Eg, {4d36e978-e325-11ce-bfc1-08002be10318}\0000
    size_t DriverKeyLength;
    BOOL GetKeyDisposition = (KeyDisposition ? TRUE : FALSE);

    //
    // Under Win95, the class key uses the class name instead of its GUID.  The
    // maximum length of a class name is less than the length of a GUID string,
    // but put a check here just to make sure that this assumption remains
    // valid.
    //
#if MAX_CLASS_NAME_LEN > MAX_GUID_STRING_LEN
#error MAX_CLASS_NAME_LEN is larger than MAX_GUID_STRING_LEN--fix DriverKey!
#endif

    //
    // Figure out what flags to pass to CM_Open_DevInst_Key
    //
    switch(KeyType) {

        case DIREG_DEV :
            RegistryBranch = CM_REGISTRY_HARDWARE;
            break;

        case DIREG_DRV :
            //
            // This key may only be opened if the device instance has been
            // registered.
            //
            if(!(DevInfoElem->DiElemFlags & DIE_IS_REGISTERED)) {
                return ERROR_DEVINFO_NOT_REGISTERED;
            }

            //
            // Retrieve the 'Driver' registry property which indicates where
            // the storage key is located in the class branch.
            //
            DriverKeyLength = sizeof(DriverKey);
            if((cr = CM_Get_DevInst_Registry_Property_Ex(
                         DevInfoElem->DevInst,
                         CM_DRP_DRIVER,
                         NULL,
                         DriverKey,
                         (PULONG)&DriverKeyLength,
                         0,
                         pDeviceInfoSet->hMachine)) != CR_SUCCESS) {

                if(cr != CR_NO_SUCH_VALUE) {
                    return MapCrToSpError(cr, ERROR_INVALID_DATA);
                } else if(!Create) {
                    return ERROR_KEY_DOES_NOT_EXIST;
                }

                //
                // The Driver entry doesn't exist, and we should create it.
                //
                hk = INVALID_HANDLE_VALUE;
                if(CR_SUCCESS != CM_Open_Class_Key_Ex(
                                     NULL,
                                     NULL,
                                     KEY_READ | KEY_WRITE,
                                     RegDisposition_OpenAlways,
                                     &hkClass,
                                     0,
                                     pDeviceInfoSet->hMachine)) {
                    //
                    // This shouldn't fail.
                    //
                    return ERROR_INVALID_DATA;
                }

                try {
                    //
                    // Find a unique key name under this class key.
                    //
                    // FUTURE-2002/04/3D-lonnym -- UmPnPMgr should be responsible for generating driver keys
                    // Presently, there are places in cfgmgr32 and in umpnpmgr
                    // (as well as here) where a new driver key is assigned.
                    // This should all be centralized in one place.
                    //
                    DriverKeyLength = SIZECHARS(DriverKey);
                    if(CR_SUCCESS != CM_Get_Class_Key_Name_Ex(
                                         &(DevInfoElem->ClassGuid),
                                         DriverKey,
                                         (PULONG)&DriverKeyLength,
                                         0,
                                         pDeviceInfoSet->hMachine)) {

                        Err = ERROR_INVALID_CLASS;
                        leave;
                    }

                    //
                    // Get actual length of string (not including terminating
                    // NULL)...
                    //
                    if(!MYVERIFY(SUCCEEDED(StringCchLength(DriverKey,
                                                           SIZECHARS(DriverKey),
                                                           &DriverKeyLength
                                                           )))) {
                        //
                        // CM API gave us garbage!!!
                        //
                        Err = ERROR_INVALID_DATA;
                        leave;
                    }

                    Err = ERROR_FILE_NOT_FOUND;

                    while(pSetupFindUniqueKey(hkClass,
                                              DriverKey,
                                              SIZECHARS(DriverKey))) {

                        Err = RegCreateKeyEx(hkClass,
                                             DriverKey,
                                             0,
                                             NULL,
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_READ | KEY_WRITE,
                                             NULL,
                                             &hk,
                                             &Disposition
                                            );

                        if(Err == ERROR_SUCCESS) {
                            //
                            // Everything's great, unless the Disposition
                            // indicates that the key already existed.  That
                            // means that someone else claimed the key before
                            // we got a chance to.  In that case, we close this
                            // key, and try again.
                            //
                            if(Disposition == REG_OPENED_EXISTING_KEY) {
                                RegCloseKey(hk);
                                hk = INVALID_HANDLE_VALUE;
                                //
                                // Truncate off the class instance part, to be
                                // replaced with a new instance number the next
                                // go-around.
                                //
                                DriverKey[DriverKeyLength] = TEXT('\0');
                            } else {
                                break;
                            }
                        } else {
                            hk = INVALID_HANDLE_VALUE;
                            break;
                        }

                        Err = ERROR_FILE_NOT_FOUND;
                    }

                    if(Err != NO_ERROR) {
                        leave;
                    }

                    //
                    // Set the device instance's 'Driver' registry property to
                    // reflect the new software registry storage location.
                    //
                    if(!MYVERIFY(SUCCEEDED(StringCchLength(DriverKey,
                                                           SIZECHARS(DriverKey),
                                                           &DriverKeyLength
                                                           )))) {
                        //
                        // this should never fail!
                        //
                        Err = ERROR_INVALID_DATA;
                        leave;
                    }

                    cr = CM_Set_DevInst_Registry_Property_Ex(
                             DevInfoElem->DevInst,
                             CM_DRP_DRIVER,
                             DriverKey,
                             (DriverKeyLength + 1) * sizeof(TCHAR),
                             0,
                             pDeviceInfoSet->hMachine
                             );

                    if(cr != CR_SUCCESS) {
                        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        leave;
                    }

                    //
                    // If the caller requested that we return the key's
                    // disposition, and they're creating the global driver key,
                    // then we need to set the disposition now.  Otherwise, we
                    // would always report the key as REG_OPENED_EXISTING_KEY,
                    // since we just got through creating it up above.
                    //
                    if(GetKeyDisposition && (Scope == DICS_FLAG_GLOBAL)) {
                        *KeyDisposition = REG_CREATED_NEW_KEY;
                        GetKeyDisposition = FALSE;
                    }

                    //
                    // At this point, we successfully created a new driver key,
                    // and we stored the key's name in the Driver devnode
                    // property.  Close our key handle and set it back to
                    // INVALID_HANDLE_VALUE so we'll know not to try to delete
                    // the key below.
                    //
                    RegCloseKey(hk);
                    hk = INVALID_HANDLE_VALUE;

                } except(pSetupExceptionFilter(GetExceptionCode())) {
                    pSetupExceptionHandler(GetExceptionCode(),
                                           ERROR_INVALID_PARAMETER,
                                           &Err
                                          );
                }

                if(hk != INVALID_HANDLE_VALUE) {

                    MYASSERT(Err != NO_ERROR);

                    RegCloseKey(hk);

                    //
                    // Additionally, if the disposition indicates that the key
                    // was newly-created, then we need to delete it, because
                    // something failed subsequent to this key's creation, and
                    // we need to clean up.
                    //
                    if(Disposition == REG_CREATED_NEW_KEY) {
                        RegDeleteKey(hkClass, DriverKey);
                    }
                }

                RegCloseKey(hkClass);

                if(Err != NO_ERROR) {
                    return Err;
                }
            }

            RegistryBranch = CM_REGISTRY_SOFTWARE;
            break;

        default :
            return ERROR_INVALID_FLAGS;
    }

    if(Scope == DICS_FLAG_CONFIGSPECIFIC) {
        RegistryBranch |= CM_REGISTRY_CONFIG;
    } else if(Scope != DICS_FLAG_GLOBAL) {
        return ERROR_INVALID_FLAGS;
    }

    //
    // If we're creating the key, and we need to track whether this key is
    // getting created, then we may have to make two calls to
    // CM_Open_DevInst_Key_Ex (the first attempting to open an existing key,
    // and the second to create it if it didn't exist).
    //
    if(Create && GetKeyDisposition) {

        cr = CM_Open_DevInst_Key_Ex(DevInfoElem->DevInst,
                                    samDesired,
                                    HwProfile,
                                    RegDisposition_OpenExisting,
                                    &hk,
                                    RegistryBranch,
                                    pDeviceInfoSet->hMachine
                                   );
        if(cr == CR_SUCCESS) {
            //
            // The key was already in existence.
            //
            *KeyDisposition = REG_OPENED_EXISTING_KEY;
            goto exit;
        }
    }

    cr = CM_Open_DevInst_Key_Ex(DevInfoElem->DevInst,
                                samDesired,
                                HwProfile,
                                (Create ? RegDisposition_OpenAlways
                                        : RegDisposition_OpenExisting),
                                &hk,
                                RegistryBranch,
                                pDeviceInfoSet->hMachine
                               );

    if((cr == CR_SUCCESS) && GetKeyDisposition) {
        *KeyDisposition = Create ? REG_CREATED_NEW_KEY
                                 : REG_OPENED_EXISTING_KEY;
    }

exit:

    if(cr == CR_SUCCESS) {
        *hDevRegKey = hk;
        Err = NO_ERROR;
    } else {
        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
    }

    return Err;
}


DWORD
_SetupDiGetDeviceRegistryProperty(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize,        OPTIONAL
    IN  BOOL             Ansi
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    CONFIGRET cr;
    ULONG CmRegProperty, PropLength;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        return ERROR_INVALID_HANDLE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element for the specified device instance.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(Property < SPDRP_MAXIMUM_PROPERTY) {
            CmRegProperty = (ULONG)SPDRP_TO_CMDRP(Property);
        } else {
            Err = ERROR_INVALID_REG_PROPERTY;
            leave;
        }

        PropLength = PropertyBufferSize;
        if(Ansi) {
            cr = CM_Get_DevInst_Registry_Property_ExA(DevInfoElem->DevInst,
                                                      CmRegProperty,
                                                      PropertyRegDataType,
                                                      PropertyBuffer,
                                                      &PropLength,
                                                      0,
                                                      pDeviceInfoSet->hMachine
                                                     );
        } else {
            cr = CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                     CmRegProperty,
                                                     PropertyRegDataType,
                                                     PropertyBuffer,
                                                     &PropLength,
                                                     0,
                                                     pDeviceInfoSet->hMachine
                                                    );
        }

        if((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL)) {

            if(RequiredSize) {
                *RequiredSize = PropLength;
            }
        }

        if(cr != CR_SUCCESS) {
            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return Err;
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDeviceRegistryPropertyA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
{
    DWORD Err;

    try {

        Err = _SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                DeviceInfoData,
                                                Property,
                                                PropertyRegDataType,
                                                PropertyBuffer,
                                                PropertyBufferSize,
                                                RequiredSize,
                                                TRUE
                                               );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}

BOOL
WINAPI
SetupDiGetDeviceRegistryProperty(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the specified property from the Plug & Play device
    storage location in the registry.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        information about the device instance to retrieve a Plug & Play registry
        property for.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure indicating
        the device instance to retrieve the Plug & Play registry property for.

    Property - Supplies an ordinal specifying the property to be retrieved.  Refer
        to sdk\inc\setupapi.h for a complete list of properties that may be retrieved.

    PropertyRegDataType - Optionally, supplies the address of a variable that
        will receive the data type of the property being retrieved.  This will
        be one of the standard registry data types (REG_SZ, REG_BINARY, etc.)

    PropertyBuffer - Supplies the address of a buffer that receives the property
        data.

    PropertyBufferSize - Supplies the length, in bytes, of PropertyBuffer.

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of bytes required to store the requested property in the buffer.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.  If the supplied buffer was not large enough
    to hold the requested property, the error will be ERROR_INSUFFICIENT_BUFFER,
    and RequiredSize will specify how large the buffer needs to be.

--*/

{
    DWORD Err;

    try {

        Err = _SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                DeviceInfoData,
                                                Property,
                                                PropertyRegDataType,
                                                PropertyBuffer,
                                                PropertyBufferSize,
                                                RequiredSize,
                                                FALSE
                                               );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
_SetupDiSetDeviceRegistryProperty(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize,
    IN     BOOL             Ansi
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    CONFIGRET cr;
    ULONG CmRegProperty;
    GUID ClassGuid;
    BOOL ClassGuidSpecified;
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    DWORD ClassNameLength;
    PCWSTR UnicodeGuidString = NULL;


    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        return ERROR_INVALID_HANDLE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // Make sure the property code is in-range, and is not SPDRP_CLASS
        // (the Class property is not settable directly, and is automatically
        // updated when the ClassGUID property changes).
        //
        // FUTURE-2002/04/30-lonnym -- Should disallow setting Class property via CM APIs as well
        // Now that cfgmgr32 is part of setupapi.dll, we could use an internal
        // interface to set the Class property, yet not expose this to callers
        // (thus helping to ensure consistency between the Class and ClassGUID
        // property values).
        //
        if((Property < SPDRP_MAXIMUM_PROPERTY) && (Property != SPDRP_CLASS)) {
            CmRegProperty = (ULONG)SPDRP_TO_CMDRP(Property);
        } else {
            Err = ERROR_INVALID_REG_PROPERTY;
            leave;
        }

        //
        // If the property we're setting is ClassGUID, then we need to check to
        // see whether the new GUID is different from the current one.  If there's
        // no change, then we're done.
        //
        if(CmRegProperty == CM_DRP_CLASSGUID) {

            if(!PropertyBuffer) {
                //
                // Then the intent is to reset the device's class GUID.  Make
                // sure they passed us a buffer length of zero.
                //
                if(PropertyBufferSize) {
                    Err = ERROR_INVALID_PARAMETER;
                    leave;
                }

                ClassGuidSpecified = FALSE;

            } else {
                //
                // If we're being called from the ANSI API then we need
                // to convert the ANSI string representation of the GUID
                // to Unicode before we convert the string to an actual GUID.
                //
                if(Ansi) {

                    Err = pSetupCaptureAndConvertAnsiArg((PCSTR)PropertyBuffer,
                                                         &UnicodeGuidString
                                                        );
                    if(Err == NO_ERROR) {
                        Err = pSetupGuidFromString(UnicodeGuidString,
                                                   &ClassGuid
                                                  );
                    }

                } else {
                    Err = pSetupGuidFromString((PCWSTR)PropertyBuffer,
                                               &ClassGuid
                                              );
                }

                if(Err != NO_ERROR) {
                    leave;
                }
                ClassGuidSpecified = TRUE;
            }

            if(IsEqualGUID(&(DevInfoElem->ClassGuid),
                           (ClassGuidSpecified ? &ClassGuid
                                               : &GUID_NULL))) {
                //
                // No change--nothing to do.
                //
                leave;
            }

            //
            // We're changing the class of this device.  First, make sure that
            // the set containing this device doesn't have an associated class
            // (otherwise, we'll suddenly have a device whose class doesn't
            // match the set's class).
            //
            // Also, make sure this isn't a remoted HDEVINFO set.  Any existing
            // class installers or co-installers should be in the loop on a
            // change in class, in case they need to clean-up any persistent
            // resource reservations they've made (e.g., releasing a COM port's
            // DosDevices name back to the COM port name arbiter free pool).
            // Since we can't invoke class-/co-installers remotely, we must
            // disallow this class GUID change.
            //
            if(pDeviceInfoSet->HasClassGuid) {
                Err = ERROR_CLASS_MISMATCH;
            } else if(pDeviceInfoSet->hMachine) {
                Err = ERROR_REMOTE_REQUEST_UNSUPPORTED;
            } else {
                Err = InvalidateHelperModules(DeviceInfoSet, DeviceInfoData, 0);
            }

            if(Err != NO_ERROR) {
                leave;
            }

            //
            // Everything seems to be in order.  Before going any further, we
            // need to delete any software keys associated with this device, so
            // we don't leave orphans in the registry when we change the
            // device's class.
            //
            // NTRAID#NTBUG9-614056-2002/05/02-lonnym -- Class-/co-installers need notification of class change
            //
            pSetupDeleteDevRegKeys(DevInfoElem->DevInst,
                                   DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGSPECIFIC,
                                   (DWORD)-1,
                                   DIREG_DRV,
                                   TRUE,
                                   pDeviceInfoSet->hMachine     // must be NULL
                                  );
        }

        if(Ansi) {
            cr = CM_Set_DevInst_Registry_Property_ExA(DevInfoElem->DevInst,
                                                      CmRegProperty,
                                                      (PVOID)PropertyBuffer,
                                                      PropertyBufferSize,
                                                      0,
                                                      pDeviceInfoSet->hMachine
                                                      );
        } else {
            cr = CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                     CmRegProperty,
                                                     (PVOID)PropertyBuffer,
                                                     PropertyBufferSize,
                                                     0,
                                                     pDeviceInfoSet->hMachine
                                                    );
        }
        if(cr == CR_SUCCESS) {
            //
            // If we were setting the device's ClassGUID property, then we need
            // to update its Class name property as well.
            //
            if(CmRegProperty == CM_DRP_CLASSGUID) {

                if(ClassGuidSpecified) {

                    if(!SetupDiClassNameFromGuid(&ClassGuid,
                                                 ClassName,
                                                 SIZECHARS(ClassName),
                                                 &ClassNameLength)) {
                        //
                        // We couldn't retrieve the corresponding class name.
                        // Set ClassNameLength to zero so that we reset class
                        // name below.
                        //
                        ClassNameLength = 0;
                    }

                } else {
                    //
                    // Resetting ClassGUID--we want to reset class name also.
                    //
                    ClassNameLength = 0;
                }

                CM_Set_DevInst_Registry_Property_Ex(
                    DevInfoElem->DevInst,
                    CM_DRP_CLASS,
                    ClassNameLength ? (PVOID)ClassName : NULL,
                    ClassNameLength * sizeof(TCHAR),
                    0,
                    pDeviceInfoSet->hMachine
                    );

                //
                // Finally, update the device's class GUID, and also update the
                // caller-supplied SP_DEVINFO_DATA structure to reflect the device's
                // new class.
                //
                CopyMemory(&(DevInfoElem->ClassGuid),
                           (ClassGuidSpecified ? &ClassGuid : &GUID_NULL),
                           sizeof(GUID)
                          );

                CopyMemory(&(DeviceInfoData->ClassGuid),
                           (ClassGuidSpecified ? &ClassGuid : &GUID_NULL),
                           sizeof(GUID)
                          );
            }

        } else {
            //
            // For backward compatibility reasons, map CR_INVALID_DATA to
            // ERROR_INVALID_PARAMETER.  For everything else, use our generic
            // CR mapping routine...
            //
            if(cr == CR_INVALID_DATA) {
                Err = ERROR_INVALID_PARAMETER;
            } else {
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(UnicodeGuidString) {
        MyFree(UnicodeGuidString);
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return Err;
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiSetDeviceRegistryPropertyA(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize
    )
{
    DWORD Err;

    try {

        Err = _SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                DeviceInfoData,
                                                Property,
                                                PropertyBuffer,
                                                PropertyBufferSize,
                                                TRUE
                                               );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}

BOOL
WINAPI
SetupDiSetDeviceRegistryProperty(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize
    )

/*++

Routine Description:

    This routine sets the specified Plug & Play device registry property.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        information about the device instance to set a Plug & Play registry
        property for.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure indicating
        the device instance to set the Plug & Play registry property for.  If the
        ClassGUID property is being set, then this structure will be updated upon
        return to reflect the device's new class.

    Property - Supplies an ordinal specifying the property to be set.  Refer to
        sdk\inc\setupapi.h for a complete listing of values that may be set
        (these values are denoted with 'R/W' in their descriptive comment).

    PropertyBuffer - Supplies the address of a buffer containing the new data
        for the property.  If the property is being cleared, then this pointer
        should be NULL, and PropertyBufferSize must be zero.

    PropertyBufferSize - Supplies the length, in bytes, of PropertyBuffer.  If
        PropertyBuffer isn't specified (i.e., the property is to be cleared),
        then this value must be zero.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    Note that the Class property cannot be set.  This is because it is based on
    the corresponding ClassGUID, and is automatically updated when that property
    changes.

    Also, note that when the ClassGUID property changes, this routine automatically
    cleans up any software keys associated with the device.  Otherwise, we would
    be left with orphaned registry keys.

--*/

{
    DWORD Err;

    try {

        Err = _SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                DeviceInfoData,
                                                Property,
                                                PropertyBuffer,
                                                PropertyBufferSize,
                                                FALSE
                                               );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
_SetupDiGetClassRegistryProperty(
    IN  CONST GUID      *ClassGuid,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize,        OPTIONAL
    IN  PCTSTR           MachineName,         OPTIONAL
    IN  BOOL             Ansi
    )
/*++

    See SetupDiGetClassRegistryProperty

--*/
{
    DWORD Err;
    CONFIGRET cr;
    ULONG CmRegProperty, PropLength;
    HMACHINE hMachine = NULL;
    Err = NO_ERROR;

    try {
        //
        // if we want to set register for another machine, find that machine
        //
        if(MachineName) {

            if(CR_SUCCESS != (cr = CM_Connect_Machine(MachineName, &hMachine))) {
                //
                // Make sure machine handle is still invalid, so we won't
                // try to disconnect later.
                //
                hMachine = NULL;
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                leave;
            }
        }

        if(Property < SPCRP_MAXIMUM_PROPERTY) {
            CmRegProperty = (ULONG)SPCRP_TO_CMCRP(Property);
        } else {
            Err = ERROR_INVALID_REG_PROPERTY;
            leave;
        }

        PropLength = PropertyBufferSize;
        if(Ansi) {
            cr = CM_Get_Class_Registry_PropertyA(
                    (LPGUID)ClassGuid,
                    CmRegProperty,
                    PropertyRegDataType,
                    PropertyBuffer,
                    &PropLength,
                    0,
                    hMachine);
         } else {
             cr = CM_Get_Class_Registry_PropertyW(
                     (LPGUID)ClassGuid,
                     CmRegProperty,
                     PropertyRegDataType,
                     PropertyBuffer,
                     &PropLength,
                     0,
                     hMachine);
         }

        if((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL)) {

            if(RequiredSize) {
                *RequiredSize = PropLength;
            }
        }

        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if (hMachine != NULL) {
        CM_Disconnect_Machine(hMachine);
    }

    return Err;
}

//
// ANSI version
//
WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassRegistryPropertyA(
    IN  CONST GUID      *ClassGuid,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize,        OPTIONAL
    IN  PCSTR            MachineName,         OPTIONAL
    IN  PVOID            Reserved
    )
/*++

    See SetupDiGetClassRegistryProperty

--*/
{
    PCWSTR MachineString = NULL;
    DWORD Err = NO_ERROR;

    try {

        if(Reserved != NULL) {
            //
            // make sure caller doesn't pass a value here
            // so we know we can use this at a later date
            //
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // convert machine-name to local
        //
        if(MachineName != NULL) {

            Err = pSetupCaptureAndConvertAnsiArg(MachineName,
                                                 &MachineString
                                                );
            if(Err != NO_ERROR) {
                leave;
            }
        }

        Err = _SetupDiGetClassRegistryProperty(ClassGuid,
                                               Property,
                                               PropertyRegDataType,
                                               PropertyBuffer,
                                               PropertyBufferSize,
                                               RequiredSize,
                                               MachineString,
                                               TRUE
                                              );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(MachineString) {
        MyFree(MachineString);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassRegistryProperty(
    IN  CONST GUID       *ClassGuid,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize,        OPTIONAL
    IN  PCTSTR           MachineName,         OPTIONAL
    IN  PVOID            Reserved
    )
/*++

Routine Description:

    This routine gets the specified Plug & Play device class registry property.
    This is just a wrapper around the Config Mgr API
    Typically the properties here can be overridden on a per-device basis,
    however this routine returns the class properties only.

Arguments:

    ClassGuid - Supplies the GUID for the device setup class from which the
        property is to be retrieved.

    Property - Supplies an ordinal specifying the property to be retrieved.
        Refer to sdk\inc\setupapi.h for a complete listing of values that may
        be set (these values are denoted with 'R/W' in their descriptive
        comment).

    PropertyRegDataType - Optionally, supplies the address of a variable that
        will receive the data type of the property being retrieved.  This will
        be one of the standard registry data types (REG_SZ, REG_BINARY, etc.)

    PropertyBuffer - Supplies the address of a buffer that receives the
        property data.

    PropertyBufferSize - Supplies the length, in bytes, of PropertyBuffer.

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of bytes required to store the requested property in the
        buffer.

    MachineName - Allows properties to be set on a remote machine (if Non-NULL)

    Reserved - should be NULL

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    DWORD Err = NO_ERROR;

    try {

        if(Reserved != NULL) {
            //
            // make sure caller doesn't pass a value here
            // so we know we can use this at a later date
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        Err = _SetupDiGetClassRegistryProperty(ClassGuid,
                                               Property,
                                               PropertyRegDataType,
                                               PropertyBuffer,
                                               PropertyBufferSize,
                                               RequiredSize,
                                               MachineName,
                                               FALSE
                                              );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
_SetupDiSetClassRegistryProperty(
    IN  CONST GUID      *ClassGuid,
    IN  DWORD            Property,
    IN  CONST BYTE*      PropertyBuffer,      OPTIONAL
    IN  DWORD            PropertyBufferSize,
    IN  PCTSTR           MachineName,         OPTIONAL
    IN  BOOL             Ansi
    )
/*++

    See SetupDiGetClassRegistryProperty

--*/
{
    DWORD Err;
    CONFIGRET cr;
    ULONG CmRegProperty, PropLength;
    HMACHINE hMachine = NULL;

    Err = NO_ERROR;

    try {
        //
        // if we want to set register for another machine, find that machine
        //
        if(MachineName) {

            if(CR_SUCCESS != (cr = CM_Connect_Machine(MachineName, &hMachine))) {
                //
                // Make sure machine handle is still invalid, so we won't
                // try to disconnect later.
                //
                hMachine = NULL;
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                leave;
            }
        }

        if(Property < SPCRP_MAXIMUM_PROPERTY) {
            CmRegProperty = (ULONG)SPCRP_TO_CMCRP(Property);
        } else {
            Err = ERROR_INVALID_REG_PROPERTY;
            leave;
        }

        PropLength = PropertyBufferSize;

        if(Ansi) {
            cr = CM_Set_Class_Registry_PropertyA(
                    (LPGUID)ClassGuid,
                    CmRegProperty,
                    PropertyBuffer,
                    PropLength,
                    0,
                    hMachine);
         } else {
             cr = CM_Set_Class_Registry_PropertyW(
                     (LPGUID)ClassGuid,
                     CmRegProperty,
                     PropertyBuffer,
                     PropLength,
                     0,
                     hMachine);
         }

         Err = MapCrToSpError(cr, ERROR_INVALID_DATA);

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hMachine != NULL) {
        CM_Disconnect_Machine(hMachine);
    }

    return Err;
}


//
// ANSI version
//
WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassRegistryPropertyA(
    IN     CONST GUID      *ClassGuid,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize,
    IN     PCSTR            MachineName,       OPTIONAL
    IN     PVOID            Reserved
    )
/*++

    See SetupDiSetClassRegistryProperty

--*/
{
    PCWSTR MachineString = NULL;
    DWORD Err = NO_ERROR;

    try {

        if(Reserved != NULL) {
            //
            // make sure caller doesn't pass a value here
            // so we know we can use this at a later date
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // convert machine-name to local
        //
        if(MachineName != NULL) {

            Err = pSetupCaptureAndConvertAnsiArg(MachineName,
                                                 &MachineString
                                                );
            if(Err != NO_ERROR) {
                leave;
            }
        }

        Err = _SetupDiSetClassRegistryProperty(ClassGuid,
                                               Property,
                                               PropertyBuffer,
                                               PropertyBufferSize,
                                               MachineString,
                                               TRUE
                                              );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(MachineString) {
        MyFree(MachineString);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassRegistryProperty(
    IN     CONST GUID      *ClassGuid,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize,
    IN     PCTSTR           MachineName,       OPTIONAL
    IN     PVOID            Reserved
    )
/*++

Routine Description:

    This routine sets the specified Plug & Play device class registry property.
    This is just a wrapper around the Config Mgr API
    Typically the properties here can be overridden on a per-device basis

Arguments:

    ClassGuid - Supplies the device setup class GUID for which the property is
        to be set.

    Property - Supplies an ordinal specifying the property to be set.  Refer to
        sdk\inc\setupapi.h for a complete list of class properties that are
        writeable.

    PropertyBuffer - Supplies the address of a buffer containing the property
        data.

    PropertyBufferSize - Supplies the length, in bytes, of PropertyBuffer.

    MachineName - Optionally, specifies a remote machine where the class
        properties are to be set.

    Reserved - should be NULL

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    DWORD Err;

    try {

        if(Reserved != NULL) {
            //
            // make sure caller doesn't pass a value here
            // so we know we can use this at a later date
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        Err = _SetupDiSetClassRegistryProperty(ClassGuid,
                                               Property,
                                               PropertyBuffer,
                                               PropertyBufferSize,
                                               MachineName,
                                               FALSE
                                              );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
pSetupFindUniqueKey(
    IN HKEY   hkRoot,
    IN LPTSTR SubKey,
    IN size_t SubKeySize
    )
/*++

Routine Description:

    This routine finds a unique key under the specified subkey.  This key is
    of the form <SubKey>\xxxx, where xxxx is a base-10, 4-digit number.

Arguments:

    hkRoot - Root key under which the specified SubKey is located.

    SubKey - Supplies the address of a buffer containing the subkey name under
        which a unique key is to be generated.  This buffer must contain enough
        additional space to acccomodate the concatenation of "\\nnnn" (i.e.,
        5 extra characters, not counting terminating null.

    SubKeySize - Supplies the size, in characters, of the SubKey buffer.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.

--*/
{
    INT  i;
    HKEY hk;
    HRESULT hr;
    size_t SubKeyEnd;
    PTSTR InstancePath;
    size_t InstancePathBufferSize;

    //
    // Find the end of the string, so we know where to add our unique instance
    // subkey path.
    //
    hr = StringCchLength(SubKey,
                         SubKeySize,
                         &SubKeyEnd
                        );
    if(FAILED(hr)) {
        MYASSERT(FALSE);
        return FALSE;
    }

    InstancePath = SubKey + SubKeyEnd;
    InstancePathBufferSize = SubKeySize - SubKeyEnd;

    for(i = 0; i <= 9999; i++) {

        hr = StringCchPrintf(InstancePath,
                             InstancePathBufferSize,
                             pszUniqueSubKey,
                             i
                             );
        if(FAILED(hr)) {
            MYASSERT(FALSE);
            return FALSE;
        }

        if(ERROR_SUCCESS != RegOpenKeyEx(hkRoot, SubKey, 0, KEY_READ, &hk)) {
            return TRUE;
        }
        RegCloseKey(hk);
    }

    return FALSE;
}


BOOL
WINAPI
SetupDiDeleteDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType
    )
/*++

Routine Description:

    This routine deletes the specified registry key(s) associated with a device
    information element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device instance to delete key(s) for.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure
        indicating the device instance to delete key(s) for.

    Scope - Specifies the scope of the registry key to be deleted.  This
        determines where the key to be deleted is located--the key may be one
        that is global (i.e., constant regardless of current hardware profile)
        or hardware profile-specific.  May be a combination of the following
        values:

        DICS_FLAG_GLOBAL - Delete the key that stores global configuration
                           information.

        DICS_FLAG_CONFIGSPECIFIC - Delete the key that stores hardware profile-
                                   specific information.

    HwProfile - Specifies the hardware profile to delete a key for, if the
        Scope parameter includes the DICS_FLAG_CONFIGSPECIFIC flag.  If this
        parameter is 0, then the key for the current hardware profile should be
        deleted (i.e., in the Class branch under HKEY_CURRENT_CONFIG).  If this
        parameter is 0xFFFFFFFF, then the key for _all_ hardware profiles
        should be deleted.

    KeyType - Specifies the type of registry storage key to be deleted.  May be
        one of the following values:

        DIREG_DEV - Delete the hardware registry key for the device.  This is
                    the key for storage of driver-independent configuration
                    information.  (This key is in the device instance key in
                    the Enum branch.

        DIREG_DRV - Delete the software (i.e., driver) registry key for the
                    device.  (This key is located in the class branch.)

        DIREG_BOTH - Delete both the hardware and software keys for the device.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    CONFIGRET cr;

    try {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                   DeviceInfoData,
                                                   NULL)) {

            Err = pSetupDeleteDevRegKeys(DevInfoElem->DevInst,
                                         Scope,
                                         HwProfile,
                                         KeyType,
                                         FALSE,
                                         pDeviceInfoSet->hMachine
                                        );

        } else {
            Err = ERROR_INVALID_PARAMETER;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
pSetupDeleteDevRegKeys(
    IN DEVINST  DevInst,
    IN DWORD    Scope,
    IN DWORD    HwProfile,
    IN DWORD    KeyType,
    IN BOOL     DeleteUserKeys,
    IN HMACHINE hMachine        OPTIONAL
    )
/*++

Routine Description:

    This is the worker routine for SetupDiDeleteDevRegKey.  See the discussion
    of that API for details.

Return Value:

    If successful, the return value is NO_ERROR;

    If failure, the return value is a Win32 error code indicating the cause of
    failure.

Remarks:

    Even if one of the operations in this routine fails, all operations will be
    attempted.  Thus, as many keys as possible will be deleted.  The error
    returned will be the first error that was encountered in this case.

--*/
{
    CONFIGRET cr = CR_SUCCESS, crTemp;
    TCHAR DriverKey[GUID_STRING_LEN + 5];   // Eg, {4d36e978-e325-11ce-bfc1-08002be10318}\0000
    size_t DriverKeyLength;
    HRESULT hr;

    if(Scope & DICS_FLAG_GLOBAL) {

        if((KeyType == DIREG_DRV) || (KeyType == DIREG_BOTH)) {
            //
            // Retrieve the current Driver key name, in case we have to restore
            // it.
            //
            DriverKeyLength = sizeof(DriverKey);
            cr = CM_Get_DevInst_Registry_Property_Ex(DevInst,
                                                     CM_DRP_DRIVER,
                                                     NULL,
                                                     DriverKey,
                                                     (PULONG)&DriverKeyLength,
                                                     0,
                                                     hMachine
                                                    );
            if(cr == CR_SUCCESS) {
                //
                // Get the actual size of the driver key name returned.
                //
                hr = StringCchLength(DriverKey,
                                     SIZECHARS(DriverKey),
                                     &DriverKeyLength
                                    );
                if(!MYVERIFY(SUCCEEDED(hr))) {
                    //
                    // CM API gave us garbage!!!
                    //
                    return ERROR_INVALID_DATA;
                }

                DriverKeyLength = (DriverKeyLength + 1) * sizeof(TCHAR);

                MYASSERT(DriverKeyLength == sizeof(DriverKey));

                //
                // Driver key exists and is valid, so make sure we delete its
                // per-hwprofile and per-user counterparts as well.
                //
                Scope |= DICS_FLAG_CONFIGSPECIFIC;
                HwProfile = (DWORD)-1;
                DeleteUserKeys = TRUE;

            } else if(cr == CR_NO_SUCH_VALUE) {
                //
                // There is no driver key, so don't bother trying to delete it
                // (in any of its forms).
                //
                if(KeyType == DIREG_BOTH) {
                    //
                    // Still need to delete the device keys.
                    //
                    KeyType = DIREG_DEV;

                    //
                    // If the device keys all get deleted successfully, then
                    // we'll consider the function call successful.
                    //
                    cr = CR_SUCCESS;

                } else {
                    //
                    // We weren't asked to delete any device keys, so we're
                    // done!
                    //
                    return NO_ERROR;
                }

            } else {
                //
                // We failed for some other reason--remember this error.  If
                // we're supposed to delete device keys, we'll go ahead and
                // try to do that.
                //
                if(KeyType == DIREG_BOTH) {
                    KeyType = DIREG_DEV;
                } else {
                    return MapCrToSpError(cr, ERROR_INVALID_DATA);
                }
            }
        }
    }

    if(Scope & DICS_FLAG_CONFIGSPECIFIC) {

        if((KeyType == DIREG_DEV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key_Ex(DevInst,
                                              HwProfile,
                                              CM_REGISTRY_HARDWARE | CM_REGISTRY_CONFIG,
                                              hMachine
                                             );
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }

        if((KeyType == DIREG_DRV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key_Ex(DevInst,
                                              HwProfile,
                                              CM_REGISTRY_SOFTWARE | CM_REGISTRY_CONFIG,
                                              hMachine
                                             );
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }
    }

    if(DeleteUserKeys) {

        if((KeyType == DIREG_DEV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key_Ex(DevInst,
                                              0,
                                              CM_REGISTRY_HARDWARE | CM_REGISTRY_USER,
                                              hMachine
                                             );
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }

        if((KeyType == DIREG_DRV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key_Ex(DevInst,
                                              0,
                                              CM_REGISTRY_SOFTWARE | CM_REGISTRY_USER,
                                              hMachine
                                             );
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }
    }

    //
    // We intentionally save the global keys for last.  As part of deleting the
    // driver key, we _should_ also reset the devnode's Driver property, since
    // there is a small window during which it is pointing to a non-nonexistent
    // key, but some other devnode might come along and claim that empty slot.
    // Voila!  You'd then have two devnodes sharing the same driver key.  This
    // would be _very_ bad.  Unfortunately, the driver value must remain in tact
    // until _after_ the key has been deleted.
    //
    // NTRAID#NTBUG9-613881-2002/05/01-lonnym -- CfgMgr should ensure driver key integrity
    //
    if(Scope & DICS_FLAG_GLOBAL) {

        if((KeyType == DIREG_DEV) || (KeyType == DIREG_BOTH)) {
            crTemp = CM_Delete_DevInst_Key_Ex(DevInst,
                                              0,
                                              CM_REGISTRY_HARDWARE,
                                              hMachine
                                             );
            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }

        if((KeyType == DIREG_DRV) || (KeyType == DIREG_BOTH)) {

            crTemp = CM_Delete_DevInst_Key_Ex(DevInst,
                                              0,
                                              CM_REGISTRY_SOFTWARE,
                                              hMachine
                                             );

            if(crTemp == CR_SUCCESS) {
                //
                // First, we delete the key.  Then, we reset the Driver property
                // to sever the link with the key.  We have to do things in this
                // order since deleting the key always depends on the Driver
                // property to be there.  Ideally, we would do things in the
                // reverse order.  By deleting the key first, it is technically
                // possible another devnode could come and grab that slot, with
                // our devnode still pointing there for a brief period of time.
                //
                CM_Set_DevInst_Registry_Property_Ex(DevInst,
                                                    CM_DRP_DRIVER,
                                                    NULL,
                                                    0,
                                                    0,
                                                    hMachine
                                                   );
            }

            if((cr == CR_SUCCESS) && (crTemp != CR_SUCCESS) && (crTemp != CR_NO_SUCH_REGISTRY_KEY)) {
                cr = crTemp;
            }
        }
    }

    return MapCrToSpError(cr, ERROR_INVALID_DATA);
}


//
// ANSI version
//
HKEY
WINAPI
SetupDiCreateDeviceInterfaceRegKeyA(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired,
    IN HINF                      InfHandle,           OPTIONAL
    IN PCSTR                     InfSectionName       OPTIONAL
    )
{
    DWORD rc;
    PWSTR name = NULL;
    HKEY h = INVALID_HANDLE_VALUE;

    try {

        if(InfSectionName) {
            rc = pSetupCaptureAndConvertAnsiArg(InfSectionName, &name);
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                         h = SetupDiCreateDeviceInterfaceRegKeyW(
                                 DeviceInfoSet,
                                 DeviceInterfaceData,
                                 Reserved,
                                 samDesired,
                                 InfHandle,
                                 name)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(name) {
        MyFree(name);
    }

    SetLastError(rc);
    return(h);
}

HKEY
WINAPI
SetupDiCreateDeviceInterfaceRegKey(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired,
    IN HINF                      InfHandle,           OPTIONAL
    IN PCTSTR                    InfSectionName       OPTIONAL
    )
/*++

Routine Description:

    This routine creates a registry storage key for a particular device
    interface, and returns a handle to the key.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device interface for whom a registry key is to be created.

    DeviceInterfaceData - Supplies a pointer to a device interface data
        structure indicating which device interface a key is to be created for.

    Reserved - Reserved for future use, must be set to 0.

    samDesired - Specifies the registry access desired for the resulting key
        handle.

    InfHandle - Optionally, supplies the handle of an opened INF file
        containing an install section to be executed for the newly-created key.
        If this parameter is specified, then InfSectionName must be specified
        as well.

        NOTE: INF-based installation is not supported for remoted device
        information sets (e.g., as created by passing a non-NULL MachineName in
        to SetupDiCreateDeviceInfoListEx).  This routine will fail with
        ERROR_REMOTE_REQUEST_UNSUPPORTED in those cases.

    InfSectionName - Optionally, supplies the name of an install section in the
        INF file specified by InfHandle.  This section will be executed for the
        newly created key. If this parameter is specified, then InfHandle must
        be specified as well.

Return Value:

    If the function succeeds, the return value is a handle to a newly-created
    registry key where private configuration data pertaining to this device
    interface may be stored/retrieved.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    The handle returned from this routine must be closed by calling
    RegCloseKey.

    During GUI-mode setup on Windows NT, quiet-install behavior is always
    employed in the absence of a user-supplied file queue, regardless of
    whether the device information element has the DI_QUIETINSTALL flag set.

--*/

{
    HKEY hk = INVALID_HANDLE_VALUE, hSubKey = INVALID_HANDLE_VALUE;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL FreeMsgHandlerContext = FALSE;
    BOOL MsgHandlerIsNativeCharWidth;
    BOOL NoProgressUI;
    DWORD KeyDisposition;

    try {

        if(Reserved != 0) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // Make sure that either both InfHandle and InfSectionName are
        // specified, or neither are...
        //
        if(InfHandle && (InfHandle != INVALID_HANDLE_VALUE)) {
            if(!InfSectionName) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }
        } else {
            if(InfSectionName) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            } else {
                //
                // Let's stick with _one_ value to indicate that the INF handle
                // wasn't suplied (the official one)...
                //
                InfHandle = INVALID_HANDLE_VALUE;
            }
        }

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        //
        // We don't support installation remotely.
        //
        if((pDeviceInfoSet->hMachine) && (InfHandle != INVALID_HANDLE_VALUE)) {
            Err = ERROR_REMOTE_REQUEST_UNSUPPORTED;
            leave;
        }

        //
        // Get a pointer to the device information element for the specified
        // device interface.
        //
        if(!(DevInfoElem = FindDevInfoElemForDeviceInterface(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        Err = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                          hk = SetupDiOpenClassRegKeyEx(
                                   &(DeviceInterfaceData->InterfaceClassGuid),
                                   KEY_READ,
                                   DIOCR_INTERFACE,
                                   (pDeviceInfoSet->hMachine
                                       ? pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                                  pDeviceInfoSet->MachineName)
                                       : NULL),
                                   NULL)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // Now, create the client-accessible registry storage key for this
        // device interface.
        //
        Err = pSetupOpenOrCreateDeviceInterfaceRegKey(hk,
                                                      pDeviceInfoSet,
                                                      DeviceInterfaceData,
                                                      TRUE,
                                                      samDesired,
                                                      &hSubKey,
                                                      &KeyDisposition
                                                     );
        if(Err != NO_ERROR) {
            leave;
        }

        //
        // We successfully created the storage key, now run an INF install
        // section against it (if specified).
        //
        if(InfHandle != INVALID_HANDLE_VALUE) {
            //
            // If a copy msg handler and context haven't been specified, then
            // use the default one.
            //
            if(DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                MsgHandler        = DevInfoElem->InstallParamBlock.InstallMsgHandler;
                MsgHandlerContext = DevInfoElem->InstallParamBlock.InstallMsgHandlerContext;
                MsgHandlerIsNativeCharWidth = DevInfoElem->InstallParamBlock.InstallMsgHandlerIsNativeCharWidth;
            } else {

                NoProgressUI = (GuiSetupInProgress || (DevInfoElem->InstallParamBlock.Flags & DI_QUIETINSTALL));

                if(!(MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                             DevInfoElem->InstallParamBlock.hwndParent,
                                             (NoProgressUI ? INVALID_HANDLE_VALUE
                                                           : NULL),
                                             0,
                                             0,
                                             NULL))) {

                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    leave;
                }

                FreeMsgHandlerContext = TRUE;
                MsgHandler = SetupDefaultQueueCallback;
                MsgHandlerIsNativeCharWidth = TRUE;
            }

            Err = GLE_FN_CALL(FALSE,
                              _SetupInstallFromInfSection(
                                  DevInfoElem->InstallParamBlock.hwndParent,
                                  InfHandle,
                                  InfSectionName,
                                  SPINST_ALL ^ SPINST_LOGCONFIG,
                                  hSubKey,
                                  NULL,
                                  0,
                                  MsgHandler,
                                  MsgHandlerContext,
                                  INVALID_HANDLE_VALUE,
                                  NULL,
                                  MsgHandlerIsNativeCharWidth,
                                  NULL)
                             );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(FreeMsgHandlerContext) {
        SetupTermDefaultQueueCallback(MsgHandlerContext);
    }

    if(Err != NO_ERROR) {
        //
        // Close registry handle, if necessary, and delete key (if newly-
        // created).  We do this prior to unlocking the devinfo set so that at
        // least no one using this HDEVINFO can get at this half-finished key.
        //
        if(hSubKey != INVALID_HANDLE_VALUE) {

            RegCloseKey(hSubKey);
            hSubKey = INVALID_HANDLE_VALUE;

            //
            // If the key was newly-created, then we want to delete it.
            //
            if(KeyDisposition == REG_CREATED_NEW_KEY) {
                //
                // Now delete the device interface key.
                //
                MYASSERT(hk != INVALID_HANDLE_VALUE);
                Err = pSetupDeleteDeviceInterfaceKey(hk,
                                                     pDeviceInfoSet,
                                                     DeviceInterfaceData
                                                    );
            }
        }
    }

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return hSubKey;
}


HKEY
WINAPI
SetupDiOpenDeviceInterfaceRegKey(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired
    )
/*++

Routine Description:

    This routine opens a registry storage key for a particular device
    interface, and returns a handle to the key.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device interface for whom a registry key is to be opened.

    DeviceInterfaceData - Supplies a pointer to a device interface data
        structure indicating which device interface a key is to be opened for.

    Reserved - Reserved for future use, must be set to 0.

    samDesired - Specifies the access you require for this key.

Return Value:

    If the function succeeds, the return value is a handle to an opened
    registry key where private configuration data pertaining to this device
    interface may be stored/retrieved.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    The handle returned from this routine must be closed by calling RegCloseKey.

--*/

{
    HKEY hk = INVALID_HANDLE_VALUE, hSubKey = INVALID_HANDLE_VALUE;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    try {

        if(Reserved != 0) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        //
        // Get a pointer to the device information element for the specified
        // device interface.
        //
        if(!(DevInfoElem = FindDevInfoElemForDeviceInterface(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        Err = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                          hk = SetupDiOpenClassRegKeyEx(
                                   &(DeviceInterfaceData->InterfaceClassGuid),
                                   KEY_READ,
                                   DIOCR_INTERFACE,
                                   (pDeviceInfoSet->hMachine
                                       ? pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                                  pDeviceInfoSet->MachineName)
                                       : NULL),
                                   NULL)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // Now, open up the client-accessible registry storage key for this
        // device interface.
        //
        Err = pSetupOpenOrCreateDeviceInterfaceRegKey(hk,
                                                      pDeviceInfoSet,
                                                      DeviceInterfaceData,
                                                      FALSE,
                                                      samDesired,
                                                      &hSubKey,
                                                      NULL
                                                     );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    SetLastError(Err);
    return hSubKey;
}


BOOL
WINAPI
SetupDiDeleteDeviceInterfaceRegKey(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved
    )
/*++

Routine Description:

    This routine deletes the registry key associated with a device interface.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device interface whose registry key is to be deleted.

    DeviceInterfaceData - Supplies a pointer to a device interface data
        structure indicating which device interface is to have its registry key
        deleted.

    Reserved - Reserved for future use, must be set to 0.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    HKEY hk = INVALID_HANDLE_VALUE;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    try {

        if(Reserved != 0) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        //
        // Get a pointer to the device information element for the specified
        // device interface.
        //
        if(!(DevInfoElem = FindDevInfoElemForDeviceInterface(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        Err = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                          hk = SetupDiOpenClassRegKeyEx(
                                   &(DeviceInterfaceData->InterfaceClassGuid),
                                   KEY_READ,
                                   DIOCR_INTERFACE,
                                   (pDeviceInfoSet->hMachine
                                       ? pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                                  pDeviceInfoSet->MachineName)
                                       : NULL),
                                   NULL)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // Now delete the device interface key.
        //
        Err = pSetupDeleteDeviceInterfaceKey(hk,
                                             pDeviceInfoSet,
                                             DeviceInterfaceData
                                            );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
pSetupOpenOrCreateDeviceInterfaceRegKey(
    IN  HKEY                      hInterfaceClassKey,
    IN  PDEVICE_INFO_SET          DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN  BOOL                      Create,
    IN  REGSAM                    samDesired,
    OUT PHKEY                     hDeviceInterfaceKey,
    OUT PDWORD                    KeyDisposition       OPTIONAL
    )
/*++

Routine Description:

    This routine creates or opens a registry storage key for the specified
    device interface, and returns a handle to the opened key.

Arguments:

    hInterfaceClassKey - Supplies a handle to the opened interface class key,
        underneath which the device interface storage key is to be opened or
        created.

    DeviceInfoSet - Supplies a pointer to the device information set containing
        the device interface for which a registry storage key is to be opened
        or created.

    DeviceInterfaceData - Supplies a pointer to a device interface data
        structure indicating which device interface a key is to be opened/
        created for.

    Create - Specifies whether the key should be created if doesn't already
        exist.

    samDesired - Specifies the access you require for this key.

    hDeviceInterfaceKey - Supplies the address of a variable that receives a
        handle to the requested registry key.  (This variable will only be
        written to if the handle is successfully opened.)

    KeyDisposition - Optionally, supplies the address of a variable that
        receives the status of the returned key handle.  Can be either:

        REG_CREATED_NEW_KEY - The key did not exist and was created.

        REG_OPENED_EXISTING_KEY - The key existed and was simply opened without
                                  being changed.  (This will always be the case
                                  if the Create parameter is FALSE.)

Return Value:

    If the function is successful, the return value is NO_ERROR, otherwise, it
    is a Win32 error code indicating the error that occurred.

Remarks:

    The algorithm used to form the storage keys for a device interface must be
    kept in sync with the kernel mode implementation of
    IoOpenDeviceInterfaceRegistryKey.

--*/
{
    DWORD Err;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;
    LPGUID ClassGuid;
    HKEY hDeviceInterfaceRootKey = INVALID_HANDLE_VALUE;
    HKEY hSubKey;
    DWORD Disposition;
    PCTSTR DevicePath;

    try {
        //
        // Get the device interface node, and verify that its class matches
        // what the caller passed us.
        //
        DeviceInterfaceNode = (PDEVICE_INTERFACE_NODE)(DeviceInterfaceData->Reserved);
        ClassGuid = &(DeviceInfoSet->GuidTable[DeviceInterfaceNode->GuidIndex]);

        if(!IsEqualGUID(ClassGuid, &(DeviceInterfaceData->InterfaceClassGuid))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // Verify that this device interface hasn't been removed.
        //
        if(DeviceInterfaceNode->Flags & SPINT_REMOVED) {
            Err = ERROR_DEVICE_INTERFACE_REMOVED;
            leave;
        }

        //
        // OK, now open the device interface's root storage key.
        //
        DevicePath = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                              DeviceInterfaceNode->SymLinkName
                                             );

        if(ERROR_SUCCESS != OpenDeviceInterfaceSubKey(hInterfaceClassKey,
                                                      DevicePath,
                                                      KEY_READ,
                                                      &hDeviceInterfaceRootKey,
                                                      NULL,
                                                      NULL)) {
            //
            // Make sure hDeviceInterfaceRootKey is still INVALID_HANDLE_VALUE,
            // so we won't try to close it later.
            //
            hDeviceInterfaceRootKey = INVALID_HANDLE_VALUE;
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(Create) {

            Err = RegCreateKeyEx(hDeviceInterfaceRootKey,
                                 pszDeviceParameters,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 samDesired,
                                 NULL,
                                 &hSubKey,
                                 KeyDisposition
                                );
        } else {

            if(KeyDisposition) {
                //
                // We set this prior to calling RegOpenKeyEx because we don't
                // want anything to go wrong once we've successfully opened
                // that key (i.e., we're protecting against the case where
                // KeyDispositiot is a bogus pointer).
                //
                *KeyDisposition = REG_OPENED_EXISTING_KEY;
            }

            Err = RegOpenKeyEx(hDeviceInterfaceRootKey,
                               pszDeviceParameters,
                               0,
                               samDesired,
                               &hSubKey
                              );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hDeviceInterfaceRootKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hDeviceInterfaceRootKey);
    }

    if(Err == NO_ERROR) {
        *hDeviceInterfaceKey = hSubKey;
    }

    return Err;
}


DWORD
pSetupDeleteDeviceInterfaceKey(
    IN HKEY                      hInterfaceClassKey,
    IN PDEVICE_INFO_SET          DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    )
/*++

Routine Description:

    This routine deletes a device interface registry key (recursively deleting
    any subkeys as well).

Arguments:

    hInterfaceClassKey - Supplies the handle to the registry key underneath
        which the 2-level interface class hierarchy exists.

    DeviceInfoSet - Supplies a pointer to the device information set containing
        the device interface whose registry key is to be deleted.

    DeviceInterfaceData - Supplies a pointer to a device interface data
        structure indicating which device interface is to have its registry key
        deleted.

Return Value:

    If successful, the return value is NO_ERROR;

    If failure, the return value is a Win32 error code indicating the cause of
    failure.

--*/
{
    DWORD Err;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;
    LPGUID ClassGuid;
    HKEY hDeviceInterfaceRootKey;
    PCTSTR DevicePath;

    Err = NO_ERROR;
    hDeviceInterfaceRootKey = INVALID_HANDLE_VALUE;

    try {
        //
        // Get the device interface node, and verify that its class matches
        // what the caller passed us.
        //
        DeviceInterfaceNode = (PDEVICE_INTERFACE_NODE)(DeviceInterfaceData->Reserved);
        ClassGuid = &(DeviceInfoSet->GuidTable[DeviceInterfaceNode->GuidIndex]);

        if(!IsEqualGUID(ClassGuid, &(DeviceInterfaceData->InterfaceClassGuid))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // Verify that this device interface hasn't been removed.
        //
        if(DeviceInterfaceNode->Flags & SPINT_REMOVED) {
            Err = ERROR_DEVICE_INTERFACE_REMOVED;
            leave;
        }

        //
        // OK, now open the device interface's root storage key.
        //
        DevicePath = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                              DeviceInterfaceNode->SymLinkName
                                             );

        if(ERROR_SUCCESS != OpenDeviceInterfaceSubKey(hInterfaceClassKey,
                                                      DevicePath,
                                                      KEY_READ,
                                                      &hDeviceInterfaceRootKey,
                                                      NULL,
                                                      NULL)) {
            //
            // Make sure hDeviceInterfaceRootKey is still INVALID_HANDLE_VALUE, so we
            // won't try to close it later.
            //
            hDeviceInterfaceRootKey = INVALID_HANDLE_VALUE;
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        Err = pSetupRegistryDelnode(hDeviceInterfaceRootKey, pszDeviceParameters);

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hDeviceInterfaceRootKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hDeviceInterfaceRootKey);
    }

    return Err;
}


DWORD
_SetupDiGetCustomDeviceProperty(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PSP_DEVINFO_DATA  DeviceInfoData,
    IN  CONST VOID       *CustomPropertyName, // ANSI or Unicode, depending on "Ansi" param.
    IN  DWORD             Flags,
    OUT PDWORD            PropertyRegDataType, OPTIONAL
    OUT PBYTE             PropertyBuffer,
    IN  DWORD             PropertyBufferSize,
    OUT PDWORD            RequiredSize,        OPTIONAL
    IN  BOOL              Ansi
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    CONFIGRET cr;
    ULONG PropLength, CmFlags;

    //
    // At present, there's only one valid flag...
    //
    if(Flags & ~DICUSTOMDEVPROP_MERGE_MULTISZ) {
        return ERROR_INVALID_FLAGS;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        return ERROR_INVALID_HANDLE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element for the specified device
        // instance.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(Flags & DICUSTOMDEVPROP_MERGE_MULTISZ) {
            CmFlags = CM_CUSTOMDEVPROP_MERGE_MULTISZ;
        } else {
            CmFlags = 0;
        }

        PropLength = PropertyBufferSize;
        if(Ansi) {
            cr = CM_Get_DevInst_Custom_Property_ExA(
                    DevInfoElem->DevInst,
                    CustomPropertyName,
                    PropertyRegDataType,
                    PropertyBuffer,
                    &PropLength,
                    CmFlags,
                    pDeviceInfoSet->hMachine
                   );
        } else {
            cr = CM_Get_DevInst_Custom_Property_ExW(
                    DevInfoElem->DevInst,
                    CustomPropertyName,
                    PropertyRegDataType,
                    PropertyBuffer,
                    &PropLength,
                    CmFlags,
                    pDeviceInfoSet->hMachine
                   );
        }

        if((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL)) {

            if(RequiredSize) {
                *RequiredSize = PropLength;
            }
        }

        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return Err;
}


//
// Unicode version
//
BOOL
WINAPI
SetupDiGetCustomDevicePropertyW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  PCWSTR           CustomPropertyName,
    IN  DWORD            Flags,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the data for the specified property, either from the
    device information element's hardware key, or from the most-specific
    per-hardware-id storage key containing that property.

Arguments:

    DeviceInfoSet -- Supplies a handle to the device information set containing
        information about the device instance to retrieve a Plug & Play
        registry property for.

    DeviceInfoData -- Supplies a pointer to a SP_DEVINFO_DATA structure
        indicating the device instance to retrieve the Plug & Play registry
        property for

    CustomPropertyName - Supplies the name of the property to be retrieved.

    Flags - Supplies flags controlling how the property data is to be
        retrieved.  May be a combination of the following values:

        DICUSTOMDEVPROP_MERGE_MULTISZ : Merge the devnode-specific REG_SZ or
                                        REG_MULTI_SZ property (if present) with
                                        the per-hardware-id REG_SZ or
                                        REG_MULTI_SZ property (if present).
                                        The resultant data will always be a
                                        multi-sz list.

    PropertyRegDataType -- Optionally, supplies the address of a variable that
        will receive the data type of the property being retrieved.  This will
        be one of the standard registry data types (REG_SZ, REG_BINARY, etc.)

    PropertyBuffer -- Supplies the address of a buffer that receives the
        property data.

    PropertyBufferSize -- Supplies the length, in bytes, of PropertyBuffer.

    RequiredSize -- Optionally, supplies the address of a variable that
        receives the number of bytes required to store the requested property
        in the buffer.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.  If the supplied buffer was not large
    enough to hold the requested property, the error will be
    ERROR_INSUFFICIENT_BUFFER and RequiredSize will specify how large the
    buffer needs to be.

--*/

{
    DWORD Err;

    try {

        Err = _SetupDiGetCustomDeviceProperty(DeviceInfoSet,
                                              DeviceInfoData,
                                              CustomPropertyName,
                                              Flags,
                                              PropertyRegDataType,
                                              PropertyBuffer,
                                              PropertyBufferSize,
                                              RequiredSize,
                                              FALSE     // want Unicode results
                                             );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}

//
// ANSI version
//
BOOL
WINAPI
SetupDiGetCustomDevicePropertyA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  PCSTR            CustomPropertyName,
    IN  DWORD            Flags,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )

/*++

Routine Description:

    (See SetupDiGetCustomDevicePropertyW)

--*/

{
    DWORD Err;

    try {

        Err = _SetupDiGetCustomDeviceProperty(DeviceInfoSet,
                                              DeviceInfoData,
                                              CustomPropertyName,
                                              Flags,
                                              PropertyRegDataType,
                                              PropertyBuffer,
                                              PropertyBufferSize,
                                              RequiredSize,
                                              TRUE         // want ANSI results
                                             );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devres.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    devres.c

Abstract:

    Header for resource dialog routines

Author:

    Paula Tomlinson (paulat) 7-Feb-1996

--*/

#pragma once

#define MAX_MSG_LEN         512
#define MAX_VAL_LEN         25

#define MAX_SPINRANGE   0x7FFF

#define MAX_RES_PROPERTY_PAGES          6

#define DMPROP_FLAG_CHANGESSAVED        0x00000001
#define DMPROP_FLAG_64BIT_RANGE         0x00000002
#define DMPROP_FLAG_CLASSNAMECHANGED    0x00000100
#define DMPROP_FLAG_DEVDESCCHANGED      0x00000200
#define DMPROP_FLAG_DRVDESCCHANGED      0x00000400
#define DMPROP_FLAG_GLOBALDISCHANGED    0x00000800
#define DMPROP_FLAG_PROFILECHANGED      0x00001000
#define DMPROP_FLAG_DEVREMOVED          0x00002000
#define DMPROP_FLAG_VIEWONLYRES         0x00004000
#define DMPROP_FLAG_DEVUSAGECHANGE      0x00008000
#define DMPROP_FLAG_USESYSSETTINGS      0x00010000
#define DMPROP_FLAG_FIXEDCONFIG         0x00020000
#define DMPROP_FLAG_FORCEDONLY          0x00040000

#define DMPROP_FLAG_HASPROBLEM          0x00800000
#define DMPROP_FLAG_DISPLAY_ALLOC       0x01000000
#define DMPROP_FLAG_DISPLAY_BOOT        0x02000000
#define DMPROP_FLAG_DISPLAY_FORCED      0x04000000
#define DMPROP_FLAG_DISPLAY_BASIC       0x08000000
#define DMPROP_FLAG_DISPLAY_MASK        0x0f000000
#define DMPROP_FLAG_PARTIAL_MATCH       0x10000000
#define DMPROP_FLAG_MATCH_OUT_OF_ORDER  0x20000000
#define DMPROP_FLAG_NO_RESOURCES        0x40000000
#define DMPROP_FLAG_SINGLE_CONFIG       0x80000000

#define DEVRES_HELP TEXT("devmgr.hlp")

#ifdef ANSI_SETUPAPI
#define DEVRES_WIDTH_FLAGS (0)
#define DEVRES_PIRQ_RESOURCE PIRQ_RESOURCE
#define DEVRES_IRQ_RESOURCE IRQ_RESOURCE
#define DEVRES_AFFINITY ULONG32
#else
#define DEVRES_WIDTH_FLAGS CM_RESDES_WIDTH_64
#define DEVRES_PIRQ_RESOURCE PIRQ_RESOURCE_64
#define DEVRES_IRQ_RESOURCE IRQ_RESOURCE_64
#define DEVRES_AFFINITY ULONG64
#endif

typedef struct {
    PROPSHEETPAGE    psp;
    HIMAGELIST       himlResourceImages;
    ULONG            ConfigListLCType;
    LOG_CONF         CurrentLC;
    ULONG            CurrentLCType;
    LOG_CONF         MatchingLC;
    ULONG            MatchingLCType;
    LOG_CONF         SelectedLC;
    ULONG            SelectedLCType;
    HDEVINFO         hDevInfo;
    PSP_DEVINFO_DATA lpdi;
    HWND             hDlg;
    DWORD            dwFlags;
    DEVINST          DevInst;
    TCHAR            szDeviceID[MAX_DEVICE_ID_LEN];
    HANDLE           hDialogEvent;
} DMPROP_DATA, *LPDMPROP_DATA;

typedef struct {
    RESOURCEID  ResourceType;
    ULONG64     ulValue;
    ULONG64     ulLen;
} LCDATA, *PLCDATA;


typedef struct {
    RESOURCEID  ResType;
    RES_DES     MatchingResDes;
    ULONG       RangeCount;
    ULONG64     ulValue;
    ULONG64     ulLen;
    ULONG64     ulEnd;
    ULONG       ulFlags;
    BOOL        bValid;
    BOOL        bFixed;
} ITEMDATA, *PITEMDATA;


typedef struct  _ResourceEditInfo_tag {
    HWND             hDlg;
    ULONG            dwPropFlags;
    WORD             wResNum;
    RESOURCEID       ridResType;        // resource type
    LOG_CONF         KnownLC;
    LOG_CONF         MatchingBasicLC;
    LOG_CONF         SelectedBasicLC;
    RES_DES          ResDes;            // res des that values are based on
    LPBYTE           pData;             // data for ResDes field
    //DEVINST          dnDevInst;
    ULONG            ulRangeCount;      // range that resource settings are based on
    ULONG64          ulCurrentVal;      // current resource start value
    ULONG64          ulCurrentLen;      // current resource range length
    ULONG64          ulCurrentEnd;      // current resource end value
    ULONG            ulCurrentFlags;    // current resource type specific flag
    PSP_DEVINFO_DATA lpdi;              // only used for devinst
    DWORD            dwFlags;           // internal state information
    BOOL             bShareable;         // Resource is shareable
    HMACHINE         hMachine;
}   RESOURCEEDITINFO, *PRESOURCEEDITINFO;

// ClearEditResConflictList Flags defines
#define CEF_UNKNOWN             0x00000001

#define REI_FLAGS_CONFLICT      0x00000001
#define REI_FLAG_NONUSEREDIT    0x00000002
#define REI_FLAG_MODIFY         0x00000004


typedef struct Generic_Des_s {
   DWORD    GENERIC_Count;
   DWORD    GENERIC_Type;
} GENERIC_DES, *PGENERIC_DES;

typedef struct Generic_Resource_S {
   GENERIC_DES    GENERIC_Header;
} GENERIC_RESOURCE, *PGENERIC_RESOURCE;

#define szNoValue                   TEXT(" ?")
#define szOneDWordHexNoConflict     TEXT("%08lX")
#define szTwoDWordHexNoConflict     TEXT("%08lX - %08lX")
#define szOne64bitHexNoConflict     TEXT("%016I64X")
#define szTwo64bitHexNoConflict     TEXT("%016I64X - %016I64X")
#define szOneWordHexNoConflict      TEXT("%04lX")
#define szTwoWordHexNoConflict      TEXT("%04lX - %04lX")
#define szOneDecNoConflict          TEXT("%02u")

#define NO_LC_MATCH         (0x00000000)
#define LC_MATCH_SUPERSET   (0x00000001)
#define LC_MATCH_SUBSET     (0x00000002)
#define LC_MATCH            (0x00000003)
#define ORDERED_LC_MATCH    (0x00000004)

typedef struct _RESDES_ENTRY {
    struct _RESDES_ENTRY *Next;
    struct _RESDES_ENTRY *CrossLink;
    LPBYTE      ResDesData;
    RESOURCEID  ResDesType;
    ULONG       ResDesDataSize;
    RES_DES     ResDesHandle;
} RESDES_ENTRY, *PRESDES_ENTRY;

typedef struct _RDE_LIST {
    struct _RDE_LIST *Prev;
    struct _RDE_LIST *Next;
    PRESDES_ENTRY Entry;
} RDE_LIST, *PRDE_LIST;

typedef struct _ITEMDATA_LISTNODE {
    struct _ITEMDATA_LISTNODE  *Next;
    PITEMDATA                   ItemData;
} ITEMDATA_LISTNODE, *PITEMDATA_LISTNODE;

//
// NTRAID#166214-2000/08/19-JamieHun Conflict Supression Hack
// this stuff needs to be fixed proper
//

#define MAX_CE_TAGS (8)             // only recognise first 8 tags specified
#define CE_TAG_RESERVED TEXT("*")   // special tag
#define CE_RES_IO TEXT("IO")
#define CE_RES_MEM TEXT("MEM")
#define CE_RES_IRQ TEXT("IRQ")
#define CE_RES_DMA TEXT("DMA")

typedef struct _CE_TAGS {
    LONG    nTags;
    LONG    Tag[MAX_CE_TAGS];
} CE_TAGS, *PCE_TAGS;

typedef struct _CE_ENTRY {
    struct _CE_ENTRY * Next;
    RESOURCEID resType;
    ULONG64 resStart;
    ULONG64 resEnd;
    CE_TAGS tags;
} CE_ENTRY, *PCE_ENTRY;

typedef struct _CONFLICT_EXCEPTIONS {
    PVOID ceTagMap;
    PCE_ENTRY exceptions;
} CONFLICT_EXCEPTIONS, *PCONFLICT_EXCEPTIONS;

//
// Prototypes
//
HPROPSHEETPAGE
GetResourceSelectionPage(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

INT_PTR
CALLBACK
pResourcePickerDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );


UINT CALLBACK pResourcePickerPropPageCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
);

HMACHINE
pGetMachine(
    LPDMPROP_DATA   lpdmpd
    );

BOOL
pInitDevResourceDlg(
    LPDMPROP_DATA   lpdmpd
    );

PITEMDATA
pGetResourceToChange(
    IN  LPDMPROP_DATA   lpdmpd,
    OUT int             *pCur
    );

VOID
pCheckEnableResourceChange(
    LPDMPROP_DATA   lpdmpd
    );

BOOL
pDevHasConfig(
    DEVINST     DevInst,
    ULONG       ulConfigType,
    HMACHINE    hMachine
    );

DWORD
pGetMinLCPriority(
    IN DEVINST DevInst,
    IN ULONG   ulConfigType,
    IN HMACHINE hMachine
    );

BOOL
pDevRequiresResources(
    DEVINST DevInst,
    HMACHINE hMachine
    );

BOOL
pGetCurrentConfig(
    IN OUT  LPDMPROP_DATA lpdmpd
    );

void
pGetHdrValues(
    IN  LPBYTE      pData,
    IN  RESOURCEID  ResType,
    OUT PULONG64    pulValue,
    OUT PULONG64    pulLen,
    OUT PULONG64    pulEnd,
    OUT PULONG      pulFlags
    );

void
pGetRangeValues(
    IN  LPBYTE      pData,
    IN  RESOURCEID  ResType,
    IN  ULONG       ulIndex,
    OUT PULONG64    pulValue, OPTIONAL
    OUT PULONG64    pulLen, OPTIONAL
    OUT PULONG64    pulEnd, OPTIONAL
    OUT PULONG64    pulAlign, OPTIONAL
    OUT PULONG      pulFlags OPTIONAL
    );

BOOL
pAlignValues(
    IN OUT PULONG64  pulValue,
    IN     ULONG64   ulStart,
    IN     ULONG64   ulLen,
    IN     ULONG64   ulEnd,
    IN     ULONG64   ulAlignment,
    IN     int       Increment
    );

void
pFormatResString(
    LPDMPROP_DATA lpdmpd,
    LPTSTR      lpszString,
    ULONG64     ulVal,
    ULONG64     ulLen,
    RESOURCEID  ResType
    );

BOOL
pUnFormatResString(
    LPTSTR      lpszString,
    PULONG64    pulVal,
    PULONG64    pulEnd,
    RESOURCEID  ridResType
    );

BOOL
pConvertEditText(
    LPTSTR      lpszConvert,
    PULONG64    pulVal,
    RESOURCEID  ridResType
    );

void
pWarnResSettingNotEditable(
    HWND    hDlg,
    WORD    idWarning
    );

LPVOID
pGetListViewItemData(
    HWND hList,
    int iItem,
    int iSubItem
    );

BOOL
pSaveDevResSettings(
    LPDMPROP_DATA   lpdmpd
    );

BOOL
pSaveCustomResSettings(
    LPDMPROP_DATA   lpdmpd,
    IN HMACHINE     hMachine
    );

BOOL
pWriteResDesRangeToForced(
    IN LOG_CONF     ForcedLogConf,
    IN RESOURCEID   ResType,
    IN ULONG        RangeIndex,
    IN RES_DES      RD,             OPTIONAL
    IN LPBYTE       ResDesData,     OPTIONAL
    IN HMACHINE     hMachine        OPTIONAL
    );

BOOL
pWriteValuesToForced(
    IN LOG_CONF     ForcedLogConf,
    IN RESOURCEID   ResType,
    IN ULONG        RangeIndex,
    IN RES_DES      RD,
    IN ULONG64      ulValue,
    IN ULONG64      ulLen,
    IN ULONG64      ulEnd,
    IN HMACHINE     hMachine
    );

BOOL
MakeResourceData(
    OUT LPBYTE     *ppResourceData,
    OUT PULONG     pulSize,
    IN  RESOURCEID ResType,
    IN  ULONG64    ulValue,
    IN  ULONG64    ulLen,
    IN  ULONG      ulFlags
    );

BOOL
pShowWindow(
    IN HWND hWnd,
    IN int nShow
    );

BOOL
pEnableWindow(
    IN HWND hWnd,
    IN BOOL Enable
    );

BOOL
pGetResDesDataList(
    IN LOG_CONF LogConf,
    IN OUT PRESDES_ENTRY *pResList,
    IN BOOL bArbitratedOnly,
    IN HMACHINE hMachine
    );

VOID
pDeleteResDesDataList(
    IN PRESDES_ENTRY pResList
    );

VOID
pHideAllControls(
    IN LPDMPROP_DATA lpdmpd
    );

VOID
pShowViewNoResources(
    IN LPDMPROP_DATA lpdmpd
    );

BOOL
pShowViewMFReadOnly(
    IN LPDMPROP_DATA lpdmpd,
    IN BOOL HideIfProb
    );

BOOL
pShowViewReadOnly(
    IN LPDMPROP_DATA lpdmpd,
    IN BOOL HideIfProb
    );

VOID
pShowViewNoAlloc(
    IN LPDMPROP_DATA lpdmpd
    );

VOID
pShowViewNeedForced(
    IN LPDMPROP_DATA lpdmpd
    );

VOID
pShowViewAllEdit(
    IN LPDMPROP_DATA lpdmpd
    );

BOOL
pLoadCurrentConfig(
    IN LPDMPROP_DATA lpdmpd,
    BOOL ReadOnly
    );

BOOL
pLoadConfig(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF forceLC,
    ULONG forceLCType
    );

BOOL
bIsMultiFunctionChild(
    PSP_DEVINFO_DATA lpdi,
    HMACHINE         hMachine
    );

VOID
pSelectLogConf(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF forceLC,
    ULONG forceLCType,
    BOOL Always
    );


VOID
pChangeCurrentResSetting(
    IN LPDMPROP_DATA lpdmpd
    );

VOID
pShowConflicts(
    IN LPDMPROP_DATA lpdmpd
    );

VOID
pShowUpdateEdit(
    IN LPDMPROP_DATA lpdmpd
    );

int
pWarnNoSave(
    HWND    hDlg,
    WORD    idWarning
    );

BOOL
pOkToSave(
    IN LPDMPROP_DATA lpdmpd
    );


//
//
//


BOOL
pGetMatchingRange(
    IN ULONG64  ulKnownValue,
    IN ULONG64  ulKnownLen,
    IN LPBYTE   pData,
    IN RESOURCEID ResType,
    OUT PULONG  pRange,
    OUT PBOOL   pExact,
    OUT PULONG  pFlags
    );

ULONG
pMergeResDesDataLists(
    IN OUT PRESDES_ENTRY pKnown,
    IN OUT PRESDES_ENTRY pTest,
    OUT PULONG pMatchCount
    );

ULONG
pCompareLogConf(
    IN LOG_CONF KnownLogConf,
    IN LOG_CONF TestLogConf,
    IN HMACHINE hMachine,
    OUT PULONG pMatchCount
    );

BOOL
pFindMatchingAllocConfig(
    IN  LPDMPROP_DATA lpdmpd
    );

BOOL
pGetMatchingResDes(
    IN ULONG64    ulKnownValue,
    IN ULONG64    ulKnownLen,
    IN ULONG64    ulKnownEnd,
    IN RESOURCEID ResType,
    IN LOG_CONF   MatchingLogConf,
    OUT PRES_DES  pMatchingResDes,
    IN HMACHINE   hMachine
    );

BOOL
pConfigHasNoAlternates(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF testLC
    );

//
// NTRAID#166214-2000/08/19-JamieHun Conflict Supression Hack
// this stuff needs to be fixed proper
//
PCONFLICT_EXCEPTIONS pLoadConflictExceptions(
    IN LPDMPROP_DATA lpdmpd
    );

VOID pFreeConflictExceptions(
    IN PCONFLICT_EXCEPTIONS pExceptions
    );

BOOL pIsConflictException(
    IN LPDMPROP_DATA lpdmpd,
    IN PCONFLICT_EXCEPTIONS pExceptions,
    IN DEVINST devConflict,
    IN PCTSTR resDesc,
    IN RESOURCEID resType,
    IN ULONG64 resValue,
    IN ULONG64 resLength
    );

INT_PTR
WINAPI
EditResourceDlgProc(
    HWND    hDlg,
    UINT    wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
LocateClosestValue(
    IN LPBYTE      pData,
    IN RESOURCEID  ResType,
    IN ULONG64     TestValue,
    IN ULONG64     TestLen,
    IN INT         Mode,
    OUT PULONG64   OutValue, OPTIONAL
    OUT PULONG64   OutLen, OPTIONAL
    OUT PULONG     OutIndex OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devres1.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    devres1.c

Abstract:

    Routines for displaying resource dialogs.

Author:

    Paula Tomlinson (paulat) 7-Feb-1996

Revision History:

    Jamie Hunter (jamiehun) 19-Mar-1998
        Removed EditResource Dialog Proceedures into this file
        Resource picking functionality improved


--*/

#include "precomp.h"
#pragma hdrstop

#define Nearness(x,y) (((x)>(y))?(x)-(y):(y)-(x))

static UDACCEL udAccel[] = {{0,1},{1,16},{2,256},{3,4096},{4,16000}};

static const DWORD EditResHelpIDs[]=
{
    IDC_EDITRES_INSTRUCTIONS,   IDH_NOHELP,
    IDC_EDITRES_MFCHILDREN,     IDH_NOHELP,
    IDC_EDITRES_VALUE_LABEL,    IDH_DEVMGR_RESOURCES_EDIT_VALUE,
    IDC_EDITRES_VALUE,          IDH_DEVMGR_RESOURCES_EDIT_VALUE,
    IDC_EDITRES_CONFLICTINFO,   IDH_DEVMGR_RESOURCES_EDIT_INFO,
    IDC_EDITRES_CONFLICTTEXT,   IDH_DEVMGR_RESOURCES_EDIT_INFO,
    IDC_EDITRES_CONFLICTLIST,   IDH_DEVMGR_RESOURCES_EDIT_INFO,
    0, 0
};


void
InitEditResDlg(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei,
    ULONG64             ulVal,
    ULONG64             ulLen
    );

void
ClearEditResConflictList(
    HWND    hDlg,
    DWORD   dwFlags
    );

void
UpdateEditResConflictList(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei,
    ULONG64             ulVal,
    ULONG64             ulLen,
    ULONG               ulFlags
    );

void
GetOtherValues(
    IN     LPBYTE      pData,
    IN     RESOURCEID  ResType,
    IN     LONG        Increment,
    OUT    PULONG64    pulValue,
    OUT    PULONG64    pulLen,
    OUT    PULONG64    pulEnd
    );

void
UpdateEditResConflictList(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei,
    ULONG64             ulVal,
    ULONG64             ulLen,
    ULONG               ulFlags
    );

BOOL
bValidateResourceVal(
    HWND                hDlg,
    PULONG64            pulVal,
    PULONG64            pulLen,
    PULONG64            pulEnd,
    PULONG              pulIndex,
    PRESOURCEEDITINFO   lprei
    );

BOOL
bConflictWarn(
    HWND                hDlg,
    ULONG64             ulVal,
    ULONG64             ulLen,
    ULONG64             ulEnd,
    PRESOURCEEDITINFO   lprei
    );

void
ClearEditResConflictList(
    HWND    hDlg,
    DWORD   dwFlags
    );

void
UpdateMFChildList(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei
    );

//---------------------------------------------------------------------------
// Edit Resource Dialog Box
//---------------------------------------------------------------------------



INT_PTR
WINAPI
EditResourceDlgProc(
    HWND    hDlg,
    UINT    wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    TCHAR   szBuffer[MAX_PATH];
    //
    // ISSUE-2000/02/03-JamieHun Remove statics from EditResourceDlgProc
    //
    static  ULONG64   ulEditedValue, ulEditedLen, ulEditedEnd;


    switch (wMsg) {

        case WM_INITDIALOG: {

            PRESOURCEEDITINFO lprei = (PRESOURCEEDITINFO)lParam;
            ULONG             ulSize = 0;

            SetWindowLongPtr(hDlg, DWLP_USER, lParam);  // save for later msgs

            lprei->dwFlags &= ~REI_FLAGS_CONFLICT;   // no conflict yet
            lprei->dwFlags |= REI_FLAG_NONUSEREDIT; // no manual edits yet

            ulEditedValue = lprei->ulCurrentVal;
            ulEditedLen = lprei->ulCurrentLen;
            ulEditedEnd = lprei->ulCurrentEnd;

            InitEditResDlg(hDlg, lprei, ulEditedValue, ulEditedLen);

            SetFocus(GetDlgItem(hDlg, IDC_EDITRES_VALUE));
            break;  // return default (FALSE) to indicate we've set focus
        }

        case WM_NOTIFY: {

            PRESOURCEEDITINFO lprei = (PRESOURCEEDITINFO)GetWindowLongPtr(hDlg, DWLP_USER);
            LPNM_UPDOWN lpnm = (LPNM_UPDOWN)lParam;

            switch (lpnm->hdr.code) {

                case UDN_DELTAPOS:
                    if (lpnm->hdr.idFrom == IDC_EDITRES_SPIN) {

                        if (lpnm->iDelta > 0) {
                            GetOtherValues(lprei->pData, lprei->ridResType, +1,
                                           &ulEditedValue,
                                           &ulEditedLen,
                                           &ulEditedEnd);
                        } else {
                            GetOtherValues(lprei->pData, lprei->ridResType, -1,
                                           &ulEditedValue,
                                           &ulEditedLen,
                                           &ulEditedEnd);
                        }

                        pFormatResString(NULL,szBuffer, ulEditedValue, ulEditedLen,
                                        lprei->ridResType);

                        lprei->dwFlags |= REI_FLAG_NONUSEREDIT;
                        SetDlgItemText(hDlg, IDC_EDITRES_VALUE, szBuffer);
                        UpdateEditResConflictList(hDlg, lprei,
                                                  ulEditedValue,
                                                  ulEditedLen,
                                                  lprei->ulCurrentFlags);
                }
                break;
            }
            break;
        }

        case WM_COMMAND: {

            switch(LOWORD(wParam)) {

                case IDOK: {

                    PRESOURCEEDITINFO  lprei = (PRESOURCEEDITINFO) GetWindowLongPtr(hDlg, DWLP_USER);
                    ULONG ulIndex;

                    //
                    // Validate the values (could have been manually edited)
                    //
                    if (bValidateResourceVal(hDlg, &ulEditedValue, &ulEditedLen,
                                             &ulEditedEnd, &ulIndex, lprei)) {
                        //
                        // Warn if there is a conflict.  If use accepts conflict
                        // end the dialog, otherwise update the
                        // edit control since it may have been changed by the
                        // Validate call.
                        //
                        //No HMACHINE
                        if(bConflictWarn(hDlg, ulEditedValue, ulEditedLen,
                                         ulEditedEnd, lprei)) {

                            lprei->ulCurrentVal = ulEditedValue;
                            lprei->ulCurrentLen = ulEditedLen;
                            lprei->ulCurrentEnd = ulEditedEnd;
                            lprei->ulRangeCount = ulIndex;
                            EndDialog(hDlg, IDOK);

                            if (lprei->pData) {
                                MyFree(lprei->pData);
                            }

                        } else {
                            //
                            // Format and display the data
                            //
                            pFormatResString(NULL,szBuffer, ulEditedValue, ulEditedLen, lprei->ridResType);
                            SetDlgItemText(hDlg, IDC_EDITRES_VALUE, szBuffer);
                            //
                            // Update the Conflict List.
                            //
                            UpdateEditResConflictList(hDlg, lprei, ulEditedValue, ulEditedLen, lprei->ulCurrentFlags);
                        }

                    }
                    return TRUE;
                }

                case IDCANCEL: {

                    PRESOURCEEDITINFO lprei = (PRESOURCEEDITINFO)GetWindowLongPtr(hDlg, DWLP_USER);

                    if (lprei->pData) {
                        MyFree(lprei->pData);
                    }

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }

                case IDC_EDITRES_VALUE: {
                    switch (HIWORD(wParam)) {
                        case EN_CHANGE: {

                            PRESOURCEEDITINFO lprei = (PRESOURCEEDITINFO)GetWindowLongPtr(hDlg, DWLP_USER);

                            // If Non user edit, then clear the flag, else
                            // clear the conflict list, since we are unsure
                            // of what the user has entered at this time

                            if (lprei->dwFlags & REI_FLAG_NONUSEREDIT) {
                                lprei->dwFlags &= ~REI_FLAG_NONUSEREDIT;
                            } else {
                                ClearEditResConflictList(hDlg, CEF_UNKNOWN);
                            }
                            break;
                        }

                        // If the edit control looses focus, then we should
                        // validte the contents
                        case EN_KILLFOCUS: {
                        }
                        break;
                    }
                    break;
                }
            }
            break;
        }

        case WM_HELP:      // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, DEVRES_HELP, HELP_WM_HELP, (ULONG_PTR)EditResHelpIDs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, DEVRES_HELP, HELP_CONTEXTMENU, (ULONG_PTR)EditResHelpIDs);
            break;
   }
   return FALSE;

} // EditResourceDlgProc




void
InitEditResDlg(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei,
    ULONG64             ulVal,
    ULONG64             ulLen
    )
{
    TCHAR       szBuffer[MAX_PATH], szInstr[MAX_PATH], szTemp[MAX_PATH],
                szResType[MAX_PATH], szResTypeLC[MAX_PATH];
    ULONG       ulSize = 0;


    //
    // Set the initial Value
    //
    pFormatResString(NULL,szBuffer, ulVal, ulLen, lprei->ridResType);
    SetDlgItemText(hDlg, IDC_EDITRES_VALUE, szBuffer);

    //
    // Setup the Spinner
    //
    SendDlgItemMessage(hDlg, IDC_EDITRES_SPIN, UDM_SETRANGE, 0, MAKELONG(MAX_SPINRANGE, 0));
    SendDlgItemMessage(hDlg, IDC_EDITRES_SPIN, UDM_SETPOS, 0, MAKELONG(0,0));
    SendDlgItemMessage(hDlg, IDC_EDITRES_SPIN, UDM_SETACCEL, 5, (LPARAM)(LPUDACCEL)udAccel);

    //
    // Limit the Edit Text.
    //
    switch (lprei->ridResType) {

        case ResType_Mem:
            LoadString(MyDllModuleHandle, IDS_MEMORY_FULL, szResType, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_MEMORY_FULL_LC, szResTypeLC, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_RANGEINSTR1, szInstr, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_RANGEINSTR2, szTemp, MAX_PATH);
            lstrcat(szInstr, szTemp);

            //
            // Limit the Input field to Start Val (8) + End Val(8) + seperator (4)
            //
            SendDlgItemMessage(hDlg, IDC_EDITRES_VALUE, EM_LIMITTEXT, 20, 0l);
            break;

        case ResType_IO:
            LoadString(MyDllModuleHandle, IDS_IO_FULL, szResType, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_RANGEINSTR1, szInstr, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_RANGEINSTR2, szTemp, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_IO_FULL_LC, szResTypeLC, MAX_PATH);
            lstrcat(szInstr, szTemp);

            //
            // Limit the Input field to Start Val (4) + End Val(4) + seperator (4)
            //
            SendDlgItemMessage(hDlg, IDC_EDITRES_VALUE, EM_LIMITTEXT, 12, 0l);
            break;

        case ResType_DMA:
            LoadString(MyDllModuleHandle, IDS_DMA_FULL, szResType, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_SINGLEINSTR1, szInstr, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_SINGLEINSTR2, szTemp, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_DMA_FULL_LC, szResTypeLC, MAX_PATH);
            lstrcat(szInstr, szTemp);

            //
            // Limit the Input field to Val (2)
            //
            SendDlgItemMessage(hDlg, IDC_EDITRES_VALUE, EM_LIMITTEXT, 2, 0l);
            break;

        case ResType_IRQ:
            LoadString(MyDllModuleHandle, IDS_IRQ_FULL, szResType, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_SINGLEINSTR1, szInstr, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_EDITRES_SINGLEINSTR2, szTemp, MAX_PATH);
            LoadString(MyDllModuleHandle, IDS_IRQ_FULL_LC, szResTypeLC, MAX_PATH);
            lstrcat(szInstr, szTemp);

            //
            // Limit the Input field to Val (2)
            //
            SendDlgItemMessage(hDlg, IDC_EDITRES_VALUE, EM_LIMITTEXT, 2, 0l);
            break;
    }

    //
    // Set the Instruction Text
    //
    wsprintf(szBuffer, szInstr, szResTypeLC);
    SetDlgItemText(hDlg, IDC_EDITRES_INSTRUCTIONS, szBuffer);

    //
    // Set the Dialog Title
    //
    LoadString(MyDllModuleHandle, IDS_EDITRES_TITLE, szTemp, MAX_PATH);
    wsprintf(szBuffer, szTemp, szResType);
    SetWindowText(hDlg, szBuffer);

    //
    // If this is a MF parent device, then show which children own this resource.
    //
    UpdateMFChildList(hDlg, lprei);

    //
    // Read the res des data and store a ptr to it so we
    // don't have to refetch it multiple times.
    //
    lprei->pData = NULL;
    if (CM_Get_Res_Des_Data_Size_Ex(&ulSize, lprei->ResDes, CM_RESDES_WIDTH_64,lprei->hMachine) == CR_SUCCESS) {
        lprei->pData = MyMalloc(ulSize);
        if (lprei->pData != NULL) {
            CM_Get_Res_Des_Data_Ex(lprei->ResDes, lprei->pData, ulSize, CM_RESDES_WIDTH_64,lprei->hMachine);
        }
    }

    //
    // Update the Conflict List.
    //
    UpdateEditResConflictList(hDlg, lprei, ulVal, ulLen, lprei->ulCurrentFlags);


} // InitEditResDlg



BOOL
LocateClosestValue(
    IN LPBYTE      pData,
    IN RESOURCEID  ResType,
    IN ULONG64     TestValue,
    IN ULONG64     TestLen,
    IN INT         Mode,
    OUT PULONG64   OutValue, OPTIONAL
    OUT PULONG64   OutLen, OPTIONAL
    OUT PULONG     OutIndex OPTIONAL
    )
/*++

Routine Description:

    This routine finds the nearest valid address/range
    to that the user specified
    if Mode == 0, the nearest value is used
    if Mode > 0, the nearest higher value is used
    if Mode < 0, the nearest lower value is used

Arguments:

    pData - information about the resources being selected
    ResType - type of resource being selected
    CurrentValue - value entered by user
    CurrentLen - length based on range entered by user
    Mode - search mode, -1 = previous, 1 = next, 0 = nearest
    OutValue - nearest valid value
    OutLen - length associated with nearest valid value

Return Value:

    If exact match found, return TRUE
    otherwise FALSE

--*/
{
    PGENERIC_RESOURCE   pGenRes = (PGENERIC_RESOURCE)pData;
    ULONG64 Start, Len, End, Align;
    ULONG Flags;
    ULONG64 BestVal;
    ULONG64 BestValL;
    ULONG64 BestValU;
    ULONG64 FoundVal = 0;
    ULONG64 FoundLen = 0;
    ULONG FoundIndex = 0;
    ULONG Index;
    BOOL FindNearest = TRUE; // indicates we should find nearest

    //
    // precedence (1) Value&Len match exactly
    // precedence (2) closest valid value
    //

    //
    // cover a catch-all case - start of the very first resource range
    //
    pGetRangeValues(pData, ResType, 0, &Start, &Len, &End, &Align, &Flags);
    //
    // we have at least 1 found value
    //
    FoundVal = Start;
    FoundLen = Len;

    //
    // Find a nearby valid range to the one supplied
    //

    //
    // check each range at a time
    // sometimes ranges may not be given in ascending order
    // eg, first range is a preferred, second range is alternative
    //
    for (Index = 0; Index < pGenRes->GENERIC_Header.GENERIC_Count; Index++) {

        //
        // get limits for this range
        //
        pGetRangeValues(pData, ResType, Index, &Start, &Len, &End, &Align, &Flags);

        //
        // first, try to find a value that is GOOD, that is <= TestValue
        //

        BestValL = TestValue;
        if (pAlignValues(&BestValL, Start, Len, End, Align, -1) == FALSE) {
            //
            // if it failed, use the lowest value in this range (ie Start)
            //
            BestValL = Start;
        }

        //
        // find an upper value that is aligned
        //
        if (BestValL == TestValue) {
            //
            // if match was exact, skip test
            //
            BestValU = TestValue;
        } else {
            //
            // search for upper limit
            //
            BestValU = TestValue;
            if (pAlignValues(&BestValU, Start, Len, End, Align, 1) == FALSE) {
                //
                // couldn't use it - find highest valid value
                //
                BestValU = End-Len+1;
                if (pAlignValues(&BestValU, Start, Len, End, Align, -1) == FALSE) {
                    //
                    // still no go
                    //
                    BestValU = BestValL;
                }
            }
        }

        //
        // now we have found our boundaries
        // may need to modify, depending on preferences
        //

        if (Mode<0) {
            //
            // if range is < TestVal, use highest, else lowest
            //
            if (BestValU <= TestValue) {
                BestVal = BestValU;
            } else {
                BestVal = BestValL;
            }
        } else if (Mode>0) {
            //
            // if range is > TestVal, use lowest, else highest
            //
            if (BestValL >= TestValue) {
                BestVal = BestValL;
            } else {
                BestVal = BestValU;
            }
        } else {
            //
            // use closest of the two values
            //
            if (Nearness(BestValL,TestValue)<= Nearness(BestValU,TestValue)) {
                BestVal = BestValL;
            } else {
                BestVal = BestValU;
            }
        }

        //
        // we know that BestVal is valid within the range
        // and is the choice for this range
        //

        //
        // handle the match cases
        //
        if (TestValue == BestVal && TestLen == Len) {
            //
            // exact match
            //

            if (OutValue != NULL) {
                *OutValue = BestVal;
            }
            if (OutLen != NULL) {
                *OutLen = Len;
            }
            if (OutIndex != NULL) {
                *OutIndex = Index;
            }
            return TRUE;
        }

        if (FindNearest && Mode != 0) {
            //
            // we are currently in "FindNearest" mode which means
            // we haven't found one in the direction we wanted
            //
            if (Mode < 0 && BestVal <= TestValue) {
                //
                // not looking for nearness now we've found one lower
                //
                FoundVal = BestVal;
                FoundLen = Len;
                FoundIndex = Index;
                FindNearest = FALSE;
            } else if (Mode > 0 && BestVal >= TestValue) {
                //
                // not looking for nearness now we've found one higher
                //
                FoundVal = BestVal;
                FoundLen = Len;
                FoundIndex = Index;
                FindNearest = FALSE;
            }

        } else if (FindNearest ||
            (Mode < 0 && BestVal <= TestValue) ||
            (Mode > 0 && BestVal >= TestValue)) {
            if (Nearness(BestVal,TestValue) < Nearness(FoundVal,TestValue)) {
                //
                // this address is nearer
                //
                FoundVal = BestVal;
                FoundLen = Len;
                FoundIndex = Index;
            } else if (Nearness(BestVal,TestValue) == Nearness(FoundVal,TestValue)) {
                //
                // this address guess is as near as nearest guess, pick the better length
                //
                // I can't see any place that this should happen
                // but theoretically it could happen
                // so this is a safety net more than anything else
                //
                if (Nearness(Len,TestLen) < Nearness(FoundLen,TestLen)) {
                    //
                    // this length is nearer
                    //
                    FoundVal = BestVal;
                    FoundLen = Len;
                    FoundIndex = Index;
                } else if (Nearness(Len,TestLen) == Nearness(FoundLen,TestLen)) {
                    //
                    // pick the bigger (safer)
                    //
                    if (Len > FoundLen) {
                        //
                        // this length is bigger
                        //
                        FoundVal = BestVal;
                        FoundLen = Len;
                        FoundIndex = Index;
                    }
                }
            }
        }
    }

    //
    // if we get here, we didn't find an exact match
    //

    // Use our best guess
    if (OutValue != NULL) {
        *OutValue = FoundVal;
    }
    if (OutLen != NULL) {
        *OutLen = FoundLen;
    }
    if (OutIndex != NULL) {
        *OutIndex = FoundIndex;
    }
    return FALSE;

}


void
GetOtherValues(
    IN     LPBYTE      pData,
    IN     RESOURCEID  ResType,
    IN     LONG        Increment,
    IN OUT PULONG64    pulValue,
    IN OUT PULONG64    pulLen,
    IN OUT PULONG64    pulEnd
    )
/*++

Routine Description:

    Finds the next valid value, wrapping around to beginning/end value when end of range

Arguments:

    pData - resource data
    ResType - resource type
    Increment - 1 or -1
    pulValue - pointer to old/new start that is changed
    pulLen - pointer to old/new length
    pulEnd - pointer to old/new end

Return Value:

    none

--*/
{

    ULONG64 TestValue = *pulValue;
    ULONG64 TestLen = *pulLen;
    ULONG64 RetValue = 0;
    ULONG64 RetLen = 0;

    MYASSERT((Increment == 1) || (Increment == -1));

    if (Increment == 1) {
        TestValue++;
        LocateClosestValue(pData,ResType,TestValue,TestLen, 1 ,&RetValue,&RetLen,NULL);
        if (RetValue < TestValue) {
            //
            // wrap around, find lowest possible valid address
            //
            LocateClosestValue(pData,ResType,0,TestLen, 0 ,&RetValue,&RetLen,NULL);
        }
    } else {
        TestValue--;
        LocateClosestValue(pData,ResType,TestValue,TestLen, -1 ,&RetValue,&RetLen,NULL);
        if (RetValue > TestValue) {
            //
            // wrap around, find highest possible valid address
            //
            LocateClosestValue(pData,ResType,(ULONG64)(-1),TestLen, 0 ,&RetValue,&RetLen,NULL);
        }
    }

    *pulValue = RetValue;
    *pulLen = RetLen;
    *pulEnd = RetValue + RetLen - 1;

    return;

} // GetOtherValues


void
UpdateEditResConflictList(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei,
    ULONG64             ulVal,
    ULONG64             ulLen,
    ULONG               ulFlags
    )
/*++

Routine Description:

    Updates all the conflict information for the selected resource
    Should give more details than UpdateDevResConflictList

Arguments:

    hDlg - handle of this dialog to display into
    lprei - resource edit info
    ulVal - value to try
    ulLen - length to test
    ulFlags - flags part of resdes

Return Value:

    none

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    HWND        hwndConflictList = GetDlgItem(hDlg, IDC_EDITRES_CONFLICTLIST);
    ULONG       ConflictCount = 0;
    ULONG       ConflictIndex = 0;
    ULONG       ulSize = 0;
    LPBYTE      pResourceData = NULL;
    CONFLICT_LIST ConflictList = 0;
    PDEVICE_INFO_SET pDeviceInfoSet;
    CONFLICT_DETAILS ConflictDetails;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szItemFormat[MAX_PATH];
    BOOL        ReservedResource = FALSE;
    BOOL        BadResource = FALSE;

    //
    // need resource-data for determining conflict
    //
    if (MakeResourceData(&pResourceData, &ulSize,
                         lprei->ridResType,
                         ulVal,
                         ulLen,
                         ulFlags)) {

        Status = CM_Query_Resource_Conflict_List(&ConflictList,
                                                    lprei->lpdi->DevInst,
                                                    lprei->ridResType,
                                                    pResourceData,
                                                    ulSize,
                                                    DEVRES_WIDTH_FLAGS,
                                                    lprei->hMachine);

        if (Status != CR_SUCCESS) {
            //
            // error occurred
            //
            ConflictList = 0;
            ConflictCount =  0;
            BadResource = TRUE;
        } else {
            //
            // find out how many things conflicted
            //
            Status = CM_Get_Resource_Conflict_Count(ConflictList,&ConflictCount);
            if (Status != CR_SUCCESS) {
                //
                // error shouldn't occur
                //
                MYASSERT(Status == CR_SUCCESS);
                ConflictCount = 0;
                BadResource = TRUE;
            }
        }
    } else {
        MYASSERT(FALSE);
        //
        // should not fail
        //
        ConflictList = 0;
        ConflictCount =  0;
        BadResource = TRUE;
    }
    if (BadResource) {
        //
        // The resource conflict information is indeterminate
        //
        SendMessage(hwndConflictList, LB_RESETCONTENT, 0, 0L);
        lprei->dwFlags &= ~REI_FLAGS_CONFLICT;
        LoadString(MyDllModuleHandle, IDS_EDITRES_UNKNOWNCONFLICT, szBuffer, MAX_PATH);
        SetDlgItemText(hDlg, IDC_EDITRES_CONFLICTTEXT, szBuffer);
        LoadString(MyDllModuleHandle, IDS_EDITRES_UNKNOWNCONFLICTINGDEVS, szBuffer, MAX_PATH);
        SendMessage(hwndConflictList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer);

    } else if (ConflictCount || ReservedResource) {

    TreatAsReserved:

        SendMessage(hwndConflictList, LB_RESETCONTENT, 0, 0L);
        lprei->dwFlags |= REI_FLAGS_CONFLICT;

        if(ReservedResource == FALSE) {
            //
            // The resource conflicts with another unknown device.
            //
            LoadString(MyDllModuleHandle, IDS_EDITRES_DEVCONFLICT, szBuffer, MAX_PATH);
            SetDlgItemText(hDlg, IDC_EDITRES_CONFLICTTEXT, szBuffer);

            for(ConflictIndex = 0; ConflictIndex < ConflictCount ; ConflictIndex++) {

                //
                // obtain details for this conflict
                //
                ZeroMemory(&ConflictDetails,sizeof(ConflictDetails));
                ConflictDetails.CD_ulSize = sizeof(ConflictDetails);
                ConflictDetails.CD_ulMask = CM_CDMASK_DEVINST | CM_CDMASK_DESCRIPTION | CM_CDMASK_FLAGS;

                Status = CM_Get_Resource_Conflict_Details(ConflictList,ConflictIndex,&ConflictDetails);
                if (Status == CR_SUCCESS) {
                    if ((ConflictDetails.CD_ulFlags & CM_CDFLAGS_RESERVED) != 0) {
                        //
                        // treat as reserved - backtrack
                        //
                        ReservedResource = TRUE;
                        goto TreatAsReserved;
                    }
                    //
                    // convert CD_dnDevInst to string information
                    //
                    lstrcpy(szBuffer,ConflictDetails.CD_szDescription);
                    if (szBuffer[0] == 0) {
                        ReservedResource = TRUE;
                        goto TreatAsReserved;
                    }

                } else {
                    MYASSERT(Status == CR_SUCCESS);
                    ReservedResource = TRUE;
                    goto TreatAsReserved;
                }

                SendMessage(hwndConflictList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer);
            }
        } else {
            LoadString(MyDllModuleHandle, IDS_EDITRES_RESERVED, szBuffer, MAX_PATH);
            SetDlgItemText(hDlg, IDC_EDITRES_CONFLICTTEXT, szBuffer);
            LoadString(MyDllModuleHandle, IDS_EDITRES_RESERVEDRANGE, szBuffer, MAX_PATH);
            SendMessage(hwndConflictList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer);
        }

    } else {
        //
        // The resource does not conflict with any other devices.
        //
        SendMessage(hwndConflictList, LB_RESETCONTENT, 0, 0L);
        lprei->dwFlags &= ~REI_FLAGS_CONFLICT;
        LoadString(MyDllModuleHandle, IDS_EDITRES_NOCONFLICT, szBuffer, MAX_PATH);
        SetDlgItemText(hDlg, IDC_EDITRES_CONFLICTTEXT, szBuffer);
        LoadString(MyDllModuleHandle, IDS_EDITRES_NOCONFLICTINGDEVS, szBuffer, MAX_PATH);
        SendMessage(hwndConflictList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer);
    }

    if (ConflictList) {
        CM_Free_Resource_Conflict_Handle(ConflictList);
    }

    if (pResourceData != NULL) {
        MyFree(pResourceData);
    }

    return;
}


BOOL
bValidateResourceVal(
    HWND                hDlg,
    PULONG64            pulVal,
    PULONG64            pulLen,
    PULONG64            pulEnd,
    PULONG              pulIndex,
    PRESOURCEEDITINFO   lprei
    )
{
    TCHAR    szSetting[MAX_VAL_LEN], szNewSetting[MAX_VAL_LEN];
    TCHAR    szMessage[MAX_MSG_LEN], szTemp[MAX_MSG_LEN], szTemp1[MAX_MSG_LEN];
    TCHAR    szTitle[MAX_PATH];
    ULONG64  ulVal, ulEnd, ulLen;
    ULONG64  ulValidVal, ulValidLen;
    ULONG    ulIndex;
    BOOL     bRet;
    BOOL     exact = TRUE;


    GetDlgItemText(hDlg, IDC_EDITRES_VALUE, szSetting, MAX_VAL_LEN);

    if (pUnFormatResString(szSetting, &ulVal, &ulEnd, lprei->ridResType)) {

        ulLen = ulEnd - ulVal + 1;

        //
        // Validate the Current Settings
        //
        // If an exact match doesn't exist
        // use a close match
        // close is based on start address
        //

        if (LocateClosestValue(lprei->pData, lprei->ridResType,
                                ulVal, ulLen,0,
                                &ulValidVal, &ulValidLen,&ulIndex) == FALSE) {
            //
            // An alternate setting was found
            // we think this might be what the user wanted
            //
            LoadString(MyDllModuleHandle, IDS_EDITRES_ENTRYERROR, szTitle, MAX_PATH);

            LoadString(MyDllModuleHandle, IDS_EDITRES_VALIDATEERROR1, szTemp, MAX_MSG_LEN);
            LoadString(MyDllModuleHandle, IDS_EDITRES_VALIDATEERROR2, szTemp1, MAX_MSG_LEN);
            lstrcat(szTemp, szTemp1);
            LoadString(MyDllModuleHandle, IDS_EDITRES_VALIDATEERROR3, szTemp1, MAX_MSG_LEN);
            lstrcat(szTemp, szTemp1);

            pFormatResString(NULL, szSetting, ulVal, ulLen, lprei->ridResType);
            pFormatResString(NULL,szNewSetting, ulValidVal, ulValidLen, lprei->ridResType);

            wsprintf(szMessage, szTemp, szSetting, szNewSetting);

            if (MessageBox(hDlg, szMessage, szTitle,
                           MB_YESNO | MB_TASKMODAL | MB_ICONEXCLAMATION) == IDYES) {
                //
                // Update the Edited values.
                //
                *pulVal = ulValidVal;
                *pulLen = ulValidLen;
                *pulEnd = ulValidVal + ulValidLen - 1;
                *pulIndex = ulIndex;
                bRet = TRUE;
            } else {
                bRet = FALSE;
            }

        } else {
            //
            // The specified values are valid
            //
            *pulVal = ulVal;
            *pulLen = ulLen;
            *pulEnd = ulEnd;
            *pulIndex = ulIndex;
            bRet = TRUE;
        }

    } else {

        switch (lprei->ridResType) {
            case ResType_Mem:
                LoadString(MyDllModuleHandle, IDS_ERROR_BADMEMTEXT, szMessage, MAX_MSG_LEN);
                break;
            case ResType_IO:
                LoadString(MyDllModuleHandle, IDS_ERROR_BADIOTEXT, szMessage, MAX_MSG_LEN);
                break;
            case ResType_DMA:
                LoadString(MyDllModuleHandle, IDS_ERROR_BADDMATEXT, szMessage, MAX_MSG_LEN);
                break;
            case ResType_IRQ:
                LoadString(MyDllModuleHandle, IDS_ERROR_BADIRQTEXT, szMessage, MAX_MSG_LEN);
                break;
        }

        LoadString(MyDllModuleHandle, IDS_EDITRES_ENTRYERROR, szTitle, MAX_PATH);
        MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_TASKMODAL | MB_ICONASTERISK);
        bRet = FALSE;
    }

    return bRet;

} // bValidateResoureceVal



BOOL
bConflictWarn(
    HWND                hDlg,
    ULONG64             ulVal,
    ULONG64             ulLen,
    ULONG64             ulEnd,
    PRESOURCEEDITINFO   lprei
    )
{
    BOOL    bRet = TRUE;
    TCHAR   szMessage[MAX_MSG_LEN], szTitle[MAX_PATH];


    if (!(lprei->dwFlags & REI_FLAG_NONUSEREDIT)) {
        //
        // user edits have been made so the conflict flag may not be
        // up-to-date, check conflicts now.
        //
        UpdateEditResConflictList(hDlg, lprei, ulVal, ulLen, lprei->ulCurrentFlags);
    }

    if (lprei->dwFlags & REI_FLAGS_CONFLICT) {

        LoadString(MyDllModuleHandle, IDS_EDITRES_CONFLICTWARNMSG, szMessage, MAX_MSG_LEN);
        LoadString(MyDllModuleHandle, IDS_EDITRES_CONFLICTWARNTITLE, szTitle, MAX_PATH);

        if (MessageBox(hDlg, szMessage, szTitle,
                MB_YESNO | MB_DEFBUTTON2| MB_TASKMODAL | MB_ICONEXCLAMATION) == IDNO) {
            bRet = FALSE;
        } else {
            bRet = TRUE;                // User approved conflict
        }
    }

    return bRet;

} // bConflictWarn



void
ClearEditResConflictList(
    HWND    hDlg,
    DWORD   dwFlags
    )
{
    HWND    hwndConflictList = GetDlgItem(hDlg, IDC_EDITRES_CONFLICTLIST);
    TCHAR   szBuffer[MAX_PATH];

    //
    // Clear the Conflict list to start.
    //
    SendMessage(hwndConflictList, LB_RESETCONTENT, 0, 0L);

    //
    // Load and set the info text string
    //
    if (dwFlags & CEF_UNKNOWN) {
        LoadString(MyDllModuleHandle, IDS_EDITRES_UNKNOWNCONFLICT, szBuffer, MAX_PATH);
    } else {
        LoadString(MyDllModuleHandle, IDS_EDITRES_NOCONFLICT, szBuffer, MAX_PATH);
    }
    SetDlgItemText(hDlg, IDC_EDITRES_CONFLICTTEXT, szBuffer);

    //
    // Load and set the List string
    //
    if (dwFlags & CEF_UNKNOWN) {
        LoadString(MyDllModuleHandle, IDS_EDITRES_UNKNOWNCONFLICTINGDEVS, szBuffer, MAX_PATH);
    } else {
        LoadString(MyDllModuleHandle, IDS_EDITRES_NOCONFLICTINGDEVS, szBuffer, MAX_PATH);
    }
    SendMessage(hwndConflictList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer);

} // ClearEditResConflictList





void
UpdateMFChildList(
    HWND                hDlg,
    PRESOURCEEDITINFO   lprei
    )
{
    UNREFERENCED_PARAMETER(hDlg);
    UNREFERENCED_PARAMETER(lprei);

    //
    // See if this is a MF parent device.  Check for a Child0000 subkey
    //
    // NOT IMPLEMENTED, SEE WINDOWS 95 SOURCES.
    //

} // UpdateMFChildList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devprop.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devprop.c

Abstract:

    Device Installer functions for property sheet support.

Author:

    Lonny McMichael (lonnym) 07-Sep-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Private routine prototypes.
//
BOOL
CALLBACK
pSetupAddPropPage(
    IN HPROPSHEETPAGE hPage,
    IN LPARAM         lParam
   );


//
// Define the context structure that gets passed to pSetupAddPropPage as lParam.
//
typedef struct _SP_PROPPAGE_ADDPROC_CONTEXT {

    BOOL            NoCancelOnFailure; // input
    HPROPSHEETPAGE *PageList;          // input(buffer)/output(contents therein)
    DWORD           PageListSize;      // input
    DWORD          *pNumPages;         // input/output

} SP_PROPPAGE_ADDPROC_CONTEXT, *PSP_PROPPAGE_ADDPROC_CONTEXT;


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetClassDevPropertySheetsA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,                  OPTIONAL
    IN  LPPROPSHEETHEADERA PropertySheetHeader,
    IN  DWORD              PropertySheetHeaderPageListSize,
    OUT PDWORD             RequiredSize,                    OPTIONAL
    IN  DWORD              PropertySheetType
    )
{
    PROPSHEETHEADERW UnicodePropertySheetHeader;
    DWORD Err;

    try {
        //
        // Make sure we're running interactively.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            Err = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
            leave;
        }

        //
        // None of the fields that we care about in this structure contain
        // characters.  Thus, we'll simply copy over the fields we need into
        // our unicode property sheet header, and pass that into the W-API.
        //
        // The fields that we care about are the following:
        //
        //    dwFlags:in
        //    nPages:in/out
        //    phpage:out (buffer pointer stays the same but contents are added)
        //
        ZeroMemory(&UnicodePropertySheetHeader, sizeof(UnicodePropertySheetHeader));

        UnicodePropertySheetHeader.dwFlags = PropertySheetHeader->dwFlags;
        UnicodePropertySheetHeader.nPages  = PropertySheetHeader->nPages;
        UnicodePropertySheetHeader.phpage  = PropertySheetHeader->phpage;

        Err = GLE_FN_CALL(FALSE,
                          SetupDiGetClassDevPropertySheetsW(
                              DeviceInfoSet,
                              DeviceInfoData,
                              &UnicodePropertySheetHeader,
                              PropertySheetHeaderPageListSize,
                              RequiredSize,
                              PropertySheetType)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        PropertySheetHeader->nPages = UnicodePropertySheetHeader.nPages;

        MYASSERT(PropertySheetHeader->phpage == UnicodePropertySheetHeader.phpage);

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiGetClassDevPropertySheets(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,                  OPTIONAL
    IN  LPPROPSHEETHEADER  PropertySheetHeader,
    IN  DWORD              PropertySheetHeaderPageListSize,
    OUT PDWORD             RequiredSize,                    OPTIONAL
    IN  DWORD              PropertySheetType
    )
/*++

Routine Description:

    This routine adds property sheets to the supplied property sheet
    header for the device information set or element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for
        which property sheets are to be retrieved.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for which property sheets are to be retrieved.  If this
        parameter is not specified, then property sheets are retrieved based
        on the global class driver list associated with the device information
        set itself.

    PropertySheetHeader - Supplies the property sheet header to which the
        property sheets are to be added.

        NOTE:  PropertySheetHeader->dwFlags _must not_ have the
        PSH_PROPSHEETPAGE flag set, or this API will fail with
        ERROR_INVALID_FLAGS.

    PropertySheetHeaderPageListSize - Specifies the size of the
        HPROPSHEETPAGE array pointed to by the PropertySheetHeader->phpage.
        Note that this is _not_ the same value as PropertySheetHeader->nPages.
        The latter specifies the number of page handles currently in the
        list.  The number of pages that may be added by this routine equals
        PropertySheetHeaderPageListSize - PropertySheetHeader->nPages.  If the
        property page provider attempts to add more pages than the property
        sheet header list can hold, this API will fail, and GetLastError will
        return ERROR_INSUFFICIENT_BUFFER.  However, any pages that have already
        been added will be in the PropertySheetHeader->phpage list, and the
        nPages field will contain the correct count.  It is the caller's
        responsibility to destroy all property page handles in this list via
        DestroyPropertySheetPage (unless the caller goes ahead and uses
        PropertySheetHeader in a call to PropertySheet).

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of property page handles added to the PropertySheetHeader.
        If this API fails with ERROR_INSUFFICIENT_BUFFER, this variable will be
        set to the total number of property pages that the property page
        provider(s) _attempted to add_ (i.e., including those which were not
        successfully added because the PropertySheetHeader->phpage array wasn't
        big enough).

        Note:  This number will not equal PropertySheetHeader->nPages upon
        return if either (a) there were already property pages in the list
        before this API was called, or (b) the call failed with
        ERROR_INSUFFICIENT_BUFFER.

    PropertySheetType - Specifies what type of property sheets are to be
        retrieved.  May be one of the following values:

        DIGCDP_FLAG_BASIC - Retrieve basic property sheets (typically, for CPL
                            applets).

        DIGCDP_FLAG_ADVANCED - Retrieve advanced property sheets (typically,
                               for the Device Manager).

        DIGCDP_FLAG_REMOTE_BASIC - Currently not used.

        DIGCDP_FLAG_REMOTE_ADVANCED - Retrieve advanced property sheets for a
                                      device on a remote machine (typically,
                                      for the Device Manager).

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err = NO_ERROR;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PDEVINSTALL_PARAM_BLOCK InstallParamBlock;
    LPGUID ClassGuid;
    HKEY hk = INVALID_HANDLE_VALUE;
    SP_PROPSHEETPAGE_REQUEST PropPageRequest;
    SP_PROPPAGE_ADDPROC_CONTEXT PropPageAddProcContext;
    PSP_ADDPROPERTYPAGE_DATA pPropertyPageData = NULL;
    SPFUSIONINSTANCE spFusionInstance;
    BOOL bUnlockDevInfoElem = FALSE;
    BOOL bUnlockDevInfoSet = FALSE;
    HPROPSHEETPAGE *LocalPageList = NULL;
    DWORD LocalPageListCount = 0;
    DWORD PageIndex, NumPages;
    PROPSHEET_PROVIDER_PROC ClassPagesEntryPoint;
    HANDLE ClassPagesFusionContext;
    PROPSHEET_PROVIDER_PROC DevicePagesEntryPoint;
    HANDLE DevicePagesFusionContext;
    DWORD OriginalPageCount;

    try {
        //
        // Make sure we're running interactively.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            Err = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
            leave;
        }

        //
        // Make sure the caller passed us a valid PropertySheetType.
        //
        if((PropertySheetType != DIGCDP_FLAG_BASIC) &&
           (PropertySheetType != DIGCDP_FLAG_ADVANCED) &&
           (PropertySheetType != DIGCDP_FLAG_REMOTE_ADVANCED)) {

            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        //
        // Make sure the property sheet header doesn't have the
        // PSH_PROPSHEETPAGE flag set.
        //
        if(PropertySheetHeader->dwFlags & PSH_PROPSHEETPAGE) {
            Err = ERROR_INVALID_FLAGS;
            leave;
        }

        //
        // Also, ensure that the parts of the property sheet header we'll be
        // dealing with look reasonable.
        //
        OriginalPageCount = PropertySheetHeader->nPages;

        if((OriginalPageCount > PropertySheetHeaderPageListSize) ||
           (PropertySheetHeaderPageListSize && !(PropertySheetHeader->phpage))) {

            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(DeviceInfoData) {
            //
            // Then we are to retrieve property sheets for a particular device.
            //
            if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                       DeviceInfoData,
                                                       NULL))
            {
                InstallParamBlock = &(DevInfoElem->InstallParamBlock);
                ClassGuid = &(DevInfoElem->ClassGuid);

            } else {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }

        } else {
            //
            // We're retrieving (advanced) property pages for the set's class.
            //
            if(pDeviceInfoSet->HasClassGuid) {
                InstallParamBlock = &(pDeviceInfoSet->InstallParamBlock);
                ClassGuid = &(pDeviceInfoSet->ClassGuid);
            } else {
                Err = ERROR_NO_ASSOCIATED_CLASS;
                leave;
            }
        }

        //
        // Fill in a property sheet request structure for later use.
        //
        PropPageRequest.cbSize         = sizeof(SP_PROPSHEETPAGE_REQUEST);
        PropPageRequest.DeviceInfoSet  = DeviceInfoSet;
        PropPageRequest.DeviceInfoData = DeviceInfoData;

        //
        // Fill in the context structure for later use by our AddPropPageProc
        // callback.  We want to allocate a local buffer of the same size as
        // the remaining space in the caller-supplied PropertySheetHeader.phpage
        // buffer.
        //
        PropPageAddProcContext.PageListSize = PropertySheetHeaderPageListSize -
                                                  PropertySheetHeader->nPages;

        if(PropPageAddProcContext.PageListSize) {

            LocalPageList =
                MyMalloc(sizeof(HPROPSHEETPAGE) * PropPageAddProcContext.PageListSize);

            if(!LocalPageList) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }
        }

        PropPageAddProcContext.PageList = LocalPageList;
        PropPageAddProcContext.pNumPages = &LocalPageListCount;

        //
        // If the caller supplied the RequiredSize output parameter, then we don't
        // want to abort the callback process, even if we run out of space in the
        // hPage list.
        //
        PropPageAddProcContext.NoCancelOnFailure = RequiredSize ? TRUE : FALSE;

        //
        // Allocate and initialize an AddPropertyPage class install params
        // structure for later use in retrieval of property pages from co-/
        // class installers.
        //
        pPropertyPageData = MyMalloc(sizeof(SP_ADDPROPERTYPAGE_DATA));
        if(!pPropertyPageData) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }
        ZeroMemory(pPropertyPageData, sizeof(SP_ADDPROPERTYPAGE_DATA));
        pPropertyPageData->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        pPropertyPageData->hwndWizardDlg = PropertySheetHeader->hwndParent;

        //
        // Check if we should be getting Basic or Advanced Property Sheets.
        // Essentially, CPL's will want BASIC sheets, and the Device Manager
        // will want advanced sheets.
        //
        switch (PropertySheetType) {

        case DIGCDP_FLAG_BASIC:
            //
            // The BasicProperties32 entrypoint is only supplied via a device's
            // driver key.  Thus, a device information element must be specified
            // when basic property pages are requested.
            //
            // NOTE: this is different from setupx, which enumerates _all_ lpdi's
            // in the list, retrieving basic properties for each.  This doesn't
            // seem to have any practical application, and if it is really
            // required, then the caller can loop through each devinfo element
            // themselves, and retrieve basic property pages for each one.
            //
            if(!DevInfoElem) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }

            //
            // If the basic property page provider has not been loaded, then load
            // it and get the function address for the BasicProperties32 function.
            //
            if(!InstallParamBlock->hinstBasicPropProvider) {

                hk = SetupDiOpenDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ
                                         );

                if(hk != INVALID_HANDLE_VALUE) {

                    try {
                        Err = GetModuleEntryPoint(hk,
                                                  pszBasicProperties32,
                                                  pszBasicPropDefaultProc,
                                                  &(InstallParamBlock->hinstBasicPropProvider),
                                                  &((FARPROC)InstallParamBlock->EnumBasicPropertiesEntryPoint),
                                                  &(InstallParamBlock->EnumBasicPropertiesFusionContext),
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  SetupapiVerifyNoProblem,
                                                  NULL,
                                                  DRIVERSIGN_NONE,
                                                  TRUE,
                                                  NULL
                                                 );

                        if(Err == ERROR_DI_DO_DEFAULT) {
                            //
                            // The BasicProperties32 value wasn't present--this is not an error.
                            //
                            Err = NO_ERROR;

                        } else if(Err != NO_ERROR) {
                            Err = ERROR_INVALID_PROPPAGE_PROVIDER;
                        }

                    } except(pSetupExceptionFilter(GetExceptionCode())) {
                        pSetupExceptionHandler(GetExceptionCode(),
                                               ERROR_INVALID_PROPPAGE_PROVIDER,
                                               &Err
                                              );
                        InstallParamBlock->EnumBasicPropertiesEntryPoint = NULL;
                        InstallParamBlock->EnumBasicPropertiesFusionContext = NULL;
                    }

                    RegCloseKey(hk);
                    hk = INVALID_HANDLE_VALUE;

                    if(Err != NO_ERROR) {
                        leave;
                    }
                }
            }

            //
            // If there is a basic property page provider entry point, then
            // call it.
            //
            if(InstallParamBlock->EnumBasicPropertiesEntryPoint) {

                PropPageRequest.PageRequested = SPPSR_ENUM_BASIC_DEVICE_PROPERTIES;

                //
                // Capture the fusion context and function entry point into
                // local variables, because we're going to be unlocking the
                // devinfo set.  Thus, it's possible the InstallParamBlock
                // could get modified (e.g., if the device's ClasssGUID were
                // changed during the call).  We at least know, however, that
                // the entry point and fusion context won't be destroyed until
                // the InstallParamBlock is destroyed, which we're preventing
                // by setting the DIE_IS_LOCKED flag below.
                //
                DevicePagesFusionContext =
                    InstallParamBlock->EnumBasicPropertiesFusionContext;

                DevicePagesEntryPoint =
                    InstallParamBlock->EnumBasicPropertiesEntryPoint;

                //
                // Release the HDEVINFO lock, so we don't run into any weird
                // deadlock issues.  We want to lock the devinfo element so
                // the helper module can't go deleting it out from under us!
                //
                if(!(DevInfoElem->DiElemFlags & DIE_IS_LOCKED)) {
                    DevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
                    bUnlockDevInfoElem = TRUE;
                }
                UnlockDeviceInfoSet(pDeviceInfoSet);
                pDeviceInfoSet = NULL;

                spFusionEnterContext(DevicePagesFusionContext, &spFusionInstance);
                try {
                    DevicePagesEntryPoint(&PropPageRequest,
                                          pSetupAddPropPage,
                                          (LPARAM)&PropPageAddProcContext
                                         );
                } finally {
                    spFusionLeaveContext(&spFusionInstance);
                }
            }

            //
            // Finish initializing our class install params structure to
            // indicate we are asking for basic property pages from the class-/
            // co-installers.
            //
            pPropertyPageData->ClassInstallHeader.InstallFunction = DIF_ADDPROPERTYPAGE_BASIC;

            break;

        case DIGCDP_FLAG_ADVANCED:
            //
            // We're retrieving advanced property pages.  We want to look for EnumPropPages32
            // entries in both the class key and (if we're talking about a specific device) in
            // the device's driver key.
            //
            if(!InstallParamBlock->hinstClassPropProvider) {

                hk = SetupDiOpenClassRegKey(ClassGuid, KEY_READ);

                if(hk != INVALID_HANDLE_VALUE) {

                    try {
                        Err = GetModuleEntryPoint(hk,
                                                  pszEnumPropPages32,
                                                  pszEnumPropDefaultProc,
                                                  &(InstallParamBlock->hinstClassPropProvider),
                                                  &((FARPROC)InstallParamBlock->ClassEnumPropPagesEntryPoint),
                                                  &(InstallParamBlock->ClassEnumPropPagesFusionContext),
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  SetupapiVerifyNoProblem,
                                                  NULL,
                                                  DRIVERSIGN_NONE,
                                                  TRUE,
                                                  NULL
                                                 );

                        if(Err == ERROR_DI_DO_DEFAULT) {
                            //
                            // The EnumPropPages32 value wasn't present--this is not an error.
                            //
                            Err = NO_ERROR;

                        } else if(Err != NO_ERROR) {
                            Err = ERROR_INVALID_PROPPAGE_PROVIDER;
                        }

                    } except(pSetupExceptionFilter(GetExceptionCode())) {
                        pSetupExceptionHandler(GetExceptionCode(),
                                               ERROR_INVALID_PROPPAGE_PROVIDER,
                                               &Err
                                              );
                        InstallParamBlock->ClassEnumPropPagesEntryPoint = NULL;
                        InstallParamBlock->ClassEnumPropPagesFusionContext = NULL;
                    }

                    RegCloseKey(hk);
                    hk = INVALID_HANDLE_VALUE;

                    if(Err != NO_ERROR) {
                        leave;
                    }
                }
            }

            if(DevInfoElem && !InstallParamBlock->hinstDevicePropProvider) {

                hk = SetupDiOpenDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ
                                         );

                if(hk != INVALID_HANDLE_VALUE) {

                    try {
                        Err = GetModuleEntryPoint(hk,
                                                  pszEnumPropPages32,
                                                  pszEnumPropDefaultProc,
                                                  &(InstallParamBlock->hinstDevicePropProvider),
                                                  &((FARPROC)InstallParamBlock->DeviceEnumPropPagesEntryPoint),
                                                  &(InstallParamBlock->DeviceEnumPropPagesFusionContext),
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  SetupapiVerifyNoProblem,
                                                  NULL,
                                                  DRIVERSIGN_NONE,
                                                  TRUE,
                                                  NULL
                                                 );

                        if(Err == ERROR_DI_DO_DEFAULT) {
                            //
                            // The EnumPropPages32 value wasn't present--this is not an error.
                            //
                            Err = NO_ERROR;

                        } else if(Err != NO_ERROR) {
                            Err = ERROR_INVALID_PROPPAGE_PROVIDER;
                        }

                    } except(pSetupExceptionFilter(GetExceptionCode())) {
                        pSetupExceptionHandler(GetExceptionCode(),
                                               ERROR_INVALID_PROPPAGE_PROVIDER,
                                               &Err
                                              );
                        InstallParamBlock->DeviceEnumPropPagesEntryPoint = NULL;
                        InstallParamBlock->DeviceEnumPropPagesFusionContext = NULL;
                    }

                    RegCloseKey(hk);
                    hk = INVALID_HANDLE_VALUE;

                    if(Err != NO_ERROR) {
                        leave;
                    }
                }
            }

            //
            // Clear the DI_GENERALPAGE_ADDED, DI_DRIVERPAGE_ADDED, and
            // DI_RESOURCEPAGE_ADDED flags.
            //
            InstallParamBlock->Flags &= ~(DI_GENERALPAGE_ADDED | DI_RESOURCEPAGE_ADDED | DI_DRIVERPAGE_ADDED);

            PropPageRequest.PageRequested = SPPSR_ENUM_ADV_DEVICE_PROPERTIES;

            //
            // Capture the fusion contexts and function entry points into local
            // variables, because we're going to be unlocking the devinfo set.
            // Thus, it's possible the InstallParamBlock could get modified.
            //
            ClassPagesFusionContext =
                InstallParamBlock->ClassEnumPropPagesFusionContext;

            ClassPagesEntryPoint =
                InstallParamBlock->ClassEnumPropPagesEntryPoint;

            DevicePagesFusionContext =
                InstallParamBlock->DeviceEnumPropPagesFusionContext;

            DevicePagesEntryPoint =
                InstallParamBlock->DeviceEnumPropPagesEntryPoint;

            //
            // Release the HDEVINFO lock, so we don't run into any weird
            // deadlock issues.  We want to lock the devinfo set/element so
            // we don't have to worry about the set being deleted out from 
            // under us.
            //
            if(DevInfoElem) {
                //
                // If we have a devinfo element, then we'd prefer to lock at
                // that level.
                //
                if(!(DevInfoElem->DiElemFlags & DIE_IS_LOCKED)) {
                    DevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
                    bUnlockDevInfoElem = TRUE;
                }

            } else {
                //
                // We don't have a device information element to lock, so we'll
                // lock the set itself...
                //
                if(!(pDeviceInfoSet->DiSetFlags & DISET_IS_LOCKED)) {
                    pDeviceInfoSet->DiSetFlags |= DISET_IS_LOCKED;
                    bUnlockDevInfoSet = TRUE;
                }
            }

            UnlockDeviceInfoSet(pDeviceInfoSet);
            pDeviceInfoSet = NULL;

            //
            // If there is an advanced property page provider for this class,
            // then call it.
            //
            if(ClassPagesEntryPoint) {
                spFusionEnterContext(ClassPagesFusionContext, &spFusionInstance);
                try {
                    ClassPagesEntryPoint(&PropPageRequest,
                                         pSetupAddPropPage,
                                         (LPARAM)&PropPageAddProcContext
                                        );
                } finally {
                    spFusionLeaveContext(&spFusionInstance);
                }
            }

            //
            // If there is an advanced property page provider for this
            // particular device, then call it.
            //
            if(DevicePagesEntryPoint) {
                spFusionEnterContext(DevicePagesFusionContext, &spFusionInstance);
                try {
                    DevicePagesEntryPoint(&PropPageRequest,
                                          pSetupAddPropPage,
                                          (LPARAM)&PropPageAddProcContext
                                         );
                } finally {
                    spFusionLeaveContext(&spFusionInstance);
                }
            }

            //
            // Finish initializing our class install params structure to
            // indicate we are asking for advanced property pages from the
            // class-/co-installers.
            //
            pPropertyPageData->ClassInstallHeader.InstallFunction = DIF_ADDPROPERTYPAGE_ADVANCED;

            break;

        case DIGCDP_FLAG_REMOTE_ADVANCED:
            //
            // Finish initializing our class install params structure to
            // indicate we are asking for remote advanced property pages from
            // the class-/co-installers.
            //
            pPropertyPageData->ClassInstallHeader.InstallFunction = DIF_ADDREMOTEPROPERTYPAGE_ADVANCED;

            break;
        }

        //
        // If we get here, then we should not have encountered any errors thus
        // far, and our class install parameter structure should be prepared
        // for requesting the appropriate pages from the class-/co-installers.
        //
        MYASSERT(NO_ERROR == Err);

        Err = DoInstallActionWithParams(
                  pPropertyPageData->ClassInstallHeader.InstallFunction,
                  DeviceInfoSet,
                  DeviceInfoData,
                  (PSP_CLASSINSTALL_HEADER)pPropertyPageData,
                  sizeof(SP_ADDPROPERTYPAGE_DATA),
                  INSTALLACTION_CALL_CI
                  );

        if(ERROR_DI_DO_DEFAULT == Err) {
            //
            // This is not an error condition.
            //
            Err = NO_ERROR;
        }

        if(NO_ERROR == Err) {
            //
            // Add these pages to the list we're building to be handed back
            // to the caller.
            //
            for(PageIndex = 0;
                PageIndex < pPropertyPageData->NumDynamicPages;
                PageIndex++)
            {
                if(pSetupAddPropPage(pPropertyPageData->DynamicPages[PageIndex],
                                     (LPARAM)&PropPageAddProcContext)) {
                    //
                    // Clear this handle out of the class install params list,
                    // because it's been either (a) transferred to the
                    // LocalPageList or (b) destroyed (i.e., because there
                    // wasn't room for it).  We do this to prevent possible
                    // double-free, e.g., if we hit an exception.
                    //
                    pPropertyPageData->DynamicPages[PageIndex] = NULL;

                } else {
                    //
                    // We ran out of room in our list, and were able to abort
                    // early because the caller didn't request the RequiredSize
                    // output.
                    //
                    break;
                }
            }

        } else {
            //
            // We encountered an error during our attempt to retrieve the
            // pages from the class-/co-installers.  We may have gotten
            // some pages here, but we won't add these to our list.  We
            // won't consider this a blocking error, because the class-/
            // co-installers shouldn't be allowed to prevent retrieval of
            // property pages from the legacy property page provider(s).
            //
            Err = NO_ERROR;
        }

        if(RequiredSize) {
            *RequiredSize = LocalPageListCount;
        }

        if(LocalPageListCount > PropPageAddProcContext.PageListSize) {
            Err = ERROR_INSUFFICIENT_BUFFER;
        }

        //
        // Copy our local buffer containing property sheet page handles over
        // into the phpage buffer in the caller-supplied property sheet header.
        //
        if(LocalPageList) {
            //
            // Make sure we skip over any pages that were already in the phpage
            // list...
            //
            NumPages = min(LocalPageListCount, PropPageAddProcContext.PageListSize);

            CopyMemory(&(PropertySheetHeader->phpage[PropertySheetHeader->nPages]),
                       LocalPageList,
                       NumPages * sizeof(HPROPSHEETPAGE)
                      );

            PropertySheetHeader->nPages += NumPages;

            //
            // Free our local buffer so we won't try to destroy these handles
            // during clean-up.
            //
            MyFree(LocalPageList);
            LocalPageList = NULL;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(bUnlockDevInfoElem || bUnlockDevInfoSet) {
        try {
            if(!pDeviceInfoSet) {
                pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet);
                MYASSERT(pDeviceInfoSet);
            }
            if(pDeviceInfoSet) {
                if(bUnlockDevInfoElem) {
                    MYASSERT(DevInfoElem);
                    MYASSERT(DevInfoElem->DiElemFlags & DIE_IS_LOCKED);
                    DevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
                } else {
                    MYASSERT(pDeviceInfoSet->DiSetFlags & DISET_IS_LOCKED);
                    pDeviceInfoSet->DiSetFlags &= ~DISET_IS_LOCKED;
                }
            }
        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        }
    }

    //
    // Clean up any property sheet page handles that aren't getting
    // returned back to the caller (for whatever reason).  Note that we protect
    // ourselves from exceptions in case the property page provider(s) gave us
    // bogus handles.
    //
    if(LocalPageList) {

        MYASSERT((Err != NO_ERROR) && (Err != ERROR_INSUFFICIENT_BUFFER));

        NumPages = min(LocalPageListCount, PropPageAddProcContext.PageListSize);

        for(PageIndex = 0; PageIndex < NumPages; PageIndex++) {
            if(LocalPageList[PageIndex]) {
                try {
                    DestroyPropertySheetPage(LocalPageList[PageIndex]);
                } except(pSetupExceptionFilter(GetExceptionCode())) {
                    pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
                }
            }
        }

        MyFree(LocalPageList);
    }

    if(pPropertyPageData) {

        for(PageIndex = 0;
            PageIndex < pPropertyPageData->NumDynamicPages;
            PageIndex++)
        {
            if(pPropertyPageData->DynamicPages[PageIndex]) {
                try {
                    DestroyPropertySheetPage(pPropertyPageData->DynamicPages[PageIndex]);
                } except(pSetupExceptionFilter(GetExceptionCode())) {
                    pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
                }
            }
        }

        MyFree(pPropertyPageData);
    }

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
CALLBACK
pSetupAddPropPage(
    IN HPROPSHEETPAGE hPage,
    IN LPARAM         lParam
   )
/*++

Routine Description:

    This is the callback routine that is passed to property page providers.
    This routine is called for each property page that the provider wishes to
    add.

Arguments:

    hPage - Supplies a handle to the property page being added.

    lParam - Supplies a pointer to a context structure used when adding the new
        property page handle.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.

--*/
{
    PSP_PROPPAGE_ADDPROC_CONTEXT Context = (PSP_PROPPAGE_ADDPROC_CONTEXT)lParam;
    DWORD PageIndex;

    //
    // Get the current page index and increment our page count.  We want to do
    // this regardless of whether we have room in our list to store the hPage.
    //
    PageIndex = (*(Context->pNumPages))++;

    if(PageIndex < Context->PageListSize) {
        Context->PageList[PageIndex] = hPage;
        return TRUE;
    }

    //
    // We can't use this property page because it won't fit in our page list.
    // If we return FALSE, the caller should clean up the property page by
    // calling DestroyPropertySheetPage().  However, if we return TRUE (i.e.,
    // because we want to keep going to get a count of how many pages there are
    // in total), then the caller won't know that we're "throwing the pages
    // away", and they won't be cleaning these up.  Thus, in that case we are
    // responsible for destroying the unused property pages.
    //
    if(Context->NoCancelOnFailure && hPage) {
        //
        // Protect ourselves in case the property page provider handed us a
        // bogus property sheet page handle...
        //
        try {
            DestroyPropertySheetPage(hPage);
        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        }
    }

    return Context->NoCancelOnFailure;
}


BOOL
CALLBACK
ExtensionPropSheetPageProc(
    IN LPVOID lpv,
    IN LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    IN LPARAM lParam
    )
{
    PSP_PROPSHEETPAGE_REQUEST PropPageRequest = (PSP_PROPSHEETPAGE_REQUEST)lpv;
    HPROPSHEETPAGE hPropSheetPage = NULL;
    BOOL b = FALSE;

    try {
        //
        // Make sure we're running interactively.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            leave;
        }

        if(PropPageRequest->cbSize != sizeof(SP_PROPSHEETPAGE_REQUEST)) {
            leave;
        }

        switch(PropPageRequest->PageRequested) {

            case SPPSR_SELECT_DEVICE_RESOURCES :

                if(!(hPropSheetPage = GetResourceSelectionPage(PropPageRequest->DeviceInfoSet,
                                                               PropPageRequest->DeviceInfoData))) {
                    leave;
                }
                break;

            default :
                //
                // Don't know what to do with this request.
                //
                leave;
        }

        if(lpfnAddPropSheetPageProc(hPropSheetPage, lParam)) {
            //
            // Page successfully handed off to requestor.  Reset our handle so that we don't
            // try to free it.
            //
            hPropSheetPage = NULL;
            b = TRUE;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    if(hPropSheetPage) {
        //
        // Property page was successfully created, but never handed off to requestor.  Free
        // it now.
        //
        DestroyPropertySheetPage(hPropSheetPage);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devres.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    devres.c

Abstract:

    Routines for displaying resource dialogs.

Author:

    Paula Tomlinson (paulat) 7-Feb-1996

Revision History:

    Jamie Hunter (jamiehun) 19-Mar-1998

--*/

#include "precomp.h"
#pragma hdrstop

//
// Private Prototypes
//


//
// Global Data
//

static INTERFACE_TYPE ResourcePickerReadOnlyInterfaces[] = {
    //
    // List of interface-types that we don't want user to edit properties of
    //

    PCIBus,

    //
    // End of list
    //
    InterfaceTypeUndefined
};

static const BOOL ResTypeEditable[ResType_MAX+1] = {
    //
    // lists resource types that are shown and are editable
    FALSE,  // ResType_None
    TRUE,   // ResType_Mem
    TRUE,   // ResType_IO
    TRUE,   // ResType_DMA
    TRUE,   // ResType_IRQ
    FALSE,  // ResType_DoNotUse
    FALSE   // ResType_BusNumber
};

#if (ResType_MAX+1) != 7
#error Fix SetupAPI devres.c, ResType_MAX has changed
#endif

//
// HELP ID's
//
static const DWORD DevResHelpIDs[]=
{
    IDC_DEVRES_ICON,            IDH_NOHELP,     // "Low (%d)" (Static)
    IDC_DEVRES_DEVDESC,         IDH_NOHELP,
    IDC_DEVRES_SETTINGSTATE,    IDH_DEVMGR_RESOURCES_SETTINGS,
    IDC_DEVRES_SETTINGSLIST,    IDH_DEVMGR_RESOURCES_SETTINGS,
    IDC_DEVRES_LCTEXT,          IDH_DEVMGR_RESOURCES_BASEDON,
    IDC_DEVRES_LOGCONFIGLIST,   IDH_DEVMGR_RESOURCES_BASEDON,
    IDC_DEVRES_CHANGE,          IDH_DEVMGR_RESOURCES_CHANGE,
    IDC_DEVRES_USESYSSETTINGS,  IDH_DEVMGR_RESOURCES_AUTO,
    IDC_DEVRES_CONFLICTDEVTEXT, IDH_DEVMGR_RESOURCES_CONFLICTS,
    IDC_DEVRES_CONFLICTINFOLIST,    IDH_DEVMGR_RESOURCES_CONFLICTS,
    IDC_DEVRES_MFPARENT,        IDH_DEVMGR_RESOURCES_PARENT,
    IDC_DEVRES_MFPARENT_DESC,   IDH_DEVMGR_RESOURCES_PARENT,
    IDC_DEVRES_MAKEFORCED,      IDH_DEVMGR_RESOURCES_SETMANUALLY,
    0, 0
};

//
// HACKHACK (jamiehun)
// after we've changed UI from a MakeForced, we post this message to get back control of keyboard
//

#define WM_USER_FOCUS           (WM_USER+101)


//
// API to obtain a resource-picker page
//

HPROPSHEETPAGE
GetResourceSelectionPage(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    LPDMPROP_DATA     pdmData;
    PROPSHEETPAGE     PropPage;

    //
    // private data
    // anything we "do" here must be "undone" in pResourcePickerPropPageCallback
    //
    pdmData = (LPDMPROP_DATA)MyMalloc(sizeof(DMPROP_DATA));
    if (pdmData == NULL) {
        return NULL;
    }
    ZeroMemory(pdmData,sizeof(DMPROP_DATA));

    pdmData->hDevInfo      = DeviceInfoSet;
    pdmData->lpdi          = DeviceInfoData;

    //
    // validate expectations
    //
    MYASSERT(pdmData->hDevInfo != NULL);
    MYASSERT(pdmData->lpdi != NULL);
    MYASSERT(pdmData->lpdi->DevInst != 0);

    ZeroMemory(&PropPage,sizeof(PropPage));

    //
    // create the Resources Property Page
    //
    PropPage.dwSize        = sizeof(PROPSHEETPAGE);
    PropPage.dwFlags       = PSP_DEFAULT | PSP_USECALLBACK;
    PropPage.hInstance     = MyDllModuleHandle;
    PropPage.pszTemplate   = MAKEINTRESOURCE(IDD_DEF_DEVRESOURCE_PROP);
    PropPage.pszIcon       = NULL;
    PropPage.pszTitle      = NULL;
    PropPage.pfnDlgProc    = pResourcePickerDlgProc;
    PropPage.lParam        = (LPARAM)pdmData;
    PropPage.pfnCallback   = pResourcePickerPropPageCallback;
#ifdef _UNICODE
    PropPage.dwFlags      |= PSP_USEFUSIONCONTEXT;
    PropPage.hActCtx       = NULL;
#endif

    return CreatePropertySheetPage(&PropPage);

} // GetResourceSelectionPage


//
// CreatePropertySheetPage - callback function
//
UINT CALLBACK pResourcePickerPropPageCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
)
/*++

Routine Description:

    Callback to handle cleanup of the property sheet

Arguments:

   Standard PropSheetPageProc arguments.

Return Value:

   Standard PropSheetPageProc return.

--*/
{
    switch (uMsg) {
        //case PSPCB_ADDREF:
        //    break;

        case PSPCB_CREATE:
            break;

        case PSPCB_RELEASE:
            //
            // release the memory we've previously allocated, outside of the actual dialog
            //
            if (ppsp->lParam != 0) {
                LPDMPROP_DATA pdmData = (LPDMPROP_DATA)(ppsp->lParam);

                MyFree(pdmData);
            }
            break;
    }

    return TRUE;

}

//
// Main dialog proceedure
//


INT_PTR
CALLBACK
pResourcePickerDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

    This routine provides the dialog box procedure for the main resource
    picker property page. MEMPHIS COMPATIBLE.

Arguments:

   Standard dialog box procedure arguments.

Return Value:

   Standard dialog box procedure return.

--*/

{
    LPDMPROP_DATA   lpdmpd = NULL;

    if (message == WM_INITDIALOG) {
        lpdmpd = (LPDMPROP_DATA)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)lpdmpd);
    } else {
        lpdmpd = (LPDMPROP_DATA)GetWindowLongPtr(hDlg, DWLP_USER);
    }

    switch (message) {

        //
        // initialize
        //
        case WM_INITDIALOG: {

            HICON           hIcon = NULL;
            int             iIcon = 0, iIndex = 0;
            ULONG           ulSize;
            PDEVICE_INFO_SET pDeviceInfoSet;
            HMACHINE        hMachine;

            lpdmpd->himlResourceImages = NULL;
            lpdmpd->CurrentLC = 0;
            lpdmpd->CurrentLCType = 0;
            lpdmpd->MatchingLC = 0;
            lpdmpd->MatchingLCType = 0;
            lpdmpd->SelectedLC = 0;
            lpdmpd->SelectedLCType = 0;
            lpdmpd->hDlg = hDlg;
            lpdmpd->dwFlags = 0;

            hMachine = pGetMachine(lpdmpd);

            lpdmpd->dwFlags |= DMPROP_FLAG_CHANGESSAVED; // Nothing to save yet

            //
            // NOTE: On Windows95, since lc info is in memory, they first
            // call CM_Setup_DevNode with CM_SETUP_WRITE_LOG_CONFS flag so
            // that in-memory lc data is flushed to the registry at this
            // point.
            //

            //
            // Init the Resource's image list.
            //
            lpdmpd->himlResourceImages = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                                  GetSystemMetrics(SM_CYSMICON),
                                                  ILC_MASK, // | ILC_SHARED,
                                                  1,
                                                  1);
            //
            // add icons to image list
            //
            for (iIcon = IDI_RESOURCEFIRST;iIcon < IDI_RESOURCELAST;++iIcon) {
                //
                // resource icon
                //
                hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(iIcon));
                iIndex = ImageList_AddIcon(lpdmpd->himlResourceImages, hIcon);
            }

            for (iIcon = IDI_RESOURCEOVERLAYFIRST;iIcon <= IDI_RESOURCEOVERLAYLAST;++iIcon) {
                //
                // overlay icon
                //
                hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(iIcon));
                iIndex = ImageList_AddIcon(lpdmpd->himlResourceImages, hIcon);

                //
                // Tag this icon as an overlay icon (the first index is an
                // index into the image list (specifies the icon), the
                // second index is just an index to assign to each mask
                // (starting with 1).
                //
                ImageList_SetOverlayImage(lpdmpd->himlResourceImages,
                                          iIndex,
                                          iIcon-IDI_RESOURCEOVERLAYFIRST+1);
            }

            if(pInitDevResourceDlg(lpdmpd)) {
                lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED; // need to save (prob because there was no config)
            }

            if (!(lpdmpd->dwFlags & DMPROP_FLAG_NO_RESOURCES)) {
                pShowConflicts(lpdmpd);
            }
            if (GuiSetupInProgress) {
                //
                // occasionally legacy devices cause resource-picker popup during setup
                // we do this here instead of create prop sheet, since I don't trust
                // people to cleanup on fail. At least here is less risky
                // clean this up in WM_DESTROY
                //
                lpdmpd->hDialogEvent = CreateEvent(NULL,TRUE,FALSE,SETUP_HAS_OPEN_DIALOG_EVENT);
                if (lpdmpd->hDialogEvent) {
                   SetEvent(lpdmpd->hDialogEvent);
                }
            } else {
                lpdmpd->hDialogEvent = NULL;
            }
            break;
        }


        //
        // cleanup
        //
        case WM_DESTROY: {

            HICON    hIcon;
            LOG_CONF LogConf;
            LONG     nItems, n;
            HWND     hList =  GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
            int    Count, i;

            //
            // Clean up the ICON resource usage
            //
            if ((hIcon = (HICON)LOWORD(SendDlgItemMessage(hDlg,
                         IDC_DEVRES_ICON, STM_GETICON, 0, 0L)))) {
                DestroyIcon(hIcon);
            }

            //
            // free the LC handles that were saved in the combobox data
            //
            nItems = (LONG)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                            CB_GETCOUNT, 0, 0L);

            for (n = 0; n < nItems ; n++) {
                LogConf = (LOG_CONF)SendDlgItemMessage(hDlg,
                                        IDC_DEVRES_LOGCONFIGLIST,
                                        CB_GETITEMDATA, n, 0L);
                CM_Free_Log_Conf_Handle(LogConf);
            }

            if (lpdmpd->CurrentLC != 0) {
                CM_Free_Log_Conf_Handle(lpdmpd->CurrentLC);
            }

            ListView_DeleteAllItems(hList); // this will destroy all data

            if (lpdmpd->himlResourceImages) {
                ImageList_Destroy(lpdmpd->himlResourceImages);
            }

            if (lpdmpd->hDialogEvent) {
                //
                // we were holding up setup, now let setup proceed
                //
                ResetEvent(lpdmpd->hDialogEvent);
                CloseHandle(lpdmpd->hDialogEvent);
                lpdmpd->hDialogEvent = NULL;
            }
            // MyFree(lpdmpd); - do this in pResourcePickerPropPageCallback instead
            break;
        }

        case WM_COMMAND:
            //
            // old-style controls
            //

            switch(LOWORD(wParam)) {
                case IDC_DEVRES_USESYSSETTINGS: {
                    //
                    // consider resource settings to have changed
                    //
                    lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED;
                    PropSheet_Changed(GetParent(hDlg), hDlg);

                    if (IsDlgButtonChecked(hDlg, (int)wParam)) {
                        //
                        // Revert back to allocated display, if any
                        //
                        lpdmpd->dwFlags |= DMPROP_FLAG_USESYSSETTINGS;
                        pSelectLogConf(lpdmpd,(LOG_CONF)0,ALLOC_LOG_CONF,TRUE);
                    } else {
                        //
                        // Allow editing
                        //
                        lpdmpd->dwFlags &= ~DMPROP_FLAG_USESYSSETTINGS;
                    }
                    pShowUpdateEdit(lpdmpd);           // update controls

                    break;
                }

                case IDC_DEVRES_LOGCONFIGLIST: {
                    //
                    // drop-down list action
                    //
                    switch (HIWORD(wParam)) {
                        case CBN_SELENDOK: {
                            ULONG    ulIndex = 0;
                            int      iItem;
                            LOG_CONF SelLC;
                            HWND     hwndLC = GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST);

                            //
                            // If there is not a Log Config selected, then bail
                            //
                            iItem = (int)SendMessage(hwndLC, CB_GETCURSEL, 0, 0);
                            if(iItem != CB_ERR) {
                                SelLC = (LOG_CONF)SendMessage(hwndLC,CB_GETITEMDATA, (WPARAM)iItem,(LPARAM)0);
                            } else {
                                SelLC = (LOG_CONF)0;
                            }
                            if(SelLC != lpdmpd->SelectedLC) {
                                pSelectLogConf(lpdmpd,SelLC,lpdmpd->ConfigListLCType,FALSE);
                            }
                            //
                            // I prob don't need this here, but I'm playing safe!
                            //
                            lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED;
                            break;
                        }
                    }
                    break;
                }

                case IDC_DEVRES_CHANGE: {
                    //
                    // change selected setting
                    //
                    pChangeCurrentResSetting(lpdmpd);
                    break;
                }

                case IDC_DEVRES_MAKEFORCED: {
                    //
                    // possibly allow editing (after we've shown message)
                    // when we get here, always show a configuration
                    //

                    if(lpdmpd->dwFlags & DMPROP_FLAG_FORCEDONLY) {
                        lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED; // need to save
                    }
                    pShowViewAllEdit(lpdmpd);
                    //
                    // select in the first available config to edit
                    //
                    pSelectLogConf(lpdmpd,(LOG_CONF)0,ALLOC_LOG_CONF,TRUE);

                    //
                    // ensure we have reasonable focus for accessability
                    //
                    PostMessage(hDlg,WM_USER_FOCUS,IDC_DEVRES_SETTINGSLIST,0);
                    break;
                }

                default:
                    break;
            }
            break;

        case WM_USER_FOCUS:
            //
            // change focus to DlgItem wParam
            //
            SetFocus(GetDlgItem(hDlg,(int)wParam));
            return TRUE;

        case WM_NOTIFY: {
            //
            // new controls & property codes
            //
            NMHDR * pHdr = (NMHDR*)lParam;

            switch (pHdr->code) {

                case PSN_SETACTIVE: {

                    HICON           hIcon = NULL, hOldIcon = NULL;
                    TCHAR           szString[MAX_PATH];
                    ULONG           ulSize = 0;
                    HMACHINE        hMachine;

                    hMachine = pGetMachine(lpdmpd);


                    //
                    // Set the ICON and device description
                    //
                    if (SetupDiLoadClassIcon(&lpdmpd->lpdi->ClassGuid, &hIcon, NULL)) {

                        if ((hOldIcon = (HICON)LOWORD(SendDlgItemMessage(hDlg, IDC_DEVRES_ICON,
                                                                         STM_SETICON,
                                                                         (WPARAM)hIcon, 0L)))) {
                            DestroyIcon(hOldIcon);
                        }
                    }

                    //
                    // First try to get the device's friendly name, then fall back to its description,
                    // and finally, use the "Unknown Device" description.
                    //
                    ulSize = MAX_PATH * sizeof(TCHAR);
                    if (CM_Get_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                                         CM_DRP_FRIENDLYNAME,
                                                         NULL, (LPBYTE)szString,
                                                         &ulSize, 0,hMachine) != CR_SUCCESS) {

                        ulSize = MAX_PATH * sizeof(TCHAR);
                        if (CM_Get_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                                             CM_DRP_DEVICEDESC,
                                                             NULL, (LPBYTE)szString,
                                                             &ulSize, 0,hMachine) != CR_SUCCESS) {

                            LoadString(MyDllModuleHandle, IDS_DEVNAME_UNK, szString, MAX_PATH);
                        }
                    }
                    SetDlgItemText(hDlg, IDC_DEVRES_DEVDESC, szString);
                    break;
                }

                case PSN_APPLY:  {
                    BOOL      bRet = FALSE;
                    //
                    // If there were Changes and they haven't been saved,
                    // then save them.
                    // consider some special cases as "haven't been saved"
                    //
                    if((lpdmpd->CurrentLC == 0) && (lpdmpd->dwFlags&DMPROP_FLAG_FIXEDCONFIG)) {
                        lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED;
                    }

                    switch(pOkToSave(lpdmpd)) {
                        case IDNO:
                            //
                            // proceed without saving
                            //
                            bRet = TRUE;
                            break;
                        case IDCANCEL:
                            //
                            // don't proceed
                            //
                            bRet = FALSE;
                            break;
                        case IDYES:
                            //
                            // proceed and save
                            //
                            bRet = pSaveDevResSettings(lpdmpd);
                            #if 0
                            if (bRet) {
                                if ((lpdmpd->lpdi)->Flags &  DI_NEEDREBOOT) {
                                    PropSheet_RebootSystem(GetParent(hDlg));
                                } else if ((lpdmpd->lpdi)->Flags &  DI_NEEDRESTART) {
                                    PropSheet_RestartWindows(GetParent(hDlg));
                                }
                            #endif
                            if (bRet) {
                                //
                                // This page doesn't support roll-back, if we saved
                                // something then we're committed, disable the cancel
                                // botton.
                                //
                                PropSheet_CancelToClose(GetParent(hDlg));
                            }
                            break;
                        default:
                            MYASSERT(FALSE /* pOkToSave returned invalid value */);
                            bRet = FALSE;
                            break;
                    }

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, bRet ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);
                    return TRUE;
                }

                case LVN_DELETEALLITEMS:
                    if (pHdr->idFrom == IDC_DEVRES_SETTINGSLIST) {
                        return FALSE;   // we want LVN_DELETEITEM messages
                    }
                    break;

                case LVN_DELETEITEM: {
                    LPNMLISTVIEW pListView = (LPNMLISTVIEW)pHdr;
                    if (pHdr->idFrom == IDC_DEVRES_SETTINGSLIST) {
                        PITEMDATA   pItemData = (PITEMDATA)(LPVOID)(pListView->lParam);
                        //
                        // when an item is deleted, destroy associated data
                        //
                        if (pItemData->MatchingResDes) {
                            CM_Free_Res_Des_Handle(pItemData->MatchingResDes);
                        }
                        MyFree(pItemData);
                    }
                    break;
                }
                    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), FALSE);
                    break;

                case LVN_ITEMCHANGED:
                    //
                    // If the item change is comming from the resource
                    // list, and there is a logconfig to be edited:
                    //
                    if (pHdr->idFrom == IDC_DEVRES_SETTINGSLIST) {
                        //
                        // see if we should enable resource change
                        //
                        pCheckEnableResourceChange(lpdmpd);
                    }
                    break;

                case NM_DBLCLK:
                    //
                    // If the double click is from the SETTINGS list
                    // AND the DEVRES_CHANGE button is enabled, then
                    // allow the change.
                    //
                    if (pHdr->idFrom == IDC_DEVRES_SETTINGSLIST) {
                        //
                        // this routine should check that we can change settings
                        //
                        pChangeCurrentResSetting(lpdmpd);
                    }
                    break;
            }
            break;
        }

        case WM_SYSCOLORCHANGE: {

            HWND hChildWnd = GetWindow(hDlg, GW_CHILD);

            while (hChildWnd != NULL) {
                SendMessage(hChildWnd, WM_SYSCOLORCHANGE, wParam, lParam);
                hChildWnd = GetWindow(hChildWnd, GW_HWNDNEXT);
            }
            break;
        }

        case WM_HELP:      // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, DEVRES_HELP, HELP_WM_HELP, (ULONG_PTR)DevResHelpIDs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, DEVRES_HELP, HELP_CONTEXTMENU, (ULONG_PTR)DevResHelpIDs);
            break;
   }

   return FALSE;

}

//
// Helper functions
//

HMACHINE
pGetMachine(
    LPDMPROP_DATA   lpdmpd
    )
/*++

Routine Description:

    Retrieve Machine Handle

Arguments:

    lpdmpd - Property Data

Return Value:

    handle

--*/
{
    HMACHINE hMachine;
    PDEVICE_INFO_SET pDeviceInfoSet;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdmpd->hDevInfo))) {
        return NULL;
    }
    hMachine = pDeviceInfoSet->hMachine;
    UnlockDeviceInfoSet(pDeviceInfoSet);
    return hMachine;
}

BOOL
pInitDevResourceDlg(
    LPDMPROP_DATA   lpdmpd
    )
/*++

Routine Description:

    This routine intializes the main resource picker property page.
    MEMPHIS COMPATIBLE.

Arguments:


Return Value:

    TRUE if "not saved"

--*/

{
    HWND            hDlg = lpdmpd->hDlg;
    CONFIGRET       Status = CR_SUCCESS;
    BOOL            bHasCurrent = FALSE;
    BOOL            bShowCurrent = FALSE;
    BOOL            bHasForced = FALSE;
    BOOL            bNoForcedConfig = FALSE;
    BOOL            bNeedsForcedConfig = FALSE;
    BOOL            bHasConfigList = FALSE;
    LV_COLUMN       LvCol;
    HWND            hWndList = NULL;
    TCHAR           szString[MAX_PATH], szTemp[MAX_PATH], szConfigType[MAX_PATH],
                    szConfig[MAX_PATH];
    ULONG           ulIndex = 0, ulSize = 0, DevStatus = 0, DevProblem = 0;
    DWORD           BusType = (DWORD)(-1);
    LOG_CONF        LogConf;
    DWORD           dwPriority = 0;
    WORD            wItem;
    ULONG           ConfigFlags;
    HMACHINE        hMachine = NULL;
    PDEVICE_INFO_SET pDeviceInfoSet;
    int             iIndex;
    BOOL            bHasPrivs = FALSE;
    //
    // Set initial control states
    //
    pHideAllControls(lpdmpd);

    //
    // determine priv token
    // security checks are visual only
    // real security checks are done in umpnpmgr
    //

    bHasPrivs = pSetupDoesUserHavePrivilege(SE_LOAD_DRIVER_NAME);

    hMachine = pGetMachine(lpdmpd);

    //
    // retrieves current configuration, if any
    //
    bHasCurrent = pGetCurrentConfig(lpdmpd);

    //
    // We sometimes get called to show this page even if the device
    // doesn't consume any resources. Check for that case and if so, just
    // display an informational message and disable everything else.
    //

    if (!pDevRequiresResources(lpdmpd->lpdi->DevInst,hMachine)) {

        //
        // This device has no resources
        //
        pShowViewNoResources(lpdmpd);
        lpdmpd->dwFlags |= DMPROP_FLAG_NO_RESOURCES;
        goto Final;
    }

    //
    // Initialize the ListView control
    //
    hWndList = GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    LvCol.mask = LVCF_TEXT;

    if (LoadString(MyDllModuleHandle, IDS_RESOURCETYPE, szString, MAX_PATH)) {
        LvCol.pszText = (LPTSTR)szString;
        ListView_InsertColumn(hWndList, 0, (LV_COLUMN FAR *)&LvCol);
    }

    if (LoadString(MyDllModuleHandle, IDS_RESOURCESETTING, szString, MAX_PATH)) {
        LvCol.pszText = (LPTSTR)szString;
        ListView_InsertColumn(hWndList, 1, (LV_COLUMN FAR *)&LvCol);
    }

    ListView_SetImageList(hWndList,lpdmpd->himlResourceImages, LVSIL_SMALL);
    //
    // Get DevStatus & DevProblem here, we may use this info further down
    //
    if (CM_Get_DevNode_Status_Ex(&DevStatus, &DevProblem, lpdmpd->lpdi->DevInst,
                              0,hMachine) != CR_SUCCESS) {
        //
        // we should never get here, show this as a problem
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_HASPROBLEM;
    } else if (DevStatus & DN_HAS_PROBLEM) {
        //
        // cache problem flag away
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_HASPROBLEM;
    } else if (DevStatus & DN_PRIVATE_PROBLEM) {
        //
        // driver indicates problem
        // for now, do same as above
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_HASPROBLEM;
    }

    if (bIsMultiFunctionChild(lpdmpd->lpdi,hMachine)) {
        //
        // If this is a MultiFunction Child, disable all change controls, put up
        // special text, and show the alloc config
        //
        pShowViewMFReadOnly(lpdmpd,FALSE);
        goto Final;
    }

    //
    // begin with read-only view, assuming settings are system
    //
    lpdmpd->dwFlags |= DMPROP_FLAG_USESYSSETTINGS;

    if (CM_Get_First_Log_Conf_Ex(NULL,
                                    lpdmpd->lpdi->DevInst,
                                    FORCED_LOG_CONF,
                                    hMachine) == CR_SUCCESS) {
        //
        // the user currently has a forced config
        //
        lpdmpd->dwFlags &= ~DMPROP_FLAG_USESYSSETTINGS;
        bHasForced = TRUE;
    }

    bShowCurrent = pShowViewReadOnly(lpdmpd,bHasPrivs);
    if (!bHasPrivs || hMachine) {
        //
        // if we don't have enough priv's
        // or we're displaying resources of a remote machine
        // bottle out here
        // we'll either be displaying current resources
        // or displaying a problem
        //
        goto Final;
    }
    if(!bHasForced) {
        //
        // Check bus we're using
        // to see if it's one of the read-only displays
        //
        ulSize = sizeof(BusType);
        if (CM_Get_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                             CM_DRP_LEGACYBUSTYPE,
                                             NULL, (LPBYTE)&BusType,
                                             &ulSize, 0,hMachine) != CR_SUCCESS) {
            BusType = (DWORD)InterfaceTypeUndefined;
        }

        if (BusType != (DWORD)InterfaceTypeUndefined) {
            int InterfaceItem;

            for(InterfaceItem = 0; ResourcePickerReadOnlyInterfaces[InterfaceItem] != InterfaceTypeUndefined; InterfaceItem++) {
                if (BusType == (DWORD)ResourcePickerReadOnlyInterfaces[InterfaceItem]) {
                    //
                    // Bus is one that we do not allow forced configs
                    // we can skip all the funky code below
                    //
                    // this is a good thing for 64-bit PCI
                    //
                    goto Final;
                }
            }
        }
    }

    //
    // Retrieve alternate configurations for this device
    //
    if (bHasCurrent) {
        //
        // Current config (if any) is indicated with zero handle
        //
        LoadString(MyDllModuleHandle, IDS_CURRENTCONFIG, szString, MAX_PATH);

        iIndex = (int)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                         CB_ADDSTRING, (WPARAM)0, (LPARAM)(LPSTR)szString);
        SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST, CB_SETITEMDATA,(WPARAM)iIndex, (LPARAM)0);
        SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST, CB_SETCURSEL,(WPARAM)0, (LPARAM)0);
    }
    //
    // now fill in alternate configurations
    // override preferred over basic (in that order)
    // don't use Filtered, filtered might remove configs that require reboot
    // but they are fine to have here
    //
    if(CM_Get_First_Log_Conf_Ex(&LogConf,lpdmpd->lpdi->DevInst,OVERRIDE_LOG_CONF,hMachine) == CR_SUCCESS) {
        lpdmpd->ConfigListLCType = OVERRIDE_LOG_CONF;
        LoadString(MyDllModuleHandle, IDS_OVERRIDECONFIG, szConfigType, MAX_PATH);
        bHasConfigList = TRUE;
    } else if(CM_Get_First_Log_Conf_Ex(&LogConf,lpdmpd->lpdi->DevInst,BASIC_LOG_CONF,hMachine) == CR_SUCCESS) {
        lpdmpd->ConfigListLCType = BASIC_LOG_CONF;
        LoadString(MyDllModuleHandle, IDS_BASICCONFIG, szConfigType, MAX_PATH);
        bHasConfigList = TRUE;
    } else {
        //
        // If there are no alternate configs, we cannot allow a forced config
        //
        bNoForcedConfig = TRUE; // cannot force
        bHasConfigList = FALSE;
        lpdmpd->ConfigListLCType = BASIC_LOG_CONF;
        lpdmpd->dwFlags |= DMPROP_FLAG_SINGLE_CONFIG;
    }
    if(bHasConfigList) {

        ulIndex = 0;
        if (!pConfigHasNoAlternates(lpdmpd,LogConf)) {
            //
            // first configuration has more than one alternative
            //
            lpdmpd->dwFlags &= ~DMPROP_FLAG_SINGLE_CONFIG;
        } else {
            //
            // begin with the assumption there is a single fixed 'basic' config
            // we will generally be proved wrong
            //
            lpdmpd->dwFlags |= DMPROP_FLAG_SINGLE_CONFIG;
        }

        while (Status == CR_SUCCESS) {
            //
            // Add this config to the Combobox
            //
            wsprintf(szTemp, TEXT("%s %04u"), szConfigType, ulIndex);

            wItem = (WORD)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                             CB_ADDSTRING, 0,
                                             (LPARAM)(LPSTR)szTemp);

            //
            // Save the log config handle as the item data in the combobox
            //
            SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST, CB_SETITEMDATA,
                               wItem, (LPARAM)LogConf);

            //
            // Get the next config
            //
            Status = CM_Get_Next_Log_Conf_Ex(&LogConf, LogConf, 0,hMachine);
            ulIndex++;
        }

        if (ulIndex > 1) {
            //
            // there is more than one config
            //
            lpdmpd->dwFlags &= ~DMPROP_FLAG_SINGLE_CONFIG;
        }

        if (lpdmpd->dwFlags & DMPROP_FLAG_SINGLE_CONFIG) {
            bNoForcedConfig = TRUE;
        }

        if (bHasCurrent) {
            //
            // try to find a matching LC now, and if we could find one,
            // re-load current display (this applies editable ranges to the resources)
            //
            if(pFindMatchingAllocConfig(lpdmpd)) {
                pLoadCurrentConfig(lpdmpd,TRUE);
            }
        }
    } else {
    }
    //
    // Get ConfigFlags here, we may use this info further down
    //
    ulSize = sizeof(ConfigFlags);
    if (CM_Get_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                         CM_DRP_CONFIGFLAGS,
                                         NULL, (LPBYTE)&ConfigFlags,
                                         &ulSize, 0,hMachine) != CR_SUCCESS) {
        ConfigFlags = 0;
    }
    if (ConfigFlags & CONFIGFLAG_NEEDS_FORCED_CONFIG) {
        //
        // registry says that we need a forced config
        // registry can only say this to us once
        //
        bNeedsForcedConfig = TRUE;
        ConfigFlags &= ~CONFIGFLAG_NEEDS_FORCED_CONFIG;
        CM_Set_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                         CM_DRP_CONFIGFLAGS,
                                         (LPBYTE)&ConfigFlags,
                                         sizeof(ConfigFlags),
                                         0,
                                         hMachine);
    }

    //
    // determine if it can be software-config'd or not
    // we need to do this prior to any initial display
    //
    dwPriority = pGetMinLCPriority(lpdmpd->lpdi->DevInst, lpdmpd->ConfigListLCType,hMachine);
    if (dwPriority < LCPRI_HARDRECONFIG) {
        //
        // doesn't need to be manually configured
        //
        lpdmpd->dwFlags &= ~DMPROP_FLAG_FORCEDONLY;
    } else {
        //
        // this cannot be software config'd
        // FORCEDONLY & bNoForcedConfig is a quandry, shouldn't happen
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_FORCEDONLY;
        if(!bHasConfigList) {
            MYASSERT(bHasConfigList);
        } else {
            MYASSERT(!bNoForcedConfig);
            bNoForcedConfig = FALSE;
        }
    }

    //
    // Try to determine initial display
    //
    // we've already covered pShowViewNoResources (no actual or potential configs)
    // and pShowViewMFReadOnly (it's a multi-function device)
    //
    // we're currently showing as pShowViewReadOnly
    //
    // some cases....
    // (1) show forced config, don't allow auto-config (config flags say requires forced)
    // (2) show forced config, allow auto-config
    // (3) don't show any config, but maybe show a forced-config button
    // (4) auto-config, don't allow forced config
    // (5) show auto-config, allow forced-config
    //
    if (bNeedsForcedConfig) {
        if (!bHasConfigList) {
            MYASSERT(bHasConfigList);
            bNeedsForcedConfig = FALSE;
        } else {
            MYASSERT(!bNoForcedConfig);
            bNoForcedConfig = FALSE;
            if (bHasForced) {
                //
                // already got one, but we'll go through the motions
                // we'll show what we have, allow user to change it
                // but we wont needlessly save it
                //
                bNeedsForcedConfig = FALSE;
            }
            //
            // caller said that device must have forced config, so go immediately there
            // = case (1) unless we've otherwise said we cannot have a forced config
            //
            lpdmpd->dwFlags |= DMPROP_FLAG_FORCEDONLY;
            pSelectLogConf(lpdmpd,(LOG_CONF)0,ALLOC_LOG_CONF,TRUE);
            pShowViewAllEdit(lpdmpd);
            goto Final;
        }
    }
    if ((!bShowCurrent) || (lpdmpd->dwFlags & DMPROP_FLAG_HASPROBLEM)) {
        //
        //  determine between pShowViewNoAlloc and pShowViewNeedForced
        //
        if (bNoForcedConfig) {
            //
            // there is a problem - device doesn't currently have a current configuration
            // but we don't have the option of letting them set forced config
            // so this ends up display only (tough-luck scenario)
            // if there are current resources, show them
            //
            pShowViewReadOnly(lpdmpd,FALSE);
        } else {
            //
            // we show the problem and we give the user
            // an option to force config
            //
            pShowViewNeedForced(lpdmpd);
        }
        goto Final;
    }
    if (!bHasConfigList) {
        //
        // If we have a current config, but no basic configs, we just display what we have
        // and don't give option to edit
        //
        pShowViewReadOnly(lpdmpd,FALSE);
        goto Final;
    }
    if ((lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS) && bNoForcedConfig) {
        //
        // we can't force a bNoForcedConfig item - display only
        //
        pShowViewReadOnly(lpdmpd,FALSE);
        goto Final;
    }
    //
    // we already have and will be displaying a current config
    //
    pShowViewAllEdit(lpdmpd);
    bNeedsForcedConfig = (BOOL)!bHasCurrent; // rarely, if ever, will this return TRUE

  Final:

    return bNeedsForcedConfig;

} // InitDevResourceDlg

PITEMDATA
pGetResourceToChange(
    IN  LPDMPROP_DATA   lpdmpd,
    OUT int             *pCur
    )
/*++

Routine Description:

    Gets resource to change
    NULL if we cannot change resource

Arguments:

    lpdmpd = dialog data
    pCur = (out) index

Return Value:

    PITEMDATA saved for selected resource

--*/
{
    HWND     hList =  GetDlgItem(lpdmpd->hDlg, IDC_DEVRES_SETTINGSLIST);
    PITEMDATA pItemData = NULL;
    int     iCur;

    //
    // first check the obvious
    //
    if (lpdmpd->dwFlags & DMPROP_FLAG_VIEWONLYRES) {
        //
        // no editing allowed
        //
        return NULL;
    }
    if (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS) {
        //
        // showing system settings
        //
        return NULL;
    }


    //
    // Check if there is a selected item.
    // If yes, then activate the change button
    // if the LC allows editing.
    //
    iCur = (int)ListView_GetNextItem(hList,-1, LVNI_SELECTED);
    if (iCur == LB_ERR) {
        //
        // no selection
        //
        return NULL;
    }
    pItemData = (PITEMDATA)pGetListViewItemData(hList, iCur, 0);
    if (pItemData == NULL) {
        //
        // shouldn't happen
        //
        MYASSERT(pItemData);
        return NULL;
    }
    if (pItemData->bFixed) {
        //
        // this is an un-editable setting
        //
        return NULL;
    }
    if (pItemData->MatchingResDes == (RES_DES)0) {
        //
        // should be caught by bFixed
        //
        MYASSERT(pItemData->MatchingResDes != (RES_DES)0);
        return NULL;
    }
    //
    // we're happy
    //
    if (pCur) {
        *pCur = iCur;
    }
    return pItemData;
}

VOID
pCheckEnableResourceChange(
    LPDMPROP_DATA   lpdmpd
    )
/*++

Routine Description:

    enables/disable change button

Arguments:


Return Value:

    none

--*/
{
#if 0 // this seems to confuse people
    EnableWindow(GetDlgItem(lpdmpd->hDlg, IDC_DEVRES_CHANGE),
                    pGetResourceToChange(lpdmpd,NULL)!=NULL);
#endif // 0

    //
    // show this button enabled if we are in EDIT mode
    //
    EnableWindow(GetDlgItem(lpdmpd->hDlg, IDC_DEVRES_CHANGE),
                 (lpdmpd->dwFlags & DMPROP_FLAG_VIEWONLYRES)==0 &&
                 (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)==0);
}

BOOL
pDevHasConfig(
    DEVINST     DevInst,
    ULONG       ulConfigType,
    HMACHINE    hMachine
    )

/*++

Routine Description:

    This routine determines whether a log config of the specified type
    exists for this device instance.
    MEMPHIS COMPATIBLE.

Arguments:

    DevInst         Device instance to query log configs for.

    ulConfigType    Specifies the type of log conf to check for the presense of.

Return Value:

   TRUE if the device has a config of that type and FALSE if it does not.

--*/

{
    BOOL bRet = (CM_Get_First_Log_Conf_Ex(NULL, DevInst, ulConfigType,hMachine) == CR_SUCCESS);
    return bRet;

} // DevHasConfig

DWORD
pGetMinLCPriority(
    IN DEVINST DevInst,
    IN ULONG   ulConfigType,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

    This routine returns the minimum priority value of all log confs of the
    specified type for this device. MEMPHIS COMPATIBLE.

Arguments:

    DevInst         Device instance to query log configs for.

    ulConfigType    Specifies the type of log conf.

Return Value:

   Returns the minimum priority value found or LCPRI_LASTSOFTCONFIG if no priorities
   are found.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    ULONG priority, minPriority = MAX_LCPRI;
    LOG_CONF LogConf, tempLC;
    BOOL FoundOneLogConfWithPriority = FALSE;

    //
    // Walk through each log conf of this type for this device and
    // save the smallest value.
    //

    Status = CM_Get_First_Log_Conf_Ex(&LogConf, DevInst, ulConfigType,hMachine);
    while (Status == CR_SUCCESS) {

        if (CM_Get_Log_Conf_Priority_Ex(LogConf, &priority, 0,hMachine) == CR_SUCCESS) {
            FoundOneLogConfWithPriority = TRUE;
            minPriority = min(minPriority, priority);
        }

        tempLC = LogConf;
        Status = CM_Get_Next_Log_Conf_Ex(&LogConf, LogConf, 0,hMachine);
        CM_Free_Log_Conf_Handle(tempLC);
    }

    if(FoundOneLogConfWithPriority) {
        return minPriority;
    } else {
        //
        // None of the LogConfigs had an associated priority. This is common on
        // NT, because the bus drivers don't specify ConfigMgr-style priorities
        // when responding to IRQ_MN_QUERY_RESOURCE_REQUIREMENTS.  Since these
        // cases are all PnP bus drivers, however, it is most correct to specify
        // these LogConfigs as soft-settable.
        //
        return LCPRI_LASTSOFTCONFIG;
    }

} // GetMinLCPriority

BOOL
pDevRequiresResources(
    DEVINST DevInst,
    HMACHINE hMachine
    )
{
    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, BASIC_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, FILTERED_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, OVERRIDE_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, FORCED_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, BOOT_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    if (CM_Get_First_Log_Conf_Ex(NULL, DevInst, ALLOC_LOG_CONF,hMachine) == CR_SUCCESS) {
        return TRUE;
    }

    return FALSE;

} // DevRequiresResources

BOOL
pGetCurrentConfig(
    IN OUT  LPDMPROP_DATA lpdmpd
    )

/*++

Routine Description:

    This routine determines the current known configuration
    current configs are either forced, alloc or boot configs.

Arguments:

    lpdmpd          Property data.

Return Value:

   TRUE if we set the current config

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    HMACHINE         hMachine;
    ULONG            Status;
    ULONG            Problem;

    MYASSERT(lpdmpd!=NULL);
    MYASSERT(lpdmpd->lpdi!=NULL);
    MYASSERT(lpdmpd->CurrentLC==0);
    MYASSERT(lpdmpd->lpdi->DevInst!=0);

    if (lpdmpd==NULL ||
        lpdmpd->lpdi==NULL ||
        lpdmpd->lpdi->DevInst==0) {
        return FALSE;
    }

    lpdmpd->dwFlags &= ~DMPROP_FLAG_DISPLAY_MASK;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdmpd->hDevInfo))) {
            return FALSE;
    }

    hMachine = pDeviceInfoSet->hMachine;

    UnlockDeviceInfoSet (pDeviceInfoSet);

    if (CM_Get_DevNode_Status_Ex(&Status, &Problem, lpdmpd->lpdi->DevInst,
                              0,hMachine) != CR_SUCCESS) {
        Problem = 0;
        Status = 0;
    } else if((Status & DN_HAS_PROBLEM)==0) {
        //
        // If this device is running, does this devinst have a ALLOC log config?
        //
        if (CM_Get_First_Log_Conf_Ex(&lpdmpd->CurrentLC,
                                     lpdmpd->lpdi->DevInst,
                                     ALLOC_LOG_CONF,
                                     hMachine) == CR_SUCCESS) {

            lpdmpd->dwFlags |= DMPROP_FLAG_DISPLAY_ALLOC;
            lpdmpd->CurrentLCType = ALLOC_LOG_CONF;
            return TRUE;
        }
    }
    //
    // If no config so far, does it have a FORCED log config?
    //

    if (CM_Get_First_Log_Conf_Ex(&lpdmpd->CurrentLC,
                                    lpdmpd->lpdi->DevInst,
                                    FORCED_LOG_CONF,
                                    hMachine) == CR_SUCCESS) {

        lpdmpd->dwFlags |= DMPROP_FLAG_DISPLAY_FORCED;
        lpdmpd->CurrentLCType = FORCED_LOG_CONF;
        return TRUE;
    }

    //
    // if there's a hardware-disabled problem, boot-config isn't valid
    //
    if(((Status & DN_HAS_PROBLEM)==0) || (Problem != CM_PROB_HARDWARE_DISABLED)) {
        //
        // Does it have a BOOT log config?
        //
        if (CM_Get_First_Log_Conf_Ex(&lpdmpd->CurrentLC,
                                        lpdmpd->lpdi->DevInst,
                                        BOOT_LOG_CONF,
                                        hMachine) == CR_SUCCESS) {

            lpdmpd->dwFlags |= DMPROP_FLAG_DISPLAY_BOOT;
            lpdmpd->CurrentLCType = BOOT_LOG_CONF;
            return TRUE;
        }
    }

    return FALSE;
}

void
pGetHdrValues(
    IN  LPBYTE      pData,
    IN  RESOURCEID  ResType,
    OUT PULONG64    pulValue,
    OUT PULONG64    pulLen,
    OUT PULONG64    pulEnd,
    OUT PULONG      pulFlags
    )
{
    switch (ResType) {

        case ResType_Mem: {

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)pData;

            *pulValue = pMemData->MEM_Header.MD_Alloc_Base;
            *pulLen   = (pMemData->MEM_Header.MD_Alloc_End -
                        pMemData->MEM_Header.MD_Alloc_Base + 1);
            *pulEnd   = pMemData->MEM_Header.MD_Alloc_End;
            *pulFlags = pMemData->MEM_Header.MD_Flags;
            break;
        }

        case ResType_IO: {

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)pData;

            *pulValue = pIoData->IO_Header.IOD_Alloc_Base;
            *pulLen   = (pIoData->IO_Header.IOD_Alloc_End -
                        pIoData->IO_Header.IOD_Alloc_Base + 1);
            *pulEnd   = pIoData->IO_Header.IOD_Alloc_End;
            *pulFlags = pIoData->IO_Header.IOD_DesFlags;
            break;
        }

        case ResType_DMA: {

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)pData;

            *pulValue = pDmaData->DMA_Header.DD_Alloc_Chan;
            *pulLen   = 1;
            *pulEnd   = *pulValue;
            *pulFlags = pDmaData->DMA_Header.DD_Flags;
            break;
        }

        case ResType_IRQ: {

            DEVRES_PIRQ_RESOURCE  pIrqData = (DEVRES_PIRQ_RESOURCE)pData;

            *pulValue = pIrqData->IRQ_Header.IRQD_Alloc_Num;
            *pulLen   = 1;
            *pulEnd   = *pulValue;
            *pulFlags = pIrqData->IRQ_Header.IRQD_Flags;
            break;
        }
    }

    if(*pulEnd < *pulValue) {
        //
        // filter out bad/zero-length range
        //
        *pulLen = 0;
    }

    return;

} // GetHdrValues

void
pGetRangeValues(
    IN  LPBYTE      pData,
    IN  RESOURCEID  ResType,
    IN  ULONG       ulIndex,
    OUT PULONG64    pulValue, OPTIONAL
    OUT PULONG64    pulLen, OPTIONAL
    OUT PULONG64    pulEnd, OPTIONAL
    OUT PULONG64    pulAlign, OPTIONAL
    OUT PULONG      pulFlags OPTIONAL
    )
{
    //
    // keep local copies
    // we transfer to parameters at end
    //
    ULONG64 ulValue;
    ULONG64 ulLen;
    ULONG64 ulEnd;
    ULONG64 ulAlign;
    ULONG ulFlags;

    switch (ResType) {

        case ResType_Mem: {

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)pData;

            ulValue = pMemData->MEM_Data[ulIndex].MR_Min;
            ulLen   = pMemData->MEM_Data[ulIndex].MR_nBytes;
            ulEnd   = pMemData->MEM_Data[ulIndex].MR_Max;
            ulFlags = pMemData->MEM_Data[ulIndex].MR_Flags;
            ulAlign = pMemData->MEM_Data[ulIndex].MR_Align;
            break;
        }

        case ResType_IO:  {

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)pData;

            ulValue = pIoData->IO_Data[ulIndex].IOR_Min;
            ulLen   = pIoData->IO_Data[ulIndex].IOR_nPorts;
            ulEnd   = pIoData->IO_Data[ulIndex].IOR_Max;
            ulFlags = pIoData->IO_Data[ulIndex].IOR_RangeFlags;
            ulAlign = pIoData->IO_Data[ulIndex].IOR_Align;
            break;
        }

        case ResType_DMA: {

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)pData;

            ulValue = pDmaData->DMA_Data[ulIndex].DR_Min;
            ulLen   = 1;
            ulEnd   = ulValue;
            ulFlags = pDmaData->DMA_Data[ulIndex].DR_Flags;
            ulAlign = 1;
            break;
        }

        case ResType_IRQ: {

            DEVRES_PIRQ_RESOURCE  pIrqData = (DEVRES_PIRQ_RESOURCE)pData;

            ulValue = pIrqData->IRQ_Data[ulIndex].IRQR_Min;
            ulLen   = 1;
            ulEnd   = ulValue;
            ulFlags = pIrqData->IRQ_Data[ulIndex].IRQR_Flags;
            ulAlign = 1;
            break;
        }
    }

    if(ulEnd < ulValue) {
        //
        // filter out bad/zero-length range
        //
        ulLen = 0;
    }

    pAlignValues(&ulValue, ulValue, ulLen, ulEnd, ulAlign,1);

    //
    // copy return parameters
    //
    if (pulValue) {
        *pulValue = ulValue;
    }
    if (pulLen) {
        *pulLen = ulLen;
    }
    if (pulEnd) {
        *pulEnd = ulEnd;
    }
    if (pulAlign) {
        *pulAlign = ulAlign;
    }
    if (pulFlags) {
        *pulFlags = ulFlags;
    }


    return;

}

BOOL
pAlignValues(
    IN OUT PULONG64  pulValue,
    IN     ULONG64   ulStart,
    IN     ULONG64   ulLen,
    IN     ULONG64   ulEnd,
    IN     ULONG64   ulAlignment,
    IN     int       Increment
    )
{
    ULONG64 NtAlign = ~ulAlignment + 1;   // convert from mask to modulus
    ULONG64 Value;
    ULONG64 Upp;
    ULONG64 Remainder;

    Value = *pulValue;

    if (NtAlign == 0) {
        return FALSE;   // bogus alignment value
    }

    if (NtAlign != 1 && Increment != 0) {
        //
        // see if we are aligned
        //

        Remainder = Value % NtAlign;

        if (Remainder != 0) {
            //
            // need to re-align
            //
            if (Increment>0) {
                //
                // Return the first valid aligned value greater than this value
                //
                Value += NtAlign - Remainder;

                if (Value <= *pulValue) {
                    //
                    // overflow detected
                    //
                    return FALSE;
                }

            } else {
                //
                // Return the first valid aligned value less than this value
                //
                Value -= Remainder;
                //
                // we never overflow going down, since zero is a common denominator
                // of alignment
                //
            }

        }
    }

    //
    // now check boundaries
    //

    if (Value < ulStart) {
        return FALSE;
    }

    Upp = Value+ulLen-1;
    if (Upp < Value) {
        //
        // catch overflow error
        //
        return FALSE;
    }
    if (Upp > ulEnd) {
        return FALSE;
    }

    //
    // set newly aligned value
    //

    *pulValue = Value;

    return TRUE;

}

void
pFormatResString(
    LPDMPROP_DATA lpdmpd,
    LPTSTR      lpszString,
    ULONG64     ulVal,
    ULONG64     ulLen,
    RESOURCEID  ResType
    )
{
    if (ulLen == 0) {
        wsprintf(lpszString, szNoValue);
    } else if ((ResType == ResType_DMA) || (ResType == ResType_IRQ)) {
        wsprintf(lpszString, szOneDecNoConflict, (UINT)ulVal);
    } else if (ResType == ResType_IO) {
        wsprintf(lpszString, szTwoWordHexNoConflict, (ULONG)ulVal,
                 (ULONG)(ulVal + ulLen - 1));
    } else if ((ulVal+(ulLen-1)) >= 0x100000000) {
        //
        // NTRAID # 712013 - this needs to be improved
        //
        wsprintf(lpszString, szTwo64bitHexNoConflict, (ULONG64)ulVal,
                 (ULONG64)(ulVal + ulLen - 1));
    } else {
        wsprintf(lpszString, szTwoDWordHexNoConflict, (ULONG)ulVal,
                 (ULONG)(ulVal + ulLen - 1));
    }

}

BOOL
pUnFormatResString(
    LPTSTR      lpszString,
    PULONG64    pulVal,
    PULONG64    pulEnd,
    RESOURCEID  ridResType
    )
{
    BOOL     bRet = FALSE;
    LPTSTR   lpszTemp = NULL;
    LPTSTR   lpszTemp2 = NULL;
    LPTSTR   lpszCopy;

    // ISSUE-2000/02/03 Fix pUnFormatResString bugs
    //
    // - extend this to handling DWORDLONG values
    // - use correct Prev/Next functions for parsing string
    //

    //
    // Allocate space for, and make a copy of the input string
    //
    lpszCopy = MyMalloc((lstrlen(lpszString)+1) * sizeof(TCHAR));

    if (lpszCopy == NULL) {
        return FALSE;
    }

    lstrcpy(lpszCopy, lpszString);

    //
    // Locate the dash if there is one, and convert the white space prev to
    // the dash to a NULL. (ie 0200 - 0400 while be 0200)
    //
    lpszTemp = lpszCopy;
    while ((*lpszTemp != '-') && (*lpszTemp != '\0')) {
        lpszTemp++; // AnsiNext?
    }

    if (*lpszTemp != '\0') {
        lpszTemp2 = lpszTemp-1;
        ++lpszTemp;
    }

    //
    // Search back to set the NULL for the Value
    //
    if (lpszTemp2 != NULL) {
        while ((*lpszTemp2 == ' ') || (*lpszTemp2 == '\t'))
            lpszTemp2--; // AnsiPrev?
        *(lpszTemp2+1)= '\0';
    }

    //
    // Convert the first entry
    //
    if (pConvertEditText(lpszCopy, pulVal, ridResType)) {
        //
        // If there is a second entry, convert it, otherwise assume a length
        // of one.
        //
        if (*lpszTemp != '\0') {
            if (pConvertEditText(lpszTemp, pulEnd,ridResType)) {
                bRet = TRUE;
            }
        } else {
            *pulEnd = *pulVal;
            bRet = TRUE;
        }
    }

    MyFree(lpszCopy);
    return bRet;

}

BOOL
pConvertEditText(
    LPTSTR      lpszConvert,
    PULONG64    pulVal,
    RESOURCEID  ridResType
    )
{
    LPTSTR   lpConvert;

    if ((ridResType == ResType_Mem) || (ridResType == ResType_IO)) {
        *pulVal = _tcstoul(lpszConvert, &lpConvert, (WORD)16);
    } else {
        *pulVal = _tcstoul(lpszConvert, &lpConvert, (WORD)10);
    }

    if (lpConvert == lpszConvert+lstrlen(lpszConvert)) {
        return TRUE;
    } else {
        return FALSE;
    }

} // ConvertEditText

void
pWarnResSettingNotEditable(
    HWND    hDlg,
    WORD    idWarning
    )
{
    TCHAR    szTitle[MAX_PATH];
    TCHAR    szMessage[MAX_PATH * 2];

    //
    // Give some warning Messages.  If there is no logconfig,
    // then we cannot edit any settings, if there is, then
    // just the setting they are choosing is not editable.
    //
    LoadString(MyDllModuleHandle, IDS_DEVRES_NOMODIFYTITLE, szTitle, MAX_PATH);
    LoadString(MyDllModuleHandle, idWarning, szMessage, MAX_PATH * 2);
    MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION);

} // WarnResSettingsNotEditable

int
pWarnNoSave(
    HWND    hDlg,
    WORD    idWarning
    )
/*++

Routine Description:

    Warn that the settings will not be saved

Arguments:

Return Value:

    IDCANCEL = don't proceed
    IDOK/IDYES/IDNO = proceed without saving

--*/
{
    TCHAR    szTitle[MAX_PATH];
    TCHAR    szMessage[MAX_PATH * 2];
    int      res;

    //
    // Give a warning message of why we can't save settings
    //
    LoadString(MyDllModuleHandle, IDS_MAKE_FORCED_TITLE, szTitle, MAX_PATH);
    LoadString(MyDllModuleHandle, idWarning, szMessage, MAX_PATH * 2);

    //res = MessageBox(hDlg, szMessage, szTitle, MB_OKCANCEL | MB_TASKMODAL | MB_ICONEXCLAMATION);
    //return res;
    res = MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION);
    return IDCANCEL;
}

LPVOID
pGetListViewItemData(
    HWND hList,
    int iItem,
    int iSubItem
    )
{
    LV_ITEM lviItem;

    lviItem.mask = LVIF_PARAM;
    lviItem.iItem = iItem;
    lviItem.iSubItem = iSubItem;

    if (ListView_GetItem(hList, &lviItem)) {
        return (LPVOID)lviItem.lParam;
    } else {
        return NULL;
    }

} // GetListViewItemData

BOOL
pSaveDevResSettings(
    LPDMPROP_DATA   lpdmpd
    )

/*++

Routine Description:

    This routine saves the resources based on the users selections.
    MEMPHIS COMPATIBLE.

Arguments:

    lpdmpd          Property data.

Return Value:

   Returns TRUE if the function succeeded and FALSE if it failed.

--*/

{
    HWND        hDlg = lpdmpd->hDlg;
    HWND        hList =  GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);

    CONFIGRET   Status = CR_SUCCESS;
    LOG_CONF    ForcedLogConf;
    RES_DES     ResDes, ResDesTemp, ResDes1;
    RESOURCEID  ResType;
    ULONG       ulSize = 0, ulCount = 0, i = 0, iCur = 0;
    LPBYTE      pData = NULL;
    PITEMDATA   pItemData = NULL;
    BOOL        bRet = TRUE;
    SP_PROPCHANGE_PARAMS PropChangeParams;
    HMACHINE        hMachine = pGetMachine(lpdmpd);

    if ((lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)!=0) {

        //-------------------------------------------------------------------
        // If the user checked the "Use Automatic Settings" checkbox, then
        // delete any Boot/Forced configs, otherwise write the current settings
        // as a forced config.
        //-------------------------------------------------------------------

        if (CM_Get_First_Log_Conf_Ex(&ForcedLogConf, lpdmpd->lpdi->DevInst,
                                     FORCED_LOG_CONF,hMachine) == CR_SUCCESS) {
            CM_Free_Log_Conf_Ex(ForcedLogConf, 0,hMachine);
            CM_Free_Log_Conf_Handle(ForcedLogConf);
        }

        // Let the helper modules (class installer/co-installers) get in on the act...
        //
        PropChangeParams.ClassInstallHeader.cbSize          = sizeof(SP_CLASSINSTALL_HEADER);
        PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

        PropChangeParams.StateChange = DICS_PROPCHANGE;
        PropChangeParams.Scope       = DICS_FLAG_GLOBAL;
        // no need to set PropChangeParams.HwProfile, since this is a global property change.

        DoInstallActionWithParams(DIF_PROPERTYCHANGE,
                                  lpdmpd->hDevInfo,
                                  lpdmpd->lpdi,
                                  (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                  sizeof(PropChangeParams),
                                  INSTALLACTION_CALL_CI
                                  );
    } else {

        //-------------------------------------------------------------------
        // The Use Automatic Settings is not selected.
        //-------------------------------------------------------------------

        bRet = pSaveCustomResSettings(lpdmpd,hMachine);
    }

    return bRet;
}

BOOL
pSaveCustomResSettings(
    LPDMPROP_DATA   lpdmpd,
    IN HMACHINE     hMachine
    )

/*++

Routine Description:

    This routine saves custom (user edited) resources. MEMPHIS COMPATIBLE but
    extracted from Memphis version of SaveDevResSetting().

Arguments:

    lpdmpd      Property data.

Return Value:

   Returns TRUE if the function succeeded and FALSE if it failed.

--*/

{
    HWND        hDlg = lpdmpd->hDlg;

    TCHAR       szWarn[MAX_MSG_LEN];
    TCHAR       szTitle[MAX_MSG_LEN];
    TCHAR       szTemp[MAX_MSG_LEN];
    DWORD       dwPriority, dwLCPri;
    LOG_CONF    ForcedLogConf;
    RES_DES     ResDes;
    HWND        hList = GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    PITEMDATA   pItemData = NULL;
    LONG        iCur;
    BOOL        bRet = FALSE;
    SP_PROPCHANGE_PARAMS PropChangeParams;
    DWORD       HardReconfigFlag;
    SP_DEVINSTALL_PARAMS DevInstallParams;
    PRESDES_ENTRY pResList = NULL, pResDesEntry = NULL, pTemp = NULL;
    PITEMDATA_LISTNODE ItemDataList = NULL, ItemDataListEntry, ItemDataListEnd = NULL;
    PGENERIC_RESOURCE pGenRes;
    ULONG       i, ulFlags;
    ULONG64     ulValue, ulLen, ulEnd;
    LOG_CONF    LogConf;
    ULONG       ulSize;
    ULONG       ulConfigFlags;
    HCURSOR     hOldCursor;
    BOOL        UsingMatch = FALSE;

    LogConf = lpdmpd->SelectedLC;
    if (LogConf == 0) {
        LogConf = lpdmpd->MatchingLC;
        UsingMatch = TRUE;
    }
    if (LogConf == 0) {
        LogConf = lpdmpd->CurrentLC;
        UsingMatch = FALSE;
    }
    if (LogConf == 0) {
        //MYASSERT(FALSE);
        return FALSE;
    }
    //
    // form the "warning - do you want to continue" message
    //
    if(!LoadString(MyDllModuleHandle, IDS_MAKE_FORCED_TITLE, szTitle, MAX_MSG_LEN)) {
        szTitle[0]=TEXT('\0');
    }
    if(!LoadString(MyDllModuleHandle, IDS_FORCEDCONFIG_WARN1, szWarn, MAX_MSG_LEN)) {
        szWarn[0]=TEXT('\0');
    }
    if(LoadString(MyDllModuleHandle, IDS_FORCEDCONFIG_WARN2, szTemp, MAX_MSG_LEN)) {
        lstrcat(szWarn, szTemp);
    }
    if(LoadString(MyDllModuleHandle, IDS_FORCEDCONFIG_WARN3, szTemp, MAX_MSG_LEN)) {
        lstrcat(szWarn, szTemp);
    }
    if(LoadString(MyDllModuleHandle, IDS_FORCEDCONFIG_WARN4, szTemp, MAX_MSG_LEN)) {
        lstrcat(szWarn, szTemp);
    }

    //
    // If the LCPRI is soft configurable, and the user chooses YES to the
    // warning, then save the new config.  If the LCPRI is not soft
    // configurable, just save with no warning
    //
    dwLCPri = pGetMinLCPriority(lpdmpd->lpdi->DevInst, lpdmpd->ConfigListLCType,hMachine);

    if (((dwLCPri >= LCPRI_DESIRED) && (dwLCPri <= LCPRI_LASTSOFTCONFIG)) &&
          (MessageBox(hDlg, szWarn, szTitle, MB_YESNO|MB_ICONEXCLAMATION) == IDNO)) {
        //
        // user doesn't want to change anything
        //
        bRet = FALSE;

    } else {
        //
        // We're still using the selected basic LC, but use the range index
        // embedded in the listview control
        // ISSUE-2000/02/03-JamieHun Selected Basic LC, check if user overrode
        // Need to check the value to see if a user overrode it (is this possible?)
        //
        bRet = TRUE;

        if (CM_Get_First_Log_Conf_Ex(&ForcedLogConf, lpdmpd->lpdi->DevInst,
                                  FORCED_LOG_CONF,hMachine) == CR_SUCCESS) {
            CM_Free_Log_Conf_Ex(ForcedLogConf, 0,hMachine);
            CM_Free_Log_Conf_Handle(ForcedLogConf);
        }

        //
        // Save the current choices as the forced config
        //
        CM_Add_Empty_Log_Conf_Ex(&ForcedLogConf, lpdmpd->lpdi->DevInst, LCPRI_FORCECONFIG,
                              FORCED_LOG_CONF | PRIORITY_EQUAL_FIRST,hMachine);

        pGetResDesDataList(LogConf, &pResList, FALSE,hMachine);
        pResDesEntry = pResList;

        if (UsingMatch && (lpdmpd->dwFlags & DMPROP_FLAG_MATCH_OUT_OF_ORDER)) {
            //
            // The resource descriptors are out-of-order.  Maintain the original ordering.
            //
            // First, build up a linked list of the data in the listview resource items.
            //
            iCur = (int)ListView_GetNextItem(hList, -1, LVNI_ALL);

            while (iCur != -1) {

                pItemData = (PITEMDATA)pGetListViewItemData(hList, iCur, 0);
                if (pItemData) {
                    //
                    // Allocate an item data list node for this data.
                    //
                    ItemDataListEntry = MyMalloc(sizeof(ITEMDATA_LISTNODE));
                    if (!ItemDataListEntry) {
                        bRet = FALSE;
                        goto clean0;
                    }

                    ItemDataListEntry->ItemData = pItemData;
                    ItemDataListEntry->Next = NULL;

                    //
                    // Append this new item to the end of our list.
                    //
                    if (ItemDataListEnd) {
                        ItemDataListEnd->Next = ItemDataListEntry;
                    } else {
                        ItemDataList = ItemDataListEntry;
                    }
                    ItemDataListEnd = ItemDataListEntry;
                }

                iCur = (int)ListView_GetNextItem(hList, iCur, LVNI_ALL);
            }

            //
            // Now loop through each resdes entry, writing each one out.  For each one, check
            // to see if it has a corresponding entry in our listview item data list.
            //
            while (pResDesEntry) {
                pGenRes = (PGENERIC_RESOURCE)pResDesEntry->ResDesData;

                for(ItemDataListEntry = ItemDataList, ItemDataListEnd = NULL;
                    ItemDataListEntry;
                    ItemDataListEnd = ItemDataListEntry, ItemDataListEntry = ItemDataListEntry->Next)
                {
                    if(pResDesEntry->ResDesType == ItemDataListEntry->ItemData->ResType) {

                        for (i = 0; i < pGenRes->GENERIC_Header.GENERIC_Count; i++) {

                            pGetRangeValues(pResDesEntry->ResDesData, pResDesEntry->ResDesType, i,
                                           &ulValue, &ulLen, &ulEnd, NULL, &ulFlags);

                            if ((ItemDataListEntry->ItemData->ulLen == ulLen) &&
                                (ItemDataListEntry->ItemData->ulValue >= ulValue) &&
                                (ItemDataListEntry->ItemData->ulEnd <= ulEnd)) {
                                //
                                // We found the matching resource descriptor.  Write this out.
                                //
                                pWriteValuesToForced(ForcedLogConf,
                                                    ItemDataListEntry->ItemData->ResType,
                                                    ItemDataListEntry->ItemData->RangeCount,
                                                    ItemDataListEntry->ItemData->MatchingResDes,
                                                    ItemDataListEntry->ItemData->ulValue,
                                                    ItemDataListEntry->ItemData->ulLen,
                                                    ItemDataListEntry->ItemData->ulEnd,
                                                    hMachine );
                                //
                                // Remove this item from our list.
                                //
                                if (ItemDataListEnd) {
                                    ItemDataListEnd->Next = ItemDataListEntry->Next;
                                } else {
                                    ItemDataList = ItemDataListEntry->Next;
                                }
                                MyFree(ItemDataListEntry);

                                break;
                            }
                        }

                        if(i < pGenRes->GENERIC_Header.GENERIC_Count) {
                            //
                            // Then we broke out of the loop early, which means we found a match
                            // already.
                            //
                            break;
                        }
                    }
                }

                //
                // If we didn't find a match, then go ahead and write out the non-arbitrated
                // resdes.
                //
                if (!ItemDataListEntry) {
                    pWriteResDesRangeToForced(ForcedLogConf,
                                             pResDesEntry->ResDesType,
                                             0,
                                             0,
                                             pResDesEntry->ResDesData,
                                             hMachine);
                }

                pResDesEntry = (PRESDES_ENTRY)pResDesEntry->Next;
            }

        } else {

            iCur = (int)ListView_GetNextItem(hList, -1, LVNI_ALL);

            while (iCur != -1) {

                pItemData = (PITEMDATA)pGetListViewItemData(hList, iCur, 0);

                if (pItemData) {

                    // retrieve values

                    while (pResDesEntry &&
                           (pItemData->ResType != pResDesEntry->ResDesType)) {
                        //
                        // write out any preceding non arbitrated resources
                        //
                        pWriteResDesRangeToForced(ForcedLogConf,
                                                 pResDesEntry->ResDesType,
                                                 0,
                                                 0,
                                                 pResDesEntry->ResDesData,
                                                 hMachine);

                        pResDesEntry = (PRESDES_ENTRY)pResDesEntry->Next;
                    }
                    if (pGetMatchingResDes(pItemData->ulValue,
                                          pItemData->ulLen,
                                          pItemData->ulEnd,
                                          pItemData->ResType,
                                          LogConf,
                                          &ResDes,
                                          hMachine)) {
                        //
                        // Write the first range as the chosen forced resource
                        //
                        pWriteValuesToForced(ForcedLogConf, pItemData->ResType,
                                            pItemData->RangeCount, ResDes,
                                            pItemData->ulValue,
                                            pItemData->ulLen,
                                            pItemData->ulEnd,
                                            hMachine);
                    }
                }

                if (pResDesEntry) {
                    pResDesEntry = (PRESDES_ENTRY)pResDesEntry->Next;
                } else {
                    MYASSERT(pResDesEntry);
                }
                iCur = (int)ListView_GetNextItem(hList, iCur, LVNI_ALL);
            }

            while (pResDesEntry) {
                //
                // write out any subsequent non arbitrated resources
                //
                pWriteResDesRangeToForced(ForcedLogConf,
                                         pResDesEntry->ResDesType,
                                         0,
                                         0,
                                         pResDesEntry->ResDesData,
                                         hMachine);

                pResDesEntry = (PRESDES_ENTRY)pResDesEntry->Next;
            }
        }

        CM_Free_Log_Conf_Handle(ForcedLogConf);

        //
        // consider clearing problem flags
        //
        ulSize = sizeof(ulConfigFlags);
        if (CM_Get_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                             CM_DRP_CONFIGFLAGS,
                                             NULL, (LPBYTE)&ulConfigFlags,
                                             &ulSize, 0,hMachine) == CR_SUCCESS) {
            if ((ulConfigFlags & CONFIGFLAG_PARTIAL_LOG_CONF) != 0) {
                //
                // have flag(s) to change
                // CONFIGFLAG_PARTIAL_LOG_CONF should be cleared - we should have written a complete config now
                //
                ulConfigFlags &= ~ (CONFIGFLAG_PARTIAL_LOG_CONF);
                CM_Set_DevInst_Registry_Property_Ex(lpdmpd->lpdi->DevInst,
                                                 CM_DRP_CONFIGFLAGS,
                                                 (LPBYTE)&ulConfigFlags,
                                                 sizeof(ulConfigFlags),
                                                 0,
                                                 hMachine);
            }

        }

        //
        // Give the class installer/co-installers a crack at the propchange process.
        //
        PropChangeParams.ClassInstallHeader.cbSize          = sizeof(SP_CLASSINSTALL_HEADER);
        PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

        PropChangeParams.StateChange = DICS_PROPCHANGE;
        PropChangeParams.Scope       = DICS_FLAG_GLOBAL;
        // no need to set PropChangeParams.HwProfile, since this is a global property change.

        DoInstallActionWithParams(DIF_PROPERTYCHANGE,
                                  lpdmpd->hDevInfo,
                                  lpdmpd->lpdi,
                                  (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                  sizeof(PropChangeParams),
                                  INSTALLACTION_CALL_CI | INSTALLACTION_NO_DEFAULT
                                 );

        //
        // Check the Priority of this LC.  If it is greater
        // than LCPRI_LASTSOFTCONFIG, then we need to reboot
        // otherwise try the dynamic changestate route.
        //

        if (CM_Get_Log_Conf_Priority_Ex(LogConf, &dwPriority, 0,hMachine) != CR_SUCCESS) {
            dwPriority = LCPRI_LASTSOFTCONFIG;
        }

        if (dwPriority <= LCPRI_LASTSOFTCONFIG) {
            //
            // Do the default action for SoftConfigable devices, which
            // will attempt to restart the device with the new config
            // This could take a while so use an hourglass
            //
            hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DoInstallActionWithParams(DIF_PROPERTYCHANGE,
                                      lpdmpd->hDevInfo,
                                      lpdmpd->lpdi,
                                      (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                      sizeof(PropChangeParams),
                                      0  // don't call class-installer, just do default action
                                     );
            SetCursor(hOldCursor);
            HardReconfigFlag = 0;

        } else if((dwPriority > LCPRI_LASTSOFTCONFIG) && (dwPriority <= LCPRI_RESTART)) {
            HardReconfigFlag = DI_NEEDRESTART;
        } else {
            HardReconfigFlag = DI_NEEDREBOOT;
        }

        lpdmpd->dwFlags |= DMPROP_FLAG_CHANGESSAVED;

        //
        // Properties have changed, so set flags to indicate if restart/reboot is required,
        // and to tell DevMgr to re-init the UI.
        //
        DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if(SetupDiGetDeviceInstallParams(lpdmpd->hDevInfo,
                                         lpdmpd->lpdi,
                                         &DevInstallParams)) {

            DevInstallParams.Flags |= (HardReconfigFlag | DI_PROPERTIES_CHANGE);

            SetupDiSetDeviceInstallParams(lpdmpd->hDevInfo,
                                          lpdmpd->lpdi,
                                          &DevInstallParams
                                         );
        }

        //
        // If we need to reboot, then set a problem on the device that indicates this (in case
        // the user doesn't listen to us, we want to flag this devnode so that the user will see
        // that this devnode needs a reboot if they go into DevMgr, etc.)
        //
        if(HardReconfigFlag) {
            PDEVICE_INFO_SET pDeviceInfoSet;
            PDEVINFO_ELEM DevInfoElem;

            if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdmpd->hDevInfo))) {
                //
                // We'd better be able to access this device information set!
                // In case we couldn't don't bother trying to set the needs-reboot problem,
                // because the whole mess is invalid!
                //
                MYASSERT(pDeviceInfoSet);
            } else {

                try {
                    DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet, lpdmpd->lpdi, NULL);
                    //
                    // We'd better be able to find this element!
                    //
                    MYASSERT(DevInfoElem);
                    //
                    // In case we can't find it, don't try to set any problem on the devnode.
                    //
                    if(DevInfoElem) {

                        SetDevnodeNeedsRebootProblem(DevInfoElem,
                                                     pDeviceInfoSet,
                                                     MSG_LOG_REBOOT_DEVRES
                                                    );
                    }
                } finally {
                    UnlockDeviceInfoSet(pDeviceInfoSet);
                }
            }

        }
    }

clean0:

    while (ItemDataList) {
        ItemDataListEntry = ItemDataList->Next;
        MyFree(ItemDataList);
        ItemDataList = ItemDataListEntry;
    }

    pDeleteResDesDataList(pResList);

    return bRet;

} // SaveCustomResSettings

BOOL
pWriteResDesRangeToForced(
    IN LOG_CONF     ForcedLogConf,
    IN RESOURCEID   ResType,
    IN ULONG        RangeIndex,
    IN RES_DES      RD,             OPTIONAL
    IN LPBYTE       ResDesData,     OPTIONAL
    IN HMACHINE     hMachine        OPTIONAL
    )
{
    RES_DES ResDes;
    ULONG   ulSize;
    LPBYTE  pData = NULL;
    BOOL Success = FALSE;


    if ((RD == 0) && (ResDesData == NULL)) {
        return FALSE;   // pass in data or handle!
    }

    if (!ResDesData) {

        if (CM_Get_Res_Des_Data_Size_Ex(&ulSize, RD, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
            return FALSE;
        }

        pData = MyMalloc(ulSize);
        if (pData == NULL) {
            return FALSE;
        }

        if (CM_Get_Res_Des_Data_Ex(RD, pData, ulSize, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
            MyFree(pData);
            return FALSE;
        }
    } else {
        pData = ResDesData;
    }

    //
    // convert the first range data into hdr data
    //
    switch (ResType) {

        case ResType_Mem: {

            PMEM_RESOURCE pMemData = (PMEM_RESOURCE)pData;
            PMEM_RESOURCE pForced = (PMEM_RESOURCE)MyMalloc(sizeof(MEM_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->MEM_Header.MD_Count      = 0;
            pForced->MEM_Header.MD_Type       = MType_Range;
            pForced->MEM_Header.MD_Alloc_Base = pMemData->MEM_Data[RangeIndex].MR_Min;
            pForced->MEM_Header.MD_Alloc_End  = pMemData->MEM_Data[RangeIndex].MR_Min +
                                                pMemData->MEM_Data[RangeIndex].MR_nBytes - 1;
            pForced->MEM_Header.MD_Flags      = pMemData->MEM_Data[RangeIndex].MR_Flags;
            pForced->MEM_Header.MD_Reserved   = 0;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_Mem,
                                        pForced,
                                        sizeof(MEM_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_IO:  {

            PIO_RESOURCE pIoData = (PIO_RESOURCE)pData;
            PIO_RESOURCE pForced = (PIO_RESOURCE)MyMalloc(sizeof(IO_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->IO_Header.IOD_Count      = 0;
            pForced->IO_Header.IOD_Type       = IOType_Range;
            pForced->IO_Header.IOD_Alloc_Base = pIoData->IO_Data[RangeIndex].IOR_Min;
            pForced->IO_Header.IOD_Alloc_End  = pIoData->IO_Data[RangeIndex].IOR_Min +
                                                pIoData->IO_Data[RangeIndex].IOR_nPorts - 1;
            pForced->IO_Header.IOD_DesFlags   = pIoData->IO_Data[RangeIndex].IOR_RangeFlags;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_IO,
                                        pForced,
                                        sizeof(IO_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_DMA: {

            PDMA_RESOURCE pDmaData = (PDMA_RESOURCE)pData;
            PDMA_RESOURCE pForced = (PDMA_RESOURCE)MyMalloc(sizeof(DMA_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->DMA_Header.DD_Count      = 0;
            pForced->DMA_Header.DD_Type       = DType_Range;
            pForced->DMA_Header.DD_Flags      = pDmaData->DMA_Data[RangeIndex].DR_Flags;
            pForced->DMA_Header.DD_Alloc_Chan = pDmaData->DMA_Data[RangeIndex].DR_Min;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_DMA,
                                        pForced,
                                        sizeof(DMA_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_IRQ: {

            DEVRES_PIRQ_RESOURCE pIrqData = (DEVRES_PIRQ_RESOURCE)pData;
            DEVRES_PIRQ_RESOURCE pForced = (DEVRES_PIRQ_RESOURCE)MyMalloc(sizeof(DEVRES_IRQ_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->IRQ_Header.IRQD_Count     = 0;
            pForced->IRQ_Header.IRQD_Type      = IRQType_Range;
            pForced->IRQ_Header.IRQD_Flags     = pIrqData->IRQ_Data[RangeIndex].IRQR_Flags;
            pForced->IRQ_Header.IRQD_Alloc_Num = pIrqData->IRQ_Data[RangeIndex].IRQR_Min;
            pForced->IRQ_Header.IRQD_Affinity  = (DEVRES_AFFINITY)(-1);

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_IRQ,
                                        pForced,
                                        sizeof(DEVRES_IRQ_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_BusNumber: {

            PBUSNUMBER_RESOURCE pBusData = (PBUSNUMBER_RESOURCE)pData;
            PBUSNUMBER_RESOURCE pForced = (PBUSNUMBER_RESOURCE)MyMalloc(sizeof(BUSNUMBER_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->BusNumber_Header.BUSD_Count      = 0;
            pForced->BusNumber_Header.BUSD_Type       = BusNumberType_Range;
            pForced->BusNumber_Header.BUSD_Flags      = pBusData->BusNumber_Data[RangeIndex].BUSR_Flags;
            pForced->BusNumber_Header.BUSD_Alloc_Base = pBusData->BusNumber_Data[RangeIndex].BUSR_Min;
            pForced->BusNumber_Header.BUSD_Alloc_End  = pBusData->BusNumber_Data[RangeIndex].BUSR_Min +
                                                  pBusData->BusNumber_Data[RangeIndex].BUSR_nBusNumbers;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_BusNumber,
                                        pForced,
                                        sizeof(BUSNUMBER_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_DevicePrivate: {

            PDEVPRIVATE_RESOURCE pPrvData = (PDEVPRIVATE_RESOURCE)pData;
            PDEVPRIVATE_RESOURCE pForced = (PDEVPRIVATE_RESOURCE)MyMalloc(sizeof(DEVPRIVATE_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->PRV_Header.PD_Count = 0;
            pForced->PRV_Header.PD_Type  = PType_Range;
            pForced->PRV_Header.PD_Data1 = pPrvData->PRV_Data[RangeIndex].PR_Data1;
            pForced->PRV_Header.PD_Data2 = pPrvData->PRV_Data[RangeIndex].PR_Data2;
            pForced->PRV_Header.PD_Data3 = pPrvData->PRV_Data[RangeIndex].PR_Data3;
            pForced->PRV_Header.PD_Flags = 0;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_DevicePrivate,
                                        pForced,
                                        sizeof(DEVPRIVATE_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_PcCardConfig: {

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_PcCardConfig,
                                        pData,
                                        sizeof(PCCARD_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine);
            break;
        }
    }

    if (pData != ResDesData) {
        MyFree(pData);
    }

    return Success;

} // WriteResDesRangeToForced

BOOL
pWriteValuesToForced(
    IN LOG_CONF     ForcedLogConf,
    IN RESOURCEID   ResType,
    IN ULONG        RangeIndex,
    IN RES_DES      RD,
    IN ULONG64      ulValue,
    IN ULONG64      ulLen,
    IN ULONG64      ulEnd,
    IN HMACHINE     hMachine
    )
{
    RES_DES ResDes;
    ULONG   ulSize;
    LPBYTE  pData = NULL;
    BOOL Success = FALSE;


    if (CM_Get_Res_Des_Data_Size_Ex(&ulSize, RD, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
        return FALSE;
    }

    pData = MyMalloc(ulSize);
    if (pData == NULL) {
        return FALSE;
    }

    if (CM_Get_Res_Des_Data_Ex(RD, pData, ulSize, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
        MyFree(pData);
        return FALSE;
    }

    //
    // convert the first range data into hdr data
    //
    switch (ResType) {

        case ResType_Mem: {

            PMEM_RESOURCE pMemData = (PMEM_RESOURCE)pData;
            PMEM_RESOURCE pForced = (PMEM_RESOURCE)MyMalloc(sizeof(MEM_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->MEM_Header.MD_Count      = 0;
            pForced->MEM_Header.MD_Type       = MType_Range;
            pForced->MEM_Header.MD_Alloc_Base = ulValue;
            pForced->MEM_Header.MD_Alloc_End  = ulEnd;
            pForced->MEM_Header.MD_Flags      = pMemData->MEM_Data[RangeIndex].MR_Flags;
            pForced->MEM_Header.MD_Reserved   = 0;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_Mem,
                                        pForced,
                                        sizeof(MEM_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_IO:  {

            PIO_RESOURCE pIoData = (PIO_RESOURCE)pData;
            PIO_RESOURCE pForced = (PIO_RESOURCE)MyMalloc(sizeof(IO_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->IO_Header.IOD_Count      = 0;
            pForced->IO_Header.IOD_Type       = IOType_Range;
            pForced->IO_Header.IOD_Alloc_Base = ulValue;
            pForced->IO_Header.IOD_Alloc_End  = ulEnd;
            pForced->IO_Header.IOD_DesFlags   = pIoData->IO_Data[RangeIndex].IOR_RangeFlags;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_IO,
                                        pForced,
                                        sizeof(IO_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_DMA: {

            PDMA_RESOURCE pDmaData = (PDMA_RESOURCE)pData;
            PDMA_RESOURCE pForced = (PDMA_RESOURCE)MyMalloc(sizeof(DMA_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->DMA_Header.DD_Count      = 0;
            pForced->DMA_Header.DD_Type       = DType_Range;
            pForced->DMA_Header.DD_Flags      = pDmaData->DMA_Data[RangeIndex].DR_Flags;
            pForced->DMA_Header.DD_Alloc_Chan = (ULONG)ulValue;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_DMA,
                                        pForced,
                                        sizeof(DMA_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_IRQ: {

            DEVRES_PIRQ_RESOURCE pIrqData = (DEVRES_PIRQ_RESOURCE)pData;
            DEVRES_PIRQ_RESOURCE pForced = (DEVRES_PIRQ_RESOURCE)MyMalloc(sizeof(DEVRES_IRQ_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->IRQ_Header.IRQD_Count     = 0;
            pForced->IRQ_Header.IRQD_Type      = IRQType_Range;
            pForced->IRQ_Header.IRQD_Flags     = pIrqData->IRQ_Data[RangeIndex].IRQR_Flags;
            pForced->IRQ_Header.IRQD_Alloc_Num = (ULONG)ulValue;
            pForced->IRQ_Header.IRQD_Affinity  = (DEVRES_AFFINITY)(-1);

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_IRQ,
                                        pForced,
                                        sizeof(DEVRES_IRQ_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_BusNumber: {

            PBUSNUMBER_RESOURCE pBusData = (PBUSNUMBER_RESOURCE)pData;
            PBUSNUMBER_RESOURCE pForced = (PBUSNUMBER_RESOURCE)MyMalloc(sizeof(BUSNUMBER_RESOURCE));
            if (!pForced) {
                break;
            }

            pForced->BusNumber_Header.BUSD_Count      = 0;
            pForced->BusNumber_Header.BUSD_Type       = BusNumberType_Range;
            pForced->BusNumber_Header.BUSD_Flags      = pBusData->BusNumber_Data[RangeIndex].BUSR_Flags;
            pForced->BusNumber_Header.BUSD_Alloc_Base = (ULONG)ulValue;
            pForced->BusNumber_Header.BUSD_Alloc_End  = (ULONG)ulEnd;

            Success = CM_Add_Res_Des_Ex(NULL,
                                        ForcedLogConf,
                                        ResType_BusNumber,
                                        pForced,
                                        sizeof(BUSNUMBER_RESOURCE),
                                        DEVRES_WIDTH_FLAGS,
                                        hMachine) == CR_SUCCESS;
            MyFree(pForced);
            break;
        }

        case ResType_DevicePrivate: {
            break;
        }

        case ResType_PcCardConfig: {
            break;
        }
    }

    if (pData) {
        MyFree(pData);
    }
    return Success;

} // WriteValuesToForced

BOOL
MakeResourceData(
    OUT LPBYTE     *ppResourceData,
    OUT PULONG     pulSize,
    IN  RESOURCEID ResType,
    IN  ULONG64    ulValue,
    IN  ULONG64    ulLen,
    IN  ULONG      ulFlags
    )
{
    BOOL bStatus = TRUE;

    try {

        switch (ResType) {

            case ResType_Mem: {

                PMEM_RESOURCE p;

                *pulSize = sizeof(MEM_RESOURCE);
                if (ppResourceData) {
                    *ppResourceData = MyMalloc(*pulSize);
                    p = (PMEM_RESOURCE)(*ppResourceData);
                    if (!p) {
                        bStatus = FALSE;
                        break;
                    }

                    p->MEM_Header.MD_Count      = 0;
                    p->MEM_Header.MD_Type       = MType_Range;
                    p->MEM_Header.MD_Alloc_Base = ulValue;
                    p->MEM_Header.MD_Alloc_End  = ulValue + ulLen - 1;
                    p->MEM_Header.MD_Flags      = ulFlags;
                    p->MEM_Header.MD_Reserved   = 0;
                }
                break;
            }

            case ResType_IO:  {

                PIO_RESOURCE p;

                *pulSize = sizeof(IO_RESOURCE);
                if (ppResourceData) {
                    *ppResourceData = MyMalloc(*pulSize);
                    p = (PIO_RESOURCE)(*ppResourceData);
                    if (!p) {
                        bStatus = FALSE;
                        break;
                    }

                    p->IO_Header.IOD_Count      = 0;
                    p->IO_Header.IOD_Type       = IOType_Range;
                    p->IO_Header.IOD_Alloc_Base = ulValue;
                    p->IO_Header.IOD_Alloc_End  = ulValue + ulLen - 1;
                    p->IO_Header.IOD_DesFlags   = ulFlags;
                }
                break;
            }

            case ResType_DMA: {

                PDMA_RESOURCE p;

                *pulSize = sizeof(DMA_RESOURCE);
                if (ppResourceData) {
                    *ppResourceData = MyMalloc(*pulSize);
                    p = (PDMA_RESOURCE)(*ppResourceData);
                    if (!p) {
                        bStatus = FALSE;
                        break;
                    }

                    p->DMA_Header.DD_Count      = 0;
                    p->DMA_Header.DD_Type       = DType_Range;
                    p->DMA_Header.DD_Flags      = ulFlags;
                    p->DMA_Header.DD_Alloc_Chan = (ULONG)ulValue;
                }
                break;
            }

            case ResType_IRQ: {

                DEVRES_PIRQ_RESOURCE p;

                *pulSize = sizeof(DEVRES_IRQ_RESOURCE);
                if (ppResourceData) {
                    *ppResourceData = MyMalloc(*pulSize);
                    p = (DEVRES_PIRQ_RESOURCE)(*ppResourceData);
                    if (!p) {
                        bStatus = FALSE;
                        break;
                    }

                    p->IRQ_Header.IRQD_Count     = 0;
                    p->IRQ_Header.IRQD_Type      = IRQType_Range;
                    p->IRQ_Header.IRQD_Flags     = ulFlags;
                    p->IRQ_Header.IRQD_Alloc_Num = (ULONG)ulValue;
                    p->IRQ_Header.IRQD_Affinity  = (DEVRES_AFFINITY)(-1); // for any processor
                }
                break;
            }

            default:
                //
                // ResTypeEditable or ResType_MAX may be wrong if this ASSERT's
                //
                MYASSERT(FALSE);
                bStatus = FALSE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bStatus = FALSE;
    }

    return bStatus;

} // MakeResourceData


BOOL
pShowWindow(
    IN HWND hWnd,
    IN int nShow
    )
/*++

Routine Description:

    A variation of ShowWindow that enables/disables window

Arguments:

    (See ShowWindow)
    hWnd  - handle of window to show
    nShow - typically SW_HIDE or SW_SHOW

Return Value:

    success status of ShowWindow

--*/
{
    EnableWindow(hWnd,nShow!=SW_HIDE);
    return ShowWindow(hWnd,nShow);
}


BOOL
pEnableWindow(
    IN HWND hWnd,
    IN BOOL Enable
    )
/*++

Routine Description:

    A variation of EnableWindow that only enables a window if it is visible

Arguments:

    (See EnableWindow)
    hWnd  - handle of window to enable/disable
    Enable - TRUE enables window (if window visible) FALSE disables window

Return Value:

    success status of EnableWindow

--*/
{
    //
    // I had to use GetWindowLong, as IsWindowVisible also checks parent flag
    // and parent is hidden until dialog is initialized
    //
    if((GetWindowLong(hWnd,GWL_STYLE) & WS_VISIBLE) == FALSE) {
        Enable = FALSE;
    }
    return EnableWindow(hWnd,Enable);
}

BOOL
pGetResDesDataList(
    IN LOG_CONF LogConf,
    IN OUT PRESDES_ENTRY *pResList,
    IN BOOL bArbitratedOnly,
    IN HMACHINE hMachine
    )
/*++

Routine Description:

    Creates a list of resource descriptors for further processing

Arguments:

    LogConf  - log config of interest
    pResList - list out
    bArbitratedOnly - filter out non-arbitrated resources
    hMachine - machine that LogConf is on

Return Value:

   None.

--*/
{
    BOOL bStatus = TRUE;
    CONFIGRET Status = CR_SUCCESS;
    PRESDES_ENTRY pHead = NULL, pEntry = NULL, pPrevious = NULL, pTemp = NULL;
    RES_DES     ResDes;
    RESOURCEID  ResType;
    ULONG       ulSize;
    LPBYTE      pData = NULL;

    //
    // Retrieve each res des in this log conf
    //

    Status = CM_Get_Next_Res_Des_Ex(&ResDes, LogConf, ResType_All, &ResType, 0,hMachine);

    while (Status == CR_SUCCESS) {

        if (bArbitratedOnly && (ResType <= ResType_None || ResType > ResType_MAX)) {
            goto NextResDes;
        }
        if (bArbitratedOnly && ResTypeEditable[ResType] == FALSE) {
            goto NextResDes;
        }

        if (CM_Get_Res_Des_Data_Size_Ex(&ulSize, ResDes, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
            CM_Free_Res_Des_Handle(ResDes);
            bStatus = FALSE;
            goto Clean0;
        }

        if (ulSize>0) {
            pData = MyMalloc(ulSize);
            if (pData == NULL) {
                CM_Free_Res_Des_Handle(ResDes);
                bStatus = FALSE;
                goto Clean0;
            }

            if (CM_Get_Res_Des_Data_Ex(ResDes, pData, ulSize, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
                CM_Free_Res_Des_Handle(ResDes);
                MyFree(pData);
                bStatus = FALSE;
                goto Clean0;
            }
        } else {
            pData = NULL;
        }

        //
        // Allocate a node for this res des and attach it to the list
        //

        pEntry = MyMalloc(sizeof(RESDES_ENTRY));
        if (pEntry == NULL) {
            CM_Free_Res_Des_Handle(ResDes);
            MyFree(pData);
            bStatus = FALSE;
            goto Clean0;
        }

        pEntry->ResDesData = pData;
        pEntry->ResDesType = ResType;
        pEntry->ResDesDataSize = ulSize;
        pEntry->ResDesHandle = ResDes;
        pEntry->Next = NULL;
        pEntry->CrossLink = NULL;

        if (!pHead) {
            pHead = pEntry;             // first entry
        }

        if (pPrevious) {
            pPrevious->Next = pEntry; // attach to previous entry
        }

        pPrevious = pEntry;

        //
        // Get next res des in LogConf
        //
    NextResDes:

        Status = CM_Get_Next_Res_Des_Ex(&ResDes, ResDes, ResType_All, &ResType, 0,hMachine);
    }

    bStatus = TRUE;

    Clean0:

    if (!bStatus) {
        pDeleteResDesDataList(pHead);
    } else {
        *pResList = pHead;
    }

    return bStatus;

} // GetResDesDataList

VOID
pDeleteResDesDataList(
    IN PRESDES_ENTRY pResList
    )
/*++

Routine Description:

    Deletes memory used by RESDES list

Arguments:

    pResList - list returned by GetResDesDataList

Return Value:

   None.

--*/
{
    PRESDES_ENTRY pTemp;
    while (pResList) {
        pTemp = pResList;
        pResList = (PRESDES_ENTRY)pResList->Next;
        if (pTemp->ResDesData) {
            MyFree(pTemp->ResDesData);
        }
        if (pTemp->ResDesHandle) {
            CM_Free_Res_Des_Handle(pTemp->ResDesHandle);
        }
        MyFree(pTemp);
    }
}

VOID
pHideAllControls(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Hide (and disable) all controls - start off with a clean slate
    Only Icon & device description will be visible

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSTATE), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_RESOURCES_TEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NOALLOCTEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT ), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MAKEFORCED), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MFPARENT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MFPARENT_DESC), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTDEVTEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTINFOLIST), SW_HIDE);

    lpdmpd->dwFlags |= DMPROP_FLAG_VIEWONLYRES;
}

VOID
pShowViewNoResources(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Show page indicating this device has no resources

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;
    TCHAR           szString[MAX_PATH];

    pHideAllControls(lpdmpd); // all hidden and disabled
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_RESOURCES_TEXT), SW_SHOW);   // show and enable text
    LoadString(MyDllModuleHandle, IDS_DEVRES_NO_RESOURCES, szString, MAX_PATH);
    SetDlgItemText(hDlg, IDC_DEVRES_NO_RESOURCES_TEXT, szString);
}

BOOL
pShowViewMFReadOnly(
    IN LPDMPROP_DATA lpdmpd,
    IN BOOL HideIfProb
    )
/*++

Routine Description:

    Show page apropriate for multifunction card that cannot be edited
    Resource settings are visible

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    TCHAR           szString[MAX_PATH];
    DEVNODE         dnParent;
    ULONG           ulSize;
    HWND hDlg = lpdmpd->hDlg;
    HMACHINE        hMachine = pGetMachine(lpdmpd);

    pHideAllControls(lpdmpd); // all hidden and disabled
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_SHOW);   // show config information
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_SHOW); // show
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTDEVTEXT), SW_SHOW); // show conflict information space
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTINFOLIST), SW_SHOW);
    //
    // indicate we cannot change as it's multi-function
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT), SW_SHOW);
    if (LoadString(MyDllModuleHandle, IDS_DEVRES_NO_CHANGE_MF, szString, MAX_PATH)) {
        SetDlgItemText(hDlg, IDC_DEVRES_NO_CHANGE_TEXT,  szString);
    }
    //
    // for parent description
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MFPARENT), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MFPARENT_DESC), SW_SHOW);
    //
    // Get the Parent's Description.
    //
    LoadString(MyDllModuleHandle, IDS_DEVNAME_UNK, szString, MAX_PATH);

    if (lpdmpd->lpdi->DevInst) {

        if (CM_Get_Parent_Ex(&dnParent, lpdmpd->lpdi->DevInst, 0,hMachine)
                          == CR_SUCCESS) {


            //
            // First, try to retrieve friendly name, then fall back to device description.
            //
            ulSize = MAX_PATH * sizeof(TCHAR);
            if(CM_Get_DevNode_Registry_Property_Ex(dnParent, CM_DRP_FRIENDLYNAME,
                                                NULL, szString, &ulSize, 0,hMachine) != CR_SUCCESS) {

                ulSize = MAX_PATH * sizeof(TCHAR);
                CM_Get_DevNode_Registry_Property_Ex(dnParent, CM_DRP_DEVICEDESC,
                                                 NULL, szString, &ulSize, 0,hMachine);
            }
        }
    }

    SetDlgItemText(hDlg, IDC_DEVRES_MFPARENT_DESC, szString);

    //
    // load and display current config (if any)
    // return FALSE if no current config
    //
    return pLoadCurrentConfig(lpdmpd,HideIfProb);
}

BOOL
pShowViewReadOnly(
    IN LPDMPROP_DATA lpdmpd,
    IN BOOL HideIfProb
    )
/*++

Routine Description:

    Show page of resources, don't allow editing, don't show editing controls

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    pHideAllControls(lpdmpd); // all hidden and disabled
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_SHOW);   // show
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_SHOW); // shown disabled
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), SW_SHOW); // shown disabled
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), SW_SHOW); // shown disabled
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), FALSE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTDEVTEXT), SW_SHOW); // show conflict information space
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTINFOLIST), SW_SHOW);

    //
    // will indicate if we're showing system settings or forced settings
    //
    CheckDlgButton(hDlg, IDC_DEVRES_USESYSSETTINGS, (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS ) ? TRUE : FALSE);

    //
    // load and display current config (if any)
    // return FALSE if no current config
    //
    return pLoadCurrentConfig(lpdmpd,HideIfProb);
}

VOID
pShowViewNoAlloc(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Modify the middle part of the control to indicate there is a problem (and there isn't much we can do about it)

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    //
    // hide all middle controls
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_HIDE);
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT ), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), SW_HIDE);
    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MAKEFORCED), SW_HIDE);
    lpdmpd->dwFlags |= DMPROP_FLAG_VIEWONLYRES;

    //pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT), SW_SHOW);  // this may say why
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MAKEFORCED), SW_HIDE);

    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTDEVTEXT), SW_HIDE); // no alloc, so hide this header & textbox
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTINFOLIST), SW_HIDE);
}

VOID
pShowViewNeedForced(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Modify the middle part of the control to indicate a forced config is required

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    pShowViewNoAlloc(lpdmpd);
    //
    // show what we need for make forced config
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT), SW_SHOW);  // this may say why
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MAKEFORCED), SW_SHOW);
}

VOID
pShowViewAllEdit(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Allow editing

Arguments:

    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    //
    // show middle controls for editing
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_CHANGE_TEXT ), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), SW_SHOW);
    ShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), SW_SHOW); // shown, but disabled
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), FALSE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_MAKEFORCED), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTDEVTEXT), SW_SHOW); // show conflict information space
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CONFLICTINFOLIST), SW_SHOW);

    pShowUpdateEdit(lpdmpd);
}

VOID
pShowUpdateEdit(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Allow editing

Arguments:

    lpdmpd = property data

Return Value:

    none

--*/
{
    HWND hDlg = lpdmpd->hDlg;

    //
    // modify editing status - we can edit
    //
    lpdmpd->dwFlags &= ~DMPROP_FLAG_VIEWONLYRES;

    if(lpdmpd->dwFlags & DMPROP_FLAG_FORCEDONLY) {
        //
        // in this case, we will never be able to use system settings
        //
        lpdmpd->dwFlags &= ~ DMPROP_FLAG_USESYSSETTINGS;
        EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), FALSE);
    }
    //
    // indicate if it's system settings or not
    //
    CheckDlgButton(hDlg, IDC_DEVRES_USESYSSETTINGS,
                    (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)?TRUE:FALSE);
    //
    // we can change logconfiglist if it's not system settings
    //
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)?FALSE:TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)?FALSE:TRUE);
    //
    // change "Change Settings" button
    //
    pCheckEnableResourceChange(lpdmpd);
}

BOOL
pLoadCurrentConfig(
    IN LPDMPROP_DATA lpdmpd,
    BOOL HideIfProb
    )
/*++

Routine Description:

    Modify the top part, to show current configuration, if any

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data

Return Value:

    TRUE if we're showing current config

--*/
{
    TCHAR    szMessage[MAX_PATH];
    ULONG    Problem;
    ULONG    Status;
    HWND hDlg = lpdmpd->hDlg;
    HMACHINE hMachine = pGetMachine(lpdmpd);
    BOOL     DoLoadConfig = FALSE;

    lpdmpd->SelectedLC = 0;
    lpdmpd->SelectedLCType = lpdmpd->CurrentLCType;

    if (lpdmpd->CurrentLC != 0) {
        DoLoadConfig = TRUE;
    }
    if(HideIfProb && (lpdmpd->dwFlags & DMPROP_FLAG_HASPROBLEM)) {
        //
        // if there's a problem and HideIfProb is TRUE, don't bother showing current config
        //
        DoLoadConfig = FALSE;
    }
    if (DoLoadConfig) {
        //
        // load in current configuration
        //
        pLoadConfig(lpdmpd,lpdmpd->CurrentLC,lpdmpd->CurrentLCType);
        return TRUE;
    }
    //
    // case where there is no suitable configuration
    //
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_RESOURCES_TEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LCTEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_LOGCONFIGLIST), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_USESYSSETTINGS), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_CHANGE), SW_HIDE);
    pShowViewNoAlloc(lpdmpd);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSTATE), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NOALLOCTEXT), SW_SHOW);

    //
    // explain why there is a problem
    // goes into NOALLOCTEXT
    //
    LoadString(MyDllModuleHandle, IDS_DEVRES_NOALLOC_PROBLEM, szMessage, MAX_PATH);

    //
    // consider being more descriptive
    //
    if ((lpdmpd->lpdi->DevInst==0)
        || (CM_Get_DevNode_Status_Ex(&Status, &Problem, lpdmpd->lpdi->DevInst,
                                      0,hMachine) != CR_SUCCESS)) {
        Status = 0;
        Problem = 0;
    }

    if ((Status & DN_HAS_PROBLEM)!=0) {

        switch (Problem) {
            case CM_PROB_DISABLED:
            case CM_PROB_HARDWARE_DISABLED:
                LoadString(MyDllModuleHandle, IDS_DEVRES_NOALLOC_DISABLED, szMessage, MAX_PATH);
                break;

            case CM_PROB_NORMAL_CONFLICT:
                LoadString(MyDllModuleHandle, IDS_DEVRES_NORMAL_CONFLICT, szMessage, MAX_PATH);
                break;
            default:
                break;
        }
    }
    SetDlgItemText(hDlg, IDC_DEVRES_NOALLOCTEXT, szMessage);

    return FALSE; // display in NoAlloc state
}

BOOL
pConfigHasNoAlternates(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF testLC
    )
/*++

Routine Description:

    A Basic config could be restrictive "these are the set of resources to use"
    This determines if the basic config passed is such a config

Arguments:

    testLC = basic config to test

Return Value:

    TRUE if it's a singular config

--*/
{
    HMACHINE      hMachine = NULL;
    PRESDES_ENTRY pConfigValues = NULL;
    PRESDES_ENTRY pValue = NULL;
    BOOL          bSuccess = TRUE;
    ULONG64       ulValue = 0, ulLen = 0, ulEnd = 0;
    ULONG         ulFlags = 0;
    PGENERIC_RESOURCE pGenRes = NULL;

    hMachine = pGetMachine(lpdmpd);
    pGetResDesDataList(testLC, &pConfigValues, TRUE, hMachine); // arbitratable resources
    for(pValue = pConfigValues;pValue;pValue = pValue->Next) {
        //
        // is this a singular value?
        //
        pGenRes = (PGENERIC_RESOURCE)(pValue->ResDesData);
        if(pGenRes->GENERIC_Header.GENERIC_Count != 1) {
            //
            // more than one entry - not singular
            //
            bSuccess = FALSE;
            break;
        }
        pGetRangeValues(pValue->ResDesData, pValue->ResDesType, 0, &ulValue, &ulLen, &ulEnd, NULL, &ulFlags);
        if (ulValue+(ulLen-1) != ulEnd) {
            //
            // not singular
            //
            bSuccess = FALSE;
            break;
        }
    }
    pDeleteResDesDataList(pConfigValues);

    return bSuccess;
}

BOOL
pLoadConfig(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF forceLC,
    ULONG forceLCType
    )
/*++

Routine Description:

    Display a configuration

Arguments:

    hDlg = dialog handle of controls
    lpdmpd = property data
    forceLC = LogConf to display
    forceLCType = type for LogConf

Return Value:

    TRUE if config loaded

--*/
{
    HWND hDlg = lpdmpd->hDlg;
    CONFIGRET   Status = CR_SUCCESS;
    HWND        hWndList;
    LV_ITEM     lviItem;
    TCHAR       szTemp[MAX_PATH];
    int         iNewItem = 0;
    ULONG       ulSize,ulFlags;
    ULONG64     ulValue, ulLen, ulEnd, ulAlign;
    ULONG64     ulMaxMem = 0;
    ULONG       ulRange;
    LPBYTE      pData = NULL;
    RES_DES     ResDes;
    RESOURCEID  ResType;
    PITEMDATA   pItemData = NULL;
    HMACHINE    hMachine = NULL;
    PDEVICE_INFO_SET pDeviceInfoSet;
    BOOL        RetCode = FALSE;
    PRESDES_ENTRY pKnownValues = NULL;
    PRESDES_ENTRY pShowValues = NULL;
    PRESDES_ENTRY pShowEntry = NULL;
    BOOL        bFixedConfig = FALSE;
    BOOL        bNoMatch;
    BOOL        bFixed;
    ULONG       MatchLevel = NO_LC_MATCH;


    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSTATE), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NO_RESOURCES_TEXT), SW_HIDE);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST), SW_SHOW);
    pShowWindow(GetDlgItem(hDlg, IDC_DEVRES_NOALLOCTEXT), SW_HIDE);

    hWndList = GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    SendMessage(hWndList, WM_SETREDRAW, (WPARAM)FALSE, 0);
    ListView_DeleteAllItems(hWndList);

    lpdmpd->dwFlags |= DMPROP_FLAG_FIXEDCONFIG; // until we determine there is at least one setting we can edit


    if (forceLC == 0) {
        forceLC = lpdmpd->CurrentLC;
        forceLCType = lpdmpd->CurrentLCType;
    }
    if (forceLC == 0) {
        MYASSERT(FALSE);
        goto Final;
    }
    hMachine = pGetMachine(lpdmpd);

    //
    // setup values that will remain the same each time I add an item
    //
    lviItem.mask     = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lviItem.pszText  = szTemp;          // reuse the szTemp buffer
    lviItem.iSubItem = 0;
    lviItem.iImage   = IDI_RESOURCE - IDI_RESOURCEFIRST;

    pGetResDesDataList(forceLC, &pShowValues, TRUE, hMachine); // editable resources
    if (forceLCType == BOOT_LOG_CONF || forceLCType == FORCED_LOG_CONF || forceLCType == ALLOC_LOG_CONF) {
        bFixedConfig = TRUE;
        if (forceLC == lpdmpd->CurrentLC && lpdmpd->MatchingLC != 0) {
            //
            // we're displaying CurrentLC, use flags & resdes's from matching LC where possible
            //
            if (pGetResDesDataList(lpdmpd->MatchingLC, &pKnownValues, TRUE, hMachine)) {
                //
                // match-up currentLC with some matching LC, so we can use flags/ranges from matching LC
                //
                MatchLevel = pMergeResDesDataLists(pShowValues,pKnownValues,NULL);
            }
        }
    } else if (lpdmpd->CurrentLC != 0) {
        //
        // the config we're displaying may allow ranges of values
        // we're going to try and match up what we are displaying to current config
        //
        if (pGetResDesDataList(lpdmpd->CurrentLC, &pKnownValues, TRUE, hMachine)) {
            //
            // try and use current values where possible
            //
            MatchLevel = pMergeResDesDataLists(pKnownValues,pShowValues,NULL);
        }
    }

    pShowEntry = pShowValues;

    while (pShowEntry) {
        bNoMatch = FALSE;
        bFixed = FALSE;
        ResDes = (RES_DES)0;
        ResType = pShowEntry->ResDesType;
        ulRange = 0;

        if (bFixedConfig) {
            //
            // we've got a current config
            //
            pGetHdrValues(pShowEntry->ResDesData, pShowEntry->ResDesType, &ulValue, &ulLen, &ulEnd, &ulFlags);
            if((ResType ==ResType_Mem) && (ulEnd > ulMaxMem)) {
                //
                // base our memory display on the fixed-config only
                //
                ulMaxMem = ulEnd;
            }
            if (pShowEntry->CrossLink) {
                //
                // use range's res-des
                //
                ResDes = pShowEntry->CrossLink->ResDesHandle;
                pShowEntry->CrossLink->ResDesHandle = (RES_DES)0;
                //
                // allow adjustment based on nearest basic config
                //
                pGetMatchingRange(ulValue,ulLen,pShowEntry->CrossLink->ResDesData, pShowEntry->CrossLink->ResDesType,&ulRange,&bFixed,NULL);
            } else {
                //
                // no range res-des
                //
                ResDes = (RES_DES)0;
                //
                // indicate that this is a non-adjustable value
                //
                bFixed = TRUE;
            }
        } else {
            //
            // we've got resource-ranges
            //
            if (pShowEntry->CrossLink) {
                //
                // take current settings from what we merged in
                //
                pGetHdrValues(pShowEntry->CrossLink->ResDesData, pShowEntry->CrossLink->ResDesType, &ulValue, &ulLen, &ulEnd, &ulFlags);
            } else {
                //
                // just take first range
                //
                pGetRangeValues(pShowEntry->ResDesData, pShowEntry->ResDesType, 0, &ulValue, &ulLen, &ulEnd, &ulAlign, &ulFlags);
            }
            //
            // range check if this is a memory resource - find highest memory value
            //
            if(ResType ==ResType_Mem) {
                ULONG64 HighVal;
                ULONG64 HighLen;
                if(LocateClosestValue(pShowEntry->ResDesData, pShowEntry->ResDesType,(ULONG64)(-1),ulLen, 0 ,&HighVal,&HighLen,NULL)) {
                    HighVal += HighLen-1;
                    if(HighVal > ulMaxMem) {
                        ulMaxMem = ulEnd;
                    }
                }
            }

            pGetMatchingRange(ulValue,ulLen,pShowEntry->ResDesData, pShowEntry->ResDesType,&ulRange,&bFixed,&ulFlags);
            //
            // use res-des from range
            //
            ResDes = pShowEntry->ResDesHandle;
            pShowEntry->ResDesHandle = (RES_DES)0;

            if (pShowEntry->CrossLink == NULL && bFixed == FALSE) {
                //
                // unknown value
                //
                bNoMatch = TRUE;
            }
        }

        if (ulLen>0) {
            //
            // Write first column text field (uses szTemp, lParam is res type)
            //
            LoadString(MyDllModuleHandle, IDS_RESOURCE_BASE + ResType, szTemp, MAX_PATH);
            ulRange = 0;

            pItemData = (PITEMDATA)MyMalloc(sizeof(ITEMDATA));
            if (pItemData != NULL) {
                pItemData->ResType = ResType;
                pItemData->MatchingResDes = ResDes;
                pItemData->RangeCount = ulRange;
                pItemData->ulValue = ulValue;                   // selected value
                pItemData->ulLen = ulLen;
                pItemData->ulEnd = ulValue + ulLen - 1;
                pItemData->ulFlags = ulFlags;
                pItemData->bValid = !bNoMatch;                  // if no chosen value
                pItemData->bFixed = bFixed;
            }
            if (bFixed == FALSE) {
                //
                // we have at least one editable value
                //
                lpdmpd->dwFlags &= ~DMPROP_FLAG_FIXEDCONFIG;
            }

            lviItem.iItem = iNewItem;
            lviItem.lParam = (LPARAM)pItemData;
            ListView_InsertItem(hWndList, &lviItem);

            //
            // Write second column text field (uses szTemp, lParam is res handle)
            //
            if (bNoMatch) {
                pFormatResString(lpdmpd,szTemp, 0, 0, ResType);
            } else {
                pFormatResString(lpdmpd,szTemp, ulValue, ulLen, ResType);
            }
            ListView_SetItemText(hWndList, iNewItem, 1, szTemp);

            ++iNewItem;
        }
        pShowEntry = pShowEntry->Next;
    }

    if(ulMaxMem > 0xFFFFFFFF) {
        //
        // an excuse to require 64-bit address range
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_64BIT_RANGE;
    }

    SendMessage(hWndList, WM_SETREDRAW, (WPARAM)TRUE, 0);

    RetCode = TRUE;

Final:

    pDeleteResDesDataList(pKnownValues);
    pDeleteResDesDataList(pShowValues);

    //
    // initialize listview headings here
    //
    ListView_SetColumnWidth(hWndList, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hWndList, 1, LVSCW_AUTOSIZE_USEHEADER);
    //
    // change "Change Settings" button
    //
    pCheckEnableResourceChange(lpdmpd);

    return RetCode;
}

BOOL
bIsMultiFunctionChild(
    PSP_DEVINFO_DATA lpdi,
    HMACHINE         hMachine
    )
/*++

Routine Description:

    Returns flag indicating if this is a child of a
    multifunction device
Arguments:

Return Value:

    TRUE if MF child

--*/
{
    ULONG   Status;
    ULONG   ProblemNumber;

    if (lpdi->DevInst) {

        if (CM_Get_DevNode_Status_Ex(&Status, &ProblemNumber,
                                  lpdi->DevInst, 0,hMachine) == CR_SUCCESS) {
            //
            // If the passed in dev is not an MF child, then it is the top
            // level MF_Parent
            //
            if (Status & DN_MF_CHILD) {
                return TRUE;
            } else {
                return FALSE;
            }
        }
    }

    return FALSE;

}

VOID
pSelectLogConf(
    LPDMPROP_DATA lpdmpd,
    LOG_CONF forceLC,
    ULONG forceLCType,
    BOOL Always
)
/*++

Routine Description:

    Selects a LogConf, showing the config in the LC control

Arguments:

Return Value:

    TRUE if MF child

--*/
{
    HWND hDlg = lpdmpd->hDlg;
    int count;
    int i;
    LOG_CONF LogConf;

    if (Always == FALSE && forceLC == lpdmpd->SelectedLC) {
        //
        // selection remains the same
        //
        return;
    }

    count = (int)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,CB_GETCOUNT, (WPARAM)0, (LPARAM)0);
    if (count == 0) {
        MYASSERT(FALSE/*shouldn't get here*/);
        pLoadCurrentConfig(lpdmpd,FALSE);
        return;
    }

    if (forceLC == 0 && lpdmpd->CurrentLC == 0) {
        //
        // no currentLC, so select first default
        //
        forceLC = (LOG_CONF)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                               CB_GETITEMDATA, (WPARAM)0, (LPARAM)0);
        if (forceLC == (LOG_CONF)0) {
            MYASSERT(FALSE/*shouldn't get here*/);
            pLoadCurrentConfig(lpdmpd,FALSE);
            return;
        }
        forceLCType = lpdmpd->ConfigListLCType;
    }

    for (i=0;i<count;i++) {
        LogConf = (LOG_CONF)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                               CB_GETITEMDATA, (WPARAM)i, (LPARAM)0);
        if (LogConf == forceLC) {
            //
            // set these first so we don't recurse around
            //
            lpdmpd->SelectedLC = forceLC;
            lpdmpd->SelectedLCType = forceLCType;
            //
            // change dialog to reflect new selection
            //
            SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,CB_SETCURSEL, (WPARAM)i, (LPARAM)0);
            pLoadConfig(lpdmpd,forceLC,forceLCType);
            pShowConflicts(lpdmpd);
            return;
        }
    }
    SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,CB_SETCURSEL, (WPARAM)(-1), (LPARAM)0);
    pLoadConfig(lpdmpd,forceLC,forceLCType);
    pShowConflicts(lpdmpd);
}


VOID
pChangeCurrentResSetting(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Brings up edit dialog to change currently selected resource

Arguments:

Return Value:

    none

--*/
{
    HWND                hDlg = lpdmpd->hDlg;
    RESOURCEEDITINFO    rei;
    HWND                hList =  GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    int                 iCur;
    PITEMDATA           pItemData = NULL;
    LV_ITEM             lviItem;
    GENERIC_RESOURCE    GenResInfo;
    PDEVICE_INFO_SET    pDeviceInfoSet;
    BOOL                changed = FALSE;
    TCHAR               szTemp[MAX_PATH];

    pItemData = pGetResourceToChange(lpdmpd,&iCur);
    if (pItemData == NULL) {
        //
        // we cannot edit this resource for some reason, give the user a hint
        // and maybe I'll get less ear-ache "I cannot change the settings"
        //
        if ((lpdmpd->dwFlags & DMPROP_FLAG_VIEWONLYRES)!=0 ||
                (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS)!=0) {
            //
            // editing not allowed - prob double-clicked on settings
            //
            return;
        }
        if (lpdmpd->dwFlags & DMPROP_FLAG_FIXEDCONFIG) {
            pWarnResSettingNotEditable(hDlg, IDS_DEVRES_NOMODIFYALL);
        } else {
            //
            // see if user needs to select a resource
            //
            iCur = (int)ListView_GetNextItem(hList,-1, LVNI_SELECTED);
            if (iCur == LB_ERR) {
                //
                // no selection
                //
                pWarnResSettingNotEditable(hDlg, IDS_DEVRES_NOMODIFYSELECT);
            } else {
                //
                // resource is just not editable
                //
                pWarnResSettingNotEditable(hDlg, IDS_DEVRES_NOMODIFYSINGLE);
            }
        }
        goto clean0;
    }

    ZeroMemory(&rei,sizeof(rei));
    rei.hMachine = pGetMachine(lpdmpd);
    rei.KnownLC = lpdmpd->CurrentLC;
    rei.MatchingBasicLC = lpdmpd->MatchingLC;
    rei.SelectedBasicLC = lpdmpd->SelectedLC;
    rei.lpdi = lpdmpd->lpdi;
    rei.dwPropFlags = lpdmpd->dwFlags;
    rei.bShareable = FALSE;
    rei.ridResType = pItemData->ResType;
    rei.ResDes = pItemData->MatchingResDes;
    rei.ulCurrentVal = pItemData->ulValue;
    rei.ulCurrentLen = pItemData->ulLen;
    rei.ulCurrentEnd = pItemData->ulEnd;
    rei.ulCurrentFlags = pItemData->ulFlags;
    rei.ulRangeCount = pItemData->RangeCount;
    rei.pData = NULL;

    if (DialogBoxParam(MyDllModuleHandle,
                       MAKEINTRESOURCE(IDD_EDIT_RESOURCE),
                       hDlg,
                       EditResourceDlgProc,
                       (LPARAM)(PRESOURCEEDITINFO)&rei) != IDOK) {
        goto clean0;
    }
    //
    // Update The Current Resource settings to Future
    // Settings, and update the Conflict list.
    //
    pItemData->ulValue = rei.ulCurrentVal;
    pItemData->ulLen = rei.ulCurrentLen;
    pItemData->ulEnd = rei.ulCurrentEnd;
    pItemData->ulFlags = rei.ulCurrentFlags;
    pItemData->RangeCount = rei.ulRangeCount;
    pItemData->bValid = TRUE; // indicate that user has explicitly changed this value

    pFormatResString(lpdmpd,szTemp,
                    rei.ulCurrentVal,
                    rei.ulCurrentLen,
                    rei.ridResType);

    ListView_SetItemText(hList, iCur, 1, szTemp);
    pShowConflicts(lpdmpd);

    //
    // clear the flag for saving changes
    //
    lpdmpd->dwFlags &= ~DMPROP_FLAG_CHANGESSAVED;
    PropSheet_Changed(GetParent(hDlg), hDlg);

clean0:
    ;
}

VOID
pShowConflicts(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Selects a LogConf, showing the config in the LC control

Arguments:

Return Value:

    TRUE if MF child

--*/
{
    HWND        hDlg = lpdmpd->hDlg;
    CONFIGRET   Status = CR_SUCCESS;
    LPVOID      vaArray[4];
    TCHAR       szTemp[MAX_PATH+4], szBuffer[MAX_PATH+16], szSetting[MAX_PATH];
    TCHAR       szFormat[MAX_PATH], szItemFormat[MAX_PATH];
    TCHAR       szUnavailable[MAX_PATH];
    LPTSTR      pszConflictList = NULL, pszConflictList2 = NULL;
    ULONG       ulSize = 0, ulLength, ulBufferLen, ulNewLength;
    ULONG       ulStartOffset = 0;
    int         Count = 0, i = 0;
    PITEMDATA   pItemData = NULL;
    LPBYTE      pResourceData = NULL;
    HWND        hwndResList = GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    HMACHINE    hMachine;
    ULONG       ConflictCount = 0;
    ULONG       ConflictIndex = 0;
    CONFLICT_LIST ConflictList = 0;
    PDEVICE_INFO_SET pDeviceInfoSet;
    CONFLICT_DETAILS ConflictDetails;
    BOOL        ReservedResource = FALSE;
    BOOL        AnyReportedResources = FALSE;
    BOOL        AnyBadResources = FALSE;
    PCONFLICT_EXCEPTIONS pConflictExceptions = NULL;
    //
    // number of resources listed
    //
    Count = ListView_GetItemCount(hwndResList);
    if (Count <= 0) {
       goto Clean0;
    }

    //
    // initial buffer that holds the strings
    // with all the conflict info in them
    //
    ulBufferLen = 2048;
    ulLength = 0;

    pszConflictList = MyMalloc(ulBufferLen * sizeof(TCHAR));
    if (pszConflictList == NULL) {
        goto Clean0;
    }
    pszConflictList[0] = 0;

    //
    // obtain machine
    //
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdmpd->hDevInfo))) {
        goto Clean0;
    }
    hMachine = pDeviceInfoSet->hMachine;
    UnlockDeviceInfoSet (pDeviceInfoSet);

    //
    // do these once - these format strings use %1!s! type formats (FormatMessage)
    //
    LoadString(MyDllModuleHandle, IDS_CONFLICT_FMT, szFormat, MAX_PATH);
    LoadString(MyDllModuleHandle, IDS_CONFLICT_UNAVAILABLE, szUnavailable, MAX_PATH);

    //
    // for every listed resource
    //

    for (i = 0; i < Count; i++) {

        ConflictList = 0;
        ConflictCount = 0;

        //
        // get the resource we're about to test
        //
        pItemData = (PITEMDATA)pGetListViewItemData(hwndResList, i, 0);
        if (pItemData == NULL || pItemData->bValid == FALSE) {
            //
            // for whatever reason, we don't want to show conflict information on this resource
            //
            ListView_SetItemState(hwndResList, i,
                                  INDEXTOOVERLAYMASK(0),
                                  LVIS_OVERLAYMASK);
            goto NextResource;
        }

        //
        // this is set to indicate conflict not reported, but is reserved
        //
        ReservedResource = FALSE;

        //
        // need resource-data for determining conflict
        //
        if (MakeResourceData(&pResourceData, &ulSize,
                             pItemData->ResType,
                             pItemData->ulValue,
                             pItemData->ulLen,
                             pItemData->ulFlags)) {

            Status = CM_Query_Resource_Conflict_List(&ConflictList,
                                                        lpdmpd->lpdi->DevInst,
                                                        pItemData->ResType,
                                                        pResourceData,
                                                        ulSize,
                                                        DEVRES_WIDTH_FLAGS,
                                                        hMachine);

            if (Status != CR_SUCCESS) {
                //
                // on the unlikely event of an error, remember an error occurred
                //
                ConflictList = 0;
                ConflictCount =  0;
                AnyBadResources = TRUE;
            } else {
                //
                // find out how many things conflicted
                //
                Status = CM_Get_Resource_Conflict_Count(ConflictList,&ConflictCount);
                if (Status != CR_SUCCESS) {
                    MYASSERT(Status == CR_SUCCESS);
                    ConflictCount =  0;
                    AnyBadResources = TRUE;
                }
            }
            if(ConflictCount && (lpdmpd->dwFlags & DMPROP_FLAG_SINGLE_CONFIG) && !(lpdmpd->dwFlags & DMPROP_FLAG_HASPROBLEM)) {
                //
                // NTRAID#166214-2000/08/19-JamieHun Conflict Supression Hack
                //
                // rules are
                //   (1) device doesn't have a problem
                //   (2) device can only have one configuration (ie, there's no basic config, or the basic config is singular)
                //   (3) it has a ResourcePickerExceptions string, and that string indicates that the exception is allowed for the specific conflict

                if(pConflictExceptions==NULL) {
                    pConflictExceptions = pLoadConflictExceptions(lpdmpd);
                }

                if (pConflictExceptions) {

                    BOOL muted = TRUE;
                    //
                    // count from 0 (first conflict) through to ConflictCount (excl)
                    //
                    for(ConflictIndex = 0; ConflictIndex < ConflictCount; ConflictIndex ++) {
                        //
                        // obtain details for this conflict
                        //
                        ZeroMemory(&ConflictDetails,sizeof(ConflictDetails));
                        ConflictDetails.CD_ulSize = sizeof(ConflictDetails);
                        ConflictDetails.CD_ulMask = CM_CDMASK_DEVINST | CM_CDMASK_DESCRIPTION | CM_CDMASK_FLAGS;
                        Status = CM_Get_Resource_Conflict_Details(ConflictList,ConflictIndex,&ConflictDetails);
                        if (Status == CR_SUCCESS) {
                            if (!pIsConflictException(lpdmpd,pConflictExceptions,ConflictDetails.CD_dnDevInst,ConflictDetails.CD_szDescription,pItemData->ResType,pItemData->ulValue,pItemData->ulLen)) {
                                muted = FALSE;
                                break;
                            }
                        }
                    }
                    if(muted) {
                        ConflictCount = 0;
                    }
                }
            }
            if (ConflictCount || ReservedResource) {
                ulStartOffset = ulLength;  // record start in case we decide to backtrack
                AnyReportedResources = TRUE; // say we reported at least one problem

            TreatAsReserved:

                ulLength = ulStartOffset;
                pszConflictList[ulLength] = 0;
                //
                // we're going to mark the resource as a problem
                //

                ListView_GetItemText(hwndResList, i, 1, szSetting, MAX_PATH);


                switch (pItemData->ResType) {
                    case ResType_Mem:
                        LoadString(MyDllModuleHandle, IDS_MEMORY_FULL, szBuffer, MAX_PATH);
                        break;
                    case ResType_IO:
                        LoadString(MyDllModuleHandle, IDS_IO_FULL, szBuffer, MAX_PATH);
                        break;
                    case ResType_DMA:
                        LoadString(MyDllModuleHandle, IDS_DMA_FULL, szBuffer, MAX_PATH);
                        break;
                    case ResType_IRQ:
                        LoadString(MyDllModuleHandle, IDS_IRQ_FULL, szBuffer, MAX_PATH);
                        break;
                    default:
                        MYASSERT(FALSE);
                }

                if ( ReservedResource == FALSE) {

                    //
                    // count from 0 (header) 1 (first conflict) through to ConflictCount
                    //
                    for(ConflictIndex = 0; ConflictIndex <= ConflictCount; ConflictIndex ++) {
                        if (ConflictIndex == 0) {
                            //
                            // first pass through, do header message
                            //
                            vaArray[0] = szBuffer;
                            vaArray[1] = szSetting;
                            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY ,
                                                szFormat,
                                                0,0,
                                                szTemp,MAX_PATH,
                                                (va_list*)vaArray); // FORMAT_MESSAGE_ARGUMENT_ARRAY

                        } else {

                            //
                            // obtain details for this conflict
                            //
                            ZeroMemory(&ConflictDetails,sizeof(ConflictDetails));
                            ConflictDetails.CD_ulSize = sizeof(ConflictDetails);
                            ConflictDetails.CD_ulMask = CM_CDMASK_DEVINST | CM_CDMASK_DESCRIPTION | CM_CDMASK_FLAGS;

                            Status = CM_Get_Resource_Conflict_Details(ConflictList,ConflictIndex-1,&ConflictDetails);
                            if (Status == CR_SUCCESS) {
                                if ((ConflictDetails.CD_ulFlags & CM_CDFLAGS_RESERVED) != 0) {
                                    //
                                    // treat as reserved - backtrack
                                    //
                                    ReservedResource = TRUE;
                                    goto TreatAsReserved;
                                } else {
                                    if (ConflictDetails.CD_szDescription[0] == 0) {
                                        //
                                        // treat as reserved - backtrack
                                        //
                                        ReservedResource = TRUE;
                                        goto TreatAsReserved;
                                    }
                                    wsprintf(szBuffer,TEXT("  %s\r\n"),ConflictDetails.CD_szDescription);
                                }
                            } else {
                                //
                                // treat as reserved
                                //
                                ReservedResource = TRUE;
                                goto TreatAsReserved;
                            }
                            lstrcpyn(szTemp,szBuffer,MAX_PATH);
                        }

                        ulNewLength = ulLength + lstrlen(szTemp);   // excluding terminating NUL

                        if ((ulNewLength+1) < ulBufferLen) {
                            //
                            // need to allocate more space - we'll double it and add some more every time
                            //
                            pszConflictList2 = MyRealloc(pszConflictList,(ulBufferLen+ulNewLength+1)  * sizeof(TCHAR));
                            if (pszConflictList2 != NULL) {
                                //
                                // succeeded in resizing buffer
                                //
                                pszConflictList = pszConflictList2;
                                ulBufferLen = ulBufferLen+ulNewLength+1;
                            }
                        }
                        if ((ulNewLength+1) < ulBufferLen) {
                            lstrcpy(pszConflictList + ulLength , szTemp);
                            ulLength = ulNewLength;
                        }

                    }
                } else {
                    //
                    // there is some other problem with resource
                    //

                    vaArray[0] = szBuffer;
                    vaArray[1] = szSetting;
                    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY ,
                                        szUnavailable,
                                        0,0,
                                        szTemp,MAX_PATH,
                                        (va_list*)vaArray); // FORMAT_MESSAGE_ARGUMENT_ARRAY

                    ulNewLength = ulLength + lstrlen(szTemp);   // excluding terminating NUL

                    if ((ulNewLength+1) < ulBufferLen) {
                        //
                        // need to allocate more space - we'll double it and add some more every time
                        //
                        pszConflictList2 = MyRealloc(pszConflictList,(ulBufferLen+ulNewLength+1)  * sizeof(TCHAR));
                        if (pszConflictList2 != NULL) {
                            //
                            // succeeded in resizing buffer
                            //
                            pszConflictList = pszConflictList2;
                            ulBufferLen = ulBufferLen+ulNewLength+1;
                        }
                    }
                    if ((ulNewLength+1) < ulBufferLen) {
                        lstrcpy(pszConflictList + ulLength , szTemp);
                        ulLength = ulNewLength;
                    }
                }

                //
                // Set the Conflict Overlay for this resource.
                //
                ListView_SetItemState(hwndResList, i,
                               INDEXTOOVERLAYMASK(IDI_CONFLICT - IDI_RESOURCEOVERLAYFIRST + 1),
                               LVIS_OVERLAYMASK);

            } else {
                //
                // resource is (aparently) working fine
                //
                ListView_SetItemState(hwndResList, i,
                                      INDEXTOOVERLAYMASK(0),
                                      LVIS_OVERLAYMASK);
            }

            if (ConflictList) {
                CM_Free_Resource_Conflict_Handle(ConflictList);
            }

            if (pResourceData != NULL) {
                MyFree(pResourceData);
            }
        } else {
            //
            // couldn't make the resource descriptor
            AnyBadResources = TRUE;
        }

        NextResource:
            ;
    }


Clean0:
    ;

    //
    // If there were any conflicts, put the list in the multiline edit box.
    //
    if (AnyReportedResources) {
        SetDlgItemText(hDlg, IDC_DEVRES_CONFLICTINFOLIST, pszConflictList);
    } else if (AnyBadResources) {
        //
        // this would most likely occur on
        // (1) running this on 95/98 (shouldn't happen)
        // (2) using new setupapi on old cfgmgr32
        //
        LoadString(MyDllModuleHandle, IDS_CONFLICT_GENERALERROR, szBuffer, MAX_PATH);
        SetDlgItemText(hDlg, IDC_DEVRES_CONFLICTINFOLIST, szBuffer);
    } else {
        LoadString(MyDllModuleHandle, IDS_DEVRES_NOCONFLICTDEVS, szBuffer, MAX_PATH);
        SetDlgItemText(hDlg, IDC_DEVRES_CONFLICTINFOLIST, szBuffer);
    }
    if(pszConflictList != NULL) {
        MyFree(pszConflictList);
    }
    if (pConflictExceptions != NULL) {
        pFreeConflictExceptions(pConflictExceptions);
    }

    return;

}

int
pOkToSave(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Check to see if there's something the user hasn't done

Arguments:

Return Value:

    IDYES = save settings
    IDNO  = don't save settings
    IDCANCEL = don't exit

--*/
{
    HWND        hDlg = lpdmpd->hDlg;
    HWND        hList = GetDlgItem(hDlg, IDC_DEVRES_SETTINGSLIST);
    int         iCur;
    int         nRes;
    PITEMDATA   pItemData;

    if (lpdmpd->dwFlags & DMPROP_FLAG_NO_RESOURCES) {
        //
        // no changes - because there are no resources
        //
        return IDNO;
    }
    if (lpdmpd->dwFlags & DMPROP_FLAG_CHANGESSAVED) {
        //
        // no changes
        //
        return IDNO;
    }
    if (lpdmpd->dwFlags & DMPROP_FLAG_USESYSSETTINGS) {
        //
        // always ok to "use sys settings"
        //
        return IDYES;
    }
    //
    // user is forcing a config - let's see if all settings are valid
    //
    //
    // The resource descriptors are out-of-order.  Maintain the original ordering.
    //
    // First, build up a linked list of the data in the listview resource items.
    //
    iCur = (int)ListView_GetNextItem(hList, -1, LVNI_ALL);

    while (iCur >= 0) {

        pItemData = (PITEMDATA)pGetListViewItemData(hList, iCur, 0);
        if (pItemData) {
            if (pItemData->bValid == FALSE) {
                //
                // we've got an invalid entry - can't save
                //
                nRes = pWarnNoSave(hDlg,IDS_FORCEDCONFIG_PARTIAL);
                if (nRes != IDOK) {
                    return IDCANCEL;
                }
                return IDNO;
            }
        }

        iCur = (int)ListView_GetNextItem(hList, iCur, LVNI_ALL);
    }

    //
    // everything checks out
    //

    return IDYES;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devres2.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    devres2.c

Abstract:

    Utility routines for resource matching

Author:

    Jamie Hunter (jamiehun) 9-July-1998

--*/

#include "precomp.h"
#pragma hdrstop

PRDE_LIST
pRDEList_Alloc()
/*++

Routine Description:

    Allocates a list-entry node

Arguments:

Return Value:

   PRDE_LIST entry

--*/
{
    PRDE_LIST Node;

    Node = (PRDE_LIST)MyMalloc(sizeof(RDE_LIST));
    if (Node == NULL) {
        return NULL;
    }
    Node->Prev = Node;
    Node->Next = Node;
    Node->Entry = NULL;
    return Node;
}

VOID
pRDEList_AddHead(
    IN OUT PRDE_LIST pList,
    IN PRDE_LIST Node
                 )
/*++

Routine Description:

    Adds a node to head of list

Arguments:

    pList =  pointer to list
    Node  =  node to add

Return Value:

   none

--*/
{
    MYASSERT(Node);
    MYASSERT(Node->Prev == Node);
    MYASSERT(Node->Next == Node);
    MYASSERT(pList);

    Node->Prev = pList;
    Node->Next = pList->Next;
    Node->Next->Prev = Node;
    pList->Next = Node; // Head
}

VOID
pRDEList_AddTail(
    IN OUT PRDE_LIST pList,
    IN PRDE_LIST Node
                 )
/*++

Routine Description:

    Adds a node to tail of list

Arguments:

    pList =  pointer to list
    Node  =  node to add

Return Value:

   none

--*/
{
    MYASSERT(Node);
    MYASSERT(Node->Prev == Node);
    MYASSERT(Node->Next == Node);
    MYASSERT(pList);

    Node->Next = pList;
    Node->Prev = pList->Prev;
    Node->Prev->Next = Node;
    pList->Prev = Node; // Tail
}

VOID
pRDEList_Remove(
    IN PRDE_LIST Node
                 )
/*++

Routine Description:

    Removes a node from list that node is member of

Arguments:

    Node  =  node to remove

Return Value:

   none

--*/
{
    MYASSERT(Node);

    if (Node->Prev == Node && Node->Next == Node) {
        //
        // already removed
        //
        return;
    }

    Node->Prev->Next = Node->Next;
    Node->Next->Prev = Node->Prev;
    Node->Next = Node;
    Node->Prev = Node;
}

PRDE_LIST
pRDEList_Find(
    IN PRDE_LIST pList,
    IN PRESDES_ENTRY pItem
    )
/*++

Routine Description:

    Looks for pItem in pList

Arguments:

    pList = list to search
    pItem = item to search for

Return Value:

   Node entry, or NULL

--*/
{
    PRDE_LIST Node;

    MYASSERT(pList);
    MYASSERT(pItem);

    Node = pList->Next; // head
    while (Node != pList) {
        if (Node->Entry == pItem) {
            return Node;
        }
        Node = Node->Next;
    }
    return NULL;
}


VOID
pRDEList_Destroy(
    IN PRDE_LIST pList
                 )
/*++

Routine Description:

    Destroy pList and everything on pList

Arguments:

    pList = list to destroy

Return Value:

   Node entry, or NULL

--*/
{
    PRDE_LIST Node,Next;

    if (pList == NULL) {
        return;
    }

    Node = pList; // head
    do
    {
        Next = Node->Next;
        MyFree(Node);       // this will free pList first, and then everything else on same list
        Node = Next;
    }
    while (Node != pList);
}

BOOL
pGetMatchingRange(
    IN ULONG64  ulKnownValue,
    IN ULONG64  ulKnownLen,
    IN LPBYTE   pData,
    IN RESOURCEID ResType,
    OUT PULONG  pRange,
    OUT PBOOL   pExact,
    OUT PULONG  pFlags
    )
/*++

Routine Description:

    Finds range index for resource inside ResDes

Arguments:

    ulKnownValue - base address
    ulKnownLen - length of resources
    pData/ResType - resource data we're comparing with
    pRange - output range index
    pExact - output true if there is only one range
    pFlags - output flags from matching range

Return Value:

   BOOL if match

--*/
{
    PGENERIC_RESOURCE pGenRes = NULL;
    ULONG64 ulValue = 0, ulLen = 0, ulEnd = 0;
    ULONG ulFlags = 0, i;

    pGenRes = (PGENERIC_RESOURCE)pData;

    for (i = 0; i < pGenRes->GENERIC_Header.GENERIC_Count; i++) {

        pGetRangeValues(pData, ResType, i, &ulValue, &ulLen, &ulEnd, NULL, &ulFlags);
        if (ulLen != ulKnownLen) {
            continue;
        }

        if ((ulKnownValue >= ulValue) &&
            ((ulKnownValue + ulLen - 1) <= ulEnd)) {

            if (pRange != NULL) {
                *pRange = i;
            }
            //
            // consider exact case
            //
            if (pExact != NULL) {
                if (pGenRes->GENERIC_Header.GENERIC_Count==1 && ulValue == ulKnownValue && (ulKnownValue + ulLen - 1) == ulEnd) {
                    *pExact = TRUE;
                }
            }
            if (pFlags != NULL) {
                //
                // want nearest flags
                //
                *pFlags = ulFlags;
            }

            return TRUE;
        }
    }
    if (pRange != NULL) {
        *pRange = 0;
    }
    return FALSE;
}


ULONG
pTryMatch(
    IN OUT PRESDES_ENTRY pKnown,
    IN OUT PRDE_LIST pResList,
    IN OUT PULONG pDepth
    )
/*++

Routine Description:

    Looks for best match of remaining requirements in
    remaining available resources
    returns number of matched requirements

Arguments:

    pKnown - requirements list (what is remaining)
    pResList - list of available resources

Return Value:

   Node entry, or NULL

--*/
{
    ULONG ThisBest = 0;
    ULONG MyBest = 0;
    PRDE_LIST pIterator = NULL;
    PRESDES_ENTRY pRange;
    ULONG64  ulValue, ulLen, ulEnd;
    ULONG  ulFlags;
    BOOL Exact = FALSE;
    ULONG Best = 0;
    PRDE_LIST pBestRes = NULL;
    BOOL BadMatch = FALSE;
    BOOL Prune = FALSE;
    BOOL NoRemaining = TRUE;

    MYASSERT(pDepth);
    *pDepth = 0;

    if (pKnown == NULL) {
        //
        // end recursion
        //
        return 0;
    }
    pKnown->CrossLink = NULL;

    //
    // we're looking for a match in pResList for pKnown
    // case (1) get a "Best" for if we decide not to match
    // case (2) get a "Best" for exact match, and chose between (1) and (2) if one exists
    // case (3) get a "Best" for each possible range match and choose best between (1) and all (3)
    //

    //
    // consider case(1) - what the results would be if we wasn't able to fit anything in
    //
    //Best = pTryMatch(pKnown->Next,pResList,pDepth);
    //pBestRes = NULL;

    pGetHdrValues(pKnown->ResDesData, pKnown->ResDesType, &ulValue, &ulLen, &ulEnd, &ulFlags);

    //
    // consider case(2) and (3) together
    //
    for(pIterator = pResList->Next;pIterator!=pResList;pIterator = pIterator->Next) {
        //
        // iterate through remaining resources
        //
        pRange = pIterator->Entry;
        if (pRange == NULL) {
            //
            // this has been used
            //
            continue;
        }
        if (pRange->ResDesType != pKnown->ResDesType) {
            //
            // not the kind of resource i'm looking for
            //
            continue;
        }
        NoRemaining = FALSE;
        if(pGetMatchingRange(ulValue, ulLen,pRange->ResDesData, pRange->ResDesType,NULL,&Exact,NULL)) {
            pIterator->Entry = NULL; // eliminate this range
            ThisBest = pTryMatch(pKnown->Next,pResList,pDepth); // match the rest, with us using this resource-range
            pIterator->Entry = pRange;
            if ((ThisBest > Best) || (pBestRes == NULL)) {
                //
                // the current best match (or first match if pBestRes == NULL)
                //
                pKnown->CrossLink = pRange;
                pBestRes = pIterator;
                Best = ThisBest;
                MyBest = 1;
                BadMatch = FALSE;
            } else {
                //
                // need to re-do best match
                //
                BadMatch = TRUE;
            }
            if (Exact || (*pDepth == ThisBest)) {
                //
                // prune - we're either exact, or got a perfect match
                //
                Prune = TRUE;
                goto Final;
            }
        }
    }

    if (NoRemaining) {
        //
        // I have no resources remaining I can use - consider this as good as a match
        // but we need to continue up the tree
        //
        Best = pTryMatch(pKnown->Next,pResList,pDepth); // match the rest, with us using this resource-range
        MyBest = TRUE;
        BadMatch = FALSE;
        goto Final;
    }

    //
    // if we get here we've:
    // (1) found a flexable match, but wasn't able to match everyone above us, or
    // (2) not found any match
    // note that if last best was n with us matching and this best is n+1 without
    // then we don't lose the best
    // consider if overall we'd do any better if we gave up our resources to someone else
    //
    if((pBestRes == NULL) || ((Best+MyBest) < *pDepth)) {
        //
        // if we had a match, only worth checking if we could increase best by more than MyBest
        // note that *pDepth is only valid if pBestRes != NULL
        //
        ThisBest = pTryMatch(pKnown->Next,pResList,pDepth);
        if ((ThisBest > (Best+MyBest)) || (pBestRes == NULL)) {
            //
            // the current best match
            //
            pKnown->CrossLink = NULL;
            pBestRes = NULL;
            Best = ThisBest;
            MyBest = 0;
            BadMatch = FALSE;
        } else {
            //
            // need to re-do best match
            //
            BadMatch = TRUE;
        }
    }

Final:

    if (BadMatch) {
        //
        // We had a bad-match since our last good match
        //
        if (pBestRes) {
            pRange = pBestRes->Entry; // the range we determined was our best bet
            pBestRes->Entry = NULL; // eliminate this range
            Best = pTryMatch(pKnown->Next,pResList,pDepth); // match the rest, with us using this resource-range
            pBestRes->Entry = pRange;
            pKnown->CrossLink = pRange;
            MyBest = 1;
        } else {
            Best = pTryMatch(pKnown->Next,pResList,pDepth); // match the rest, with us not using this resource range
            pKnown->CrossLink = NULL;
            MyBest = 0;
        }
    }

    //
    // if we found a match, we've saved it in pKnown->CrossLink
    // return Best+0 if it's better we don't fit our resource in, Best+1 otherwise
    // returns *pDepth = Best+1 if everyone (me up) fit their resources in
    //

    (*pDepth)++; // increment to include me
    return Best+MyBest; // MyBest = 1 if I managed to match my resource (or no resources left), Best = everyone to the right of me
}

ULONG
pMergeResDesDataLists(
    IN OUT PRESDES_ENTRY pKnown,
    IN OUT PRESDES_ENTRY pTest,
    OUT PULONG pMatchCount
    )
/*++

Routine Description:

    Map entries in pKnown into pTest
    as best as possible

Arguments:

    pKnown - list of known values
    pTest - list of ranges
    pMatchCount - set to be number of resources matched

Return Value:

    NO_LC_MATCH  if no correlation (not a single known matches)
    LC_MATCH_SUPERSET if at least one known matches, but some known's don't
    LC_MATCH_SUBSET if all known matches, but there are some range-items unmatched
    LC_MATCH if all known matches and all range-items match
    ORDERED_LC_MATCH if match, and match is in order

    pKnown->CrossLink entries point to matching entries in pTest
    pTest->CrossLink entries point to matching entries in pKnown

--*/
{
    PRDE_LIST pResList = NULL;
    PRDE_LIST Node;
    PRESDES_ENTRY pKnownEntry;
    PRESDES_ENTRY pTestEntry;
    ULONG Success = NO_LC_MATCH;
    ULONG Depth = 0;
    BOOL SomeKnownMatched = FALSE;
    BOOL SomeKnownUnMatched = FALSE;
    BOOL SomeTestMatched = FALSE;
    BOOL SomeTestUnMatched = FALSE;
    BOOL Ordered = TRUE;
    ULONG MatchCount = 0;

    if (pKnown == NULL) {
        goto Final;
    }

    //
    // reset
    //
    for(pKnownEntry = pKnown; pKnownEntry != NULL ;pKnownEntry = pKnownEntry->Next) {
        pKnownEntry->CrossLink = NULL;
    }

    for(pTestEntry = pTest; pTestEntry != NULL ;pTestEntry = pTestEntry->Next) {
        pTestEntry->CrossLink = NULL;
    }

    pResList = pRDEList_Alloc();

    if (pResList == NULL) {
        goto Final;
    }

    //
    // make all resources available
    // this gives us a work list without destroying original list
    //
    for(pTestEntry = pTest; pTestEntry != NULL ;pTestEntry = pTestEntry->Next) {
        Node = pRDEList_Alloc();

        if (Node == NULL) {
            goto Final;
        }
        Node->Entry = pTestEntry;
        pRDEList_AddTail(pResList,Node);
    }

    MatchCount = pTryMatch(pKnown,pResList,&Depth);

    if (MatchCount ==0) {
        //
        // no match
        //
        goto Final;
    }

    //
    // pKnown now has it's Cross-Link's set to determine success of this match
    //
    // consider NO_LC_MATCH, LC_MATCH_SUPERSET and ORDERED_LC_MATCH cases
    //

    pKnownEntry = pKnown;
    pTestEntry = pTest;

    while (pKnownEntry) {
        if (pKnownEntry->CrossLink == NULL) {
            SomeKnownUnMatched = TRUE;
        } else {
            SomeKnownMatched = TRUE;    // we have at least one matched
            pKnownEntry->CrossLink->CrossLink = pKnownEntry; // cross-link test entries
            if (pKnownEntry->CrossLink != pTestEntry) {
                Ordered = FALSE;        // ordered compare lost
            } else {
                pTestEntry = pTestEntry->Next; // goto next test for ordered
            }
        }
        pKnownEntry = pKnownEntry->Next;
    }
    if (Ordered && pTestEntry != NULL) {
        Ordered = FALSE;
    }

    if (SomeKnownUnMatched) {
        if (SomeKnownMatched) {
            Success = LC_MATCH_SUPERSET;
        }
        goto Final;
    }

    if (Ordered) {
        Success = ORDERED_LC_MATCH;
        goto Final;
    }

    //
    // consider between LC_MATCH_SUBSET and LC_MATCH
    //
    pTestEntry = pTest;

    while (pTestEntry) {
        if (pTestEntry->CrossLink == NULL) {
            //
            // the first NULL CrossLink entry makes Known a Subset of Test
            Success = LC_MATCH_SUBSET;
            goto Final;
        }
        pTestEntry = pTestEntry->Next;
    }
    //
    // if we get here, there is an exact match
    //
    Success = LC_MATCH;

  Final:
    pRDEList_Destroy(pResList);

    if (pMatchCount != NULL) {
        *pMatchCount = MatchCount;
    }

    return Success;
}

ULONG
pCompareLogConf(
    IN LOG_CONF KnownLogConf,
    IN LOG_CONF TestLogConf,
    IN HMACHINE hMachine,
    OUT PULONG pMatchCount
    )

/*++

Routine Description:

    This routine compares two log confs and returns info about how well
    they match.
    This simply uses the pMergeResDesDataLists function to get match status

Arguments:

   KnownLogConf = First log conf to compare (fixed values)
   TestConfType = Second log conf to compare (range values)
   hMachine = Machine to compare on
   pMatchCount = number of resources matched

Return Value:

    As pMergeResDesDataLists

--*/

{
    PRESDES_ENTRY pKnownResList = NULL, pTestResList = NULL;
    ULONG Status;

    //
    // Retrieve the resources for each log conf
    //

    if (!pGetResDesDataList(KnownLogConf, &pKnownResList, TRUE,hMachine)) {
        if (pMatchCount) {
            *pMatchCount = 0;
        }
        return NO_LC_MATCH;
    }

    if (!pGetResDesDataList(TestLogConf, &pTestResList, TRUE,hMachine)) {
        pDeleteResDesDataList(pKnownResList);
        if (pMatchCount) {
            *pMatchCount = 0;
        }
        return NO_LC_MATCH;
    }

    Status = pMergeResDesDataLists(pKnownResList,pTestResList,pMatchCount);

    pDeleteResDesDataList(pKnownResList);
    pDeleteResDesDataList(pTestResList);

    return Status;
}

BOOL
pFindMatchingAllocConfig(
    IN  LPDMPROP_DATA lpdmpd
    )
{
    HWND     hDlg = lpdmpd->hDlg;
    ULONG    ulBasicLC = 0;
    ULONG    ulBasicCount = 0;
    BOOL     bFoundCorrectLC = FALSE;
    LOG_CONF LogConf;
    ULONG    lastMatchStatus = NO_LC_MATCH, bestMatchStatus = NO_LC_MATCH;
    UINT lastMatchCount;
    UINT bestMatchCount = 0;
    HMACHINE hMachine;

    hMachine = pGetMachine(lpdmpd);

    lpdmpd->MatchingLC = (LOG_CONF)0;
    lpdmpd->MatchingLCType = BASIC_LOG_CONF;

    //
    // Load the values associated with the allocated config in the list box,
    // but associate each with the resource requirements descriptor that it
    // originated from. To do this, we have to match the allocated config
    // with the basic/filtered config it is based on.
    //
    // NOTE: if we got here, then we know that an known config of some kind
    // exists (passed in as param) and that at least one basic/filtered config
    // exists. Further more, we know that the combobox has already been
    // filled in with a list of any basic/filtered configs and the lc handle
    // associated with them.
    //

    ulBasicCount = (ULONG)SendDlgItemMessage(hDlg,IDC_DEVRES_LOGCONFIGLIST,CB_GETCOUNT,
                                                        (WPARAM)0,(LPARAM)0);
    if (ulBasicCount == (ULONG)LB_ERR) {
        return FALSE;
    }

    for (ulBasicLC = 0 ; ulBasicLC < ulBasicCount; ulBasicLC++) {
        //
        // Retrieve the log conf handle
        //

        LogConf = (LOG_CONF)SendDlgItemMessage(hDlg, IDC_DEVRES_LOGCONFIGLIST,
                                               CB_GETITEMDATA, ulBasicLC, 0L);

        if (LogConf != 0) {
            //
            // Determine how good a match this requirements list is.
            //

            lastMatchStatus = pCompareLogConf(lpdmpd->CurrentLC, LogConf,hMachine,&lastMatchCount);
            if ((lastMatchStatus > bestMatchStatus)
                ||  ((bestMatchStatus == lastMatchStatus) && lastMatchCount > bestMatchCount)) {
                bestMatchCount = lastMatchCount;
                bestMatchStatus =lastMatchStatus;
                lpdmpd->MatchingLC = LogConf;
            }
        }
    }

    if (bestMatchStatus == NO_LC_MATCH || bestMatchStatus == LC_MATCH_SUBSET) {
        //
        // this doesn't follow any valid config
        //
        return FALSE;
    }

    lpdmpd->dwFlags &= ~(DMPROP_FLAG_PARTIAL_MATCH|DMPROP_FLAG_MATCH_OUT_OF_ORDER);
    if (bestMatchStatus != ORDERED_LC_MATCH) {
        //
        // If match status isn't ORDERED_LC_MATCH, then ordering of the resource descriptors
        // didn't match up.  Set a flag to indicate this, so that later on we'll know to handle
        // this specially.
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_MATCH_OUT_OF_ORDER;
    } else if (bestMatchStatus < LC_MATCH) {
        //
        // match is partial
        //
        lpdmpd->dwFlags |= DMPROP_FLAG_PARTIAL_MATCH;
    }
    return TRUE;

} // LoadMatchingAllocConfig

BOOL
pGetMatchingResDes(
    IN ULONG64    ulKnownValue,
    IN ULONG64    ulKnownLen,
    IN ULONG64    ulKnownEnd,
    IN RESOURCEID ResType,
    IN LOG_CONF   MatchingLogConf,
    OUT PRES_DES  pMatchingResDes,
    IN HMACHINE   hMachine
    )
/*++

Routine Description:

    This returns a res des that matches the specified values.
    used by pSaveCustomResSettings

Arguments:

    ulKnownValue    Starting resource value to match against

    ulKnownLen      Length of resource to match against

    ResType         Type of resource to match against

    MatchnigLogConf Log conf to retreive potential matching res des from

    pMatchingResDes Supplies a pointer that on return contains a matching
                    res des if any.

Return Value:

   None.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    RESOURCEID  Res;
    RES_DES     ResDes, ResDesTemp;
    ULONG64     ulValue = 0, ulLen = 0, ulEnd = 0;
    ULONG       ulSize, ulFlags = 0, i;
    PGENERIC_RESOURCE   pGenRes;
    BOOL        bMatch = FALSE;
    LPBYTE      pData = NULL;


    //
    // The MatchingLogConf is a requirements list. Loop through each res des
    // in the matching log conf until we find a res des that matches the
    // known res des values.
    //
    Status = CM_Get_Next_Res_Des_Ex(&ResDes, MatchingLogConf, ResType, &Res, 0,hMachine);

    while (Status == CR_SUCCESS) {
        //
        // Get res des data
        //
        if (CM_Get_Res_Des_Data_Size_Ex(&ulSize, ResDes, CM_RESDES_WIDTH_64,hMachine) != CR_SUCCESS) {
            CM_Free_Res_Des_Handle(ResDes);
            break;
        }

        pData = MyMalloc(ulSize);
        if (pData == NULL) {
            CM_Free_Res_Des_Handle(ResDes);
            break;
        }

        if (CM_Get_Res_Des_Data_Ex(ResDes, pData, ulSize, DEVRES_WIDTH_FLAGS,hMachine) != CR_SUCCESS) {
            CM_Free_Res_Des_Handle(ResDes);
            MyFree(pData);
            break;
        }

        if(pGetMatchingRange(ulKnownValue,ulKnownLen,pData,ResType,NULL,NULL,NULL)) {
            *pMatchingResDes = ResDes;
            bMatch = TRUE;
            MyFree(pData);
            goto MatchFound;
        }

        //
        // Get next res des in log conf
        //
        ResDesTemp = ResDes;
        Status = CM_Get_Next_Res_Des_Ex(&ResDes, ResDesTemp,
                                     ResType, &Res, 0,hMachine);

        CM_Free_Res_Des_Handle(ResDesTemp);
        MyFree(pData);
    }

    MatchFound:

    return bMatch;

} // GetMatchingResDes



//
// NTRAID#166214-2000/08/19-JamieHun Conflict Supression Hack
// this stuff needs to be fixed proper
//

PTSTR
pGetRegString(
    IN HKEY hKey,
    IN PCTSTR regval
    )
/*++

Routine Description:

    Obtain and return a registry string allocated by MyMalloc
    return NULL if we couldn't retrieve string

Arguments:

    hKey - key to retrieve string from
    regval - value to retrieve

Return Value:

    copy of registry string, may be free'd with MyFree

--*/
{
    DWORD dwSize;
    DWORD dwType;
    PTSTR pSz;
    LONG res;

    dwType = 0;
    dwSize = 0;
    res = RegQueryValueEx(hKey,regval,NULL,&dwType,(PBYTE)NULL,&dwSize);
    if (res != ERROR_SUCCESS) {
        return NULL;
    }
    if (dwType != REG_SZ) {
        return NULL;
    }
    pSz = MyMalloc(dwSize);
    if (pSz == NULL) {
        return NULL;
    }
    res = RegQueryValueEx(hKey,regval,NULL,&dwType,(PBYTE)pSz,&dwSize);
    if (res != ERROR_SUCCESS) {
        MyFree(pSz);
        return NULL;
    }
    return pSz;
}

VOID
pFillCETags(
    IN PCONFLICT_EXCEPTIONS pExceptions,
    IN PCE_TAGS pTags,
    PTSTR pSz
    )
/*++

Routine Description:

    parse a list of tags into CE_TAGS structure
    adding the strings into the string table en-route
    note that this structure will be flexable and allow ',' or ';' seperator
    however when used in Exceptions string, we've already eliminated any ';'

    format is:
    <tag>,<tag>,<tag> or <tag>;<tag>;<tag>

Arguments:

    pExceptions - context information
    pTags - tag structure to fill in

Return Value:

    none

--*/
{
    static CE_TAGS DummyEntry = { -1 }; // if we write a new string, negative size count means this isn't a devnode entry

    MYASSERT(pTags->nTags == 0);

    while(pSz[0] && pTags->nTags < MAX_CE_TAGS) {
        if(pSz[0]==TEXT(',')||pSz[0]==TEXT(';')||pSz[0]<=TEXT(' ')) {
            pSz++;
        } else {
            PTSTR pOldSz = pSz;
            PTSTR pLastSpace = NULL;
            LONG id;
            while (pSz[0] && pSz[0]!=TEXT(';')&& pSz[0]!=TEXT(',')) {
                if (pSz[0]<=TEXT(' ')) {
                    if (pLastSpace==NULL) {
                        pLastSpace = pSz;
                    }
                } else {
                    pLastSpace = NULL;
                }
                pSz++;
            }
            //
            // pSz points to '\0', ';' or ','
            // pLastSpace points to any trailing WS
            // pOldSz points to start of string
            //
            if(pLastSpace==NULL) {
                pLastSpace = pSz;
            }
            if (pSz[0]) {
                pSz++;
            }
            pLastSpace[0]=TEXT('\0');
            //
            // pSz points to next string, pOldSz points to this string
            // add string to string table, place in list of tags
            //
            id = pSetupStringTableAddStringEx(pExceptions->ceTagMap,pOldSz,STRTAB_CASE_INSENSITIVE|STRTAB_BUFFER_WRITEABLE,&DummyEntry,sizeof(DummyEntry));
            if (id>=0) {
                pTags->Tag[pTags->nTags++] = id;
            }
        }
    }
}

PCE_ENTRY
pScanConflictExceptionEntry(
    IN PCONFLICT_EXCEPTIONS pExceptions,
    PTSTR pSz
    )
/*++

Routine Description:

    obtains conflict exception info from string

    format is:
    (1)  <tags>          - always ignore tag for any type of conflict
    (2)  <rt>:<tags>     - ignore tag for <rt> resource type
    (3)  <rt>@x:<tags>   - IRQ/DMA - specfic
    (4)  <rt>@x-y:<tags> - IO/MEM - range

    <tags>  are a comma-sep list of tags <tag>,<tag>,<tag>

Arguments:

    pExceptions - context information
    pSz - string to parse

Return Value:

    CE_ENTRY structure if this is a valid descriptor

--*/
{
    PTSTR brk;
    PCE_ENTRY pEntry;
    TCHAR rt[5];
    int c;

    while (pSz[0] && pSz[0]<=TEXT(' ')) {
        pSz++;
    }
    if (!pSz[0]) {
        return NULL;
    }

    pEntry = MyMalloc(sizeof(CE_ENTRY));

    if (pEntry == NULL) {
        return NULL;
    }
    ZeroMemory(pEntry,sizeof(CE_ENTRY));

    brk = _tcschr(pSz,TEXT(':'));

    if(!brk) {
        //
        // treat as tags only
        //
        pEntry->resType = ResType_None;
    } else {
        //
        // determine resource type
        //
        for(c=0;_istalpha(pSz[0]) && c<(sizeof(rt)/sizeof(TCHAR)-1);c++,pSz++) {
            rt[c] = (TCHAR)_totupper(pSz[0]);
        }
        rt[c] = 0;
        while (pSz[0] && pSz[0]<=TEXT(' ')) {
            pSz++;
        }
        if (pSz[0]!=TEXT(':') && pSz[0]!=TEXT('@')) {
            MyFree(pEntry);
            return NULL;
        } else if (_tcscmp(rt,CE_RES_IO)==0) {
            pEntry->resType = ResType_IO;
        } else if (_tcscmp(rt,CE_RES_MEM)==0) {
            pEntry->resType = ResType_Mem;
        } else if (_tcscmp(rt,CE_RES_IRQ)==0) {
            pEntry->resType = ResType_IRQ;
        } else if (_tcscmp(rt,CE_RES_DMA)==0) {
            pEntry->resType = ResType_DMA;
        } else {
            MyFree(pEntry);
            return NULL;
        }
        if (pSz[0]!=TEXT('@')) {
            //
            // no range follows
            //
            pEntry->resStart = (ULONG64)0;
            pEntry->resEnd = (ULONG64)(-1);
        } else {
            //
            // @x[-y]:
            //
            ULONG x;
            ULONG y;
            PTSTR i;

            pSz++; // past @

            while (pSz[0] && pSz[0]<=TEXT(' ')) {
                pSz++;
            }
            i = pSz;
            x = _tcstoul(pSz,&i,0);
            if (i==pSz) {
                MyFree(pEntry);
                return NULL;
            }
            pSz = i;
            while (pSz[0] && pSz[0]<=TEXT(' ')) {
                pSz++;
            }
            if (pSz[0]==TEXT('-')) {
                //
                // -y
                //
                pSz++;
                while (pSz[0] && pSz[0]<=TEXT(' ')) {
                    pSz++;
                }
                i = pSz;
                y = _tcstoul(pSz,&i,0);
                if (i==pSz || y<x) {
                    MyFree(pEntry);
                    return NULL;
                }
                pSz = i;
                while (pSz[0] && pSz[0]<=TEXT(' ')) {
                    pSz++;
                }
            } else {
                y = x;
            }
            pEntry->resStart = x;
            pEntry->resEnd = y;
        }
        if (pSz[0] != TEXT(':')) {
            MyFree(pEntry);
            return NULL;
        }
        pSz ++; // skip past colon
    }
    //
    // at this point, expect a list of tags
    // each tag terminated by a comma
    //
    pFillCETags(pExceptions,&pEntry->tags,pSz);
    if (!pEntry->tags.nTags) {
        MyFree(pEntry);
        return NULL;
    }
    return pEntry;
}

PCONFLICT_EXCEPTIONS pLoadConflictExceptions(
    IN LPDMPROP_DATA lpdmpd
    )
/*++

Routine Description:

    Load the string "ResourcePickerExceptions" if any
    create a context structure for eliminating false conflicts
    this is one huge hack.

Arguments:

    lpdmpd - Context data

Return Value:

    CONFLICT_EXCEPTIONS structure, if "active" contains a string table and a list of resource exceptions

--*/
{
    PCONFLICT_EXCEPTIONS pExceptions;
    PCE_ENTRY pEntry;
    BOOL bStatus;
    HKEY hDevRegKey;
    PTSTR pSz;
    PTSTR pScanSz;
    PTSTR pOldSz;
    PCE_TAGS pTags;

    //
    // we always create the structure, so we will avoid looking for registry info every time
    //
    pExceptions = MyMalloc(sizeof(CONFLICT_EXCEPTIONS));
    if (pExceptions == NULL) {
        return NULL;
    }
    ZeroMemory(pExceptions,sizeof(CONFLICT_EXCEPTIONS));

    hDevRegKey = SetupDiOpenDevRegKey(lpdmpd->hDevInfo,lpdmpd->lpdi,DICS_FLAG_GLOBAL,0,DIREG_DRV,KEY_READ);
    if (hDevRegKey == INVALID_HANDLE_VALUE) {
        //
        // can't find key, no conflict elimination
        //
        return pExceptions;
    }
    pSz = pGetRegString(hDevRegKey,REGSTR_VAL_RESOURCE_PICKER_EXCEPTIONS);
    RegCloseKey(hDevRegKey);
    if(pSz == NULL) {
        //
        // can't find key, no conflict elimination
        //
        return pExceptions;
    }

    //
    // now parse the string creating our context to eliminate false conflicts
    //

    pExceptions->ceTagMap = pSetupStringTableInitializeEx(sizeof(CE_TAGS),0);
    if (pExceptions->ceTagMap == NULL) {
        MyFree(pSz);
        return pExceptions;
    }

    pScanSz = pSz;

    while (pScanSz[0]) {
        if (pScanSz[0] == TEXT(';')) {
            pScanSz ++;
        } else {
            pOldSz = pScanSz;
            while (pScanSz[0] && pScanSz[0] != TEXT(';')) {
                pScanSz++;
            }
            if (pScanSz[0]) {
                pScanSz[0] = 0;
                pScanSz++;
            }
            pEntry = pScanConflictExceptionEntry(pExceptions,pOldSz);
            if (pEntry) {
                pEntry->Next = pExceptions->exceptions;
                pExceptions->exceptions = pEntry;
            }
        }
    }

    MyFree(pSz);
    return pExceptions;
}

VOID pFreeConflictExceptions(
    IN PCONFLICT_EXCEPTIONS pExceptions
    )
/*++

Routine Description:

    Releases memory used by PCONFLICT_EXCEPTIONS

Arguments:

    pExceptions     structure to release

Return Value:

   None.

--*/
{
    //
    // free the list
    //
    while (pExceptions->exceptions) {
        PCE_ENTRY pEntry = pExceptions->exceptions;
        pExceptions->exceptions = pEntry->Next;
        MyFree(pEntry);
    }
    //
    // free the string table
    //
    if (pExceptions->ceTagMap) {
        pSetupStringTableDestroy(pExceptions->ceTagMap);
    }
    MyFree(pExceptions);
}

BOOL pIsConflictException(
    IN LPDMPROP_DATA lpdmpd,
    IN PCONFLICT_EXCEPTIONS pExceptions,
    IN DEVINST devConflict,
    IN PCTSTR resDesc,
    IN RESOURCEID resType,
    IN ULONG64 resValue,
    IN ULONG64 resLength
    )
/*++

Routine Description:

    Load the string "ResourcePickerExceptions" if any
    create a context structure for eliminating false conflicts
    this is one huge hack.

Arguments:

    lpdmpd - Context data
    pExceptions - Cache of information
    devConflict - DEVINST that's shown to be conflicting with us, -1 if "unavailable" (tag = *)
    resType - type of resource that we tested
    resValue - value of resource that we tested
    resLength - length of resource that we tested

Return Value:

    TRUE if this is an exception

--*/
{
    HMACHINE hMachine;
    TCHAR DevNodeName[MAX_DEVNODE_ID_LEN];
    CE_TAGS tags;
    PCE_ENTRY pEntry;
    LONG tagent;
    LONG n,m;
    ULONG64 resEnd = resValue+(resLength-1);
    PTSTR pSz;
    HKEY hKey;

    //
    // if we're not doing any exceptions, get out ASAP
    //
    if (pExceptions->exceptions == NULL) {
        return FALSE;
    }

    hMachine = pGetMachine(lpdmpd);
    //
    // handle "reserved" case first
    //
    if (devConflict != -1) {
        //
        // obtain device instance string
        //
        if(CM_Get_Device_ID_Ex(devConflict,DevNodeName,MAX_DEVNODE_ID_LEN,0,hMachine)!=CR_SUCCESS) {
            devConflict = -1;
        }
    }
    if (devConflict == -1) {
        if (resDesc && resDesc[0]) {
            lstrcpy(DevNodeName,resDesc);
        } else {
            lstrcpy(DevNodeName,CE_TAG_RESERVED);
        }
    } else {
    }
    //
    // is this a brand-new devnodename ?
    //
    tags.nTags = 0;
    tagent = pSetupStringTableLookUpStringEx(pExceptions->ceTagMap,DevNodeName,STRTAB_CASE_INSENSITIVE|STRTAB_BUFFER_WRITEABLE,&tags,sizeof(tags));
    if(tagent<0 || tags.nTags<0) {
        //
        // this particular devnode hasn't been processed before, ouch time
        //
        ZeroMemory(&tags,sizeof(tags)); // default reserved case
        if (devConflict != -1) {
            //
            // we need to get regkey for this devnode
            // I could do this via setupapi, or cfgmgr
            // for efficiency, I'm going latter route
            //
            if(CM_Open_DevNode_Key_Ex(devConflict,
                     KEY_READ,
                     0,
                     RegDisposition_OpenExisting,
                     &hKey,
                     CM_REGISTRY_SOFTWARE,
                     hMachine) == CR_SUCCESS) {

                pSz = pGetRegString(hKey,REGSTR_VAL_RESOURCE_PICKER_TAGS);
                RegCloseKey(hKey);

                if (pSz) {
                    //
                    // now fill in tags
                    //
                    pFillCETags(pExceptions,&tags,pSz);
                    MyFree(pSz);
                }
            }
        }
        //
        // now write this back into the string table
        // this time, non-negative nTags indicates we've processed this once
        // we will re-write the extra-data
        //
        tagent = pSetupStringTableAddStringEx(pExceptions->ceTagMap,DevNodeName,STRTAB_CASE_INSENSITIVE|STRTAB_BUFFER_WRITEABLE|STRTAB_NEW_EXTRADATA,&tags,sizeof(tags));
    }
    if (tagent<0) {
        //
        // if this happens, we have other problems (out of memory)
        //
        return FALSE;
    }

    //
    // go through our list of exceptions
    // an exception that mentions tagent, or any of tags associated with tagent (in tags) is rejected
    // the policy in this routine is make this an exception if we can
    //

    for(pEntry=pExceptions->exceptions;pEntry;pEntry=pEntry->Next) {

        if (pEntry->resType != ResType_None) {
            //
            // we need to validate the resource
            //
            if (pEntry->resType != resType ||
                    pEntry->resStart > resValue ||
                    pEntry->resEnd < resEnd) {
                continue;
            }
        }
        for (n=0;n<pEntry->tags.nTags;n++) {
            if (pEntry->tags.Tag[n] == tagent) {
                MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Eliminated false conflict with %s type=%u, start=0x%08x, len=0x%08x\n"),DevNodeName,resType,resValue,resLength));
                return TRUE;    // hit (devnode itself, where devnode may also be "*")
            }
            for (m=0;m<tags.nTags;m++) {
                if (pEntry->tags.Tag[n] == tags.Tag[m]) {
                    MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Eliminated false conflict with %s (via tag %s) type=%u, start=0x%08x, len=0x%08x\n"),DevNodeName,pStringTableStringFromId(pExceptions->ceTagMap,tags.Tag[m]),resType,resValue,resLength));
                    return TRUE;    // hit on one of associated tags
                }
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devwiz.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devwiz.c

Abstract:

    Device Installer functions for install wizard support.

Author:

    Lonny McMichael (lonnym) 22-Sep-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define some macros to make the code a little cleaner.
//

//
// BOOL
// USE_CI_SELSTRINGS(
//     IN PDEVINSTALL_PARAM_BLOCK p
//     );
//
// This macro checks all the appropriate values to determine whether the
// class-installer provided strings may be used in the wizard.
//
#define USE_CI_SELSTRINGS(p)                                                \
                                                                            \
    (((((p)->Flags) & (DI_USECI_SELECTSTRINGS | DI_CLASSINSTALLPARAMS)) ==  \
      (DI_USECI_SELECTSTRINGS | DI_CLASSINSTALLPARAMS)) &&                  \
     (((p)->ClassInstallHeader->InstallFunction) == DIF_SELECTDEVICE))

//
// PTSTR
// GET_CI_SELSTRING(
//     IN PDEVINSTALL_PARAM_BLOCK p,
//     IN <FieldName>             f
//     );
//
// This macro retrieves a pointer to the specified string in a
// SP_SELECTDEVICE_PARAMS structure.
//
#define GET_CI_SELSTRINGS(p, f)                                             \
                                                                            \
    (((PSP_SELECTDEVICE_PARAMS)((p)->ClassInstallHeader))->f)

//
// Definitions for timer used in device selection listboxes.
//
#define SELECTMFG_TIMER_ID              1
#define SELECTMFG_TIMER_DELAY           250

//
// Define a message sent from our auxilliary class driver search thread.
//
#define WMX_CLASSDRVLIST_DONE    (WM_USER+131)
#define WMX_NO_DRIVERS_IN_LIST   (WM_USER+132)

//
// HELP ID's
//
static const DWORD SelectDeviceShowAllHelpIDs[]=
{
    IDC_NDW_PICKDEV_MFGLIST,            IDH_DEVMGR_SELECTDEVICE_MANUFACTURER,
    IDC_NDW_PICKDEV_ONEMFG_DRVLIST,     IDH_DEVMGR_SELECTDEVICE_MODEL,
    IDC_NDW_PICKDEV_DRVLIST,            IDH_DEVMGR_SELECTDEVICE_MODEL,
    IDC_NDW_STATUS_TEXT,                IDH_NOHELP,
    IDC_CLASSICON,                      IDH_NOHELP,
    IDC_NDW_PICKDEV_COMPAT,             IDH_DEVMGR_SELECTDEVICE_SHOWCOMPATIBLE,
    IDC_NDW_PICKDEV_WINDOWSUPDATE,      IDH_DEVMGR_SELECTDEVICE_WINDOWSUPDATE,
    IDC_NDW_PICKDEV_HAVEDISK,           IDH_DEVMGR_SELECTDEVICE_HAVEDISK,
    IDC_NDW_TEXT,                       IDH_NOHELP,
    IDD_DEVINSLINE,                     IDH_NOHELP,
    0, 0
};

static const DWORD SelectDeviceShowSimilarHelpIDs[]=
{
    IDC_NDW_PICKDEV_MFGLIST,            IDH_DEVMGR_SELECTDEVICE_MANUFACTURER,
    IDC_NDW_PICKDEV_ONEMFG_DRVLIST,     IDH_DEVMGR_SELECTDEVICE_MODEL,
    IDC_NDW_PICKDEV_DRVLIST,            IDH_DEVMGR_SELECTDEVICE_MODEL,
    IDC_NDW_STATUS_TEXT,                IDH_NOHELP,
    IDC_CLASSICON,                      IDH_NOHELP,
    IDC_NDW_PICKDEV_COMPAT,             IDH_DEVMGR_SELECTDEVICE_SHOWCOMPATIBLE,
    IDC_NDW_PICKDEV_WINDOWSUPDATE,      IDH_DEVMGR_SELECTDEVICE_WINDOWSUPDATE,
    IDC_NDW_PICKDEV_HAVEDISK,           IDH_DEVMGR_SELECTDEVICE_HAVEDISK,
    IDC_NDW_TEXT,                       IDH_NOHELP,
    IDD_DEVINSLINE,                     IDH_NOHELP,
    0, 0
};

#define SELECTDEVICE_HELP TEXT("devmgr.hlp")

//
// Define structure containing class driver search context that is passed to
// an auxilliary thread while a Select Device dialog is displayed.
//
typedef struct _CLASSDRV_THREAD_CONTEXT {

    HDEVINFO        DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;

    HWND NotificationWindow;

} CLASSDRV_THREAD_CONTEXT, *PCLASSDRV_THREAD_CONTEXT;


//
// Private function prototypes
//
DWORD
pSetupCreateNewDevWizData(
    IN  PSP_INSTALLWIZARD_DATA  InstallWizardData,
    OUT PNEWDEVWIZ_DATA        *NewDeviceWizardData
    );

UINT
CALLBACK
SelectDevicePropSheetPageProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE ppsp
    );

INT_PTR
CALLBACK
SelectDeviceDlgProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
InitSelectDeviceDlg(
    IN     HWND hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    );

VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
OnSetActive(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    );

DWORD
HandleSelectOEM(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    );

DWORD
HandleWindowsUpdate(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    );

DWORD
FillInDeviceList(
    IN HWND           hwndDlg,
    IN PSP_DIALOGDATA lpdd
    );

VOID
ShowListForMfg(
    IN PSP_DIALOGDATA          lpdd,
    IN PDEVICE_INFO_SET        DeviceInfoSet,
    IN PDEVINSTALL_PARAM_BLOCK InstallParamBlock,
    IN PDRIVER_NODE            DriverNode,        OPTIONAL
    IN INT                     iMfg
    );

VOID
LockAndShowListForMfg(
    IN PSP_DIALOGDATA   lpdd,
    IN INT              iMfg
    );

PDRIVER_NODE
GetDriverNodeFromLParam(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PSP_DIALOGDATA   lpdd,
    IN LPARAM           lParam
    );

BOOL
pSetupIsSelectedHardwareIdValid(
    IN HWND           hWnd,
    IN PSP_DIALOGDATA lpdd,
    IN INT            iCur
    );

VOID
SetSelectedDriverNode(
    IN PSP_DIALOGDATA lpdd,
    IN INT            iCur
    );

BOOL
bNoDevsToShow(
    IN PDEVINFO_ELEM DevInfoElem
    );

PNEWDEVWIZ_DATA
GetNewDevWizDataFromPsPage(
    LPPROPSHEETPAGE ppsp
    );

LONG
GetCurDesc(
    IN PSP_DIALOGDATA lpdd
    );

VOID
OnCancel(
    IN PNEWDEVWIZ_DATA ndwData
    );

VOID
__cdecl
ClassDriverSearchThread(
    IN PVOID Context
    );

BOOL
pSetupIsClassDriverListBuilt(
    IN PSP_DIALOGDATA lpdd
    );

VOID
pSetupDevInfoDataFromDialogData(
    IN  PSP_DIALOGDATA   lpdd,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    );

VOID
ToggleDialogControls(
    IN HWND                hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData,
    IN BOOL                Enable
    );

void
CleanupDriverLists(
    IN OUT PNEWDEVWIZ_DATA ndwData
    );

BOOL
CDMIsInternetAvailable(
    void
    );


HPROPSHEETPAGE
WINAPI
SetupDiGetWizardPage(
    IN HDEVINFO               DeviceInfoSet,
    IN PSP_DEVINFO_DATA       DeviceInfoData,    OPTIONAL
    IN PSP_INSTALLWIZARD_DATA InstallWizardData,
    IN DWORD                  PageType,
    IN DWORD                  Flags
    )
/*++

Routine Description:

    This routine retrieves a handle to one of the Setup API-provided wizard
    pages, for an application to include in its own wizard.

Arguments:

    DeviceInfoSet - Supplies the handle of the device information set to
        retrieve a wizard page for.

    DeviceInfoData - Optionally, supplies the address of a device information
        element with which the wizard page will be associated.  This parameter
        is only used if the flags parameter includes DIWP_FLAG_USE_DEVINFO_DATA.
        If that flag is set, and if this parameter is not specified, then the
        wizard page will be associated with the global class driver list.

    InstallWizardData - Supplies the address of a PSP_INSTALLWIZARD_DATA
        structure containing parameters to be used by this wizard page.  The
        cbSize field must be set to the size of the structure, in bytes, or the
        structure will be considered invalid.

    PageType - Supplies an ordinal indicating the type of wizard page to be
        retreived.  May be one of the following values:

        SPWPT_SELECTDEVICE - Retrieve a select device wizard page.

    Flags - Supplies flags that specify how the wizard page is to be created.
        May be a combination of the following values:

        SPWP_USE_DEVINFO_DATA - Use the device information element specified
                                by DeviceInfoData, or use the global class
                                driver list if DeviceInfoData is not supplied.
                                If this flag is not supplied, the wizard page
                                will act upon the currently selected device
                                (as selected by SetupDiSetSelectedDevice), or
                                upon the global class driver list if no device
                                is selected.

Return Value:

    If the function succeeds, the return value is the handle to the requested
    wizard page.

    If the function fails, the return value is NULL.  To get extended error
    information, call GetLastError.

Remarks:

    A device information set may not be destroyed as long as there are any
    active wizard pages using it.  In addition, if the wizard page is
    associated with a particular device information element, then that element
    will not be deletable as long as it is being used by a wizard page.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    PDEVINFO_ELEM DevInfoElem;
    DWORD Err = NO_ERROR;
    HPROPSHEETPAGE hPage = NULL;
    PNEWDEVWIZ_DATA ndwData = NULL;
    PWIZPAGE_OBJECT WizPageObject = NULL;
    //
    // Store the address of the corresponding wizard object at the
    // end of the PROPSHEETPAGE buffer.
    //
    BYTE pspBuffer[sizeof(PROPSHEETPAGE) + sizeof(PVOID)];
    LPPROPSHEETPAGE Page = (LPPROPSHEETPAGE)pspBuffer;

    try {
        //
        // Make sure we're running interactively.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            Err = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
            leave;
        }

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        switch(PageType) {

            case SPWPT_SELECTDEVICE :

                Page->pszTemplate = MAKEINTRESOURCE(IDD_DYNAWIZ_SELECTDEV_PAGE);
                Page->pfnDlgProc = SelectDeviceDlgProc;
                Page->pfnCallback = SelectDevicePropSheetPageProc;

                Page->pszHeaderTitle = MAKEINTRESOURCE(IDS_NDW_SELECTDEVICE);
                Page->pszHeaderSubTitle = NULL;

                break;

            default :
                Err = ERROR_INVALID_PARAMETER;
                leave;
        }

        //
        // Validate the supplied InstallWizardData structure, and create a
        // private storage buffer for internal use by the wizard page.
        //
        if((Err = pSetupCreateNewDevWizData(InstallWizardData, &ndwData)) != NO_ERROR) {
            leave;
        }

        //
        // Store the device information set handle in the dialogdata structure
        // embedded in the New Device Wizard buffer.
        //
        ndwData->ddData.DevInfoSet = DeviceInfoSet;

        //
        // If the caller specified the SPWP_USE_DEVINFO_DATA flag, then store information
        // in the dialog data structure about the specified devinfo element (if supplied).
        //
        if(Flags & SPWP_USE_DEVINFO_DATA) {
            if(DeviceInfoData) {
                //
                // Verify that the specified device information element is a valid one.
                //
                if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                             DeviceInfoData,
                                                             NULL))) {
                    Err = ERROR_INVALID_PARAMETER;
                    leave;

                } else if(DevInfoElem->DiElemFlags & DIE_IS_LOCKED) {
                    //
                    // Device information element cannot be explicitly used by more than
                    // one wizard page at a time.
                    //
                    Err = ERROR_DEVINFO_DATA_LOCKED;
                    leave;
                }

                DevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
                ndwData->ddData.DevInfoElem = DevInfoElem;
            }
            ndwData->ddData.flags = DD_FLAG_USE_DEVINFO_ELEM;
        }

        //
        // We've successfully created and initialized the devwiz data structure.
        // Now create a wizpage object so we can keep track of it.
        //
        if(WizPageObject = MyMalloc(sizeof(WIZPAGE_OBJECT))) {
            WizPageObject->RefCount = 0;
            WizPageObject->ndwData = ndwData;
            //
            // Insert this new object into the devinfo set's wizard object list.
            //
            WizPageObject->Next = pDeviceInfoSet->WizPageList;
            pDeviceInfoSet->WizPageList = WizPageObject;

        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        Page->dwSize = sizeof(pspBuffer);

        Page->dwFlags = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | PSP_USECALLBACK | PSP_USEFUSIONCONTEXT;
        Page->hActCtx = NULL;

        Page->hInstance = MyDllModuleHandle;

        Page->lParam = (LPARAM)DeviceInfoSet;

        *((PVOID *)(&(pspBuffer[sizeof(PROPSHEETPAGE)]))) = WizPageObject;

        if(!(hPage = CreatePropertySheetPage(Page))) {
            Err = ERROR_INVALID_DATA;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    if(Err != NO_ERROR) {
        if(ndwData) {
            MyFree(ndwData);
        }
        if(WizPageObject) {
            MyFree(WizPageObject);
        }
    }

    SetLastError(Err);
    return hPage;
}


BOOL
WINAPI
SetupDiGetSelectedDevice(
    IN  HDEVINFO          DeviceInfoSet,
    OUT PSP_DEVINFO_DATA  DeviceInfoData
    )
/*++

Routine Description:

    This routine retrieves the currently-selected device for the specified
    device information set.  This is typically used during an installation
    wizard.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for
        which the selected device is to be retrieved.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure
        that receives the currently-selected device.  If there is no device
        currently selected, then the routine will fail, and GetLastError
        will return ERROR_NO_DEVICE_SELECTED.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err = NO_ERROR;

    try {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        if(pDeviceInfoSet->SelectedDevInfoElem) {

            if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                  pDeviceInfoSet->SelectedDevInfoElem,
                                                  DeviceInfoData))) {
                Err = ERROR_INVALID_USER_BUFFER;
            }

        } else {
            Err = ERROR_NO_DEVICE_SELECTED;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiSetSelectedDevice(
    IN HDEVINFO          DeviceInfoSet,
    IN PSP_DEVINFO_DATA  DeviceInfoData
    )
/*++

Routine Description:

    This routine sets the specified device information element to be the
    currently selected member of a device information set.  This is typically
    used during an installation wizard.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for
        which the selected device is to be set.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure
        specifying the device information element to be selected.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err = NO_ERROR;
    PDEVINFO_ELEM DevInfoElem;

    try {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                DeviceInfoData,
                                                NULL
                                               );
        if(DevInfoElem) {
            pDeviceInfoSet->SelectedDevInfoElem = DevInfoElem;
        } else {
            Err = ERROR_INVALID_PARAMETER;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
pSetupCreateNewDevWizData(
    IN  PSP_INSTALLWIZARD_DATA  InstallWizardData,
    OUT PNEWDEVWIZ_DATA        *NewDeviceWizardData
    )
/*++

Routine Description:

    This routine validates an InstallWizardData buffer, then allocates and
    fills in a NEWDEVWIZ_DATA buffer based on information supplied therein.

Arguments:

    InstallWizardData - Supplies the address of an installation wizard data
        structure to be validated and used in building the private buffer.

    NewDeviceWizardData - Supplies the address of a variable that receives a
        pointer to the newly-allocated install wizard data buffer.  This buffer
        will not be modified unless the NEWDEVWIZ_DATA buffer was successfully
        built.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise, it is
    a Win32 error code.

--*/
{
    PNEWDEVWIZ_DATA ndwData = NULL;
    DWORD Err = NO_ERROR;

    if((InstallWizardData->ClassInstallHeader.cbSize != sizeof(SP_CLASSINSTALL_HEADER)) ||
       (InstallWizardData->ClassInstallHeader.InstallFunction != DIF_INSTALLWIZARD)) {

        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // The dynamic page entries are currently ignored, as are the Private
    // fields.  Also, the hwndWizardDlg is not validated.
    //

    try {

        if(ndwData = MyMalloc(sizeof(NEWDEVWIZ_DATA))) {
            ZeroMemory(ndwData, sizeof(NEWDEVWIZ_DATA));
        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        //
        // Initialize the Current Description string table index in the dialog
        // data to -1, so that it will get updated when the wizard page is
        // first entered.
        //
        ndwData->ddData.iCurDesc = -1;

        //
        // Copy the installwizard data.
        //
        CopyMemory(&(ndwData->InstallData),
                   InstallWizardData,
                   sizeof(SP_INSTALLWIZARD_DATA)
                  );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if((Err != NO_ERROR) && ndwData) {
        MyFree(ndwData);
    } else {
        *NewDeviceWizardData = ndwData;
    }

    return Err;
}


UINT
CALLBACK
SelectDevicePropSheetPageProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE ppsp
    )
/*++

Routine Description:

    This routine is called when the Select Device wizard page is created or
    destroyed.

Arguments:

    hwnd - Reserved

    uMsg - Action flag, either PSPCB_CREATE or PSPCB_RELEASE

    ppsp - Supplies the address of the PROPSHEETPAGE structure being created or
        destroyed.

Return Value:

    If uMsg is PSPCB_CREATE, then return non-zero to allow the page to be
    created, or zero to prevent it.

    if uMsg is PSPCB_RELEASE, the return value is ignored.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    UINT ret;
    PVOID WizObjectId;
    PWIZPAGE_OBJECT CurWizObject, PrevWizObject;

    //
    // Access the device info set handle stored in the propsheetpage's lParam.
    //
    if(!(pDeviceInfoSet = AccessDeviceInfoSet((HDEVINFO)(ppsp->lParam)))) {
        return FALSE;
    }

    ret = TRUE;

    try {
        //
        // The ObjectID (pointer, actually) for the corresponding wizard
        // object for this page is stored at the end of the ppsp structure.
        // Retrieve this now, and look for it in the devinfo set's list of
        // wizard objects.
        //
        WizObjectId = *((PVOID *)(&(((PBYTE)ppsp)[sizeof(PROPSHEETPAGE)])));

        for(CurWizObject = pDeviceInfoSet->WizPageList, PrevWizObject = NULL;
            CurWizObject;
            PrevWizObject = CurWizObject, CurWizObject = CurWizObject->Next) {

            if(WizObjectId == CurWizObject) {
                //
                // We found our object.
                //
                break;
            }
        }

        if(!CurWizObject) {
            ret = FALSE;
            leave;
        }

        switch(uMsg) {

            case PSPCB_CREATE :
                //
                // Fail the create if we've already been created once
                // (hopefully, this will never happen).
                //
                if(CurWizObject->RefCount) {
                    ret = FALSE;
                    leave;
                } else {
                    CurWizObject->RefCount++;
                }
                break;

            case PSPCB_RELEASE :
                //
                // Decrement the wizard object refcount.  If it goes to zero
                // (or if it already was zero because we never got a
                // PSPCB_CREATE message), then remove the object from the
                // linked list, and free all associated memory.
                //
                if(CurWizObject->RefCount) {
                    CurWizObject->RefCount--;
                }

                MYASSERT(!CurWizObject->RefCount);

                if(!CurWizObject->RefCount) {
                    //
                    // Remove the object from the object list.
                    //
                    if(PrevWizObject) {
                        PrevWizObject->Next = CurWizObject->Next;
                    } else {
                        pDeviceInfoSet->WizPageList = CurWizObject->Next;
                    }

                    //
                    // If this wizard object was explicitly tied to a
                    // particular device information element, then unlock that
                    // element now.
                    //
                    if((CurWizObject->ndwData->ddData.flags & DD_FLAG_USE_DEVINFO_ELEM) &&
                       (DevInfoElem = CurWizObject->ndwData->ddData.DevInfoElem)) {

                        MYASSERT(DevInfoElem->DiElemFlags & DIE_IS_LOCKED);

                        DevInfoElem->DiElemFlags ^= DIE_IS_LOCKED;
                    }

                    MyFree(CurWizObject->ndwData);
                    MyFree(CurWizObject);
                }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        ret = FALSE;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return ret;
}


INT_PTR
CALLBACK
SelectDeviceDlgProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    This is the dialog proc for the Select Device wizard page.

--*/
{
    INT iCur;
    HICON hicon;
    PNEWDEVWIZ_DATA ndwData;
    PSP_INSTALLWIZARD_DATA iwd;
    LV_ITEM lvItem;
    TCHAR TempString[LINE_LEN];
    PCLASSDRV_THREAD_CONTEXT ClassDrvThreadContext;
    HCURSOR hOldCursor;
    OSVERSIONINFOEX osVersionInfoEx;
    DWORD Err;

    if(uMsg == WM_INITDIALOG) {

        LPPROPSHEETPAGE Page = (LPPROPSHEETPAGE)lParam;

        //
        // Retrieve a pointer to the device wizard data associated with
        // this wizard page.
        //
        ndwData = GetNewDevWizDataFromPsPage(Page);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)ndwData);

        if(ndwData) {
            ndwData->bInit = TRUE;
            ndwData->idTimer = 0;
            ndwData->bInit = FALSE;
        } else {
            //
            // This is really bad--we can't simply call EndDialog() since we
            // don't know whether we're a dialog or a wizard page.  This should
            // never happen.
            //
            return TRUE;  // we didn't set the focus
        }

        if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
            //
            // For the stand-alone dialog box version, we initialize here.
            //
            ndwData->bInit = TRUE;       // Still doing some init stuff

            //
            // Make sure our "waiting for class list" static text control is
            // hidden!
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);

            if(!InitSelectDeviceDlg(hwndDlg, ndwData)) {
                //
                // We don't have any items displayed so ask the user if they
                // want to go directly to Have Disk, or just cancel.
                //
                PostMessage(hwndDlg, WMX_NO_DRIVERS_IN_LIST, 0, 0);
            }

            ndwData->bInit = FALSE;      // Done with init stuff

            return FALSE;   // we already set the focus.

        } else {
            return TRUE;    // we didn't set the focus
        }

    } else {
        //
        // For the small set of messages that we get before WM_INITDIALOG, we
        // won't have a devwizdata pointer!
        //
        if(ndwData = (PNEWDEVWIZ_DATA)GetWindowLongPtr(hwndDlg, DWLP_USER)) {
            iwd = &(ndwData->InstallData);
        } else {
            //
            // If we haven't gotten a WM_INITDIALOG message yet, or if for some
            // reason we weren't able to retrieve the ndwData pointer when we
            // did, then we simply return FALSE for all messages.
            //
            // (If we ever need to process messages before WM_INITDIALOG (e.g.,
            // set font), then we'll need to modify this approach.)
            //
            return FALSE;
        }
    }

    switch(uMsg) {

        case WMX_CLASSDRVLIST_DONE :

            MYASSERT(ndwData->ddData.AuxThreadRunning);
            ndwData->ddData.AuxThreadRunning = FALSE;

            //
            // wParam is a boolean indicating the result of the class driver
            // search.
            //
            // lParam is NO_ERROR upon success, or a Win32 error code
            // indicating cause of failure.
            //
            switch(ndwData->ddData.PendingAction) {

                case PENDING_ACTION_NONE :
                    //
                    // Then the thread has completed, but the user is still
                    // mulling over the choices on the compatible driver list.
                    // If the class driver list was successfully built, then
                    // there's nothing to do here.  If it failed for some
                    // reason (highly unlikely), then we (silently) disable the
                    // 'show compatible devices' check box.
                    if(!wParam) {
                        ndwData->ddData.flags |= DD_FLAG_CLASSLIST_FAILED;
                        EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), FALSE);
                    }
                    break;

                case PENDING_ACTION_SELDONE :
                    //
                    // In this case, we don't care what happened in the other
                    // thread.  The user has made their selection, and we're
                    // ready to return success.
                    //
                    SetSelectedDriverNode(&(ndwData->ddData),
                                          ndwData->ddData.CurSelectionForSuccess
                                         );
                    EndDialog(hwndDlg, NO_ERROR);
                    break;

                case PENDING_ACTION_SHOWCLASS :
                    //
                    // Then we've been waiting on the class driver search to
                    // complete, so that we can show the list.  Hopefully, the
                    // search was successful.  If not, we'll give the user a
                    // popup saying that the list could not be shown, and then
                    // leave them in the compatible list view (with the class
                    // list radio button now disabled).
                    //
                    ndwData->ddData.PendingAction = PENDING_ACTION_NONE;

                    if(wParam) {
                        //
                        // The class driver list was built successfully.
                        //
                        if(ndwData->ddData.CurSelectionForSuccess != LB_ERR) {

                            lvItem.mask = LVIF_TEXT;
                            lvItem.iItem = ndwData->ddData.CurSelectionForSuccess;
                            lvItem.iSubItem = 0;
                            lvItem.pszText = TempString;
                            lvItem.cchTextMax = SIZECHARS(TempString);

                            if(ListView_GetItem((ndwData->ddData).hwndDrvList, &lvItem)) {
                                //
                                // Now retrieve the (case-insensitive) string
                                // ID of this string, and store it as the
                                // current description ID.
                                //
                                (ndwData->ddData).iCurDesc = LookUpStringInDevInfoSet(
                                                                 (ndwData->ddData).DevInfoSet,
                                                                 TempString,
                                                                 FALSE
                                                                 );
                            }
                        }

                        ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);

                        if(FillInDeviceList(hwndDlg, &(ndwData->ddData)) == NO_ERROR) {
                            //
                            // Enable the OK/Next button
                            //
                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
                            } else {
                                if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                   ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                   !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                    //
                                    // No back if we skipped the Class list, and are in express mode
                                    //
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
                                } else {
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                                }
                            }

                            break;
                        }
                    }

                    //
                    // Inform the user that the class driver search failed.
                    //
                    if(!LoadString(MyDllModuleHandle,
                                   IDS_SELECT_DEVICE,
                                   TempString,
                                   SIZECHARS(TempString))) {
                        *TempString = TEXT('\0');
                    }

                    FormatMessageBox(MyDllModuleHandle,
                                     hwndDlg,
                                     MSG_NO_CLASSDRVLIST_ERROR,
                                     TempString,
                                     MB_OK | MB_TASKMODAL
                                    );

                    //
                    // Check the 'Show compatible devices' check box and then
                    // gray it out since the user cannot uncheck it since we
                    // don't have a class list.
                    //
                    CheckDlgButton(hwndDlg, IDC_NDW_PICKDEV_COMPAT, BST_CHECKED);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), FALSE);
                    ndwData->ddData.bShowCompat = TRUE;
                    ndwData->ddData.flags |= DD_FLAG_CLASSLIST_FAILED;

                    //
                    // We also must unhide the compatible driver list controls,
                    // and re-enable the OK button.
                    //
                    ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_SHOW);
                    if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                        EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
                    } else {
                        if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                           ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                           !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                            //
                            // No back if we skipped the Class list, and are in
                            // express mode
                            //
                            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
                        } else {
                            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                        }
                    }

                    break;

                case PENDING_ACTION_CANCEL :
                    //
                    // This is an easy one.  No matter what happened in the
                    // other thread, we simply want to clean up and return.
                    //
                    OnCancel(ndwData);
                    EndDialog(hwndDlg, ERROR_CANCELLED);
                    break;

                case PENDING_ACTION_OEM :
                case PENDING_ACTION_WINDOWSUPDATE:

                    if(ndwData->ddData.PendingAction == PENDING_ACTION_OEM) {
                       
                        Err = HandleSelectOEM(hwndDlg, ndwData);

                        if (Err == NO_ERROR) {
                            //
                            // The class installer picked a driver for the
                            // user automatically, so just end the dialog or
                            // go to the next wizard page.
                            //
                            ndwData->ddData.PendingAction = PENDING_ACTION_NONE;
    
                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                EndDialog(hwndDlg, NO_ERROR);
                            } else {
                                iwd->Flags |= NDW_INSTALLFLAG_CI_PICKED_OEM;
                                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
                            }
    
                            break;
                        }
                    } else {
                        //
                        // Call HandleWindowsUpdate.  If this API succeeds
                        // then it will fill in the existing list control with
                        // the Windows Update drivers.
                        //
                        Err = HandleWindowsUpdate(hwndDlg, ndwData); 
                    }

                    ToggleDialogControls(hwndDlg, ndwData, TRUE);

                    if ((Err == NO_ERROR) ||
                        (Err == ERROR_DI_DO_DEFAULT)) {
                        //
                        // If HandleSelectOEM or HandleWindowsUpdate returned
                        // NO_ERROR or ERROR_DI_DO_DEFAULT then they have
                        // updated the existing listbox of drivers, so there
                        // is no need to fire up the class driver list thread
                        // again.
                        //
                        ndwData->ddData.PendingAction = PENDING_ACTION_NONE;
                    } else {
                        //
                        // HandleSelectOEM or HandleWindowsUpdate returned some
                        // other error, so the dialog needs to be put back to
                        // the state it was in before the user pressed the 
                        // button.  This includes starting up the class driver
                        // search thread again, if needed.
                        //
                        if(ndwData->ddData.bShowCompat) {
                            ndwData->ddData.PendingAction = PENDING_ACTION_NONE;
                        } else {
                            ndwData->ddData.PendingAction = PENDING_ACTION_SHOWCLASS;
                        }
    
                        ndwData->bInit = FALSE;
    
                        //
                        // We got here by aborting the class driver search.
                        // Since we may need it after all, we must re-start the
                        // search (unless the auxilliary thread happened to
                        // have already finished before we sent it the abort
                        // request).
                        //
                        if(!(ndwData->ddData.flags & DD_FLAG_CLASSLIST_FAILED) &&
                           !pSetupIsClassDriverListBuilt(&(ndwData->ddData)))
                        {
                            //
                            // Allocate a context structure to pass to the
                            // auxilliary thread (the auxilliary thread will
                            // take care of freeing the memory).
                            //
                            if(ClassDrvThreadContext = MyMalloc(sizeof(CLASSDRV_THREAD_CONTEXT))) {
    
                                try {
                                    //
                                    // Fill in the context structure, and fire
                                    // off the thread.
                                    //
                                    ClassDrvThreadContext->DeviceInfoSet =
                                                    ndwData->ddData.DevInfoSet;
    
                                    //
                                    // SP_DEVINFO_DATA can only be retrieved
                                    // whilst the device information set is
                                    // locked.
                                    //
                                    pSetupDevInfoDataFromDialogData(
                                        &(ndwData->ddData),
                                        &(ClassDrvThreadContext->DeviceInfoData)
                                        );
    
                                    ClassDrvThreadContext->NotificationWindow = hwndDlg;
    
                                    if(_beginthread(ClassDriverSearchThread, 0, ClassDrvThreadContext) == -1) {
                                        MyFree(ClassDrvThreadContext);
                                        ClassDrvThreadContext = NULL;
                                    } else {
                                        //
                                        // Our class driver search context has
                                        // been officially handed off to the
                                        // thread we just created.  Reset our
                                        // pointer so we won't try to free this
                                        // later.
                                        //
                                        ClassDrvThreadContext = NULL;
    
                                        ndwData->ddData.AuxThreadRunning = TRUE;
    
                                        //
                                        // If we're currently in the class
                                        // driver list view, then disable the
                                        // OK/Next button, since the user can't
                                        // select a class driver yet.
                                        //
                                        if(!ndwData->ddData.bShowCompat) {
    
                                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                                EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
                                            } else {
                                                if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                                   ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                                   !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                                    //
                                                    // No back if we skipped
                                                    // the Class list, and are
                                                    // in express mode
                                                    //
                                                    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
                                                } else {
                                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                                                }
                                            }
                                        }
                                    }
    
                                } except(pSetupExceptionFilter(GetExceptionCode())) {
    
                                    pSetupExceptionHandler(GetExceptionCode(),
                                                           ERROR_INVALID_PARAMETER,
                                                           NULL
                                                          );
    
                                    if(ClassDrvThreadContext) {
                                        MyFree(ClassDrvThreadContext);
                                    }
                                }
                            }
    
                            if(!(ndwData->ddData.AuxThreadRunning)) {
                                //
                                // We couldn't start the class driver search
                                // thread.  Check and disable the 'Show
                                // compatible devices' check box.
                                //
                                if(!ndwData->ddData.bShowCompat) {
                                    CheckDlgButton(hwndDlg,
                                                   IDC_NDW_PICKDEV_COMPAT,
                                                   BST_CHECKED
                                                  );
                                }
    
                                ndwData->ddData.flags |= DD_FLAG_CLASSLIST_FAILED;
                                EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), FALSE);
                            }
                        }
                    }

                    break;
            }

            break;

        case WMX_NO_DRIVERS_IN_LIST: {

            TCHAR Title[LINE_LEN];

            if(!LoadString(MyDllModuleHandle, IDS_SELECT_DEVICE, Title, SIZECHARS(Title))) {
                Title[0]=TEXT('\0');
            }
            if(!LoadString(MyDllModuleHandle, IDS_NDW_NODRIVERS_WARNING, TempString, SIZECHARS(TempString))) {
                TempString[0]=TEXT('\0');
            }

            if(IDOK == MessageBox(hwndDlg, TempString, Title, MB_OKCANCEL | MB_ICONEXCLAMATION)) {
                PostMessage(hwndDlg, WM_COMMAND, IDC_NDW_PICKDEV_HAVEDISK, 0);
            } else {
                PostMessage(hwndDlg, WM_COMMAND, IDCANCEL, 0);
            }

            break;
        }

        case WM_DESTROY:

            if(ndwData->ddData.AuxThreadRunning) {
                //
                // This should never happen.  But just to be on the safe side,
                // if it does, we'll cancel the search.  We _will not_ however,
                // wait for the WMX_CLASSDRVLIST_DONE message, to signal that
                // the thread has terminated.  This should be OK, since the
                // worst that can happen is that it will try to send a message
                // to a window that no longer exists.
                //
                SetupDiCancelDriverInfoSearch(ndwData->ddData.DevInfoSet);
            }

            if(ndwData->idTimer) {
                ndwData->bInit = TRUE;
                KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
            }

            if(hicon = (HICON)SendDlgItemMessage(hwndDlg, IDC_CLASSICON, STM_GETICON, 0, 0)) {
                DestroyIcon(hicon);
            }

            if(hicon = (HICON)SendDlgItemMessage(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON, STM_GETICON, 0, 0)) {
                DestroyIcon(hicon);
            }

            if(ndwData->ddData.hImageList) {
                ImageList_Destroy(ndwData->ddData.hImageList);
            }

            if(ndwData->ddData.hFontNormal) {
                DeleteObject(ndwData->ddData.hFontNormal);
            }

            if(ndwData->ddData.hFontBold) {
                DeleteObject(ndwData->ddData.hFontBold);
            }
            break;

        case WM_COMMAND:

            switch(LOWORD(wParam)) {

                case IDC_NDW_PICKDEV_COMPAT:

                    if((HIWORD(wParam) == BN_CLICKED) &&
                       IsWindowVisible(GetDlgItem(hwndDlg, LOWORD(wParam)))) {

                        ndwData->ddData.bShowCompat = IsDlgButtonChecked(hwndDlg, IDC_NDW_PICKDEV_COMPAT);

                        //
                        // Update the current description ID in the dialog data
                        // so that the same device will be highlighted when we
                        // switch from one view to the other.
                        //
                        iCur = (int)ListView_GetNextItem((ndwData->ddData).hwndDrvList,
                                                         -1,
                                                         LVNI_SELECTED
                                                        );

                        if(ndwData->ddData.AuxThreadRunning) {
                            //
                            // There are two possibilities here:
                            //
                            // 1. The user was looking at the compatible driver
                            //    list, and then decided to look at the class
                            //    driver list, which we're not done building
                            //    yet.  In that case, hide the compatible
                            //    driver listbox, and unhide our "waiting for
                            //    class list" static text control.
                            //
                            // 2. The user switched to the class driver list
                            //    view, saw that we were still working on it,
                            //    and then decided to switch back to the
                            //    compatible list.  In that case, we simply
                            //    need to re-hide the "waiting for class list"
                            //    static text control, and show the compatible
                            //    driver listbox again.  In this case, we don't
                            //    want to attempt to re-initialize the listbox,
                            //    as that will require acquiring the HDEVINFO
                            //    lock, and we will hang.
                            //
                            if(ndwData->ddData.bShowCompat) {

                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_SHOW);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), SW_SHOW);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), SW_SHOW);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK), SW_SHOW);
                                if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                    EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
                                } else {
                                    if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                       ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                       !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                        //
                                        // No back if we skipped the Class
                                        // list, and are in express mode
                                        //
                                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
                                    } else {
                                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                                    }
                                }

                                //
                                // We no longer have a pending action.
                                //
                                ndwData->ddData.PendingAction = PENDING_ACTION_NONE;

                            } else {
                                //
                                // Temporarily hide the compatible driver
                                // listbox, and unhide the "waiting for class
                                // list" static text control.
                                //
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_HIDE);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), SW_HIDE);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), SW_HIDE);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK), SW_HIDE);
                                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_SHOW);

                                if(!LoadString(MyDllModuleHandle, IDS_NDW_RETRIEVING_LIST, TempString, SIZECHARS(TempString))) {
                                    TempString[0]=TEXT('\0');
                                }
                                SetDlgItemText(hwndDlg, IDC_NDW_STATUS_TEXT, TempString);

                                //
                                // Disable the OK/Next button, because the user
                                // can't select a class driver yet.
                                //
                                if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                    EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
                                } else {
                                    if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                       ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                       !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                        //
                                        // No back if we skipped the Class
                                        // list, and are in express mode
                                        //
                                        PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
                                    } else {
                                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                                    }
                                }

                                MYASSERT(ndwData->ddData.PendingAction == PENDING_ACTION_NONE);

                                ndwData->ddData.PendingAction = PENDING_ACTION_SHOWCLASS;
                                ndwData->ddData.CurSelectionForSuccess = iCur;
                            }

                        } else {

                            if(iCur != LB_ERR) {

                                lvItem.mask = LVIF_TEXT;
                                lvItem.iItem = iCur;
                                lvItem.iSubItem = 0;
                                lvItem.pszText = TempString;
                                lvItem.cchTextMax = SIZECHARS(TempString);

                                if(ListView_GetItem((ndwData->ddData).hwndDrvList, &lvItem)) {
                                    //
                                    // Now retrieve the (case-insensitive)
                                    // string ID of this string, and store it
                                    // as the current description ID.
                                    //
                                    (ndwData->ddData).iCurDesc =
                                        LookUpStringInDevInfoSet((ndwData->ddData).DevInfoSet,
                                                                 TempString,
                                                                 FALSE
                                                                );
                                }
                            }

                            FillInDeviceList(hwndDlg, &(ndwData->ddData));

                            //
                            // If we just filled in the compatible driver list,
                            // then make sure there isn't a timer waiting to
                            // pounce and destroy our list!
                            //
                            if((ndwData->ddData.bShowCompat) &&
                               (ndwData->idTimer)) {

                                KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                                ndwData->idTimer = 0;
                            }
                        }
                    }
                    break;

                case IDC_NDW_PICKDEV_HAVEDISK :
                    //
                    // If we're doing a dialog box, then pressing "Have Disk"
                    // will popup another Select Device dialog.  Disable all
                    // controls on this one first, to avoid user confusion.
                    //
                    ToggleDialogControls(hwndDlg, ndwData, FALSE);

                    //
                    // If HandleSelectOEM returns success, we are done, and can
                    // either end the dialog, or proceed to the next wizard
                    // page.
                    //
                    if(ndwData->ddData.AuxThreadRunning) {
                        //
                        // The auxilliary thread is still running.  Set our
                        // cursor to an hourglass, and set our pending action
                        // to be OEM Select while we wait for the thread to
                        // respond to our cancel request.
                        //
                        MYASSERT((ndwData->ddData.PendingAction == PENDING_ACTION_NONE) ||
                                 (ndwData->ddData.PendingAction == PENDING_ACTION_SHOWCLASS));

                        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                        try {

                            SetupDiCancelDriverInfoSearch(ndwData->ddData.DevInfoSet);
                            //
                            // Disable all dialog controls, so that no other
                            // button may be pressed until we respond to this
                            // pending action.  Also, kill the timer, so that
                            // it doesn't fire in the meantime.
                            //
                            ndwData->bInit = TRUE;
                            if(ndwData->idTimer) {
                                KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                                ndwData->idTimer = 0;
                            }
                            ndwData->ddData.PendingAction = PENDING_ACTION_OEM;

                        } except(pSetupExceptionFilter(GetExceptionCode())) {
                            pSetupExceptionHandler(GetExceptionCode(),
                                                   ERROR_INVALID_PARAMETER,
                                                   NULL
                                                  );
                        }

                        SetCursor(hOldCursor);

                    } else {

                        if(HandleSelectOEM(hwndDlg, ndwData) == NO_ERROR) {

                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                EndDialog(hwndDlg, NO_ERROR);
                            } else {
                                iwd->Flags |= NDW_INSTALLFLAG_CI_PICKED_OEM;
                                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
                            }

                        } else {
                            //
                            // The user didn't make an OEM selection, so we
                            // need to re-enable the controls on our dialog or
                            // wizard.
                            //
                            ToggleDialogControls(hwndDlg, ndwData, TRUE);
                        }
                    }
                    break;

                case IDC_NDW_PICKDEV_WINDOWSUPDATE:
                    //
                    // If we're doing a dialog box, then pressing "Have Disk"
                    // will popup another Select Device dialog.  Disable all
                    // controls on this one first, to avoid user confusion.
                    //
                    ToggleDialogControls(hwndDlg, ndwData, FALSE);

                    if(ndwData->ddData.AuxThreadRunning) {
                        //
                        // The auxilliary thread is still running.  Set our
                        // cursor to an hourglass, and set our pending action
                        // to be Windows Update Select while we wait for the
                        // thread to respond to our cancel request.
                        //
                        MYASSERT((ndwData->ddData.PendingAction == PENDING_ACTION_NONE) ||
                                 (ndwData->ddData.PendingAction == PENDING_ACTION_SHOWCLASS));

                        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                        try {

                            SetupDiCancelDriverInfoSearch(ndwData->ddData.DevInfoSet);
                            //
                            // Disable all dialog controls, so that no other
                            // button may be pressed until we respond to this
                            // pending action.  Also, kill the timer, so that
                            // it doesn't fire in the meantime.
                            //
                            ndwData->bInit = TRUE;
                            if(ndwData->idTimer) {
                                KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                                ndwData->idTimer = 0;
                            }
                            ndwData->ddData.PendingAction = PENDING_ACTION_WINDOWSUPDATE;

                        } except(pSetupExceptionFilter(GetExceptionCode())) {
                            pSetupExceptionHandler(GetExceptionCode(),
                                                   ERROR_INVALID_PARAMETER,
                                                   NULL
                                                  );
                        }

                        SetCursor(hOldCursor);

                    } else {
                        //
                        // Call Windows Update to get an updated list of drivers
                        // to populate our listview control with, and then
                        // reenable the dialog controls.
                        //
                        HandleWindowsUpdate(hwndDlg, ndwData);
                        ToggleDialogControls(hwndDlg, ndwData, TRUE);
                    }
                    break;

                case IDOK :
HandleOK:
                    iCur = (int)ListView_GetNextItem((ndwData->ddData).hwndDrvList,
                                                     -1,
                                                     LVNI_SELECTED
                                                    );
                    if(iCur != LB_ERR) {
                        //
                        // We have retrieved a valid selection from our listbox.
                        //
                        if(ndwData->ddData.AuxThreadRunning) {
                            //
                            // The auxilliary thread is still running.  Set our
                            // cursor to an hourglass, while we wait for the
                            // thread to terminate.
                            //
                            MYASSERT((ndwData->ddData.PendingAction == PENDING_ACTION_NONE) ||
                                     (ndwData->ddData.PendingAction == PENDING_ACTION_SHOWCLASS));

                            hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                            try {

                                SetupDiCancelDriverInfoSearch(ndwData->ddData.DevInfoSet);
                                //
                                // Disable all dialog controls, so that no
                                // other button may be pressed until we respond
                                // to this pending action.  Also, kill the
                                // timer, so that it doesn't fire in the
                                // meantime.
                                //
                                ToggleDialogControls(hwndDlg, ndwData, FALSE);
                                ndwData->bInit = TRUE;
                                if(ndwData->idTimer) {
                                    KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                                    ndwData->idTimer = 0;
                                }
                                ndwData->ddData.PendingAction = PENDING_ACTION_SELDONE;
                                ndwData->ddData.CurSelectionForSuccess = iCur;

                            } except(pSetupExceptionFilter(GetExceptionCode())) {
                                pSetupExceptionHandler(GetExceptionCode(),
                                                       ERROR_INVALID_PARAMETER,
                                                       NULL
                                                      );
                            }

                            SetCursor(hOldCursor);

                        } else {
                            //
                            // The auxilliary thread has already returned. We
                            // can return success right here.
                            //
                            SetSelectedDriverNode(&(ndwData->ddData), iCur);
                            EndDialog(hwndDlg, NO_ERROR);
                        }

                    } else {
                        //
                        // If the list box is empty, then just leave. We will
                        // treat this just like the user canceled.
                        //
                        if(0 == ListView_GetItemCount((ndwData->ddData).hwndDrvList)) {

                            PostMessage(hwndDlg, WM_COMMAND, IDCANCEL, 0);

                        } else {
                            //
                            // Tell user to select something since there are
                            // items in the list
                            //
                            if(!LoadString(MyDllModuleHandle,
                                           IDS_SELECT_DEVICE,
                                           TempString,
                                           SIZECHARS(TempString))) {
                                *TempString = TEXT('\0');
                            }

                            FormatMessageBox(MyDllModuleHandle,
                                             hwndDlg,
                                             MSG_SELECTDEVICE_ERROR,
                                             TempString,
                                             MB_OK | MB_ICONEXCLAMATION
                                            );
                        }
                    }
                    break;

                case IDCANCEL :

                    if(ndwData->ddData.AuxThreadRunning) {
                        //
                        // The auxilliary thread is running, so we have to ask
                        // it to cancel, and set our pending action to do the
                        // cancel upon the thread's termination notification.
                        //
                        MYASSERT((ndwData->ddData.PendingAction == PENDING_ACTION_NONE) ||
                                 (ndwData->ddData.PendingAction == PENDING_ACTION_SHOWCLASS));

                        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                        try {

                            SetupDiCancelDriverInfoSearch(ndwData->ddData.DevInfoSet);
                            //
                            // Disable all dialog controls, so that no other
                            // button may be pressed until we respond to this
                            // pending action.  Also, kill the timer, so that
                            // it doesn't fire in the meantime.
                            //
                            ToggleDialogControls(hwndDlg, ndwData, FALSE);
                            ndwData->bInit = TRUE;
                            if(ndwData->idTimer) {
                                KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                                ndwData->idTimer = 0;
                            }
                            ndwData->ddData.PendingAction = PENDING_ACTION_CANCEL;

                        } except(pSetupExceptionFilter(GetExceptionCode())) {
                            pSetupExceptionHandler(GetExceptionCode(),
                                                   ERROR_INVALID_PARAMETER,
                                                   NULL
                                                  );
                        }

                        SetCursor(hOldCursor);

                    } else {
                        //
                        // The auxilliary thread isn't running, so we can
                        // return right here.
                        //
                        OnCancel(ndwData);
                        EndDialog(hwndDlg, ERROR_CANCELLED);
                    }
                    break;

                default :
                    return FALSE;
            }
            break;

        case WM_NOTIFY :

            switch(((LPNMHDR)lParam)->code) {

                case PSN_SETACTIVE :
                    //
                    // Init the text in set active since a class installer has
                    // the option of replacing it.
                    //
                    SetDlgText(hwndDlg, IDC_NDW_TEXT, IDS_NDW_PICKDEV1, IDS_NDW_PICKDEV1);

                    ndwData->bInit = TRUE;       // Still doing some init stuff

                    if(!OnSetActive(hwndDlg, ndwData)) {
                        SetDlgMsgResult(hwndDlg, uMsg, -1);
                    }

                    ndwData->bInit = FALSE;      // Done with init stuff
                    break;

                case PSN_WIZBACK :
                    CleanupDriverLists(ndwData);

                    if(iwd->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {
                        SetDlgMsgResult(hwndDlg, uMsg, IDD_DYNAWIZ_SELECT_PREVPAGE);
                    } else {
                        SetDlgMsgResult(hwndDlg, uMsg, IDD_DYNAWIZ_SELECTCLASS_PAGE);
                    }
                    break;

                case PSN_WIZNEXT :
                    if(!(iwd->Flags & NDW_INSTALLFLAG_CI_PICKED_OEM)) {

                        iCur = (int)ListView_GetNextItem((ndwData->ddData).hwndDrvList,
                                                         -1,
                                                         LVNI_SELECTED
                                                        );
                        if(iCur != LB_ERR) {
                            //
                            // We have retrieved a valid selection from our
                            // listbox.
                            //
                            if (pSetupIsSelectedHardwareIdValid(hwndDlg, &(ndwData->ddData), iCur)) {
                                SetSelectedDriverNode(&(ndwData->ddData), iCur);
                            } else {
                                SetDlgMsgResult(hwndDlg, uMsg, (LRESULT)-1);
                                break;
                            }

                        } else {        // Invalid Listview selection
                            //
                            // Fail the call and end the case
                            //
                            SetDlgMsgResult(hwndDlg, uMsg, (LRESULT)-1);
                            break;
                        }
                    }

                    //
                    // Update the current description in the dialog data so
                    // that we'll hi-lite the correct selection if the user
                    // comes back to this page.
                    //
                    (ndwData->ddData).iCurDesc = GetCurDesc(&(ndwData->ddData));

                    if(iwd->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {
                        SetDlgMsgResult(hwndDlg, uMsg, IDD_DYNAWIZ_SELECT_NEXTPAGE);
                    } else {
                        SetDlgMsgResult(hwndDlg, uMsg, IDD_DYNAWIZ_ANALYZEDEV_PAGE);
                    }
                    break;

                case LVN_ITEMCHANGED :
                    //
                    // If the idFrom is the MFG list, then update the Drv list.
                    //
                    if(((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_MFGLIST) && !ndwData->bInit) {

                        if(ndwData->idTimer) {
                            KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
                        }

                        ndwData->idTimer = SetTimer(hwndDlg,
                                                    SELECTMFG_TIMER_ID,
                                                    SELECTMFG_TIMER_DELAY,
                                                    NULL
                                                   );

                        if(ndwData->idTimer == 0) {
                            goto SelectMfgItemNow;
                        }
                    }

                    //
                    // If the idFrom is either of the model lists then update
                    // the digital signature icon and text.
                    //
                    if(((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_ONEMFG_DRVLIST) ||
                       ((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_DRVLIST)) {

                        LVITEM lviItem;
                        int iImage = -1;

                        hicon = NULL;

                        iCur = (int)ListView_GetNextItem((ndwData->ddData).hwndDrvList,
                                                         -1,
                                                         LVNI_SELECTED
                                                        );

                        if(iCur != -1) {
                            //
                            // We have retrieved a valid selection from our
                            // listbox.
                            //
                            lviItem.mask = LVIF_IMAGE;
                            lviItem.iItem = iCur;
                            lviItem.iSubItem = 0;

                            if(ListView_GetItem((ndwData->ddData).hwndDrvList, &lviItem)) {
                                iImage = lviItem.iImage;
                            }
                        }

                        if(iImage != -1) {
                            //
                            // Enable the OK/Next button, because there's
                            // currently an item selected in the model list.
                            //
                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
                            } else {
                                if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                   ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                   !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                    //
                                    // No back if we skipped the Class list,
                                    // and are in express mode
                                    //
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
                                } else {
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                                }
                            }

                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), SW_SHOW);
                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), SW_SHOW);

                            //
                            // Don't show the link if we are in GUI setup
                            // because help center is not installed yet and so
                            // clicking on the link won't do anything.
                            //
                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK),
                                       GuiSetupInProgress ? SW_HIDE : SW_SHOW);

                            hicon = NULL;

                            try {

                                if(iImage == IMAGE_ICON_SIGNED) {
                                    //
                                    // Load the digital signature icon and text
                                    //
                                    hicon = LoadImage(MyDllModuleHandle,
                                                      MAKEINTRESOURCE(IDI_SIGNED),
                                                      IMAGE_ICON,
                                                      GetSystemMetrics(SM_CXSMICON),
                                                      GetSystemMetrics(SM_CYSMICON),
                                                      0
                                                      );

                                    if(!LoadString(MyDllModuleHandle,
                                                   IDS_DRIVER_IS_SIGNED,
                                                   TempString,
                                                   SIZECHARS(TempString))) {
                                        *TempString = TEXT('\0');
                                    }

                                    if((ndwData->ddData).hFontNormal) {
                                        SetWindowFont(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), (ndwData->ddData).hFontNormal, TRUE);
                                    }
                                } else if(iImage == IMAGE_ICON_AUTHENTICODE_SIGNED) {
                                    //
                                    // Load the digital signature icon and text
                                    //
                                    hicon = LoadImage(MyDllModuleHandle,
                                                      MAKEINTRESOURCE(IDI_CERT),
                                                      IMAGE_ICON,
                                                      GetSystemMetrics(SM_CXSMICON),
                                                      GetSystemMetrics(SM_CYSMICON),
                                                      0
                                                      );

                                    if(!LoadString(MyDllModuleHandle,
                                                   IDS_DRIVER_AUTHENTICODE_SIGNED,
                                                   TempString,
                                                   SIZECHARS(TempString))) {
                                        *TempString = TEXT('\0');
                                    }

                                    if((ndwData->ddData).hFontNormal) {
                                        SetWindowFont(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), (ndwData->ddData).hFontNormal, TRUE);
                                    }
                                } else {
                                    //
                                    // Load the warning icon and text
                                    //
                                    hicon = LoadImage(MyDllModuleHandle,
                                                      MAKEINTRESOURCE(IDI_WARN),
                                                      IMAGE_ICON,
                                                      GetSystemMetrics(SM_CXSMICON),
                                                      GetSystemMetrics(SM_CYSMICON),
                                                      0
                                                      );

                                    if(!LoadString(MyDllModuleHandle,
                                                   IDS_DRIVER_NOT_SIGNED,
                                                   TempString,
                                                   SIZECHARS(TempString))) {
                                        *TempString = TEXT('\0');
                                    }

                                    if((ndwData->ddData).hFontBold) {
                                        SetWindowFont(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), (ndwData->ddData).hFontBold, TRUE);
                                    }
                                }

                                if(hicon) {
                                    hicon = (HICON)SendDlgItemMessage(hwndDlg,
                                                                      IDC_NDW_PICKDEV_SIGNED_ICON,
                                                                      STM_SETICON,
                                                                      (WPARAM)hicon,
                                                                      0L
                                                                      );
                                }

                            } except(pSetupExceptionFilter(GetExceptionCode())) {
                                pSetupExceptionHandler(GetExceptionCode(),
                                                       ERROR_INVALID_PARAMETER,
                                                       NULL
                                                      );
                            }

                            if(hicon) {
                                DestroyIcon(hicon);
                            }

                            SetDlgItemText(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT, TempString);

                        } else {
                            //
                            // Nothing is selected so hide the icon and the
                            // text.
                            //
                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), SW_HIDE);
                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), SW_HIDE);
                            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK), SW_HIDE);

                            //
                            // Disable the OK/Next button, because the user
                            // can't select a class driver yet.
                            //
                            if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                                EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
                            } else {
                                if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                                   ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                                   !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                                    //
                                    // No back if we skipped the Class list,
                                    // and are in express mode
                                    //
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
                                } else {
                                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                                }
                            }
                        }
                    }

                    break;

                case NM_RETURN:
                case NM_CLICK:
                    if((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_SIGNED_LINK) {
                        //
                        // We need to know if this is a server machine or a
                        // workstation machine since there are different help
                        // topic structures for the different products.
                        //
                        ZeroMemory(&osVersionInfoEx, sizeof(osVersionInfoEx));
                        osVersionInfoEx.dwOSVersionInfoSize = sizeof(osVersionInfoEx);
                        if(!GetVersionEx((LPOSVERSIONINFO)&osVersionInfoEx)) {
                            //
                            // If GetVersionEx fails then assume this is a
                            // workstation machine.
                            //
                            osVersionInfoEx.wProductType = VER_NT_WORKSTATION;
                        }

                        ShellExecute(hwndDlg,
                                     TEXT("open"),
                                     TEXT("HELPCTR.EXE"),
                                     (osVersionInfoEx.wProductType == VER_NT_WORKSTATION)
                                        ? TEXT("HELPCTR.EXE -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm")
                                        : TEXT("HELPCTR.EXE -url hcp://services/subsite?node=Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm"),
                                     NULL,
                                     SW_SHOWNORMAL
                                     );
                    }
                    break;

                case NM_DBLCLK :
                    if(((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_DRVLIST) ||
                       ((((LPNMHDR)lParam)->idFrom) == IDC_NDW_PICKDEV_ONEMFG_DRVLIST)) {

                        if(ndwData->ddData.flags & DD_FLAG_IS_DIALOGBOX) {
                            goto HandleOK;
                        } else {
                            PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
                        }
                    }
                    break;
            }

            break;

        case WM_TIMER :
            KillTimer(hwndDlg, SELECTMFG_TIMER_ID);
            ndwData->idTimer = 0;

SelectMfgItemNow:
            iCur = ListView_GetNextItem((ndwData->ddData).hwndMfgList,
                                        -1,
                                        LVNI_SELECTED
                                       );
            if(iCur != -1) {

                RECT rcTo, rcFrom;

                ListView_EnsureVisible((ndwData->ddData).hwndMfgList, iCur, FALSE);
                UpdateWindow((ndwData->ddData).hwndMfgList);

                GetWindowRect((ndwData->ddData).hwndDrvList, &rcTo);
                MapWindowPoints(NULL, hwndDlg, (LPPOINT)&rcTo, 2);

                ListView_GetItemRect((ndwData->ddData).hwndMfgList,
                                     iCur,
                                     &rcFrom,
                                     LVIR_LABEL
                                    );
                MapWindowPoints((ndwData->ddData).hwndMfgList,
                                hwndDlg,
                                (LPPOINT)&rcFrom,
                                2
                               );

                DrawAnimatedRects(hwndDlg, IDANI_OPEN, &rcFrom, &rcTo);
                LockAndShowListForMfg(&(ndwData->ddData), iCur);
            }
            break;

        case WM_SYSCOLORCHANGE :
            _OnSysColorChange(hwndDlg, wParam, lParam);
            break;

        case WM_HELP:      // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle,
                    SELECTDEVICE_HELP,
                    HELP_WM_HELP,
                    (ndwData->ddData.flags & DD_FLAG_SHOWSIMILARDRIVERS) ?
                    (ULONG_PTR)SelectDeviceShowSimilarHelpIDs :
                    (ULONG_PTR)SelectDeviceShowAllHelpIDs
                    );
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam,
                    SELECTDEVICE_HELP,
                    HELP_CONTEXTMENU,
                    (ndwData->ddData.flags & DD_FLAG_SHOWSIMILARDRIVERS) ?
                    (ULONG_PTR)SelectDeviceShowSimilarHelpIDs :
                    (ULONG_PTR)SelectDeviceShowAllHelpIDs
                    );
            break;

        default :

            if(!g_uQueryCancelAutoPlay) {
                g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
            }

            if(uMsg == g_uQueryCancelAutoPlay) {
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, 1 );
                return 1;       // cancel auto-play
            }

            return FALSE;
    }

    return TRUE;
}


INT CALLBACK
DriverNodeCompareProc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
/*++

Routine Description:

    This routine is the callback for the list control sorting that is done when
    ListView_SortItems is called.

    The sorting this routine does is that if a DriverNode has the
    DNF_INF_IS_SIGNED flag then it is considered better than a DriverNode that
    does not have this flag. If both DriverNodes have, or don't have, this
    flag then a simple string compare is done.

Return Value:

    -1 if lParam1 is better than lParam2 (should be higher in the ListControl
    +1 if lParam2 is better than lParam1 (should be higher in the ListControl
    0  if lParam1 and lParam2 are the same

--*/
{
    if((((PDRIVER_NODE)lParam1)->Flags & DNF_INF_IS_SIGNED) &&
       !(((PDRIVER_NODE)lParam2)->Flags & DNF_INF_IS_SIGNED)) {

        return -1;
    }

    if((((PDRIVER_NODE)lParam2)->Flags & DNF_INF_IS_SIGNED) &&
       !(((PDRIVER_NODE)lParam1)->Flags & DNF_INF_IS_SIGNED)) {

        return 1;
    }

    //
    // At this point both driver nodes are signed or both are not signed, so
    // compare based on their description.
    //
    return (lstrcmpi(pStringTableStringFromId(((PDEVICE_INFO_SET)lParamSort)->StringTable,
                                              ((PDRIVER_NODE)lParam1)->DevDescriptionDisplayName),
                     pStringTableStringFromId(((PDEVICE_INFO_SET)lParamSort)->StringTable,
                                              ((PDRIVER_NODE)lParam2)->DevDescriptionDisplayName)));
}


VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    This routine notifies all child windows of the specified window when there
    is a system color change.

Return Value:

    None.

--*/
{
    HWND hChildWnd;

    hChildWnd = GetWindow(hWnd, GW_CHILD);

    while(hChildWnd != NULL) {
        SendMessage(hChildWnd, WM_SYSCOLORCHANGE, wParam, lParam);
        hChildWnd = GetWindow(hChildWnd, GW_HWNDNEXT);
    }
}


DWORD
FillInDeviceList(
    IN HWND           hwndDlg,
    IN PSP_DIALOGDATA lpdd
    )
/*++

Routine Description:

    This routine sets the dialog to have the appropriate description strings.
    It also alternates dialog between showing the manufacturer "double list"
    and the single list.   This is done by showing/hiding overlapping listview.

    NOTE:  DO NOT CALL THIS ROUTINE WHILE ANOTHER THREAD IS BUSY BUILDING A
    CLASS DRIVER LIST.  WE WILL HANG HERE UNTIL THE OTHER THREAD COMPLETES!!!!

Arguments:

    hwndDlg - Supplies the handle of the dialog window.

    lpdd - Supplies the address of a dialog data buffer containing parameters
        to be used in filling in the device list.

Return Value:

    If success, the return value is NO_ERROR, otherwise, it is a Win32 code.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDRIVER_NODE DriverNodeHead, CurDriverNode;
    DWORD DriverNodeType;
    LONG MfgNameId;
    INT i;
    LPTSTR lpszMfg;
    LV_COLUMN lvcCol;
    LV_ITEM lviItem;
    BOOL bDidDrvList = FALSE;
    PDEVINSTALL_PARAM_BLOCK dipb;
    DWORD Err = NO_ERROR;
    TCHAR szBuf[LINE_LEN];
    TCHAR szMessage[MAX_INSTRUCTION_LEN];
    TCHAR szText[SDT_MAX_TEXT];
    LPTSTR lpszText;
    size_t szTextSize;
    CONST GUID *ClassGuid;
    HRESULT hr;
    BOOL TurnRedrawBackOn = FALSE;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return ERROR_INVALID_HANDLE;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            dipb = &(DevInfoElem->InstallParamBlock);
            ClassGuid = &(DevInfoElem->ClassGuid);

            if(lpdd->bShowCompat) {
                DriverNodeHead = DevInfoElem->CompatDriverHead;
                DriverNodeType = SPDIT_COMPATDRIVER;
            } else {
                DriverNodeHead = DevInfoElem->ClassDriverHead;
                DriverNodeType = SPDIT_CLASSDRIVER;
            }

        } else {
            //
            // We better not be trying to display a compatible driver list if
            // we don't have a devinfo element!
            //
            MYASSERT(!lpdd->bShowCompat);

            //
            // Since we don't have any compatible drivers to show, we will hide
            // the show compatible checkbox.
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), SW_HIDE);

            dipb = &(pDeviceInfoSet->InstallParamBlock);
            DriverNodeHead = pDeviceInfoSet->ClassDriverHead;
            DriverNodeType = SPDIT_CLASSDRIVER;

            if(pDeviceInfoSet->HasClassGuid) {
                ClassGuid = &(pDeviceInfoSet->ClassGuid);
            } else {
                ClassGuid = &GUID_DEVCLASS_UNKNOWN;
            }
        }

        if(!DriverNodeHead) {

            if(!(lpdd->flags & DD_FLAG_IS_DIALOGBOX)) {
                //
                // We can't just go away, so we have to do something useful.
                // For now, simply display the UI as if we had a single-Mfg
                // list, except that the list is empty.
                //
                // Hide the mult mfg controls
                //
                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_MFGLIST), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), SW_HIDE);

                //
                // Show the Single MFG controls
                //
                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_SHOW);

                //
                // Set the Models string
                //
                lvcCol.mask = LVCF_FMT | LVCF_TEXT;
                lvcCol.fmt = LVCFMT_LEFT;

                if(USE_CI_SELSTRINGS(dipb)) {
                    lvcCol.pszText = GET_CI_SELSTRINGS(dipb, ListLabel);
                    ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), 0, &lvcCol);
                } else {
                    if(!(LoadString(MyDllModuleHandle,
                                    IDS_NDWSEL_MODELSLABEL,
                                    szBuf,
                                    SIZECHARS(szBuf)))) {
                        *szBuf = TEXT('\0');
                    }
                    lvcCol.pszText = szBuf;
                    ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), 0, &lvcCol);
                }

                //
                // Use the single listbox view for the driver list.
                //
                lpdd->hwndDrvList = GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST);

                ListView_DeleteAllItems(lpdd->hwndDrvList);
            }

            Err = ERROR_DI_BAD_PATH;
            leave;
        }

        if((lpdd->flags & DD_FLAG_IS_DIALOGBOX) && !USE_CI_SELSTRINGS(dipb)) {
            //
            // If a class installer didn't supply strings for us to use in this
            // dialogbox, then retrieve the instruction text to be used.
            //
            // First, get the class description to use for the dialog text.
            //
            if(!SetupDiGetClassDescription(ClassGuid, szBuf, SIZECHARS(szBuf), NULL)) {
                //
                // Fall back to the generic description "device"
                //
                if(!LoadString(MyDllModuleHandle,
                               IDS_GENERIC_DEVNAME,
                               szBuf,
                               SIZECHARS(szBuf))) {
                    *szBuf = TEXT('\0');
                }
            }

            if(!lpdd->bShowCompat) {
                //
                // Show class list.
                //
                hr = HRESULT_FROM_WIN32(GLE_FN_CALL(0,
                                                    LoadString(MyDllModuleHandle,
                                                               IDS_INSTALLSTR1,
                                                               szMessage,
                                                               SIZECHARS(szMessage))
                                                   )
                                       );

                if(SUCCEEDED(hr)) {

                    hr = StringCchPrintfEx(szText,
                                         SIZECHARS(szText),
                                         &lpszText,
                                         &szTextSize,
                                         0,
                                         szMessage,
                                         szBuf
                                        );

                    MYASSERT(SUCCEEDED(hr));

                } else {
                    *szText = TEXT('\0');
                }

            } else {
                //
                // Show compatible list.
                //
                hr = HRESULT_FROM_WIN32(GLE_FN_CALL(0,
                                                    LoadString(MyDllModuleHandle,
                                                               IDS_INSTALLSTR0,
                                                               szMessage,
                                                               SIZECHARS(szMessage))
                                                   )
                                       );
                if(SUCCEEDED(hr)) {

                    hr = StringCchPrintfEx(szText,
                                           SIZECHARS(szText),
                                           &lpszText,
                                           &szTextSize,
                                           0,
                                           szMessage,
                                           szBuf
                                          );

                    MYASSERT(SUCCEEDED(hr));

                } else {
                    *szText = TEXT('\0');
                }

                if(SUCCEEDED(hr)) {

                    hr = HRESULT_FROM_WIN32(GLE_FN_CALL(0,
                                                        LoadString(MyDllModuleHandle,
                                                                   IDS_INSTALLCLASS,
                                                                   lpszText,
                                                                   szTextSize)
                                                       )
                                           );
                    if(SUCCEEDED(hr)) {
                        //
                        // Update our pointer to the end of the string, and the
                        // variable indicating the space remaining in the
                        // szText buffer.
                        //
                        hr = StringCchLength(szText, SIZECHARS(szText), &szTextSize);

                        MYASSERT(SUCCEEDED(hr));

                        if(SUCCEEDED(hr)) {
                            lpszText = szText + szTextSize;
                            szTextSize = SIZECHARS(szText) - szTextSize;
                        }
                    }
                }
            }

            if(SUCCEEDED(hr)) {

                if(dipb->DriverPath != -1) {
                    //
                    // Inform the user that the list they're seeing represents
                    // only what was found in the location they pointed us at.
                    //
                    LoadString(MyDllModuleHandle,
                               IDS_INSTALLOEM1,
                               lpszText,
                               szTextSize
                               );

                } else if (dipb->Flags & DI_SHOWOEM) {
                    //
                    // Tell the user they can click "Have Disk".
                    //
                    LoadString(MyDllModuleHandle,
                               IDS_INSTALLOEM,
                               lpszText,
                               szTextSize
                              );
                }
            }

            SetDlgItemText(hwndDlg, IDC_NDW_TEXT, szText);
        }

        if((!lpdd->bShowCompat) && (dipb->Flags & DI_MULTMFGS)) {
            //
            // Hide the Single MFG controls
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);

            //
            // Show the Multiple MFG controls
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_MFGLIST), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), SW_SHOW);

            //
            // Set the colunm heading for the Driver list
            //
            lvcCol.mask = LVCF_FMT | LVCF_TEXT;
            lvcCol.fmt = LVCFMT_LEFT;

            if(USE_CI_SELSTRINGS(dipb)) {
                lvcCol.pszText = GET_CI_SELSTRINGS(dipb, ListLabel);
                ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), 0, &lvcCol);
            } else {
                if(!(LoadString(MyDllModuleHandle,
                                IDS_NDWSEL_MODELSLABEL,
                                szBuf,
                                SIZECHARS(szBuf)))) {
                    *szBuf = TEXT('\0');
                }
                lvcCol.pszText = szBuf;
                ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), 0, &lvcCol);
            }

            //
            // Use the 2nd listbox of the Manufacturers/Models view for the
            // driver list.
            //
            lpdd->hwndDrvList = GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST);

            ListView_SetExtendedListViewStyle(lpdd->hwndDrvList, LVS_EX_LABELTIP);

            if(lpdd->hImageList) {
                ListView_SetImageList(lpdd->hwndDrvList, lpdd->hImageList, LVSIL_SMALL);
            }

            //
            // No redraw for faster insert
            //
            SendMessage(lpdd->hwndMfgList, WM_SETREDRAW, FALSE, 0L);
            TurnRedrawBackOn = TRUE;

            //
            // Clean out the MFG list before filling it.
            //
            ListView_DeleteAllItems(lpdd->hwndMfgList);

            lviItem.mask = LVIF_TEXT | LVIF_PARAM;
            lviItem.iItem = 0;
            lviItem.iSubItem = 0;

            //
            // Setup the Column Header
            //
            MfgNameId = -1;

            for(CurDriverNode = DriverNodeHead; CurDriverNode; CurDriverNode = CurDriverNode->Next) {
                //
                // Skip this driver node if it is to be excluded of if it is an
                // old INET driver or if it is a BAD driver.
                //
                if((CurDriverNode->Flags & DNF_OLD_INET_DRIVER) ||
                   (CurDriverNode->Flags & DNF_BAD_DRIVER) ||
                   ((CurDriverNode->Flags & DNF_EXCLUDEFROMLIST) &&
                    !(dipb->FlagsEx & DI_FLAGSEX_ALLOWEXCLUDEDDRVS))) {

                    continue;
                }

                if((MfgNameId == -1) || (MfgNameId != CurDriverNode->MfgName)) {

                    MfgNameId = CurDriverNode->MfgName;

                    MYASSERT(CurDriverNode->MfgDisplayName != -1);
                    lpszMfg = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                       CurDriverNode->MfgDisplayName
                                                      );
                    lviItem.pszText = lpszMfg;
                    lviItem.lParam = (LPARAM)CurDriverNode;
                    i = ListView_InsertItem(lpdd->hwndMfgList, &lviItem);
                }

                //
                // If this driver node is the selected one, preselect here.
                //
                if(lpdd->iCurDesc == CurDriverNode->DevDescription) {
                    ListView_SetItemState(lpdd->hwndMfgList,
                                          i,
                                          (LVIS_SELECTED|LVIS_FOCUSED),
                                          (LVIS_SELECTED|LVIS_FOCUSED)
                                         );
                    ShowListForMfg(lpdd, pDeviceInfoSet, dipb, NULL, i);
                    bDidDrvList = TRUE;
                }
            }

            //
            // Resize the Column
            //
            ListView_SetColumnWidth(lpdd->hwndMfgList, 0, LVSCW_AUTOSIZE_USEHEADER);

            //
            // If we did not expand one of the MFGs by default, then
            // expand the First MFG.
            //
            if(!bDidDrvList) {

                ListView_SetItemState(lpdd->hwndMfgList,
                                      0,
                                      (LVIS_SELECTED|LVIS_FOCUSED),
                                      (LVIS_SELECTED|LVIS_FOCUSED)
                                     );
                ShowListForMfg(lpdd, pDeviceInfoSet, dipb, NULL, 0);

                SendMessage(lpdd->hwndMfgList, WM_SETREDRAW, TRUE, 0L);
                TurnRedrawBackOn = FALSE;

            } else {
                //
                // We must set redraw back to true before sending the
                // LVM_ENSUREVISIBLE message, or otherwise, the listbox item
                // may only be partially exposed.
                //
                SendMessage(lpdd->hwndMfgList, WM_SETREDRAW, TRUE, 0L);
                TurnRedrawBackOn = FALSE;

                ListView_EnsureVisible(lpdd->hwndMfgList,
                                       ListView_GetNextItem(lpdd->hwndMfgList, -1, LVNI_SELECTED),
                                       FALSE
                                      );
            }

        } else {
            //
            // Hide the mult mfg controls
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_MFGLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);

            //
            // Show the Single MFG controls
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_SHOW);

            //
            // Set the Models string
            //
            lvcCol.mask = LVCF_FMT | LVCF_TEXT;
            lvcCol.fmt = LVCFMT_LEFT;

            if(USE_CI_SELSTRINGS(dipb)) {
                lvcCol.pszText = GET_CI_SELSTRINGS(dipb, ListLabel);
                ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), 0, &lvcCol);
            } else {
                if(!(LoadString(MyDllModuleHandle,
                                IDS_NDWSEL_MODELSLABEL,
                                szBuf,
                                SIZECHARS(szBuf)))) {
                    *szBuf = TEXT('\0');
                }
                lvcCol.pszText = szBuf;
                ListView_SetColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), 0, &lvcCol);
            }

            //
            // Use the single listbox view for the driver list.
            //
            lpdd->hwndDrvList = GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST);

            if (lpdd->hImageList) {
                ListView_SetImageList(lpdd->hwndDrvList, lpdd->hImageList, LVSIL_SMALL);
            }

            ShowListForMfg(lpdd, pDeviceInfoSet, dipb, DriverNodeHead, -1);
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {

        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);

        if(TurnRedrawBackOn) {
            SendMessage(lpdd->hwndMfgList, WM_SETREDRAW, TRUE, 0L);
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return Err;
}


VOID
ShowListForMfg(
    IN PSP_DIALOGDATA          lpdd,
    IN PDEVICE_INFO_SET        DeviceInfoSet,
    IN PDEVINSTALL_PARAM_BLOCK InstallParamBlock,
    IN PDRIVER_NODE            DriverNode,        OPTIONAL
    IN INT                     iMfg
    )
/*++

Routine Description:

    This routine builds the driver description list.
    THE LOCK MUST ALREADY BE ACQUIRED BEFORE CALLING THIS ROUTINE!

Arguments:

    lpdd - Supplies the address of a dialog data buffer containing parameters
        to be used in filling in the driver description list.

    DeviceInfoSet - Supplies the address of the device information set
        structure for which the driver description list is to be built.

    InstallParamBlock - Supplies the address of a device installation parameter
        block that controls how the list is displayed.

    DriverNode - Optionally, supplies a pointer to the first node in a driver
        node list to traverse, adding to the list for each node.  If DriverNode
        is not specified, then the list is to be built based on a particular
        manufacturer, whose index in the Manufacturer list is given by iMfg.

    iMfg - Supplies the index within the Manufacturer list that the driver
        description list is to be based on.  This parameter is ignored if a
        DriverNode is specified.

Return Value:

    None.

--*/
{
    INT         i = -1;
    LV_ITEM     lviItem;
    LV_FINDINFO lvfiFind;
    LONG        MfgNameId = -1;
    TCHAR       szTemp[LINE_LEN];
    SYSTEMTIME  SystemTime;
    TCHAR       FormatString[LINE_LEN];
    HRESULT     hr;
    PTSTR       StringEnd;
    size_t      StringBufSize;

    //
    // Set listview sortascending style based on DI_INF_IS_SORTED flag
    //
    SetWindowLong(lpdd->hwndDrvList,
                  GWL_STYLE,
                  (GetWindowLong(lpdd->hwndDrvList, GWL_STYLE) & ~(LVS_SORTASCENDING | LVS_SORTDESCENDING)) |
                      ((InstallParamBlock->Flags & DI_INF_IS_SORTED)
                          ? 0
                          : LVS_SORTASCENDING)
                 );

    SendMessage(lpdd->hwndDrvList, WM_SETREDRAW, FALSE, 0L);

    try {
        //
        // Clean out the List.
        //
        ListView_DeleteAllItems(lpdd->hwndDrvList);

        if(!DriverNode) {

            if(ListView_GetItemCount(lpdd->hwndMfgList) > 0) {

                lviItem.mask = LVIF_PARAM;
                lviItem.iItem = iMfg;
                lviItem.iSubItem = 0;
                if(!ListView_GetItem(lpdd->hwndMfgList, &lviItem) ||
                   !(DriverNode = GetDriverNodeFromLParam(DeviceInfoSet, lpdd, lviItem.lParam))) {

                    leave;
                }
                MfgNameId = DriverNode->MfgName;
            } else {
                //
                // This means that there are no Manufacturers so we just have a empty list.
                //
                leave;
            }
        }

        lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lviItem.iItem = 0;
        lviItem.iSubItem = 0;

        //
        // Add descriptions to the list
        //
        for( ; DriverNode; DriverNode = DriverNode->Next) {

            if((MfgNameId != -1) && (MfgNameId != DriverNode->MfgName)) {
                //
                // We've gone beyond the manufacturer list--break out of loop.
                //
                break;
            }

            //
            // If this is a special "Don't show me" one, then skip it
            //
            if((DriverNode->Flags & DNF_OLD_INET_DRIVER) ||
               (DriverNode->Flags & DNF_BAD_DRIVER) ||
               ((DriverNode->Flags & DNF_EXCLUDEFROMLIST) &&
                !(InstallParamBlock->FlagsEx & DI_FLAGSEX_ALLOWEXCLUDEDDRVS))) {

                continue;
            }

            //
            // Build the device description string to add to the models list.
            //
            hr = StringCchCopyEx(
                     szTemp,
                     SIZECHARS(szTemp),
                     pStringTableStringFromId(DeviceInfoSet->StringTable,
                                              DriverNode->DevDescriptionDisplayName),
                     &StringEnd,
                     &StringBufSize,
                     0
                     );

            //
            // This shouldn't fail, since the maximum length of a device
            // description name is less than the size of our szTemp buffer!
            //
            MYASSERT(SUCCEEDED(hr));

            if(SUCCEEDED(hr)) {

                if((DriverNode->Flags & DNF_DUPDESC) &&
                   (DriverNode->ProviderDisplayName != -1)) {

                    //
                    // For drivers with duplicate descriptions add the provider
                    // name in parens.
                    //

                    if(GetWindowLong(lpdd->hwndDrvList, GWL_EXSTYLE) & WS_EX_RTLREADING) {
                        MYVERIFY(SUCCEEDED(StringCchPrintfEx(StringEnd,
                                              StringBufSize,
                                              NULL,
                                              NULL,
                                              STRSAFE_IGNORE_NULLS | STRSAFE_NO_TRUNCATION,
                                              L" \x200E(%s)\x200E",
                                              pStringTableStringFromId(
                                                  DeviceInfoSet->StringTable,
                                                  DriverNode->ProviderDisplayName)
                                             )));
                    } else {
                        MYVERIFY(SUCCEEDED(StringCchPrintfEx(StringEnd,
                                              StringBufSize,
                                              NULL,
                                              NULL,
                                              STRSAFE_IGNORE_NULLS | STRSAFE_NO_TRUNCATION,
                                              TEXT(" (%s)"),
                                              pStringTableStringFromId(
                                                  DeviceInfoSet->StringTable,
                                                  DriverNode->ProviderDisplayName)
                                         )));
                    }

                } else if(DriverNode->Flags & DNF_DUPPROVIDER) {
                    //
                    // For drivers with duplicate descriptions and providers,
                    // add the driver version and driver date if there is one,
                    // in  brackets.
                    //
                    if(DriverNode->DriverVersion != 0) {

                        ULARGE_INTEGER Version;

                        Version.QuadPart = DriverNode->DriverVersion;

                        if(LoadString(MyDllModuleHandle,
                                      IDS_VERSION,
                                      FormatString,
                                      SIZECHARS(FormatString))) {

                            hr = StringCchPrintfEx(StringEnd,
                                                   StringBufSize,
                                                   &StringEnd,
                                                   &StringBufSize,
                                                   STRSAFE_NO_TRUNCATION,
                                                   FormatString,
                                                   HIWORD(Version.HighPart),
                                                   LOWORD(Version.HighPart),
                                                   HIWORD(Version.LowPart),
                                                   LOWORD(Version.LowPart)
                                                  );
                        }
                    }

                    if(SUCCEEDED(hr) &&
                       ((DriverNode->DriverDate.dwLowDateTime != 0) ||
                        (DriverNode->DriverDate.dwHighDateTime != 0))) {

                        if(FileTimeToSystemTime(&(DriverNode->DriverDate), &SystemTime)) {
                            if(GetDateFormat(LOCALE_USER_DEFAULT,
                                             ((GetWindowLong(lpdd->hwndDrvList, GWL_EXSTYLE) & WS_EX_RTLREADING)
                                                 ? DATE_SHORTDATE | DATE_RTLREADING
                                                 : DATE_SHORTDATE),
                                             &SystemTime,
                                             NULL,
                                             FormatString,
                                             SIZECHARS(FormatString)) != 0) {

                                MYVERIFY(SUCCEEDED(StringCchPrintfEx(StringEnd,
                                                          StringBufSize,
                                                          NULL,
                                                          NULL,
                                                          STRSAFE_NO_TRUNCATION,
                                                          TEXT(" [%s]"),
                                                          FormatString
                                                 )));
                            }
                        }
                    }
                }
            }

            lviItem.pszText = szTemp;

            lviItem.lParam = (LPARAM)DriverNode;

            //
            // We have to test for DNF_AUTHENTICODE_SIGNED first since if
            // that flag is set then DNF_INF_IS_SIGNED is also always set.
            //
            if (DriverNode->Flags & DNF_AUTHENTICODE_SIGNED) {
                lviItem.iImage = IMAGE_ICON_AUTHENTICODE_SIGNED;
            } else if (DriverNode->Flags & DNF_INF_IS_SIGNED) {
                lviItem.iImage = IMAGE_ICON_SIGNED;
            } else {
                lviItem.iImage = IMAGE_ICON_NOT_SIGNED;
            }

            if(ListView_InsertItem(lpdd->hwndDrvList, &lviItem) != -1) {
                lviItem.iItem++;
            }
        }

        //
        // Sort the list unless the DI_INF_IS_SORTED flag is set
        //
        if(GetWindowLong(lpdd->hwndDrvList, GWL_STYLE) & LVS_SORTASCENDING) {
            ListView_SortItems(lpdd->hwndDrvList,
                               (PFNLVCOMPARE)DriverNodeCompareProc,
                               (LPARAM)DeviceInfoSet
                               );
        }

        //
        // Resize the Column
        //
        ListView_SetColumnWidth(lpdd->hwndDrvList, 0, LVSCW_AUTOSIZE_USEHEADER);

        //
        // select the current description string
        //
        if(lpdd->iCurDesc == -1) {
            i = 0;
        } else {
            lvfiFind.flags = LVFI_STRING;
            lvfiFind.psz = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                                    lpdd->iCurDesc
                                                   );
            i = ListView_FindItem(lpdd->hwndDrvList, -1, &lvfiFind);
            if(i == -1) {
                i = 0;
            }
        }
        ListView_SetItemState(lpdd->hwndDrvList,
                              i,
                              (LVIS_SELECTED|LVIS_FOCUSED),
                              (LVIS_SELECTED|LVIS_FOCUSED)
                             );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        i = -1;
    }

    //
    // We must turn redraw back on before sending the LVM_ENSUREVISIBLE
    // message, or otherwise the item may only be partially visible.
    //
    SendMessage(lpdd->hwndDrvList, WM_SETREDRAW, TRUE, 0L);
    if(i != -1) {
        ListView_EnsureVisible(lpdd->hwndDrvList, i, FALSE);
    }
}


VOID
LockAndShowListForMfg(
    IN PSP_DIALOGDATA   lpdd,
    IN INT              iMfg
    )
/*++

Routine Description:

    This routine is a wrapper for ShowListForMfg.  It is to be called from
    points where the device information set lock is not already owned (e.g.,
    the dialog prop message loop.

Arguments:

    lpdd - Supplies the address of a dialog data buffer containing parameters
        to be used in filling in the driver description list.

    iMfg - Supplies the index within the Manufacturer list that the driver
        description list is to be based on.

Return Value:

    None.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINSTALL_PARAM_BLOCK dipb;
    PDEVINFO_ELEM DevInfoElem;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        dipb = DevInfoElem ? &(DevInfoElem->InstallParamBlock)
                           : &(pDeviceInfoSet->InstallParamBlock);

        ShowListForMfg(lpdd,
                       pDeviceInfoSet,
                       dipb,
                       NULL,
                       iMfg
                      );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);
}


BOOL
InitSelectDeviceDlg(
    IN     HWND hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine initializes the select device wizard page.  It
    builds the class list if it is needed, shows/hides necessary
    controls based on Flags, and comes up with the right text
    description of what's going on.

Arguments:

    hwndDlg - Handle to dialog window

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

Return Value:

    TRUE if we have at least one driver (compat or class) displayed.
    FALSE if we do not have any drivers (class and compat) displayed.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    SP_DEVINFO_DATA DevInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD DriverType = SPDIT_CLASSDRIVER;
    DWORD Err;
    INT ShowWhat;
    CONST GUID *ClassGuid;
    HICON hIcon;
    LV_COLUMN lvcCol;
    BOOL SpawnClassDriverSearch = FALSE;
    PCLASSDRV_THREAD_CONTEXT ClassDrvThreadContext;
    HCURSOR hOldCursor;
    BOOL bRet = TRUE;
    PSP_DIALOGDATA lpdd;
    TCHAR szBuf[LINE_LEN];
    HFONT hfont;
    LOGFONT LogFont;

    MYASSERT(ndwData);
    lpdd = &(ndwData->ddData);
    MYASSERT(lpdd);

    if(!lpdd->hwndMfgList) {

        UINT ImageListFlags = 0;

        //
        // Then this is the first time we've initialized this dialog (we may
        // hit this routine multiple times in the wizard case, because the user
        // can go back and forth between pages).
        //
        lpdd->hwndMfgList = GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_MFGLIST);
        //
        // Don't worry--hwndDrvList will be set later in FillInDeviceList().
        //

        //
        // Create an image list and add the signed and not signed (blank) icons
        // to the list.
        // Note: If the window is in right-to-left reading then we need to OR
        // in the ILC_MIRROR flag so that the icons do NOT get mirrored along
        // with the rest of the UI.
        //
        ImageListFlags = ILC_MASK;
        if(GetWindowLong(hwndDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
            ImageListFlags |= ILC_MIRROR;
        }


        lpdd->hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                            GetSystemMetrics(SM_CYSMICON),
                                            ImageListFlags,
                                            1,
                                            1
                                            );

        if(lpdd->hImageList) {

            ImageList_SetBkColor(lpdd->hImageList, GetSysColor(COLOR_WINDOW));

            if((hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(IDI_BLANK))) != NULL) {
                ImageList_AddIcon(lpdd->hImageList, hIcon);
            }

            if((hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(IDI_SIGNED))) != NULL) {
                ImageList_AddIcon(lpdd->hImageList, hIcon);
            }

            if((hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(IDI_CERT))) != NULL) {
                ImageList_AddIcon(lpdd->hImageList, hIcon);
            }
        }

        //
        // Create the normal and bold fonts for the digital signing text.
        //
        lpdd->hFontNormal = lpdd->hFontBold = NULL;

        if((hfont = (HFONT)SendMessage(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), WM_GETFONT, 0, 0)) != NULL) {
            GetObject(hfont, sizeof(LogFont), &LogFont);
            lpdd->hFontNormal = CreateFontIndirect(&LogFont);
        }

        if((hfont = (HFONT)SendMessage(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), WM_GETFONT, 0, 0)) != NULL) {
            GetObject(hfont, sizeof(LogFont), &LogFont);
            LogFont.lfWeight = FW_BOLD;
            lpdd->hFontBold = CreateFontIndirect(&LogFont);
        }

        ListView_SetExtendedListViewStyle(lpdd->hwndMfgList, LVS_EX_LABELTIP);

        //
        // Insert a ListView column for each of the listboxes.
        // Set the text for the Manufacturer label now since it can't be
        // changed by class installers like the model label can.
        //
        lvcCol.mask = 0;

        ListView_InsertColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), 0, &lvcCol);
        ListView_InsertColumn(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), 0, &lvcCol);

        lvcCol.mask = LVCF_FMT | LVCF_TEXT;
        lvcCol.fmt = LVCFMT_LEFT;
        if(!(LoadString(MyDllModuleHandle,
                        IDS_NDWSEL_MFGLABEL,
                        szBuf,
                        SIZECHARS(szBuf)))) {
            *szBuf = TEXT('\0');
        }
        lvcCol.pszText = szBuf;
        ListView_InsertColumn(lpdd->hwndMfgList, 0, &lvcCol);
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return FALSE;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            dipb = &(DevInfoElem->InstallParamBlock);
            ClassGuid = &(DevInfoElem->ClassGuid);
            //
            // Fill in a SP_DEVINFO_DATA structure for a later call to
            // SetupDiBuildDriverInfoList.
            //
            DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             &DevInfoData
                                            );
            //
            // Set flags indicating which driver lists already exist.
            //
            if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDCOMPATINFO) {
                lpdd->bKeeplpCompatDrvList = TRUE;
            }

            if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) {
                lpdd->bKeeplpClassDrvList = TRUE;
            }

            if(DevInfoElem->SelectedDriver) {
                lpdd->bKeeplpSelectedDrv = TRUE;
            }

            //
            // We want to start out with the compatible driver list.
            //
            DriverType = SPDIT_COMPATDRIVER;

        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
            if(pDeviceInfoSet->HasClassGuid) {
                ClassGuid = &(pDeviceInfoSet->ClassGuid);
            } else {
                ClassGuid = &GUID_DEVCLASS_UNKNOWN;
            }

            if(pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) {
                lpdd->bKeeplpClassDrvList = TRUE;
            }

            if(pDeviceInfoSet->SelectedClassDriver) {
                lpdd->bKeeplpSelectedDrv = TRUE;
            }
        }

        //
        // Get/set class icon
        //
        if(IsEqualGUID(ClassGuid, &GUID_NULL)) {
            if(!SetupDiLoadClassIcon(&GUID_DEVCLASS_UNKNOWN, &hIcon, &(lpdd->iBitmap))) {
                hIcon = NULL;
            }
        } else {
            if(!SetupDiLoadClassIcon(ClassGuid, &hIcon, &(lpdd->iBitmap))) {
                hIcon = NULL;
            }
        }

        if(hIcon) {
            SendDlgItemMessage(hwndDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hIcon, 0L);
        }

        //
        // If we are supposed to override the instructions and title with the
        // class installer-provided strings, do it now.
        //
        if(USE_CI_SELSTRINGS(dipb)) {

            if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {
                SetWindowText(hwndDlg, GET_CI_SELSTRINGS(dipb, Title));
            } else {
                //
                // Set wizard title and subtitle
                //
                PropSheet_SetHeaderTitle(GetParent(hwndDlg),
                        PropSheet_HwndToIndex(GetParent(hwndDlg), hwndDlg),
                        GET_CI_SELSTRINGS(dipb, Title));

                PropSheet_SetHeaderSubTitle(GetParent(hwndDlg),
                        PropSheet_HwndToIndex(GetParent(hwndDlg), hwndDlg),
                        GET_CI_SELSTRINGS(dipb, SubTitle));
            }
            SetDlgItemText(hwndDlg, IDC_NDW_TEXT, GET_CI_SELSTRINGS(dipb, Instructions));
        }

        //
        // If we should not allow OEM driver, then hide the HAVE disk button.
        //
        if(!(dipb->Flags & DI_SHOWOEM)) {
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_HAVEDISK), SW_HIDE);
        }

        //
        // Hide the Windows Update button if we should not search the web.
        //
        if((!(dipb->FlagsEx & DI_FLAGSEX_SHOWWINDOWSUPDATE)) ||
            !CDMIsInternetAvailable()) {

            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_WINDOWSUPDATE), SW_HIDE);
        }

        if(dipb->FlagsEx & DI_FLAGSEX_FILTERSIMILARDRIVERS) {
            lpdd->flags |= DD_FLAG_SHOWSIMILARDRIVERS;
        }

        //
        // In order to decrease the amount of time the user must wait before
        // they're able to work with the Select Device dialog, we have adopted
        // a 'hybrid' multi-threaded approach.  As soon as we get the first
        // displayable list built, then we will return, and build the other
        // list (if necessary) in another thread.
        //
        // We do it this way because it's easier, it maintains the existing
        // external behavior, and because it's easier.
        //
        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));  // Potentially slow operations ahead!

        if(DriverType == SPDIT_COMPATDRIVER) {
            //
            // OR in the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS flag so that we
            // don't include old internet drivers in the list that we get back.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if(SetupDiGetDeviceInstallParams(lpdd->DevInfoSet,
                                             &DevInfoData,
                                             &DeviceInstallParams)) {

                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;

                SetupDiSetDeviceInstallParams(lpdd->DevInfoSet,
                                              &DevInfoData,
                                              &DeviceInstallParams
                                             );
            }

            SetupDiBuildDriverInfoList(lpdd->DevInfoSet,
                                       &DevInfoData,
                                       SPDIT_COMPATDRIVER
                                      );

            //
            // Verify that there are some devices in the list to show.
            //
            if(bNoDevsToShow(DevInfoElem)) {
                if(!lpdd->bKeeplpCompatDrvList) {
                    SetupDiDestroyDriverInfoList(lpdd->DevInfoSet, &DevInfoData, SPDIT_COMPATDRIVER);
                }
                DriverType = SPDIT_CLASSDRIVER;

            } else if(!lpdd->bKeeplpClassDrvList) {
                //
                // We have a list to get our UI up and running, but we don't
                // have a class driver list yet.  Set a flag that causes us to
                // spawn a thread for this later.
                //
                SpawnClassDriverSearch = TRUE;
            }
        }

        if(DriverType == SPDIT_CLASSDRIVER) {
            //
            // We couldn't find any compatible drivers, so we fall back on the
            // class driver list.  In this case we have to have this list
            // before continuing.  In the future, maybe we'll get fancier and
            // do this in a separate thread, but for now, we just make the user
            // wait.
            //

            //
            // OR in the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS flag so that we
            // don't include old internet drivers in the list that we get back.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if(SetupDiGetDeviceInstallParams(lpdd->DevInfoSet,
                                              DevInfoElem ? &DevInfoData : NULL,
                                              &DeviceInstallParams)) {

                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;

                SetupDiSetDeviceInstallParams(lpdd->DevInfoSet,
                                              DevInfoElem ? &DevInfoData : NULL,
                                              &DeviceInstallParams
                                             );
            }

            SetupDiBuildDriverInfoList(lpdd->DevInfoSet,
                                       DevInfoElem ? &DevInfoData : NULL,
                                       SPDIT_CLASSDRIVER
                                      );
        }

        SetCursor(LoadCursor(NULL, IDC_ARROW));  // Done with slow operations.

        if(DriverType == SPDIT_COMPATDRIVER) {
            //
            // Since we ran this through bNoDevsToShow() above, and it
            // succeeded, we know there's at least one driver in the compatible
            // driver list.
            //
            lpdd->bShowCompat = TRUE;
            CheckDlgButton(hwndDlg,
                           IDC_NDW_PICKDEV_COMPAT,
                           BST_CHECKED
                           );
        } else {
            //
            // There is no compatible list, so hide the radio buttons.
            //
            lpdd->bShowCompat = FALSE;
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), SW_HIDE);
        }

        //
        // Initial current description.  This will be used to set
        // the Default ListView selection.
        //
        if(lpdd->iCurDesc == -1) {
            //
            // If we already have a selected driver for the devinfo set or
            // element, then we'll use that, otherwise, we'll use the devinfo
            // element's description (if applicable).
            //
            if(DevInfoElem) {
                if(DevInfoElem->SelectedDriver) {
                    lpdd->iCurDesc = DevInfoElem->SelectedDriver->DevDescription;
                } else {

                    TCHAR TempString[LINE_LEN];
                    ULONG TempStringSize;

                    //
                    // Use the caller-supplied device description, if there is
                    // one.  If not, then see if we can retrieve the DeviceDesc
                    // registry property.
                    //
                    TempStringSize = sizeof(TempString);

                    if((DevInfoElem->DeviceDescription == -1) &&
                       (CM_Get_DevInst_Registry_Property(DevInfoElem->DevInst,
                                                         CM_DRP_DEVICEDESC,
                                                         NULL,
                                                         TempString,
                                                         &TempStringSize,
                                                         0) == CR_SUCCESS)) {
                        //
                        // We were able to retrieve a device description.  Now
                        // store it (case-insensitive only) in the devinfo
                        // element.
                        //
                        DevInfoElem->DeviceDescription = pStringTableAddString(
                                                           pDeviceInfoSet->StringTable,
                                                           TempString,
                                                           STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                           NULL,0
                                                           );
                    }

                    lpdd->iCurDesc = DevInfoElem->DeviceDescription;
                }
            } else {
                if(pDeviceInfoSet->SelectedClassDriver) {
                    lpdd->iCurDesc = pDeviceInfoSet->SelectedClassDriver->DevDescription;
                }
            }
        }

        Err = FillInDeviceList(hwndDlg, lpdd);

        if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {

            HWND hLineWnd;
            RECT Rect;

            //
            // If FillInDeviceList() fails during init time, don't even bring
            // up the dialog.
            //
            if(Err != NO_ERROR) {
                EndDialog(hwndDlg, Err);
                leave;
            }

            //
            // Set the initial focus on the OK button.
            //
            SetFocus(GetDlgItem(hwndDlg, IDOK));

            //
            // Use the fancy etched frame style for the separator bar in the
            // dialog.
            //
            hLineWnd = GetDlgItem(hwndDlg, IDD_DEVINSLINE);
            SetWindowLong(hLineWnd,
                          GWL_EXSTYLE,
                          (GetWindowLong(hLineWnd, GWL_EXSTYLE) | WS_EX_STATICEDGE)
                         );
            GetClientRect(hLineWnd, &Rect);
            SetWindowPos(hLineWnd,
                         HWND_TOP,
                         0,
                         0,
                         Rect.right,
                         GetSystemMetrics(SM_CYEDGE),
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED
                        );
        }

        //
        // If DriverType is SPDIT_CLASSDRIVER and ListView_GetItemCount returns
        // 0 then we don't have any items to show at all. This will only happen
        // when we search the default Windows INF directory and we do not have
        // any INFs for a device.
        //
        if((DriverType == SPDIT_CLASSDRIVER) &&
           (0 == ListView_GetItemCount(lpdd->hwndDrvList))) {

            TCHAR TempString[LINE_LEN];

            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_ONEMFG_DRVLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_MFGLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_DRVLIST), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK), SW_HIDE);

            ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_SHOW);

            if(!LoadString(MyDllModuleHandle, IDS_NDW_NO_DRIVERS, TempString, SIZECHARS(TempString))) {
                *TempString = TEXT('\0');
            }
            SetDlgItemText(hwndDlg, IDC_NDW_STATUS_TEXT, TempString);

            if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {
                EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
            } else {
                if(((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
                   ((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
                   !((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
                    //
                    // No back if we skipped the Class list, and are in express
                    // mode
                    //
                    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
                } else {
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                }
            }

            bRet = FALSE;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {

        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);

        bRet = FALSE;
        SpawnClassDriverSearch = FALSE;

        //
        // If we're doing the dialog box version, then an exception should
        // cause us to terminate the dialog and return an error.
        //
        if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {
            EndDialog(hwndDlg, ERROR_INVALID_DATA);
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(SpawnClassDriverSearch) {
        //
        // Allocate a context structure to pass to the auxilliary thread (the
        // auxilliary thread will take care of freeing the memory).
        //
        if(!(ClassDrvThreadContext = MyMalloc(sizeof(CLASSDRV_THREAD_CONTEXT)))) {

            if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {
                EndDialog(hwndDlg, ERROR_NOT_ENOUGH_MEMORY);
            }

        } else {

            try {
                //
                // Fill in the context structure, and fire off the thread.
                // NOTE: The DevInfoData struct has to have been filled in above
                // for us to have gotten to this point.
                //
                ClassDrvThreadContext->DeviceInfoSet = lpdd->DevInfoSet;

                CopyMemory(&(ClassDrvThreadContext->DeviceInfoData),
                           &DevInfoData,
                           sizeof(DevInfoData)
                          );

                ClassDrvThreadContext->NotificationWindow = hwndDlg;

                if(_beginthread(ClassDriverSearchThread, 0, ClassDrvThreadContext) == -1) {
                    //
                    // Assume out-of-memory
                    //
                    if(lpdd->flags & DD_FLAG_IS_DIALOGBOX) {
                        EndDialog(hwndDlg, ERROR_NOT_ENOUGH_MEMORY);
                    }

                } else {
                    //
                    // Memory "handed off" to other thread--reset the pointer
                    // so we won't try to free it below...
                    //
                    ClassDrvThreadContext = NULL;
                    lpdd->AuxThreadRunning = TRUE;
                }

            } except(pSetupExceptionFilter(GetExceptionCode())) {
                pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
            }

            if(ClassDrvThreadContext) {
                MyFree(ClassDrvThreadContext);
            }
        }
    }

    return bRet;
}


PDRIVER_NODE
GetDriverNodeFromLParam(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PSP_DIALOGDATA   lpdd,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    This routine interprets lParam as a pointer to a driver node, and tries to
    find the node in the class driver list for either the selected devinfo
    element, or the set itself.  If the lpdd flags field has the
    DD_FLAG_USE_DEVINFO_ELEM bit set, then the lpdd's DevInfoElem will be used
    instead of the currently selected device.

Arguments:

    DeviceInfoSet - Supplies the address of the device information set
        structure to search for the driver node in.

    lpdd - Supplies the address of a dialog data structure that specifies
        whether the wizard has an explicit association to the global class
        driver list or to a particular device information element, and if so,
        what it's associated with.

    lParam - Supplies a value which may be the address of a driver node.  The
        appropriate linked list of driver nodes is searched to see if one of
        them has this value as its address, and if so, a pointer to that driver
        node is returned.

Return Value:

    If success, the return value is the address of the matching driver node,
    otherwise, it is NULL.

--*/
{
    PDRIVER_NODE CurDriverNode;
    PDEVINFO_ELEM DevInfoElem;

    if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
        DevInfoElem = lpdd->DevInfoElem;
    } else {
        DevInfoElem = DeviceInfoSet->SelectedDevInfoElem;
    }

    if(DevInfoElem) {
        CurDriverNode = (lpdd->bShowCompat) ? DevInfoElem->CompatDriverHead
                                            : DevInfoElem->ClassDriverHead;
    } else {
        MYASSERT(!lpdd->bShowCompat);
        CurDriverNode = DeviceInfoSet->ClassDriverHead;
    }

    while(CurDriverNode) {
        if(CurDriverNode == (PDRIVER_NODE)lParam) {
            return CurDriverNode;
        } else {
            CurDriverNode = CurDriverNode->Next;
        }
    }

    return NULL;
}


BOOL
OnSetActive(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine handles the PSN_SETACTIVE message of the select device wizard
    page.

Arguments:

    hwndDlg - Supplies the window handle of the wizard dialog page.

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

Return Value:

    If success, the return value is TRUE, otherwise, it is FALSE.

--*/
{
    BOOL b = TRUE;
    PSP_INSTALLWIZARD_DATA iwd;
    PSP_DIALOGDATA lpdd;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;

    MYASSERT(ndwData);
    iwd = &(ndwData->InstallData);
    lpdd = &(ndwData->ddData);

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return FALSE;
    }

    try {
        //
        // Make sure our "waiting for class list" static text control is
        // hidden!
        //
        ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_STATUS_TEXT), SW_HIDE);

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            dipb = &(DevInfoElem->InstallParamBlock);
        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        //
        // Set the Button State
        //
        if((iwd->Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) &&
           (iwd->Flags & NDW_INSTALLFLAG_EXPRESSINTRO) &&
           !(iwd->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {
            //
            // No back if we skipped the Class list, and are in express mode
            //
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
        } else {
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
        }

        //
        // Set the New Class install params.
        // If we are being jumped to by a dyna wiz page,
        // then do not call the class installer
        //
        if(iwd->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {
            InitSelectDeviceDlg(hwndDlg, ndwData);
        } else {

            BOOL FlagNeedsReset = FALSE;
            SP_DEVINFO_DATA DeviceInfoData;
            DWORD CiErr;
            PDEVINFO_ELEM CurDevInfoElem;

            //
            // Call the Class Installer
            //
            if(!(dipb->Flags & DI_NODI_DEFAULTACTION)) {
                dipb->Flags |= DI_NODI_DEFAULTACTION;
                FlagNeedsReset = TRUE;
            }

            if(DevInfoElem) {
                //
                // Initialize a SP_DEVINFO_DATA buffer to use as an argument to
                // SetupDiCallClassInstaller.
                //
                DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                 DevInfoElem,
                                                 &DeviceInfoData
                                                );
            }

            //
            // We need to unlock the HDEVINFO before calling the class
            // installer.
            //
            UnlockDeviceInfoSet(pDeviceInfoSet);
            pDeviceInfoSet = NULL;

            CiErr = _SetupDiCallClassInstaller(
                        DIF_SELECTDEVICE,
                        lpdd->DevInfoSet,
                        DevInfoElem ? &DeviceInfoData : NULL,
                        CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS
                        );

            //
            // Re-acquire the HDEVINFO lock.
            //
            if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
                //
                // should never hit this code path
                //
                MYASSERT(pDeviceInfoSet);
                b = FALSE;
                leave;
            }

            if(DevInfoElem && !(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM)) {
                //
                // Verify that the class installer didn't do something nasty
                // like delete the currently selected devinfo element!
                //
                for(CurDevInfoElem = pDeviceInfoSet->DeviceInfoHead;
                    CurDevInfoElem;
                    CurDevInfoElem = CurDevInfoElem->Next) {

                    if(CurDevInfoElem = DevInfoElem) {
                        break;
                    }
                }

                if(!CurDevInfoElem) {
                    //
                    // The class installer deleted the selected devinfo
                    // element.  Get the newly-selected one, or fall back to
                    // the global driver list if none selected.
                    //
                    if(DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem) {
                        dipb = &(DevInfoElem->InstallParamBlock);
                    } else {
                        dipb = &(pDeviceInfoSet->InstallParamBlock);
                    }

                    //
                    // Don't need to reset the default action flag.
                    //
                    FlagNeedsReset = FALSE;
                }
            }

            //
            // Reset the DI_NODI_DEFAULTACTION flag if necessary.
            //
            if(FlagNeedsReset) {
                dipb->Flags &= ~DI_NODI_DEFAULTACTION;
            }

            switch(CiErr) {
                //
                // Class installer did the select, so goto analyze
                //
                case NO_ERROR :

                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DYNAWIZ_ANALYZEDEV_PAGE);
                    break;

                //
                // Class installer wants us to do default.
                //
                case ERROR_DI_DO_DEFAULT :

                    InitSelectDeviceDlg(hwndDlg, ndwData);
                    break;

                default :
                    //
                    // If we are doing an OEM select, and we fail, then
                    // we should init after clearing the OEM stuff.
                    //
                    if(iwd->Flags & NDW_INSTALLFLAG_CI_PICKED_OEM) {

                        iwd->Flags &= ~NDW_INSTALLFLAG_CI_PICKED_OEM;

                        //
                        // Destroy the existing class driver list.
                        //
                        if(DevInfoElem) {
                            //
                            // Initialize a SP_DEVINFO_DATA buffer to use as an
                            // argument to SetupDiDestroyDriverInfoList.
                            //
                            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                             DevInfoElem,
                                                             &DeviceInfoData
                                                            );
                        }

                        SetupDiDestroyDriverInfoList(lpdd->DevInfoSet,
                                                     DevInfoElem ? &DeviceInfoData : NULL,
                                                     SPDIT_CLASSDRIVER
                                                    );

                        //
                        // Make sure the OEM button is shown.
                        //
                        dipb->Flags |= DI_SHOWOEM;

                        InitSelectDeviceDlg(hwndDlg, ndwData);

                    } else {
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_DYNAWIZ_SELECTCLASS_PAGE);
                    }
                    break;
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        b = FALSE;
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return b;
}


BOOL
pSetupIsSelectedHardwareIdValid(
    IN HWND           hWnd,
    IN PSP_DIALOGDATA lpdd,
    IN INT            iCur
    )
/*++

Routine Description:

    This routine will check to see if the driver selected by the user is valid.
    If the driver is not valid then we will prompt the user with a message box
    telling them that the driver was not writen for their hardware and ask them
    if they want to continue.

    A compatible driver is considered valid if one of the Hardware or
    Compatible IDs of the driver node matches a Hardware or Compatible ID of
    the hardware.  The only reason we have this check is that class-/
    co-installers can do the list themselves so we just need to make sure they
    didn't stick a driver node into the compatible list that is not really
    compatible.

    A class driver is considered valid if it has the same Name, section name,
    and INF as a driver in the compatible list.  Or if one of the Hardware or
    Compatible IDs of the driver node matches a Hardware or Compatible ID of
    the hardware.

Arguments:

    hwnd - Supplies the window handle of the wizard dialog page.

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

    iCur - The index of the selected driver in the list view.

Return Value:

    TRUE if the selected driver is valid, or if the selected driver is NOT
    valid but the user said they still want to install it.

    FALSE otherwise.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDRIVER_NODE DriverNode;
    LV_ITEM lviItem;
    PDEVINFO_ELEM DevInfoElem;
    LPTSTR Title = NULL;
    LPTSTR Message = NULL;
    UINT MessageLen;
    BOOL bRet = FALSE;
    LPTSTR IDBuffer = NULL;
    ULONG IDBufferLen;
    PTSTR pID, SelectedDriverHardwareId, SelectedDriverCompatibleId;
    DWORD i, j;
    int FailCount = 0;
    PTSTR StringBuffers = NULL;

    //
    // If the DD_FLAG_USE_DEVINFO_ELEM flag is not set then we don't have a
    // DevNode to validate the choosen ID against...so just return TRUE.
    //
    MYASSERT(lpdd);
    if(!(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM)) {
        return TRUE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return FALSE;
    }

    try {
        //
        // Figure out which device we're working with (there'd better be _some_
        // device--it doesn't make sense to ask about compatibility otherwise!
        //
        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }
        MYASSERT(DevInfoElem);
        if(!DevInfoElem) {
            //
            // Return true, since this is analogous to the case where the
            // device has no hardware or compatible IDs.
            //
            bRet = TRUE;
            leave;
        }

        //
        // We won't verify the selected driver for certain classes of devices.
        // This is usually because the device is not very Plug and Play and so
        // we can't tell what is a valid driver and what isn't a valid driver.
        // Currently the list of classes that we don't verify are:
        //
        //  Monitor
        //
        if(IsEqualGUID(&GUID_DEVCLASS_MONITOR, &(DevInfoElem->ClassGuid))) {

            bRet = TRUE;
            leave;
        }

        lviItem.mask = LVIF_PARAM;
        lviItem.iItem = iCur;
        lviItem.iSubItem = 0;

        if(ListView_GetItem(lpdd->hwndDrvList, &lviItem)) {
            DriverNode = GetDriverNodeFromLParam(pDeviceInfoSet, lpdd, lviItem.lParam);
        } else {
            DriverNode = NULL;
        }

        if(!DriverNode) {
            MYASSERT(FALSE);    // this should never happen.
            leave;
        }

        //
        // allocate memory required for various strings to reduce stack usage
        //
        StringBuffers = MyMalloc(sizeof(TCHAR)*(LINE_LEN+SDT_MAX_TEXT+REGSTR_VAL_MAX_HCID_LEN));

        if(StringBuffers) {
            Title = StringBuffers;              // [LINE_LEN]
            Message = Title+LINE_LEN;           // [SDT_MAX_TEXT]
            IDBuffer = Message+SDT_MAX_TEXT;    // [REGSTR_VAL_MAX_HCID_LEN]
        } else {
            leave;  // out-of-memory, gotta bail!
        }

        //
        // Retrieve the HardwareId for the selected driver.
        //
        SelectedDriverHardwareId = pStringTableStringFromId(
                                       pDeviceInfoSet->StringTable,
                                       DriverNode->HardwareId
                                       );

        for(i=0; i<2; i++) {

            IDBufferLen = REGSTR_VAL_MAX_HCID_LEN;

            if(CR_SUCCESS == CM_Get_DevInst_Registry_Property_Ex(
                                DevInfoElem->DevInst,
                                (i ? CM_DRP_COMPATIBLEIDS
                                   : CM_DRP_HARDWAREID),
                                NULL,
                                IDBuffer,
                                &IDBufferLen,
                                0,
                                pDeviceInfoSet->hMachine)) {
                //
                // See if the HardwareID for the selected driver matches
                // any of the Hardware or Compatible IDs for the actual
                // hardware.
                //
                for(pID = IDBuffer; *pID; pID += (lstrlen(pID) + 1)) {

                    if(!lstrcmpi(SelectedDriverHardwareId, pID)) {

                        bRet = TRUE;
                        leave;
                    }
                }

                //
                // See if any of the Compatible IDs for the selected driver
                // match any of the Hardware or Compatible IDs for the
                // actual hardware
                //
                for(j=0; j < DriverNode->NumCompatIds; j++) {

                    SelectedDriverCompatibleId = pStringTableStringFromId(
                                                     pDeviceInfoSet->StringTable,
                                                     DriverNode->CompatIdList[j]
                                                     );

                    for(pID = IDBuffer; *pID; pID += (lstrlen(pID) + 1)) {

                        if(!lstrcmpi(SelectedDriverCompatibleId, pID)) {

                            bRet = TRUE;
                            leave;
                        }
                    }
                }

            } else {

                FailCount++;
            }
        }

        //
        // If FailCount is 2 then CM_Get_DevInst_Registry_Property_Ex
        // failed for both CM_DRP_HARDWAREID and CM_DRP_COMPATIBLEIDS.
        // Since this DevNode does not have any Hardware or Compatible IDs
        // we will let the user install any driver they want on this
        // device.  This usually happens only with manually installed
        // devices.
        //
        if(FailCount == 2) {
            bRet = TRUE;
            leave;
        }

        //
        // At this point none of the Hardware or Compatible Ids of the
        // selected driver node match any of the Hardware or Compatible Ids
        // of the actual hardware.  We will do one last check here if this
        // is a class driver.  We will see if this class driver node has
        // the same description, install section, and INF as a driver in
        // the compatible list.  The reason for this is that we don't
        // handle duplicate descriptions well for class drivers since we
        // don't compute their Rank.  This means that if two driver nodes
        // exist in an INF with the same description we might not have the
        // correct matching one in the class list.
        //
        if(!lpdd->bShowCompat) {

            PDRIVER_NODE CurDriverNode = NULL;

            //
            // Enumerate through all of the compatible driver nodes
            //
            for(CurDriverNode = DevInfoElem->CompatDriverHead;
                CurDriverNode;
                CurDriverNode = CurDriverNode->Next) {

                if((CurDriverNode->InfFileName == DriverNode->InfFileName) &&
                   (CurDriverNode->InfSectionName == DriverNode->InfSectionName) &&
                   (CurDriverNode->DrvDescription == DriverNode->DrvDescription)) {

                    //
                    // We found a node that matches ours in the
                    // compatible driver list so that means that this
                    // class driver node is good.
                    //
                    bRet = TRUE;
                    leave;
                }
            }
        }

        //
        // The ID of the driver that the user selected does not match any
        // of the Hardware or Compatible IDs of this device.  Warn the user
        // that this is a bad thing and see if they want to continue.
        //
        if(!LoadString(MyDllModuleHandle, IDS_DRIVER_UPDATE_TITLE, Title, LINE_LEN)) {
            *Title = TEXT('\0');
        }

        MessageLen  = LoadString(MyDllModuleHandle, IDS_DRIVER_NOMATCH1, Message, SDT_MAX_TEXT);
        MessageLen += LoadString(MyDllModuleHandle, IDS_DRIVER_NOMATCH2, Message + MessageLen, SDT_MAX_TEXT - MessageLen);
        MessageLen += LoadString(MyDllModuleHandle, IDS_DRIVER_NOMATCH3, Message + MessageLen, SDT_MAX_TEXT - MessageLen);

        if(MessageLen) {

            if(IDYES == MessageBox(hWnd,
                                   Message,
                                   Title,
                                   MB_YESNO
                                   | MB_TASKMODAL
                                   | MB_ICONEXCLAMATION
                                   | MB_DEFBUTTON2)) {

                bRet = TRUE;
                leave;
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(StringBuffers) {
        MyFree(StringBuffers);
    }

    return bRet;
}


VOID
SetSelectedDriverNode(
    IN PSP_DIALOGDATA lpdd,
    IN INT            iCur
    )
/*++

Routine Description:

    This routine sets the selected driver for the currently selected device (or
    global class driver list if no device selected) in the device information
    set referenced in the SP_DIALOGDATA structure.  If the
    DD_FLAG_USE_DEVINFO_ELEM flag in the structure is set, then the driver is
    selected for the set or element based on the DevInfoElem pointer instead of
    the currently selected one.

Arguments:

    lpdd - Supplies the address of a dialog data structure that contains
        information about the device information set being used.

    iCur - Supplies the index within the driver listbox window containing the
        driver to be selected.

Return Value:

    None.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDRIVER_NODE DriverNode;
    LV_ITEM lviItem;
    PDEVINFO_ELEM DevInfoElem;
    TCHAR ClassGuidString[GUID_STRING_LEN];
    SP_DEVINFO_DATA DevInfoData;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return;
    }

    try {

        lviItem.mask = LVIF_PARAM;
        lviItem.iItem = iCur;
        lviItem.iSubItem = 0;

        if(ListView_GetItem(lpdd->hwndDrvList, &lviItem)) {
            DriverNode = GetDriverNodeFromLParam(pDeviceInfoSet, lpdd, lviItem.lParam);
        } else {
            DriverNode = NULL;
        }

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            //
            // If a driver node is being selected, update the device's class to
            // ensure it matches the class of the INF containing the selected
            // driver node.
            //
            if(DriverNode) {
                //
                // Get the INF class GUID for this driver node in string form,
                // because this property is stored as a REG_SZ.
                //
                pSetupStringFromGuid(&(pDeviceInfoSet->GuidTable[DriverNode->GuidIndex]),
                                     ClassGuidString,
                                     SIZECHARS(ClassGuidString)
                                    );

                //
                // Fill in a SP_DEVINFO_DATA structure for the upcoming call to
                // SetupDiSetDeviceRegistryProperty.
                //
                DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                 DevInfoElem,
                                                 &DevInfoData
                                                );

                if(!SetupDiSetDeviceRegistryProperty(lpdd->DevInfoSet,
                                                     &DevInfoData,
                                                     SPDRP_CLASSGUID,
                                                     (PBYTE)ClassGuidString,
                                                     sizeof(ClassGuidString))) {
                    //
                    // The class cannot be updated--don't change the selected
                    // driver.
                    //
                    leave;
                }
            }

            DevInfoElem->SelectedDriver = DriverNode;
            if(DriverNode) {
                DevInfoElem->SelectedDriverType = (lpdd->bShowCompat)
                                                      ? SPDIT_COMPATDRIVER
                                                      : SPDIT_CLASSDRIVER;
            } else {
                DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
            }
        } else {
            pDeviceInfoSet->SelectedClassDriver = DriverNode;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);
}


DWORD
HandleSelectOEM(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine selects a new device based on a user-supplied path.  Calling
    this routine may cause a driver list to get built, which is a potentially
    slow operation.

Arguments:

    hwndDlg - Supplies the window handle of the select device wizard page.

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error
    code indicating the cause of failure.

--*/
{
    PSP_DIALOGDATA lpdd;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    SP_DEVINFO_DATA DevInfoData;
    DWORD Err;

    MYASSERT(ndwData);
    lpdd = &(ndwData->ddData);

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return ERROR_INVALID_HANDLE;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        //
        // If this is for a particular device, then initialize a device
        // information structure to use for SelectOEMDriver.
        //
        if(DevInfoElem) {

            DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             &DevInfoData
                                            );
        }

        //
        // Unlock the device information set before popping up the OEM driver
        // selection UI.  Otherwise, our multi-threaded dialog will deadlock.
        //
        UnlockDeviceInfoSet(pDeviceInfoSet);
        pDeviceInfoSet = NULL;

        if((Err = SelectOEMDriver(hwndDlg,
                                  lpdd->DevInfoSet,
                                  DevInfoElem ? &DevInfoData : NULL,
                                  !(lpdd->flags & DD_FLAG_IS_DIALOGBOX)
                                 )) == ERROR_DI_DO_DEFAULT) {

            if(DevInfoElem && DevInfoElem->CompatDriverHead) {

                lpdd->bShowCompat = TRUE;

                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), SW_SHOW);

            } else {

                lpdd->bShowCompat = FALSE;

                //
                // Since we don't have any compatible drivers to show, we will
                // hide the show compatible and show class selection buttons.
                //
                ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), SW_HIDE);
            }

            CheckDlgButton(hwndDlg,
                           IDC_NDW_PICKDEV_COMPAT,
                           lpdd->bShowCompat ? BST_CHECKED : BST_UNCHECKED
                          );

            //
            // Enable the UI.  We turned it off when the user pressed the Have
            // Disk... button
            //
            ToggleDialogControls(hwndDlg, ndwData, TRUE);

            //
            // Fill in the list to select from
            //
            FillInDeviceList(hwndDlg, lpdd);
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return Err;
}


DWORD
SelectWindowsUpdateDriver(
    IN     HWND             hwndParent,     OPTIONAL
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN     PTSTR            CDMPath,
    IN     BOOL             IsWizard
    )
/*++

Routine Description:

    This is the worker routine that actually allows for the selection of a
    Windows Update driver.

Arguments:

    hwndParent - Optionally, supplies the window handle that is to be the
        parent for any selection UI.  If this parameter is not supplied, then
        the hwndParent field of the devinfo set or element will be used.

    DeviceInfoSet - Supplies the handle of the device info set for which a
        Windows Update driver selection is to be performed.

    DeviceInfoData - Optionally, supplies the address of the device information
        element to select a driver for.  If this parameter is not supplied,
        then a Windows Update driver for the global class driver list will be
        selected.

        If a compatible driver was found for this device, the device
        information element will have its class GUID updated upon return to
        reflect the device's new class.

    CDMPath - Supplies the directory path where Windows Update downloaded the
        driver package(s) to.

    IsWizard - Specifies whether this routine is being called in the context of
        a select device wizard page.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error
    code indicating the cause of failure.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PDEVINSTALL_PARAM_BLOCK dipb;
    DWORD Err = NO_ERROR;
    HWND hwndSave;
    LONG DriverPathSave;
    DWORD DriverPathFlagsSave;
    BOOL bRestoreHwnd = FALSE, bRestoreDriverPath = FALSE;
    UINT NewClassDriverCount;
    TCHAR Title[MAX_TITLE_LEN];
    HCURSOR hOldCursor;
    BOOL bDoneWithDrvSearch = TRUE;

    PDRIVER_NODE lpOrgCompat;
    PDRIVER_NODE lpOrgCompatTail;
    UINT         OrgCompatCount;
    PDRIVER_NODE lpOrgClass;
    PDRIVER_NODE lpOrgClassTail;
    UINT         OrgClassCount;
    PDRIVER_NODE lpOrgSel;
    PDRIVER_NODE CurDriverNode;
    PDRIVER_NODE DriverNodeHead = NULL;
    DWORD        dwOrgSelType;
    DWORD        dwOrgFlags;
    DWORD        dwOrgFlagsEx;
    BOOL         bRestoreDeviceInfo = FALSE;
    LONG         DriverPathId;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return ERROR_INVALID_HANDLE;
    }

    try {

        if(DeviceInfoData) {
            //
            // Then we're working with a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }

            dipb = &(DevInfoElem->InstallParamBlock);

        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        //
        // Make this selection window the parent window for Windows Update UI
        //
        if(hwndParent) {
            hwndSave = dipb->hwndParent;
            dipb->hwndParent = hwndParent;
            bRestoreHwnd = TRUE;
        }

        //
        // Don't assume there is no old path.  Save old one and pretend there
        // is no old one in case of cancel.
        //
        DriverPathSave = dipb->DriverPath;
        dipb->DriverPath = -1;

        //
        // Clear the DI_ENUMSINGLEINF flag, because we're going to be getting
        // a path to a directory, _not_ to an individual INF
        //
        DriverPathFlagsSave = dipb->Flags & DI_ENUMSINGLEINF;
        dipb->Flags &= ~DI_ENUMSINGLEINF;
        bRestoreDriverPath = TRUE;

        //
        // Set the DriverPath to the path returned by CDM
        //
        if((DriverPathId = pStringTableAddString(
                                      pDeviceInfoSet->StringTable,
                                      CDMPath,
                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                      NULL,0)) == -1) {

            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;

        } else {

            dipb->DriverPath = DriverPathId;

        }

        //
        // Save the Original List info, in case we get
        // an empty list on the Windows Update information.
        //
        // Note: we don't attempt to save/restore our driver enumeration hints
        //
        if(DevInfoElem) {
            lpOrgClass      = DevInfoElem->ClassDriverHead;
            lpOrgClassTail  = DevInfoElem->ClassDriverTail;
            OrgClassCount   = DevInfoElem->ClassDriverCount;

            lpOrgSel        = DevInfoElem->SelectedDriver;
            dwOrgSelType    = DevInfoElem->SelectedDriverType;
        } else {
            lpOrgClass      = pDeviceInfoSet->ClassDriverHead;
            lpOrgClassTail  = pDeviceInfoSet->ClassDriverTail;
            OrgClassCount   = pDeviceInfoSet->ClassDriverCount;

            lpOrgSel        = pDeviceInfoSet->SelectedClassDriver;
            dwOrgSelType    = lpOrgSel ? SPDIT_CLASSDRIVER : SPDIT_NODRIVER;
        }

        dwOrgFlags = dipb->Flags;
        dwOrgFlagsEx = dipb->FlagsEx;

        bRestoreDeviceInfo = TRUE;

        if(DevInfoElem) {
            DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
            DevInfoElem->ClassDriverCount = 0;
            DevInfoElem->ClassDriverEnumHint = NULL;
            DevInfoElem->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

            DevInfoElem->SelectedDriver = NULL;
            DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
        } else {
            lpOrgCompat = NULL; // just so we won't ever try to free this list.

            pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
            pDeviceInfoSet->ClassDriverCount = 0;
            pDeviceInfoSet->ClassDriverEnumHint = NULL;
            pDeviceInfoSet->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

            pDeviceInfoSet->SelectedClassDriver = NULL;
        }

        dipb->Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
        dipb->FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;


        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); // Potentially slow operation ahead!
        dipb->FlagsEx |= DI_FLAGSEX_INET_DRIVER;
        bDoneWithDrvSearch = FALSE;

        Err = GLE_FN_CALL(FALSE,
                          SetupDiBuildDriverInfoList(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDIT_CLASSDRIVER)
                         );

        dipb->FlagsEx &= ~DI_FLAGSEX_INET_DRIVER;
        SetCursor(hOldCursor);                    // done with slow operation.
        bDoneWithDrvSearch = TRUE;

        if(Err != NO_ERROR) {
            leave;
        }

        if(DevInfoElem) {
            NewClassDriverCount = DevInfoElem->ClassDriverCount;
            DriverNodeHead = DevInfoElem->ClassDriverHead;
        } else {
            NewClassDriverCount = pDeviceInfoSet->ClassDriverCount;
            DriverNodeHead = pDeviceInfoSet->ClassDriverHead;
        }

        if(!NewClassDriverCount) {

            if(!LoadString(MyDllModuleHandle,
                           IDS_SELECT_DEVICE,
                           Title,
                           SIZECHARS(Title))) {
                *Title = TEXT('\0');
            }

            FormatMessageBox(MyDllModuleHandle,
                             NULL,
                             MSG_NO_DEVICEINFO_ERROR,
                             Title,
                             MB_OK | MB_TASKMODAL
                            );

            Err = ERROR_DI_BAD_PATH;
            leave;
        }

        //
        // If we get to here, then we have at least one class driver--the class
        // driver list head had better point to something!
        //
        MYASSERT(DriverNodeHead);

        //
        // Assume every driver node in the list is signed.  Note that this
        // may not actually be the case, as Windows Update may have given
        // us a "stub" INF whose only use is to build up a list of choices
        // to present to the user.  After the user makes a selection, the
        // relevant ID will then be sent to Windows Update to retrieve the
        // real (signed) package.
        //
        for(CurDriverNode=DriverNodeHead;
            CurDriverNode;
            CurDriverNode = CurDriverNode->Next) {

            CurDriverNode->Flags |= DNF_INF_IS_SIGNED;
        }

        //
        // We're happy with our new class driver list, so destroy the original
        // list
        //
        if(bRestoreDeviceInfo) {
            DereferenceClassDriverList(pDeviceInfoSet, lpOrgClass);
            bRestoreDeviceInfo = FALSE;
        }

        //
        // We're happy with the new path, so we don't want to restore the
        // original path.
        //
        bRestoreDriverPath = FALSE;

    } except(pSetupExceptionFilter(GetExceptionCode())) {

        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);

        if(!bDoneWithDrvSearch) {
            dipb->FlagsEx &= ~DI_FLAGSEX_INET_DRIVER;
            SetCursor(hOldCursor);
        }
    }

    if(bRestoreDeviceInfo || bRestoreHwnd || bRestoreDriverPath) {

        try {
            //
            // If necessary, restore the original list(s).
            //
            if(bRestoreDeviceInfo) {

                if(DevInfoElem) {

                    DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                    DevInfoElem->ClassDriverHead = lpOrgClass;
                    DevInfoElem->ClassDriverTail = lpOrgClassTail;
                    DevInfoElem->ClassDriverCount = OrgClassCount;

                    DevInfoElem->SelectedDriver = lpOrgSel;
                    DevInfoElem->SelectedDriverType = dwOrgSelType;

                } else {

                    DereferenceClassDriverList(pDeviceInfoSet, pDeviceInfoSet->ClassDriverHead);
                    pDeviceInfoSet->ClassDriverHead = lpOrgClass;
                    pDeviceInfoSet->ClassDriverTail = lpOrgClassTail;
                    pDeviceInfoSet->ClassDriverCount = OrgClassCount;

                    pDeviceInfoSet->SelectedClassDriver = lpOrgSel;
                }

                dipb->Flags = dwOrgFlags;
                dipb->FlagsEx = dwOrgFlagsEx;
            }

            //
            // If the install param block needs its parent hwnd restored, do so
            // now.
            //
            if(bRestoreHwnd) {
                dipb->hwndParent = hwndSave;
            }

            //
            // Likewise, restore the old driver path if necessary.
            //
            if(bRestoreDriverPath) {
                dipb->DriverPath = DriverPathSave;
                dipb->Flags |= DriverPathFlagsSave;
            }

        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(),
                                   ERROR_INVALID_PARAMETER,
                                   NULL
                                  );
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return Err;
}


DWORD
HandleWindowsUpdate(
    IN     HWND            hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine selects a new driver based on a list from INF file(s) that get
    downloaded from the Windows Update Internet site.

Arguments:

    hwndDlg - Supplies the window handle of the select device wizard page.

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error
    code indicating the cause of failure.

--*/
{
    PSP_DIALOGDATA lpdd;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINSTALL_PARAM_BLOCK dipb;
    SP_WINDOWSUPDATE_PARAMS WindowsUpdateParams;
    PDEVINFO_ELEM DevInfoElem;
    SP_DEVINFO_DATA DevInfoData;
    TCHAR CDMPath[MAX_PATH];
    ULONG BufferLen;
    DOWNLOADINFO DownloadInfo;
    HMODULE hModCDM = NULL;
    DOWNLOAD_UPDATED_FILES_PROC DownloadUpdateFilesProc;
    DWORD Err;
    TCHAR Title[MAX_TITLE_LEN];
    SPFUSIONINSTANCE spFusionInstance;
    BOOL bLeaveFusionContext = FALSE;

    MYASSERT(ndwData);
    lpdd = &(ndwData->ddData);

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return ERROR_INVALID_HANDLE;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        //
        // If this is for a particular device, then initialize a device
        // information structure.
        //
        if(DevInfoElem) {

            DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             &DevInfoData
                                            );

            dipb = &(DevInfoElem->InstallParamBlock);

        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        //
        // Call the class installer to get the package ID and so it can open
        // a handle to the Windows Update server.
        //
        ZeroMemory(&WindowsUpdateParams, sizeof(SP_WINDOWSUPDATE_PARAMS));
        WindowsUpdateParams.ClassInstallHeader.InstallFunction = DIF_GETWINDOWSUPDATEINFO;
        WindowsUpdateParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);

        Err = DoInstallActionWithParams(DIF_GETWINDOWSUPDATEINFO,
                                        pDeviceInfoSet,
                                        DevInfoElem ? &DevInfoData : NULL,
                                        &WindowsUpdateParams.ClassInstallHeader,
                                        sizeof(SP_WINDOWSUPDATE_PARAMS),
                                        INSTALLACTION_CALL_CI
                                       );
        if(Err != NO_ERROR) {
            leave;
        }

        //
        // We now have a PackageId and a handle to the Windows Update
        // server.
        //

        //
        // Fill In the DOWNLOADINFO structure to pass to CDM.DLL
        //
        ZeroMemory(&DownloadInfo, sizeof(DOWNLOADINFO));
        DownloadInfo.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
        DownloadInfo.lpFile = NULL;

        DownloadInfo.lpHardwareIDs = (LPCWSTR)WindowsUpdateParams.PackageId;

        DownloadInfo.lpDeviceInstanceID = NULL;

        GetVersionEx((OSVERSIONINFOW *)&DownloadInfo.OSVersionInfo);

        //
        // Set dwArchitecture to PROCESSOR_ARCHITECTURE_UNKNOWN, this
        // causes Windows Update to check base on the architecture of the
        // machine itself.  You only need to explictly set the value if
        // you want to download drivers for a different architecture than
        // the machine this is running on.
        //
        DownloadInfo.dwArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
        DownloadInfo.dwFlags = 0;
        DownloadInfo.dwClientID = 0;
        DownloadInfo.localid = 0;

        CDMPath[0] = TEXT('\0');

        //
        // Dynamically retrieve the CDM function we need to call.
        //
        bLeaveFusionContext = spFusionEnterContext(NULL, &spFusionInstance);

        Err = GLE_FN_CALL(NULL, hModCDM = LoadLibrary(TEXT("cdm.dll")));

        if(Err == NO_ERROR) {

            Err = GLE_FN_CALL(NULL,
                              DownloadUpdateFilesProc = (PVOID)GetProcAddress(
                                                                   hModCDM,
                                                                   "DownloadUpdatedFiles")
                              );
        }

        if(Err == NO_ERROR) {

            Err = GLE_FN_CALL(FALSE,
                              DownloadUpdateFilesProc(WindowsUpdateParams.CDMContext,
                                                      hwndDlg,
                                                      &DownloadInfo,
                                                      CDMPath,
                                                      sizeof(CDMPath),
                                                      &BufferLen)
                             );

            if((Err == NO_ERROR) && !(*CDMPath)) {
                Err = ERROR_DI_BAD_PATH;
            }
        }

        if(hModCDM) {
            FreeLibrary(hModCDM);
            hModCDM = NULL;
        }

        if(bLeaveFusionContext) {
            spFusionLeaveContext(&spFusionInstance);
            bLeaveFusionContext = FALSE;
        }

        if(Err != NO_ERROR) {
            //
            // Pop up an error messagebox informing the user that we didn't
            // get any drivers from Windows Update.
            //
            if(!LoadString(MyDllModuleHandle,
                           IDS_SELECT_DEVICE,
                           Title,
                           SIZECHARS(Title))) {
                *Title = TEXT('\0');
            }

            FormatMessageBox(MyDllModuleHandle,
                             NULL,
                             MSG_NO_DEVICEINFO_ERROR,
                             Title,
                             MB_OK | MB_TASKMODAL
                            );
            leave;
        }

        Err = SelectWindowsUpdateDriver(hwndDlg,
                                        lpdd->DevInfoSet,
                                        DevInfoElem ? &DevInfoData : NULL,
                                        CDMPath,
                                        !(lpdd->flags & DD_FLAG_IS_DIALOGBOX)
                                       );

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // Fill in the list to select from
        //
        lpdd->bShowCompat = FALSE;
        CheckDlgButton(hwndDlg,
                       IDC_NDW_PICKDEV_COMPAT,
                       BST_UNCHECKED
                       );

        //
        // Enable the UI.  We turned it off when the user pressed the Windows
        // Update... button
        //
        ToggleDialogControls(hwndDlg, ndwData, TRUE);

        FillInDeviceList(hwndDlg, lpdd);

        //
        // Since we only show the class list when selecting from Windows
        // Update, hide the selection buttons.
        //
        ShowWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), SW_HIDE);

    } except(pSetupExceptionFilter(GetExceptionCode())) {

        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);

        if(hModCDM) {
            FreeLibrary(hModCDM);
        }

        if(bLeaveFusionContext) {
            spFusionLeaveContext(&spFusionInstance);
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return Err;
}


PNEWDEVWIZ_DATA
GetNewDevWizDataFromPsPage(
    LPPROPSHEETPAGE ppsp
    )
/*++

Routine Description:

    This routine retrieves a pointer to a NEWDEVWIZDATA structure to be used by
    a wizard page dialog proc.  It is called during the WM_INITDIALOG handling.

Arguments:

    Page - Property sheet page structure for this wizard page.

Return Value:

    If success, a pointer to the structure, NULL otherwise.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PVOID WizObjectId;
    PWIZPAGE_OBJECT CurWizObject = NULL;

    //
    // Access the device info set handle stored in the propsheetpage's lParam.
    //
    MYASSERT(ppsp);
    if(pDeviceInfoSet = AccessDeviceInfoSet((HDEVINFO)(ppsp->lParam))) {

        try {
            //
            // The ObjectID (pointer, actually) for the corresponding wizard
            // object for this page is stored at the end of the ppsp structure.
            // Retrieve this now, and look for it in the devinfo set's list of
            // wizard objects.
            //
            WizObjectId = *((PVOID *)(&(((PBYTE)ppsp)[sizeof(PROPSHEETPAGE)])));

            for(CurWizObject = pDeviceInfoSet->WizPageList;
                CurWizObject;
                CurWizObject = CurWizObject->Next) {

                if(WizObjectId == CurWizObject) {
                    //
                    // We found our object.
                    //
                    break;
                }
            }

        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
            CurWizObject = NULL;
        }

        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return CurWizObject ? CurWizObject->ndwData : NULL;
}


BOOL
WINAPI
SetupDiSelectDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    Default handler for DIF_SELECTDEVICE

    This routine will handle the UI for allowing a user to select a driver
    for the specified device information set or element. By using the Flags
    field of the installation parameter block struct, the caller can specify
    special handling of the UI, such as allowing selecting from OEM disks.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        driver is to be selected.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for which a driver is to be selected.  If this parameter is
        not specified, then a driver will be selected for the global class
        driver list associated with the device information set itself.

        This is an IN OUT parameter because the class GUID for the device will
        be updated to reflect the class of the most-compatible driver, if a
        compatible driver list was built.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err = NO_ERROR;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PDEVINSTALL_PARAM_BLOCK dipb;
    WIZPAGE_OBJECT WizPageObject;
    NEWDEVWIZ_DATA ndwData;
    PWIZPAGE_OBJECT CurWizObject, PrevWizObject;
    //
    // Store the address of the corresponding wizard object at the
    // end of the PROPSHEETPAGE buffer.
    //
    BYTE pspBuffer[sizeof(PROPSHEETPAGE) + sizeof(PVOID)];
    LPPROPSHEETPAGE Page = (LPPROPSHEETPAGE)pspBuffer;

    try {
        //
        // Make sure we're running interactively.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            Err = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
            leave;
        }

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        //
        // This routine cannot be called when the lock level is nested
        // (i.e., > 1).  This is explicitly disallowed, so that our multi-
        // threaded dialog won't deadlock.
        //
        if(pDeviceInfoSet->LockRefCount > 1) {
            Err = ERROR_DEVINFO_LIST_LOCKED;
            leave;
        }

        if(DeviceInfoData) {
            //
            // Special check to make sure we aren't being passed a zombie
            // (different from phantom, the zombie devinfo element is one whose
            // corresponding devinst was deleted via SetupDiRemoveDevice, but
            // who lingers on until the caller kills it via
            // SetupDiDeleteDeviceInfo or SetupDiDestroyDeviceInfoList).
            //
            if(!DeviceInfoData->DevInst) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }

            //
            // Then we are to select a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }

            dipb = &(DevInfoElem->InstallParamBlock);
        } else {
            dipb = &(pDeviceInfoSet->InstallParamBlock);
        }

        ZeroMemory(&ndwData, sizeof(ndwData));
        ndwData.ddData.iCurDesc = -1;
        ndwData.ddData.DevInfoSet = DeviceInfoSet;
        ndwData.ddData.DevInfoElem = DevInfoElem;
        ndwData.ddData.flags = DD_FLAG_USE_DEVINFO_ELEM | DD_FLAG_IS_DIALOGBOX;

        WizPageObject.RefCount = 1;
        WizPageObject.ndwData = &ndwData;
        //
        // We're safe in placing this stack object in the devinfo set's linked
        // list, since nobody will ever attempt to free it.
        //
        WizPageObject.Next = pDeviceInfoSet->WizPageList;
        pDeviceInfoSet->WizPageList = &WizPageObject;

        //
        // Since we're using the same code as the Add New Device Wizard, we
        // have to supply a LPROPSHEETPAGE as the lParam to the DialogProc.
        // (All we care about is the lParam field, and the DWORD at the end
        // of the buffer.)
        //
        Page->lParam = (LPARAM)DeviceInfoSet;

        *((PVOID *)(&(pspBuffer[sizeof(PROPSHEETPAGE)]))) = &WizPageObject;

        //
        // Release the lock, so other stuff can happen while this dialog is up.
        //
        UnlockDeviceInfoSet(pDeviceInfoSet);
        pDeviceInfoSet = NULL;

        Err = (DWORD)DialogBoxParam(MyDllModuleHandle,
                                    MAKEINTRESOURCE(DLG_DEVINSTALL),
                                    dipb->hwndParent,
                                    SelectDeviceDlgProc,
                                    (LPARAM)Page
                                   );

        //
        // Re-acquire the devinfo set lock.
        //
        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            //
            // should never hit this code path
            // this would imply another thread messed this handle up
            //
            MYASSERT(pDeviceInfoSet);
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        //
        // Now remove the wizard page object from the devinfo set's list.  We
        // can't assume that it's still at the head of the list, since someone
        // else couldn've added another page.
        //
        for(CurWizObject = pDeviceInfoSet->WizPageList, PrevWizObject = NULL;
            CurWizObject;
            PrevWizObject = CurWizObject, CurWizObject = CurWizObject->Next) {

            if(CurWizObject == &WizPageObject) {
                break;
            }
        }

        MYASSERT(CurWizObject);

        if(PrevWizObject) {
            PrevWizObject->Next = CurWizObject->Next;
        } else {
            pDeviceInfoSet->WizPageList = CurWizObject->Next;
        }

        if(DeviceInfoData) {
            //
            // Update the caller's device information element with its
            // (potentially) new class.
            //
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             DeviceInfoData
                                            );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
bNoDevsToShow(
    IN PDEVINFO_ELEM DevInfoElem
    )
/*++

Routine Description:

    This routine determines whether or not there are any compatible devices to
    be displayed for the specified devinfo element.

Arguments:

    DevInfoElem - Supplies the address of a devinfo element to check.

Return Value:

    If there are no devices to show, the return value is TRUE.
    If there is at least one device (driver node) without the
    DNF_EXCLUDEFROMLIST flag set, the return value is FALSE.

--*/
{
    PDRIVER_NODE CurDriverNode;

    for(CurDriverNode = DevInfoElem->CompatDriverHead;
        CurDriverNode;
        CurDriverNode = CurDriverNode->Next) {

        if(!(CurDriverNode->Flags & DNF_OLD_INET_DRIVER) &&
           !(CurDriverNode->Flags & DNF_BAD_DRIVER) &&
           (!(CurDriverNode->Flags & DNF_EXCLUDEFROMLIST) ||
            (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALLOWEXCLUDEDDRVS))) {

            return FALSE;
        }
    }

    return TRUE;
}


VOID
OnCancel(
    IN PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine is only called in the select device dialog (not wizard) case.
    Its sole purpose is to destroy any driver lists that weren't present before
    SetupDiSelectDevice was called.

Arguments:

    ndwData - Supplies the address of a data structure containing information
        on the driver lists to be (possibly) destroyed.

Return Value:

    None.

--*/
{
    PSP_DIALOGDATA lpdd;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    DWORD SelectedDriverType = SPDIT_NODRIVER;

    MYASSERT(ndwData);
    lpdd = &(ndwData->ddData);

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {

            if(lpdd->bKeeplpSelectedDrv) {
                SelectedDriverType = DevInfoElem->SelectedDriverType;
            } else {
                DevInfoElem->SelectedDriver = NULL;
                DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
            }

            if((DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) &&
               !lpdd->bKeeplpClassDrvList && (SelectedDriverType != SPDIT_CLASSDRIVER)) {

                DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                DevInfoElem->ClassDriverCount = 0;
                DevInfoElem->ClassDriverEnumHint = NULL;
                DevInfoElem->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;
                DevInfoElem->InstallParamBlock.Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;
            }

            if((DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDCOMPATINFO) &&
               !lpdd->bKeeplpCompatDrvList && (SelectedDriverType != SPDIT_COMPATDRIVER)) {

                DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);
                DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                DevInfoElem->CompatDriverCount = 0;
                DevInfoElem->CompatDriverEnumHint = NULL;
                DevInfoElem->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;
                DevInfoElem->InstallParamBlock.Flags   &= ~DI_DIDCOMPAT;
                DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDCOMPATINFO;
            }

        } else {

            if(lpdd->bKeeplpSelectedDrv) {
                if(pDeviceInfoSet->SelectedClassDriver) {
                    SelectedDriverType = SPDIT_CLASSDRIVER;
                }
            } else {
                pDeviceInfoSet->SelectedClassDriver = NULL;
            }

            if((pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) &&
               !lpdd->bKeeplpClassDrvList && (SelectedDriverType != SPDIT_CLASSDRIVER)) {

                DereferenceClassDriverList(pDeviceInfoSet, pDeviceInfoSet->ClassDriverHead);
                pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
                pDeviceInfoSet->ClassDriverCount = 0;
                pDeviceInfoSet->ClassDriverEnumHint = NULL;
                pDeviceInfoSet->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;
                pDeviceInfoSet->InstallParamBlock.Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                pDeviceInfoSet->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);
}


LONG
GetCurDesc(
    IN PSP_DIALOGDATA lpdd
    )
/*++

Routine Description:

    This routine returns the (case-insensitive) string table index for the
    description of the currently selected driver.  This is used to select a
    particular entry in a listview control.

Arguments:

    lpdd - Supplies the address of a dialog data structure that contains
        information about the device information set being used.

Return Value:

    The string table ID for the device description, as stored in the currently-
    selected driver node.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    LONG ret;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return -1;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            ret = DevInfoElem->SelectedDriver
                      ? DevInfoElem->SelectedDriver->DevDescription
                      : -1;
        } else {
            ret = pDeviceInfoSet->SelectedClassDriver
                      ? pDeviceInfoSet->SelectedClassDriver->DevDescription
                      : -1;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        ret = -1;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return ret;
}


VOID
__cdecl
ClassDriverSearchThread(
    IN PVOID Context
    )

/*++

Routine Description:

    Thread entry point to build a class driver list asynchronously to the main
    thread which is displaying a Select Device dialog.  This thread will free
    the memory containing its context, so the main thread should not access it
    after passing it to this thread.

Arguments:

    Context - supplies driver search context.

Return Value:

    None.

--*/

{
    PCLASSDRV_THREAD_CONTEXT ClassDrvThreadContext = Context;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    BOOL b;
    DWORD Err;

    //
    // OR in the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS flag so that we don't
    // include old internet drivers in the list that we get back.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(SetupDiGetDeviceInstallParams(ClassDrvThreadContext->DeviceInfoSet,
                                     &(ClassDrvThreadContext->DeviceInfoData),
                                     &DeviceInstallParams))
    {
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;

        SetupDiSetDeviceInstallParams(ClassDrvThreadContext->DeviceInfoSet,
                                      &(ClassDrvThreadContext->DeviceInfoData),
                                      &DeviceInstallParams
                                     );
    }

    Err = GLE_FN_CALL(FALSE,
                      b = SetupDiBuildDriverInfoList(
                              ClassDrvThreadContext->DeviceInfoSet,
                              &(ClassDrvThreadContext->DeviceInfoData),
                              SPDIT_CLASSDRIVER)
                     );

    //
    // Now send a message to our notification window informing them of the outcome.
    //
    PostMessage(ClassDrvThreadContext->NotificationWindow,
                WMX_CLASSDRVLIST_DONE,
                (WPARAM)b,
                (LPARAM)Err
               );

    MyFree(Context);

    //
    // Done.
    //
    _endthread();
}


BOOL
pSetupIsClassDriverListBuilt(
    IN PSP_DIALOGDATA lpdd
    )
/*++

Routine Description:

    This routine determines whether or not a class driver list has already been
    built for the specified dialog data.

Arguments:

    lpdd - Supplies the address of a dialog data buffer that is being queried
        for the presence of a class driver list.

Return Value:

    If a class driver list has already been built, the return value is TRUE,
    otherwise, it is FALSE.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    BOOL b = FALSE;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return FALSE;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            b = DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST;
        } else {
            b = pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return b;
}


VOID
pSetupDevInfoDataFromDialogData(
    IN  PSP_DIALOGDATA   lpdd,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine fills in a SP_DEVINFO_DATA structure based on the device
    information element specified in the supplied dialog data.

Arguments:

    lpdd - Supplies the address of a dialog data buffer that specifies a
        devinfo element to be used in filling in the DeviceInfoData buffer.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure that
        is filled in with information about the devinfo element specified in
        the dialog data.

Return Value:

    None.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        //
        // The dialog data had better be referencing a devinfo element!
        //
        MYASSERT(DevInfoElem);

        DeviceInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
        DevInfoDataFromDeviceInfoElement(pDeviceInfoSet, DevInfoElem, DeviceInfoData);

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);
}


VOID
CleanupDriverLists(
    IN OUT PNEWDEVWIZ_DATA ndwData
    )
/*++

Routine Description:

    This routine will destroy both the class and compatible driver lists that
    were created while the wizard page was up.

Arguments:

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

Return Value:

    None.

--*/
{
    PSP_DIALOGDATA lpdd;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    SP_DEVINFO_DATA DeviceInfoData;

    MYASSERT(ndwData);
    lpdd = &(ndwData->ddData);

    MYASSERT(lpdd);
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(lpdd->DevInfoSet))) {
        //
        // should never hit this code path
        //
        MYASSERT(pDeviceInfoSet);
        return;
    }

    try {

        if(lpdd->flags & DD_FLAG_USE_DEVINFO_ELEM) {
            DevInfoElem = lpdd->DevInfoElem;
        } else {
            DevInfoElem = pDeviceInfoSet->SelectedDevInfoElem;
        }

        if(DevInfoElem) {
            //
            // Initialize a SP_DEVINFO_DATA buffer to use as an argument to
            // SetupDiDestroyDriverInfoList.
            //
            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             &DeviceInfoData
                                            );

            //
            // We need to reset the DriverPath so that if we come back into the
            // wizard we will rebuild from the correct directory.  Otherwise we
            // will be stuck with the Have Disk... path that the user entered.
            //
            DevInfoElem->InstallParamBlock.DriverPath = -1;

        } else {

            pDeviceInfoSet->InstallParamBlock.DriverPath = -1;
        }

        SetupDiDestroyDriverInfoList(pDeviceInfoSet,
                                     DevInfoElem ? &DeviceInfoData : NULL,
                                     SPDIT_COMPATDRIVER
                                    );

        SetupDiDestroyDriverInfoList(pDeviceInfoSet,
                                     DevInfoElem ? &DeviceInfoData : NULL,
                                     SPDIT_CLASSDRIVER
                                    );


    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);
}


VOID
ToggleDialogControls(
    IN HWND                hwndDlg,
    IN OUT PNEWDEVWIZ_DATA ndwData,
    IN BOOL                Enable
    )
/*++

Routine Description:

    This routine either enables or disables all controls on a Select Device
    dialog box, depending on the value of Enable.

Arguments:

    hwndDlg - Supplies the handle of the Select Device dialog

    ndwData - Supplies the address of a New Device Wizard data block to be used
        during the processing of this message.

    Enable - If TRUE, then enable all controls (with possible exception of
        "Show all devices" radio button (if class list search failed).  If
        FALSE, disable all controls.

Return Value:

    None.

--*/
{
    //
    // If we're enabling controls, make sure we only enable the "Show
    // compatible drivers" check box if we successfully built a class list.
    //
    if(Enable) {
        if(!((ndwData->ddData).flags & DD_FLAG_CLASSLIST_FAILED)) {
            EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), TRUE);
        } else {
            //
            // The class list failed to build, so we will show the compatible
            // list only.  Check and disable the show compatible check box.
            //
            (ndwData->ddData).bShowCompat = TRUE;
            CheckDlgButton(hwndDlg, IDC_NDW_PICKDEV_COMPAT, BST_CHECKED);
            EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), FALSE);
        }
    } else {
        EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_COMPAT), FALSE);
    }

    EnableWindow((ndwData->ddData).hwndDrvList, Enable);
    EnableWindow((ndwData->ddData).hwndMfgList, Enable);

    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_HAVEDISK), Enable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_WINDOWSUPDATE), Enable);

    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_ICON), Enable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_TEXT), Enable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_NDW_PICKDEV_SIGNED_LINK), Enable);

    if ((ndwData->ddData).flags & DD_FLAG_IS_DIALOGBOX) {
        EnableWindow(GetDlgItem(hwndDlg, IDOK), Enable);
        EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), Enable);
    } else {
        INT WizardFlags = 0;

        if (Enable) {
            //
            // Don't show the back button if we are in express mode.
            //
            if(!((ndwData->InstallData).Flags & NDW_INSTALLFLAG_SKIPCLASSLIST) ||
               !((ndwData->InstallData).Flags & NDW_INSTALLFLAG_EXPRESSINTRO) ||
               ((ndwData->InstallData).DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED)) {

                WizardFlags |= PSWIZB_BACK;
            }

            //
            // Show the Next button if there is at least one driver selected in the
            // list view.
            //
            if(ListView_GetSelectedCount((ndwData->ddData).hwndDrvList) > 0) {
                WizardFlags |= PSWIZB_NEXT;
            }
        }

        PropSheet_SetWizButtons(GetParent(hwndDlg), WizardFlags);

        EnableWindow(GetDlgItem(GetParent(hwndDlg), IDCANCEL), Enable);
    }
}


BOOL
CDMIsInternetAvailable(
    void
    )
/*++

Routine Description:

    This routine will return TRUE or FALSE based on if this machine can get to
    the Internet or not.

Arguments:

    None

Return Value:

    TRUE if the machine can get to the Internet.
    FALSE if the machine can NOT get to the Internet.

--*/
{
    BOOL IsInternetAvailable = FALSE;
    HKEY hKey = INVALID_HANDLE_VALUE;
    DWORD Policy;
    ULONG cbData;
    HMODULE hModCDM = NULL;
    CDM_INTERNET_AVAILABLE_PROC CdmInternetAvailable;
    SPFUSIONINSTANCE spFusionInstance;
    BOOL bLeaveFusionContext = FALSE;

    try {
        //
        // Check the DontSearchWindowsUpdate DriverSearching policy.
        //
        if(ERROR_SUCCESS == RegOpenKeyEx(
                                HKEY_CURRENT_USER,
                                TEXT("Software\\Policies\\Microsoft\\Windows\\DriverSearching"),
                                0,
                                KEY_READ,
                                &hKey)) {

            cbData = sizeof(Policy);
            //
            //  Initialize Policy, so we don't pickup random data if
            //  actual cbData size < sizeof(DWORD)
            //
            Policy = 0;
            if(ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                TEXT("DontSearchWindowsUpdate"),
                                                NULL,
                                                NULL,
                                                (LPBYTE)&Policy,
                                                &cbData)) {
                if(Policy) {
                    //
                    // If the DontSearchWindowsUpdate policy is set then we
                    // want to return FALSE.
                    //
                    leave;
                }
            }

        } else {
            //
            // Couldn't open the policy registry key--make sure it's still set
            // to an invalid value so we'll know not to try and close it later.
            //
            hKey = INVALID_HANDLE_VALUE;
        }

        bLeaveFusionContext = spFusionEnterContext(NULL,&spFusionInstance);

        if((NO_ERROR != GLE_FN_CALL(NULL, hModCDM = LoadLibrary(TEXT("cdm.dll")))) ||
           (NO_ERROR != GLE_FN_CALL(NULL, CdmInternetAvailable = (PVOID)GetProcAddress(hModCDM, "DownloadIsInternetAvailable")))) {

            leave;
        }

        IsInternetAvailable = CdmInternetAvailable();

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    if(hModCDM) {
        FreeLibrary(hModCDM);
    }

    if(bLeaveFusionContext) {
        spFusionLeaveContext(&spFusionInstance);
    }

    if(hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    return IsInternetAvailable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devwmi.c ===
/*++
    
    Microsoft Windows
    Copyright (c) Microsoft Corporation.  All rights reserved.

    File:       DEVWMI.C
    
    Contents: 
      
        The purpose of this file is to establish security on driver while it is 
        being installed on the system.  The function SetupConfigureWmiFromInfSection 
        is the external call that will establish security for a device when passed
        the [DDInstall.WMI] section and the appropriate INF and flags.  
                                 
    Notes:
    
        To configure WMI security for downlevel platforms where the [DDInstall.WMI]
        section isn't natively supported by setupapi, a redistributable co-installer 
        is supplied in the DDK for use on those platforms.
    

--*/

#include "precomp.h"
#pragma hdrstop

#include <sddl.h>
#include <aclapi.h>
#include <strsafe.h>
 
//
// ** Function Prototypes **
//

ULONG 
ParseSection(
    IN     INFCONTEXT  InfLineContext,
    IN OUT PTCHAR     *GuidString,
    IN OUT ULONG      *GuidStringLen,
    IN OUT PDWORD      Flags,
    IN OUT PTCHAR     *SectionNameString,
    IN OUT ULONG      *SectionNameStringLen
    );

ULONG 
EstablishGuidSecurity(
    IN PTCHAR GuidString,
    IN PTCHAR SDDLString,
    IN DWORD  Flags
    );


ULONG
GetSecurityKeyword(
    IN     HINF     InfFile,
    IN     LPCTSTR  WMIINterfaceSection,
    IN OUT PTCHAR  *SDDLString,
    IN OUT ULONG   *SDDLStringLen
    );

ULONG 
ParseSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR   SD,
    OUT PSECURITY_INFORMATION  SecurityInformation,
    OUT PSID                  *Owner,
    OUT PSID                  *Group,
    OUT PACL                  *Dacl,
    OUT PACL                  *Sacl
    );


//
// these are keywords introduced by this co-installer
// note that the names are not case sensitive
//
#define WMIINTERFACE_KEY           TEXT("WmiInterface")
#define WMIGUIDSECURITYSECTION_KEY TEXT("security")

//
// ANSI version
//

WINSETUPAPI
BOOL
WINAPI
SetupConfigureWmiFromInfSectionA(
    IN HINF   InfHandle,
    IN PCSTR  SectionName,
    IN DWORD  Flags
    ) 
{

    DWORD  rc;
    PWSTR UnicodeSectionName = NULL;

    try {

        //
        // For this API, only the SectionName needs to be converted to Unicode since it 
        // is the only string passed in as a parameter.
        //
        rc = pSetupCaptureAndConvertAnsiArg(SectionName,&UnicodeSectionName);
        if(rc != NO_ERROR) { 
            leave; 
        }

        rc = GLE_FN_CALL(FALSE, 
                         SetupConfigureWmiFromInfSection(InfHandle,
                                                         UnicodeSectionName,
                                                         Flags)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(UnicodeSectionName) {
        MyFree(UnicodeSectionName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);

}


//
// UNICODE version
//
WINSETUPAPI
BOOL
WINAPI
SetupConfigureWmiFromInfSection(
    IN HINF   InfHandle,
    IN PCTSTR SectionName,
    IN DWORD  Flags
    )
/*++

Routine Description:

    Process all WmiInterface lines from the WMI install sections, by parsing  
    the directives to obatins the GUID and SDDL strings.  For each corresponding 
    SDDL for GUID, then establish the appropriate security descriptors.

Arguments:

    InfHandle     [in] - handle to INF file
    SectionName   [in] - name of the WMI install section [DDInstall.WMI]
    Flags         [in] - SCWMI_CLOBBER_SECURITY flag only (this flag will override any
                         flag specified in the INF).
    
Return Value:

    TRUE if successful, otherwise FALSE>
    Win32 error code retrieved via GetLastError(), or ERROR_UNIDENTIFIED_ERROR
    if GetLastError() returned NO_ERROR.


--*/ 
{
    PTCHAR       GuidString, SDDLString, SectionNameString, InterfaceName;
    ULONG        GuidStringLen, SDDLStringLen, SectionNameStringLen, InterfaceNameLen;
    INFCONTEXT   InfLineContext;
    PLOADED_INF  pInf;
    DWORD        Status;
    INT          count;

    //
    // Initialize all of the variables
    //
    Status = NO_ERROR;

    GuidString = NULL;
    GuidStringLen = 0;
    SectionNameString = NULL;
    SectionNameStringLen = 0;
    SDDLString = NULL;
    SDDLStringLen = 0;
    InterfaceName =  NULL;
    count = 0;
    pInf = NULL;

    try {
        if((InfHandle == INVALID_HANDLE_VALUE) ||
           (InfHandle == NULL)) {
            Status = ERROR_INVALID_HANDLE;
            leave;
        } else if(LockInf((PLOADED_INF)InfHandle)) {
            pInf = (PLOADED_INF)InfHandle;
        } else {
           Status = ERROR_INVALID_HANDLE;
           leave;
        }


        InterfaceNameLen = MAX_INF_STRING_LENGTH;
        InterfaceName = MyMalloc(InterfaceNameLen * sizeof(TCHAR));
        //
        // If the memory wasn't allocated, then return an error
        //
        if(!InterfaceName) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        //
        // we look for keyword "WmiInterface" in the CompSectionName section
        //
        if(SetupFindFirstLine(InfHandle,
                              SectionName,
                              NULL,
                              &InfLineContext)) {

            do {
                count++;


                Status = GLE_FN_CALL(FALSE,
                                     SetupGetStringField(&InfLineContext,
                                                         0,
                                                         (PTSTR)InterfaceName,
                                                         InterfaceNameLen,
                                                         NULL));

                if((Status == NO_ERROR) && !(lstrcmpi(WMIINTERFACE_KEY, InterfaceName))) {

                    //
                    // WMIInterface = GUID, flags, SectionName
                    // The GUID should be at index 1, flags at index 2, and section
                    // name at index 3
                    //
                    Status = ParseSection(InfLineContext,
                                          &GuidString,
                                          &GuidStringLen,
                                          &Flags,
                                          &SectionNameString,
                                          &SectionNameStringLen
                                         );

                    if(Status != NO_ERROR) {
                        WriteLogEntry(pInf->LogContext, 
                                      SETUP_LOG_ERROR | SETUP_LOG_BUFFER, 
                                      MSG_FAILED_PARSESECTION,
                                      NULL,
                                      count,
                                      SectionName,
                                      pInf->VersionBlock.Filename
                                     );
                        WriteLogError(pInf->LogContext,
                                      SETUP_LOG_ERROR,
                                      Status
                                     );
                        leave;
                    }

                    //
                    // Get SDDL string from the section specified by the interface
                    //
                    Status = GetSecurityKeyword(InfHandle,
                                                SectionNameString,
                                                &SDDLString,
                                                &SDDLStringLen
                                               );
                    if(Status != NO_ERROR) {
                        WriteLogEntry(pInf->LogContext, 
                                      SETUP_LOG_ERROR | SETUP_LOG_BUFFER, 
                                      MSG_FAILED_GET_SECURITY,
                                      NULL,
                                      SectionName,
                                      pInf->VersionBlock.Filename
                                      );
                        WriteLogError(pInf->LogContext,
                                      SETUP_LOG_ERROR,
                                      Status
                                      );
                        break;
                    }

                    Status = EstablishGuidSecurity(GuidString, SDDLString, Flags);

                    if(Status != NO_ERROR) {
                        WriteLogEntry(pInf->LogContext, 
                                      SETUP_LOG_ERROR | SETUP_LOG_BUFFER, 
                                      MSG_FAILED_SET_SECURITY,
                                      NULL,
                                      SectionName,
                                      pInf->VersionBlock.Filename
                                      );
                        WriteLogError(pInf->LogContext,
                                      SETUP_LOG_ERROR,
                                      Status
                                      );
                        break;
                    }
                }
            } while(SetupFindNextLine(&InfLineContext, &InfLineContext));
        }


    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Status);
    }
     
    //
    // Clean up temporary allocated resources
    //
    
    if(GuidString){
        MyFree(GuidString);         
    }

    if(SectionNameString){
        MyFree(SectionNameString);
    }

    if(SDDLString) { 
        MyFree(SDDLString);
    }

    if(InterfaceName) {
        MyFree(InterfaceName);
    }

    if(pInf) {
        UnlockInf((PLOADED_INF)InfHandle);
    }

    SetLastError(Status);
    return(Status == NO_ERROR);
}



ULONG 
ParseSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR   SD,
    OUT PSECURITY_INFORMATION  SecurityInformation,
    OUT PSID                  *Owner,
    OUT PSID                  *Group,
    OUT PACL                  *Dacl,
    OUT PACL                  *Sacl
    )
/*++

    Routine Description:    
    
        Checks information provided in the security descriptor to make sure that 
        at least the dacl, sacl, owner or group security was specified.  Otherwise
        it will return an error.        
                 
    
    Arguments:
        
        SD                  [in]   - security descriptor data structure 
                                     already allocated and where security info is 
        SecurityInformation [out]  - indicates which security information is present
        Owner               [out]  - variable that receives a pointer to the owner 
                                     SID in the security descriptor 
        Group               [out]  - variable that receives a pointer to the group 
                                     SID in the security descriptor
        Dacl                [out]  - variable that receives a pointer to the DACL 
                                     in the returned security descriptor
        Sacl                [out]  - variable that receives a pointer to the SACL 
                                     in the returned security descriptor

    Returns:    
    
        NO_ERROR or an error code.
        
--*/ 
{
    BOOL Ok, Present, Defaulted;

    *SecurityInformation = 0;

    *Dacl = NULL;
    *Sacl = NULL;
    *Owner = NULL;
    *Group = NULL;

    Ok = GetSecurityDescriptorOwner(SD,
                                    Owner,
                                    &Defaulted
                                    );
    if(Ok && (Owner != NULL)) {
        *SecurityInformation |= OWNER_SECURITY_INFORMATION;
    }

    Ok = GetSecurityDescriptorGroup(SD,
                                    Group,
                                    &Defaulted
                                    );
    if(Ok && (Group != NULL)) {
        *SecurityInformation |= GROUP_SECURITY_INFORMATION;
    }

    Ok = GetSecurityDescriptorDacl(SD,
                                   &Present,
                                   Dacl,
                                   &Defaulted
                                   );

    if(Ok && Present) {
        *SecurityInformation |= DACL_SECURITY_INFORMATION;
    }


    Ok = GetSecurityDescriptorSacl(SD,
                                   &Present,
                                   Sacl,
                                   &Defaulted
                                   );

    if(Ok && Present) {
        *SecurityInformation |= SACL_SECURITY_INFORMATION;
    }


    //
    // If no security info in the security descriptor then it is an
    // error
    //
    return((*SecurityInformation == 0) ?
           ERROR_INVALID_PARAMETER :
           NO_ERROR);
}


ULONG 
EstablishGuidSecurity(
    IN PTCHAR GuidString,
    IN PTCHAR SDDLString,
    IN DWORD  Flags
    )
/*++


    Routine Description:    
        
        Writes security information to registry key (specified by WMIGUIDSECURITYKEY in
        regstr.w).  Makes sure that the DACL is not null. Function will only write 
        security information if it is not specified or the SCWMI_OVERWRITE_SECURITY flag is set.
                 
    
    Arguments:
        
        GuidString  [in]    - GUID String taken from the INF file for the WMI interface
        SDDLString  [in]    - The security description string for the corresponding GUID (also
                              taken from the INF) that indicates what to set the security to.
        Flags       [in]    - SCWMI_CLOBBER_SECURITY flag only
        
    Returns:    
        
        Status, normally NO_ERROR
        
--*/ 
{
    HKEY Key;
    PACL Dacl, Sacl;
    PSID Owner, Group;
    SECURITY_INFORMATION SecurityInformation;
    PSECURITY_DESCRIPTOR SD;
    ULONG Status;
    ULONG SizeNeeded;
    BOOL Present, Ok;

    Key = INVALID_HANDLE_VALUE;
    SD = NULL;


    try {
    
        //
        // First check if security has already been set for this guid. If
        // so then we don't want to overwrite it.
        //
        Status = RegOpenKey(HKEY_LOCAL_MACHINE,
                            REGSTR_PATH_WMI_SECURITY,
                            &Key
                            );
        if(Status != ERROR_SUCCESS) {      
            //
            // Ensure key remains INVALID_HANDLE_VALUE so we don't try to free 
            // it later
            //
            Key = INVALID_HANDLE_VALUE;
            leave;
        } 

        if(!((Flags &  SCWMI_CLOBBER_SECURITY) ||
           (ERROR_SUCCESS != RegQueryValueEx(Key,
                                             GuidString,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &SizeNeeded)))) {
            //
            // We weren't told to clobber security and security exists so 
            // there is nothing to do.
            //
            leave;
        }


        //
        // No security already setup so, lets go ahead and set it up
        // Lets create a SD from the SDDL string
        //
        Status = GLE_FN_CALL(FALSE, 
                             ConvertStringSecurityDescriptorToSecurityDescriptor(
                                  SDDLString,
                                  SDDL_REVISION_1,
                                  &SD,
                                  NULL)
                             );
                                                                

        if(Status != NO_ERROR) {
            //
            // Ensure SD remains NULL so it isn't freed later.
            //
            SD = NULL;
            leave;
        }
        //
        // Break up the SD into its components
        //
        Status = ParseSecurityDescriptor(SD,
                                         &SecurityInformation,
                                         &Owner,
                                         &Group,
                                         &Dacl,
                                         &Sacl
                                         );
        if(Status == NO_ERROR) {
            //
            // Don't allow any SD to be setup with a NULL DACL
            // as this results in full access for anyone
            //
            if(Dacl != NULL) {
                //
                // For wmiguids, the owner, group and sacl don't mean
                // much so we just set the DACL.
                //
                SecurityInformation = DACL_SECURITY_INFORMATION;
                Owner = NULL;
                Group = NULL;
                Sacl = NULL;

                Status = SetNamedSecurityInfo(GuidString,
                                              SE_WMIGUID_OBJECT,
                                              SecurityInformation,
                                              Owner,
                                              Group,
                                              Dacl,
                                              Sacl
                                              );
            } else {
                Status = ERROR_INVALID_PARAMETER;
                leave;
            }
        }
    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Status);
    }


    if(SD) {
        //
        //  Explicity must use LocalFree for Security Descriptors returned by
        //  ConvertStringSecurityDescriptorToSecurityDescriptor
        //
        LocalFree(SD);
    }
    if(Key == INVALID_HANDLE_VALUE) {
        RegCloseKey(Key);
    }
    return Status;
}

ULONG 
ParseSection(
            IN     INFCONTEXT  InfLineContext,
            IN OUT PTCHAR     *GuidString, 
            IN OUT ULONG      *GuidStringLen,
            IN OUT PDWORD      Flags,
            IN OUT PTCHAR     *SectionNameString,
            IN OUT ULONG      *SectionNameStringLen
            ) 
/*++


    Routinte Description:    
        
        This section parses the GUID, flags, and SectionName, respectively.  
        There should only be 3 fields in the WMIInterface section, otherwise an
        error will be returned.                  
    
    Arguments:
        
        InfLineContext          [in]       - The line from the INF we are parsing
        GuidString              [in, out]  - Passed as NULL by the caller, then memory is allocated
                                             and filled with the corresponding GUID string.
        GuidStringLen           [in, out]  - Passed as zero by the caller, and then set to the 
                                             maximum length for the GUID.
        Flags                   [in, out]  - SCWMI_CLOBBER_SECURITY flag only
        SectionNameString       [in, out]  - assed as NULL by the caller, then memory is allocated
                                             and filled with the corresponding section name.
        SectionNameStringLen    [in, out]  - assed as zero by the caller, and then set to the 
                                             maximum length for the section name
                  
    Returns:    
        
        Status, normally NO_ERROR

--*/ 
{
    PTCHAR TempGuidString = NULL;
    ULONG FieldCount;
    ULONG Status;
    INT infFlags;
    int i;
    size_t Length;

    Status = NO_ERROR;

    try {
    
        //
        // Make sure there are 3 fields specified in the section 
        //
        FieldCount = SetupGetFieldCount(&InfLineContext);
        if(FieldCount < 3) {
            Status = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // Get the guid string
        //
        *GuidStringLen = MAX_GUID_STRING_LEN;
        *GuidString = MyMalloc((*GuidStringLen) * sizeof(TCHAR));
        
        //
        // If the memory wasn't allocated, then return an error
        //
        if(!(*GuidString)) {
           Status = ERROR_NOT_ENOUGH_MEMORY;
           leave;
        }
        
        Status = GLE_FN_CALL(FALSE,
                            SetupGetStringField(&InfLineContext,
                                                1,
                                                (PTSTR)(*GuidString),
                                                *GuidStringLen,
                                                NULL)
                           );
        
        if(Status != NO_ERROR) {
            leave;
        }
        
        
        //
        // If the GUID string has curly braces take them off
        //
        
        //
        // String has curly braces as first and last character
        // Checks to make sure it has the same length as a GUID, otherwise, this function
        // relies on the WMI security API to handle and invalid GUID.
        //
        if(((*GuidString)[0] == TEXT('{')) &&
           SUCCEEDED(StringCchLength(*GuidString,MAX_GUID_STRING_LEN,&Length)) &&
            (Length == (MAX_GUID_STRING_LEN-1)) &&
          ((*GuidString)[MAX_GUID_STRING_LEN-2] == TEXT('}'))) {
        
            TempGuidString = MyMalloc((MAX_GUID_STRING_LEN-2) * sizeof(TCHAR));
            if(TempGuidString == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }
        
            //
            // Copy the GuidString, except the first and last character (the braces)
            //
            if(FAILED(StringCchCopyN(TempGuidString, 
                                    MAX_GUID_STRING_LEN-2,
                                    &(*GuidString)[1],
                                    MAX_GUID_STRING_LEN-3))) {
                Status = ERROR_INVALID_PARAMETER;
                MyFree(TempGuidString);
                TempGuidString = NULL;
                leave;
            }
        
            MyFree(*GuidString);
        
            //
            // Set GuidString equal to our new one without braces
            //
            *GuidString = TempGuidString;
            TempGuidString = NULL;
        
        }
        
        //
        // Now get the flags string
        //
        
        Status = GLE_FN_CALL(FALSE,
                            SetupGetIntField(&InfLineContext,
                                             2,
                                             &infFlags)
                           );
        
        if(Status != NO_ERROR) {
            leave;
        }
           
        //
        // if the flags in the INF were not set then use the flags indicated in the INF,
        // otherwise default to use the ones passed in by the calling function.
        //
        if(!(*Flags)) {
            *Flags = infFlags; 
        }
        
        *SectionNameStringLen = MAX_INF_STRING_LENGTH;
        *SectionNameString    = MyMalloc(*SectionNameStringLen * sizeof(TCHAR));
        
        //
        // If the memory wasn't allocated, then return an error
        //
        if(!(*SectionNameString)) {
           Status = ERROR_NOT_ENOUGH_MEMORY;
           leave;
        }
        
        Status = GLE_FN_CALL(FALSE,
                            SetupGetStringField(&InfLineContext,
                                                3,
                                                (PTSTR)(*SectionNameString),
                                                (*SectionNameStringLen),
                                                NULL)
                           );
        
       

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Status);
    }

    //
    // If the function exits abnormally then clean up any strings allocated.
    //
    if(Status != NO_ERROR) {
        if(*GuidString){
             MyFree(*GuidString);         
             *GuidString = NULL;
         }
        if(TempGuidString) {
            MyFree(TempGuidString);
   
        }
        if(*SectionNameString){
             MyFree(*SectionNameString);
             *SectionNameString = NULL;
        }
    }
   
    return Status;
}


ULONG
GetSecurityKeyword(
    IN     HINF     InfFile,
    IN     LPCTSTR  WMIInterfaceSection,
    IN OUT PTCHAR  *SDDLString, 
    IN OUT ULONG   *SDDLStringLen
    )
/*++
        
    Routine Description:    
        
        The section name specified under the WMIInterface should contain a 
        security section the specifies the SDDL.  It should be in the form
        security = <SDDL>.  This fcuntion extracts the SDDL.  There should
        only be one security section, otherwise an error will be returned.                 
    
    Arguments:
        
        InfLineContext          [in]      - the line from the INF file
        WMIInterfaceSection     [in]      - the section name indicating what
                                            section contains the security info
        SDDLString              [in, out] - passed in as NULL by the caller, is
                                            allocated and filled in with the 
                                            corresponding security description
                                            string.
        SDDLStringLen           [in, out] - passed in as 0 by the caller and set
                                            to the maximum length of an INF field.
                  
    Returns:    
        
        Status, normally NO_ERROR

--*/ 
{
    INFCONTEXT InfLineContext;
    DWORD Status;
    ULONG FieldCount;

    Status = NO_ERROR;

    try {

        if(SetupFindFirstLine(InfFile,
                              WMIInterfaceSection,
                              WMIGUIDSECURITYSECTION_KEY,
                              &InfLineContext)) {

            //
            // WmiGuidSecurity = <SDDL>
            // sddl will be at index 1
            //  
            FieldCount = SetupGetFieldCount(&InfLineContext);
            if(FieldCount < 1) {
                Status = ERROR_INVALID_PARAMETER;
                leave;
            }
            //
            // Get the SDDL string
            //
            *SDDLStringLen =  MAX_INF_STRING_LENGTH;
            *SDDLString = MyMalloc(*SDDLStringLen * sizeof(TCHAR));

            //
            // If the memory wasn't allocated, then return an error
            //
            if(!(*SDDLString)) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }

            Status = GLE_FN_CALL(FALSE,
                                 SetupGetStringField(&InfLineContext,
                                                     1,
                                                     (PTSTR)(*SDDLString),
                                                     (*SDDLStringLen),
                                                     NULL)
                                );

            if(Status == NO_ERROR) {

                //
                // There should not be more than one security entry
                //

                if(SetupFindNextMatchLine(&InfLineContext,
                                          WMIGUIDSECURITYSECTION_KEY,
                                          &InfLineContext)) {
                    Status = ERROR_INVALID_PARAMETER;
                    leave;
                }
            }

         
        }

    }except(pSetupExceptionFilter(GetExceptionCode())){
            pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Status);
    }

    //
    // If the function exits abnormally then clean up any strings allocated.
    //
    if(Status != NO_ERROR) {
        if(*SDDLString) {
                MyFree(*SDDLString);         
                *SDDLString = NULL;
            }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\filelog.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    filelog.c

Abstract:

    Routines for logging files in copy logs.

Author:

    Ted Miller (tedm) 14-Jun-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Define name of system log file and various strings used
// within it.
//
PCTSTR SystemLogFileName = TEXT("repair\\setup.log");
PCTSTR NtFileSectionName = TEXT("Files.WinNT");

//
// Define structure used internally to represent a file log file.
//
typedef struct _SETUP_FILE_LOG {
    PCTSTR FileName;
    BOOL QueryOnly;
    BOOL SystemLog;
} SETUP_FILE_LOG, *PSETUP_FILE_LOG;


#ifdef UNICODE
//
// ANSI version
//
HSPFILELOG
SetupInitializeFileLogA(
    IN PCSTR LogFileName,   OPTIONAL
    IN DWORD Flags
    )
{
    PWSTR p;
    DWORD d;
    HSPFILELOG h;

    if(LogFileName) {
        d = pSetupCaptureAndConvertAnsiArg(LogFileName,&p);
        if(d != NO_ERROR) {
            SetLastError(d);
            return(INVALID_HANDLE_VALUE);
        }
    } else {
        p = NULL;
    }

    h = SetupInitializeFileLogW(p,Flags);
    d = GetLastError();

    if(p) {
        MyFree(p);
    }

    SetLastError(d);
    return(h);
}
#else
//
// Unicode stub
//
HSPFILELOG
SetupInitializeFileLogW(
    IN PCWSTR LogFileName,  OPTIONAL
    IN DWORD  Flags
    )
{
    UNREFERENCED_PARAMETER(LogFileName);
    UNREFERENCED_PARAMETER(Flags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(INVALID_HANDLE_VALUE);
}
#endif

HSPFILELOG
SetupInitializeFileLog(
    IN PCTSTR LogFileName,  OPTIONAL
    IN DWORD  Flags
    )

/*++

Routine Description:

    Initialize a file for logging or query. The caller may specify that he
    wishes to use the system log, which is where the system tracks which
    files are installed as part of Windows NT; or the caller may specify
    any other random file to be used as a log.

    If the user specifies the system log not for query only, the function fails
    unless the user is administrator. However this only guarantees security
    on the log when the system is installed on a drive with a filesystem that
    supports ACLs; the log is simply a file and anyone can access it unless
    setup can secure it via ACLs.

Arguments:

    LogFileName - if specified, supplies the filename of the file to be used
        as the log file. Must be specified if Flags does not include
        SPFILELOG_SYSTEMLOG. Must not be specified if Flags includes
        SPFILELOG_SYSTEMLOG.

    Flags - supplies a combination of the following values:

        SPFILELOG_SYSTEMLOG - use the Windows NT system file log, which is used
            to track what files are installed as part of Windows NT. The user must
            be administrator to specify this option unless SPFILELOG_QUERYONLY
            is specified, and LogFileName must not be specified. May not be specified
            in combination with SPFILELOG_FORCENEW.

        SPFILELOG_FORCENEW - if the log file exists, it will be overwritten.
            If the log file exists and this flag is not specified then additional
            files are added to the existing log. May not be specified in combination
            with SPFILELOG_SYSTEMLOG.

        SPFILELOG_QUERYONLY - open the log file for querying only. The user

Return Value:

    Handle to file log or INVALID_HANDLE_VALUE if the function fails;
    extended error info is available via GetLastError() in this case.

--*/

{
    TCHAR SysLogFileName[MAX_PATH];
    PCTSTR FileName;
    PSETUP_FILE_LOG FileLog;
    DWORD Err;
    HANDLE hFile;

    //
    // Validate args.
    //
    Err = ERROR_INVALID_PARAMETER;
    if(Flags & SPFILELOG_SYSTEMLOG) {
        if((Flags & SPFILELOG_FORCENEW) || LogFileName) {
            goto clean0;
        }
        //
        // User must be administrator to gain write access to system log.
        //
        if(!(Flags & SPFILELOG_QUERYONLY) && !pSetupIsUserAdmin()) {
            Err = ERROR_ACCESS_DENIED;
            goto clean0;
        }

        //
        // uses actual windows directory instead of hydra remapped
        //
        lstrcpyn(SysLogFileName,WindowsDirectory,MAX_PATH);
        pSetupConcatenatePaths(SysLogFileName,SystemLogFileName,MAX_PATH,NULL);
        FileName = SysLogFileName;
    } else {
        if(LogFileName) {
            if(!lstrcpyn(SysLogFileName,LogFileName,MAX_PATH)) {
                //
                // lstrcpyn faulted, LogFileName must be bad
                //
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            FileName = SysLogFileName;
        } else {
            goto clean0;
        }
    }

    //
    // Allocate a log file structure.
    //
    Err = ERROR_NOT_ENOUGH_MEMORY;
    if(FileLog = MyMalloc(sizeof(SETUP_FILE_LOG))) {
        FileLog->FileName = DuplicateString(FileName);
        if(!FileLog->FileName) {
            goto clean1;
        }
    } else {
        goto clean0;
    }

    FileLog->QueryOnly = ((Flags & SPFILELOG_QUERYONLY) != 0);
    FileLog->SystemLog = ((Flags & SPFILELOG_SYSTEMLOG) != 0);

    //
    // See if the file exists.
    //
    if(FileExists(FileName,NULL)) {

        //
        // If it's the system log, take ownership of the file.
        //
        if(FileLog->SystemLog) {
            Err = TakeOwnershipOfFile(FileName);
            if(Err != NO_ERROR) {
                goto clean2;
            }
        }

        //
        // Set attribute to normal. This ensures we can delete/open/create the file
        // as appropriate below.
        //
        if(!SetFileAttributes(FileName,FILE_ATTRIBUTE_NORMAL)) {
            Err = GetLastError();
            goto clean2;
        }

        //
        // Delete the file now if the caller specified the force_new flag.
        //
        if((Flags & SPFILELOG_FORCENEW) && !DeleteFile(FileName)) {
            Err = GetLastError();
            goto clean2;
        }
    }

    //
    // Make sure we can open/create the file by attempting to do that now.
    //
    hFile = CreateFile(
                FileName,
                GENERIC_READ | (FileLog->QueryOnly ? 0 : GENERIC_WRITE),
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_ALWAYS,            // Open if exists, create if not
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if(hFile == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        goto clean2;
    }

    CloseHandle(hFile);
    return((HSPFILELOG)FileLog);

clean2:
    MyFree(FileLog->FileName);
clean1:
    MyFree(FileLog);
clean0:
    SetLastError(Err);
    return(INVALID_HANDLE_VALUE);
}


BOOL
SetupTerminateFileLog(
    IN HSPFILELOG FileLogHandle
    )

/*++

Routine Description:

    Releases resources associated with a file log.

Arguments:

    FileLogHandle - supplies the handle to the file log, as returned
        by SetupInitializeLogFile.

Return Value:

    Boolean value indicating outcome. If FALSE, the caller can use
    GetLastError() to get extended error info.

--*/

{
    PSETUP_FILE_LOG FileLog;
    DWORD Err;

    FileLog = (PSETUP_FILE_LOG)FileLogHandle;
    Err = NO_ERROR;

    try {
        MyFree(FileLog->FileName);
        MyFree(FileLog);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupLogFileA(
    IN HSPFILELOG FileLogHandle,
    IN PCSTR      LogSectionName,   OPTIONAL
    IN PCSTR      SourceFilename,
    IN PCSTR      TargetFilename,
    IN DWORD      Checksum,         OPTIONAL
    IN PCSTR      DiskTagfile,      OPTIONAL
    IN PCSTR      DiskDescription,  OPTIONAL
    IN PCSTR      OtherInfo,        OPTIONAL
    IN DWORD      Flags
    )
{
    PWSTR logsectionname = NULL;
    PWSTR sourcefilename = NULL;
    PWSTR targetfilename = NULL;
    PWSTR disktagfile = NULL;
    PWSTR diskdescription = NULL;
    PWSTR otherinfo = NULL;
    DWORD d;
    BOOL b;

    if(LogSectionName) {
        d = pSetupCaptureAndConvertAnsiArg(LogSectionName,&logsectionname);
    } else {
        d = NO_ERROR;
    }
    if(d == NO_ERROR) {
        d = pSetupCaptureAndConvertAnsiArg(SourceFilename,&sourcefilename);
    }
    if(d == NO_ERROR) {
        d = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetfilename);
    }
    if((d == NO_ERROR) && DiskTagfile) {
        d = pSetupCaptureAndConvertAnsiArg(DiskTagfile,&disktagfile);
    }
    if((d == NO_ERROR) && DiskDescription) {
        d = pSetupCaptureAndConvertAnsiArg(DiskDescription,&diskdescription);
    }
    if((d == NO_ERROR) && OtherInfo) {
        d = pSetupCaptureAndConvertAnsiArg(OtherInfo,&otherinfo);
    }

    if(d == NO_ERROR) {

        b = SetupLogFileW(
                FileLogHandle,
                logsectionname,
                sourcefilename,
                targetfilename,
                Checksum,
                disktagfile,
                diskdescription,
                otherinfo,
                Flags
                );

        d = GetLastError();

    } else {
        b = FALSE;
    }

    if(logsectionname) {
        MyFree(logsectionname);
    }
    if(sourcefilename) {
        MyFree(sourcefilename);
    }
    if(targetfilename) {
        MyFree(targetfilename);
    }
    if(disktagfile) {
        MyFree(disktagfile);
    }
    if(diskdescription) {
        MyFree(diskdescription);
    }
    if(otherinfo) {
        MyFree(otherinfo);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupLogFileW(
    IN HSPFILELOG FileLogHandle,
    IN PCWSTR     LogSectionName,   OPTIONAL
    IN PCWSTR     SourceFilename,
    IN PCWSTR     TargetFilename,
    IN DWORD      Checksum,         OPTIONAL
    IN PCWSTR     DiskTagfile,      OPTIONAL
    IN PCWSTR     DiskDescription,  OPTIONAL
    IN PCWSTR     OtherInfo,        OPTIONAL
    IN DWORD      Flags
    )
{
    UNREFERENCED_PARAMETER(FileLogHandle);
    UNREFERENCED_PARAMETER(LogSectionName);
    UNREFERENCED_PARAMETER(SourceFilename);
    UNREFERENCED_PARAMETER(TargetFilename);
    UNREFERENCED_PARAMETER(Checksum);
    UNREFERENCED_PARAMETER(DiskTagfile);
    UNREFERENCED_PARAMETER(DiskDescription);
    UNREFERENCED_PARAMETER(OtherInfo);
    UNREFERENCED_PARAMETER(Flags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupLogFile(
    IN HSPFILELOG FileLogHandle,
    IN PCTSTR     LogSectionName,   OPTIONAL
    IN PCTSTR     SourceFilename,
    IN PCTSTR     TargetFilename,
    IN DWORD      Checksum,         OPTIONAL
    IN PCTSTR     DiskTagfile,      OPTIONAL
    IN PCTSTR     DiskDescription,  OPTIONAL
    IN PCTSTR     OtherInfo,        OPTIONAL
    IN DWORD      Flags
    )

/*++

Routine Description:

    Logs a file into a file log.

Arguments:

    FileLogHandle - supplies the handle to the file log, as returned
        by SetupInitializeLogFile(). The caller must not have passed
        SPFILELOG_QUERYONLY when the log file was opened/initialized.

    LogSectionName - required if SPFILELOG_SYSTEMLOG was not passed when
        the file log was opened/initialized; optional otherwise.
        Supplies the name for a logical grouping of files within the log.

    SourceFilename - supplies the name of the file as it exists on the
        source media from which it was installed. This name should be in
        whatever format is meaningful to the caller.

    TargetFilename - supplies the name of the file as it exists on the
        Target. This name should be in whatever format is meaningful to
        the caller.

    Checksum - supplies a 32-bit checksum value. Required for the system log.

    DiskTagfile - Gives the tagfile for the media from which the file
        was installed. Required for the system log if SPFILELOG_OEMFILE
        is specified. Ignored for the system log if SPFILELOG_OEMFILE is
        not specified.

    DiskDescription - Gives the human-readable description for the media
        from which the file was installed. Required for the system log if
        SPFILELOG_OEMFILE is specified. Ignored for the system log if
        SPFILELOG_OEMFILE is not specified.

    OtherInfo - supplies additional information to be associated with the
        file.

    Flags - may supply SPFILELOG_OEMFILE, which is meaningful only for
        the system log and indicates that the file is not an MS-supplied file.
        Can be used to convert an existing file's entry such as when an oem
        overwrites an MS-supplied system file.

Return Value:

    Boolean value indicating outcome. If FALSE, the caller can use
    GetLastError() to get extended error info.

--*/

{
    PSETUP_FILE_LOG FileLog;
    DWORD Err;
    BOOL b;
    TCHAR LineToWrite[512];
    TCHAR sourceFilename[MAX_PATH];
    PTSTR p,Directory;

    FileLog = (PSETUP_FILE_LOG)FileLogHandle;

    try {
        //
        // Validate params. Handle must be for non-queryonly.
        // If for the system log and oem file is specified,
        // caller must have passed disk tagfile and description.
        // There's really no way to validate the checksum because
        // 0 is a perfectly valid one.
        // If not the system log, caller must have passed a section name.
        //
        if(FileLog->QueryOnly
        || (  FileLog->SystemLog
            && (Flags & SPFILELOG_OEMFILE)
            && (!DiskTagfile || !DiskDescription))
        || (!FileLog->SystemLog && !LogSectionName))
        {
            Err = ERROR_INVALID_PARAMETER;

        } else {
            //
            // Use default section if not specified.
            //
            if(!LogSectionName) {
                MYASSERT(FileLog->SystemLog);
                LogSectionName = NtFileSectionName;
            }

            //
            // IF THIS LOGIC IS CHANGED BE SURE TO CHANGE
            // SetupQueryFileLog() AS WELL!
            //
            // Split up the source filename into filename and
            // directory if appropriate.
            //
            lstrcpyn(sourceFilename,SourceFilename,MAX_PATH);
            if(FileLog->SystemLog && (Flags & SPFILELOG_OEMFILE)) {
                if(p = _tcsrchr(sourceFilename,TEXT('\\'))) {
                    *p++ = 0;
                    Directory = p;
                } else {
                    Directory = TEXT("\\");
                }
            } else {
                Directory = TEXT("");
            }

            wnsprintf(
                LineToWrite,
                sizeof(LineToWrite)/sizeof(LineToWrite[0]),
                TEXT("%s,%x,%s,%s,\"%s\""),
                sourceFilename,
                Checksum,
                Directory,
                DiskTagfile ? DiskTagfile : TEXT(""),
                DiskDescription ? DiskDescription : TEXT("")
                );


            b = WritePrivateProfileString(
                    LogSectionName,
                    TargetFilename,
                    LineToWrite,
                    FileLog->FileName
                    );

            Err = b ? NO_ERROR : GetLastError();
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupRemoveFileLogEntryA(
    IN HSPFILELOG FileLogHandle,
    IN PCSTR      LogSectionName,   OPTIONAL
    IN PCSTR      TargetFilename    OPTIONAL
    )
{
    PWSTR logsectionname,targetfilename;
    DWORD d;
    BOOL b;

    if(LogSectionName) {
        d = pSetupCaptureAndConvertAnsiArg(LogSectionName,&logsectionname);
        if(d != NO_ERROR) {
            SetLastError(d);
            return(FALSE);
        }
    } else {
        logsectionname = NULL;
    }
    if(TargetFilename) {
        d = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetfilename);
        if(d != NO_ERROR) {
            if(logsectionname) {
                MyFree(logsectionname);
            }
            SetLastError(d);
            return(FALSE);
        }
    } else {
        targetfilename = NULL;
    }

    b = SetupRemoveFileLogEntryW(FileLogHandle,logsectionname,targetfilename);
    d = GetLastError();

    if(logsectionname) {
        MyFree(logsectionname);
    }
    if(targetfilename) {
        MyFree(targetfilename);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupRemoveFileLogEntryW(
    IN HSPFILELOG FileLogHandle,
    IN PCWSTR     LogSectionName,   OPTIONAL
    IN PCWSTR     TargetFilename    OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(FileLogHandle);
    UNREFERENCED_PARAMETER(LogSectionName);
    UNREFERENCED_PARAMETER(TargetFilename);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupRemoveFileLogEntry(
    IN HSPFILELOG FileLogHandle,
    IN PCTSTR     LogSectionName,   OPTIONAL
    IN PCTSTR     TargetFilename    OPTIONAL
    )

/*++

Routine Description:

    Removes an entry or section from a file log.

Arguments:

    FileLogHandle - supplies the handle to the file log, as returned
        by SetupInitializeLogFile(). The caller must not have passed
        SPFILELOG_QUERYONLY when the log file was opened/initialized.

    LogSectionName - Supplies the name for a logical grouping of files
        within the log. Required for non-system logs; optional for the
        system log.

    TargetFilename - supplies the name of the file as it exists on the
        Target. This name should be in whatever format is meaningful to
        the caller. If not specified, the entire section specified by
        LogSectionName is removed. Removing the main section for NT files
        is not allowed.

Return Value:

    Boolean value indicating outcome. If FALSE, the caller can use
    GetLastError() to get extended error info.

--*/

{
    DWORD Err;
    PSETUP_FILE_LOG FileLog;
    BOOL b;

    FileLog = (PSETUP_FILE_LOG)FileLogHandle;

    try {

        Err = NO_ERROR;
        if(FileLog->QueryOnly) {
            Err = ERROR_INVALID_PARAMETER;
        } else {
            if(!LogSectionName) {
                if(FileLog->SystemLog) {
                    LogSectionName = NtFileSectionName;
                } else {
                    Err = ERROR_INVALID_PARAMETER;
                }
            }
            //
            // Diallow removing the main nt files section.
            //
            if((Err == NO_ERROR)
            && FileLog->SystemLog
            && !TargetFilename
            && !lstrcmpi(LogSectionName,NtFileSectionName))
            {
                Err = ERROR_INVALID_PARAMETER;
            }
        }

        if(Err == NO_ERROR) {
            b = WritePrivateProfileString(LogSectionName,TargetFilename,NULL,FileLog->FileName);
            Err = b ? NO_ERROR : GetLastError();
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueryFileLogA(
    IN  HSPFILELOG       FileLogHandle,
    IN  PCSTR            LogSectionName,   OPTIONAL
    IN  PCSTR            TargetFilename,
    IN  SetupFileLogInfo DesiredInfo,
    OUT PSTR             DataOut,          OPTIONAL
    IN  DWORD            ReturnBufferSize,
    OUT PDWORD           RequiredSize      OPTIONAL
    )
{
    PWSTR logsectionname;
    PWSTR targetfilename;
    PWSTR unicodeBuffer = NULL;
    DWORD unicodeSize = 2048;
    PSTR ansidata;
    DWORD requiredsize;
    DWORD d;
    BOOL b;

    d = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetfilename);
    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }
    if(LogSectionName) {
        d = pSetupCaptureAndConvertAnsiArg(LogSectionName,&logsectionname);
        if(d != NO_ERROR) {
            MyFree(targetfilename);
            SetLastError(d);
            return(FALSE);
        }
    } else {
        logsectionname = NULL;
    }
    unicodeBuffer = MyMalloc(unicodeSize*sizeof(WCHAR));
    if(!unicodeBuffer) {
        if(targetfilename) {
            MyFree(targetfilename);
        }
        if(logsectionname) {
            MyFree(logsectionname);
        }
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    b = SetupQueryFileLogW(
            FileLogHandle,
            logsectionname,
            targetfilename,
            DesiredInfo,
            unicodeBuffer,
            unicodeSize,
            &requiredsize
            );

    d = GetLastError();

    if(b) {
        d = NO_ERROR;

        if(ansidata = pSetupUnicodeToAnsi(unicodeBuffer)) {

            requiredsize = lstrlenA(ansidata)+1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    b = FALSE;
                    d = ERROR_INVALID_PARAMETER;
                }
            }

            if(b && DataOut) {
                if(ReturnBufferSize >= requiredsize) {
                    if(!lstrcpyA(DataOut,ansidata)) {
                        //
                        // lstrcpy faulted, ReturnBuffer must be invalid
                        //
                        d = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }
                } else {
                    d = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                }
            }

            MyFree(ansidata);
        } else {
            b = FALSE;
            d = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    MyFree(targetfilename);
    if(logsectionname) {
        MyFree(logsectionname);
    }
    if(unicodeBuffer) {
        MyFree(unicodeBuffer);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueryFileLogW(
    IN  HSPFILELOG       FileLogHandle,
    IN  PCWSTR           LogSectionName,   OPTIONAL
    IN  PCWSTR           TargetFilename,
    IN  SetupFileLogInfo DesiredInfo,
    OUT PWSTR            DataOut,          OPTIONAL
    IN  DWORD            ReturnBufferSize,
    OUT PDWORD           RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(FileLogHandle);
    UNREFERENCED_PARAMETER(LogSectionName);
    UNREFERENCED_PARAMETER(TargetFilename);
    UNREFERENCED_PARAMETER(DesiredInfo);
    UNREFERENCED_PARAMETER(DataOut);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueryFileLog(
    IN  HSPFILELOG       FileLogHandle,
    IN  PCTSTR           LogSectionName,   OPTIONAL
    IN  PCTSTR           TargetFilename,
    IN  SetupFileLogInfo DesiredInfo,
    OUT PTSTR            DataOut,          OPTIONAL
    IN  DWORD            ReturnBufferSize,
    OUT PDWORD           RequiredSize      OPTIONAL
    )

/*++

Routine Description:

     Returns information from a setup file log.

Arguments:

    FileLogHandle - supplies handle to open file log, as returned by
        SetupInitializeFileLog().

    LogSectionName - required for non-system logs; if not specified
        for the system log a default is supplied. Supplies the name
        for a logical grouping within the log that is meaningful
        to the caller.

    TargetFilename - supplies name of file for which log information
        is desired.

    DesiredInfo - supplies an ordinal indicating what information
        is desired about the file.

    DataOut - If specified, points to a buffer that receives the
        requested information for the file. Note that not all info
        is provided for every file; an error is not returned if an entry
        for the file exists in the log but is empty.

    ReturnBufferSize - supplies size of the buffer (in chars) pointed to
        by DataOut. If the buffer is too small and DataOut is specified,
        no data is stored and the function returns FALSE. If DataOut is
        not specified this value is ignored.

    RequiredSize - receives the number of characters (including the
        terminating nul) required to hold the result.

Return Value:

    Boolean value indicating result. If FALSE, extended error info is
    available from GetLastError().

--*/

{
    DWORD Err;
    PSETUP_FILE_LOG FileLog;
    BOOL b;
    TCHAR ProfileValue[2*MAX_PATH];
    INT n;
    DWORD d;
    PTCHAR Field,End,Info;
    UINT InfoLength;
    BOOL Quoted;

    FileLog = (PSETUP_FILE_LOG)FileLogHandle;

    try {
        //
        // Validate arguments.
        // Section name must be supplied for non-system log.
        //
        if((!FileLog->SystemLog && !LogSectionName)
        || (DesiredInfo >= SetupFileLogMax) || !TargetFilename) {
            Err = ERROR_INVALID_PARAMETER;
        } else {

            if(!LogSectionName) {
                MYASSERT(FileLog->SystemLog);
                LogSectionName = NtFileSectionName;
            }

            //
            // Query the log file via profile API.
            //
            d = GetPrivateProfileString(
                    LogSectionName,
                    TargetFilename,
                    TEXT(""),
                    ProfileValue,
                    sizeof(ProfileValue)/sizeof(ProfileValue[0]),
                    FileLog->FileName
                    );

            if(d) {
                //
                // We want to retreive the Nth item in the value we just
                // retreived, where N is based on what the caller wants.
                // This routine assumes that the SetupFileLogInfo enum is
                // in the same order as items appear in a line in the log!
                //
                Field = ProfileValue;
                n = 0;

                nextfield:
                //
                // Find the end of the current field, which is
                // the first comma, or the end of the value.
                // Skip leading spaces.
                //
                while(*Field == TEXT(' ')) {
                    Field++;
                }
                End = Field;
                Quoted = FALSE;
                while(*End) {
                    if(*End == TEXT('\"')) {
                        Quoted = !Quoted;
                    } else {
                        if(!Quoted && *End == TEXT(',')) {
                            //
                            // Got the end of the field.
                            //
                            break;
                        }
                    }
                    End++;
                }
                //
                // At this point, Field points to the start of the field
                // and End points at the character that terminated it.
                //
                if(n == DesiredInfo) {
                    Info = Field;
                    InfoLength = (UINT)(End-Field);
                    //
                    // Compensate for trailing space.
                    //
                    while (*--End == TEXT(' ')) {
                        InfoLength--;
                    }
                } else {
                    //
                    // Skip trailing spaces and the comma, if any.
                    //
                    while(*End == ' ') {
                        End++;
                    }
                    if(*End == ',') {
                        //
                        // More fields exist.
                        //
                        Field = End+1;
                        n++;
                        goto nextfield;
                    } else {
                        //
                        // Item doesn't exist.
                        //
                        Info = TEXT("");
                        InfoLength = 0;
                    }
                }

                if(RequiredSize) {
                    *RequiredSize = InfoLength+1;
                }
                Err = NO_ERROR;
                if(DataOut) {
                    if(ReturnBufferSize > InfoLength) {
                        lstrcpyn(DataOut,Info,InfoLength+1);
                    } else {
                        Err = ERROR_INSUFFICIENT_BUFFER;
                    }
                }
            } else {
                Err = ERROR_FILE_NOT_FOUND;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\dll.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    dll.c

Abstract:

    Initialization/de-initialization of setupapi.dll

Author:

    Lonny McMichael (lonnym) 10-May-1995

Revision History:

    Jamie Hunter (JamieHun) Apr-25-2002
            Security code review

--*/

#include "precomp.h"
#pragma hdrstop

HANDLE MyDllModuleHandle;

OSVERSIONINFOEX OSVersionInfo;

//
// TLS Data
//
DWORD TlsIndex = (DWORD)(-1);           // no data
PSETUP_TLS pLastTlsAlloc = NULL;        // for cleanup


//
// Static strings we retreive once. Listed in order they are retrieved
//
PCTSTR OsLoaderRelativePath = NULL;     // (can be NULL)
PCTSTR OsSystemPartitionRoot = NULL;    // eg: \\?\GLOBALROOT\Device\HarddiskVolume1
PCTSTR ProcessFileName = NULL;          // Filename of app calling setupapi
PCTSTR WindowsDirectory = NULL;         // %windir%, GetSystemWindowsDirectory()
PCTSTR InfDirectory = NULL;             // %windir%\INF
PCTSTR System16Directory = NULL;        // %windir%\SYSTEM
PCTSTR LastGoodDirectory = NULL;        // %windir%\LastGood
PCTSTR SystemDirectory = NULL;          // <sys>, %windir%\SYSTEM or %windir%\System32
PCTSTR WindowsBackupDirectory = NULL;   // <sys>\ReinstallBackups
PCTSTR ConfigDirectory = NULL;          // <sys>\CONFIG
PCTSTR DriversDirectory = NULL;         // <sys>\DRIVERS
PCTSTR SystemSourcePath = NULL;         // location system installed from
PCTSTR ServicePackSourcePath = NULL;    // location service pack installed from (can be NULL)
PCTSTR ServicePackCachePath = NULL;     // location service pack files are cached
PCTSTR DriverCacheSourcePath = NULL;    // location of driver cache (can be NULL)
BOOL   GuiSetupInProgress = FALSE;      // set if we determine we're in GUI setup
PCTSTR InfSearchPaths = NULL;           // Multi-sz list of fully-qualified directories where INFs are to be searched for.
#ifndef _WIN64
BOOL   IsWow64 = FALSE;                 // set if we're running under WOW64
#endif
CRITICAL_SECTION InitMutex;             // for one-time initializations
CRITICAL_SECTION ImageHlpMutex;         // for dealing with IMAGEHLP library
CRITICAL_SECTION DelayedComponentMutex; // for any delayed initialization of certain components
CRITICAL_SECTION PlatformPathOverrideCritSect;
CRITICAL_SECTION LogUseCountCs;
CRITICAL_SECTION MruCritSect;
CRITICAL_SECTION NetConnectionListCritSect;
BOOL   InInitialization = FALSE;
DWORD  DoneInitialization = 0;          // bitmask of items we've initialized
DWORD  DoneCleanup = 0;                 // bitmask of items we've cleaned up
DWORD  DoneComponentInitialize = 0;     // bitmask of components we've done delayed initialization
DWORD  FailedComponentInitialize = 0;   // bitmask of components we've failed initialization
HANDLE GlobalNoDriverPromptsEventFlag = NULL;  // event that acts as a flag during setup
INT DoneCriticalSections = 0;
DWORD Seed;

CRITICAL_SECTION * CriticalSectionList[] = {
    &InitMutex,
    &ImageHlpMutex,
    &DelayedComponentMutex,
    &PlatformPathOverrideCritSect,
    &LogUseCountCs,
    &MruCritSect,
    &NetConnectionListCritSect,
    NULL
};

#define DONEINIT_TLS          (0x0000001)
#define DONEINIT_UTILS        (0x0000002)
#define DONEINIT_MEM          (0x0000004)
#define DONEINIT_CTRL         (0x0000008)
#define DONEINIT_FUSION       (0x0000010)
#define DONEINIT_STUBS        (0x0000020)
#define DONEINIT_COMMON       (0x0000040)
#define DONEINIT_DIAMOND      (0x0000080)
#define DONEINIT_LOGGING      (0x0000100)
#define DONEINIT_CFGMGR32     (0x0000200)
#define DONEINIT_COMPLETE     (0x8000000)



//
// various control flags
//
DWORD GlobalSetupFlags = 0;
DWORD GlobalSetupFlagsOverride = PSPGF_MINIMAL_EMBEDDED | PSPGF_NO_SCE_EMBEDDED;     // flags that cannot be modified

//
// Declare a (non-CONST) array of strings that specifies what lines to look for
// in an INF's [ControlFlags] section when determining whether a particular device
// ID should be excluded.  These lines are of the form "ExcludeFromSelect[.<suffix>]",
// where <suffix> is determined and filled in during process attach as an optimization.
//
// The max string length (including NULL) is 32, and there can be a maximum of 3
// such strings.  E.g.: ExcludeFromSelect, ExcludeFromSelect.NT, ExcludeFromSelect.NTAmd64
//
// WARNING!! Be very careful when mucking with the order/number of these entries.  Check
// the assumptions made in devdrv.c!pSetupShouldDevBeExcluded.
//
TCHAR pszExcludeFromSelectList[3][32] = { INFSTR_KEY_EXCLUDEFROMSELECT,
                                          INFSTR_KEY_EXCLUDEFROMSELECT,
                                          INFSTR_KEY_EXCLUDEFROMSELECT
                                        };

DWORD ExcludeFromSelectListUb;  // contains the number of strings in the above list (2 or 3).


#ifndef _WIN64
BOOL
GetIsWow64 (
    VOID
    );
#endif

BOOL
CommonProcessAttach(
    IN BOOL Attach
    );

PCTSTR
GetDriverCacheSourcePath(
    VOID
    );

PCTSTR
pSetupGetOsLoaderPath(
    VOID
    );

PCTSTR
pSetupGetSystemPartitionRoot(
    VOID
    );

PCTSTR
pSetupGetProcessPath(
    VOID
    );

BOOL
pGetGuiSetupInProgress(
    VOID
    );


BOOL
CfgmgrEntry(
    PVOID hModule,
    ULONG Reason,
    PCONTEXT pContext
    );


BOOL
ThreadTlsInitialize(
    IN BOOL Init
    );

VOID
ThreadTlsCleanup(
    );

BOOL
IsNoDriverPrompts(
    VOID
    );

DWORD
GetEmbeddedFlags(
    VOID
    );

DWORD
GetSeed(
    VOID
    );


BOOL
ProcessAttach(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
/*++

Routine Description:

    Handles DLL_PROCESS_ATTACH in a way that can be unwound

Arguments:

    Reserved = 'Reserved' value passed into DllMain

Return Value:

    TRUE if processed initialized
    FALSE if partially/not initialized

--*/
{
    BOOL b = FALSE;

    if(DoneCleanup) {
        //
        // if we get here, this means someone lied to us
        //
        MYASSERT(!DoneCleanup);
        DoneInitialization &= ~DoneCleanup;
        DoneCleanup = 0;
    }
    //
    // nothing should already be initialized
    //
    MYASSERT(!DoneInitialization);

    try {
        MyDllModuleHandle = DllHandle;

        //
        // initialize TLS before anything else - hence why we use LocalAlloc
        //
        TlsIndex = TlsAlloc();
        if (TlsIndex!=(DWORD)(-1)) {
            DoneInitialization |= DONEINIT_TLS;
        } else {
            leave;
        }

        //
        // always do pSetupInitializeUtils and MemoryInitializeEx first
        // (pSetupInitializeUtils sets up memory functions)
        //
        if(pSetupInitializeUtils()) {
            DoneInitialization |= DONEINIT_UTILS;
        } else {
            leave;
        }
        if(MemoryInitializeEx(TRUE)) {
            DoneInitialization |= DONEINIT_MEM;
        } else {
            leave;
        }
        if(spFusionInitialize()) {
            DoneInitialization |= DONEINIT_FUSION;
        }
        //
        // Dynamically load proc addresses of NT-specific APIs
        // must be before CommonProcessAttach etc
        // however memory must be initialized
        //
        InitializeStubFnPtrs();
        DoneInitialization |= DONEINIT_STUBS;
        //
        // most of the remaining initialization
        //
        if(CommonProcessAttach(TRUE)) {
            DoneInitialization |= DONEINIT_COMMON;
        } else {
            leave;
        }
        if(DiamondProcessAttach(TRUE)) {
            DoneInitialization |= DONEINIT_DIAMOND;
        } else {
            leave;
        }
        if(InitializeContextLogging(TRUE)) {
            DoneInitialization |= DONEINIT_LOGGING;
        } else {
            leave;
        }

        //
        // Since we've incorporated cfgmgr32 into setupapi, we need
        // to make sure it gets initialized just like it did when it was
        // its own DLL. - must do AFTER everything else
        //
        if(CfgmgrEntry(DllHandle, Reason, Reserved)) {
            DoneInitialization |= DONEINIT_CFGMGR32;
        }
        DoneInitialization |= DONEINIT_COMPLETE;
        b = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    return b;
}

void
DestroySetupTlsData(
    )
/*++

Routine Description:

    Destroy all TLS data from every thread
    calling any cleanup routines as required

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    PSETUP_TLS pTLS;

    if(pLastTlsAlloc) {
        pLastTlsAlloc->Prev->Next = NULL;
        while(pLastTlsAlloc) {
            pTLS = pLastTlsAlloc;
            pLastTlsAlloc = pTLS->Next;
            TlsSetValue(TlsIndex,pTLS); // switch specific data into this thread
            ThreadTlsCleanup();
            LocalFree(pTLS);
        }
    }
    TlsSetValue(TlsIndex,NULL); // don't leave invalid pointer hanging around
}

void
ProcessDetach(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
/*++

Routine Description:

    Handles DLL_PROCESS_DETACH

Arguments:

    Reserved = 'Reserved' value passed into DllMain
        Which is actually TRUE for Process Exit, FALSE otherwise

Return Value:

    None
--*/
{
    DWORD ToCleanup = DoneInitialization & ~ DoneCleanup;
    if(!ToCleanup) {
        //
        // nothing to cleanup
        //
        return;
    }
    try {
        if (ToCleanup & DONEINIT_COMPLETE) {
            DoneCleanup |= DONEINIT_COMPLETE;
        }

        if(DoneInitialization & DONEINIT_TLS) {
            //
            // cleanup all remaining Tls data
            //
            if(!Reserved) {
                //
                // only do this for FreeLibrary/ failed LoadLibrary
                //
                DestroySetupTlsData();
            }
        }
        if(ToCleanup & DONEINIT_TLS) {
            //
            // destroy our allocated TLS index
            // do this now so that we don't try allocating
            // TLS storage during this cleanup
            //
            TlsFree(TlsIndex);
            TlsIndex = (DWORD)(-1);
            DoneCleanup |= DONEINIT_TLS;
        }

        //
        // do things generally in reverse order of ProcessAttach
        //

        // Since we've incorporated cfgmgr32 into setupapi, we need
        // to make sure it gets uninitialized just like it did when it was
        // its own DLL. - must do BEFORE anything else
        //
        if(ToCleanup & DONEINIT_CFGMGR32) {
            CfgmgrEntry(DllHandle, Reason, Reserved);
            DoneCleanup |= DONEINIT_CFGMGR32;
        }

        if(ToCleanup & DONEINIT_DIAMOND) {
            DiamondProcessAttach(FALSE);
            DoneCleanup |= DONEINIT_DIAMOND;
        }

#if 0   // see ComponentCleanup at end of file
        ComponentCleanup(DoneComponentInitialize);
#endif
        if(ToCleanup & DONEINIT_FUSION) {
            //
            // Fusion cleanup
            // only do full if this is FreeLibrary (or failed attach)
            //
            spFusionUninitialize((Reserved == NULL) ? TRUE : FALSE);
            DoneCleanup |= DONEINIT_FUSION;
        }

        if(ToCleanup & DONEINIT_COMMON) {
            //
            // Most of remaining cleanup
            //
            CommonProcessAttach(FALSE);
            DoneCleanup |= DONEINIT_COMMON;
        }
        if(ToCleanup & DONEINIT_STUBS) {
            //
            // Clean up stub functions
            //
            CleanUpStubFns();
            DoneCleanup |= DONEINIT_STUBS;
        }
        if(ToCleanup & DONEINIT_LOGGING) {
            //
            // Clean up context logging
            //
            InitializeContextLogging(FALSE);
            DoneCleanup |= DONEINIT_LOGGING;
        }
        //
        // *THESE MUST ALWAYS BE* very last things, in this order
        //
        if(ToCleanup & DONEINIT_MEM) {
            //
            // Clean up context logging
            //
            MemoryInitializeEx(FALSE);
            DoneCleanup |= DONEINIT_MEM;
        }
        if(ToCleanup & DONEINIT_UTILS) {
            //
            // Clean up context logging
            //
            pSetupUninitializeUtils();
            DoneCleanup |= DONEINIT_UTILS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
}

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
    BOOL b;

    InInitialization = TRUE;

    b = TRUE;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        b = ProcessAttach(DllHandle,Reason,Reserved);
        if(!b) {
            ProcessDetach(DllHandle,DLL_THREAD_DETACH,NULL);
        }
        break;

    case DLL_THREAD_ATTACH:
        //
        // don't do anything here
        // any TLS must be done on demand
        // via SetupGetTlsData
        //
        break;

    case DLL_PROCESS_DETACH:
        //
        // any TLS cleanup must be done in ThreadTlsCleanup
        //
        ProcessDetach(DllHandle,Reason,Reserved);
        break;

    case DLL_THREAD_DETACH:
        ThreadTlsInitialize(FALSE);
        break;
    }

    InInitialization = FALSE;
    return(b);
}

PSETUP_TLS
SetupGetTlsData(
    )
/*++

Routine Description:

    Called to obtain a pointer to TLS data

Arguments:

    NONE

Return Value:

    Pointer to TLS data, or NULL

--*/
{
    PSETUP_TLS pTLS;

    if (TlsIndex==(DWORD)(-1)) {
        return NULL;
    }
    pTLS = (PSETUP_TLS)TlsGetValue(TlsIndex);
    if (!pTLS) {
        ThreadTlsInitialize(TRUE);
        pTLS = (PSETUP_TLS)TlsGetValue(TlsIndex);
    }
    return pTLS;
}

VOID
ThreadTlsCleanup(
    )
/*++

Routine Description:

    Called to uninitialize some pTLS data
    might be a different thread to initialize
    but SetupAPI TLS data will have been switched in

Arguments:

    pTLS - data to cleanup

Return Value:

    NONE.

--*/
{
    DiamondTlsInit(FALSE);
    ContextLoggingTlsInit(FALSE);
}

BOOL
ThreadTlsUnlink(
    IN PSETUP_TLS pTLS
    )
{
    BOOL b;
    try {
        EnterCriticalSection(&InitMutex);
        if(pTLS->Next == pTLS->Prev) {
            pLastTlsAlloc = NULL;
        } else {
            pTLS->Prev->Next = pTLS->Next;
            pTLS->Next->Prev = pTLS->Prev;
            pLastTlsAlloc = pTLS->Prev; // anything but pTLS
        }
        LeaveCriticalSection(&InitMutex);
        b = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    return b;
}

PSETUP_TLS
ThreadTlsCreate(
    )
/*++

Routine Description:

    Called to create pTLS data for this thread

Arguments:

    NONE

Return Value:

    per-thread data, or NULL on failure

--*/
{
    BOOL b;
    PSETUP_TLS pTLS;
    if (TlsIndex==(DWORD)(-1)) {
        return NULL;
    }
    pTLS = (PSETUP_TLS)LocalAlloc(LMEM_ZEROINIT,sizeof(SETUP_TLS));
    if(!pTLS) {
        return NULL;
    }
    b = TlsSetValue(TlsIndex,pTLS);
    if(!b) {
        LocalFree(pTLS);
        return NULL;
    }
    try {
        EnterCriticalSection(&InitMutex);
        if(pLastTlsAlloc) {
            pTLS->Prev = pLastTlsAlloc;
            pTLS->Next = pTLS->Prev->Next;
            pTLS->Prev->Next = pTLS;
            pTLS->Next->Prev = pTLS;
        } else {
            pTLS->Next = pTLS;
            pTLS->Prev = pTLS;
        }
        pLastTlsAlloc = pTLS;
        LeaveCriticalSection(&InitMutex);
        b = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        LocalFree(pTLS);
        TlsSetValue(TlsIndex,NULL);
        return NULL;
    }
    //
    // TLS data initialized, now specific Init routines
    //
    b = DiamondTlsInit(TRUE);
    if(b) {
        b = ContextLoggingTlsInit(TRUE);
        if(b) {
            //
            // all done ok
            //
            return pTLS;
        }
        //
        // cleanup DiamondTlsInit
        //
        DiamondTlsInit(FALSE);
    }
    //
    // cleanup memory
    //
    TlsSetValue(TlsIndex,NULL);
    if(ThreadTlsUnlink(pTLS)) {
        LocalFree(pTLS);
    }
    return NULL;
}

BOOL
ThreadTlsInitialize(
    IN BOOL Init
    )
/*++

Routine Description:

    Called with TRUE to initialize TLS, if FALSE, to uninitialize

Arguments:

    Init - indicates if we are to initialize vs uninitialize

Return Value:

    NONE.

--*/
{
    BOOL b = FALSE;
    PSETUP_TLS pTLS = NULL;
    if (TlsIndex!=(DWORD)(-1)) {
        if (Init) {
            pTLS = ThreadTlsCreate();
            b = pTLS ? TRUE : FALSE;
        } else {
            pTLS = (PSETUP_TLS)TlsGetValue(TlsIndex);
            if(pTLS) {
                ThreadTlsCleanup();
                TlsSetValue(TlsIndex,NULL);
                if(ThreadTlsUnlink(pTLS)) {
                    LocalFree(pTLS);
                }
            }
            b = TRUE;
        }
    }
    return b;
}

BOOL
IsInteractiveWindowStation(
    )
/*++

Routine Description:

    Determine if we are running on an interactive station vs non-interactive station (i.e., service)

Arguments:

    none

Return Value:

    True if interactive

--*/
{
    HWINSTA winsta;
    USEROBJECTFLAGS flags;
    BOOL interactive = TRUE; // true unless we determine otherwise
    DWORD lenNeeded;

    winsta = GetProcessWindowStation();
    if(!winsta) {
        return interactive;
    }
    if(GetUserObjectInformation(winsta,UOI_FLAGS,&flags,sizeof(flags),&lenNeeded)) {
        interactive = (flags.dwFlags & WSF_VISIBLE) ? TRUE : FALSE;
    }
    //
    // don't call CLoseWindowStation
    //
    return interactive;
}

BOOL
CommonProcessAttach(
    IN BOOL Attach
    )
{
    BOOL b;
    TCHAR Buffer[MAX_PATH+32];
    PTCHAR p;
    UINT u;

    b = !Attach;

    if(Attach) {

        try {

            //
            // (remaining) critical sections
            //
            while(CriticalSectionList[DoneCriticalSections]) {
                InitializeCriticalSection(CriticalSectionList[DoneCriticalSections]);
                //
                // increment only if we get here (exception can occur)
                //
                DoneCriticalSections++;
            }
#ifndef _WIN64
            IsWow64 = GetIsWow64();
#endif
            //
            // flag indicating we're running in context of GUI setup
            //
            GuiSetupInProgress = pGetGuiSetupInProgress();
            //
            // determine if we're interactive or not
            //
            if(!IsInteractiveWindowStation()) {
                GlobalSetupFlagsOverride |= PSPGF_NONINTERACTIVE;   // don't allow this to be changed
                GlobalSetupFlags |= PSPGF_NONINTERACTIVE;           // actual value
            }
            if(IsNoDriverPrompts()) {
                GlobalSetupFlagsOverride |= PSPGF_UNATTENDED_SETUP; // don't allow this to be changed
                GlobalSetupFlags |= PSPGF_UNATTENDED_SETUP;         // actual value
            }

            GlobalSetupFlags |= GetEmbeddedFlags();

            Seed = GetSeed();

            pSetupInitNetConnectionList(TRUE);
            pSetupInitPlatformPathOverrideSupport(TRUE);
            OsLoaderRelativePath = pSetupGetOsLoaderPath();         // ok to fail
            OsSystemPartitionRoot = pSetupGetSystemPartitionRoot(); // ok to fail

            //
            // Fill in system and windows directories.
            //
            if ((ProcessFileName = pSetupGetProcessPath()) == NULL) {
                goto cleanAll;
            }

            //
            // determine %windir%
            //
            if(((u = GetSystemWindowsDirectory(Buffer,MAX_PATH)) == 0) || u>MAX_PATH) {
                goto cleanAll;
            }
            p = Buffer + u; // offset past directory to do all the sub-directories

            //
            // %windir% ==> WindowsDirectory
            //
            if((WindowsDirectory = DuplicateString(Buffer)) == NULL) {
                goto cleanAll;
            }

            //
            // %windir%\INF ==> InfDirectory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,TEXT("INF"),MAX_PATH,NULL)
               || ((InfDirectory = DuplicateString(Buffer)) == NULL)) {
                goto cleanAll;
            }

            //
            // %windir%\SYSTEM ==> System16Directory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,TEXT("SYSTEM"),MAX_PATH,NULL)
               || ((System16Directory = DuplicateString(Buffer))==NULL)) {
                goto cleanAll;
            }

            //
            // %windir%\LastGood ==> LastGoodDirectory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,SP_LASTGOOD_NAME,MAX_PATH,NULL)
               || ((LastGoodDirectory = DuplicateString(Buffer))==NULL)) {
                goto cleanAll;
            }

            //
            // determine system directory
            //
            if(((u = GetSystemDirectory(Buffer,MAX_PATH)) == 0) || u>MAX_PATH) {
                goto cleanAll;
            }
            p = Buffer + u; // offset past directory to do all the sub-directories

            //
            // <sys> ==> SystemDirectory (%windir%\System or %windir%\System32)
            //
            if((SystemDirectory = DuplicateString(Buffer)) == NULL) {
                goto cleanAll;
            }

            //
            // <sys>\ReinstallBackups ==> WindowsBackupDirectory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,TEXT("ReinstallBackups"),MAX_PATH,NULL)
               || ((WindowsBackupDirectory = DuplicateString(Buffer))==NULL)) {
                goto cleanAll;
            }

            //
            // <sys>\CONFIG ==> ConfigDirectory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,TEXT("CONFIG"),MAX_PATH,NULL)
               || ((ConfigDirectory = DuplicateString(Buffer))==NULL)) {
                goto cleanAll;
            }

            //
            // <sys>\DRIVERS ==> DriversDirectory
            //
            *p = 0;
            if(!pSetupConcatenatePaths(Buffer,TEXT("DRIVERS"),MAX_PATH,NULL)
               || ((DriversDirectory = DuplicateString(Buffer))==NULL)) {
                goto cleanAll;
            }

            //
            // location system installed from
            //
            if((SystemSourcePath = GetSystemSourcePath())==NULL) {
                goto cleanAll;
            }

            //
            // location service pack installed from (may be NULL)
            //
            ServicePackSourcePath = GetServicePackSourcePath();
            //
            // location of local disk cached files (may be NULL)
            // files here have precedence over everything else
            //
            ServicePackCachePath = GetServicePackCachePath();
            //
            // location of driver cache (may be NULL)
            //
            DriverCacheSourcePath = GetDriverCacheSourcePath();

            //
            // determine driver search path
            //
            if((InfSearchPaths = AllocAndReturnDriverSearchList(INFINFO_INF_PATH_LIST_SEARCH))==NULL) {
                goto cleanAll;
            }

            //
            // note that InitMiniIconList, InitDrvSearchInProgressList, and
            // InitDrvSignPolicyList need to be explicitly cleaned up on failure
            //

            //
            // initialize mini icons
            //
            if(!InitMiniIconList()) {
                goto cleanAll;
            }

            //
            // allows aborting of search
            //
            if(!InitDrvSearchInProgressList()) {
                DestroyMiniIconList();
                goto cleanAll;
            }

            //
            // global list of device setup classes subject to driver signing policy
            //
            if(!InitDrvSignPolicyList()) {
                DestroyMiniIconList();
                DestroyDrvSearchInProgressList();
                goto cleanAll;
            }

            //
            // common version initialization
            //
            ZeroMemory(&OSVersionInfo,sizeof(OSVersionInfo));
            OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVersionInfo);
            if((!GetVersionEx((LPOSVERSIONINFO)&OSVersionInfo))
               || (OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)) {
                //
                // should never get here
                //
                MYASSERT(FALSE);
                DestroyMiniIconList();
                DestroyDrvSearchInProgressList();
                DestroyDrvSignPolicyList();
                goto cleanAll;
            }

            //
            // Fill in our ExcludeFromSelect string list which
            // we pre-compute as an optimization.
            //
            if(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
                lstrcat(pszExcludeFromSelectList[1],
                        pszNtSuffix
                       );
                lstrcat(pszExcludeFromSelectList[2],
                        pszNtPlatformSuffix
                       );
                ExcludeFromSelectListUb = 3;
            } else {
                lstrcat(pszExcludeFromSelectList[1],
                        pszWinSuffix
                       );
                ExcludeFromSelectListUb = 2;
            }
            //
            // Now lower-case all the strings in this list, so that it
            // doesn't have to be done at each string table lookup.
            //
            for(u = 0; u < ExcludeFromSelectListUb; u++) {
                CharLower(pszExcludeFromSelectList[u]);
            }

            b = TRUE;
cleanAll: ;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Unexpected exception occurred, drop into cleanup
            //
        }
        if(b) {
            //
            // succeeded
            //
            goto Done;
        }
    } else {
        //
        // Detach
        //
        DestroyMiniIconList();
        DestroyDrvSearchInProgressList();
        DestroyDrvSignPolicyList();
        if(GlobalNoDriverPromptsEventFlag) {
            CloseHandle(GlobalNoDriverPromptsEventFlag);
        }
    }
    while(DoneCriticalSections--) {
        DeleteCriticalSection(CriticalSectionList[DoneCriticalSections]);
    }
    if (InfSearchPaths) {
        MyFree(InfSearchPaths);
        InfSearchPaths = NULL;
    }
    if (DriverCacheSourcePath) {
        MyFree(DriverCacheSourcePath);
        DriverCacheSourcePath = NULL;
    }
    if (ServicePackSourcePath) {
        MyFree(ServicePackSourcePath);
        ServicePackSourcePath = NULL;
    }
    if (ServicePackCachePath) {
        MyFree(ServicePackCachePath);
        ServicePackCachePath = NULL;
    }
    if (SystemSourcePath) {
        MyFree(SystemSourcePath);
        SystemSourcePath = NULL;
    }
    if (SystemDirectory) {
        MyFree(SystemDirectory);
        SystemDirectory = NULL;

        if (WindowsBackupDirectory) {
            MyFree(WindowsBackupDirectory);
            WindowsBackupDirectory = NULL;
        }
        if (ConfigDirectory) {
            MyFree(ConfigDirectory);
            ConfigDirectory = NULL;
        }
        if (DriversDirectory) {
            MyFree(DriversDirectory);
            DriversDirectory = NULL;
        }
    }
    if (WindowsDirectory) {
        MyFree(WindowsDirectory);
        WindowsDirectory = NULL;

        if (InfDirectory) {
            MyFree(InfDirectory);
            InfDirectory = NULL;
        }
        if (System16Directory) {
            MyFree(System16Directory);
            System16Directory = NULL;
        }
        if (LastGoodDirectory) {
            MyFree(LastGoodDirectory);
        }   LastGoodDirectory = NULL;
    }
    if (ProcessFileName) {
        MyFree(ProcessFileName);
        ProcessFileName = NULL;
    }
    if (OsLoaderRelativePath) {
        MyFree(OsLoaderRelativePath);
        OsLoaderRelativePath = NULL;
    }
    if (OsSystemPartitionRoot) {
        MyFree(OsSystemPartitionRoot);
        OsSystemPartitionRoot = NULL;
    }
    pSetupInitNetConnectionList(FALSE);
    pSetupInitPlatformPathOverrideSupport(FALSE);
Done:
    return(b);
}

#if MEM_DBG
#undef GetSystemSourcePath          // defined again below
#endif

PCTSTR
GetSystemSourcePath(
    TRACK_ARG_DECLARE
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the source path from
    which the system was installed, or "A:\" if that value cannot be determined.
    This value is retrieved from the following registry location:

    \HKLM\Software\Microsoft\Windows\CurrentVersion\Setup

        SourcePath : REG_SZ : "\\ntamd64\1300fre.wks"  // for example.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is a pointer to the path string.
    This memory must be freed via MyFree().

    If the function fails due to out-of-memory, the return value is NULL.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD Err, DataType, DataSize;
    PTSTR Value;
    PCTSTR ReturnVal;

    TRACK_PUSH

    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           CharBuffer,
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "SourcePath" value.
        //
        Err = QueryRegistryValue(hKey, pszSourcePath, &Value, &DataType, &DataSize);

        RegCloseKey(hKey);
    }

    ReturnVal = NULL;

    if(Err == NO_ERROR) {

        ReturnVal = Value;

    }

    if(!ReturnVal && Err != ERROR_NOT_ENOUGH_MEMORY) {
        //
        // We failed to retrieve the SourcePath value, and it wasn't due to an out-of-memory
        // condition.  Fall back to our default of "A:\".
        //
        ReturnVal = DuplicateString(pszOemInfDefaultPath);
    }

    TRACK_POP

    return ReturnVal;
}

#if MEM_DBG
#define GetSystemSourcePath()   GetSystemSourcePath(TRACK_ARG_CALL)
#endif



#if MEM_DBG
#undef GetServicePackSourcePath         // defined again below
#undef GetServicePackCachePath         // defined again below
#endif

PCTSTR
GetServicePackSourcePath(
    TRACK_ARG_DECLARE
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the service pack source path
    where we should look for service pack source files, or "CDM" if that value cannot be determined.
    This value is retrieved from the following registry location:

    \HKLM\Software\Microsoft\Windows\CurrentVersion\Setup

        ServicePackSourcePath : REG_SZ : "\\ntamd64\1300fre.wks"  // for example.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is a pointer to the path string.
    This memory must be freed via MyFree().

    If the function fails due to out-of-memory, the return value is NULL.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD Err, DataType, DataSize;
    PTSTR Value;
    PCTSTR ReturnStr = NULL;

    TRACK_PUSH

    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           CharBuffer,
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "ServicePackSourcePath" value.
        //
        Err = QueryRegistryValue(hKey, pszSvcPackPath, &Value, &DataType, &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {

        ReturnStr = Value;

    }

    if(!ReturnStr && Err != ERROR_NOT_ENOUGH_MEMORY) {
        //
        // We failed to retrieve the ServicePackSourcePath value, and it wasn't due to an out-of-memory
        // condition.  Fall back to the SourcePath value in the registry
        //

        ReturnStr = GetSystemSourcePath();
    }

    TRACK_POP

    return ReturnStr;
}

PCTSTR
GetServicePackCachePath(
    TRACK_ARG_DECLARE
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the service pack cache path
    where we should look for files ahead of anything else

    This value is retrieved from the following registry location:

    \HKLM\Software\Microsoft\Windows\CurrentVersion\Setup

        ServicePackCachePath : REG_SZ : "c:\windows\foo"  // for example.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is a pointer to the path string.
    This memory must be freed via MyFree().

    If the function fails due to out-of-memory, the return value is NULL.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD Err, DataType, DataSize;
    PTSTR Value;
    PCTSTR ReturnStr = NULL;

    TRACK_PUSH

    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           CharBuffer,
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "ServicePackCachePath" value.
        //
        Err = QueryRegistryValue(hKey, pszSvcPackCachePath, &Value, &DataType, &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {

        ReturnStr = Value;

    }

    TRACK_POP

    return ReturnStr;
}

#if MEM_DBG
#define GetServicePackSourcePath()   GetServicePackSourcePath(TRACK_ARG_CALL)
#define GetServicePackCachePath()   GetServicePackCachePath(TRACK_ARG_CALL)
#endif



PCTSTR
GetDriverCacheSourcePath(
    VOID
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the source path to the local driver cache
    cab-file.

    This value is retrieved from the following registry location:

    \HKLM\Software\Microsoft\Windows\CurrentVersion\Setup

        DriverCachePath : REG_SZ : "\\ntamd64\1300fre.wks"  // for example.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is a pointer to the path string.
    This memory must be freed via MyFree().

    If the function fails due to out-of-memory, the return value is NULL.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD Err, DataType, DataSize;
    PTSTR Value;
    TCHAR Path[MAX_PATH];

    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           CharBuffer,
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "DriverCachePath" value.
        //
        Err = QueryRegistryValue(hKey, pszDriverCachePath, &Value, &DataType, &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {
        if(Value) {

            ExpandEnvironmentStrings(Value,Path,MAX_PATH);

            MyFree(Value);

            Value = NULL;

            if (*Path) {
                Value = DuplicateString( Path );
            }

            return (PCTSTR)Value;
        }
    } else if(Err == ERROR_NOT_ENOUGH_MEMORY) {
        return NULL;
    }

    return NULL;

}




BOOL
pSetupSetSystemSourcePath(
    IN PCTSTR NewSourcePath,
    IN PCTSTR NewSvcPackSourcePath
    )
/*++

Routine Description:

    This routine is used to override the system source path used by setupapi (as
    retrieved by GetSystemSourcePath during DLL initialization).  This is used by
    syssetup.dll to set the system source path appropriately during GUI-mode setup,
    so that the device installer APIs will copy files from the correct source location.

    We do the same thing for the service pack source path

    NOTE:  This routine IS NOT thread safe!

Arguments:

    NewSourcePath - supplies the new source path to be used.
    NewSvcPackSourcePath - supplies the new svcpack source path to be used.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails (due to out-of-memory), the return value is FALSE.

--*/
{
    PCTSTR p,q;

    p = (PCTSTR)DuplicateString(NewSourcePath);
    q = (PCTSTR)DuplicateString(NewSvcPackSourcePath);

    if(p) {
        MyFree(SystemSourcePath);
        SystemSourcePath = p;
    }

    if (q) {
        MyFree(ServicePackSourcePath);
        ServicePackSourcePath = q;
    }

    if (!p || !q) {
        //
        // failed due to out of memory!
        //
        return(FALSE);
    }

    return TRUE;
}


PCTSTR
pSetupGetOsLoaderPath(
    VOID
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the path to the OsLoader
    (relative to the system partition drive).  This value is retrieved from the
    following registry location:

        HKLM\System\Setup
            OsLoaderPath : REG_SZ : <path>    // e.g., "\os\winnt40"

Arguments:

    None.

Return Value:

    If the registry entry is found, the return value is a pointer to the string containing
    the path.  The caller must free this buffer via MyFree().

    If the registry entry is not found, or memory cannot be allocated for the buffer, the
    return value is NULL.

--*/
{
    HKEY hKey;
    PTSTR Value;
    DWORD Err, DataType, DataSize;

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    TEXT("SYSTEM\\Setup"),
                    0,
                    KEY_READ,
                    &hKey) == ERROR_SUCCESS) {

        Err = QueryRegistryValue(hKey, TEXT("OsLoaderPath"), &Value, &DataType, &DataSize);

        RegCloseKey(hKey);

        return (Err == NO_ERROR) ? (PCTSTR)Value : NULL;
    }

    return NULL;
}

PCTSTR
pSetupGetSystemPartitionRoot(
    VOID
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer containing the path to the OsLoader
    (relative to the system partition drive).  This value is retrieved from the
    following registry location:

        HKLM\System\Setup
            SystemPartition : REG_SZ : <path>    // e.g., "\Device\HarddiskVolume1"

Arguments:

    None.

Return Value:

    If the registry entry is found, the return value is a pointer to the string containing
    the path.  The caller must free this buffer via MyFree().

    If the registry entry is not found, or memory cannot be allocated for the buffer, the
    return value is NULL.

--*/
{
#ifdef UNICODE
    HKEY hKey;
    PTSTR Value;
    DWORD Err, DataType, DataSize;
    TCHAR Path[MAX_PATH];

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    TEXT("SYSTEM\\Setup"),
                    0,
                    KEY_READ,
                    &hKey) == ERROR_SUCCESS) {

        Err = QueryRegistryValue(hKey, TEXT("SystemPartition"), &Value, &DataType, &DataSize);

        RegCloseKey(hKey);

        if(Err == NO_ERROR) {
            //
            // prepend \\?\GLOBALROOT\
            //
            lstrcpy(Path,TEXT("\\\\?\\GLOBALROOT\\"));
            if(pSetupConcatenatePaths(Path,Value,MAX_PATH,NULL)) {
                MyFree(Value);
                Value = DuplicateString(Path);
                if(!Value) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                Err = GetLastError();
                MyFree(Value);
            }
        }

        return (Err == NO_ERROR) ? (PCTSTR)Value : NULL;
    }
#endif

    return NULL;
}

PCTSTR
pSetupGetProcessPath(
    VOID
    )
/*++

Routine Description:

    Get the name of the EXE that we're running in.

Arguments:

    NONE.

Return Value:

    Pointer to a dynamically allocated string containing the name.

--*/

{
    LPTSTR modname;

    modname = MyMalloc(MAX_PATH * sizeof(TCHAR));

    if(modname != NULL) {
        if(GetModuleFileName(NULL, modname, MAX_PATH) > 0) {
            LPTSTR modname2;
            modname2 = MyRealloc(modname, (lstrlen(modname)+1)*sizeof(TCHAR));
            if(modname2) {
                modname = modname2;
            }
            return modname;
        } else {
#ifdef PRERELEASE
            OutputDebugStringA("GetModuleFileName returned 0\r\n");
            DebugBreak();
#endif
            MyFree(modname);
        }
    }

    return NULL;
}

#ifdef UNICODE
BOOL
pGetGuiSetupInProgress(
    VOID
    )
/*++

Routine Description:

    This routine determines if we're doing a gui-mode setup.

    This value is retrieved from the following registry location:

    \HKLM\System\Setup\

        SystemSetupInProgress : REG_DWORD : 0x00 (where nonzero means we're doing a gui-setup)

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is a pointer to the path string.
    This memory must be freed via MyFree().

    If the function fails due to out-of-memory, the return value is NULL.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD Err, DataType, DataSize = sizeof(DWORD);
    DWORD Value;

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("System\\Setup"),
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "DriverCachePath" value.
        //
        Err = RegQueryValueEx(
                    hKey,
                    TEXT("SystemSetupInProgress"),
                    NULL,
                    &DataType,
                    (LPBYTE)&Value,
                    &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {
        if(Value) {
            return(TRUE);
        }
    }

    return(FALSE);

}

#else

BOOL
pGetGuiSetupInProgress(
    VOID
    )
{
    return FALSE;
}

#endif

VOID pSetupSetGlobalFlags(
    IN DWORD Value
    )
/*++

    exported as a private function

Routine Description:

    Sets global flags to change certain setupapi features,
    such as "should we call runonce after installing every device" (set if we will manually call it)
    or "should we backup every file"
    Used to initialize value

Arguments:

    Value: combination of:

        PSPGF_NO_RUNONCE     - set to inhibit runonce calls (e.g., during GUI-
                               mode setup)

        PSPGF_NO_BACKUP      - set to inhibit automatic backup (e.g., during
                               GUI-mode setup)

        PSPGF_NONINTERACTIVE - set to inhibit _all_ UI (e.g., for server-side
                               device installation)

        PSPGF_SERVER_SIDE_RUNONCE - batch RunOnce entries for server-side
                                    processing (for use only by umpnpmgr)

        PSPGF_NO_VERIFY_INF  - set to inhibit verification (digital signature) of
                               INF files until after the cyrpto DLLs have been registered.

        PSPGF_UNATTENDED_SETUP - similar to NONINTERACTIVE - but specific to unattended setup

        PSPGF_AUTOFAIL_VERIFIES - automatically fail all calls to crypto

Return Value:

    none

--*/
{
    pSetupModifyGlobalFlags((DWORD)(-1),Value);
}

VOID
pSetupModifyGlobalFlags(
    IN DWORD Flags,
    IN DWORD Value
    )
/*++

    exported as a private function

Routine Description:

    Modifies global setup flags

    such as "should we call runonce after installing every device" (set if we will manually call it)
    or "should we backup every file"
    only modifies specified flags to given value

Arguments:

    Flags: what actual flags to modify, combination of:

        PSPGF_NO_RUNONCE     - set to inhibit runonce calls (e.g., during GUI-
                               mode setup)

        PSPGF_NO_BACKUP      - set to inhibit automatic backup (e.g., during
                               GUI-mode setup)

        PSPGF_NONINTERACTIVE - set to inhibit _all_ UI (e.g., for server-side
                               device installation)

        PSPGF_SERVER_SIDE_RUNONCE - batch RunOnce entries for server-side
                                    processing (for use only by umpnpmgr)

        PSPGF_NO_VERIFY_INF  - set to inhibit verification (digital signature) of
                               INF files until after the cyrpto DLLs have been registered.

        PSPGF_UNATTENDED_SETUP - similar to PSPGF_NONINTERACTIVE, but specific to setup

        PSPGF_AUTOFAIL_VERIFIES - automatically fail all calls to crypto

    Value: new value of bits specified in Flags

Return Value:

    none

--*/
{
    Flags &= ~GlobalSetupFlagsOverride; // exclusion
#ifdef UNICODE
    if((Flags & PSPGF_NO_VERIFY_INF) && !(Value & PSPGF_NO_VERIFY_INF) && (GlobalSetupFlags & PSPGF_NO_VERIFY_INF)) {
        Seed = GetSeed();
    }
#endif
    GlobalSetupFlags = (Value & Flags) | (GlobalSetupFlags & ~Flags);
}

DWORD pSetupGetGlobalFlags(
    VOID
    )
/*++

    exported as a private function, also called internally

Routine Description:

    Return flags previously set

Arguments:

    none

Return value:

    Flags (combination of values described above for pSetupSetGlobalFlags)

--*/
{
    return GlobalSetupFlags;
}

BOOL
WINAPI
SetupSetNonInteractiveMode(
    IN BOOL NonInteractiveFlag
    )
/*++

    Global access to the flag PSPGF_NONINTERACTIVE

Routine Description:

    Set/Reset the NonInteractiveMode flag, and return previous flag value
    (can't clear override)

Arguments:

    New flag value

Return value:

    Old flag value

--*/
{
    BOOL f = (GlobalSetupFlags & PSPGF_NONINTERACTIVE) ? TRUE : FALSE;
    if (NonInteractiveFlag) {
        pSetupModifyGlobalFlags(PSPGF_NONINTERACTIVE,PSPGF_NONINTERACTIVE);
    } else {
        pSetupModifyGlobalFlags(PSPGF_NONINTERACTIVE,0);
    }
    return f;
}

BOOL
WINAPI
SetupGetNonInteractiveMode(
    VOID
    )
/*++

    Global access to the flag PSPGF_NONINTERACTIVE

Routine Description:

    Get current flag value

Arguments:

    none

Return value:

    Current flag value

--*/
{
    return (GlobalSetupFlags & PSPGF_NONINTERACTIVE) ? TRUE : FALSE;
}

#ifndef _WIN64
BOOL
GetIsWow64 (
    VOID
    )
/*++

Routine Description:

    Determine if we're running on WOW64 or not (not supported on ANSI builds)

Arguments:

    none

Return value:

    TRUE if running under WOW64 (and special Wow64 features available)

--*/
{
#ifdef UNICODE
    ULONG_PTR       ul = 0;
    NTSTATUS        st;

    //
    // If this call succeeds and sets ul non-zero
    // it's a 32-bit process running on Win64
    //

    st = NtQueryInformationProcess(NtCurrentProcess(),
                                   ProcessWow64Information,
                                   &ul,
                                   sizeof(ul),
                                   NULL);

    if (NT_SUCCESS(st) && (0 != ul)) {
        // 32-bit code running on Win64
        return TRUE;
    }
#endif
    return FALSE;
}
#endif // _WIN64

#if 0 // deleted code
//
// this will be useful at somepoint, but not used right now
//
BOOL
InitComponents(
    DWORD Components
    )
/*++

Routine Description:

    Called at a point we want certain components initialized

Arguments:

    bitmask of components to initialize

Return value:

    TRUE if all initialized ok

--*/
{
    BOOL success = FALSE;
    PSETUP_TLS pPerThread = SetupGetTlsData();
    BOOL locked = FALSE;

    if(!pPerThread) {
        MYASSERT(pPerThread);
        return FALSE;
    }

    try {
        EnterCriticalSection(&DelayedComponentMutex);
        locked = TRUE;
        Components &= ~ DoneComponentInitialize;
        Components &= ~ pPerThread->PerThreadDoneComponent;

        if (!Components) {
            //
            // already done
            //
            success = TRUE;
            leave;
        }
        if (Components & FailedComponentInitialize) {
            //
            // previously failed
            //
            leave;
        }
        if (Components & pPerThread->PerThreadFailedComponent) {
            //
            // previously failed
            //
            leave;
        }
        MYASSERT(((DoneComponentInitialize | pPerThread->PerThreadDoneComponent) & Components) == Components);
        MYASSERT(((FailedComponentInitialize | pPerThread->PerThreadFailedComponent) & Components) == 0);
        success = TRUE;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        MYASSERT(FALSE);
    }
    if(locked) {
        LeaveCriticalSection(&DelayedComponentMutex);
    }
    return success;
}

VOID
ComponentCleanup(
    DWORD Components
    )
/*++

Routine Description:

    Called to cleanup components

Arguments:

    bitmask of components to uninitialize

Return value:

    none

--*/
{
    PSETUP_TLS pPerThread = SetupGetTlsData();
    BOOL locked = FALSE;

    try {
        EnterCriticalSection(&DelayedComponentMutex);
        locked = TRUE;
        Components &= (DoneComponentInitialize | (pPerThread? pPerThread->PerThreadDoneComponent : 0));
        if (!Components) {
            //
            // already done
            //
            leave;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        MYASSERT(FALSE);
    }
    MYASSERT(((DoneComponentInitialize | (pPerThread ? pPerThread->PerThreadDoneComponent : 0)) & Components) == 0);
    if(locked) {
        LeaveCriticalSection(&DelayedComponentMutex);
    }
}
#endif // deleted code

#ifdef UNICODE
BOOL
pSetupSetNoDriverPrompts(
    BOOL Flag
    )
/*++

    exported as a private function

Routine Description:

    Sets system into headless/non-headless mode

Arguments:

    Flag - indicating mode

--*/
{
    //
    //
    if(!GuiSetupInProgress) {
        return FALSE;
    }
    if(GlobalNoDriverPromptsEventFlag == NULL) {
        GlobalNoDriverPromptsEventFlag = CreateEvent(NULL,TRUE,Flag,SETUP_NODRIVERPROMPTS_MODE);
        if(GlobalNoDriverPromptsEventFlag == NULL) {
            return FALSE;
        }
    }
    if(Flag) {
        //
        // force this process's setupapi to be non-interative, and any future setupapi's
        //
        GlobalSetupFlagsOverride |= PSPGF_UNATTENDED_SETUP;   // don't allow this to be changed
        GlobalSetupFlags |= PSPGF_UNATTENDED_SETUP;           // actual value
        SetEvent(GlobalNoDriverPromptsEventFlag);
    } else {
        //
        // can't reset flag for this/existing processes, but can reset it for all future processes
        //
        ResetEvent(GlobalNoDriverPromptsEventFlag);
    }
    return TRUE;
}
#endif

BOOL
IsNoDriverPrompts(
    VOID
    )
/*++

    internal

Routine Description:

    Obtains headless state

Arguments:

    Flag - indicating mode

--*/
{
#ifdef UNICODE
    if(!GuiSetupInProgress) {
        return FALSE;
    }
    if(GlobalNoDriverPromptsEventFlag == NULL) {
        GlobalNoDriverPromptsEventFlag = OpenEvent(SYNCHRONIZE,FALSE,SETUP_NODRIVERPROMPTS_MODE);
        if(GlobalNoDriverPromptsEventFlag == NULL) {
            return FALSE;
        }
    }
    //
    // poll event, returning TRUE if it's signalled
    //
    return WaitForSingleObject(GlobalNoDriverPromptsEventFlag,0) == WAIT_OBJECT_0;
#else
    return FALSE;
#endif
}


DWORD
GetEmbeddedFlags(
    VOID
    )
/*++

Routine Description:

    This routine determines whether or not we are running on an embedded
    product, and if so, whether:

    * The "minimize setupapi footprint" option is enabled.  This causes us to
      modify our default behaviors as follows:

          1.  Never call any crypto APIs, and just assume everything is signed
          2.  Never generate PNFs.

    * The "disable SCE" option is enabled.  This causes us to avoid all use of
      the Security Configuration Editor (SCE) routines (as the corresponding
      DLLs won't be available on that embedded configuration).

Arguments:

    none

Return value:

    Combination of the following flags:

    PSPGF_MINIMAL_EMBEDDED if we're running in "minimize footprint" mode

    PSPGF_NO_SCE_EMBEDDED if we're running in "disable SCE" mode

--*/
{
    OSVERSIONINFOEX osvix;
    DWORDLONG dwlConditionMask = 0;
    HKEY hKey;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD RegDataType, Data, DataSize;
    DWORD Flags;

    //
    // Are we on the embedded product suite?
    //
    ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
    osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvix.wSuiteMask = VER_SUITE_EMBEDDEDNT;
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    if(!VerifyVersionInfo(&osvix,
                          VER_SUITENAME,
                          dwlConditionMask)) {
        return 0;
    }

    Flags = 0;

    //
    // OK, we running on embedded.  Now we need to find out whether or not we
    // should run in "minimal footprint" mode.  This is stored in a REG_DWORD
    // value entry called "MinimizeFootprint" under
    // HKLM\Software\Microsoft\Windows\CurrentVersion\Setup.
    //
    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     CharBuffer,
                                     0,
                                     KEY_READ,
                                     &hKey)) {
        DataSize = sizeof(Data);

        if((ERROR_SUCCESS == RegQueryValueEx(hKey,
                                             pszMinimizeFootprint,
                                             NULL,
                                             &RegDataType,
                                             (LPBYTE)&Data,
                                             &DataSize))
           && (RegDataType == REG_DWORD) && (DataSize == sizeof(Data))) {

            Flags |= PSPGF_MINIMAL_EMBEDDED;
        }

        RegCloseKey(hKey);
    }

    //
    // Now look under HKLM\Software\Microsoft\EmbeddedNT\Security for a
    // DisableSCE REG_DWORD value entry, indicating we shouldn't call SCE.
    //
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     pszEmbeddedNTSecurity,
                                     0,
                                     KEY_READ,
                                     &hKey)) {
        DataSize = sizeof(Data);

        if((ERROR_SUCCESS == RegQueryValueEx(hKey,
                                             pszDisableSCE,
                                             NULL,
                                             &RegDataType,
                                             (LPBYTE)&Data,
                                             &DataSize))
           && (RegDataType == REG_DWORD) && (DataSize == sizeof(Data))) {

            Flags |= PSPGF_NO_SCE_EMBEDDED;
        }

        RegCloseKey(hKey);
    }

    return Flags;
}

#ifdef UNICODE
DWORD
GetSeed(
    VOID
    )
{
    HKEY hKey;
    DWORD val = 0;
    DWORD valsize, valdatatype;

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        return val;
    }

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     L"System\\WPA\\PnP",
                                     0,
                                     KEY_READ,
                                     &hKey)) {

        valsize = sizeof(val);
        if((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                             L"seed",
                                             NULL,
                                             &valdatatype,
                                             (PBYTE)&val,
                                             &valsize))
           || (valdatatype != REG_DWORD) || (valsize != sizeof(val))) {

            val = 0;
        }

        RegCloseKey(hKey);
    }

    return val;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\diutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    diutil.c

Abstract:

    Device Installer utility routines.

Author:

    Lonny McMichael (lonnym) 10-May-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <initguid.h>

//
// Define and initialize all device class GUIDs.
// (This must only be done once per module!)
//
#include <devguid.h>

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

//
// Define the period in miliseconds to wait between attempts to lock the SCM database
//
#define ACQUIRE_SCM_LOCK_INTERVAL 500

//
// Define the number of attempts at locking the SCM database should be made
// currently 10 * .5s = 5 seconds.
//
#define ACQUIRE_SCM_LOCK_ATTEMPTS 10

//
// Declare global string variables used throughout device
// installer routines.
//
// These strings are defined in regstr.h:
//
CONST TCHAR pszNoUseClass[]                      = REGSTR_VAL_NOUSECLASS,
            pszNoInstallClass[]                  = REGSTR_VAL_NOINSTALLCLASS,
            pszNoDisplayClass[]                  = REGSTR_VAL_NODISPLAYCLASS,
            pszDeviceDesc[]                      = REGSTR_VAL_DEVDESC,
            pszDevicePath[]                      = REGSTR_VAL_DEVICEPATH,
            pszPathSetup[]                       = REGSTR_PATH_SETUP,
            pszKeySetup[]                        = REGSTR_KEY_SETUP,
            pszPathRunOnce[]                     = REGSTR_PATH_RUNONCE,
            pszSourcePath[]                      = REGSTR_VAL_SRCPATH,
            pszSvcPackPath[]                     = REGSTR_VAL_SVCPAKSRCPATH,
            pszSvcPackCachePath[]                = REGSTR_VAL_SVCPAKCACHEPATH,
            pszDriverCachePath[]                 = REGSTR_VAL_DRIVERCACHEPATH,
            pszBootDir[]                         = REGSTR_VAL_BOOTDIR,
            pszInsIcon[]                         = REGSTR_VAL_INSICON,
            pszInstaller32[]                     = REGSTR_VAL_INSTALLER_32,
            pszEnumPropPages32[]                 = REGSTR_VAL_ENUMPROPPAGES_32,
            pszInfPath[]                         = REGSTR_VAL_INFPATH,
            pszInfSection[]                      = REGSTR_VAL_INFSECTION,
            pszDrvDesc[]                         = REGSTR_VAL_DRVDESC,
            pszHardwareID[]                      = REGSTR_VAL_HARDWAREID,
            pszCompatibleIDs[]                   = REGSTR_VAL_COMPATIBLEIDS,
            pszDriver[]                          = REGSTR_VAL_DRIVER,
            pszConfigFlags[]                     = REGSTR_VAL_CONFIGFLAGS,
            pszMfg[]                             = REGSTR_VAL_MFG,
            pszService[]                         = REGSTR_VAL_SERVICE,
            pszProviderName[]                    = REGSTR_VAL_PROVIDER_NAME,
            pszFriendlyName[]                    = REGSTR_VAL_FRIENDLYNAME,
            pszServicesRegPath[]                 = REGSTR_PATH_SERVICES,
            pszInfSectionExt[]                   = REGSTR_VAL_INFSECTIONEXT,
            pszDeviceClassesPath[]               = REGSTR_PATH_DEVICE_CLASSES,
            pszDeviceInstance[]                  = REGSTR_VAL_DEVICE_INSTANCE,
            pszDefault[]                         = REGSTR_VAL_DEFAULT,
            pszControl[]                         = REGSTR_KEY_CONTROL,
            pszLinked[]                          = REGSTR_VAL_LINKED,
            pszDeviceParameters[]                = REGSTR_KEY_DEVICEPARAMETERS,
            pszLocationInformation[]             = REGSTR_VAL_LOCATION_INFORMATION,
            pszCapabilities[]                    = REGSTR_VAL_CAPABILITIES,
            pszUiNumber[]                        = REGSTR_VAL_UI_NUMBER,
            pszUpperFilters[]                    = REGSTR_VAL_UPPERFILTERS,
            pszLowerFilters[]                    = REGSTR_VAL_LOWERFILTERS,
            pszMatchingDeviceId[]                = REGSTR_VAL_MATCHINGDEVID,
            pszBasicProperties32[]               = REGSTR_VAL_BASICPROPERTIES_32,
            pszCoInstallers32[]                  = REGSTR_VAL_COINSTALLERS_32,
            pszPathCoDeviceInstallers[]          = REGSTR_PATH_CODEVICEINSTALLERS,
            pszSystem[]                          = REGSTR_KEY_SYSTEM,
            pszDrvSignPath[]                     = REGSTR_PATH_DRIVERSIGN,
            pszNonDrvSignPath[]                  = REGSTR_PATH_NONDRIVERSIGN,
            pszDrvSignPolicyPath[]               = REGSTR_PATH_DRIVERSIGN_POLICY,
            pszNonDrvSignPolicyPath[]            = REGSTR_PATH_NONDRIVERSIGN_POLICY,
            pszDrvSignPolicyValue[]              = REGSTR_VAL_POLICY,
            pszDrvSignBehaviorOnFailedVerifyDS[] = REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY,
            pszDriverDate[]                      = REGSTR_VAL_DRIVERDATE,
            pszDriverDateData[]                  = REGSTR_VAL_DRIVERDATEDATA,
            pszDriverVersion[]                   = REGSTR_VAL_DRIVERVERSION,
            pszDevSecurity[]                     = REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR,
            pszDevType[]                         = REGSTR_VAL_DEVICE_TYPE,
            pszExclusive[]                       = REGSTR_VAL_DEVICE_EXCLUSIVE,
            pszCharacteristics[]                 = REGSTR_VAL_DEVICE_CHARACTERISTICS,
            pszUiNumberDescFormat[]              = REGSTR_VAL_UI_NUMBER_DESC_FORMAT,
            pszRemovalPolicyOverride[]           = REGSTR_VAL_REMOVAL_POLICY,
            pszReinstallPath[]                   = REGSTR_PATH_REINSTALL,
            pszReinstallDeviceInstanceIds[]      = REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS,
            pszReinstallDisplayName[]            = REGSTR_VAL_REINSTALL_DISPLAYNAME,
            pszReinstallString[]                 = REGSTR_VAL_REINSTALL_STRING;


//
// Other misc. global strings (defined in devinst.h):
//
CONST TCHAR pszInfWildcard[]              = DISTR_INF_WILDCARD,
            pszOemInfWildcard[]           = DISTR_OEMINF_WILDCARD,
            pszCiDefaultProc[]            = DISTR_CI_DEFAULTPROC,
            pszUniqueSubKey[]             = DISTR_UNIQUE_SUBKEY,
            pszOemInfGenerate[]           = DISTR_OEMINF_GENERATE,
            pszOemInfDefaultPath[]        = DISTR_OEMINF_DEFAULTPATH,
            pszDefaultService[]           = DISTR_DEFAULT_SERVICE,
            pszGuidNull[]                 = DISTR_GUID_NULL,
            pszEventLog[]                 = DISTR_EVENTLOG,
            pszGroupOrderListPath[]       = DISTR_GROUPORDERLIST_PATH,
            pszServiceGroupOrderPath[]    = DISTR_SERVICEGROUPORDER_PATH,
            pszOptions[]                  = DISTR_OPTIONS,
            pszOptionsText[]              = DISTR_OPTIONSTEXT,
            pszLanguagesSupported[]       = DISTR_LANGUAGESSUPPORTED,
            pszRunOnceExe[]               = DISTR_RUNONCE_EXE,
            pszGrpConv[]                  = DISTR_GRPCONV,
            pszGrpConvNoUi[]              = DISTR_GRPCONV_NOUI,
            pszDefaultSystemPartition[]   = DISTR_DEFAULT_SYSPART,
            pszBasicPropDefaultProc[]     = DISTR_BASICPROP_DEFAULTPROC,
            pszEnumPropDefaultProc[]      = DISTR_ENUMPROP_DEFAULTPROC,
            pszCoInstallerDefaultProc[]   = DISTR_CODEVICEINSTALL_DEFAULTPROC,
            pszDriverObjectPathPrefix[]   = DISTR_DRIVER_OBJECT_PATH_PREFIX,
            pszDriverSigningClasses[]     = DISTR_DRIVER_SIGNING_CLASSES,
            pszEmbeddedNTSecurity[]       = DISTR_PATH_EMBEDDED_NT_SECURITY,
            pszMinimizeFootprint[]        = DISTR_VAL_MINIMIZE_FOOTPRINT,
            pszDisableSCE[]               = DISTR_VAL_DISABLE_SCE;


//
// Define flag bitmask indicating which flags are controlled internally by the
// device installer routines, and thus are read-only to clients.
//
#define DI_FLAGS_READONLY    ( DI_DIDCOMPAT | DI_DIDCLASS | DI_MULTMFGS )

#define DI_FLAGSEX_READONLY  (  DI_FLAGSEX_DIDINFOLIST     \
                              | DI_FLAGSEX_DIDCOMPATINFO   \
                              | DI_FLAGSEX_IN_SYSTEM_SETUP \
                              | DI_FLAGSEX_CI_FAILED       \
                              | DI_FLAGSEX_RESERVED2       )
//
// (DI_FLAGSEX_RESERVED2 used to be DI_FLAGSEX_AUTOSELECTRANK0.  It's obsolete,
// but we didn't want to mark it as illegal because it would cause failures
// when the functionality wasn't that important anyway.  Instead, we just
// ignore this bit.)
//

#define DNF_FLAGS_READONLY   (  DNF_DUPDESC           \
                              | DNF_OLDDRIVER         \
                              | DNF_CLASS_DRIVER      \
                              | DNF_COMPATIBLE_DRIVER \
                              | DNF_INET_DRIVER       \
                              | DNF_INDEXED_DRIVER    \
                              | DNF_OLD_INET_DRIVER   \
                              | DNF_DUPPROVIDER       \
                              | DNF_INF_IS_SIGNED     \
                              | DNF_OEM_F6_INF        \
                              | DNF_DUPDRIVERVER      \
                              | DNF_AUTHENTICODE_SIGNED)

//
// Define flag bitmask indicating which flags are illegal.
//
#define DI_FLAGS_ILLEGAL    ( 0x00400000L )  // setupx DI_NOSYNCPROCESSING flag
#define DI_FLAGSEX_ILLEGAL  ( 0xC0004008L )  // all undefined/obsolete flags
#define DNF_FLAGS_ILLEGAL   ( 0xFFFC0010L )  // ""

#define NDW_INSTALLFLAG_ILLEGAL (~( NDW_INSTALLFLAG_DIDFACTDEFS        \
                                  | NDW_INSTALLFLAG_HARDWAREALLREADYIN \
                                  | NDW_INSTALLFLAG_NEEDRESTART        \
                                  | NDW_INSTALLFLAG_NEEDREBOOT         \
                                  | NDW_INSTALLFLAG_NEEDSHUTDOWN       \
                                  | NDW_INSTALLFLAG_EXPRESSINTRO       \
                                  | NDW_INSTALLFLAG_SKIPISDEVINSTALLED \
                                  | NDW_INSTALLFLAG_NODETECTEDDEVS     \
                                  | NDW_INSTALLFLAG_INSTALLSPECIFIC    \
                                  | NDW_INSTALLFLAG_SKIPCLASSLIST      \
                                  | NDW_INSTALLFLAG_CI_PICKED_OEM      \
                                  | NDW_INSTALLFLAG_PCMCIAMODE         \
                                  | NDW_INSTALLFLAG_PCMCIADEVICE       \
                                  | NDW_INSTALLFLAG_USERCANCEL         \
                                  | NDW_INSTALLFLAG_KNOWNCLASS         ))

#define DYNAWIZ_FLAG_ILLEGAL (~( DYNAWIZ_FLAG_PAGESADDED             \
                               | DYNAWIZ_FLAG_INSTALLDET_NEXT        \
                               | DYNAWIZ_FLAG_INSTALLDET_PREV        \
                               | DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT ))

#define NEWDEVICEWIZARD_FLAG_ILLEGAL (~(0)) // no flags are legal presently


//
// Declare data used in GUID->string conversion (from ole32\common\ccompapi.cxx).
//
static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const TCHAR szDigits[] = TEXT("0123456789ABCDEF");


PDEVICE_INFO_SET
AllocateDeviceInfoSet(
    VOID
    )
/*++

Routine Description:

    This routine allocates a device information set structure, zeroes it,
    and initializes the synchronization lock for it.

Arguments:

    none.

Return Value:

    If the function succeeds, the return value is a pointer to the new
    device information set.

    If the function fails, the return value is NULL.

--*/
{
    PDEVICE_INFO_SET p;

    if(p = MyMalloc(sizeof(DEVICE_INFO_SET))) {

        ZeroMemory(p, sizeof(DEVICE_INFO_SET));

        p->MachineName = -1;
        p->InstallParamBlock.DriverPath = -1;
        p->InstallParamBlock.CoInstallerCount = -1;

        //
        // If we're in GUI-mode setup on Windows NT, we'll automatically set
        // the DI_FLAGSEX_IN_SYSTEM_SETUP flag in the devinstall parameter
        // block for this devinfo set.
        //
        if(GuiSetupInProgress) {
            p->InstallParamBlock.FlagsEx |= DI_FLAGSEX_IN_SYSTEM_SETUP;
        }

        //
        // If we're in non-interactive mode, set the "be quiet" bits.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            p->InstallParamBlock.Flags   |= DI_QUIETINSTALL;
            p->InstallParamBlock.FlagsEx |= DI_FLAGSEX_NOUIONQUERYREMOVE;
        }

        //
        // Initialize our enumeration 'hints'
        //
        p->DeviceInfoEnumHintIndex = INVALID_ENUM_INDEX;
        p->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;


        if(p->StringTable = pStringTableInitialize(0)) {

            if (CreateLogContext(NULL, FALSE, &(p->InstallParamBlock.LogContext)) == NO_ERROR) {
                //
                // succeeded
                //
                if(InitializeSynchronizedAccess(&(p->Lock))) {
                    return p;
                }

                DeleteLogContext(p->InstallParamBlock.LogContext);
            }

            pStringTableDestroy(p->StringTable);
        }
        MyFree(p);
    }

    return NULL;
}


VOID
DestroyDeviceInfoElement(
    IN HDEVINFO         hDevInfo,
    IN PDEVICE_INFO_SET pDeviceInfoSet,
    IN PDEVINFO_ELEM    DeviceInfoElement
    )
/*++

Routine Description:

    This routine destroys the specified device information element, freeing
    all resources associated with it.
    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    hDevInfo - Supplies a handle to the device information set whose internal
        representation is given by pDeviceInfoSet.  This opaque handle is
        actually the same pointer as pDeviceInfoSet, but we want to keep this
        distinction clean, so that in the future we can change our implementation
        (e.g., hDevInfo might represent an offset in an array of DEVICE_INFO_SET
        elements).

    pDeviceInfoSet - Supplies a pointer to the device information set of which
        the devinfo element is a member.  This set contains the class driver list
        object list that must be used in destroying the class driver list.

    DeviceInfoElement - Supplies a pointer to the device information element
        to be destroyed.

Return Value:

    None.

--*/
{
    DWORD i;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode, NextDeviceInterfaceNode;
    CONFIGRET cr;

    MYASSERT(hDevInfo && (hDevInfo != INVALID_HANDLE_VALUE));

    //
    // Free resources contained in the install parameters block.  Do this
    // before anything else, because we'll be calling the class installer
    // with DIF_DESTROYPRIVATEDATA, and we want everything to be in a
    // consistent state when we do (plus, it may need to destroy private
    // data it's stored with individual driver nodes).
    //
    DestroyInstallParamBlock(hDevInfo,
                             pDeviceInfoSet,
                             DeviceInfoElement,
                             &(DeviceInfoElement->InstallParamBlock)
                            );

    //
    // Dereference the class driver list.
    //
    DereferenceClassDriverList(pDeviceInfoSet, DeviceInfoElement->ClassDriverHead);

    //
    // Destroy compatible driver list.
    //
    DestroyDriverNodes(DeviceInfoElement->CompatDriverHead, pDeviceInfoSet);

    //
    // If this is a non-registered device instance, then delete any registry
    // keys the caller may have created during the lifetime of this element.
    //
    if(DeviceInfoElement->DevInst && !(DeviceInfoElement->DiElemFlags & DIE_IS_REGISTERED)) {
        //
        // We don't support remote creation of devnodes, so this had better not
        // have an associated hMachine!
        //
        MYASSERT(!(pDeviceInfoSet->hMachine));

        pSetupDeleteDevRegKeys(DeviceInfoElement->DevInst,
                               DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGSPECIFIC,
                               (DWORD)-1,
                               DIREG_BOTH,
                               TRUE,
                               pDeviceInfoSet->hMachine         // must be NULL
                              );

        cr = CM_Uninstall_DevInst(DeviceInfoElement->DevInst, 0);
    }

    //
    // Free any device interface lists that may be associated with this devinfo element.
    //
    if(DeviceInfoElement->InterfaceClassList) {

        for(i = 0; i < DeviceInfoElement->InterfaceClassListSize; i++) {

            for(DeviceInterfaceNode = DeviceInfoElement->InterfaceClassList[i].DeviceInterfaceNode;
                DeviceInterfaceNode;
                DeviceInterfaceNode = NextDeviceInterfaceNode) {

                NextDeviceInterfaceNode = DeviceInterfaceNode->Next;
                MyFree(DeviceInterfaceNode);
            }
        }

        MyFree(DeviceInfoElement->InterfaceClassList);
    }

    //
    // Zero the signature field containing the address of the containing devinfo
    // set.  This will keep us thinking an SP_DEVINFO_DATA is still valid after
    // the underlying element has been deleted.
    //
    DeviceInfoElement->ContainingDeviceInfoSet = NULL;

    MyFree(DeviceInfoElement);
}


DWORD
DestroyDeviceInfoSet(
    IN HDEVINFO         hDevInfo,      OPTIONAL
    IN PDEVICE_INFO_SET pDeviceInfoSet
    )
/*++

Routine Description:

    This routine frees a device information set, and all resources
    used on its behalf.

Arguments:

    hDevInfo - Optionally, supplies a handle to the device information set
        whose internal representation is given by pDeviceInfoSet.  This
        opaque handle is actually the same pointer as pDeviceInfoSet, but
        we want to keep this distinction clean, so that in the future we
        can change our implementation (e.g., hDevInfo might represent an
        offset in an array of DEVICE_INFO_SET elements).

        This parameter will only be NULL if we're cleaning up half-way
        through the creation of a device information set.

    pDeviceInfoSet - supplies a pointer to the device information set
        to be freed.

Return Value:

    If successful, the return code is NO_ERROR, otherwise, it is an
    ERROR_* code.

--*/
{
    PDEVINFO_ELEM NextElem;
    PDRIVER_NODE DriverNode, NextNode;
    PMODULE_HANDLE_LIST_NODE NextModuleHandleNode;
    DWORD i;
    SPFUSIONINSTANCE spFusionInstance;

    //
    // We have to make sure that the wizard refcount is zero, and that we
    // haven't acquired the lock more than once (i.e., we're nested more than
    // one level deep in Di calls.  Also, make sure the devinfo set hasn't been
    // explicitly locked (e.g., across helper module calls).
    //
    if(pDeviceInfoSet->WizPageList ||
       (pDeviceInfoSet->LockRefCount > 1) ||
       (pDeviceInfoSet->DiSetFlags & DISET_IS_LOCKED)) {

        return ERROR_DEVINFO_LIST_LOCKED;
    }

    //
    // Additionally, make sure that there aren't any devinfo elements in this
    // set that are locked.
    //
    for(NextElem = pDeviceInfoSet->DeviceInfoHead;
        NextElem;
        NextElem = NextElem->Next)
    {
        if(NextElem->DiElemFlags & DIE_IS_LOCKED) {
            return ERROR_DEVINFO_DATA_LOCKED;
        }
    }

    //
    // Destroy all the device information elements in this set.  Make sure
    // that we maintain consistency while removing devinfo elements, because
    // we may be calling the class installer.  This means that the device
    // installer APIs still have to work, even while we're tearing down the
    // list.
    //
    while(pDeviceInfoSet->DeviceInfoHead) {

        NextElem = pDeviceInfoSet->DeviceInfoHead->Next;
        DestroyDeviceInfoElement(hDevInfo, pDeviceInfoSet, pDeviceInfoSet->DeviceInfoHead);

        MYASSERT(pDeviceInfoSet->DeviceInfoCount > 0);
        pDeviceInfoSet->DeviceInfoCount--;

        //
        // If this element was the currently selected device for this
        // set, then reset the device selection.
        //
        if(pDeviceInfoSet->SelectedDevInfoElem == pDeviceInfoSet->DeviceInfoHead) {
            pDeviceInfoSet->SelectedDevInfoElem = NULL;
        }

        pDeviceInfoSet->DeviceInfoHead = NextElem;
    }

    MYASSERT(pDeviceInfoSet->DeviceInfoCount == 0);
    pDeviceInfoSet->DeviceInfoTail = NULL;

    //
    // Free resources contained in the install parameters block.  Do this
    // before anything else, because we'll be calling the class installer
    // with DIF_DESTROYPRIVATEDATA, and we want everything to be in a
    // consistent state when we do (plus, it may need to destroy private
    // data it's stored with individual driver nodes).
    //
    DestroyInstallParamBlock(hDevInfo,
                             pDeviceInfoSet,
                             NULL,
                             &(pDeviceInfoSet->InstallParamBlock)
                            );

    //
    // Destroy class driver list.
    //
    if(pDeviceInfoSet->ClassDriverHead) {
        //
        // We've already destroyed all device information elements, so there should be
        // exactly one driver list object remaining--the one referenced by the global
        // class driver list.  Also, it's refcount should be 1.
        //
        MYASSERT(
            (pDeviceInfoSet->ClassDrvListObjectList) &&
            (!pDeviceInfoSet->ClassDrvListObjectList->Next) &&
            (pDeviceInfoSet->ClassDrvListObjectList->RefCount == 1) &&
            (pDeviceInfoSet->ClassDrvListObjectList->DriverListHead == pDeviceInfoSet->ClassDriverHead)
           );

        MyFree(pDeviceInfoSet->ClassDrvListObjectList);
        DestroyDriverNodes(pDeviceInfoSet->ClassDriverHead, pDeviceInfoSet);
    }

    //
    // Free the interface class GUID list (if there is one).
    //
    if(pDeviceInfoSet->GuidTable) {
        MyFree(pDeviceInfoSet->GuidTable);
    }

    //
    // Destroy the associated string table.
    //
    pStringTableDestroy(pDeviceInfoSet->StringTable);

    //
    // Destroy the lock (we have to do this after we've made all necessary calls
    // to the class installer, because after the lock is freed, the HDEVINFO set
    // is inaccessible).
    //
    DestroySynchronizedAccess(&(pDeviceInfoSet->Lock));

    //
    // If there are any module handles left to be freed, do that now.
    //
    for(; pDeviceInfoSet->ModulesToFree; pDeviceInfoSet->ModulesToFree = NextModuleHandleNode) {

        NextModuleHandleNode = pDeviceInfoSet->ModulesToFree->Next;

        for(i = 0; i < pDeviceInfoSet->ModulesToFree->ModuleCount; i++) {

            MYASSERT(pDeviceInfoSet->ModulesToFree->ModuleList[i].ModuleHandle);

            //
            // We're entering a fusion context, so we must guard this with SEH
            // because we don't want to get "stuck" there if we happen to hit
            // an exception...
            //
            spFusionEnterContext(pDeviceInfoSet->ModulesToFree->ModuleList[i].FusionContext,
                                 &spFusionInstance
                                );
            try {
                FreeLibrary(pDeviceInfoSet->ModulesToFree->ModuleList[i].ModuleHandle);
            } except(pSetupExceptionFilter(GetExceptionCode())) {
                pSetupExceptionHandler(GetExceptionCode(),
                                       ERROR_INVALID_PARAMETER,
                                       NULL
                                      );
            }
            spFusionLeaveContext(&spFusionInstance);
            spFusionKillContext(pDeviceInfoSet->ModulesToFree->ModuleList[i].FusionContext);
        }

        MyFree(pDeviceInfoSet->ModulesToFree);
    }

    //
    // If this is a remote HDEVINFO set, then disconnect from the remote machine.
    //
    if(pDeviceInfoSet->hMachine) {
        CM_Disconnect_Machine(pDeviceInfoSet->hMachine);
    }

    //
    // Now, destroy the container itself.
    //
    MyFree(pDeviceInfoSet);

    return NO_ERROR;
}


VOID
DestroyInstallParamBlock(
    IN HDEVINFO                hDevInfo,         OPTIONAL
    IN PDEVICE_INFO_SET        pDeviceInfoSet,
    IN PDEVINFO_ELEM           DevInfoElem,      OPTIONAL
    IN PDEVINSTALL_PARAM_BLOCK InstallParamBlock
    )
/*++

Routine Description:

    This routine frees any resources contained in the specified install
    parameter block.  THE BLOCK ITSELF IS NOT FREED!

Arguments:

    hDevInfo - Optionally, supplies a handle to the device information set
        containing the element whose parameter block is to be destroyed.

        If this parameter is not supplied, then we're cleaning up after
        failing part-way through a SetupDiCreateDeviceInfoList.

    pDeviceInfoSet - Supplies a pointer to the device information set of which
        the devinfo element is a member.

    DevInfoElem - Optionally, supplies the address of the device information
        element whose parameter block is to be destroyed.  If the parameter
        block being destroyed is associated with the set itself, then this
        parameter will be NULL.

    InstallParamBlock - Supplies the address of the install parameter
        block whose resources are to be freed.

Return Value:

    None.

--*/
{
    SP_DEVINFO_DATA DeviceInfoData;
    LONG i;

    if(InstallParamBlock->UserFileQ) {
        //
        // If there's a user-supplied file queue stored in this installation
        // parameter block, then decrement the refcount on it.  Make sure we
        // do this before calling the class installer with DIF_DESTROYPRIVATEDATA,
        // or else they won't be able to close the queue.
        //
        MYASSERT(((PSP_FILE_QUEUE)(InstallParamBlock->UserFileQ))->LockRefCount);

        ((PSP_FILE_QUEUE)(InstallParamBlock->UserFileQ))->LockRefCount--;
    }

    if(hDevInfo && (hDevInfo != INVALID_HANDLE_VALUE)) {
        //
        // Call the class installer/co-installers (if there are any) to let them
        // clean up any private data they may have.
        //
        if(DevInfoElem) {
            //
            // Generate an SP_DEVINFO_DATA structure from our device information
            // element (if we have one).
            //
            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                             DevInfoElem,
                                             &DeviceInfoData
                                            );
        }

        InvalidateHelperModules(hDevInfo,
                                (DevInfoElem ? &DeviceInfoData : NULL),
                                IHM_FREE_IMMEDIATELY
                               );
    }

    if(InstallParamBlock->ClassInstallHeader) {
        MyFree(InstallParamBlock->ClassInstallHeader);
    }

    //
    // Get rid of the log context sitting in here.
    //
    DeleteLogContext(InstallParamBlock->LogContext);
}


PDEVICE_INFO_SET
AccessDeviceInfoSet(
    IN HDEVINFO DeviceInfoSet
    )
/*++

Routine Description:

    This routine locks the specified device information set, and returns
    a pointer to the structure for its internal representation.  It also
    increments the lock refcount on this set, so that it can't be destroyed
    if the lock has been acquired multiple times.

    After access to the set is completed, the caller must call
    UnlockDeviceInfoSet with the pointer returned by this function.

Arguments:

    DeviceInfoSet - Supplies the pointer to the device information set
        to be accessed.

Return Value:

    If the function succeeds, the return value is a pointer to the
    device information set.

    If the function fails, the return value is NULL.

Remarks:

    If the method for accessing a device information set's internal
    representation via its handle changes (e.g., instead of a pointer, it's an
    index into a table), then RollbackDeviceInfoSet and CommitDeviceInfoSet
    must also be changed.  Also, we cast an HDEVINFO to a PDEVICE_INFO_SET
    when specifying the containing device information set in a call to
    pSetupOpenAndAddNewDevInfoElem in devinfo.c!SetupDiGetClassDevsEx (only
    when we're working with a cloned devinfo set).

--*/
{
    PDEVICE_INFO_SET p;

    try {
        p = (PDEVICE_INFO_SET)DeviceInfoSet;
        if(LockDeviceInfoSet(p)) {
            p->LockRefCount++;
        } else {
            p = NULL;
        }
    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        p = NULL;
    }

    return p;
}


PDEVICE_INFO_SET
CloneDeviceInfoSet(
    IN HDEVINFO hDevInfo
    )
/*++

Routine Description:

    This routine locks the specified device information set, then returns a
    clone of the structure used for its internal representation.  Device
    information elements or device interface nodes may subsequently be added to
    this cloned devinfo set, and the results can be committed via
    CommitDeviceInfoSet.  If the changes must be backed out (e.g., because an
    error was encountered while adding the additional elements to the set), the
    routine RollbackDeviceInfoSet must be called.

    After access to the set is completed (and the changes have either been
    committed or rolled back per the discussion above), the caller must call
    UnlockDeviceInfoSet with the pointer returned by CommitDeviceInfoSet or
    RollbackDeviceInfoSet.

Arguments:

    hDevInfo - Supplies the handle of the device information set to be cloned.

Return Value:

    If the function succeeds, the return value is a pointer to the
    device information set.

    If the function fails, the return value is NULL.

Remarks:

    The device information set handle specified to this routine MUST NOT BE
    USED until the changes are either committed or rolled back.  Also, the
    PDEVICE_INFO_SET returned by this routine must not be treated like an
    HDEVINFO handle--it is not.

--*/
{
    PDEVICE_INFO_SET p = NULL, NewDevInfoSet = NULL;
    BOOL b = FALSE;
    PVOID StringTable = NULL;

    try {

        if(!(p = AccessDeviceInfoSet(hDevInfo))) {
            leave;
        }

        //
        // OK, we successfully locked the device information set.  Now, make a
        // copy of the internal structure to return to the caller.
        //
        NewDevInfoSet = MyMalloc(sizeof(DEVICE_INFO_SET));
        if(!NewDevInfoSet) {
            leave;
        }

        CopyMemory(NewDevInfoSet, p, sizeof(DEVICE_INFO_SET));

        //
        // Duplicate the string table contained in this device information set.
        //
        StringTable = pStringTableDuplicate(p->StringTable);
        if(!StringTable) {
            leave;
        }

        NewDevInfoSet->StringTable = StringTable;

        //
        // We've successfully cloned the device information set!
        //
        b = TRUE;

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    if(!b) {
        //
        // We failed to make a copy of the device information set--free any
        // memory we may have allocated, and unlock the original devinfo set
        // before returning failure.
        //
        if(NewDevInfoSet) {
            MyFree(NewDevInfoSet);
        }
        if(StringTable) {
            pStringTableDestroy(StringTable);
        }
        if(p) {
            UnlockDeviceInfoSet(p);
        }
        return NULL;
    }

    return NewDevInfoSet;
}


PDEVICE_INFO_SET
RollbackDeviceInfoSet(
    IN HDEVINFO hDevInfo,
    IN PDEVICE_INFO_SET ClonedDeviceInfoSet
    )
/*++

Routine Description:

    This routine rolls back the specified hDevInfo to a known good state that
    was saved when the set was cloned via a prior call to CloneDeviceInfoSet.

Arguments:

    hDevInfo - Supplies the handle of the device information set to be rolled
        back.

    ClonedDeviceInfoSet - Supplies the address of the internal structure
        representing the hDevInfo set's cloned (and potentially, modified)
        information.  Upon successful return, this structure will be freed.

Return Value:

    If the function succeeds, the return value is a pointer to the rolled-back
    device information set structure.

    If the function fails, the return value is NULL.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem, NextDevInfoElem;
    DWORD i, DeviceInterfaceCount;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode, NextDeviceInterfaceNode;

    //
    // Retrieve a pointer to the hDevInfo set's internal representation (we
    // don't need to acquire the lock, because we did that when we originally
    // cloned the structure).
    //
    // NOTE:  If the method for accessing an HDEVINFO set's internal
    // representation ever changes (i.e., the AccessDeviceInfoSet routine),
    // then this code will need to be modified accordingly.
    //
    pDeviceInfoSet = (PDEVICE_INFO_SET)hDevInfo;

    //
    // Make sure no additional locks have been acquired against the cloned
    // DEVICE_INFO_SET.
    //
    MYASSERT(pDeviceInfoSet->LockRefCount == ClonedDeviceInfoSet->LockRefCount);

    //
    // Do some validation to see whether it looks like only new device
    // information elements were added onto the end of our existing list (i.e.,
    // it's invalid to add new elements within the existing list, or to remove
    // elements from the existing list).
    //
#if ASSERTS_ON
    if(pDeviceInfoSet->DeviceInfoHead) {

        DWORD DevInfoElemCount = 1;

        MYASSERT(pDeviceInfoSet->DeviceInfoHead == ClonedDeviceInfoSet->DeviceInfoHead);
        for(DevInfoElem = ClonedDeviceInfoSet->DeviceInfoHead;
            DevInfoElem->Next;
            DevInfoElem = DevInfoElem->Next, DevInfoElemCount++) {

            if(DevInfoElem == pDeviceInfoSet->DeviceInfoTail) {
                break;
            }
        }
        //
        // Did we find the original tail?
        //
        MYASSERT(DevInfoElem == pDeviceInfoSet->DeviceInfoTail);
        //
        // And did we traverse the same number of nodes in getting there that
        // was in the original list?
        //
        MYASSERT(DevInfoElemCount == pDeviceInfoSet->DeviceInfoCount);
    }
#endif

    //
    // Destroy any newly-added members of the device information element list.
    //
    // If our original set had a tail, then we want to prune any elements after
    // that.  If our original set had no tail, then it had no head either
    // (i.e., it was empty).  In that case, we want to prune every element in
    // the cloned list.
    //
    for(DevInfoElem = (pDeviceInfoSet->DeviceInfoTail
                        ? pDeviceInfoSet->DeviceInfoTail->Next
                        : ClonedDeviceInfoSet->DeviceInfoHead);
        DevInfoElem;
        DevInfoElem = NextDevInfoElem) {

        NextDevInfoElem = DevInfoElem->Next;

        MYASSERT(!DevInfoElem->ClassDriverCount);
        MYASSERT(!DevInfoElem->CompatDriverCount);

        //
        // Free any device interface lists that may be associated with this
        // devinfo element.
        //
        if(DevInfoElem->InterfaceClassList) {

            for(i = 0; i < DevInfoElem->InterfaceClassListSize; i++) {

                for(DeviceInterfaceNode = DevInfoElem->InterfaceClassList[i].DeviceInterfaceNode;
                    DeviceInterfaceNode;
                    DeviceInterfaceNode = NextDeviceInterfaceNode) {

                    NextDeviceInterfaceNode = DeviceInterfaceNode->Next;
                    MyFree(DeviceInterfaceNode);
                }
            }

            MyFree(DevInfoElem->InterfaceClassList);
        }

        MyFree(DevInfoElem);
    }

    if(pDeviceInfoSet->DeviceInfoTail) {
        pDeviceInfoSet->DeviceInfoTail->Next = NULL;
    }

    //
    // At this point, we've trimmed our device information element list back to
    // what it was prior to the cloning of the device information set.  However,
    // we may have added new device interface nodes onto the interface class
    // lists of existing devinfo elements.  Go and truncate any such nodes.
    //
    for(DevInfoElem = pDeviceInfoSet->DeviceInfoHead;
        DevInfoElem;
        DevInfoElem = DevInfoElem->Next) {

        if(DevInfoElem->InterfaceClassList) {

            for(i = 0; i < DevInfoElem->InterfaceClassListSize; i++) {

                if(DevInfoElem->InterfaceClassList[i].DeviceInterfaceTruncateNode) {
                    //
                    // One or more device interface nodes were added to this
                    // list.  Find the tail of the list as it existed prior to
                    // cloning, and truncate from there.
                    //
                    DeviceInterfaceNode = NULL;
                    DeviceInterfaceCount = 0;
                    for(NextDeviceInterfaceNode = DevInfoElem->InterfaceClassList[i].DeviceInterfaceNode;
                        NextDeviceInterfaceNode;
                        DeviceInterfaceNode = NextDeviceInterfaceNode, NextDeviceInterfaceNode = NextDeviceInterfaceNode->Next) {

                        if(NextDeviceInterfaceNode == DevInfoElem->InterfaceClassList[i].DeviceInterfaceTruncateNode) {
                            break;
                        }

                        //
                        // We haven't encountered the truncate point yet--
                        // increment the count of device interface nodes we've
                        // traversed so far.
                        //
                        DeviceInterfaceCount++;
                    }

                    //
                    // We'd better have found the node to truncate in our list!
                    //
                    MYASSERT(NextDeviceInterfaceNode);

                    //
                    // Truncate the list, and destroy all newly-added device
                    // interface nodes.
                    //
                    if(DeviceInterfaceNode) {
                        DeviceInterfaceNode->Next = NULL;
                    } else {
                        DevInfoElem->InterfaceClassList[i].DeviceInterfaceNode = NULL;
                    }
                    DevInfoElem->InterfaceClassList[i].DeviceInterfaceCount = DeviceInterfaceCount;

                    for(DeviceInterfaceNode = NextDeviceInterfaceNode;
                        DeviceInterfaceNode;
                        DeviceInterfaceNode = NextDeviceInterfaceNode) {

                        NextDeviceInterfaceNode = DeviceInterfaceNode->Next;
                        MyFree(DeviceInterfaceNode);
                    }

                    //
                    // Reset the truncate node pointer.
                    //
                    DevInfoElem->InterfaceClassList[i].DeviceInterfaceTruncateNode = NULL;
                }
            }
        }
    }

    //
    // OK, our device information element list and device interface node lists
    // are exactly as they were before the cloning took place.  However, it's
    // possible that we allocated (or reallocated) a new buffer for our
    // GUID table, so we need to update that GUID table pointer and size in our
    // original device information set structure.
    //
    pDeviceInfoSet->GuidTable     = ClonedDeviceInfoSet->GuidTable;
    pDeviceInfoSet->GuidTableSize = ClonedDeviceInfoSet->GuidTableSize;

    //
    // The device information set has been successfully rolled back.  Free the
    // memory associated with the clone.
    //
    pStringTableDestroy(ClonedDeviceInfoSet->StringTable);
    MyFree(ClonedDeviceInfoSet);

    //
    // Return the original (rolled-back) device information set structure to
    // the caller.
    //
    return pDeviceInfoSet;
}


PDEVICE_INFO_SET
CommitDeviceInfoSet(
    IN HDEVINFO hDevInfo,
    IN PDEVICE_INFO_SET ClonedDeviceInfoSet
    )
/*++

Routine Description:

    This routine commits the changes that have been made to a cloned device
    information set.  The clone was generated via a prior call to
    CloneDeviceInfoSet.

Arguments:

    hDevInfo - Supplies the handle of the device information set whose changes
        are to be committed.

    ClonedDeviceInfoSet - Supplies the address of the internal structure
        representing the hDevInfo set's cloned (and potentially, modified)
        information.  Upon successful return, this structure will be freed.

Return Value:

    If the function succeeds, the return value is a pointer to the committed
    device information set structure.

    If the function fails, the return value is NULL.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    DWORD i;

    //
    // Retrieve a pointer to the hDevInfo set's internal representation (we
    // don't need to acquire the lock, because we did that when we cloned the
    // originally cloned the structure).
    //
    // NOTE:  If the method for accessing an HDEVINFO set's internal
    // representation ever changes (i.e., the AccessDeviceInfoSet routine),
    // then this code will need to be modified accordingly.
    //
    pDeviceInfoSet = (PDEVICE_INFO_SET)hDevInfo;

    //
    // Make sure no additional locks have been acquired against the cloned
    // DEVICE_INFO_SET.
    //
    MYASSERT(pDeviceInfoSet->LockRefCount == ClonedDeviceInfoSet->LockRefCount);

    //
    // Free the old string table.
    //
    pStringTableDestroy(pDeviceInfoSet->StringTable);

    //
    // Now copy the cloned device information set structure into the 'real' one.
    //
    CopyMemory(pDeviceInfoSet, ClonedDeviceInfoSet, sizeof(DEVICE_INFO_SET));

    //
    // Now we have to go through each device information element's interface
    // class list and reset the DeviceInterfaceTruncateNode fields to indicate
    // that all the new device interface nodes that were added have been
    // committed.
    //
    for(DevInfoElem = pDeviceInfoSet->DeviceInfoHead;
        DevInfoElem;
        DevInfoElem = DevInfoElem->Next) {

        for(i = 0; i < DevInfoElem->InterfaceClassListSize; i++) {
            DevInfoElem->InterfaceClassList[i].DeviceInterfaceTruncateNode = NULL;
        }
    }

    //
    // Free the cloned device information set structure.
    //
    MyFree(ClonedDeviceInfoSet);

    //
    // We've successfully committed the changes into the original device
    // information set structure--return that structure.
    //
    return pDeviceInfoSet;
}


PDEVINFO_ELEM
FindDevInfoByDevInst(
    IN  PDEVICE_INFO_SET  DeviceInfoSet,
    IN  DEVINST           DevInst,
    OUT PDEVINFO_ELEM    *PrevDevInfoElem OPTIONAL
    )
/*++

Routine Description:

    This routine searches through all (registered) elements of a
    device information set, looking for one that corresponds to the
    specified device instance handle.  If a match is found, a pointer
    to the device information element is returned.

Arguments:

    DeviceInfoSet - Specifies the set to be searched.

    DevInst - Specifies the device instance handle to search for.

    PrevDevInfoElem - Optionaly, supplies the address of the variable that
        receives a pointer to the device information element immediately
        preceding the matching element.  If the element was found at the
        front of the list, then this variable will be set to NULL.

Return Value:

    If a device information element is found, the return value is a
    pointer to that element, otherwise, the return value is NULL.

--*/
{
    PDEVINFO_ELEM cur, prev;

    for(cur = DeviceInfoSet->DeviceInfoHead, prev = NULL;
        cur;
        prev = cur, cur = cur->Next)
    {
        if((cur->DiElemFlags & DIE_IS_REGISTERED) && (cur->DevInst == DevInst)) {

            if(PrevDevInfoElem) {
                *PrevDevInfoElem = prev;
            }
            return cur;
        }
    }

    return NULL;
}


BOOL
DevInfoDataFromDeviceInfoElement(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PDEVINFO_ELEM    DevInfoElem,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine fills in a SP_DEVINFO_DATA structure based on the
    information in the supplied DEVINFO_ELEM structure.

    Note:  The supplied DeviceInfoData structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set
        containing the specified element.

    DevInfoElem - Supplies a pointer to the DEVINFO_ELEM structure
        containing information to be used in filling in the
        SP_DEVINFO_DATA buffer.

    DeviceInfoData - Supplies a pointer to the buffer that will
        receive the filled-in SP_DEVINFO_DATA structure

Return Value:

    If the function succeeds, the return value is TRUE, otherwise, it
    is FALSE.

--*/
{
    if(DeviceInfoData->cbSize != sizeof(SP_DEVINFO_DATA)) {
        return FALSE;
    }

    ZeroMemory(DeviceInfoData, sizeof(SP_DEVINFO_DATA));
    DeviceInfoData->cbSize = sizeof(SP_DEVINFO_DATA);

    CopyMemory(&(DeviceInfoData->ClassGuid),
               &(DevInfoElem->ClassGuid),
               sizeof(GUID)
              );

    DeviceInfoData->DevInst = DevInfoElem->DevInst;

    //
    // The 'Reserved' field actually contains a pointer to the
    // corresponding device information element.
    //
    DeviceInfoData->Reserved = (ULONG_PTR)DevInfoElem;

    return TRUE;
}


PDEVINFO_ELEM
FindAssociatedDevInfoElem(
    IN  PDEVICE_INFO_SET  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA  DeviceInfoData,
    OUT PDEVINFO_ELEM    *PreviousElement OPTIONAL
    )
/*++

Routine Description:

    This routine returns the devinfo element for the specified
    SP_DEVINFO_DATA, or NULL if no devinfo element exists.

Arguments:

    DeviceInfoSet - Specifies the set to be searched.

    DeviceInfoData - Supplies a pointer to a device information data
        buffer specifying the device information element to retrieve.

    PreviousElement - Optionally, supplies the address of a
        DEVINFO_ELEM pointer that receives the element that precedes
        the specified element in the linked list.  If the returned
        element is located at the front of the list, then this value
        will be set to NULL.  If the element is not found, the value of
        PreviousElement upon return is undefined.

Return Value:

    If a device information element is found, the return value is a
    pointer to that element, otherwise, the return value is NULL.

--*/
{
    PDEVINFO_ELEM DevInfoElem, CurElem, PrevElem;
    PDEVINFO_ELEM ActualDevInfoElem = NULL;

    try {
        if((DeviceInfoData->cbSize != sizeof(SP_DEVINFO_DATA)) ||
           !(DevInfoElem = (PDEVINFO_ELEM)DeviceInfoData->Reserved)) {
            leave;
        }

        if(PreviousElement) {
            //
            // The caller requested that the preceding element be returned
            // (probably because the element is about to be deleted).  Since
            // this is a singly-linked list, we'll search through the list
            // until we find the desired element.
            //
            for(CurElem = DeviceInfoSet->DeviceInfoHead, PrevElem = NULL;
                CurElem;
                PrevElem = CurElem, CurElem = CurElem->Next) {

                if(CurElem == DevInfoElem) {
                    //
                    // We found the element in our set.
                    //
                    *PreviousElement = PrevElem;
                    ActualDevInfoElem = CurElem;
                    leave;
                }
            }

        } else {
            //
            // The caller doesn't care what the preceding element is, so we
            // can go right to the element, and validate it by ensuring that
            // the ContainingDeviceInfoSet field at the location pointed to
            // by DevInfoElem matches the devinfo set where this guy is supposed
            // to exist.
            //
            if(DevInfoElem->ContainingDeviceInfoSet == DeviceInfoSet) {
                ActualDevInfoElem = DevInfoElem;
                leave;
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        ActualDevInfoElem = NULL;
    }

    return ActualDevInfoElem;
}


BOOL
DrvInfoDataFromDriverNode(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PDRIVER_NODE     DriverNode,
    IN  DWORD            DriverType,
    OUT PSP_DRVINFO_DATA DriverInfoData
    )
/*++

Routine Description:

    This routine fills in a SP_DRVINFO_DATA structure based on the
    information in the supplied DRIVER_NODE structure.

    Note:  The supplied DriverInfoData structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set
        in which the driver node is located.

    DriverNode - Supplies a pointer to the DRIVER_NODE structure
        containing information to be used in filling in the
        SP_DRVNFO_DATA buffer.

    DriverType - Specifies what type of driver this is.  This value
        may be either SPDIT_CLASSDRIVER or SPDIT_COMPATDRIVER.

    DriverInfoData - Supplies a pointer to the buffer that will
        receive the filled-in SP_DRVINFO_DATA structure

Return Value:

    If the function succeeds, the return value is TRUE, otherwise, it
    is FALSE.

--*/
{
    PTSTR StringPtr;
    DWORD DriverInfoDataSize;

    if((DriverInfoData->cbSize != sizeof(SP_DRVINFO_DATA)) &&
       (DriverInfoData->cbSize != sizeof(SP_DRVINFO_DATA_V1))) {
        return FALSE;
    }

    DriverInfoDataSize = DriverInfoData->cbSize;

    ZeroMemory(DriverInfoData, DriverInfoDataSize);
    DriverInfoData->cbSize = DriverInfoDataSize;

    DriverInfoData->DriverType = DriverType;

    StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                         DriverNode->DevDescriptionDisplayName
                                         );

    if (!MYVERIFY(SUCCEEDED(StringCchCopy(DriverInfoData->Description,
                                          SIZECHARS(DriverInfoData->Description),
                                          StringPtr)))) {
        return FALSE;
    }

    StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                         DriverNode->MfgDisplayName
                                         );

    if (!MYVERIFY(SUCCEEDED(StringCchCopy(DriverInfoData->MfgName,
                                          SIZECHARS(DriverInfoData->MfgName),
                                          StringPtr)))) {
        return FALSE;
    }


    if(DriverNode->ProviderDisplayName != -1) {

        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->ProviderDisplayName
                                             );

        if (!MYVERIFY(SUCCEEDED(StringCchCopy(DriverInfoData->ProviderName,
                                              SIZECHARS(DriverInfoData->ProviderName),
                                              StringPtr)))) {
            return FALSE;
        }
    }

    //
    // The 'Reserved' field actually contains a pointer to the
    // corresponding driver node.
    //
    DriverInfoData->Reserved = (ULONG_PTR)DriverNode;

    //
    //new NT 5 fields
    //
    if(DriverInfoDataSize == sizeof(SP_DRVINFO_DATA)) {
        DriverInfoData->DriverDate = DriverNode->DriverDate;
        DriverInfoData->DriverVersion = DriverNode->DriverVersion;
    }

    return TRUE;
}


PDRIVER_NODE
FindAssociatedDriverNode(
    IN  PDRIVER_NODE      DriverListHead,
    IN  PSP_DRVINFO_DATA  DriverInfoData,
    OUT PDRIVER_NODE     *PreviousNode    OPTIONAL
    )
/*++

Routine Description:

    This routine searches through all driver nodes in a driver node
    list, looking for one that corresponds to the specified driver
    information structure.  If a match is found, a pointer to the
    driver node is returned.

Arguments:

    DriverListHead - Supplies a pointer to the head of linked list
        of driver nodes to be searched.

    DriverInfoData - Supplies a pointer to a driver information buffer
        specifying the driver node to retrieve.

    PreviousNode - Optionally, supplies the address of a DRIVER_NODE
        pointer that receives the node that precedes the specified
        node in the linked list.  If the returned node is located at
        the front of the list, then this value will be set to NULL.

Return Value:

    If a driver node is found, the return value is a pointer to that
    node, otherwise, the return value is NULL.

--*/
{
    PDRIVER_NODE DriverNode, CurNode, PrevNode;

    if(((DriverInfoData->cbSize != sizeof(SP_DRVINFO_DATA)) &&
        (DriverInfoData->cbSize != sizeof(SP_DRVINFO_DATA_V1))) ||
       !(DriverNode = (PDRIVER_NODE)DriverInfoData->Reserved)) {

        return NULL;
    }

    for(CurNode = DriverListHead, PrevNode = NULL;
        CurNode;
        PrevNode = CurNode, CurNode = CurNode->Next) {

        if(CurNode == DriverNode) {
            //
            // We found the driver node in our list.
            //
            if(PreviousNode) {
                *PreviousNode = PrevNode;
            }
            return CurNode;
        }
    }

    return NULL;
}


PDRIVER_NODE
SearchForDriverNode(
    IN  PVOID             StringTable,
    IN  PDRIVER_NODE      DriverListHead,
    IN  PSP_DRVINFO_DATA  DriverInfoData,
    OUT PDRIVER_NODE     *PreviousNode    OPTIONAL
    )
/*++

Routine Description:

    This routine searches through all driver nodes in a driver node
    list, looking for one that matches the fields in the specified
    driver information structure (the 'Reserved' field is ignored).
    If a match is found, a pointer to the driver node is returned.

Arguments:

    StringTable - Supplies the string table that should be used in
        retrieving string IDs for driver look-up.

    DriverListHead - Supplies a pointer to the head of linked list
        of driver nodes to be searched.

    DriverInfoData - Supplies a pointer to a driver information buffer
        specifying the driver parameters we're looking for.

    PreviousNode - Optionally, supplies the address of a DRIVER_NODE
        pointer that receives the node that precedes the specified
        node in the linked list.  If the returned node is located at
        the front of the list, then this value will be set to NULL.

Return Value:

    If a driver node is found, the return value is a pointer to that
    node, otherwise, the return value is NULL.

--*/
{
    PDRIVER_NODE CurNode, PrevNode;
    LONG DevDescription, MfgName, ProviderName;
    TCHAR TempString[LINE_LEN];
    DWORD TempStringLength;
    BOOL  Match;
    HRESULT hr;

    MYASSERT((DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) ||
             (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1)));

    //
    // Retrieve the string IDs for the 3 driver parameters we'll be
    // matching against.
    //
    hr = StringCchCopy(TempString,
                       SIZECHARS(TempString),
                       DriverInfoData->Description
                      );
    if(FAILED(hr)) {
        return NULL;
    }

    if((DevDescription = pStringTableLookUpString(
                             StringTable,
                             TempString,
                             &TempStringLength,
                             NULL,
                             NULL,
                             STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                             NULL,0)) == -1) {
        return NULL;
    }

    hr = StringCchCopy(TempString,
                       SIZECHARS(TempString),
                       DriverInfoData->MfgName
                      );
    if(FAILED(hr)) {
        return NULL;
    }

    if((MfgName = pStringTableLookUpString(
                             StringTable,
                             TempString,
                             &TempStringLength,
                             NULL,
                             NULL,
                             STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                             NULL,0)) == -1) {

        return NULL;
    }

    //
    // ProviderName may be empty...
    //
    if(*(DriverInfoData->ProviderName)) {

        hr = StringCchCopy(TempString,
                           SIZECHARS(TempString),
                           DriverInfoData->ProviderName
                          );
        if(FAILED(hr)) {
            return NULL;
        }

        if((ProviderName = pStringTableLookUpString(
                                 StringTable,
                                 TempString,
                                 &TempStringLength,
                                 NULL,
                                 NULL,
                                 STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                 NULL,0)) == -1) {

            return NULL;
        }

    } else {
        ProviderName = -1;
    }

    for(CurNode = DriverListHead, PrevNode = NULL;
        CurNode;
        PrevNode = CurNode, CurNode = CurNode->Next)
    {
        //
        // Check first on DevDescription (least likely to match), then on
        // MfgName, and finally on ProviderName. On NT 5 and later we will also
        // check the DriverDate and DriverVersion.
        //
        if(CurNode->DevDescription == DevDescription) {

            if(CurNode->MfgName == MfgName) {

                if(CurNode->ProviderName == ProviderName) {

                    //
                    // On NT 5 and later, also compare the DriverDate and DriverVersion
                    //
                    if(DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) {
                        //
                        // Assume that we have a match
                        //
                        Match = TRUE;

                        //
                        // If the DriverDate passed in is not 0 then make sure
                        // it matches
                        //
                        if((DriverInfoData->DriverDate.dwLowDateTime != 0) ||
                           (DriverInfoData->DriverDate.dwHighDateTime != 0)) {

                            if((CurNode->DriverDate.dwLowDateTime != DriverInfoData->DriverDate.dwLowDateTime) ||
                               (CurNode->DriverDate.dwHighDateTime != DriverInfoData->DriverDate.dwHighDateTime)) {

                                Match = FALSE;
                            }
                        }

                        //
                        // If the DriverVersion passed in is not 0 then make
                        // sure it matches
                        //
                        else if(DriverInfoData->DriverVersion != 0) {

                            if(CurNode->DriverVersion != DriverInfoData->DriverVersion) {
                                Match = FALSE;
                            }
                        }

                        if(Match) {
                            //
                            // We found the driver node in our list.
                            //
                            if(PreviousNode) {
                                *PreviousNode = PrevNode;
                            }
                            return CurNode;
                        }

                    } else {
                        //
                        // We found the driver node in our list.
                        //
                        if(PreviousNode) {
                            *PreviousNode = PrevNode;
                        }
                        return CurNode;
                    }
                }
            }
        }
    }

    return NULL;
}


DWORD
DrvInfoDetailsFromDriverNode(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDRIVER_NODE            DriverNode,
    OUT PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData, OPTIONAL
    IN  DWORD                   BufferSize,
    OUT PDWORD                  RequiredSize          OPTIONAL
    )
/*++

Routine Description:

    This routine fills in a SP_DRVINFO_DETAIL_DATA structure based on the
    information in the supplied DRIVER_NODE structure.

    If the buffer is supplied, and is valid, this routine is guaranteed to
    fill in all statically-sized fields, and as many IDs as will fit in the
    variable-length multi-sz buffer.

    Note:  If supplied, the DriverInfoDetailData structure must have its
    cbSize field filled in correctly, or the call will fail. Here correctly
    means sizeof(SP_DRVINFO_DETAIL_DATA), which we use as a signature.
    This is entirely separate from BufferSize. See below.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set
        in which the driver node is located.

    DriverNode - Supplies a pointer to the DRIVER_NODE structure
        containing information to be used in filling in the
        SP_DRVNFO_DETAIL_DATA buffer.

    DriverInfoDetailData - Optionally, supplies a pointer to the buffer
        that will receive the filled-in SP_DRVINFO_DETAIL_DATA structure.
        If this buffer is not supplied, then the caller is only interested
        in what the RequiredSize for the buffer is.

    BufferSize - Supplies size of the DriverInfoDetailData buffer, in
        bytes.  If DriverInfoDetailData is not specified, then this
        value must be zero. This value must be at least the size
        of the fixed part of the structure (ie,
        offsetof(SP_DRVINFO_DETAIL_DATA,HardwareID)) plus sizeof(TCHAR),
        which gives us enough room to store the fixed part plus
        a terminating nul to guarantee we return at least a valid
        empty multi_sz.

    RequiredSize - Optionally, supplies the address of a variable that
        receives the number of bytes required to store the data. Note that
        depending on structure alignment and the data itself, this may
        actually be *smaller* than sizeof(SP_DRVINFO_DETAIL_DATA).

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    PTSTR StringPtr, BufferPtr;
    DWORD IdListLen, CompatIdListLen, StringLen, TotalLen, i;
    DWORD Err = ERROR_INSUFFICIENT_BUFFER;

    #define FIXEDPARTLEN offsetof(SP_DRVINFO_DETAIL_DATA,HardwareID)

    if(DriverInfoDetailData) {
        //
        // Check validity of the DriverInfoDetailData buffer on the way in,
        // and make sure we have enough room for the fixed part
        // of the structure plus the extra nul that will terminate the
        // multi_sz.
        //
        if((DriverInfoDetailData->cbSize != sizeof(SP_DRVINFO_DETAIL_DATA)) ||
           (BufferSize < (FIXEDPARTLEN + sizeof(TCHAR)))) {

            return ERROR_INVALID_USER_BUFFER;
        }
        //
        // The buffer is large enough to contain at least the fixed-length part
        // of the structure (plus an empty multi-sz list).
        //
        Err = NO_ERROR;

    } else if(BufferSize) {
        return ERROR_INVALID_USER_BUFFER;
    }

    if(DriverInfoDetailData) {

        ZeroMemory(DriverInfoDetailData, FIXEDPARTLEN + sizeof(TCHAR));
        DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

        DriverInfoDetailData->InfDate = DriverNode->InfDate;

        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->InfSectionName
                                             );

        if (!MYVERIFY(SUCCEEDED(StringCchCopy(DriverInfoDetailData->SectionName,
                                              SIZECHARS(DriverInfoDetailData->SectionName),
                                              StringPtr)))) {
            return ERROR_INVALID_DATA;
        }

        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->InfFileName
                                             );

        if (!MYVERIFY(SUCCEEDED(StringCchCopy(DriverInfoDetailData->InfFileName,
                                              SIZECHARS(DriverInfoDetailData->InfFileName),
                                              StringPtr)))) {
            return ERROR_INVALID_DATA;
        }

        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->DrvDescription
                                             );

        if (!MYVERIFY(SUCCEEDED(StringCchCopy(DriverInfoDetailData->DrvDescription,
                                              SIZECHARS(DriverInfoDetailData->DrvDescription),
                                              StringPtr)))) {
            return ERROR_INVALID_DATA;
        }

        //
        // Initialize the multi_sz to be empty.
        //
        DriverInfoDetailData->HardwareID[0] = 0;

        //
        // The 'Reserved' field actually contains a pointer to the
        // corresponding driver node.
        //
        DriverInfoDetailData->Reserved = (ULONG_PTR)DriverNode;
    }

    //
    // Now, build the multi-sz buffer containing the hardware and compatible
    // IDs.
    //
    if(DriverNode->HardwareId == -1) {
        //
        // If there's no HardwareId, then we know there are no compatible IDs,
        // so we can return right now.
        //
        if(RequiredSize) {
            *RequiredSize = FIXEDPARTLEN + sizeof(TCHAR);
        }
        return Err;
    }

    if(DriverInfoDetailData) {
        BufferPtr = DriverInfoDetailData->HardwareID;
        IdListLen = (BufferSize - FIXEDPARTLEN) / sizeof(TCHAR);
    } else {
        IdListLen = 0;
    }

    //
    // Retrieve the HardwareId.
    //
    StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                         DriverNode->HardwareId
                                        );

    TotalLen = StringLen = lstrlen(StringPtr) + 1; // include nul terminator

    if(StringLen < IdListLen) {
        MYASSERT(Err == NO_ERROR);
        CopyMemory(BufferPtr,
                   StringPtr,
                   StringLen * sizeof(TCHAR)
                  );
        BufferPtr += StringLen;
        IdListLen -= StringLen;
        DriverInfoDetailData->CompatIDsOffset = StringLen;
    } else {
        if(RequiredSize) {
            //
            // Since the caller requested the required size, we can't just
            // return here.  Set the error, so we'll know not to bother trying
            // to fill the buffer.
            //
            Err = ERROR_INSUFFICIENT_BUFFER;
        } else {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    //
    // Remember the size of the buffer left over for CompatibleIDs.
    //
    CompatIdListLen = IdListLen;

    //
    // Now retrieve the CompatibleIDs.
    //
    for(i = 0; i < DriverNode->NumCompatIds; i++) {

        MYASSERT(DriverNode->CompatIdList[i] != -1);

        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DriverNode->CompatIdList[i]
                                            );
        StringLen = lstrlen(StringPtr) + 1;

        if(Err == NO_ERROR) {

            if(StringLen < IdListLen) {
                CopyMemory(BufferPtr,
                           StringPtr,
                           StringLen * sizeof(TCHAR)
                          );
                BufferPtr += StringLen;
                IdListLen -= StringLen;

            } else {

                Err = ERROR_INSUFFICIENT_BUFFER;
                if(!RequiredSize) {
                    //
                    // We've run out of buffer, and the caller doesn't care
                    // what the total required size is, so bail now.
                    //
                    break;
                }
            }
        }

        TotalLen += StringLen;
    }

    if(DriverInfoDetailData) {
        //
        // Append the additional terminating nul.  Note that we've been saving
        // the last character position in the buffer all along, so we're
        // guaranteed to be inside the buffer.
        //
        MYASSERT(BufferPtr < (PTSTR)((PBYTE)DriverInfoDetailData + BufferSize));
        *BufferPtr = 0;

        //
        // Store the length of the CompatibleIDs list.  Note that this is the
        // length of the list actually returned, which may be less than the
        // length of the entire list (if the caller-supplied buffer wasn't
        // large enough).
        //
        if(CompatIdListLen -= IdListLen) {
            //
            // If this list is non-empty, then add a character for the extra nul
            // terminating the multi-sz list.
            //
            CompatIdListLen++;
        }
        DriverInfoDetailData->CompatIDsLength = CompatIdListLen;
    }

    if(RequiredSize) {
        *RequiredSize = FIXEDPARTLEN + ((TotalLen + 1) * sizeof(TCHAR));
    }

    return Err;
}


PDRIVER_LIST_OBJECT
GetAssociatedDriverListObject(
    IN  PDRIVER_LIST_OBJECT  ObjectListHead,
    IN  PDRIVER_NODE         DriverListHead,
    OUT PDRIVER_LIST_OBJECT *PrevDriverListObject OPTIONAL
    )
/*++

Routine Description:

    This routine searches through a driver list object list, and returns a
    pointer to the driver list object containing the list specified by
    DrvListHead.  It also optionally returns the preceding object in the list
    (used when extracting the driver list object from the linked list).

Arguments:

    ObjectListHead - Specifies the linked list of driver list objects to be
        searched.

    DriverListHead - Specifies the driver list to be searched for.

    PrevDriverListObject - Optionaly, supplies the address of the variable that
        receives a pointer to the driver list object immediately preceding the
        matching object.  If the object was found at the front of the list,
        then this variable will be set to NULL.

Return Value:

    If the matching driver list object is found, the return value is a pointer
    to that element, otherwise, the return value is NULL.

--*/
{
    PDRIVER_LIST_OBJECT prev = NULL;

    while(ObjectListHead) {

        if(ObjectListHead->DriverListHead == DriverListHead) {

            if(PrevDriverListObject) {
                *PrevDriverListObject = prev;
            }

            return ObjectListHead;
        }

        prev = ObjectListHead;
        ObjectListHead = ObjectListHead->Next;
    }

    return NULL;
}


VOID
DereferenceClassDriverList(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PDRIVER_NODE     DriverListHead OPTIONAL
    )
/*++

Routine Description:

    This routine dereferences the class driver list object associated with the
    supplied DriverListHead.  If the refcount goes to zero, the object is
    destroyed, and all associated memory is freed.

Arguments:

    DeviceInfoSet - Supplies the address of the device information set
    containing the linked list of class driver list objects.

    DriverListHead - Optionally, supplies a pointer to the header of the driver
    list to be dereferenced.  If this parameter is not supplied, the routine
    does nothing.

Return Value:

    None.

--*/
{
    PDRIVER_LIST_OBJECT DrvListObject, PrevDrvListObject;

    if(DriverListHead) {

        DrvListObject = GetAssociatedDriverListObject(
                            DeviceInfoSet->ClassDrvListObjectList,
                            DriverListHead,
                            &PrevDrvListObject
                            );

        MYASSERT(DrvListObject && DrvListObject->RefCount);

        if(!(--DrvListObject->RefCount)) {

            if(PrevDrvListObject) {
                PrevDrvListObject->Next = DrvListObject->Next;
            } else {
                DeviceInfoSet->ClassDrvListObjectList = DrvListObject->Next;
            }
            MyFree(DrvListObject);

            DestroyDriverNodes(DriverListHead, DeviceInfoSet);
        }
    }
}


DWORD
GetDevInstallParams(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    OUT PSP_DEVINSTALL_PARAMS   DeviceInstallParams
    )
/*++

Routine Description:

    This routine fills in a SP_DEVINSTALL_PARAMS structure based on the
    installation parameter block supplied.

    Note:  The DeviceInstallParams structure must have its cbSize field
    filled in correctly, or the call will fail.

Arguments:

    DeviceInfoSet - Supplies the address of the device information set
        containing the parameters to be retrieved.  (This parameter is
        used to gain access to the string table for some of the string
        parameters).

    DevInstParamBlock - Supplies the address of an installation parameter
        block containing the parameters to be used in filling out the
        return buffer.

    DeviceInstallParams - Supplies the address of a buffer that will
        receive the filled-in SP_DEVINSTALL_PARAMS structure.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    PTSTR StringPtr;

    if(DeviceInstallParams->cbSize != sizeof(SP_DEVINSTALL_PARAMS)) {
        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // Fill in parameters.
    //
    ZeroMemory(DeviceInstallParams, sizeof(SP_DEVINSTALL_PARAMS));
    DeviceInstallParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    DeviceInstallParams->Flags                    = DevInstParamBlock->Flags;
    DeviceInstallParams->FlagsEx                  = DevInstParamBlock->FlagsEx;
    DeviceInstallParams->hwndParent               = DevInstParamBlock->hwndParent;
    DeviceInstallParams->InstallMsgHandler        = DevInstParamBlock->InstallMsgHandler;
    DeviceInstallParams->InstallMsgHandlerContext = DevInstParamBlock->InstallMsgHandlerContext;
    DeviceInstallParams->FileQueue                = DevInstParamBlock->UserFileQ;
    DeviceInstallParams->ClassInstallReserved     = DevInstParamBlock->ClassInstallReserved;
    //
    // The Reserved field is currently unused.
    //

    if(DevInstParamBlock->DriverPath != -1) {

        StringPtr = pStringTableStringFromId(DeviceInfoSet->StringTable,
                                             DevInstParamBlock->DriverPath
                                             );

        if (!MYVERIFY(SUCCEEDED(StringCchCopy(DeviceInstallParams->DriverPath,
                                              SIZECHARS(DeviceInstallParams->DriverPath),
                                              StringPtr)))) {
            return ERROR_INVALID_DATA;
        }
    }

    return NO_ERROR;
}


DWORD
GetClassInstallParams(
    IN  PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams, OPTIONAL
    IN  DWORD                   BufferSize,
    OUT PDWORD                  RequiredSize        OPTIONAL
    )
/*++

Routine Description:

    This routine fills in a buffer with the class installer parameters (if any)
    contained in the installation parameter block supplied.

    Note:  If supplied, the ClassInstallParams structure must have the cbSize
    field of the embedded SP_CLASSINSTALL_HEADER structure set to the size, in bytes,
    of the header.  If this is not set correctly, the call will fail.

Arguments:

    DevInstParamBlock - Supplies the address of an installation parameter block
        containing the class installer parameters to be used in filling out the
        return buffer.

    DeviceInstallParams - Optionally, supplies the address of a buffer
        that will receive the class installer parameters structure currently
        stored in the installation parameters block.  If this parameter is not
        supplied, then BufferSize must be zero.

    BufferSize - Supplies the size, in bytes, of the DeviceInstallParams
        buffer, or zero if DeviceInstallParams is not supplied.

    RequiredSize - Optionally, supplies the address of a variable that
        receives the number of bytes required to store the data.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    //
    // First, see whether we have any class install params, and if not, return
    // ERROR_NO_CLASSINSTALL_PARAMS.
    //
    if(!DevInstParamBlock->ClassInstallHeader) {
        return ERROR_NO_CLASSINSTALL_PARAMS;
    }

    if(ClassInstallParams) {

        if((BufferSize < sizeof(SP_CLASSINSTALL_HEADER)) ||
           (ClassInstallParams->cbSize != sizeof(SP_CLASSINSTALL_HEADER))) {

            return ERROR_INVALID_USER_BUFFER;
        }

    } else if(BufferSize) {
        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // Store required size in output parameter (if requested).
    //
    if(RequiredSize) {
        *RequiredSize = DevInstParamBlock->ClassInstallParamsSize;
    }

    //
    // See if supplied buffer is large enough.
    //
    if(BufferSize < DevInstParamBlock->ClassInstallParamsSize) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    CopyMemory((PVOID)ClassInstallParams,
               (PVOID)DevInstParamBlock->ClassInstallHeader,
               DevInstParamBlock->ClassInstallParamsSize
              );

    return NO_ERROR;
}


DWORD
SetDevInstallParams(
    IN OUT PDEVICE_INFO_SET        DeviceInfoSet,
    IN     PSP_DEVINSTALL_PARAMS   DeviceInstallParams,
    OUT    PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    IN     BOOL                    MsgHandlerIsNativeCharWidth
    )
/*++

Routine Description:

    This routine updates an internal parameter block based on the parameters
    supplied in a SP_DEVINSTALL_PARAMS structure.

    Note:  The supplied DeviceInstallParams structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DeviceInfoSet - Supplies the address of the device information set
        containing the parameters to be set.

    DeviceInstallParams - Supplies the address of a buffer containing the new
        installation parameters.

    DevInstParamBlock - Supplies the address of an installation parameter
        block to be updated.

    MsgHandlerIsNativeCharWidth - supplies a flag indicating whether the
        InstallMsgHandler in the DeviceInstallParams structure points to
        a callback routine that is expecting arguments in the 'native'
        character format. A value of FALSE is meaningful only in the
        Unicode build and specifies that the callback routine wants
        ANSI parameters.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    size_t DriverPathLen;
    LONG StringId;
    TCHAR TempString[MAX_PATH];
    HSPFILEQ OldQueueHandle = NULL;
    BOOL bRestoreQueue = FALSE;
    HRESULT hr;
    DWORD Err;

    if(DeviceInstallParams->cbSize != sizeof(SP_DEVINSTALL_PARAMS)) {
        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // No validation is currently required for the hwndParent,
    // InstallMsgHandler, InstallMsgHandlerContext, or ClassInstallReserved
    // fields.
    //

    //
    // Validate Flags(Ex)
    //
    if((DeviceInstallParams->Flags & DI_FLAGS_ILLEGAL) ||
       (DeviceInstallParams->FlagsEx & DI_FLAGSEX_ILLEGAL)) {

        return ERROR_INVALID_FLAGS;
    }

    //
    // Make sure that if DI_CLASSINSTALLPARAMS is being set, that we really do
    // have class install parameters.
    //
    if((DeviceInstallParams->Flags & DI_CLASSINSTALLPARAMS) &&
       !(DevInstParamBlock->ClassInstallHeader)) {

        return ERROR_NO_CLASSINSTALL_PARAMS;
    }

    //
    // Make sure that if DI_NOVCP is being set, that we have a caller-supplied
    // file queue.
    //
    if((DeviceInstallParams->Flags & DI_NOVCP) &&
       ((DeviceInstallParams->FileQueue == NULL) || (DeviceInstallParams->FileQueue == INVALID_HANDLE_VALUE))) {

        return ERROR_INVALID_FLAGS;
    }

    //
    // Make sure that if DI_FLAGSEX_ALTPLATFORM_DRVSEARCH is being set, that we
    // have a caller-supplied file queue.
    //
    // NOTE: We don't actually verify at this time that the file queue has
    // alternate platform info associated with it--this association can
    // actually be done later.  We _will_ catch this (and return an error) in
    // SetupDiBuildDriverInfoList if at that time we find that the file queue
    // has no alt platform info.
    //
    if((DeviceInstallParams->FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) &&
       !(DeviceInstallParams->Flags & DI_NOVCP)) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Validate that the DriverPath string is properly NULL-terminated.
    //
    hr = StringCchLength(DeviceInstallParams->DriverPath,
                         SIZECHARS(DeviceInstallParams->DriverPath),
                         &DriverPathLen
                        );
    if(FAILED(hr)) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Validate the caller-supplied file queue.
    //
    if((DeviceInstallParams->FileQueue == NULL) || (DeviceInstallParams->FileQueue == INVALID_HANDLE_VALUE)) {
        //
        // Store the current file queue handle (if any) to be released later.
        //
        OldQueueHandle = DevInstParamBlock->UserFileQ;
        DevInstParamBlock->UserFileQ = NULL;
        bRestoreQueue = TRUE;

    } else {
        //
        // The caller supplied a file queue handle.  See if it's the same one
        // we already have.
        //
        if(DeviceInstallParams->FileQueue != DevInstParamBlock->UserFileQ) {
            //
            // The caller has supplied a file queue handle that's different
            // from the one we currently have stored.  Remember the old handle
            // (in case we need to restore), and store the new handle.  Also,
            // increment the lock refcount on the new handle (enclose in
            // try/except in case it's a bogus one).
            //
            OldQueueHandle = DevInstParamBlock->UserFileQ;
            bRestoreQueue = TRUE;

            Err = ERROR_INVALID_PARAMETER; //default answer in case of failure.

            try {
                if(((PSP_FILE_QUEUE)(DeviceInstallParams->FileQueue))->Signature == SP_FILE_QUEUE_SIG) {

                    ((PSP_FILE_QUEUE)(DeviceInstallParams->FileQueue))->LockRefCount++;
                    DevInstParamBlock->UserFileQ = DeviceInstallParams->FileQueue;

                } else {
                    //
                    // Queue's signature isn't valid
                    //
                    bRestoreQueue = FALSE;
                }

            } except(pSetupExceptionFilter(GetExceptionCode())) {
                pSetupExceptionHandler(GetExceptionCode(),
                                       ERROR_INVALID_PARAMETER,
                                       &Err
                                      );
                DevInstParamBlock->UserFileQ = OldQueueHandle;
                bRestoreQueue = FALSE;
            }

            if(!bRestoreQueue) {
                //
                // Error encountered, probably because the file queue handle we
                // were given was invalid.
                //
                return Err;
            }
        }
    }

    //
    // Store the specified driver path.
    //
    if(DriverPathLen) {

        hr = StringCchCopy(TempString,
                           SIZECHARS(TempString),
                           DeviceInstallParams->DriverPath
                          );
        if(FAILED(hr)) {
            //
            // This shouldn't fail since we validated the string's length
            // previously.
            //
            StringId = -1;

        } else {

            StringId = pStringTableAddString(
                           DeviceInfoSet->StringTable,
                           TempString,
                           STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                           NULL, 0
                           );
        }

        if(StringId == -1) {
            //
            // We couldn't add the new driver path string to the string table.
            // Restore the old file queue (if necessary) and return an error.
            //
            if(bRestoreQueue) {

                if(DevInstParamBlock->UserFileQ) {
                    try {
                        ((PSP_FILE_QUEUE)(DevInstParamBlock->UserFileQ))->LockRefCount--;
                    } except(pSetupExceptionFilter(GetExceptionCode())) {
                        pSetupExceptionHandler(GetExceptionCode(),
                                               ERROR_INVALID_PARAMETER,
                                               NULL
                                              );
                    }
                }
                DevInstParamBlock->UserFileQ = OldQueueHandle;
            }
            return FAILED(hr) ? ERROR_INVALID_DATA : ERROR_NOT_ENOUGH_MEMORY;
        }
        DevInstParamBlock->DriverPath = StringId;
    } else {
        DevInstParamBlock->DriverPath = -1;
    }

    //
    // Should be smooth sailing from here on out.  Decrement the refcount on
    // the old queue handle, if there was one.
    //
    if(OldQueueHandle) {
        try {
            MYASSERT(((PSP_FILE_QUEUE)OldQueueHandle)->LockRefCount);
            ((PSP_FILE_QUEUE)OldQueueHandle)->LockRefCount--;
        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(),
                                   ERROR_INVALID_PARAMETER,
                                   NULL
                                  );
        }
    }

    //
    // Ignore attempts at modifying read-only flags.
    //
    DevInstParamBlock->Flags   = (DeviceInstallParams->Flags & ~DI_FLAGS_READONLY) |
                                 (DevInstParamBlock->Flags   &  DI_FLAGS_READONLY);

    DevInstParamBlock->FlagsEx = (DeviceInstallParams->FlagsEx & ~DI_FLAGSEX_READONLY) |
                                 (DevInstParamBlock->FlagsEx   &  DI_FLAGSEX_READONLY);

    //
    // Additionally, if we're in non-interactive mode, make sure not to clear
    // our "be quiet" flags.
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        DevInstParamBlock->Flags   |= DI_QUIETINSTALL;
        DevInstParamBlock->FlagsEx |= DI_FLAGSEX_NOUIONQUERYREMOVE;
    }

    //
    // Store the rest of the parameters.
    //
    DevInstParamBlock->hwndParent               = DeviceInstallParams->hwndParent;
    DevInstParamBlock->InstallMsgHandler        = DeviceInstallParams->InstallMsgHandler;
    DevInstParamBlock->InstallMsgHandlerContext = DeviceInstallParams->InstallMsgHandlerContext;
    DevInstParamBlock->ClassInstallReserved     = DeviceInstallParams->ClassInstallReserved;

    DevInstParamBlock->InstallMsgHandlerIsNativeCharWidth = MsgHandlerIsNativeCharWidth;

    return NO_ERROR;
}


DWORD
SetClassInstallParams(
    IN OUT PDEVICE_INFO_SET        DeviceInfoSet,
    IN     PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN     DWORD                   ClassInstallParamsSize,
    OUT    PDEVINSTALL_PARAM_BLOCK DevInstParamBlock
    )
/*++

Routine Description:

    This routine updates an internal class installer parameter block based on
    the parameters supplied in a class installer parameter buffer.  If this
    buffer is not supplied, then the existing class installer parameters (if
    any) are cleared.

Arguments:

    DeviceInfoSet - Supplies the address of the device information set
        for which class installer parameters are to be set.

    ClassInstallParams - Optionally, supplies the address of a buffer
        containing the class installer parameters to be used.  The
        SP_CLASSINSTALL_HEADER structure at the beginning of the buffer must
        have its cbSize field set to be sizeof(SP_CLASSINSTALL_HEADER), and the
        InstallFunction field must be set to the DI_FUNCTION code reflecting
        the type of parameters supplied in the rest of the buffer.

        If this parameter is not supplied, then the current class installer
        parameters (if any) will be cleared for the specified device
        information set or element.

    ClassInstallParamsSize - Supplies the size, in bytes, of the
        ClassInstallParams buffer.  If the buffer is not supplied (i.e., the
        class installer parameters are to be cleared), then this value must be
        zero.

    DevInstParamBlock - Supplies the address of an installation parameter block
        to be updated.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    PBYTE NewParamBuffer;
    DWORD Err;

    if(ClassInstallParams) {

        if((ClassInstallParamsSize < sizeof(SP_CLASSINSTALL_HEADER)) ||
           (ClassInstallParams->cbSize != sizeof(SP_CLASSINSTALL_HEADER))) {

            return ERROR_INVALID_USER_BUFFER;
        }

        //
        // DIF codes must be non-zero...
        //
        if(!(ClassInstallParams->InstallFunction)) {
            return ERROR_INVALID_PARAMETER;
        }

    } else {
        //
        // We are to clear any existing class installer parameters.
        //
        if(ClassInstallParamsSize) {
            return ERROR_INVALID_USER_BUFFER;
        }

        if(DevInstParamBlock->ClassInstallHeader) {
            MyFree(DevInstParamBlock->ClassInstallHeader);
            DevInstParamBlock->ClassInstallHeader = NULL;
            DevInstParamBlock->ClassInstallParamsSize = 0;
            DevInstParamBlock->Flags &= ~DI_CLASSINSTALLPARAMS;
        }

        return NO_ERROR;
    }

    //
    // Validate the new class install parameters w.r.t. the value of the
    // specified InstallFunction code.
    //
    switch(ClassInstallParams->InstallFunction) {

        case DIF_ENABLECLASS :
            //
            // We should have a SP_ENABLECLASS_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_ENABLECLASS_PARAMS)) {

                PSP_ENABLECLASS_PARAMS EnableClassParams;

                EnableClassParams = (PSP_ENABLECLASS_PARAMS)ClassInstallParams;
                //
                // Don't bother validating GUID--just validate EnableMessage field.
                //
                if(EnableClassParams->EnableMessage <= ENABLECLASS_FAILURE) {
                    //
                    // parameter set validated.
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_MOVEDEVICE :
            //
            // Deprecated function.
            //
            return ERROR_DI_FUNCTION_OBSOLETE;

        case DIF_PROPERTYCHANGE :
            //
            // We should have a SP_PROPCHANGE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_PROPCHANGE_PARAMS)) {

                PSP_PROPCHANGE_PARAMS PropChangeParams;

                PropChangeParams = (PSP_PROPCHANGE_PARAMS)ClassInstallParams;
                if((PropChangeParams->StateChange >= DICS_ENABLE) &&
                   (PropChangeParams->StateChange <= DICS_STOP)) {

                    //
                    // Validate Scope specifier--even though these values are defined like
                    // flags, they are mutually exclusive, so treat them like ordinals.
                    //
                    if((PropChangeParams->Scope == DICS_FLAG_GLOBAL) ||
                       (PropChangeParams->Scope == DICS_FLAG_CONFIGSPECIFIC) ||
                       (PropChangeParams->Scope == DICS_FLAG_CONFIGGENERAL)) {

                        //
                        // DICS_START and DICS_STOP are always config specific.
                        //
                        if(((PropChangeParams->StateChange == DICS_START) || (PropChangeParams->StateChange == DICS_STOP)) &&
                           (PropChangeParams->Scope != DICS_FLAG_CONFIGSPECIFIC)) {

                            goto BadPropChangeParams;
                        }

                        //
                        // parameter set validated
                        //
                        // NOTE: Even though DICS_FLAG_CONFIGSPECIFIC indicates
                        // that the HwProfile field specifies a hardware profile,
                        // there's no need to do validation on that.
                        //
                        break;
                    }
                }
            }

BadPropChangeParams:
            return ERROR_INVALID_PARAMETER;

        case DIF_REMOVE :
            //
            // We should have a SP_REMOVEDEVICE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_REMOVEDEVICE_PARAMS)) {

                PSP_REMOVEDEVICE_PARAMS RemoveDevParams;

                RemoveDevParams = (PSP_REMOVEDEVICE_PARAMS)ClassInstallParams;
                if((RemoveDevParams->Scope == DI_REMOVEDEVICE_GLOBAL) ||
                   (RemoveDevParams->Scope == DI_REMOVEDEVICE_CONFIGSPECIFIC)) {
                    //
                    // parameter set validated
                    //
                    // NOTE: Even though DI_REMOVEDEVICE_CONFIGSPECIFIC indicates
                    // that the HwProfile field specifies a hardware profile,
                    // there's no need to do validation on that.
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_UNREMOVE :
            //
            // We should have a SP_UNREMOVEDEVICE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_UNREMOVEDEVICE_PARAMS)) {

                PSP_UNREMOVEDEVICE_PARAMS UnremoveDevParams;

                UnremoveDevParams = (PSP_UNREMOVEDEVICE_PARAMS)ClassInstallParams;
                if(UnremoveDevParams->Scope == DI_UNREMOVEDEVICE_CONFIGSPECIFIC) {
                    //
                    // parameter set validated
                    //
                    // NOTE: Even though DI_UNREMOVEDEVICE_CONFIGSPECIFIC indicates
                    // that the HwProfile field specifies a hardware profile,
                    // there's no need to do validation on that.
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_SELECTDEVICE :
            //
            // We should have a SP_SELECTDEVICE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_SELECTDEVICE_PARAMS)) {

                PSP_SELECTDEVICE_PARAMS SelectDevParams;

                SelectDevParams = (PSP_SELECTDEVICE_PARAMS)ClassInstallParams;
                //
                // Validate that the string fields are properly NULL-terminated.
                //
                if(SUCCEEDED(StringCchLength(SelectDevParams->Title, SIZECHARS(SelectDevParams->Title), NULL)) &&
                   SUCCEEDED(StringCchLength(SelectDevParams->Instructions, SIZECHARS(SelectDevParams->Instructions), NULL)) &&
                   SUCCEEDED(StringCchLength(SelectDevParams->ListLabel, SIZECHARS(SelectDevParams->ListLabel), NULL)) &&
                   SUCCEEDED(StringCchLength(SelectDevParams->SubTitle, SIZECHARS(SelectDevParams->SubTitle), NULL)))
                {
                    //
                    // parameter set validated
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_INSTALLWIZARD :
            //
            // We should have a SP_INSTALLWIZARD_DATA structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_INSTALLWIZARD_DATA)) {

                PSP_INSTALLWIZARD_DATA InstallWizData;
                DWORD i;

                InstallWizData = (PSP_INSTALLWIZARD_DATA)ClassInstallParams;
                //
                // Validate the propsheet handle list.
                //
                if(InstallWizData->NumDynamicPages <= MAX_INSTALLWIZARD_DYNAPAGES) {

                    for(i = 0; i < InstallWizData->NumDynamicPages; i++) {
                        //
                        // For now, just verify that all handles are non-NULL.
                        //
                        if(!(InstallWizData->DynamicPages[i])) {
                            //
                            // Invalid property sheet page handle
                            //
                            return ERROR_INVALID_PARAMETER;
                        }
                    }

                    //
                    // Handles are verified, now verify Flags.
                    //
                    if(!(InstallWizData->Flags & NDW_INSTALLFLAG_ILLEGAL)) {

                        if(!(InstallWizData->DynamicPageFlags & DYNAWIZ_FLAG_ILLEGAL)) {
                            //
                            // parameter set validated
                            //
                            break;
                        }
                    }
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_NEWDEVICEWIZARD_PRESELECT :
        case DIF_NEWDEVICEWIZARD_SELECT :
        case DIF_NEWDEVICEWIZARD_PREANALYZE :
        case DIF_NEWDEVICEWIZARD_POSTANALYZE :
        case DIF_NEWDEVICEWIZARD_FINISHINSTALL :
        case DIF_ADDPROPERTYPAGE_ADVANCED:
        case DIF_ADDPROPERTYPAGE_BASIC:
        case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED:
            //
            // We should have a SP_NEWDEVICEWIZARD_DATA structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_NEWDEVICEWIZARD_DATA)) {

                PSP_NEWDEVICEWIZARD_DATA NewDevWizData;
                DWORD i;

                NewDevWizData = (PSP_NEWDEVICEWIZARD_DATA)ClassInstallParams;
                //
                // Validate the propsheet handle list.
                //
                if(NewDevWizData->NumDynamicPages <= MAX_INSTALLWIZARD_DYNAPAGES) {

                    for(i = 0; i < NewDevWizData->NumDynamicPages; i++) {
                        //
                        // For now, just verify that all handles are non-NULL.
                        //
                        if(!(NewDevWizData->DynamicPages[i])) {
                            //
                            // Invalid property sheet page handle
                            //
                            return ERROR_INVALID_PARAMETER;
                        }
                    }

                    //
                    // Handles are verified, now verify Flags.
                    //
                    if(!(NewDevWizData->Flags & NEWDEVICEWIZARD_FLAG_ILLEGAL)) {
                        //
                        // parameter set validated
                        //
                        break;
                    }
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_DETECT :
            //
            // We should have a SP_DETECTDEVICE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_DETECTDEVICE_PARAMS)) {

                PSP_DETECTDEVICE_PARAMS DetectDeviceParams;

                DetectDeviceParams = (PSP_DETECTDEVICE_PARAMS)ClassInstallParams;
                //
                // Make sure there's an entry point for the progress notification callback.
                //
                if(DetectDeviceParams->DetectProgressNotify) {
                    //
                    // parameter set validated.
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_GETWINDOWSUPDATEINFO:  // aka DIF_RESERVED1
            //
            // We should have a SP_WINDOWSUPDATE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_WINDOWSUPDATE_PARAMS)) {

                PSP_WINDOWSUPDATE_PARAMS WindowsUpdateParams;

                WindowsUpdateParams = (PSP_WINDOWSUPDATE_PARAMS)ClassInstallParams;

                //
                // Validate the PackageId string
                //
                if(SUCCEEDED(StringCchLength(WindowsUpdateParams->PackageId,
                                             SIZECHARS(WindowsUpdateParams->PackageId),
                                             NULL))) {
                    //
                    // parameter set validated
                    // NOTE: It is valid for the CDMContext handle to
                    // be NULL.
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_TROUBLESHOOTER:
            //
            // We should have a SP_TROUBLESHOOTER_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_TROUBLESHOOTER_PARAMS)) {

                PSP_TROUBLESHOOTER_PARAMS TroubleshooterParams;

                TroubleshooterParams = (PSP_TROUBLESHOOTER_PARAMS)ClassInstallParams;

                //
                // For now, just verify that the strings are properly null
                // terminated.
                //
                if(SUCCEEDED(StringCchLength(TroubleshooterParams->ChmFile, SIZECHARS(TroubleshooterParams->ChmFile), NULL)) &&
                   SUCCEEDED(StringCchLength(TroubleshooterParams->HtmlTroubleShooter, SIZECHARS(TroubleshooterParams->HtmlTroubleShooter), NULL)))
                {
                    //
                    // parameter set validated
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_POWERMESSAGEWAKE:
            //
            // We should have a SP_POWERMESSAGEWAKE_PARAMS structure.
            //
            if(ClassInstallParamsSize == sizeof(SP_POWERMESSAGEWAKE_PARAMS)) {

                PSP_POWERMESSAGEWAKE_PARAMS PowerMessageWakeParams;

                PowerMessageWakeParams = (PSP_POWERMESSAGEWAKE_PARAMS)ClassInstallParams;

                //
                // Verify the message string is properly null terminated.
                //
                if(SUCCEEDED(StringCchLength(PowerMessageWakeParams->PowerMessageWake,
                                             SIZECHARS(PowerMessageWakeParams->PowerMessageWake),
                                             NULL))) {
                    //
                    // parameter set validated
                    //
                    break;
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_INTERFACE_TO_DEVICE:   // aka DIF_RESERVED2
            //
            // FUTURE-2002/04/28-lonnym -- DIF_INTERFACE_TO_DEVICE should be deprecated.
            // This DIF request (and associated PSP_INTERFACE_TO_DEVICE_PARAMS_W
            // structure) does not adhere to the the setupapi rule that no
            // pointers to callers' buffers can be cached within setupapi's
            // structures.  This is not a public DIF request (its numeric value
            // is reserved in setupapi.h, however), and the necessity for this
            // mechanism should be eliminated in the future when software
            // enumeration (aka, SWENUM) functionality is incorporated into
            // core Plug&Play.
            //

            //
            // We should have a SP_INTERFACE_TO_DEVICE_PARAMS_W structure
            //
            if(ClassInstallParamsSize == sizeof(SP_INTERFACE_TO_DEVICE_PARAMS_W)) {

                PSP_INTERFACE_TO_DEVICE_PARAMS_W InterfaceToDeviceParams;

                InterfaceToDeviceParams = (PSP_INTERFACE_TO_DEVICE_PARAMS_W)ClassInstallParams;

                //
                // Pointer to the device interface string must be valid.  Since
                // device interface names are variable-length, the only thing
                // we can say with certainty is that they must fit in a
                // UNICODE_STRING buffer (maximum size is 32K characters).
                //
                if(InterfaceToDeviceParams->Interface &&
                   SUCCEEDED(StringCchLength(InterfaceToDeviceParams->Interface, UNICODE_STRING_MAX_CHARS, NULL))) {
                    //
                    // If there's a device ID, make sure it refers to an actual
                    // device on the system (may or may not be a phantom).
                    //
                    if(InterfaceToDeviceParams->DeviceId) {

                        DEVINST DevInst;

                        if(CR_SUCCESS == CM_Locate_DevInst_Ex(
                                             &DevInst,
                                             InterfaceToDeviceParams->DeviceId,
                                             CM_LOCATE_DEVINST_NORMAL | CM_LOCATE_DEVINST_PHANTOM,
                                             DeviceInfoSet->hMachine))
                        {
                            //
                            // parameter set validated
                            //
                            break;
                        }

                    } else {
                        //
                        // The caller is setting this with an empty device id,
                        // hoping that a class installer or co-installer can
                        // fill in the answer.
                        //
                        break;  // it's valid for DeviceId to be empty
                    }
                }
            }
            return ERROR_INVALID_PARAMETER;

        case DIF_INSTALLDEVICE:
        case DIF_ASSIGNRESOURCES:
        case DIF_PROPERTIES:
        case DIF_FIRSTTIMESETUP:
        case DIF_FOUNDDEVICE:
        case DIF_SELECTCLASSDRIVERS:
        case DIF_VALIDATECLASSDRIVERS:
        case DIF_INSTALLCLASSDRIVERS:
        case DIF_CALCDISKSPACE:
        case DIF_DESTROYPRIVATEDATA:
        case DIF_VALIDATEDRIVER:
        case DIF_DETECTVERIFY:
        case DIF_INSTALLDEVICEFILES:
        case DIF_SELECTBESTCOMPATDRV:
        case DIF_ALLOW_INSTALL:
        case DIF_REGISTERDEVICE:
        case DIF_UNUSED1:
        case DIF_INSTALLINTERFACES:
        case DIF_DETECTCANCEL:
        case DIF_REGISTER_COINSTALLERS:
        case DIF_UPDATEDRIVER_UI:
            //
            // For all other system-defined DIF codes, disallow storage of any
            // associated class install params.
            //
            return ERROR_INVALID_PARAMETER;

        default :
            //
            // Some generic buffer for a custom DIF request.  No validation to
            // be done.
            //
            break;
    }

    //
    // The class install parameters have been validated.  Allocate a buffer for
    // the new parameter structure.
    //
    if(!(NewParamBuffer = MyMalloc(ClassInstallParamsSize))) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Err = NO_ERROR;

    try {
        CopyMemory(NewParamBuffer,
                   ClassInstallParams,
                   ClassInstallParamsSize
                  );
    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(Err != NO_ERROR) {
        //
        // Then an exception occurred and we couldn't store the new parameters.
        //
        MyFree(NewParamBuffer);
        return Err;
    }

    if(DevInstParamBlock->ClassInstallHeader) {
        MyFree(DevInstParamBlock->ClassInstallHeader);
    }
    DevInstParamBlock->ClassInstallHeader = (PSP_CLASSINSTALL_HEADER)NewParamBuffer;
    DevInstParamBlock->ClassInstallParamsSize = ClassInstallParamsSize;
    DevInstParamBlock->Flags |= DI_CLASSINSTALLPARAMS;

    return NO_ERROR;
}


DWORD
GetDrvInstallParams(
    IN  PDRIVER_NODE          DriverNode,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
/*++

Routine Description:

    This routine fills in a SP_DRVINSTALL_PARAMS structure based on the
    driver node supplied

    Note:  The supplied DriverInstallParams structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DriverNode - Supplies the address of the driver node containing the
        installation parameters to be retrieved.

    DriverInstallParams - Supplies the address of a SP_DRVINSTALL_PARAMS
        structure that will receive the installation parameters.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

NOTE:

    This routine _does not_ set the Win98-compatible DNF_CLASS_DRIVER or
    DNF_COMPATIBLE_DRIVER flags that indicate whether or not the driver node is
    from a class or compatible driver list, respectively.

--*/
{
    if(DriverInstallParams->cbSize != sizeof(SP_DRVINSTALL_PARAMS)) {
        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // Copy the parameters.
    //
    DriverInstallParams->Rank = DriverNode->Rank;
    DriverInstallParams->Flags = DriverNode->Flags;
    DriverInstallParams->PrivateData = DriverNode->PrivateData;

    //
    // The 'Reserved' field of the SP_DRVINSTALL_PARAMS structure isn't
    // currently used.
    //

    return NO_ERROR;
}


DWORD
SetDrvInstallParams(
    IN  PSP_DRVINSTALL_PARAMS DriverInstallParams,
    OUT PDRIVER_NODE          DriverNode
    )
/*++

Routine Description:

    This routine sets the driver installation parameters for the specified
    driver node based on the caller-supplied SP_DRVINSTALL_PARAMS structure.

    Note:  The supplied DriverInstallParams structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DriverInstallParams - Supplies the address of a SP_DRVINSTALL_PARAMS
        structure containing the installation parameters to be used.

    DriverNode - Supplies the address of the driver node whose installation
        parameters are to be set.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.

--*/
{
    if(DriverInstallParams->cbSize != sizeof(SP_DRVINSTALL_PARAMS)) {
        return ERROR_INVALID_USER_BUFFER;
    }

    //
    // Validate the flags.
    //
    if(DriverInstallParams->Flags & DNF_FLAGS_ILLEGAL) {
        return ERROR_INVALID_FLAGS;
    }

    //
    // No validation currently being done on Rank and PrivateData fields.
    //

    //
    // ISSUE-2002/04/28-lonnym -- Should we disallow shifting ranks to other ranges?
    // There have been some abuses by class-/co-installers in shifting ranks of
    // certain kinds of drivers (e.g., older than a certain date) up to a high
    // value where they're considered worse than anything else.  This causes
    // inconsistency and inpredictability in driver ranking/selection and
    // results in vendor confusion and incongruity with Windows Update logic
    // for deciding what drivers it should offer as updates.  A proposed
    // improvement would be to only allow ranks to be shifted "up" to the top
    // of the current range in which they exist.
    //

    //
    // We're ready to copy the parameters.
    //
    DriverNode->Rank = DriverInstallParams->Rank;
    DriverNode->PrivateData = DriverInstallParams->PrivateData;
    //
    // Ignore attempts at modifying read-only flags.
    //
    DriverNode->Flags = (DriverInstallParams->Flags & ~DNF_FLAGS_READONLY) |
                        (DriverNode->Flags          &  DNF_FLAGS_READONLY);

    return NO_ERROR;
}


LONG
AddMultiSzToStringTable(
    IN  PVOID   StringTable,
    IN  PTCHAR  MultiSzBuffer,
    OUT PLONG   StringIdList,
    IN  DWORD   StringIdListSize,
    IN  BOOL    CaseSensitive,
    OUT PTCHAR *UnprocessedBuffer    OPTIONAL
    )
/*++

Routine Description:

    This routine adds every string in the MultiSzBuffer to the specified
    string table, and stores the resulting IDs in the supplied output buffer.

Arguments:

    StringTable - Supplies the handle of the string table to add the strings to.

    MultiSzBuffer - Supplies the address of the REG_MULTI_SZ buffer containing
        the strings to be added.

    StringIdList - Supplies the address of an array of LONGs that receives the
        list of IDs for the added strings (the ordering of the IDs in this
        list will be the same as the ordering of the strings in the MultiSzBuffer.

    StringIdListSize - Supplies the size, in LONGs, of the StringIdList.  If the
        number of strings in MultiSzBuffer exceeds this amount, then only the
        first StringIdListSize strings will be added, and the position in the
        buffer where processing was halted will be stored in UnprocessedBuffer.

    CaseSensitive - Specifies whether the string should be added case-sensitively.

    UnprocessedBuffer - Optionally, supplies the address of a character pointer
        that receives the position where processing was aborted because the
        StringIdList buffer was filled.  If all strings in the MultiSzBuffer were
        processed, then this pointer will be set to NULL.

Return Value:

    If successful, the return value is the number of strings added.
    If failure, the return value is -1 (this happens if a string cannot be
    added because of an out-of-memory condition).

--*/
{
    PTSTR CurString;
    LONG StringCount = 0;

    for(CurString = MultiSzBuffer;
        (*CurString && (StringCount < (LONG)StringIdListSize));
        CurString += (lstrlen(CurString)+1)) {

        StringIdList[StringCount] = pStringTableAddString(
                                        StringTable,
                                        CurString,
                                        CaseSensitive
                                            ? STRTAB_CASE_SENSITIVE
                                            : STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                        NULL,0
                                        );

        if(StringIdList[StringCount] == -1) {
            StringCount = -1;
            break;
        }

        StringCount++;
    }

    if(UnprocessedBuffer) {
        *UnprocessedBuffer = (*CurString ? CurString : NULL);
    }

    return StringCount;
}


LONG
LookUpStringInDevInfoSet(
    IN HDEVINFO DeviceInfoSet,
    IN PTSTR    String,
    IN BOOL     CaseSensitive
    )
/*++

Routine Description:

    This routine looks up the specified string in the string table associated with
    the specified device information set.

Arguments:

    DeviceInfoSet - Supplies the pointer to the device information set containing
        the string table to look the string up in.

    String - Specifies the string to be looked up.  This string is not specified as
        const, so that the lookup routine may modify it (i.e., lower-case it) without
        having to allocate a temporary buffer.

    CaseSensitive - If TRUE, then a case-sensitive lookup is performed, otherwise, the
        lookup is case-insensitive.

Return Value:

    If the function succeeds, the return value is the string's ID in the string table.
    device information set.

    If the function fails, the return value is -1.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    LONG StringId;
    DWORD StringLen;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        return -1;
    }

    try {

        StringId = pStringTableLookUpString(pDeviceInfoSet->StringTable,
                                            String,
                                            &StringLen,
                                            NULL,
                                            NULL,
                                            STRTAB_BUFFER_WRITEABLE |
                                                (CaseSensitive ? STRTAB_CASE_SENSITIVE
                                                               : STRTAB_CASE_INSENSITIVE),
                                            NULL,0
                                           );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(),
                               ERROR_INVALID_PARAMETER,
                               NULL
                              );
        StringId = -1;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return StringId;
}


BOOL
ShouldClassBeExcluded(
    IN LPGUID ClassGuid,
    IN BOOL   ExcludeNoInstallClass
    )
/*++

Routine Description:

    This routine determines whether a class should be excluded from
    some operation, based on whether it has a NoInstallClass or
    NoUseClass value entry in its registry key.

Arguments:

    ClassGuidString - Supplies the address of the class GUID to be
        filtered.

    ExcludeNoInstallClass - TRUE if NoInstallClass classes should be
        excluded and FALSE if they should not be excluded.

Return Value:

    If the class should be excluded, the return value is TRUE, otherwise
    it is FALSE.

--*/
{
    HKEY hk;
    BOOL ExcludeClass = FALSE;

    if((hk = SetupDiOpenClassRegKey(ClassGuid, KEY_READ)) != INVALID_HANDLE_VALUE) {

        try {

            if(RegQueryValueEx(hk,
                               pszNoUseClass,
                               NULL,
                               NULL,
                               NULL,
                               NULL) == ERROR_SUCCESS) {

                ExcludeClass = TRUE;

            } else if(ExcludeNoInstallClass &&
                      (ERROR_SUCCESS == RegQueryValueEx(hk,
                                                        pszNoInstallClass,
                                                        NULL,
                                                        NULL,
                                                        NULL,
                                                        NULL))) {
                ExcludeClass = TRUE;
            }
        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(),
                                   ERROR_INVALID_PARAMETER,
                                   NULL
                                  );
        }

        RegCloseKey(hk);
    }

    return ExcludeClass;
}


BOOL
ClassGuidFromInfVersionNode(
    IN  PINF_VERSION_NODE VersionNode,
    OUT LPGUID            ClassGuid
    )
/*++

Routine Description:

    This routine retrieves the class GUID for the INF whose version node
    is specified.  If the version node doesn't have a ClassGUID value,
    then the Class value is retrieved, and all class GUIDs matching this
    class name are retrieved.  If there is exactly 1 match found, then
    this GUID is returned, otherwise, the routine fails.

Arguments:

    VersionNode - Supplies the address of an INF version node that
        must contain either a ClassGUID or Class entry.

    ClassGuid - Supplies the address of the variable that receives the
        class GUID.

Return Value:

    If a class GUID was retrieved, the return value is TRUE, otherwise,
    it is FALSE.

--*/
{
    PCTSTR GuidString, NameString;
    DWORD NumGuids;

    if(GuidString = pSetupGetVersionDatum(VersionNode, pszClassGuid)) {

        if(pSetupGuidFromString(GuidString, ClassGuid) == NO_ERROR) {
            return TRUE;
        }

    } else {

        NameString = pSetupGetVersionDatum(VersionNode, pszClass);
        if(NameString &&
           SetupDiClassGuidsFromName(NameString,
                                     ClassGuid,
                                     1,
                                     &NumGuids) && NumGuids) {
            return TRUE;
        }
    }

    return FALSE;
}


DWORD
EnumSingleDrvInf(
    IN     PCTSTR                       InfName,
    IN OUT LPWIN32_FIND_DATA            InfFileData,
    IN     DWORD                        SearchControl,
    IN     InfCacheCallback             EnumInfCallback,
    IN     PSETUP_LOG_CONTEXT           LogContext,
    IN OUT PDRVSEARCH_CONTEXT           Context
    )
/*++

Routine Description:

    This routine finds and opens the specified INF, and calls the
    supplied callback routine for it. It's primary purpose is to
    provide the callback with the same information the cache-search
    does.

Arguments:

    InfName - Supplies the name of the INF to call the callback for.

    InfFileData - Supplies data returned from FindFirstFile/FindNextFile
        for this INF.  This parameter is used as input if the
        INFINFO_INF_NAME_IS_ABSOLUTE SearchControl value is specified.
        If any other SearchControl value is specified, then this buffer
        is used to retrieve the Win32 Find Data for the specified INF.

    SearchControl - Specifies where the INF should be searched for.  May
        be one of the following values:

        INFINFO_INF_NAME_IS_ABSOLUTE - Open the specified INF name as-is.
        INFINFO_DEFAULT_SEARCH - Look in INF dir, then System32
        INFINFO_REVERSE_DEFAULT_SEARCH - reverse of the above
        INFINFO_INF_PATH_LIST_SEARCH - search each dir in 'DevicePath' list
                                       (stored in registry).

    EnumInfCallback - Supplies the address of the callback routine
        to use.  The prototype for this callback is as follows:

        typedef BOOL (CALLBACK * InfCacheCallback)(
            IN PSETUP_LOG_CONTEXT LogContext,
            IN PCTSTR InfPath,
            IN PLOADED_INF pInf,
            IN PVOID Context
            );

        The callback routine returns TRUE to continue enumeration,
        or FALSE to abort it (with GetLastError set to ERROR_CANCELLED)

    Context - Supplies the address of a buffer that the callback may
        use to retrieve/return data.

Return Value:

    If the function succeeds, and the enumeration callback returned
    TRUE (continue enumeration), the return value is NO_ERROR.

    If the function succeeds, and the enumeration callback returned
    FALSE (abort enumeration), the return value is ERROR_CANCELLED.

    If the function fails, the return value is an ERROR_* status code.

--*/
{
    TCHAR PathBuffer[MAX_PATH];
    PCTSTR InfFullPath;
    DWORD Err;
    BOOL TryPnf = FALSE;
    PLOADED_INF Inf;
    BOOL PnfWasUsed;
    UINT ErrorLineNumber;
    BOOL Continue;

    if(SearchControl == INFINFO_INF_NAME_IS_ABSOLUTE) {
        InfFullPath = InfName;
    } else {
        //
        // The specified INF name should be searched for based
        // on the SearchControl type.
        //
        Err = SearchForInfFile(InfName,
                               InfFileData,
                               SearchControl,
                               PathBuffer,
                               SIZECHARS(PathBuffer),
                               NULL
                              );
        if(Err != NO_ERROR) {
            return Err;
        } else {
            InfFullPath = PathBuffer;
        }
    }

    //
    // If the 'try pnf' flag isn't set, then we need to examine this particular
    // filename, to see whether it's a pnf candidate.
    //
    if(Context->Flags & DRVSRCH_TRY_PNF) {
        TryPnf = TRUE;
    } else {
        InfSourcePathFromFileName(InfName, NULL, &TryPnf);
    }

    //
    // Attempt to load the INF file.  Note that throughout this routine, we
    // don't do any explicit locking of the INF before searching for sections,
    // etc.  That's because we know that this INF handle will never be exposed
    // to anyone else, and thus there are no concurrency problems.
    //
    Err = LoadInfFile(
              InfFullPath,
              InfFileData,
              INF_STYLE_WIN4,
              LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | (TryPnf ? LDINF_FLAG_ALWAYS_TRY_PNF : LDINF_FLAG_MATCH_CLASS_GUID),
              (Context->Flags & DRVSRCH_FILTERCLASS) ? Context->ClassGuidString : NULL,
              NULL,
              NULL,
              NULL,
              LogContext,
              &Inf,
              &ErrorLineNumber,
              &PnfWasUsed
              );

    if(Err != NO_ERROR) {

        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR,
            MSG_LOG_COULD_NOT_LOAD_INF,
            NULL,
            InfFullPath);

        return NO_ERROR;
    }

    //
    // Call the supplied callback routine.
    //
    try {

        Err = GLE_FN_CALL(FALSE,
                          EnumInfCallback(LogContext,
                                          InfFullPath,
                                          Inf,
                                          PnfWasUsed,
                                          Context)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    FreeInfFile(Inf);

    return Err;
}


DWORD
EnumDrvInfsInDirPathList(
    IN     PCTSTR                       DirPathList,   OPTIONAL
    IN     DWORD                        SearchControl,
    IN     InfCacheCallback             EnumInfCallback,
    IN     BOOL                         IgnoreNonCriticalErrors,
    IN     PSETUP_LOG_CONTEXT           LogContext,
    IN OUT PDRVSEARCH_CONTEXT           Context
    )
/*++

Routine Description:

    This routine enumerates all INFs present in the search list specified
    by SearchControl, using the accelerated search cache

Arguments:

    DirPathList - Optionally, specifies the search path listing all
        directories to be enumerated.  This string may contain multiple
        paths, separated by semicolons (;).  If this parameter is not
        specified, then the SearchControl value will determine the
        search path to be used.

    SearchControl - Specifies the set of directories to be enumerated.
        If SearchPath is specified, this parameter is ignored.  May be
        one of the following values:

        INFINFO_DEFAULT_SEARCH : enumerate %windir%\inf, then
            %windir%\system32

        INFINFO_REVERSE_DEFAULT_SEARCH : reverse of the above

        INFINFO_INF_PATH_LIST_SEARCH : enumerate INFs in each of the
            directories listed in the DevicePath value entry under:

            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion.

    EnumInfCallback - Supplies the address of the callback routine
        to use.  The prototype for this callback is as follows:

        typedef BOOL (CALLBACK * InfCacheCallback)(
            IN PSETUP_LOG_CONTEXT LogContext,
            IN PCTSTR InfPath,
            IN PLOADED_INF pInf,
            IN PVOID Context
            );

        The callback routine returns TRUE to continue enumeration,
        or FALSE to abort it (with GetLastError set to ERROR_CANCELLED)

    IgnoreNonCriticalErrors - If TRUE, then all errors are ignored
        except those that prevent enumeration from continuing.

    Context - Supplies the address of a buffer that the callback may
        use to retrieve/return data.

Return Value:

    If the function succeeds, and enumeration has not been aborted,
    then the return value is NO_ERROR.

    If the function succeeds, and enumeration has been aborted,
    then the return value is ERROR_CANCELLED.

    If the function fails, the return value is an ERROR_* status code.

--*/
{
    DWORD Err = NO_ERROR;
    PCTSTR PathList, CurPath;
    BOOL FreePathList = FALSE;
    DWORD Action;
    PTSTR ClassIdList = NULL;
    PTSTR HwIdList = NULL;
    size_t len;
    size_t TotalLength = 1;
    HRESULT hr;

    try {

        if(DirPathList) {
            //
            // Use the specified search path(s).
            //
            PathList = GetFullyQualifiedMultiSzPathList(DirPathList);
            if(PathList) {
                FreePathList = TRUE;
            }

        } else if(SearchControl == INFINFO_INF_PATH_LIST_SEARCH) {
            //
            // Use our global list of INF search paths.
            //
            PathList = InfSearchPaths;

        } else {
            //
            // Retrieve the path list.
            //
            PathList = AllocAndReturnDriverSearchList(SearchControl);
            if(PathList) {
                FreePathList = TRUE;
            }
        }

        if(!PathList) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        //
        // If we're doing a non-native driver search, we want to search INFs
        // the old-fashioned way (i.e., sans INF cache).
        //
        if(Context->AltPlatformInfo) {
            Action = INFCACHE_ENUMALL;
        } else {
            Action = INFCACHE_DEFAULT;
        }

        if(Context->Flags & DRVSRCH_TRY_PNF) {
            //
            // TRY_PNF also forces us to build/use cache, except when we're
            // doing non-native driver searching.
            //
            Action |= INFCACHE_FORCE_PNF;

            if(!Context->AltPlatformInfo) {
                Action |= INFCACHE_FORCE_CACHE;
            }
        }

        if(Context->Flags & DRVSRCH_EXCLUDE_OLD_INET_DRIVERS) {
            //
            // exclude old internet INF's from search
            //
            Action |= INFCACHE_EXC_URL;
        }
        Action |= INFCACHE_EXC_NOMANU;    // exclude INF's that have no/empty [Manufacturer] section
        Action |= INFCACHE_EXC_NULLCLASS; // exclude INF's that have a ClassGuid = {<nill>}
        Action |= INFCACHE_EXC_NOCLASS;   // exclude INF's that don't have class information

        //
        // build class list if needed
        //
        // This is a multi-sz list consisting of:
        //     (1) the class GUID (string form)
        //     (2) name of class, if GUID has a corresponding class name
        //         (A class GUID should always have a name, but because we
        //         currently don't disallow callers going and whacking the
        //         class name directly via CM property APIs, we're protecting
        //         ourself against what is effectively a corrupted registry.
        //
        if(Context->Flags & DRVSRCH_FILTERCLASS) {

            TCHAR clsnam[MAX_CLASS_NAME_LEN];
            LPTSTR StringEnd;
            TotalLength = 1; // bias by 1 for extra null in multi-sz list

            MYASSERT(Context->ClassGuidString);

            hr = StringCchLength(Context->ClassGuidString,
                                 GUID_STRING_LEN,
                                 &len
                                );

            if(FAILED(hr) || (++len != GUID_STRING_LEN)) {
                //
                // Should never encounter this failure.
                //
                MYASSERT(FALSE);
                Err = ERROR_INVALID_DATA;
                leave;
            }

            TotalLength += len;

            //
            // Call SetupDiClassNameFromGuid to retrieve the class name
            // corresponding to this class GUID.
            // This allows us to find INFs that list this specific class name
            // but not the GUID.
            // Note that this will also return INFs that list the class name
            // but a different GUID, however these get filtered out later.
            //
            if(SetupDiClassNameFromGuid(
                   &Context->ClassGuid,
                   clsnam,
                   SIZECHARS(clsnam),
                   NULL)
               && *clsnam) {

                hr = StringCchLength(clsnam,
                                     SIZECHARS(clsnam),
                                     &len
                                    );

                if(FAILED(hr)) {
                    //
                    // Should never encounter this failure.
                    //
                    MYASSERT(FALSE);
                    Err = ERROR_INVALID_DATA;
                    leave;
                }

                len++;
                TotalLength += len;

            } else {
                *clsnam = TEXT('\0');
            }

            ClassIdList = (PTSTR)MyMalloc(TotalLength * sizeof(TCHAR));
            if(!ClassIdList) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }

            CopyMemory(ClassIdList,
                       Context->ClassGuidString,
                       GUID_STRING_LEN * sizeof(TCHAR)
                      );

            if(*clsnam) {
                CopyMemory(ClassIdList + GUID_STRING_LEN, clsnam, (len * sizeof(TCHAR)));
            }

            ClassIdList[TotalLength - 1] = TEXT('\0');
        }

        //
        // build HwIdList if needed
        //
        if(!Context->BuildClassDrvList) {

            PLONG pDevIdNum;
            PCTSTR CurDevId;
            int i;
            ULONG NumChars;
            TotalLength = 1; // bias by 1 for extra null in multi-sz list

            //
            // first pass, obtain size
            //
            for(i = 0; i < 2; i++) {

                for(pDevIdNum = Context->IdList[i]; *pDevIdNum != -1; pDevIdNum++) {
                    //
                    // First, obtain the device ID string corresponding to our
                    // stored-away string table ID.
                    //
                    CurDevId = pStringTableStringFromId(Context->StringTable, *pDevIdNum);
                    MYASSERT(CurDevId);

                    hr = StringCchLength(CurDevId,
                                         MAX_DEVICE_ID_LEN,
                                         &len
                                        );
                    if(FAILED(hr)) {
                        //
                        // Should never encounter this failure.
                        //
                        MYASSERT(FALSE);
                        Err = ERROR_INVALID_DATA;
                        leave;
                    }

                    len++;
                    TotalLength += len;
                }
            }

            HwIdList = (PTSTR)MyMalloc(TotalLength * sizeof(TCHAR));
            if(!HwIdList) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }

            //
            // second pass, write list
            //
            len = 0;

            for(i = 0; i < 2; i++) {

                for(pDevIdNum = Context->IdList[i]; *pDevIdNum != -1; pDevIdNum++) {
                    //
                    // Retrieve the device ID string directly into the buffer
                    // we've prepared.
                    //
                    CurDevId = pStringTableStringFromId(Context->StringTable, *pDevIdNum);
                    MYASSERT(CurDevId);

                    if (CurDevId) {

                        MYASSERT(TotalLength > len);
                        NumChars = TotalLength - len;

                        if (!MYVERIFY(SUCCEEDED(StringCchCopy(HwIdList+len,
                                                              NumChars,
                                                              CurDevId)))) {
                            Err = ERROR_INVALID_DATA;
                            leave;
                        }

                        len += (1 + lstrlen(HwIdList+len));
                    }
                }
            }
            MYASSERT(len == (TotalLength - 1));
            HwIdList[len] = TEXT('\0');
        }

        Err = InfCacheSearchPath(LogContext,
                                 Action,
                                 PathList,
                                 EnumInfCallback,
                                 Context,
                                 ClassIdList,
                                 HwIdList
                                );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(ClassIdList) {
        MyFree(ClassIdList);
    }
    if(HwIdList) {
        MyFree(HwIdList);
    }
    if(FreePathList) {
        MYASSERT(PathList);
        MyFree(PathList);
    }

    if((Err == ERROR_CANCELLED) || !IgnoreNonCriticalErrors) {
        return Err;
    } else {
        return NO_ERROR;
    }
}


DWORD
CreateDriverNode(
    IN  UINT          Rank,
    IN  PCTSTR        DevDescription,
    IN  PCTSTR        DrvDescription,
    IN  PCTSTR        ProviderName,   OPTIONAL
    IN  PCTSTR        MfgName,
    IN  PFILETIME     InfDate,
    IN  PCTSTR        InfFileName,
    IN  PCTSTR        InfSectionName,
    IN  PVOID         StringTable,
    IN  LONG          InfClassGuidIndex,
    OUT PDRIVER_NODE *DriverNode
    )
/*++

Routine Description:

    This routine creates a new driver node, and initializes it with
    the supplied information.

Arguments:

    Rank - The rank match of the driver node being created.  This is a
        value in [0..n], where a lower number indicates a higher level of
        compatibility between the driver represented by the node, and the
        device being installed.

    DevDescription - Supplies the description of the device that will be
        supported by this driver.

    DrvDescription - Supplies the description of this driver.

    ProviderName - Supplies the name of the provider of this INF.

    MfgName - Supplies the name of the manufacturer of this device.

    InfDate - Supplies the address of the variable containing the date
        when the INF was last written to.

    InfFileName - Supplies the full name of the INF file for this driver.

    InfSectionName - Supplies the name of the install section in the INF
        that would be used to install this driver.

    StringTable - Supplies the string table that the specified strings are
        to be added to.

    InfClassGuidIndex - Supplies the index into the containing HDEVINFO set's
        GUID table where the class GUID for this INF is stored.

    DriverNode - Supplies the address of a DRIVER_NODE pointer that will
        receive a pointer to the newly-allocated node.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise the
    ERROR_* code is returned.

--*/
{
    PDRIVER_NODE pDriverNode;
    DWORD Err = ERROR_NOT_ENOUGH_MEMORY;
    TCHAR TempString[MAX_PATH];  // an INF path is the longest string we'll store in here.

    //
    // validate the sizes of the strings passed in
    // certain assumptions are made about the strings thoughout
    // but at this point the sizes are not yet within our control
    //
    if(!MYVERIFY(DevDescription &&
                 DrvDescription &&
                 MfgName &&
                 InfFileName &&
                 InfSectionName)) {

        return ERROR_INVALID_DATA;
    }

    if(FAILED(StringCchLength(DevDescription, LINE_LEN, NULL)) ||
       FAILED(StringCchLength(DrvDescription, LINE_LEN, NULL)) ||
       (ProviderName && FAILED(StringCchLength(ProviderName, LINE_LEN, NULL))) ||
       FAILED(StringCchLength(MfgName, LINE_LEN, NULL)) ||
       FAILED(StringCchLength(InfFileName, MAX_PATH, NULL)) ||
       FAILED(StringCchLength(InfSectionName, MAX_SECT_NAME_LEN, NULL)))
    {
        //
        // any of these could potentially cause a buffer overflow later
        // on, so not allowed
        //
        return ERROR_BUFFER_OVERFLOW;
    }

    if(!(pDriverNode = MyMalloc(sizeof(DRIVER_NODE)))) {
        return Err;
    }

    try {
        //
        // Initialize the various fields in the driver node structure.
        //
        ZeroMemory(pDriverNode, sizeof(DRIVER_NODE));

        pDriverNode->Rank = Rank;
        pDriverNode->InfDate = *InfDate;
        pDriverNode->HardwareId = -1;

        pDriverNode->GuidIndex = InfClassGuidIndex;

        //
        // Now, add the strings to the associated string table, and store the
        // string IDs.
        //
        // Cast the DrvDescription string being added case-sensitively as PTSTR
        // instead of PCTSTR.  Case sensitive string additions don't modify the
        // buffer passed in, so we're safe in doing so.
        //
        if((pDriverNode->DrvDescription = pStringTableAddString(StringTable,
                                                                (PTSTR)DrvDescription,
                                                                STRTAB_CASE_SENSITIVE,
                                                                NULL,0)) == -1) {
            leave;
        }

        //
        // For DevDescription, ProviderName, and MfgName, we use the string table IDs to do fast
        // comparisons for driver nodes.  Thus, we need to store case-insensitive IDs.  However,
        // these strings are also used for display, so we have to store them in their case-sensitive
        // form as well.
        //
        // We must first copy the strings into a modifiable buffer, since we're going to need to add
        // them case-insensitively.
        //
        if(FAILED(StringCchCopy(TempString, SIZECHARS(TempString), DevDescription))) {
            Err = ERROR_INVALID_DATA;   // should never fail
            leave;
        }

        if((pDriverNode->DevDescriptionDisplayName = pStringTableAddString(
                                                         StringTable,
                                                         TempString,
                                                         STRTAB_CASE_SENSITIVE,
                                                         NULL,0)) == -1) {
            leave;
        }

        if((pDriverNode->DevDescription = pStringTableAddString(
                                              StringTable,
                                              TempString,
                                              STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                              NULL,0)) == -1) {
            leave;
        }

        if(ProviderName) {
            if(FAILED(StringCchCopy(TempString, SIZECHARS(TempString), ProviderName))) {
                Err = ERROR_INVALID_DATA;   // should never fail
                leave;
            }

            if((pDriverNode->ProviderDisplayName = pStringTableAddString(
                                                        StringTable,
                                                        TempString,
                                                        STRTAB_CASE_SENSITIVE,
                                                        NULL,0)) == -1) {
                leave;
            }

            if((pDriverNode->ProviderName = pStringTableAddString(
                                                StringTable,
                                                TempString,
                                                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                NULL,0)) == -1) {
                leave;
            }

        } else {
            pDriverNode->ProviderName = pDriverNode->ProviderDisplayName = -1;
        }

        if(FAILED(StringCchCopy(TempString, SIZECHARS(TempString), MfgName))) {
            Err = ERROR_INVALID_DATA;   // should never fail
            leave;
        }

        if((pDriverNode->MfgDisplayName = pStringTableAddString(
                                              StringTable,
                                              TempString,
                                              STRTAB_CASE_SENSITIVE,
                                              NULL,0)) == -1) {
            leave;
        }

        if((pDriverNode->MfgName = pStringTableAddString(
                                        StringTable,
                                        TempString,
                                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                        NULL,0)) == -1) {
            leave;
        }

        if(FAILED(StringCchCopy(TempString, SIZECHARS(TempString), InfFileName))) {
            Err = ERROR_INVALID_DATA;   // should never fail
            leave;
        }

        if((pDriverNode->InfFileName = pStringTableAddString(
                                            StringTable,
                                            TempString,
                                            STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                            NULL,0)) == -1) {
            leave;
        }

        //
        // Add INF section name case-sensitively, since we may have a legacy driver node, which requires
        // that the original case be maintained.
        //
        if((pDriverNode->InfSectionName = pStringTableAddString(StringTable,
                                                                (PTSTR)InfSectionName,
                                                                STRTAB_CASE_SENSITIVE,
                                                                NULL,0)) == -1) {
            leave;
        }

        //
        // If we get to here, then we've successfully stored all strings.
        //
        Err = NO_ERROR;

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(Err == NO_ERROR) {
        *DriverNode = pDriverNode;
    } else {
        DestroyDriverNodes(pDriverNode, (PDEVICE_INFO_SET)NULL);
    }

    return Err;
}


BOOL
pRemoveDirectory(
    PTSTR Path
    )
/*++

Routine Description:

    This routine recursively deletes the specified directory and all the
    files in it.  If it encounters some error, it will still delete as many of
    the files/subdirectories as possible.

Arguments:

    Path - Fully-qualified path of directory to remove.

Return Value:

    TRUE - if the directory was sucessfully deleted
    FALSE - if the directory was not successfully deleted
    (Note: if the path to a file is passed to this routine, it will fail)

--*/
{
    PWIN32_FIND_DATA pFindFileData = NULL;
    HANDLE           hFind = INVALID_HANDLE_VALUE;
    PTSTR            FindPath = NULL;
    DWORD            dwAttributes;

    //
    // First, figure out what the path we've been handed represents.
    //
    dwAttributes = GetFileAttributes(Path);

    if(dwAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

        HANDLE          hReparsePoint;

        //
        // We don't want to enumerate files on the other side of a reparse
        // point, we simply want to delete the reparse point itself.
        //
        // NTRAID#NTBUG9-611113-2002/04/28-lonnym - Need to delete reparse point properly
        //
        hReparsePoint = CreateFile(
                           Path,
                           DELETE,
                           FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
                           NULL
                          );

        if(hReparsePoint == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        CloseHandle(hReparsePoint);
        return TRUE;

    } else if(!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        //
        // This is a file--this routine isn't supposed to be called with a
        // path to a file.
        //
        MYASSERT(FALSE);
        return FALSE;
    }

    try {
        //
        // Allocate a scratch buffer (we don't want this on the stack because
        // this is a recursive routine)
        //
        FindPath = MyMalloc(MAX_PATH * sizeof(TCHAR));
        if(!FindPath) {
            leave;
        }

        //
        // Also, allocate a WIN32_FIND_DATA structure (same reason)
        //
        pFindFileData = MyMalloc(sizeof(WIN32_FIND_DATA));
        if(!pFindFileData) {
            leave;
        }

        //
        // Make a copy of the path, and tack \*.* on the end.
        //
        if(FAILED(StringCchCopy(FindPath, MAX_PATH, Path)) ||
           !pSetupConcatenatePaths(FindPath,
                                   TEXT("*.*"),
                                   MAX_PATH,
                                   NULL)) {
            leave;
        }

        hFind = FindFirstFile(FindPath, pFindFileData);

        if(hFind != INVALID_HANDLE_VALUE) {

            PTSTR  FilenamePart;
            size_t FilenamePartSize;

            //
            // Get a pointer to the filename part at the end of the path so
            // that we can replace it with each filename/directory as we
            // enumerate them in-turn.
            //
            FilenamePart = (PTSTR)pSetupGetFileTitle(FindPath);

            //
            // Also, compute the remaining space in the buffer so we don't
            // overrun.
            //
            FilenamePartSize = MAX_PATH - (FilenamePart - FindPath);

            do {

                if(FAILED(StringCchCopy(FilenamePart,
                                        FilenamePartSize,
                                        pFindFileData->cFileName))) {
                    //
                    // We ran across a file/directory that blew our path length
                    // past the MAX_PATH boundary.  Skip it and move on.
                    //
                    continue;
                }

                //
                // If this is a directory...
                //
                if(pFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    //
                    // ...and it's not "." or ".."
                    //
                    if(_tcsicmp(pFindFileData->cFileName, TEXT(".")) &&
                       _tcsicmp(pFindFileData->cFileName, TEXT(".."))) {
                        //
                        // ...recursively delete it
                        //
                        pRemoveDirectory(FindPath);
                    }

                } else {
                    //
                    // This is a file
                    //
                    SetFileAttributes(FindPath, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(FindPath);
                }

            } while(FindNextFile(hFind, pFindFileData));
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    if(hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
    }

    if(pFindFileData) {
        MyFree(pFindFileData);
    }

    if(FindPath) {
        MyFree(FindPath);
    }

    //
    // Remove the root directory
    // (We didn't bother to track intermediate results, because RemoveDirectory
    // will fail if the directory specified is non-empty.  Thus, this single
    // API call serves as the definitive report card on whether we were
    // successful.)
    //
    return RemoveDirectory(Path);
}


BOOL
RemoveCDMDirectory(
  IN PTSTR FullPathName
  )
/*++

Routine Description:

    This routine deletes the Code Download Manager temporary directory.

    Note that we assume that this is a full path (including a filename at the
    end).  We will strip off the filename and remove the entire directory where
    this file (the INF file) is located.

Arguments:

    FullPathName - Full path to a file in the directory that might be deleted.

Return Value:

    TRUE - if the directory containing the file was sucessfully deleted.
    FALSE - if the directory containing the file was not successfully deleted.

--*/
{
    TCHAR Directory[MAX_PATH];
    PTSTR FileName;

    //
    // First strip off the file name so we are just left with the directory.
    //
    if(FAILED(StringCchCopy(Directory, SIZECHARS(Directory), FullPathName))) {
        return FALSE;
    }

    FileName = (PTSTR)pSetupGetFileTitle((PCTSTR)Directory);
    *FileName = TEXT('\0');

    if(!*Directory) {
        //
        // Then we were handed a simple filename, sans path.
        //
        return FALSE;
    }

    return pRemoveDirectory(Directory);
}


VOID
DestroyDriverNodes(
    IN PDRIVER_NODE DriverNode,
    IN PDEVICE_INFO_SET pDeviceInfoSet OPTIONAL
    )
/*++

Routine Description:

    This routine destroys the specified driver node linked list, freeing
    all resources associated with it.

Arguments:

    DriverNode - Supplies a pointer to the head of the driver node linked
    list to be destroyed.

    pDeviceInfoSet - Optionally, supplies a pointer to the device info set
        containing the driver node list to be destroyed.  This parameter is
        only needed if one or more of the driver nodes may have come from a
        Windows Update package, and thus require their local source directory
        to be removed.

Return Value:

    None.

--*/
{
    PDRIVER_NODE NextNode;
    PTSTR szInfFileName;

    while(DriverNode) {

        NextNode = DriverNode->Next;

        if(DriverNode->CompatIdList) {
            MyFree(DriverNode->CompatIdList);
        }

        //
        // If this driver was from the Internet then we want to delete the
        // directory where it lives.
        //
        if(pDeviceInfoSet && (DriverNode->Flags & PDNF_CLEANUP_SOURCE_PATH)) {

            szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                     DriverNode->InfFileName
                                                    );

            if(szInfFileName) {
                RemoveCDMDirectory(szInfFileName);
            }
        }

        MyFree(DriverNode);

        DriverNode = NextNode;
    }
}


PTSTR
GetFullyQualifiedMultiSzPathList(
    IN PCTSTR PathList
    )
/*++

Routine Description:

    This routine takes a list of semicolon-delimited directory paths, and
    returns a newly-allocated buffer containing a multi-sz list of those paths,
    fully qualified.  The buffer returned from this routine must be freed with
    MyFree().

Arguments:

    PathList - list of directories to be converted (must be less than MAX_PATH)

Return Value:

    If the function succeeds, the return value is a pointer to the allocated buffer
    containing the multi-sz list.

    If failure (e.g., due to out-of-memory), the return value is NULL.

--*/
{
    TCHAR PathListBuffer[MAX_PATH + 1];  // extra char 'cause this is a multi-sz list
    PTSTR CurPath, CharPos, NewBuffer, TempPtr;
    DWORD RequiredSize;
    BOOL Success;

    //
    // First, convert this semicolon-delimited list into a multi-sz list.
    //
    if(FAILED(StringCchCopy(PathListBuffer,
                            SIZECHARS(PathListBuffer) - 1, // leave room for extra null
                            PathList))) {
        return NULL;
    }
    RequiredSize = DelimStringToMultiSz(PathListBuffer,
                                        SIZECHARS(PathListBuffer),
                                        TEXT(';')
                                       );

    if(!(NewBuffer = MyMalloc((RequiredSize * MAX_PATH * sizeof(TCHAR)) + sizeof(TCHAR)))) {
        return NULL;
    }

    Success = TRUE; // assume success from here on out.

    try {
        //
        // Now fill in the buffer with the fully-qualified directory paths.
        //
        CharPos = NewBuffer;

        for(CurPath = PathListBuffer; *CurPath; CurPath += (lstrlen(CurPath) + 1)) {

            RequiredSize = GetFullPathName(CurPath,
                                           MAX_PATH,
                                           CharPos,
                                           &TempPtr
                                          );
            if(!RequiredSize || (RequiredSize >= MAX_PATH)) {
                //
                // If we start failing because MAX_PATH isn't big enough
                // anymore, we wanna know about it!
                //
                MYASSERT(RequiredSize < MAX_PATH);
                Success = FALSE;
                leave;
            }

            CharPos += (RequiredSize + 1);
        }

        *(CharPos++) = TEXT('\0');  // add extra NULL to terminate the multi-sz list.

        //
        // Trim this buffer down to just the size required (this should never
        // fail, but it's no big deal if it does).
        //
        if(TempPtr = MyRealloc(NewBuffer, (DWORD)((PBYTE)CharPos - (PBYTE)NewBuffer))) {
            NewBuffer = TempPtr;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        Success = FALSE;
    }

    if(!Success) {
        MyFree(NewBuffer);
        NewBuffer = NULL;
    }

    return NewBuffer;
}


BOOL
InitMiniIconList(
    VOID
    )
/*++

Routine Description:

    This routine initializes the global mini-icon list, including setting up
    the synchronization lock.  When this global structure is no longer needed,
    DestroyMiniIconList must be called.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is TRUE, otherwise it is FALSE.

--*/
{
    ZeroMemory(&GlobalMiniIconList, sizeof(MINI_ICON_LIST));
    return InitializeSynchronizedAccess(&GlobalMiniIconList.Lock);
}


BOOL
DestroyMiniIconList(
    VOID
    )
/*++

Routine Description:

    This routine destroys the global mini-icon list created by a call to
    InitMiniIconList.

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is TRUE, otherwise it is FALSE.

--*/
{
    if(LockMiniIconList(&GlobalMiniIconList)) {
        DestroyMiniIcons();
        DestroySynchronizedAccess(&GlobalMiniIconList.Lock);
        return TRUE;
    }

    return FALSE;
}


DWORD
GetModuleEntryPoint(
    IN     HKEY                    hk,                    OPTIONAL
    IN     LPCTSTR                 RegistryValue,
    IN     LPCTSTR                 DefaultProcName,
    OUT    HINSTANCE              *phinst,
    OUT    FARPROC                *pEntryPoint,
    OUT    HANDLE                 *pFusionContext,
    OUT    BOOL                   *pMustAbort,            OPTIONAL
    IN     PSETUP_LOG_CONTEXT      LogContext,            OPTIONAL
    IN     HWND                    Owner,                 OPTIONAL
    IN     CONST GUID             *DeviceSetupClassGuid,  OPTIONAL
    IN     SetupapiVerifyProblem   Problem,
    IN     LPCTSTR                 DeviceDesc,            OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   NoUI,
    IN OUT PVERIFY_CONTEXT         VerifyContext          OPTIONAL
    )
/*++

Routine Description:

    This routine is used to retrieve the procedure address of a specified
    function in a specified module.

Arguments:

    hk - Optionally, supplies an open registry key that contains a value entry
        specifying the module (and optionally, the entry point) to be retrieved.
        If this parameter is not specified (set to INVALID_HANDLE_VALUE), then
        the RegistryValue parameter is interpreted as the data itself, instead
        of the value containing the entry.

    RegistryValue - If hk is supplied, this specifies the name of the registry
        value that contains the module and entry point information.  Otherwise,
        it contains the actual data specifying the module/entry point to be
        used.

    DefaultProcName - Supplies the name of a default procedure to use if one
        is not specified in the registry value.

    phinst - Supplies the address of a variable that receives a handle to the
        specified module, if it is successfully loaded and the entry point found.

    pEntryPoint - Supplies the address of a function pointer that receives the
        specified entry point in the loaded module.

    pFusionContext - Supplies the address of a handle that receives a fusion
        context for the dll if the dll has a manifest, NULL otherwise.

    pMustAbort - Optionally, supplies the address of a boolean variable that is
        set upon return to indicate whether a failure (i.e., return code other
        than NO_ERROR) should abort the device installer action underway.  This
        variable is always set to FALSE when the function succeeds.

        If this argument is not supplied, then the arguments below are ignored.

    LogContext - Optionally, supplies the log context to be used when logging
        entries into the setupapi logfile.  Not used if pMustAbort isn't
        specified.

    Owner - Optionally, supplies window to own driver signing dialogs, if any.
        Not used if pMustAbort isn't specified.

    DeviceSetupClassGuid - Optionally, supplies the address of a GUID that
        indicates the device setup class associated with this operation.  This
        is used for retrieval of validation platform information, as well as
        for retrieval of the DeviceDesc to be used for driver signing errors
        (if the caller doesn't specify a DeviceDesc).  Not used if pMustAbort
        isn't specified.

    Problem - Supplies the problem type to use if driver signing error occurs.
        Not used if pMustAbort isn't specified.

    DeviceDesc - Optionally, supplies the device description to use if driver
        signing error occurs.  Not used if pMustAbort isn't specified.

    DriverSigningPolicy - Supplies policy to be employed if a driver signing
        error is encountered.  Not used if pMustAbort isn't specified.

    NoUI - Set to true if driver signing popups are to be suppressed (e.g.,
        because the user has previously responded to a warning dialog and
        elected to proceed.  Not used if pMustAbort isn't specified.

    VerifyContext - optionally, supplies the address of a structure that caches
        various verification context handles.  These handles may be NULL (if
        not previously acquired, and they may be filled in upon return (in
        either success or failure) if they were acquired during the processing
        of this verification request.  It is the caller's responsibility to
        free these various context handles when they are no longer needed by
        calling pSetupFreeVerifyContextMembers.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the specified value entry could not be found, the return value is
    ERROR_DI_DO_DEFAULT.
    If any other error is encountered, an ERROR_* code is returned.

Remarks:

    This function is useful for loading a class installer or property provider,
    and receiving the procedure address specified.  The syntax of the registry
    entry is: value=dll[,proc name] where dll is the name of the module to load,
    and proc name is an optional procedure to search for.  If proc name is not
    specified, the procedure specified by DefaultProcName will be used.

--*/
{
    DWORD Err = ERROR_INVALID_DATA; // relevant only if we execute 'finally' due to exception
    DWORD RegDataType;
    size_t BufferSize;
    DWORD  RegBufferSize;
    TCHAR TempBuffer[MAX_PATH];
    TCHAR ModulePath[MAX_PATH];
    SPFUSIONINSTANCE spFusionInstance;
    CHAR ProcBuffer[MAX_PATH*sizeof(TCHAR)];
    PTSTR StringPtr;
    PSTR  ProcName;   // ANSI-only, because it's used for GetProcAddress.
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform = NULL;
    PTSTR LocalDeviceDesc = NULL;
    HRESULT hr;
    BOOL bLeaveFusionContext = FALSE;

    *phinst = NULL;
    *pEntryPoint = NULL;
    *pFusionContext = NULL;

    if(pMustAbort) {
        *pMustAbort = FALSE;
    }

    if(hk != INVALID_HANDLE_VALUE) {
        //
        // See if the specified value entry is present (and of the right
        // data type).
        //
        RegBufferSize = sizeof(TempBuffer);
        if((RegQueryValueEx(hk,
                            RegistryValue,
                            NULL,
                            &RegDataType,
                            (PBYTE)TempBuffer,
                            &RegBufferSize) != ERROR_SUCCESS) ||
           (RegDataType != REG_SZ)) {

            return ERROR_DI_DO_DEFAULT;
        }
        //
        // number of characters taken up by string -
        // string could be badly formed in registry
        //
        hr = StringCchLength(TempBuffer,RegBufferSize/sizeof(TCHAR),&BufferSize);
        if(FAILED(hr)) {
            return HRESULT_CODE(hr);
        }
        BufferSize++; // including null

    } else {
        //
        // Copy the specified data into the buffer as if we'd just retrieved it
        // from the registry.
        //
        hr = StringCchCopyEx(TempBuffer,
                             SIZECHARS(TempBuffer),
                             RegistryValue,
                             NULL,
                             &BufferSize,
                             0
                            );
        if(FAILED(hr)) {
            return HRESULT_CODE(hr);
        }

        //
        // StringCchCopyEx gives us the number of characters remaining in the
        // buffer (including the terminating NULL), but we want to know the
        // number of characters taken up by the string (including terminating
        // NULL).
        //
        BufferSize = SIZECHARS(TempBuffer) - BufferSize + 1;
    }

    hr = StringCchCopy(ModulePath,
                       SIZECHARS(ModulePath),
                       SystemDirectory
                      );

    if(!MYVERIFY(SUCCEEDED(hr))) {
        // this should never fail!
        return HRESULT_CODE(hr);
    }

    //
    // Find the beginning of the entry point name, if present.
    //
    for(StringPtr = TempBuffer + (BufferSize - 2);
        StringPtr >= TempBuffer;
        StringPtr--) {

        if(*StringPtr == TEXT(',')) {
            *(StringPtr++) = TEXT('\0');
            break;
        }
        //
        // If we hit a double-quote mark, then set the character pointer
        // to the beginning of the string so we'll terminate the search.
        //
        if(*StringPtr == TEXT('\"')) {
            StringPtr = TempBuffer;
        }
    }

    if(StringPtr > TempBuffer) {
        //
        // We encountered a comma in the string.  Scan forward from that point
        // to ensure that there aren't any leading spaces in the entry point
        // name.
        //
        for(; (*StringPtr && IsWhitespace(StringPtr)); StringPtr++);

        if(!(*StringPtr)) {
            //
            // Then there was no entry point given after all.
            //
            StringPtr = TempBuffer;
        }
    }

    pSetupConcatenatePaths(ModulePath, TempBuffer, SIZECHARS(ModulePath), NULL);

    try {
        //
        // If requested, check the digital signature of this module before
        // loading it.
        //
        // NTRAID#NTBUG9-611189-2002/04/29-lonnym - Need to also validate linked-against DLLs
        //
        if(pMustAbort) {
            //
            // Retrieve validation information relevant to this device setup
            // class.
            //
            IsInfForDeviceInstall(LogContext,
                                  DeviceSetupClassGuid,
                                  NULL,
                                  DeviceDesc ? NULL : &LocalDeviceDesc,
                                  &ValidationPlatform,
                                  NULL,
                                  NULL,
                                  FALSE
                                 );

            Err = _VerifyFile(LogContext,
                              VerifyContext,
                              NULL,
                              NULL,
                              0,
                              pSetupGetFileTitle(ModulePath),
                              ModulePath,
                              NULL,
                              NULL,
                              FALSE,
                              ValidationPlatform,
                              (VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL
                             );

            if(Err != NO_ERROR) {

                if(!_HandleFailedVerification(Owner,
                                              Problem,
                                              ModulePath,
                                              (DeviceDesc ? DeviceDesc
                                                          : LocalDeviceDesc),
                                              DriverSigningPolicy,
                                              NoUI,
                                              Err,
                                              LogContext,
                                              NULL,
                                              NULL,
                                              NULL)) {
                    //
                    // The operation should be aborted.
                    //
                    *pMustAbort = TRUE;
                    MYASSERT(Err != NO_ERROR);
                    leave;
                }
            }
        }

        *pFusionContext = spFusionContextFromModule(ModulePath);
        bLeaveFusionContext = spFusionEnterContext(*pFusionContext,
                                                   &spFusionInstance
                                                  );

        Err = GLE_FN_CALL(NULL,
                          *phinst = LoadLibraryEx(ModulePath,
                                                  NULL,
                                                  LOAD_WITH_ALTERED_SEARCH_PATH)
                         );

        if(Err != NO_ERROR) {

            if(LogContext) {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_MOD_LOADFAIL_ERROR,
                    NULL,
                    ModulePath);
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
            }
            leave;
        }

        //
        // We've successfully loaded the module, now get the entry point.
        // (GetProcAddress is an ANSI-only API, so we have to convert the proc
        // name to ANSI here.
        //
        ProcName = ProcBuffer;

        if(StringPtr > TempBuffer) {
            //
            // An entry point was specified in the value entry--use it instead
            // of the default provided.
            //
            WideCharToMultiByte(CP_ACP,
                                0,
                                StringPtr,
                                -1,
                                ProcName,
                                sizeof(ProcBuffer),
                                NULL,
                                NULL
                               );
        } else {
            //
            // No entry point was specified--use default.
            //
            WideCharToMultiByte(CP_ACP,
                                0,
                                DefaultProcName,
                                -1,
                                ProcName,
                                sizeof(ProcBuffer),
                                NULL,
                                NULL
                               );
        }

        Err = GLE_FN_CALL(NULL,
                          *pEntryPoint = (FARPROC)GetProcAddress(*phinst,
                                                                 ProcName)
                         );

        if(Err != NO_ERROR) {

            FreeLibrary(*phinst);
            *phinst = NULL;
            if(LogContext) {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                    MSG_LOG_MOD_PROCFAIL_ERROR,
                    NULL,
                    ModulePath,
                    (StringPtr > TempBuffer ? StringPtr : DefaultProcName));
                WriteLogError(
                    LogContext,
                    DRIVER_LOG_ERROR,
                    Err);
            }
            leave;
        }

        if(LogContext) {
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_VERBOSE1,
                MSG_LOG_MOD_LIST_PROC,
                NULL,
                ModulePath,
                (StringPtr > TempBuffer ? StringPtr : DefaultProcName));
        }

    } finally {
        if((Err != NO_ERROR) && *phinst) {
            FreeLibrary(*phinst);
            *phinst = NULL;
        }
        if(bLeaveFusionContext) {
            spFusionLeaveContext(&spFusionInstance);
        }
        if(Err != NO_ERROR) {
            spFusionKillContext(*pFusionContext);
            *pFusionContext = NULL;
        }
        //
        // Free buffers we may have retrieved when calling
        // IsInfForDeviceInstall().
        //
        if(LocalDeviceDesc) {
            MyFree(LocalDeviceDesc);
        }
        if(ValidationPlatform) {
            MyFree(ValidationPlatform);
        }
    }

    return Err;
}


DWORD
pSetupGuidFromString(
    IN  PCTSTR GuidString,
    OUT LPGUID Guid
    )
/*++

Routine Description:

    This routine converts the character representation of a GUID into its
    binary form (a GUID struct).  The GUID is in the following form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where 'x' is a hexadecimal digit.

Arguments:

    GuidString - Supplies a pointer to the null-terminated GUID string.

    Guid - Supplies a pointer to the variable that receives the GUID structure.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, the return value is RPC_S_INVALID_STRING_UUID.

--*/
{
    TCHAR UuidBuffer[GUID_STRING_LEN - 1];
    size_t BufferSize;

    //
    // Since we're using a RPC UUID routine, we need to strip off the
    // surrounding curly braces first.
    //
    if(*GuidString++ != TEXT('{')) {
        return RPC_S_INVALID_STRING_UUID;
    }

    if(FAILED(StringCchCopyEx(UuidBuffer,
                            SIZECHARS(UuidBuffer),
                            GuidString,
                            NULL,
                            &BufferSize,
                            0))) {

        return RPC_S_INVALID_STRING_UUID;
    }
    //
    // StringCchCopyEx gives us the number of characters remaining in the
    // buffer (including the terminating NULL), but we want to know the number
    // of characters taken up by the string (excluding terminating NULL, just
    // like lstrlen gives).
    //
    BufferSize = SIZECHARS(UuidBuffer) - BufferSize;

    if((BufferSize != (GUID_STRING_LEN - 2)) ||
       (UuidBuffer[GUID_STRING_LEN - 3] != TEXT('}'))) {

        return RPC_S_INVALID_STRING_UUID;
    }

    UuidBuffer[GUID_STRING_LEN - 3] = TEXT('\0');

    return ((UuidFromString(UuidBuffer, Guid) == RPC_S_OK) ? NO_ERROR : RPC_S_INVALID_STRING_UUID);
}


DWORD
pSetupStringFromGuid(
    IN  CONST GUID *Guid,
    OUT PTSTR       GuidString,
    IN  DWORD       GuidStringSize
    )
/*++

Routine Description:

    This routine converts a GUID into a null-terminated string which represents
    it.  This string is of the form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where x represents a hexadecimal digit.

    This routine comes from ole32\common\ccompapi.cxx.  It is included here to
    avoid linking to ole32.dll.  (The RPC version allocates memory, so it was
    avoided as well.)

Arguments:

    Guid - Supplies a pointer to the GUID whose string representation is
        to be retrieved.

    GuidString - Supplies a pointer to character buffer that receives the
        string.  This buffer must be _at least_ 39 (GUID_STRING_LEN) characters
        long.

    GuidStringSize - Supplies the size, in characters, of the GuidString buffer.

Return Value:

    If success, the return value is NO_ERROR.
    if failure, the return value is ERROR_INSUFFICIENT_BUFFER (the only way
    this can fail is due to being handed too small a buffer).

--*/
{
    CONST BYTE *GuidBytes;
    INT i;

    if(GuidStringSize < GUID_STRING_LEN) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    GuidBytes = (CONST BYTE *)Guid;

    *GuidString++ = TEXT('{');

    for(i = 0; i < sizeof(GuidMap); i++) {

        if(GuidMap[i] == '-') {
            *GuidString++ = TEXT('-');
        } else {
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *GuidString++ = TEXT('}');
    *GuidString   = TEXT('\0');

    return NO_ERROR;
}


BOOL
pSetupIsGuidNull(
    IN CONST GUID *Guid
    )
{
    return IsEqualGUID(Guid, &GUID_NULL);
}


VOID
GetRegSubkeysFromDeviceInterfaceName(
    IN OUT PTSTR  DeviceInterfaceName,
    OUT    PTSTR *SubKeyName
    )
/*++

Routine Description:

    This routine breaks up a device interface path into 2 parts--the symbolic
    link name and the (optional) reference string.  It then munges the symbolic
    link name part into the subkey name as it appears under the interface class
    key.

    NOTE: The algorithm for parsing the device interface name must be kept in
    sync with the kernel-mode implementation of IoOpenDeviceInterfaceRegistryKey.

Arguments:

    DeviceInterfaceName - Supplies the name of the device interface to be
        parsed into registry subkey names.  Upon return, this name will have
        been terminated at the backslash preceding the reference string (if
        there is one), and all backslashes will have been replaced with '#'
        characters.

    SubKeyName - Supplies the address of a character pointer that receives the
        address of the reference string (within the DeviceInterfaceName string).
        If there is no reference string, this parameter will be filled in with
        NULL.

Return Value:

    none

--*/
{
    PTSTR p;

    //
    // Scan across the name to find the beginning of the refstring component (if
    // there is one).  The format of the symbolic link name is:
    //
    // \\?\munged_name[\refstring]
    //
    MYASSERT(DeviceInterfaceName[0] == TEXT('\\'));
    MYASSERT(DeviceInterfaceName[1] == TEXT('\\'));
    //
    // Allow both '\\.\' and '\\?\' for now, since Memphis currently uses the former.
    //
    MYASSERT((DeviceInterfaceName[2] == TEXT('?')) || (DeviceInterfaceName[2] == TEXT('.')));
    MYASSERT(DeviceInterfaceName[3] == TEXT('\\'));

    p = _tcschr(&(DeviceInterfaceName[4]), TEXT('\\'));

    if(p) {
        *p = TEXT('\0');
        *SubKeyName = p + 1;
    } else {
        *SubKeyName = NULL;
    }

    for(p = DeviceInterfaceName; *p; p++) {
        if(*p == TEXT('\\')) {
            *p = TEXT('#');
        }
    }
}


LONG
OpenDeviceInterfaceSubKey(
    IN     HKEY   hKeyInterfaceClass,
    IN     PCTSTR DeviceInterfaceName,
    IN     REGSAM samDesired,
    OUT    PHKEY  phkResult,
    OUT    PTSTR  OwningDevInstName,    OPTIONAL
    IN OUT PDWORD OwningDevInstNameSize OPTIONAL
    )
/*++

Routine Description:

    This routine munges the specified device interface symbolic link name into
    a subkey name that is then opened underneath the specified interface class
    key.

    NOTE:  This munging algorithm must be kept in sync with the kernel-mode
    routines that generate these keys (e.g., IoRegisterDeviceInterface).

Arguments:

    hKeyInterfaceClass - Supplies the handle of the currently-open interface
        class key under which the device interface subkey is to be opened.

    DeviceInterfaceName - Supplies the symbolic link name ('\\?\' form) of the
        device interface for which the subkey is to be opened.

    samDesired - Specifies the access desired on the key to be opened.

    phkResult - Supplies the address of a variable that receives the registry
        handle, if successfully opened.

    OwningDevInstName - Optionally, supplies a character buffer that receives
        the name of the device instance that owns this interface.

    OwningDevInstNameSize - Optionally, supplies the address of a variable
        that, on input, contains the size of the OwningDevInstName buffer (in
        bytes).  Upon return, it receives that actual number of bytes stored in
        OwningDevInstName (including terminating NULL).

Return Value:

    If success, the return value is ERROR_SUCCESS.
    if failure, the return value is a Win32 error code indicating the cause of
    failure.  Most likely errors are ERROR_NOT_ENOUGH_MEMORY, ERROR_MORE_DATA,
    or ERROR_NO_SUCH_DEVICE_INTERFACE.

--*/
{
    size_t BufferLength;
    LONG Err;
    PTSTR TempBuffer = NULL;
    PTSTR RefString = NULL;
    PTSTR ValueBuffer = NULL;
    TCHAR NoRefStringSubKeyName[2];
    HKEY hKey;
    DWORD RegDataType;

    Err = ERROR_SUCCESS;
    hKey = INVALID_HANDLE_VALUE;
    TempBuffer = NULL;

    try {
        //
        // We need to allocate a temporary buffer to hold the symbolic link
        // name while we munge it.  Since device interface names are variable-
        // length, the only thing we can say with certainty about their size is
        // that they must fit in a UNICODE_STRING buffer (maximum size is 32K
        // characters).
        //
        if(FAILED(StringCchLength(DeviceInterfaceName,
                                  UNICODE_STRING_MAX_CHARS,
                                  &BufferLength))) {

            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        BufferLength = (BufferLength + 1) * sizeof(TCHAR);

        if(!(TempBuffer = MyMalloc(BufferLength))) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        CopyMemory(TempBuffer, DeviceInterfaceName, BufferLength);

        //
        // Parse this device interface name into the (munged) symbolic link
        // name and (optional) refstring.
        //
        GetRegSubkeysFromDeviceInterfaceName(TempBuffer, &RefString);

        //
        // Now open the symbolic link subkey under the interface class key.
        //
        if(ERROR_SUCCESS != RegOpenKeyEx(hKeyInterfaceClass,
                                         TempBuffer,
                                         0,
                                         KEY_READ,
                                         &hKey)) {
            //
            // Ensure the key handle is still invalid, so we won't try to close
            // it later.
            //
            hKey = INVALID_HANDLE_VALUE;
            Err = ERROR_NO_SUCH_DEVICE_INTERFACE;
            leave;
        }

        //
        // If the caller requested it, retrieve the device instance that owns
        // this interface.
        //
        if(OwningDevInstName) {

            Err = RegQueryValueEx(hKey,
                                 pszDeviceInstance,
                                 NULL,
                                 &RegDataType,
                                 (LPBYTE)OwningDevInstName,
                                 OwningDevInstNameSize
                                 );

            if((Err != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
                if (Err != ERROR_MORE_DATA) {
                    Err = ERROR_NO_SUCH_DEVICE_INTERFACE;
                }
                leave;
            }
        }

        //
        // Now open up the subkey representing the particular 'instance' of
        // this interface (this is based on the refstring).
        //
        if(RefString) {
            //
            // Back up the pointer one character.  We know we're somewhere
            // within TempBuffer (but not at the beginning) so this is safe.
            //
            RefString--;
        } else {
            RefString = NoRefStringSubKeyName;
            NoRefStringSubKeyName[1] = TEXT('\0');
        }
        *RefString = TEXT('#');

        if(ERROR_SUCCESS != RegOpenKeyEx(hKey,
                                         RefString,
                                         0,
                                         samDesired,
                                         phkResult)) {

            Err = ERROR_NO_SUCH_DEVICE_INTERFACE;
            leave;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(TempBuffer) {
        MyFree(TempBuffer);
    }

    if(ValueBuffer) {
        MyFree(ValueBuffer);
    }

    if(hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    return Err;
}


LONG
AddOrGetGuidTableIndex(
    IN PDEVICE_INFO_SET  DeviceInfoSet,
    IN CONST GUID       *ClassGuid,
    IN BOOL              AddIfNotPresent
    )
/*++

Routine Description:

    This routine retrieves the index of a class GUID within the devinfo set's
    GUID list (optionally, adding the GUID if not already present).
    This is used to allow DWORD comparisons instead of 16-byte GUID comparisons
    (and to save space).

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set containing
        the list of class GUIDs for which an index is to be retrieved.

    InterfaceClassGuid - Supplies a pointer to the GUID for which an index is
        to be added/retrieved.

    AddIfNotPresent - If TRUE, the class GUID will be added to the list if it's
        not already there.

Return Value:

    If success, the return value is an index into the devinfo set's GuidTable
    array.

    If failure, the return value is -1.  If adding, this indicates an out-of-
    memory condition.  If simply retrieving, then this indicates that the GUID
    is not in the list.

--*/
{
    LONG i;
    LPGUID NewGuidList;

    for(i = 0; (DWORD)i < DeviceInfoSet->GuidTableSize; i++) {

        if(IsEqualGUID(ClassGuid, &(DeviceInfoSet->GuidTable[i]))) {
            return i;
        }
    }

    if(AddIfNotPresent) {

        NewGuidList = NULL;

        try {

            if(DeviceInfoSet->GuidTable) {
                NewGuidList = MyRealloc(DeviceInfoSet->GuidTable, (i + 1) * sizeof(GUID));
                if(NewGuidList) {
                    DeviceInfoSet->GuidTable = NewGuidList;
                    NewGuidList = NULL;
                } else {
                    i = -1;
                    leave;
                }
            } else {
                NewGuidList = MyMalloc(sizeof(GUID));
                if(NewGuidList) {
                    DeviceInfoSet->GuidTable = NewGuidList;
                    //
                    // We don't want to reset NewGuidList to NULL in this case,
                    // since we may need to free it if we hit an exception.
                    //
                } else {
                    i = -1;
                    leave;
                }
            }

            CopyMemory(&(DeviceInfoSet->GuidTable[i]), ClassGuid, sizeof(GUID));

            NewGuidList = NULL; // from this point on, we don't want this freed

            DeviceInfoSet->GuidTableSize = i + 1;

        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
            i = -1;
        }

        //
        // If we hit an error, free our buffer if it was newly-allocated.
        //
        if(i == -1) {
            if(NewGuidList) {
                MyFree(NewGuidList);
                //
                // We should only need to free the GUID list in the case where
                // we previously had no list.  Since we weren't successful in
                // adding this list, reset the GuidTable pointer (our size
                // should've never been updated, so it'll still report a length
                // of zero).
                //
                MYASSERT(DeviceInfoSet->GuidTableSize == 0);
                DeviceInfoSet->GuidTable = NULL;
            }
        }

    } else {
        //
        // We didn't find the interface class GUID in our list, and we aren't
        // supposed to add it.
        //
        i = -1;
    }

    return i;
}


PINTERFACE_CLASS_LIST
AddOrGetInterfaceClassList(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PDEVINFO_ELEM    DevInfoElem,
    IN LONG             InterfaceClassGuidIndex,
    IN BOOL             AddIfNotPresent
    )
/*++

Routine Description:

    This routine retrieves the device interface list of the specified class
    that is 'owned' by the specified devinfo element.  This list can optionally
    be created if it doesn't already exist.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set containing
        the devinfo element for which a device interface list is to be
        retrieved.

    DevInfoElem - Supplies a pointer to the devinfo element for which an
        interface device list is to be retrieved.

    InterfaceClassGuidIndex - Supplies the index of the interface class GUID
        within the hdevinfo set's InterfaceClassGuidList array.

    AddIfNotPresent - If TRUE, then a new device interface list of the
        specified class will be created for this devinfo element, if it doesn't
        already exist.

Return Value:

    If successful, the return value is a pointer to the requested device
    interface list for this devinfo element.

    If failure, the return value is NULL.  If AddIfNotPresent is TRUE, then
    this indicates an out-of-memory condition, otherwise, it indicates that the
    requested interface class list was not present for the devinfo element.

--*/
{
    DWORD i;
    BOOL succeed = TRUE;
    PINTERFACE_CLASS_LIST NewClassList;

    for(i = 0; i < DevInfoElem->InterfaceClassListSize; i++) {

        if(DevInfoElem->InterfaceClassList[i].GuidIndex == InterfaceClassGuidIndex) {
            return (&(DevInfoElem->InterfaceClassList[i]));
        }
    }

    //
    // The requested interface class list doesn't presently exist for this devinfo element.
    //
    if(AddIfNotPresent) {

        NewClassList = NULL;

        try {

            if(DevInfoElem->InterfaceClassList) {
                NewClassList = MyRealloc(DevInfoElem->InterfaceClassList, (i + 1) * sizeof(INTERFACE_CLASS_LIST));
                if(NewClassList) {
                    DevInfoElem->InterfaceClassList = NewClassList;
                    NewClassList = NULL;
                } else {
                    succeed = FALSE;
                    leave;
                }
            } else {
                NewClassList = MyMalloc(sizeof(INTERFACE_CLASS_LIST));
                if(NewClassList) {
                    DevInfoElem->InterfaceClassList = NewClassList;
                    //
                    // We don't want to reset NewClassList to NULL in this
                    // case, since we may need to free it if we hit an
                    // exception.
                    //
                } else {
                    succeed = FALSE;
                    leave;
                }
            }

            ZeroMemory(&(DevInfoElem->InterfaceClassList[i]), sizeof(INTERFACE_CLASS_LIST));

            DevInfoElem->InterfaceClassList[i].GuidIndex = InterfaceClassGuidIndex;

            NewClassList = NULL; // from this point on, we don't want this freed

            DevInfoElem->InterfaceClassListSize = i + 1;

        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
            succeed = FALSE;
        }

        //
        // If we hit an error, free our buffer if it was newly-allocated
        //
        if(!succeed) {
            if(NewClassList) {
                MyFree(NewClassList);
                //
                // We should only need to free the class list in the case where
                // we previously had no list.  Since we weren't successful in
                // adding this list, reset the InterfaceClassList pointer (our
                // size should've never been updated, so it'll still report a
                // length of zero).
                //
                MYASSERT(DevInfoElem->InterfaceClassListSize == 0);
                DevInfoElem->InterfaceClassList = NULL;
            }
        }

    } else {
        //
        // We aren't supposed to add the class list if it doesn't already exist.
        //
        succeed = FALSE;
    }

    return (succeed ? &(DevInfoElem->InterfaceClassList[i]) : NULL);
}


BOOL
DeviceInterfaceDataFromNode(
    IN  PDEVICE_INTERFACE_NODE     DeviceInterfaceNode,
    IN  CONST GUID                *InterfaceClassGuid,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData
    )
/*++

Routine Description:

    This routine fills in a PSP_DEVICE_INTERFACE_DATA structure based
    on the information in the supplied device interface node.

    Note:  The supplied DeviceInterfaceData structure must have its cbSize
    field filled in correctly, or the call will fail.

Arguments:

    DeviceInterfaceNode - Supplies the address of the device interface node
        to be used in filling in the device interface data buffer.

    InterfaceClassGuid - Supplies a pointer to the class GUID for this
        device interface.

    DeviceInterfaceData - Supplies the address of the buffer to retrieve
        the device interface data.

Return Value:

    If the function succeeds, the return value is TRUE, otherwise, it
    is FALSE.

--*/
{
    if(DeviceInterfaceData->cbSize != sizeof(SP_DEVICE_INTERFACE_DATA)) {
        return FALSE;
    }

    CopyMemory(&(DeviceInterfaceData->InterfaceClassGuid),
               InterfaceClassGuid,
               sizeof(GUID)
              );

    DeviceInterfaceData->Flags = DeviceInterfaceNode->Flags;

    DeviceInterfaceData->Reserved = (ULONG_PTR)DeviceInterfaceNode;

    return TRUE;
}


PDEVINFO_ELEM
FindDevInfoElemForDeviceInterface(
    IN PDEVICE_INFO_SET          DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    )
/*++

Routine Description:

    This routine searches through all elements of a device information
    set, looking for one that corresponds to the devinfo element pointer
    stored in the OwningDevInfoElem backpointer of the device interface
    node referenced in the Reserved field of the device interface data.  If a
    match is found, a pointer to the device information element is returned.

Arguments:

    DeviceInfoSet - Specifies the set to be searched.

    DeviceInterfaceData - Supplies a pointer to the device interface data
        for which the corresponding devinfo element is to be returned.

Return Value:

    If a device information element is found, the return value is a
    pointer to that element, otherwise, the return value is NULL.

--*/
{
    PDEVINFO_ELEM DevInfoElem;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;

    if(DeviceInterfaceData->cbSize != sizeof(SP_DEVICE_INTERFACE_DATA)) {
        return NULL;
    }

    //
    // The Reserved field contains a pointer to the underlying device interface
    // node.
    //
    DeviceInterfaceNode = (PDEVICE_INTERFACE_NODE)(DeviceInterfaceData->Reserved);

    for(DevInfoElem = DeviceInfoSet->DeviceInfoHead;
        DevInfoElem;
        DevInfoElem = DevInfoElem->Next) {

        if(DevInfoElem == DeviceInterfaceNode->OwningDevInfoElem) {

            return DevInfoElem;
        }
    }

    return NULL;
}


DWORD
MapCrToSpErrorEx(
    IN CONFIGRET CmReturnCode,
    IN DWORD     Default,
    IN BOOL      BackwardCompatible
    )
/*++

Routine Description:

    This routine maps some CM error return codes to setup api (Win32) return
    codes, and maps everything else to the value specied by Default.

Arguments:

    CmReturnCode - Specifies the ConfigMgr return code to be mapped.

    Default - Specifies the default value to use if no explicit mapping
        applies.

    BackwardCompatible - Supplies a boolean indicating whether the mapping
        returned must be compatible with behavior of previous OSes.  For
        example, due to an original oversight in defining this mapping, the
        CR_NO_SUCH_VALUE code ended up mapping to the default.  As this is a
        common/important value (used to signal absence of a property, end of an
        enumeration of items, etc.), the mapping cannot be changed now.
        Existing APIs that used this old mapping should specify TRUE here to
        maintain the old behavior.  New APIs should specify FALSE, and this
        routine should be kept in sync with any additions to the CONFIGRET set
        of errors.

Return Value:

    Setup API (Win32) error code.

--*/
{
    switch(CmReturnCode) {

        case CR_SUCCESS :
            return NO_ERROR;

        case CR_CALL_NOT_IMPLEMENTED :
            return ERROR_CALL_NOT_IMPLEMENTED;

        case CR_OUT_OF_MEMORY :
            return ERROR_NOT_ENOUGH_MEMORY;

        case CR_INVALID_POINTER :
            return ERROR_INVALID_USER_BUFFER;

        case CR_INVALID_DEVINST :
            return ERROR_NO_SUCH_DEVINST;

        case CR_INVALID_DEVICE_ID :
            return ERROR_INVALID_DEVINST_NAME;

        case CR_ALREADY_SUCH_DEVINST :
            return ERROR_DEVINST_ALREADY_EXISTS;

        case CR_INVALID_REFERENCE_STRING :
            return ERROR_INVALID_REFERENCE_STRING;

        case CR_INVALID_MACHINENAME :
            return ERROR_INVALID_MACHINENAME;

        case CR_REMOTE_COMM_FAILURE :
            return ERROR_REMOTE_COMM_FAILURE;

        case CR_MACHINE_UNAVAILABLE :
            return ERROR_MACHINE_UNAVAILABLE;

        case CR_NO_CM_SERVICES :
            return ERROR_NO_CONFIGMGR_SERVICES;

        case CR_ACCESS_DENIED :
            return ERROR_ACCESS_DENIED;

        case CR_NOT_DISABLEABLE :
            return ERROR_NOT_DISABLEABLE;

        case CR_NO_SUCH_REGISTRY_KEY :
            return ERROR_KEY_DOES_NOT_EXIST;

        case CR_INVALID_PROPERTY :
            return ERROR_INVALID_REG_PROPERTY;

        case CR_BUFFER_SMALL :
            return ERROR_INSUFFICIENT_BUFFER;

        case CR_REGISTRY_ERROR :
            return ERROR_PNP_REGISTRY_ERROR;

        case CR_NO_SUCH_VALUE :
            if(BackwardCompatible) {
                return Default;
            } else {
                return ERROR_NOT_FOUND;
            }

        default :
            return Default;
    }
}


LPQUERY_SERVICE_LOCK_STATUS GetServiceLockStatus(
    IN SC_HANDLE SCMHandle
    )
/*++

Routine Description:

    Obtain service lock status - called when service is locked

Arguments:

    SCMHandle - supplies a handle to the SCM to lock

Return Value:

    NULL if failed (GetLastError contains error) otherwise buffer
    allocated by MyMalloc

--*/
{
    LPQUERY_SERVICE_LOCK_STATUS LockStatus = NULL;
    DWORD BufferSize;
    DWORD ReqBufferSize;
    DWORD Err;

    try {
        //
        // Choose an initial size for our buffer that should accommodate most
        // scenarios.
        //
        BufferSize = sizeof(QUERY_SERVICE_LOCK_STATUS) + (MAX_PATH * sizeof(TCHAR));

        while((LockStatus = MyMalloc(BufferSize)) != NULL) {

            Err = GLE_FN_CALL(FALSE,
                              QueryServiceLockStatus(SCMHandle,
                                                     LockStatus,
                                                     BufferSize,
                                                     &ReqBufferSize)
                             );

            if(Err == NO_ERROR) {
                leave;
            }

            MyFree(LockStatus);
            LockStatus = NULL;

            if(Err == ERROR_INSUFFICIENT_BUFFER) {
                //
                // We'll try again with the new required size.
                //
                BufferSize = ReqBufferSize;

            } else {
                //
                // We failed for some reason other than buffer-too-small. Bail.
                //
                leave;
            }
        }

        //
        // If we get here, then we failed due to out-of-memory.
        //
        Err = ERROR_NOT_ENOUGH_MEMORY;

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(Err == NO_ERROR) {
        MYASSERT(LockStatus);
        return LockStatus;
    } else {
        if(LockStatus) {
            MyFree(LockStatus);
        }
        SetLastError(Err);
        return NULL;
    }
}


DWORD
pAcquireSCMLock(
    IN  SC_HANDLE           SCMHandle,
    OUT SC_LOCK            *pSCMLock,
    IN  PSETUP_LOG_CONTEXT  LogContext OPTIONAL
    )
/*++

Routine Description:

    This routine attempts to lock the SCM database.  If it is already locked it
    will retry ACQUIRE_SCM_LOCK_ATTEMPTS times at intervals of
    ACQUIRE_SCM_LOCK_INTERVAL.

Arguments:

    SCMHandle - supplies a handle to the SCM to lock

    pSCMLock - receives the lock handle

    LogContext - optionally, supplies the logging context handle to use.

Return Value:

    NO_ERROR if the lock is acquired, otherwise a Win32 error code

Remarks:

    The value of *pSCMLock is guaranteed to be NULL if the lock is not acquired

--*/
{
    DWORD Err;
    ULONG Attempts = ACQUIRE_SCM_LOCK_ATTEMPTS;
    LPQUERY_SERVICE_LOCK_STATUS LockStatus = NULL;

    MYASSERT(pSCMLock);
    *pSCMLock = NULL;

    while((NO_ERROR != (Err = GLE_FN_CALL(NULL, *pSCMLock = LockServiceDatabase(SCMHandle))))
          && (Attempts > 0))
    {
        //
        // Check if the error is that someone else has locked the SCM
        //
        if(Err == ERROR_SERVICE_DATABASE_LOCKED) {

            Attempts--;
            //
            // Sleep for specified time
            //
            Sleep(ACQUIRE_SCM_LOCK_INTERVAL);

        } else {
            //
            // Unrecoverable error occured
            //
            break;
        }
    }

    if(*pSCMLock) {
        return NO_ERROR;
    }

    if(Err == ERROR_SERVICE_DATABASE_LOCKED) {

        LPTSTR lpLockOwner;
        DWORD dwLockDuration;

        try {

            LockStatus = GetServiceLockStatus(SCMHandle);

            if(LockStatus) {

                if(!LockStatus->fIsLocked) {
                    //
                    // While it's theoretically possible the lock just
                    // happens to have freed up at this exact instant, this
                    // more likely signals an underlying problem with the
                    // Service Controller.  If we went back and tried
                    // again, we'd probably end up in an infinite loop.
                    // Since we already have what should be an adequate
                    // retry count, there's no point doing it all again.
                    // Thus, we'll just log the event with a question mark
                    // "?" for owner and 0 seconds for duration.
                    //
                    lpLockOwner = NULL;
                    dwLockDuration = 0;
                } else {
                    //
                    // Actual information!  Let's use that...
                    //
                    lpLockOwner = LockStatus->lpLockOwner;
                    dwLockDuration = LockStatus->dwLockDuration;
                }

            } else {
                //
                // Couldn't retrieve the lock status
                //
                lpLockOwner = NULL;
                dwLockDuration = 0;
            }

            WriteLogEntry(LogContext,
                          SETUP_LOG_ERROR,
                          MSG_LOG_SCM_LOCKED_INFO,
                          NULL,
                          (lpLockOwner ? lpLockOwner : TEXT("?")),
                          dwLockDuration
                         );

        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        }

        if(LockStatus) {
            MyFree(LockStatus);
        }
    }

    //
    // We have been unable to lock the SCM
    //
    return Err;
}


DWORD
pSetupAcquireSCMLock(
    IN  SC_HANDLE  SCMHandle,
    OUT SC_LOCK   *pSCMLock
    )
/*++

Routine Description:

    variation of pAcquireSCMLock used by SysSetup
    See pAcquireSCMLock

--*/
{
    return pAcquireSCMLock(SCMHandle, pSCMLock, NULL);
}


DWORD
InvalidateHelperModules(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            Flags
    )
/*++

Routine Description:

    This routine resets the list of 'helper modules' (class installer, property
    page providers, and co-installers), and either frees them immediately or
    migrates the module handles to the devinfo set's list of things to clean up
    when the HDEVINFO is destroyed.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a list of 'helper' modules to be invalidated.

    DeviceInfoData - Optionally, specifies a particular device information
        element containing a list of 'helper' modules to be invalidated.  If
        this parameter is not specified, then the list of modules for the
        set itself will be invalidated.

    Flags - Supplies flags that control the behavior of this routine.  May be
        a combination of the following values:

        IHM_COINSTALLERS_ONLY - If this flag is set, only the co-installers
                                list will be invalidated.  Otherwise, the class
                                installer and property page providers will also
                                be invalidated.

        IHM_FREE_IMMEDIATELY  - If this flag is set, then the modules will be
                                freed immediately.  Otherwise, the modules will
                                be added to the HDEVINFO set's list of things
                                to clean up at handle close time.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is
    ERROR_NOT_ENOUGH_MEMORY.  (This routine cannot fail if the
    IHM_FREE_IMMEDIATELY flag is set.)

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, i, CiErr;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK InstallParamBlock;
    DWORD NumModulesToInvalidate;
    PMODULE_HANDLE_LIST_NODE NewModuleHandleNode;
    BOOL UnlockDevInfoElem, UnlockDevInfoSet;
    LONG CoInstallerIndex;
    SPFUSIONINSTANCE spFusionInstance;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        //
        // The handle's no longer valid--the user must've already destroyed the
        // set.  We have nothing to do.
        //
        return NO_ERROR;
    }

    Err = NO_ERROR;
    UnlockDevInfoElem = UnlockDevInfoSet = FALSE;
    DevInfoElem = NULL;
    NewModuleHandleNode = NULL;

    try {
        //
        // If we're invalidating helper modules for a particular devinfo
        // element, then find that element.
        //
        if(DeviceInfoData) {
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                //
                // The element must've been deleted--we've nothing to do.
                //
                leave;
            }
            InstallParamBlock = &(DevInfoElem->InstallParamBlock);
        } else {
            InstallParamBlock = &(pDeviceInfoSet->InstallParamBlock);
        }

        //
        // Count the number of module handles we need to free/migrate.
        //
        if(InstallParamBlock->CoInstallerCount == -1) {
            NumModulesToInvalidate = 0;
        } else {
            MYASSERT(InstallParamBlock->CoInstallerCount >= 0);
            NumModulesToInvalidate = (DWORD)(InstallParamBlock->CoInstallerCount);
        }

        if(!(Flags & IHM_COINSTALLERS_ONLY)) {
            if(InstallParamBlock->hinstClassInstaller) {
                NumModulesToInvalidate++;
            }
            if(InstallParamBlock->hinstClassPropProvider) {
                NumModulesToInvalidate++;
            }
            if(InstallParamBlock->hinstDevicePropProvider) {
                NumModulesToInvalidate++;
            }
            if(InstallParamBlock->hinstBasicPropProvider) {
                NumModulesToInvalidate++;
            }
        }

        if(NumModulesToInvalidate) {
            //
            // If we can't unload these modules at this time, then create a
            // node to store these module handles until the devinfo set is
            // destroyed.
            //
            if(!(Flags & IHM_FREE_IMMEDIATELY)) {

                NewModuleHandleNode = MyMalloc(offsetof(MODULE_HANDLE_LIST_NODE, ModuleList)
                                               + (NumModulesToInvalidate * sizeof(MODULE_HANDLE_LIST_INSTANCE))
                                              );

                if(!NewModuleHandleNode) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    leave;
                }
            }

            //
            // Give the class installers/co-installers a DIF_DESTROYPRIVATEDATA
            // notification.
            //
            if(DevInfoElem) {
                //
                // "Pin" the devinfo element, so that the class installer and
                // co-installers can't delete it out from under us (e.g., by
                // calling SetupDiDeleteDeviceInfo).
                //
                if(!(DevInfoElem->DiElemFlags & DIE_IS_LOCKED)) {
                    DevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
                    UnlockDevInfoElem = TRUE;
                }

            } else {
                //
                // No device information element to lock, so "pin" the devinfo
                // set itself...
                //
                if(!(pDeviceInfoSet->DiSetFlags & DISET_IS_LOCKED)) {
                    pDeviceInfoSet->DiSetFlags |= DISET_IS_LOCKED;
                    UnlockDevInfoSet = TRUE;
                }
            }

            //
            // Unlock the devinfo set prior to calling the helper modules...
            //
            UnlockDeviceInfoSet(pDeviceInfoSet);
            pDeviceInfoSet = NULL;

            CiErr = _SetupDiCallClassInstaller(DIF_DESTROYPRIVATEDATA,
                                               DeviceInfoSet,
                                               DeviceInfoData,
                                               CALLCI_CALL_HELPERS
                                              );

            MYASSERT((CiErr == NO_ERROR) || (CiErr == ERROR_DI_DO_DEFAULT));

            //
            // Now re-acquire the lock.  Since we pinned the devinfo element
            // (or the set, if we didn't have an element), we should find
            // things just as we left them.
            //
            pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet);

            MYASSERT(pDeviceInfoSet);

#if ASSERTS_ON
            if(DevInfoElem) {

                MYASSERT(DevInfoElem == FindAssociatedDevInfoElem(
                                            pDeviceInfoSet,
                                            DeviceInfoData,
                                            NULL));

                MYASSERT(InstallParamBlock == &(DevInfoElem->InstallParamBlock));

            } else {

                MYASSERT(InstallParamBlock == &(pDeviceInfoSet->InstallParamBlock));
            }
#endif

            //
            // Clear the "locked" flag, if we set it above...
            //
            if(UnlockDevInfoElem) {
                MYASSERT(DevInfoElem->DiElemFlags & DIE_IS_LOCKED);
                DevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
                UnlockDevInfoElem = FALSE;
            } else if(UnlockDevInfoSet) {
                MYASSERT(pDeviceInfoSet->DiSetFlags & DISET_IS_LOCKED);
                pDeviceInfoSet->DiSetFlags &= ~DISET_IS_LOCKED;
                UnlockDevInfoSet = FALSE;
            }

            //
            // Store the module handles in the node we allocated, and link it
            // into the list of module handles associated with this devinfo
            // set.
            //
            i = 0;

            if(!(Flags & IHM_COINSTALLERS_ONLY)) {
                //
                // Either free the modules now, or store them in our 'to do'
                // list...
                //
                if(Flags & IHM_FREE_IMMEDIATELY) {

                    if(InstallParamBlock->hinstClassInstaller) {
                        spFusionEnterContext(InstallParamBlock->ClassInstallerFusionContext,
                                             &spFusionInstance
                                            );
                        FreeLibrary(InstallParamBlock->hinstClassInstaller);
                        spFusionLeaveContext(&spFusionInstance);
                        spFusionKillContext(InstallParamBlock->ClassInstallerFusionContext);
                    }

                    if(InstallParamBlock->hinstClassPropProvider) {
                        spFusionEnterContext(InstallParamBlock->ClassEnumPropPagesFusionContext,
                                             &spFusionInstance
                                            );
                        FreeLibrary(InstallParamBlock->hinstClassPropProvider);
                        spFusionLeaveContext(&spFusionInstance);
                        spFusionKillContext(InstallParamBlock->ClassEnumPropPagesFusionContext);
                    }

                    if(InstallParamBlock->hinstDevicePropProvider) {
                        spFusionEnterContext(InstallParamBlock->DeviceEnumPropPagesFusionContext,
                                             &spFusionInstance
                                            );
                        FreeLibrary(InstallParamBlock->hinstDevicePropProvider);
                        spFusionLeaveContext(&spFusionInstance);
                        spFusionKillContext(InstallParamBlock->DeviceEnumPropPagesFusionContext);
                    }

                    if(InstallParamBlock->hinstBasicPropProvider) {
                        spFusionEnterContext(InstallParamBlock->EnumBasicPropertiesFusionContext,
                                             &spFusionInstance
                                            );
                        FreeLibrary(InstallParamBlock->hinstBasicPropProvider);
                        spFusionLeaveContext(&spFusionInstance);
                        spFusionKillContext(InstallParamBlock->EnumBasicPropertiesFusionContext);
                    }

                } else {

                    if(InstallParamBlock->hinstClassInstaller) {
                        NewModuleHandleNode->ModuleList[i].ModuleHandle = InstallParamBlock->hinstClassInstaller;
                        NewModuleHandleNode->ModuleList[i++].FusionContext = InstallParamBlock->ClassInstallerFusionContext;
                    }

                    if(InstallParamBlock->hinstClassPropProvider) {
                        NewModuleHandleNode->ModuleList[i].ModuleHandle = InstallParamBlock->hinstClassPropProvider;
                        NewModuleHandleNode->ModuleList[i++].FusionContext = InstallParamBlock->ClassEnumPropPagesFusionContext;
                    }

                    if(InstallParamBlock->hinstDevicePropProvider) {
                        NewModuleHandleNode->ModuleList[i].ModuleHandle = InstallParamBlock->hinstDevicePropProvider;
                        NewModuleHandleNode->ModuleList[i++].FusionContext = InstallParamBlock->DeviceEnumPropPagesFusionContext;
                    }

                    if(InstallParamBlock->hinstBasicPropProvider) {
                        NewModuleHandleNode->ModuleList[i].ModuleHandle = InstallParamBlock->hinstBasicPropProvider;
                        NewModuleHandleNode->ModuleList[i++].FusionContext = InstallParamBlock->EnumBasicPropertiesFusionContext;
                    }
                }
            }

            for(CoInstallerIndex = 0;
                CoInstallerIndex < InstallParamBlock->CoInstallerCount;
                CoInstallerIndex++)
            {
                if(Flags & IHM_FREE_IMMEDIATELY) {
                    spFusionEnterContext(InstallParamBlock->CoInstallerList[CoInstallerIndex].CoInstallerFusionContext,
                                         &spFusionInstance
                                        );
                    FreeLibrary(InstallParamBlock->CoInstallerList[CoInstallerIndex].hinstCoInstaller);
                    spFusionLeaveContext(&spFusionInstance);
                    spFusionKillContext(InstallParamBlock->CoInstallerList[CoInstallerIndex].CoInstallerFusionContext);
                } else {
                    NewModuleHandleNode->ModuleList[i].ModuleHandle =
                        InstallParamBlock->CoInstallerList[CoInstallerIndex].hinstCoInstaller;
                    NewModuleHandleNode->ModuleList[i++].FusionContext =
                        InstallParamBlock->CoInstallerList[CoInstallerIndex].CoInstallerFusionContext;
                }
            }

            //
            // Unless we're freeing these modules immediately, our modules-to-
            // free list index should now match the number of modules we're
            // supposed to be invalidating.
            //
            MYASSERT((Flags & IHM_FREE_IMMEDIATELY) || (i == NumModulesToInvalidate));

            if(!(Flags & IHM_FREE_IMMEDIATELY)) {

                NewModuleHandleNode->ModuleCount = NumModulesToInvalidate;

                NewModuleHandleNode->Next = pDeviceInfoSet->ModulesToFree;
                pDeviceInfoSet->ModulesToFree = NewModuleHandleNode;

                //
                // Now, clear the node pointer, so we won't try to free it if
                // we hit an exception.
                //
                NewModuleHandleNode = NULL;
            }

            //
            // Clear all the module handles (and entry points).  They will be
            // retrieved anew the next time they're needed.
            //
            if(!(Flags & IHM_COINSTALLERS_ONLY)) {
                InstallParamBlock->hinstClassInstaller              = NULL;
                InstallParamBlock->ClassInstallerEntryPoint         = NULL;
                InstallParamBlock->ClassInstallerFusionContext      = NULL;
                //
                // Also, clear the "class installer failed" flag, if set,
                // because that class installer is history.
                //
                InstallParamBlock->FlagsEx &= ~DI_FLAGSEX_CI_FAILED;

                InstallParamBlock->hinstClassPropProvider           = NULL;
                InstallParamBlock->ClassEnumPropPagesEntryPoint     = NULL;
                InstallParamBlock->ClassEnumPropPagesFusionContext  = NULL;

                InstallParamBlock->hinstDevicePropProvider          = NULL;
                InstallParamBlock->DeviceEnumPropPagesEntryPoint    = NULL;
                InstallParamBlock->DeviceEnumPropPagesFusionContext = NULL;

                InstallParamBlock->hinstBasicPropProvider           = NULL;
                InstallParamBlock->EnumBasicPropertiesEntryPoint    = NULL;
                InstallParamBlock->EnumBasicPropertiesFusionContext = NULL;
            }

            if(InstallParamBlock->CoInstallerCount != -1) {
                if(InstallParamBlock->CoInstallerList) {
                    MyFree(InstallParamBlock->CoInstallerList);
                    InstallParamBlock->CoInstallerList = NULL;
                }
            }
        }

        //
        // Set the co-installer count back to -1, even if their weren't any
        // co-installers to unload.  That will ensure that we'll re-load the
        // co-installers for the next class installer request we receive.
        //
        InstallParamBlock->CoInstallerCount = -1;

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        //
        // We should never encounter an exception, but if we do, just make sure
        // we do any necessary clean-up.  Don't return an error in this case--
        // the only error this routine is supposed to return is out-of-memory.
        //
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);

        if(UnlockDevInfoElem || UnlockDevInfoSet) {

            if(!pDeviceInfoSet) {
                //
                // We hit an exception while we had the set unlocked.  Attempt
                // to re-acquire the lock.
                //
                pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet);

                //
                // Since we had the set/element "pinned", we should've been
                // able to re-acquire the lock...
                //
                MYASSERT(pDeviceInfoSet);
            }

            if(pDeviceInfoSet) {

                if(UnlockDevInfoElem) {

                    MYASSERT(DevInfoElem);

                    MYASSERT(DevInfoElem == FindAssociatedDevInfoElem(
                                                pDeviceInfoSet,
                                                DeviceInfoData,
                                                NULL));

                    if(DevInfoElem) {
                        MYASSERT(DevInfoElem->DiElemFlags & DIE_IS_LOCKED);
                        DevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
                    }

                } else {
                    MYASSERT(pDeviceInfoSet->DiSetFlags & DISET_IS_LOCKED);
                    pDeviceInfoSet->DiSetFlags &= ~DISET_IS_LOCKED;
                }
            }
        }

        if(NewModuleHandleNode) {
            MyFree(NewModuleHandleNode);
        }
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return Err;
}


DWORD
DoInstallActionWithParams(
    IN DI_FUNCTION             InstallFunction,
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    IN OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN DWORD                   ClassInstallParamsSize,
    IN DWORD                   Flags
    )
/*++

Routine Description:

    This routine performs a requested installation action, using the specified
    class install parameters.  Any existing class install parameters are
    preserved.

Arguments:

    InstallFunction - Specifies the DIF_* action to be performed.

    DeviceInfoSet - Supplies a handle to the device information set for which
        the installation action is to be performed.

    DeviceInfoData - Optionally, supplies the address of a device information
        structure specifying a particular element for which the installation
        action is to be performed.

    ClassInstallParams - Optionally, supplies the address of a class install
        parameter buffer to be used for this action.  If this parameter is not
        specified, then no class install params will be available to the class
        installer during this call (even if there were pre-existing parameters
        coming into this function).

        ** NOTE: The class install params stucture must be static in size.
        ** I.e., it cannot have a variable-length array at the end such that
        ** it might "grow" as a result of the requested DIF processing.

    ClassInstallParamsSize - Supplies the size, in bytes, of the
        ClassInstallParams buffer, or zero if ClassInstallParams is not
        specified.

    Flags - Supplies flags that control the behavior of this routine.  May be
        a combination of the following values:

        INSTALLACTION_CALL_CI - Call the class installer for this action
            request.

        INSTALLACTION_NO_DEFAULT - Don't perform the default action (if this
            flag is specified without INSTALLACTION_CALL_CI, then this routine
            is a no-op).

Return Value:

    If the request was handled successfully, the return value is NO_ERROR.

    If the request was not handled (but no error occurred), the return value is
    ERROR_DI_DO_DEFAULT.

    Otherwise, the return value is a Win32 error code indicating the cause of
    failure.

--*/
{
    PBYTE OldCiParams;
    DWORD OldCiParamsSize, Err;
    SP_PROPCHANGE_PARAMS PropChangeParams;
    SP_DEVINSTALL_PARAMS DevInstallParams;
    DWORD FlagsToClear;

    //
    // Retrieve any existing class install parameters, then write out
    // parameters for DIF_PROPERTYCHANGE.
    //
    OldCiParams = NULL;
    OldCiParamsSize = 0;
    FlagsToClear = 0;

    try {

        while(NO_ERROR != (Err = GLE_FN_CALL(FALSE,
                                             SetupDiGetClassInstallParams(
                                                 DeviceInfoSet,
                                                 DeviceInfoData,
                                                 (PSP_CLASSINSTALL_HEADER)OldCiParams,
                                                 OldCiParamsSize,
                                                 &OldCiParamsSize)))) {
            //
            // Before going any further, free our existing buffer (if there is
            // one).
            //
            if(OldCiParams) {
                MyFree(OldCiParams);
                OldCiParams = NULL;
            }

            if(Err == ERROR_INSUFFICIENT_BUFFER) {
                //
                // Allocate a buffer of the size required, and try again.
                //
                MYASSERT(OldCiParamsSize >= sizeof(SP_CLASSINSTALL_HEADER));

                if(!(OldCiParams = MyMalloc(OldCiParamsSize))) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    leave;
                }

                ((PSP_CLASSINSTALL_HEADER)OldCiParams)->cbSize = sizeof(SP_CLASSINSTALL_HEADER);

            } else {
                //
                // Treat any other error as if there are no class install
                // params (since ERROR_NO_CLASSINSTALL_PARAMS is really the
                // only error we should ever see here anyway).
                //
                OldCiParamsSize = 0;
                break;
            }
        }

        //
        // Retrieve the device install params for the set or element we're
        // working with.
        //
        DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

        Err = GLE_FN_CALL(FALSE,
                          SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                                        DeviceInfoData,
                                                        &DevInstallParams)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // It's possible that the class install params we just retrieved are
        // 'turned off' (i.e., the DI_CLASSINSTALLPARAMS bit is cleared).
        // Check for that condition now, so we can restore the parameters to
        // the same state later.
        //
        if(OldCiParams && !(DevInstallParams.Flags & DI_CLASSINSTALLPARAMS)) {
            FlagsToClear |= DI_CLASSINSTALLPARAMS;
        }

        //
        // If the caller doesn't want us to do the default action, then check
        // to see whether we need to temporarily set the DI_NODI_DEFAULTACTION
        // flag.
        //
        if((Flags & INSTALLACTION_NO_DEFAULT) &&
           !(DevInstallParams.Flags & DI_NODI_DEFAULTACTION)) {

            FlagsToClear |= DI_NODI_DEFAULTACTION;

            DevInstallParams.Flags |= DI_NODI_DEFAULTACTION;

            Err = GLE_FN_CALL(FALSE,
                              SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                                            DeviceInfoData,
                                                            &DevInstallParams)
                             );

            if(Err != NO_ERROR) {
                leave;
            }
        }

        Err = GLE_FN_CALL(FALSE,
                          SetupDiSetClassInstallParams(DeviceInfoSet,
                                                       DeviceInfoData,
                                                       ClassInstallParams,
                                                       ClassInstallParamsSize)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // OK, now call the class installer.
        //
        Err = _SetupDiCallClassInstaller(
                  InstallFunction,
                  DeviceInfoSet,
                  DeviceInfoData,
                  ((Flags & INSTALLACTION_CALL_CI)
                      ? (CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS)
                      : 0)
                  );

        //
        // Save the class install params results in the ClassInstallParams
        // value that was passed in.
        //
        if(ClassInstallParams) {

            DWORD TempErr;

            TempErr = GLE_FN_CALL(FALSE,
                                  SetupDiGetClassInstallParams(
                                      DeviceInfoSet,
                                      DeviceInfoData,
                                      ClassInstallParams,
                                      ClassInstallParamsSize,
                                      NULL)
                                 );

            if(TempErr != NO_ERROR) {
                //
                // This really shouldn't fail.  Only return this error to the
                // caller if we don't already have a non-success status.
                //
                if(Err == NO_ERROR) {
                    Err = TempErr;
                }
            }
        }

        //
        // Restore the previous class install params.
        //
        SetupDiSetClassInstallParams(DeviceInfoSet,
                                     DeviceInfoData,
                                     (PSP_CLASSINSTALL_HEADER)OldCiParams,
                                     OldCiParamsSize
                                    );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(OldCiParams) {
        MyFree(OldCiParams);
    }

    if(FlagsToClear) {

        if(SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                         DeviceInfoData,
                                         &DevInstallParams)) {

            DevInstallParams.Flags &= ~FlagsToClear;

            SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                          DeviceInfoData,
                                          &DevInstallParams
                                         );
        }
    }

    return Err;
}


BOOL
GetBestDeviceDesc(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,  OPTIONAL
    OUT PTSTR            DeviceDescBuffer
    )
/*++

Routine Description:

    This routine retrieves the best possible description to be displayed for
    the specified devinfo set or element (e.g., for driver signing popups). We
    will try to retrieve this string by doing the following things (in order)
    until one of them succeeds:

        1.  If there's a selected driver, retrieve the DeviceDesc in that
            driver node.
        2.  If this is for a device information element, then use devnode's
            DeviceDesc property.
        3.  Retrieve the description of the class (via
            SetupDiGetClassDescription).
        4.  Use the (localized) string "Unknown driver software package".

    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which
        a description is to be retrieved (unless DeviceInfoData is also
        supplied, in which case we retrieve the description for that particular
        element instead.

    DeviceInfoData - Optionally, supplies the device information element for
        which a description is to be retrieved.

    DeviceDescBuffer - Supplies the address of a character buffer that must be
        at least LINE_LEN characters long.  Upon successful return, this buffer
        will be filled in with a device description

Return Value:

    TRUE if some description was retrieved, FALSE otherwise.

--*/
{
    SP_DRVINFO_DATA DriverInfoData;
    GUID ClassGuid;
    BOOL b;
    HRESULT hr;

    //
    // First, see if there's a selected driver for this device information set
    // or element.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if(SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData)) {
        //
        // Copy the description into the caller-supplied buffer and return.
        //
        hr = StringCchCopy(DeviceDescBuffer,
                           LINE_LEN,
                           DriverInfoData.Description
                          );

        MYASSERT(SUCCEEDED(hr));

        if(SUCCEEDED(hr)) {
            return TRUE;
        }
    }

    //
    // OK, next try to retrieve the DeviceDesc property (if we're working on a
    // device information element.
    //
    if(DeviceInfoData) {

        if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                            DeviceInfoData,
                                            SPDRP_DEVICEDESC,
                                            NULL,
                                            (PBYTE)DeviceDescBuffer,
                                            LINE_LEN * sizeof(TCHAR),
                                            NULL)) {
            return TRUE;
        }
    }

    //
    // Next, try to retrieve the class's friendly name.
    //
    if(DeviceInfoData) {
        CopyMemory(&ClassGuid, &(DeviceInfoData->ClassGuid), sizeof(GUID));
    } else {
        b = SetupDiGetDeviceInfoListClass(DeviceInfoSet, &ClassGuid);
        MYASSERT(b);
        if(!b) {
            return FALSE;
        }
    }

    if(SetupDiGetClassDescription(&ClassGuid,
                                  DeviceDescBuffer,
                                  LINE_LEN,
                                  NULL)) {
        return TRUE;

    } else {
        //
        // We have a class that isn't already installed.  Therefore, we just
        // give it a generic description.
        //
        if(LoadString(MyDllModuleHandle,
                      IDS_UNKNOWN_DRIVER,
                      DeviceDescBuffer,
                      LINE_LEN)) {

            return TRUE;
        }
    }

    return FALSE;
}


BOOL
GetDecoratedModelsSection(
    IN  PSETUP_LOG_CONTEXT      LogContext,            OPTIONAL
    IN  PLOADED_INF             Inf,
    IN  PINF_LINE               MfgListLine,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,       OPTIONAL
    OUT PTSTR                   DecoratedModelsSection OPTIONAL
    )
/*++

Routine Description:

    This routine examines each (optional) TargetDecoration field within the
    specified manufacturer's entry in the [Manufacturer] section, to see if any
    are applicable to the current OS.  If so, the most-appropriate one (based
    on OS major and minor version) is chosen, and the TargetDecoration string
    is appended to the manufacturer's models section name, and returned to the
    caller.

    The format of the TargetDecoration field is as follows:

    NT[architecture][.[OSMajorVer][.[OSMinorVer][.[ProductType][.[SuiteMask]]]]]

    Where:

    architecture may be x86, IA64, or AMD64.

    OSMajorVer is the OS major version (e.g., for Whistler, it's 5)

    OSMinorVer is the OS minor version (e.g., for Whistler, it's 1)

    ProductType indicates the type of product, and may be one of the following
    values (as defined in winnt.h):

        VER_NT_WORKSTATION              0x0000001
        VER_NT_DOMAIN_CONTROLLER        0x0000002
        VER_NT_SERVER                   0x0000003

    SuiteMask is a combination of the following flags identifying the product
    suites available on the system (as defined in winnt.h):

        VER_SUITE_SMALLBUSINESS             0x00000001
        VER_SUITE_ENTERPRISE                0x00000002
        VER_SUITE_BACKOFFICE                0x00000004
        VER_SUITE_COMMUNICATIONS            0x00000008
        VER_SUITE_TERMINAL                  0x00000010
        VER_SUITE_SMALLBUSINESS_RESTRICTED  0x00000020
        VER_SUITE_EMBEDDEDNT                0x00000040
        VER_SUITE_DATACENTER                0x00000080
        VER_SUITE_SINGLEUSERTS              0x00000100

    Refer to the discussion in the SDK for the OSVERSIONINFOEX structure for
    more information.

    THIS ROUTINE DOES NOT DO LOCKING ON THE INF!!!

Arguments:

    LogContext - optionally, supplies the log context to use if an error is
        encountered (e.g., decorated section name is too long)

    Inf - supplies a pointer to the inf descriptor for the loaded device INF.

    MfgListLine - supplies a pointer to the line descriptor for the
        manufacturer's entry within the [Manufacturer] section.  THIS LINE MUST
        BE CONTAINED WITHIN THE SPECIFIED INF!!

    AltPlatformInfo - optionally, supplies alternate platform information to be
        used when selecting the most-appropriate models section.

        NOTE: If this parameter is supplied, then we must do our own version
        comparisons, as VerifyVersionInfo() has no clue about non-native
        matters.  This also means that we do not take into account either
        ProductType or SuiteMask in our comparison.

    DecoratedModelsSection - upon successful return, receives the decorated
        models section name based on the most-appropriate TargetDecoration
        field in the manufacturer's entry.

        This character buffer must be at least MAX_SECT_NAME_LEN characters.

Return Value:

    If an applicable TargetDecoration entry was found (thus
    DecoratedModelsSection was filled in), the return value is TRUE.

    Otherwise, the return value is FALSE.

--*/
{
    #define DEC_INCLUDES_ARCHITECTURE  4
    #define DEC_INCLUDES_PRODUCTTYPE   2
    #define DEC_INCLUDES_SUITEMASK     1

    DWORD CurFieldIndex;
    PCTSTR CurTargetDecoration, ModelsSectionName;
    PCTSTR BestTargetDecoration = NULL;
    size_t SectionNameLen;
    TCHAR DecBuffer[MAX_SECT_NAME_LEN];
    PTSTR CurDecPtr, NextDecPtr;
    DWORD BestMajorVer = 0, BestMinorVer = 0;
    DWORD BestDecIncludesMask = 0;
    DWORD CurMajorVer, CurMinorVer;
    BYTE ProductType;
    WORD SuiteMask;
    INT   TempInt;
    DWORD CurDecIncludesMask;
    BOOL NewBestFound;
    OSVERSIONINFOEX OsVersionInfoEx;
    DWORDLONG ConditionMask;
    DWORD TypeMask;
    DWORD Platform;
    PCTSTR NtArchSuffix;
    HRESULT hr;

    //
    // Set OsVersionInfoEx size field to zero as a flag to indicate that
    // structure initialization is necessary if we end up needing to call
    // VerifyVersionInfo later.
    //
    OsVersionInfoEx.dwOSVersionInfoSize = 0;

    //
    // Determine which platform we should be looking for...
    //
    Platform = AltPlatformInfo ? AltPlatformInfo->Platform
                               : OSVersionInfo.dwPlatformId;

    //
    // ...as well as which OS/architecture decoration.  (Note that we skip the
    // first character of the platform suffix, since we don't want the
    // leading '.')
    //
    if(AltPlatformInfo) {

        switch(AltPlatformInfo->ProcessorArchitecture) {

            case PROCESSOR_ARCHITECTURE_INTEL :
                NtArchSuffix = &(pszNtX86Suffix[1]);
                break;

            case PROCESSOR_ARCHITECTURE_IA64 :
                NtArchSuffix = &(pszNtIA64Suffix[1]);
                break;

            case PROCESSOR_ARCHITECTURE_AMD64 :
                NtArchSuffix = &(pszNtAMD64Suffix[1]);
                break;

            default:
                //
                // Unknown/invalid architecture
                //
                return FALSE;
        }

    } else {
        NtArchSuffix = &(pszNtPlatformSuffix[1]);
    }

    //
    // TargetDecoration fields start at field index 2...
    //
    for(CurFieldIndex = 2;
        CurTargetDecoration = InfGetField(Inf, MfgListLine, CurFieldIndex, NULL);
        CurFieldIndex++)
    {
        //
        // Copy the TargetDecoration into a scratch buffer so we can extract
        // the various fields from it.
        //
        if(FAILED(StringCchCopy(DecBuffer, SIZECHARS(DecBuffer), CurTargetDecoration))) {
            //
            // TargetDecoration is invalid (too large).  Skip it and continue.
            //
            continue;
        }

        //
        // First part is traditional per-OS/architecture decoration.
        //
        CurMajorVer = CurMinorVer = 0;
        CurDecIncludesMask = 0;

        CurDecPtr = _tcschr(DecBuffer, TEXT('.'));

        if(CurDecPtr) {
            *CurDecPtr = TEXT('\0');
        }

        if(Platform == VER_PLATFORM_WIN32_NT) {
            //
            // We're on NT, so first try the NT architecture-specific
            // extension, then the generic NT extension.
            //
            if(!_tcsicmp(DecBuffer, NtArchSuffix)) {

                CurDecIncludesMask |= DEC_INCLUDES_ARCHITECTURE;

            } else if(_tcsicmp(DecBuffer, &(pszNtSuffix[1]))) {
                //
                // TargetDecoration isn't applicable for this OS/architecture.
                // Skip it and continue on to the next one.
                //
                continue;
            }

        } else {
            //
            // We're on Win9x, so try the Windows-specific extension
            //
            if(_tcsicmp(DecBuffer, &(pszWinSuffix[1]))) {
                //
                // TargetDecoration isn't applicable for this OS.
                // Skip it and continue on to the next one.
                //
                continue;
            }
        }

        //
        // If we get to here, then the decoration is applicable to the
        // OS/architecture under which we're running (or for which alt platform
        // info was specified)
        //
        if(CurDecPtr) {
            //
            // Version info is included--extract the supplied components and
            // use VerifyVersionInfo to see if they're valid for the OS version
            // under which we're running.
            //

            //
            // Get major version...
            //
            NextDecPtr = _tcschr(++CurDecPtr, TEXT('.'));

            if(NextDecPtr) {
                *NextDecPtr = TEXT('\0');
            }

            if(!pAToI(CurDecPtr, &TempInt) || (TempInt < 0)) {
                continue;
            }

            CurMajorVer = (DWORD)TempInt;

            if(NextDecPtr) {
                CurDecPtr = NextDecPtr + 1;
            } else {
                //
                // No more fields to retrieve--assume minor version of 0.
                //
                CurMinorVer = 0;
                goto AllFieldsRetrieved;
            }

            //
            // Get minor version...
            //
            NextDecPtr = _tcschr(CurDecPtr, TEXT('.'));

            if(NextDecPtr) {
                *NextDecPtr = TEXT('\0');
            }

            if(!pAToI(CurDecPtr, &TempInt) || (TempInt < 0)) {
                continue;
            }

            CurMinorVer = (DWORD)TempInt;

            //
            // If minor version is supplied, then major version must be
            // supplied as well.
            //
            if(CurMinorVer && !CurMajorVer) {
                continue;
            }

            if(NextDecPtr && !AltPlatformInfo) {
                CurDecPtr = NextDecPtr + 1;
            } else {
                //
                // No more fields to retrieve
                //
                goto AllFieldsRetrieved;
            }

            //
            // Get product type
            //
            NextDecPtr = _tcschr(CurDecPtr, TEXT('.'));

            if(NextDecPtr) {
                *NextDecPtr = TEXT('\0');
            }

            if(!pAToI(CurDecPtr, &TempInt) ||
               (TempInt < 0) || (TempInt > 0xff)) {
                continue;
            }

            ProductType = (BYTE)TempInt;

            if(ProductType) {
                CurDecIncludesMask |= DEC_INCLUDES_PRODUCTTYPE;
            }

            if(NextDecPtr) {
                CurDecPtr = NextDecPtr + 1;
            } else {
                //
                // No more fields to retrieve
                //
                goto AllFieldsRetrieved;
            }

            //
            // Get suite mask.  If we find another '.' in the TargetDecoration
            // field, this indicates additional fields we don't know about
            // (e.g., a future version of setupapi has added more fields, say,
            // for service pack info).  Since we don't know how to interpret
            // these additional fields, an entry containing them must be
            // skipped.
            //
            if(_tcschr(CurDecPtr, TEXT('.'))) {
                continue;
            }

            if(!pAToI(CurDecPtr, &TempInt) ||
               (TempInt < 0) || (TempInt > 0xffff)) {
                continue;
            }

            SuiteMask = (WORD)TempInt;

            if(SuiteMask) {
                CurDecIncludesMask |= DEC_INCLUDES_SUITEMASK;
            }

AllFieldsRetrieved :

            if(AltPlatformInfo) {
                //
                // We're doing a non-native driver search, so we're on our own
                // to do version comparison...
                //
                if((AltPlatformInfo->MajorVersion < CurMajorVer) ||
                   ((AltPlatformInfo->MajorVersion == CurMajorVer) &&
                    (AltPlatformInfo->MinorVersion < CurMinorVer))) {

                    //
                    // The alternate platform info is for an older (lower-
                    // versioned) OS than the current TargetDecoration.
                    //
                    continue;
                }

            } else {
                //
                // We're doing native driver searching, we can use the handy
                // API, VerifyVersionInfo.
                //
                if(!OsVersionInfoEx.dwOSVersionInfoSize) {
                    //
                    // First time we've needed to call VerifyVersionInfo--must
                    // initialize the structure first...
                    //
                    ZeroMemory(&OsVersionInfoEx, sizeof(OsVersionInfoEx));
                    OsVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
                }

                TypeMask = 0;
                ConditionMask = 0;

                OsVersionInfoEx.dwMajorVersion = CurMajorVer;
                OsVersionInfoEx.dwMinorVersion = CurMinorVer;

                if(CurMajorVer) {

                    TypeMask |= (VER_MAJORVERSION | VER_MINORVERSION);

                    VER_SET_CONDITION(ConditionMask,
                                      VER_MAJORVERSION,
                                      VER_GREATER_EQUAL
                                     );

                    VER_SET_CONDITION(ConditionMask,
                                      VER_MINORVERSION,
                                      VER_GREATER_EQUAL
                                     );
                }

                if(CurDecIncludesMask & DEC_INCLUDES_PRODUCTTYPE) {

                    OsVersionInfoEx.wProductType = ProductType;

                    TypeMask |= VER_PRODUCT_TYPE;

                    VER_SET_CONDITION(ConditionMask,
                                      VER_PRODUCT_TYPE,
                                      VER_EQUAL
                                     );
                } else {
                    OsVersionInfoEx.wProductType = 0;
                }

                if(CurDecIncludesMask & DEC_INCLUDES_SUITEMASK) {

                    OsVersionInfoEx.wSuiteMask = SuiteMask;

                    TypeMask |= VER_SUITENAME;

                    VER_SET_CONDITION(ConditionMask,
                                      VER_SUITENAME,
                                      VER_AND
                                     );
                } else {
                    OsVersionInfoEx.wSuiteMask = 0;
                }

                //
                // Only call VerifyVersionInfo if one or more criteria were
                // supplied (otherwise, assume this TargetDecoration is
                // applicable)
                //
                if(TypeMask) {

                    if(!VerifyVersionInfo(&OsVersionInfoEx, TypeMask, ConditionMask)) {
                        //
                        // TargetDecoration isn't applicable to current OS version.
                        //
                        continue;
                    }
                }
            }
        }

        //
        // If we get to here, we have an applicable TargetDecoration--see if
        // it's the best one we've seen thus far...
        //
        NewBestFound = FALSE;

        if((CurMajorVer > BestMajorVer) ||
           ((CurMajorVer == BestMajorVer) && (CurMinorVer > BestMinorVer))) {
            //
            // Newer version
            //
            NewBestFound = TRUE;

        } else if((CurMajorVer == BestMajorVer) && (CurMinorVer == BestMinorVer)) {
            //
            // Version is same as current best.  Is it as-specific or more so?
            // NOTE: we update on "as-specific" (i.e., equal) matches to catch
            // the case where our only applicable decoration is "NT".  In that
            // case, our best and current version is "0.0", and our masks are
            // both zero as well.
            //
            if(CurDecIncludesMask >= BestDecIncludesMask) {
                NewBestFound = TRUE;
            }
        }

        if(NewBestFound) {
            BestTargetDecoration = CurTargetDecoration;
            BestMajorVer = CurMajorVer;
            BestMinorVer = CurMinorVer;
            BestDecIncludesMask = CurDecIncludesMask;
        }
    }

    if(!BestTargetDecoration) {
        //
        // No applicable TargetDecoration was found.
        //
        return FALSE;
    }

    //
    // Construct the decorated section name by appending the TargetDecoration
    // to the models section name.
    //
    if(!(ModelsSectionName = InfGetField(Inf, MfgListLine, 1, NULL))) {
        //
        // Should never happen
        //
        MYASSERT(ModelsSectionName);
        return FALSE;
    }

    hr = StringCchCopyEx(DecoratedModelsSection,
                         MAX_SECT_NAME_LEN,
                         ModelsSectionName,
                         &CurDecPtr,
                         &SectionNameLen,
                         0
                        );

    if(SUCCEEDED(hr)) {
        //
        // Now append a "."
        //
        hr = StringCchCopyEx(CurDecPtr,
                             SectionNameLen,
                             TEXT("."),
                             &CurDecPtr,
                             &SectionNameLen,
                             0
                            );

        if(SUCCEEDED(hr)) {
            //
            // ...and finally append the decoration
            //
            hr = StringCchCopyEx(CurDecPtr,
                                 SectionNameLen,
                                 BestTargetDecoration,
                                 NULL,
                                 &SectionNameLen,
                                 0
                                );
        }
    }

    if(FAILED(hr)) {
        //
        // Decorated section name exceeds maximum length of a section name!
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR,
            MSG_LOG_DEC_MODELS_SEC_TOO_LONG,
            NULL,
            ModelsSectionName,
            BestTargetDecoration,
            MAX_SECT_NAME_LEN
           );

        return FALSE;
    }

    return TRUE;
}


LONG
pSetupExceptionFilter(
    DWORD ExceptionCode
    )
/*++

Routine Description:

    This routine acts as the exception filter for all of setupapi.  We will
    handle all exceptions except for the following:

    EXCEPTION_SPAPI_UNRECOVERABLE_STACK_OVERFLOW
        This means we previously tried to reinstate the guard page after a
        stack overflow, but couldn't.  We have no choice but to let the
        exception trickle all the way back out.

    EXCEPTION_POSSIBLE_DEADLOCK
        We are not allowed to handle this exception which fires when the
        deadlock detection gflags option has been enabled.

Arguments:

    ExceptionCode - Specifies the exception that occurred (i.e., as returned
        by GetExceptionCode)

Return Value:

    If the exception should be handled, the return value is
    EXCEPTION_EXECUTE_HANDLER.

    Otherwise, the return value is EXCEPTION_CONTINUE_SEARCH.

--*/
{
    if((ExceptionCode == EXCEPTION_SPAPI_UNRECOVERABLE_STACK_OVERFLOW) ||
       (ExceptionCode == EXCEPTION_POSSIBLE_DEADLOCK)) {

        return EXCEPTION_CONTINUE_SEARCH;
    } else {
        return EXCEPTION_EXECUTE_HANDLER;
    }
}


VOID
pSetupExceptionHandler(
    IN  DWORD  ExceptionCode,
    IN  DWORD  AccessViolationError,
    OUT PDWORD Win32ErrorCode        OPTIONAL
    )
/*++

Routine Description:

    This routine, called from inside an exception handler block, provides
    common exception handling functionality to be used throughout setupapi.
    It has knowledge of which exceptions require extra work (e.g., stack
    overflow), and also optionally returns a Win32 error code that represents
    the exception.  (The caller specifies the error to be used when an access
    violation occurs.)

Arguments:

    ExceptionCode - Specifies the exception that occurred (i.e., as returned
        by GetExceptionCode)

    AccessViolationError - Specifies the Win32 error code to be returned via
        the optional Win32ErrorCode OUT parameter when the exception
        encountered was EXCEPTION_ACCESS_VIOLATION.

    Win32ErrorCode - Optionally, supplies the address of a DWORD that receives
        the Win32 error code corresponding to the exception (taking into
        account the AccessViolationError code supplied above, if applicable).

Return Value:

    None

--*/
{
    DWORD Err;

    //
    // Exception codes we should never attempt to handle...
    //
    MYASSERT(ExceptionCode != EXCEPTION_SPAPI_UNRECOVERABLE_STACK_OVERFLOW);
    MYASSERT(ExceptionCode != EXCEPTION_POSSIBLE_DEADLOCK);

    if(ExceptionCode == STATUS_STACK_OVERFLOW) {

        if(_resetstkoflw()) {
            Err = ERROR_STACK_OVERFLOW;
        } else {
            //
            // Couldn't recover from stack overflow!
            //
            RaiseException(EXCEPTION_SPAPI_UNRECOVERABLE_STACK_OVERFLOW,
                           EXCEPTION_NONCONTINUABLE,
                           0,
                           NULL
                          );
            //
            // We should never get here, but initialize Err to make code
            // analysis tools happy...
            //
            Err = ERROR_UNRECOVERABLE_STACK_OVERFLOW;
        }

    } else {
        //
        // Except for a couple of special cases (for backwards-compatibility),
        // attempt to map exception code to a Win32 error (we can do this
        // since exception codes generally correlate with NTSTATUS codes).
        //
        switch(ExceptionCode) {

            case EXCEPTION_ACCESS_VIOLATION :
                Err = AccessViolationError;
                break;

            case EXCEPTION_IN_PAGE_ERROR :
                Err = ERROR_READ_FAULT;
                break;

            default :
                Err = RtlNtStatusToDosErrorNoTeb((NTSTATUS)ExceptionCode);
                if(Err == ERROR_MR_MID_NOT_FOUND) {
                    //
                    // Exception code didn't map to a Win32 error.
                    //
                    Err = ERROR_UNKNOWN_EXCEPTION;
                }
                break;
        }
    }

    if(Win32ErrorCode) {
        *Win32ErrorCode = Err;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\diansicv.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    diansicv.c

Abstract:

    Routine to convert device installer data structures between
    ANSI and Unicode.

Author:

    Ted Miller (tedm) 19-July-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


DWORD
pSetupDiDevInstParamsAnsiToUnicode(
    IN  PSP_DEVINSTALL_PARAMS_A AnsiDevInstParams,
    OUT PSP_DEVINSTALL_PARAMS_W UnicodeDevInstParams
    )

/*++

Routine Description:

    This routine converts an SP_DEVINSTALL_PARAMS_A structure to
    an SP_DEVINSTALL_PARAMS_W, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    AnsiDevInstParams - supplies ANSI device installation parameters
        to be converted to unicode.

    UnicodeDevInstParams - if successful, receives Unicode equivalent of
        AnsiDevInstParams.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    It is not believed that, given valid arguments, text conversion itself
    can fail, since all ANSI chars always have Unicode equivalents.

--*/

{
    DWORD rc;

    try {

        if(AnsiDevInstParams->cbSize != sizeof(SP_DEVINSTALL_PARAMS_A)) {
            rc = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        //
        // Fixed part of structure.
        //
        MYASSERT(offsetof(SP_DEVINSTALL_PARAMS_A,DriverPath) == offsetof(SP_DEVINSTALL_PARAMS_W,DriverPath));

        CopyMemory(UnicodeDevInstParams,
                   AnsiDevInstParams,
                   offsetof(SP_DEVINSTALL_PARAMS_W,DriverPath)
                  );

        UnicodeDevInstParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS_W);

        //
        // Convert the single string in the structure. To make things easier
        // we'll just convert the entire buffer. There's no potential for
        // overflow.
        //
        rc = GLE_FN_CALL(0,
                         MultiByteToWideChar(
                             CP_ACP,
                             MB_PRECOMPOSED,
                             AnsiDevInstParams->DriverPath,
                             sizeof(AnsiDevInstParams->DriverPath),
                             UnicodeDevInstParams->DriverPath,
                             SIZECHARS(UnicodeDevInstParams->DriverPath))
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    return rc;
}


DWORD
pSetupDiDevInstParamsUnicodeToAnsi(
    IN  PSP_DEVINSTALL_PARAMS_W UnicodeDevInstParams,
    OUT PSP_DEVINSTALL_PARAMS_A AnsiDevInstParams
    )

/*++

Routine Description:

    This routine converts an SP_DEVINSTALL_PARAMS_W structure to
    an SP_DEVINSTALL_PARAMS_A, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    UnicodeDevInstParams - supplies Unicode device installation parameters
        to be converted to ANSI.

    AnsiDevInstParams - if successful, receives Ansi equivalent of
        UnicodeDevInstParams.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    Unicode chars that can't be represented in the current system ANSI codepage
    will be replaced with a system default in the ANSI structure.

--*/

{
    DWORD rc;
    UCHAR AnsiString[MAX_PATH*2];
    HRESULT hr;

    MYASSERT(UnicodeDevInstParams->cbSize == sizeof(SP_DEVINSTALL_PARAMS_W));

    try {

        if(AnsiDevInstParams->cbSize != sizeof(SP_DEVINSTALL_PARAMS_A)) {
            rc = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        //
        // Fixed part of structure.
        //
        MYASSERT(offsetof(SP_DEVINSTALL_PARAMS_A,DriverPath) == offsetof(SP_DEVINSTALL_PARAMS_W,DriverPath));

        CopyMemory(AnsiDevInstParams,
                   UnicodeDevInstParams,
                   offsetof(SP_DEVINSTALL_PARAMS_W,DriverPath)
                  );

        AnsiDevInstParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS_A);

        //
        // Convert the single string in the structure. Unfortunately there is
        // potential for overflow because some Unicode chars could convert to
        // double-byte ANSI characters -- but the string in the ANSI structure
        // is only MAX_PATH *bytes* (not MAX_PATH double-byte *characters*) 
        // long.
        //
        rc = GLE_FN_CALL(0,
                         WideCharToMultiByte(
                             CP_ACP,
                             0,
                             UnicodeDevInstParams->DriverPath,
                             SIZECHARS(UnicodeDevInstParams->DriverPath),
                             AnsiString,
                             sizeof(AnsiString),
                             NULL,
                             NULL)
                        );
                        
        if(rc != NO_ERROR) {
            leave;
        }

        //
        // Copy converted string into caller's structure, limiting
        // its length to avoid overflow.
        //
        hr = StringCchCopyA(AnsiDevInstParams->DriverPath,
                            sizeof(AnsiDevInstParams->DriverPath),
                            AnsiString
                            );
        if(FAILED(hr)) {
            rc = HRESULT_CODE(hr);
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    return rc;
}


DWORD
pSetupDiSelDevParamsAnsiToUnicode(
    IN  PSP_SELECTDEVICE_PARAMS_A AnsiSelDevParams,
    OUT PSP_SELECTDEVICE_PARAMS_W UnicodeSelDevParams
    )

/*++

Routine Description:

    This routine converts an SP_SELECTDEVICE_PARAMS_A structure to
    an SP_SELECTDEVICE_PARAMS_W, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    AnsiSelDevParams - supplies ANSI device selection parameters
        to be converted to unicode.

    UnicodeSelDevParams - if successful, receives Unicode equivalent of
        AnsiSelDevParams.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    It is not believed that, given valid arguments, text conversion itself
    can fail, since all ANSI chars always have Unicode equivalents.

--*/

{
    DWORD rc;

    try {

        if(AnsiSelDevParams->ClassInstallHeader.cbSize != sizeof(SP_CLASSINSTALL_HEADER)) {
            rc = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        //
        // Fixed part of structure.
        //
        MYASSERT(offsetof(SP_SELECTDEVICE_PARAMS_A,Title) == offsetof(SP_SELECTDEVICE_PARAMS_W,Title));

        CopyMemory(
            UnicodeSelDevParams,
            AnsiSelDevParams,
            offsetof(SP_SELECTDEVICE_PARAMS_W,Title)
            );

        //
        // Convert the strings in the structure. To make things easier
        // we'll just convert the entire buffers. There's no potential for 
        // overflow.
        //
        rc = GLE_FN_CALL(0,
                         MultiByteToWideChar(
                             CP_ACP,
                             MB_PRECOMPOSED,
                             AnsiSelDevParams->Title,
                             sizeof(AnsiSelDevParams->Title),
                             UnicodeSelDevParams->Title,
                             SIZECHARS(UnicodeSelDevParams->Title))
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(0,
                         MultiByteToWideChar(
                             CP_ACP,
                             MB_PRECOMPOSED,
                             AnsiSelDevParams->Instructions,
                             sizeof(AnsiSelDevParams->Instructions),
                             UnicodeSelDevParams->Instructions,
                             SIZECHARS(UnicodeSelDevParams->Instructions))
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(0,
                         MultiByteToWideChar(
                             CP_ACP,
                             MB_PRECOMPOSED,
                             AnsiSelDevParams->ListLabel,
                             sizeof(AnsiSelDevParams->ListLabel),
                             UnicodeSelDevParams->ListLabel,
                             SIZECHARS(UnicodeSelDevParams->ListLabel))
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(0,
                         MultiByteToWideChar(
                             CP_ACP,
                             MB_PRECOMPOSED,
                             AnsiSelDevParams->SubTitle,
                             sizeof(AnsiSelDevParams->SubTitle),
                             UnicodeSelDevParams->SubTitle,
                             SIZECHARS(UnicodeSelDevParams->SubTitle))
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }    

    return rc;
}


DWORD
pSetupDiSelDevParamsUnicodeToAnsi(
    IN  PSP_SELECTDEVICE_PARAMS_W UnicodeSelDevParams,
    OUT PSP_SELECTDEVICE_PARAMS_A AnsiSelDevParams
    )

/*++

Routine Description:

    This routine converts an SP_SELECTDEVICE_PARAMS_W structure to
    an SP_SELECTDEVICE_PARAMS_A, guarding against bogus pointers
    passed in the by the caller.  It is assumed that the ANSI output buffer is
    of sufficient size, and that its ClassInstallHeader.cbSize field is
    initialized correctly.

Arguments:

    UnicodeSelDevParams - supplies Unicode device selection parameters
        to be converted to ANSI.

    AnsiSelDevParams - if successful, receives Ansi equivalent of
        UnicodeSelDevParams.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    Unicode chars that can't be represented in the current system ANSI codepage
    will be replaced with a system default in the ANSI structure.

--*/

{
    DWORD rc;
    UCHAR AnsiTitle[MAX_TITLE_LEN*2];
    UCHAR AnsiInstructions[MAX_INSTRUCTION_LEN*2];
    UCHAR AnsiListLabel[MAX_LABEL_LEN*2];
    UCHAR AnsiSubTitle[MAX_SUBTITLE_LEN*2];
    HRESULT hr;

    MYASSERT(UnicodeSelDevParams->ClassInstallHeader.cbSize == sizeof(SP_CLASSINSTALL_HEADER));
    MYASSERT(AnsiSelDevParams->ClassInstallHeader.cbSize    == sizeof(SP_CLASSINSTALL_HEADER));

    try {
        //
        // Fixed part of structure.
        //
        MYASSERT(offsetof(SP_SELECTDEVICE_PARAMS_A,Title) == offsetof(SP_SELECTDEVICE_PARAMS_W,Title));

        CopyMemory(
            AnsiSelDevParams,
            UnicodeSelDevParams,
            offsetof(SP_SELECTDEVICE_PARAMS_W,Title)
            );

        ZeroMemory(AnsiSelDevParams->Reserved,sizeof(AnsiSelDevParams->Reserved));

        //
        // Convert the strings in the structure. Unfortunately there is
        // potential for overflow because some Unicode chars could convert to
        // double-byte ANSI characters -- but the strings in the ANSI structure
        // are sized in *bytes* (not double-byte *characters*).
        //
        rc = GLE_FN_CALL(0,
                         WideCharToMultiByte(
                             CP_ACP,
                             0,
                             UnicodeSelDevParams->Title,
                             SIZECHARS(UnicodeSelDevParams->Title),
                             AnsiTitle,
                             sizeof(AnsiTitle),
                             NULL,
                             NULL)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(0,
                         WideCharToMultiByte(
                             CP_ACP,
                             0,
                             UnicodeSelDevParams->Instructions,
                             SIZECHARS(UnicodeSelDevParams->Instructions),
                             AnsiInstructions,
                             sizeof(AnsiInstructions),
                             NULL,
                             NULL)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(0,
                         WideCharToMultiByte(
                             CP_ACP,
                             0,
                             UnicodeSelDevParams->ListLabel,
                             SIZECHARS(UnicodeSelDevParams->ListLabel),
                             AnsiListLabel,
                             sizeof(AnsiListLabel),
                             NULL,
                             NULL)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(0,
                         WideCharToMultiByte(
                             CP_ACP,
                             0,
                             UnicodeSelDevParams->SubTitle,
                             SIZECHARS(UnicodeSelDevParams->SubTitle),
                             AnsiSubTitle,
                             sizeof(AnsiSubTitle),
                             NULL,
                             NULL)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        //
        // Copy converted strings into caller's structure, limiting lengths to
        // avoid overflow.
        //
#undef CPYANS
#define CPYANS(field) StringCchCopyA(AnsiSelDevParams->field,            \
                                     sizeof(AnsiSelDevParams->field),    \
                                     Ansi##field)

        if(FAILED(hr = CPYANS(Title)) ||
           FAILED(hr = CPYANS(Instructions)) ||
           FAILED(hr = CPYANS(ListLabel)) ||
           FAILED(hr = CPYANS(SubTitle))) {

            rc = HRESULT_CODE(hr);
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    return rc;
}


DWORD
pSetupDiDrvInfoDataAnsiToUnicode(
    IN  PSP_DRVINFO_DATA_A AnsiDrvInfoData,
    OUT PSP_DRVINFO_DATA_W UnicodeDrvInfoData
    )

/*++

Routine Description:

    This routine converts an SP_DRVINFO_DATA_A structure to
    an SP_DRVINFO_DATA_W, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    AnsiDrvInfoData - supplies ANSI structure to be converted to unicode.

    UnicodeDrvInfoData - if successful, receives Unicode equivalent of
        AnsiDrvInfoData.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    It is not believed that, given valid arguments, text conversion itself
    can fail, since all ANSI chars always have Unicode equivalents.

--*/

{
    DWORD rc;

    try {

        if((AnsiDrvInfoData->cbSize != sizeof(SP_DRVINFO_DATA_A)) &&
           (AnsiDrvInfoData->cbSize != sizeof(SP_DRVINFO_DATA_V1_A))) {

            rc = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        //
        // Fixed part of structure.
        //
        MYASSERT(offsetof(SP_DRVINFO_DATA_A,Description) == offsetof(SP_DRVINFO_DATA_W,Description));

        ZeroMemory(UnicodeDrvInfoData, sizeof(SP_DRVINFO_DATA_W));

        CopyMemory(
            UnicodeDrvInfoData,
            AnsiDrvInfoData,
            offsetof(SP_DRVINFO_DATA_W,Description)
            );

        UnicodeDrvInfoData->cbSize = sizeof(SP_DRVINFO_DATA_W);

        //
        // Convert the strings in the structure. To make things easier we'll
        // just convert the entire buffers. There's no potential for overflow.
        //
        rc = GLE_FN_CALL(0,
                         MultiByteToWideChar(
                             CP_ACP,
                             MB_PRECOMPOSED,
                             AnsiDrvInfoData->Description,
                             sizeof(AnsiDrvInfoData->Description),
                             UnicodeDrvInfoData->Description,
                             SIZECHARS(UnicodeDrvInfoData->Description))
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(0,
                         MultiByteToWideChar(
                             CP_ACP,
                             MB_PRECOMPOSED,
                             AnsiDrvInfoData->MfgName,
                             sizeof(AnsiDrvInfoData->MfgName),
                             UnicodeDrvInfoData->MfgName,
                             SIZECHARS(UnicodeDrvInfoData->MfgName))
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(0,
                         MultiByteToWideChar(
                             CP_ACP,
                             MB_PRECOMPOSED,
                             AnsiDrvInfoData->ProviderName,
                             sizeof(AnsiDrvInfoData->ProviderName),
                             UnicodeDrvInfoData->ProviderName,
                             SIZECHARS(UnicodeDrvInfoData->ProviderName))
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        //
        // Successfully converted all strings to unicode.  Set the final two
        // fields (DriverDate and DriverVersion) unless the caller supplied us
        // with a version 1 structure.
        //
        if(AnsiDrvInfoData->cbSize == sizeof(SP_DRVINFO_DATA_A)) {
            UnicodeDrvInfoData->DriverDate = AnsiDrvInfoData->DriverDate;
            UnicodeDrvInfoData->DriverVersion = AnsiDrvInfoData->DriverVersion;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }    

    return rc;
}


DWORD
pSetupDiDrvInfoDataUnicodeToAnsi(
    IN  PSP_DRVINFO_DATA_W UnicodeDrvInfoData,
    OUT PSP_DRVINFO_DATA_A AnsiDrvInfoData
    )

/*++

Routine Description:

    This routine converts an SP_DRVINFO_DATA_W structure to
    an SP_DRVINFO_DATA_A, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    UnicodeDrvInfoData - supplies Unicode structure to be converted
        to ANSI.

    AnsiDrvInfoData - if successful, receives Ansi equivalent of
        UnicodeDrvInfoData.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    Unicode chars that can't be represented in the current system ANSI codepage
    will be replaced with a system default in the ANSI structure.

--*/

{
    DWORD rc;
    UCHAR AnsiDescription[LINE_LEN*2];
    UCHAR AnsiMfgName[LINE_LEN*2];
    UCHAR AnsiProviderName[LINE_LEN*2];
    HRESULT hr;

    MYASSERT(UnicodeDrvInfoData->cbSize == sizeof(SP_DRVINFO_DATA_W));

    try {

        if((AnsiDrvInfoData->cbSize != sizeof(SP_DRVINFO_DATA_A)) &&
           (AnsiDrvInfoData->cbSize != sizeof(SP_DRVINFO_DATA_V1_A))) {

            rc = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        //
        // Copy over the DriverType and the Reserved field.
        //
        AnsiDrvInfoData->DriverType = UnicodeDrvInfoData->DriverType;
        AnsiDrvInfoData->Reserved = UnicodeDrvInfoData->Reserved;

        //
        // Convert the strings in the structure. Unfortunately there is
        // potential for overflow because some Unicode chars could convert 
        // to double-byte ANSI characters -- but the strings in the ANSI 
        // structure are sized in *bytes* (not double-byte *characters*).
        //
        rc = GLE_FN_CALL(0,
                         WideCharToMultiByte(
                             CP_ACP,
                             0,
                             UnicodeDrvInfoData->Description,
                             SIZECHARS(UnicodeDrvInfoData->Description),
                             AnsiDescription,
                             sizeof(AnsiDescription),
                             NULL,
                             NULL)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(0,
                         WideCharToMultiByte(
                             CP_ACP,
                             0,
                             UnicodeDrvInfoData->MfgName,
                             SIZECHARS(UnicodeDrvInfoData->MfgName),
                             AnsiMfgName,
                             sizeof(AnsiMfgName),
                             NULL,
                             NULL)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(0,
                         WideCharToMultiByte(
                             CP_ACP,
                             0,
                             UnicodeDrvInfoData->ProviderName,
                             SIZECHARS(UnicodeDrvInfoData->ProviderName),
                             AnsiProviderName,
                             sizeof(AnsiProviderName),
                             NULL,
                             NULL)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        //
        // Copy converted strings into caller's structure, limiting lengths to
        // avoid overflow.
        //
#undef CPYANS
#define CPYANS(field) StringCchCopyA(AnsiDrvInfoData->field,          \
                                     sizeof(AnsiDrvInfoData->field),  \
                                     Ansi##field)
                       
        if(FAILED(hr = CPYANS(Description)) ||
           FAILED(hr = CPYANS(MfgName)) ||
           FAILED(hr = CPYANS(ProviderName))) {

            rc = HRESULT_CODE(hr);
            leave;
        }
            
        //
        // Successfully converted/transferred all the unicode strings back to
        // ANSI.  Now, set the final two fields (DriverDate and DriverVersion)
        // unless the caller supplied us with a version 1 structure.
        //
        if(AnsiDrvInfoData->cbSize == sizeof(SP_DRVINFO_DATA_A)) {
            AnsiDrvInfoData->DriverDate = UnicodeDrvInfoData->DriverDate;
            AnsiDrvInfoData->DriverVersion = UnicodeDrvInfoData->DriverVersion;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    return rc;
}


DWORD
pSetupDiDevInfoSetDetailDataUnicodeToAnsi(
    IN  PSP_DEVINFO_LIST_DETAIL_DATA_W UnicodeDevInfoSetDetails,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_A AnsiDevInfoSetDetails
    )

/*++

Routine Description:

    This routine converts an SP_DEVINFO_LIST_DETAIL_DATA_W structure
    to an SP_DEVINFO_LIST_DETAIL_DATA_A, guarding against bogus pointers
    passed in the by the caller.

Arguments:

    UnicodeDevInfoSetDetails - supplies Unicode structure to be converted
        to ANSI.

    AnsiDevInfoSetDetails - if successful, receives Ansi equivalent of
        UnicodeDevInfoSetDetails.

Return Value:

    NO_ERROR                - conversion successful.
    ERROR_INVALID_PARAMETER - one of the arguments was not a valid pointer.

    Unicode chars that can't be represented in the current system ANSI codepage
    will be replaced with a system default in the ANSI structure.

--*/

{
    DWORD rc;
    UCHAR AnsiRemoteMachineName[SP_MAX_MACHINENAME_LENGTH * 2];
    HRESULT hr;

    MYASSERT(UnicodeDevInfoSetDetails->cbSize == sizeof(SP_DEVINFO_LIST_DETAIL_DATA_W));

    rc = NO_ERROR;

    try {

        if(AnsiDevInfoSetDetails->cbSize != sizeof(SP_DEVINFO_LIST_DETAIL_DATA_A)) {
            rc = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        //
        // Fixed part of structure.
        //
        MYASSERT(offsetof(SP_DEVINFO_LIST_DETAIL_DATA_A, RemoteMachineName) ==
                 offsetof(SP_DEVINFO_LIST_DETAIL_DATA_W, RemoteMachineName)
                );

        CopyMemory(AnsiDevInfoSetDetails,
                   UnicodeDevInfoSetDetails,
                   offsetof(SP_DEVINFO_LIST_DETAIL_DATA_W, RemoteMachineName)
                  );

        AnsiDevInfoSetDetails->cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA_A);

        //
        // Convert the strings in the structure. Unfortunately there is
        // potential for overflow because some Unicode chars could convert to
        // double-byte ANSI characters -- but the strings in the ANSI structure
        // are sized in *bytes* (not double-byte *characters*).
        //
        rc = GLE_FN_CALL(0,
                         WideCharToMultiByte(
                             CP_ACP,
                             0,
                             UnicodeDevInfoSetDetails->RemoteMachineName,
                             SIZECHARS(UnicodeDevInfoSetDetails->RemoteMachineName),
                             AnsiRemoteMachineName,
                             sizeof(AnsiRemoteMachineName),
                             NULL,
                             NULL)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        //
        // Copy converted string into caller's structure, limiting lengths to
        // avoid overflow.
        //
        hr = StringCchCopyA(AnsiDevInfoSetDetails->RemoteMachineName,
                            sizeof(AnsiDevInfoSetDetails->RemoteMachineName),
                            AnsiRemoteMachineName
                            );
        if(FAILED(hr)) {
            rc = HRESULT_CODE(hr);
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\diamond.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    diamond.c

Abstract:

    Diamond MSZIP decompression support.

Author:

    Ted Miller (tedm) 31-Jan-1995

Revision History:

    Jamie Hunter (JamieHun) Jul-12-2000
        Made this behave better in MUI scenario
        changed all handles to be of type HANDLE rather than HFILE
        use UNICODE where we can
        convert path to short filename in the one place we can't

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
DiamondInitialize(
    VOID
    );

INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    );

int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    );


UINT
pDiamondNotifyFileDone(
    IN PDIAMOND_THREAD_DATA PerThread,
    IN DWORD                Win32Error
    )
{
    UINT u;
    FILEPATHS FilePaths;

    MYASSERT(PerThread->CurrentTargetFile);

    FilePaths.Source = PerThread->CabinetFile;
    FilePaths.Target = PerThread->CurrentTargetFile;
    FilePaths.Win32Error = Win32Error;

    u = pSetupCallMsgHandler(
            NULL, // LogContext - we get from thread log context
            PerThread->MsgHandler,
            PerThread->IsMsgHandlerNativeCharWidth,
            PerThread->Context,
            SPFILENOTIFY_FILEEXTRACTED,
            (UINT_PTR)&FilePaths,
            0
            );

    return(u);
}


INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    PSETUP_TLS pTLS;
    PDIAMOND_THREAD_DATA PerThread;
    INT_PTR rc;
    HANDLE hFile;
    CABINET_INFO CabInfo;
    FILE_IN_CABINET_INFO FileInCab;
    FILETIME FileTime, UtcTime;
    TCHAR NewPath[MAX_PATH];
    PTSTR p;
    DWORD err;
    UINT action;

    pTLS = SetupGetTlsData();
    if(!pTLS) {
        return (INT_PTR)(-1);
    }
    PerThread = &pTLS->Diamond;

    switch(Operation) {

    case fdintCABINET_INFO:
        //
        // Tell the callback function, in case it wants to do something
        // with this information.
        //
        err = ERROR_NOT_ENOUGH_MEMORY;

        CabInfo.CabinetFile = NewPortableString(Parameters->psz1);
        if(CabInfo.CabinetFile) {

            CabInfo.DiskName = NewPortableString(Parameters->psz2);
            if(CabInfo.DiskName) {

                CabInfo.CabinetPath = NewPortableString(Parameters->psz3);
                if(CabInfo.CabinetPath) {

                    CabInfo.SetId = Parameters->setID;
                    CabInfo.CabinetNumber = Parameters->iCabinet;

                    err = (DWORD)pSetupCallMsgHandler(
                            NULL, // LogContext - we get from thread log context
                            PerThread->MsgHandler,
                            PerThread->IsMsgHandlerNativeCharWidth,
                            PerThread->Context,
                            SPFILENOTIFY_CABINETINFO,
                            (UINT_PTR)&CabInfo,
                            0
                            );

                    MyFree(CabInfo.CabinetPath);
                }
                MyFree(CabInfo.DiskName);
            }
            MyFree(CabInfo.CabinetFile);
        }

        if(err != NO_ERROR) {
            PerThread->LastError = err;
        }
        return (INT_PTR)((err == NO_ERROR) ? 0 : -1);

    case fdintCOPY_FILE:
        //
        // Diamond is asking us whether we want to copy the file.
        // If we switched cabinets, then the answer is no.
        //
        if(PerThread->SwitchedCabinets) {
            PerThread->LastError = NO_ERROR;
            return (INT_PTR)(-1);
        }

        // Pass the information on to the callback function and
        // let it decide.
        //
        FileInCab.NameInCabinet = NewPortableString(Parameters->psz1);
        FileInCab.FileSize = Parameters->cb;
        FileInCab.DosDate = Parameters->date;
        FileInCab.DosTime = Parameters->time;
        FileInCab.DosAttribs = Parameters->attribs;
        FileInCab.Win32Error = NO_ERROR;

        if(!FileInCab.NameInCabinet) {
            PerThread->LastError = ERROR_NOT_ENOUGH_MEMORY;
            return (INT_PTR)(-1);
        }

        //
        // Call the callback function.
        //
        action = pSetupCallMsgHandler(NULL, // LogContext - we get from thread log context
                                      PerThread->MsgHandler,
                                      PerThread->IsMsgHandlerNativeCharWidth,
                                      PerThread->Context,
                                      SPFILENOTIFY_FILEINCABINET,
                                      (UINT_PTR)&FileInCab,
                                      (UINT_PTR)PerThread->CabinetFile
                                      );

        MyFree (FileInCab.NameInCabinet);

        switch(action) {

        case FILEOP_SKIP:
            rc = 0;
            break;

        case FILEOP_DOIT:
            //
            // The callback wants to copy the file. In this case it has
            // provided us the full target pathname to use.
            //
            MYASSERT(PerThread->CurrentTargetFile == NULL);

            if(p = DuplicateString(FileInCab.FullTargetName)) {

                //
                // we need ANSI version of filename for sake of Diamond API's
                // note that the handle returned here must be compatible with
                // the handle returned by SpdFdiOpen
                //

                hFile = CreateFile(FileInCab.FullTargetName,
                                   GENERIC_READ | GENERIC_WRITE,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE, // should probably be 0
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

                if(hFile == INVALID_HANDLE_VALUE) {
                    PerThread->LastError = GetLastError();
                    rc = -1;
                    MyFree(p);
                } else {
                    rc = (INT_PTR)hFile;
                    PerThread->CurrentTargetFile = p;
                }
            } else {

                PerThread->LastError = ERROR_NOT_ENOUGH_MEMORY;
                rc = -1;
            }

            break;

        case FILEOP_ABORT:
            //
            // Abort.
            //
            rc = -1;
            PerThread->LastError = FileInCab.Win32Error;
            //
            // here, if PerThread->LastError is still NO_ERROR, this is ok
            // it was the callback's intent
            // we know callback itself is ok, since internal failure returns
            // FILEOP_INTERNAL_FAILED
            //
            break;

        case FILEOP_INTERNAL_FAILED:
            //
            // should only be returned by callback wrapper
            //
            PerThread->LastError = GetLastError();
            if(!PerThread->LastError) {
                MYASSERT(PerThread->LastError);
                PerThread->LastError = ERROR_OPERATION_ABORTED;
            }
            rc = -1;
            break;

        default:
            PerThread->LastError = ERROR_OPERATION_ABORTED;
        }

        return rc;

    case fdintCLOSE_FILE_INFO:
        //
        // Diamond is done with the target file and wants us to close it.
        // (ie, this is the counterpart to fdintCOPY_FILE).
        //
        // We want the timestamp to be what is stored in the cabinet.
        // Note that we lose the create and last access times in this case.
        //
        if(DosDateTimeToFileTime(Parameters->date,Parameters->time,&FileTime) &&
            LocalFileTimeToFileTime(&FileTime, &UtcTime)) {

            SetFileTime((HANDLE)Parameters->hf,NULL,NULL,&UtcTime);
        }

        SpdFdiClose(Parameters->hf);

        //
        // Call the callback function to inform it that the file has been
        // successfully extracted from the cabinet.
        //
        MYASSERT(PerThread->CurrentTargetFile);

        err = (DWORD)pDiamondNotifyFileDone(PerThread,NO_ERROR);

        if(err != NO_ERROR) {
            PerThread->LastError = err;
        }

        MyFree(PerThread->CurrentTargetFile);
        PerThread->CurrentTargetFile = NULL;

        return (INT_PTR)((err == NO_ERROR) ? TRUE : -1);

    case fdintPARTIAL_FILE:
    case fdintENUMERATE:

        //
        // We don't do anything with this.
        //
        return (INT_PTR)(0);

    case fdintNEXT_CABINET:

        if((Parameters->fdie == FDIERROR_NONE) || (Parameters->fdie == FDIERROR_WRONG_CABINET)) {
            //
            // A file continues into another cabinet.
            // Inform the callback function, who is responsible for
            // making sure the cabinet is accessible when it returns.
            //
            err = ERROR_NOT_ENOUGH_MEMORY;
            CabInfo.SetId = 0;
            CabInfo.CabinetNumber = 0;

            CabInfo.CabinetPath = NewPortableString(Parameters->psz3);
            if(CabInfo.CabinetPath) {

                CabInfo.CabinetFile = NewPortableString(Parameters->psz1);
                if(CabInfo.CabinetFile) {

                    CabInfo.DiskName = NewPortableString(Parameters->psz2);
                    if(CabInfo.DiskName) {

                        err = (DWORD)pSetupCallMsgHandler(NULL, // LogContext - we get from thread log context
                                                          PerThread->MsgHandler,
                                                          PerThread->IsMsgHandlerNativeCharWidth,
                                                          PerThread->Context,
                                                          SPFILENOTIFY_NEEDNEWCABINET,
                                                          (UINT_PTR)&CabInfo,
                                                          (UINT_PTR)NewPath
                                                          );

                        if(err == NO_ERROR) {
                            //
                            // See if a new path was specified.
                            //
                            if(NewPath[0]) {
                                lstrcpyn(PerThread->UserPath,NewPath,MAX_PATH);
                                if(!pSetupConcatenatePaths(PerThread->UserPath,TEXT("\\"),MAX_PATH,NULL)) {
                                    err = ERROR_BUFFER_OVERFLOW;
                                } else {
                                    PSTR pp = NewAnsiString(PerThread->UserPath);
                                    if(strlen(pp)>=CB_MAX_CAB_PATH) {
                                        err = ERROR_BUFFER_OVERFLOW;
                                    } else {
                                        strcpy(Parameters->psz3,pp);
                                    }
                                    MyFree(pp);
                                }
                            }
                        }
                        if(err == NO_ERROR) {
                            //
                            // Remember that we switched cabinets.
                            //
                            PerThread->SwitchedCabinets = TRUE;
                        }

                        MyFree(CabInfo.DiskName);
                    }

                    MyFree(CabInfo.CabinetFile);
                }

                MyFree(CabInfo.CabinetPath);
            }

        } else {
            //
            // Some other error we don't understand -- this indicates
            // a bad cabinet.
            //
            err = ERROR_INVALID_DATA;
        }

        if(err != NO_ERROR) {
            PerThread->LastError = err;
        }

        return (INT_PTR)((err == NO_ERROR) ? 0 : -1);

    default:
        //
        // Unknown notification type. Should never get here.
        //
        MYASSERT(0);
        return (INT_PTR)(0);
    }
}

PVOID
DIAMONDAPI
SpdFdiAlloc(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by FDICopy to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return(MyMalloc(NumberOfBytes));
}


VOID
DIAMONDAPI
SpdFdiFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by FDICopy to free a memory block.
    The block must have been allocated with SpdFdiAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    MyFree(Block);
}


INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )

/*++

Routine Description:

    Callback used by FDICopy to open files.

    This routine is capable only of opening existing files.

    When making changes here, also take note of other places
    that open the file directly (search for SpdFdiOpen)

Arguments:

    FileName - supplies name of file to be opened.

    oflag - supplies flags for open.

    pmode - supplies additional flags for open.

Return Value:

    Handle to open file or -1 if error occurs.

--*/

{
    HANDLE h;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;

    UNREFERENCED_PARAMETER(pmode);

    pTLS = SetupGetTlsData();
    if (!pTLS) {
        return -1;
    }
    PerThread = &pTLS->Diamond;

    MYASSERT(PerThread);

    if(oflag & (_O_WRONLY | _O_RDWR | _O_APPEND | _O_CREAT | _O_TRUNC | _O_EXCL)) {
        PerThread->LastError = ERROR_INVALID_PARAMETER;
        return(-1);
    }

    h = CreateFileA(FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);
    if(h == INVALID_HANDLE_VALUE) {
        PerThread->LastError = GetLastError();
        return(-1);
    }

    return (INT_PTR)h;
}

UINT
DIAMONDAPI
SpdFdiRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to read from a file.

Arguments:

    Handle - supplies handle to open file to be read from.

    pv - supplies pointer to buffer to receive bytes we read.

    ByteCount - supplies number of bytes to read.

Return Value:

    Number of bytes read or -1 if an error occurs.

--*/

{
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;
    DWORD d;
    HANDLE hFile = (HANDLE)Handle;
    DWORD bytes;
    UINT rc;

    if(ReadFile(hFile,pv,(DWORD)ByteCount,&bytes,NULL)) {
        rc = (UINT)bytes;
    } else {
        d = GetLastError();
        rc = (UINT)(-1);

        pTLS = SetupGetTlsData();
        MYASSERT(pTLS);
        PerThread = &pTLS->Diamond;
        PerThread->LastError = d;
    }
    return rc;
}


UINT
DIAMONDAPI
SpdFdiWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to write to a file.

Arguments:

    Handle - supplies handle to open file to be written to.

    pv - supplies pointer to buffer containing bytes to write.

    ByteCount - supplies number of bytes to write.

Return Value:

    Number of bytes written (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;
    DWORD d;
    HANDLE hFile = (HANDLE)Handle;
    DWORD bytes;

    if(WriteFile(hFile,pv,(DWORD)ByteCount,&bytes,NULL)) {
        rc = (UINT)bytes;
    } else {
        d = GetLastError();
        rc = (UINT)(-1);

        pTLS = SetupGetTlsData();
        MYASSERT(pTLS);
        PerThread = &pTLS->Diamond;
        PerThread->LastError = d;
    }

    return rc;
}


int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    )

/*++

Routine Description:

    Callback used by FDICopy to close files.

Arguments:

    Handle - handle of file to close.

Return Value:

    0 (success).

--*/

{
    HANDLE hFile = (HANDLE)Handle;
    BOOL success = FALSE;

    //
    // diamond has in the past given us an invalid file handle
    // actually it gives us the same file handle twice.
    //
    //
    try {
        success = CloseHandle(hFile);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        success = FALSE;
    }

    MYASSERT(success);

    //
    // Always act like we succeeded.
    //
    return 0;
}


long
DIAMONDAPI
SpdFdiSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    )

/*++

Routine Description:

    Callback used by FDICopy to seek files.

Arguments:

    Handle - handle of file to close.

    Distance - supplies distance to seek. Interpretation of this
        parameter depends on the value of SeekType.

    SeekType - supplies a value indicating how Distance is to be
        interpreted; one of SEEK_SET, SEEK_CUR, SEEK_END.

Return Value:

    New file offset or -1 if an error occurs.

--*/

{
    LONG rc;
    DWORD d;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;
    HANDLE hFile = (HANDLE)Handle;
    DWORD pos_low;
    DWORD method;

    switch(SeekType) {
        case SEEK_SET:
            method = FILE_BEGIN;
            break;

        case SEEK_CUR:
            method = FILE_CURRENT;
            break;

        case SEEK_END:
            method = FILE_END;
            break;

        default:
            return -1;
    }

    pos_low = SetFilePointer(hFile,(DWORD)Distance,NULL,method);
    if(pos_low == INVALID_SET_FILE_POINTER) {
        d = GetLastError();
        rc = -1L;

        pTLS = SetupGetTlsData();
        MYASSERT(pTLS);
        PerThread = &pTLS->Diamond;
        PerThread->LastError = d;
    } else {
        rc = (long)pos_low;
    }

    return(rc);
}


DWORD
DiamondProcessCabinet(
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth
    )

/*++

Routine Description:

    Process a diamond cabinet file, iterating through all files
    contained within it and calling the callback function with
    information about each file.

Arguments:

    SourceFileName - supplies name of cabinet file.

    Flags - supplies flags to control behavior of cabinet processing.

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in cabinet processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

Return Value:

    Win32 error code indicating result. If the cabinet was corrupt,
    ERROR_INVALID_DATA is returned.

--*/

{
    BOOL b;
    DWORD rc;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;
    PSTR FilePartA = NULL;
    PSTR PathPartA = NULL;
    PCTSTR FileTitle;
    CHAR c;
    int h;

    UNREFERENCED_PARAMETER(Flags);

    //
    // Fetch pointer to per-thread data.
    // may cause initialization
    //
    pTLS = SetupGetTlsData();
    if(!pTLS) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }
    PerThread = &pTLS->Diamond;

    MYASSERT(PerThread->FdiContext);

    //
    // Because diamond does not really give us a truly comprehensive
    // context mechanism, our diamond support is NOT reentrant.
    // No synchronization is required to check this state because
    // it is stored in per-thread data.
    //
    if(PerThread->InDiamond) {
        rc = ERROR_INVALID_FUNCTION;
        goto c0;
    }

    PerThread->InDiamond = TRUE;

    //
    // Split the cabinet name into path and name.
    // we need to convert to short-name format before
    // passing it on, so that diamond doesn't get upset
    // in MUI install situations
    //
    FileTitle = pSetupGetFileTitle(CabinetFile);
    FilePartA = GetAnsiMuiSafeFilename(FileTitle);
    PathPartA = GetAnsiMuiSafePathname(CabinetFile);
    if(!FilePartA || !PathPartA) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c1;
    }

    //
    // Initialize thread globals.
    //
    PerThread->LastError = NO_ERROR;
    PerThread->CabinetFile = CabinetFile;

    PerThread->MsgHandler = MsgHandler;
    PerThread->IsMsgHandlerNativeCharWidth = IsMsgHandlerNativeCharWidth;
    PerThread->Context = Context;

    PerThread->SwitchedCabinets = FALSE;
    PerThread->UserPath[0] = 0;

    PerThread->CurrentTargetFile = NULL;

    //
    // Perform the copy.
    //
    b = FDICopy(
            PerThread->FdiContext,
            FilePartA,
            PathPartA,
            0,                          // flags
            DiamondNotifyFunction,
            NULL,                       // no decryption
            NULL                        // don't bother with user-specified data
            );

    if(b) {

        //
        // Everything succeeded so we shouldn't have any partially
        // processed files.
        //
        MYASSERT(!PerThread->CurrentTargetFile);
        rc = NO_ERROR;

    } else {

        switch(PerThread->FdiError.erfOper) {

        case FDIERROR_NONE:
            //
            // We shouldn't see this -- if there was no error
            // then FDICopy should have returned TRUE.
            //
            MYASSERT(PerThread->FdiError.erfOper != FDIERROR_NONE);
            rc = ERROR_INVALID_DATA;
            break;

        case FDIERROR_CABINET_NOT_FOUND:
            rc = ERROR_FILE_NOT_FOUND;
            break;

        case FDIERROR_CORRUPT_CABINET:
            //
            // Read/open/seek error or corrupt cabinet
            //
            rc = PerThread->LastError;
            if(rc == NO_ERROR) {
                rc = ERROR_INVALID_DATA;
            }
            break;

        case FDIERROR_ALLOC_FAIL:
            rc = ERROR_NOT_ENOUGH_MEMORY;
            break;

        case FDIERROR_TARGET_FILE:
        case FDIERROR_USER_ABORT:
            rc = PerThread->LastError;
            break;

        case FDIERROR_NOT_A_CABINET:
        case FDIERROR_UNKNOWN_CABINET_VERSION:
        case FDIERROR_BAD_COMPR_TYPE:
        case FDIERROR_MDI_FAIL:
        case FDIERROR_RESERVE_MISMATCH:
        case FDIERROR_WRONG_CABINET:
        default:
            //
            // Cabinet is corrupt or not actually a cabinet, etc.
            //
            rc = ERROR_INVALID_DATA;
            break;
        }

        if(PerThread->CurrentTargetFile) {
            //
            // Call the callback function to inform it that the last file
            // was not successfully extracted from the cabinet.
            // Also remove the partially copied file.
            //
            DeleteFile(PerThread->CurrentTargetFile);

            pDiamondNotifyFileDone(PerThread,rc);
            MyFree(PerThread->CurrentTargetFile);
            PerThread->CurrentTargetFile = NULL;
        }

    }

c1:
    if(FilePartA) {
        MyFree(FilePartA);
    }
    if(PathPartA) {
        MyFree(PathPartA);
    }
    PerThread->InDiamond = FALSE;
c0:
    return(rc);
}


BOOL
DiamondIsCabinet(
    IN PCTSTR FileName
    )

/*++

Routine Description:

    Determine if a file is a diamond cabinet.

Arguments:

    FileName - supplies name of file to be checked.

Return Value:

    TRUE if file is diamond file. FALSE if not;

--*/

{
    FDICABINETINFO CabinetInfo;
    BOOL b;
    INT_PTR h;
    HANDLE hFile;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;

    b = FALSE;

    //
    // Get TLS data, may cause initialization
    //
    pTLS = SetupGetTlsData();
    if(!pTLS) {
        goto c0;
    }

    if (!FileExists(FileName,NULL)) {
        return FALSE;
    }

    PerThread = &pTLS->Diamond;

    MYASSERT(PerThread->FdiContext);

    //
    // Because diamond does not really give us a truly comprehensive
    // context mechanism, our diamond support is NOT reentrant.
    // No synchronization is required to check this state because
    // it is stored in per-thread data.
    //
    if(PerThread->InDiamond) {
        MYASSERT( FALSE && TEXT("PerThread->InDiamond failed") );
        goto c0;
    }

    PerThread->InDiamond = TRUE;

    //
    // The handle returned here must be compatible with
    // that returnd by SpdFdiOpen
    //
    hFile = CreateFile(FileName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);
    if(hFile == INVALID_HANDLE_VALUE) {
        goto c1;
    }
    h = (INT_PTR)hFile;
    SpdFdiSeek(h , 0, SEEK_SET);
    b = FDIIsCabinet(PerThread->FdiContext,h,&CabinetInfo);

#if DBG
    if (!b) {
        LPCTSTR p;
        p = _tcsrchr(FileName, TEXT('.'));
        while (p && *p) {
            if (*p == '_') {
                MYASSERT(FALSE && TEXT("FDIIsCabinetFailed for a file ending in _"));
                SpdFdiSeek(h , 0, SEEK_SET);
                FDIIsCabinet(PerThread->FdiContext,h,&CabinetInfo);
            }
            p++;
        }
    }
#endif

    SpdFdiClose(h);

c1:
    PerThread->InDiamond = FALSE;
c0:
    return(b);
}



BOOL
DiamondInitialize(
    VOID
    )

/*++

Routine Description:

    Per-thread initialization routine for Diamond.
    Called once per thread.

Arguments:

    None.

Return Value:

    Boolean result indicating success or failure.
    Failure can be assumed to be out of memory.

--*/

{
    HFDI FdiContext;
    PDIAMOND_THREAD_DATA PerThread;
    PSETUP_TLS pTLS;
    BOOL retval = FALSE;

    pTLS = SetupGetTlsData();
    MYASSERT(pTLS);
    PerThread = &pTLS->Diamond;
    PerThread->FdiContext = NULL;

    retval = FALSE;
    try {

        //
        // Initialize a diamond context.
        //
        FdiContext = FDICreate(
                        SpdFdiAlloc,
                        SpdFdiFree,
                        SpdFdiOpen,
                        SpdFdiRead,
                        SpdFdiWrite,
                        SpdFdiClose,
                        SpdFdiSeek,
                        cpuUNKNOWN,
                        &PerThread->FdiError
                        );

        if(FdiContext) {
            PerThread->FdiContext = FdiContext;
            retval = TRUE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        retval = FALSE;
    }

    return(retval);
}


VOID
DiamondTerminate(
    VOID
    )

/*++

Routine Description:

    Per-thread termination routine for Diamond.
    Called internally.

Arguments:

    None.

Return Value:

    Boolean result indicating success or failure.
    Failure can be assumed to be out of memory.

--*/

{
    PSETUP_TLS pTLS;
    PDIAMOND_THREAD_DATA PerThread;

    pTLS = SetupGetTlsData();
    PerThread = pTLS? &pTLS->Diamond : NULL;
    if(PerThread && PerThread->FdiContext) {
        FDIDestroy(PerThread->FdiContext);
        PerThread->FdiContext = NULL;
    }

}


BOOL
DiamondProcessAttach(
    IN BOOL Attach
    )

/*++

Routine Description:

    Process attach routine. Must be called by the DLL entry point routine
    on DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH notifications.

Arguments:

    Attach - TRUE if process is attaching; FALSE if not.

Return Value:

    Boolean result indicating success or failure. Meaningful only if
    Attach is TRUE.

--*/

{
    return TRUE;
}


BOOL
DiamondTlsInit(
    IN BOOL Init
    )

/*++

Routine Description:

    The routine initializes per-thread data used by diamond.

Arguments:

    Init - TRUE if thread initialization; FALSE to cleanup

Return Value:

    None.

--*/

{
    if(Init) {
        return DiamondInitialize();
    } else {
        DiamondTerminate();
        return TRUE;
    }
}


///////////////////////////////////////////////////////////////////////////


BOOL
_SetupIterateCabinet(
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth
    )
{
    PTSTR cabinetFile;
    DWORD rc;

    //
    // Flags param not used. Make sure it's zero.
    //
    if(Flags) {
        rc = ERROR_INVALID_PARAMETER;
        goto c0;
    }

    //
    // Get a copy of the cabinet file name to validate
    // the caller's buffer.
    //
    try {
        cabinetFile = DuplicateString(CabinetFile);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        goto c0;
    }

    if(!cabinetFile) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }

    rc = DiamondProcessCabinet(cabinetFile,Flags,MsgHandler,Context,IsMsgHandlerNativeCharWidth);

    MyFree(cabinetFile);

c0:
    SetLastError(rc);
    return(rc == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupIterateCabinetA(
    IN  PCSTR               CabinetFile,
    IN  DWORD               Flags,
    IN  PSP_FILE_CALLBACK_A MsgHandler,
    IN  PVOID               Context
    )
{
    BOOL b;
    DWORD rc;
    PCWSTR cabinetFile;

    rc = pSetupCaptureAndConvertAnsiArg(CabinetFile,&cabinetFile);
    if(rc == NO_ERROR) {

        b = _SetupIterateCabinet(cabinetFile,Flags,MsgHandler,Context,FALSE);
        rc = GetLastError();

        MyFree(cabinetFile);

    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupIterateCabinetW(
    IN  PCWSTR              CabinetFile,
    IN  DWORD               Flags,
    IN  PSP_FILE_CALLBACK_W MsgHandler,
    IN  PVOID               Context
    )
{
    UNREFERENCED_PARAMETER(CabinetFile);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(MsgHandler);
    UNREFERENCED_PARAMETER(Context);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupIterateCabinet(
    IN  PCTSTR            CabinetFile,
    IN  DWORD             Flags,
    IN  PSP_FILE_CALLBACK MsgHandler,
    IN  PVOID             Context
    )
{
    return(_SetupIterateCabinet(CabinetFile,Flags,MsgHandler,Context,TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\diskspac.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    diskspac.c

Abstract:

    APIs and supporting routines for disk space requirement
    calculation.

Author:

    Ted Miller (tedm) 26-Jul-1996

Revision History:

    Jamie Hunter (JamieHun) Apr-24-2002
            Security code review

--*/

#include "precomp.h"
#pragma hdrstop


//
// An HDSKSPC actually points to one of these.
//
typedef struct _DISK_SPACE_LIST {

    MYLOCK Lock;

    PVOID DrivesTable;

    UINT Flags;

} DISK_SPACE_LIST, *PDISK_SPACE_LIST;

#define LockIt(h)   BeginSynchronizedAccess(&h->Lock)
#define UnlockIt(h) EndSynchronizedAccess(&h->Lock)

__inline
LONGLONG
_AdjustSpace(
    IN LONGLONG sz,
    IN LONGLONG block
    )
{
    //
    // 4097,512 should return 4097+(512-1) = 4608
    // -4097,512 should return -(4097+(512-1)) = -4608
    //
    LONGLONG sign = (sz<0?-1:1);
    LONGLONG rem = (sz*sign)%block;

    return sz + (rem ? sign*(block-rem) : 0);
}

//
// These structures are stored as data associated with
// paths/filenames in the string table.
//

typedef struct _XFILE {
    //
    // -1 means it doesn't currently exist
    //
    LONGLONG CurrentSize;

    //
    // -1 means it will be deleted.
    //
    LONGLONG NewSize;

} XFILE, *PXFILE;


typedef struct _XDIRECTORY {
    //
    // Value indicating how many bytes will be required
    // to hold all the files in the FilesTable after they
    // are put on a file queue and then the queue is committed.
    //
    // This may be a negative number indicating that space will
    // actually be freed!
    //
    LONGLONG SpaceRequired;

    PVOID FilesTable;

} XDIRECTORY, *PXDIRECTORY;


typedef struct _XDRIVE {
    //
    // Value indicating how many bytes will be required
    // to hold all the files in the space list for this drive.
    //
    // This may be a negative number indicating that space will
    // actually be freed!
    //
    LONGLONG SpaceRequired;

    PVOID DirsTable;

    DWORD BytesPerCluster;

    //
    // This is the amount to skew SpaceRequired, based on
    // SetupAdjustDiskSpaceList(). We track this separately
    // for flexibility.
    //
    LONGLONG Slop;

} XDRIVE, *PXDRIVE;


typedef struct _RETURN_BUFFER_INFO {
    PVOID ReturnBuffer;
    DWORD ReturnBufferSize;
    DWORD RequiredSize;
    BOOL IsUnicode;
} RETURN_BUFFER_INFO, *PRETURN_BUFFER_INFO;


BOOL
pSetupQueryDrivesInDiskSpaceList(
    IN  HDSKSPC DiskSpace,
    OUT PVOID   ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize,       OPTIONAL
    IN  BOOL    IsUnicode
    );

BOOL
pAddOrRemoveFileFromSectionToDiskSpaceList(
    IN OUT PDISK_SPACE_LIST        DiskSpaceList,
    IN     HINF                    LayoutInf,
    IN     PINFCONTEXT             LineInSection,   OPTIONAL
    IN     PCTSTR                  FileName,        OPTIONAL
    IN     PCTSTR                  TargetDirectory,
    IN     UINT                    Operation,
    IN     BOOL                    Add,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo  OPTIONAL
    );

BOOL
_SetupAddSectionToDiskSpaceList(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    ListInfHandle,  OPTIONAL
    IN PCTSTR                  SectionName,
    IN UINT                    Operation,
    IN PVOID                   Reserved1,
    IN UINT                    Reserved2,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    );

BOOL
_SetupRemoveSectionFromDiskSpaceList(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    ListInfHandle,  OPTIONAL
    IN PCTSTR                  SectionName,
    IN UINT                    Operation,
    IN PVOID                   Reserved1,
    IN UINT                    Reserved2,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    );

BOOL
pAddOrRemoveInstallSection(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    LayoutInfHandle, OPTIONAL
    IN PCTSTR                  SectionName,
    IN BOOL                    Add,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo  OPTIONAL
    );

BOOL
pSetupAddToDiskSpaceList(
    IN  PDISK_SPACE_LIST DiskSpaceList,
    IN  PCTSTR           TargetFilespec,
    IN  LONGLONG         FileSize,
    IN  UINT             Operation
    );

BOOL
pSetupRemoveFromDiskSpaceList(
    IN  PDISK_SPACE_LIST DiskSpaceList,
    IN  PCTSTR           TargetFilespec,
    IN  UINT             Operation
    );

VOID
pRecalcSpace(
    IN OUT PDISK_SPACE_LIST DiskSpaceList,
    IN     LONG             DriveStringId
    );

BOOL
pStringTableCBEnumDrives(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

BOOL
pStringTableCBDelDrives(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

BOOL
pStringTableCBDelDirs(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

BOOL
pStringTableCBZeroDirsTableMember(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

BOOL
pStringTableCBDupMemberStringTable(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

DWORD
pParsePath(
    IN  PCTSTR    PathSpec,
    OUT PTSTR     Buffer,
    OUT PTSTR    *DirectoryPart,
    OUT PTSTR    *FilePart,
    OUT LONGLONG *FileSize,
    IN  UINT      Flags
    );




HDSKSPC
SetupCreateDiskSpaceList(
    IN PVOID Reserved1,
    IN DWORD Reserved2,
    IN UINT  Flags
    )

/*++

Routine Description:

    This routine creates a disk space list, which can be used to
    determine required disk space for a set of file operations
    that parallel those that an application will perform later,
    such as via the file queue APIs.

Arguments:

    Reserved1 - Unused, must be 0.

    Reserved2 - Unused, must be 0.

    Flags - Specifies flags that govern operation of the disk space list.

        SPDSL_IGNORE_DISK: If this flag is set, then delete operations
            will be ignored, and copy operations will behave as if
            the target files are not present on the disk, regardless of
            whether the files are actually present. This flag is useful
            to determine an approximate size that can be associated with
            a set of files.
        SPDSL_DISALLOW_NEGATIVE_ADJUST:

Return Value:

    Handle to disk space list to be used in subsequent operations,
    or NULL if the routine fails, in which case GetLastError()
    returns extended error info.

--*/

{
    PDISK_SPACE_LIST SpaceList = NULL;
    DWORD d;

    //
    // Validate args.
    //
    if(Reserved1 || Reserved2) {
        d = ERROR_INVALID_PARAMETER;
        goto c1;
    }
    //
    // validate what flags are allowed
    //
    if (Flags & ~(SPDSL_IGNORE_DISK|SPDSL_DISALLOW_NEGATIVE_ADJUST)) {
        d = ERROR_INVALID_PARAMETER;
        goto c1;
    }

    //
    // Allocate space for a structure.
    //
    SpaceList = MyMalloc(sizeof(DISK_SPACE_LIST));
    if(!SpaceList) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c1;
    }

    ZeroMemory(SpaceList,sizeof(DISK_SPACE_LIST));

    SpaceList->Flags = Flags;

    //
    // Create a string table for the drives.
    //
    SpaceList->DrivesTable = pStringTableInitialize(sizeof(XDRIVE));
    if(!SpaceList->DrivesTable) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c2;
    }

    //
    // Create a locking structure for this guy.
    //
    if(!InitializeSynchronizedAccess(&SpaceList->Lock)) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c3;
    }

    //
    // Success.
    //
    return(SpaceList);

c3:
    pStringTableDestroy(SpaceList->DrivesTable);
c2:
    if(SpaceList) {
        MyFree(SpaceList);
    }
c1:
    SetLastError(d);
    return(NULL);
}


//
// Ansi version.
//
HDSKSPC
SetupCreateDiskSpaceListA(
    IN PVOID Reserved1,
    IN DWORD Reserved2,
    IN UINT  Flags
    )
{
    //
    // Nothing actually ansi/unicode specific now
    //
    return(SetupCreateDiskSpaceListW(Reserved1,Reserved2,Flags));
}

HDSKSPC
SetupDuplicateDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN PVOID   Reserved1,
    IN DWORD   Reserved2,
    IN UINT    Flags
    )

/*++

Routine Description:

    This routine duplicates a disk space, creating a new, fully independent
    disk space list.

Arguments:

    DiskSpace - supplies handle of disk space list to be duplicated.

    Reserved1 - reserved, must be 0.

    Reserved2 - reserved, must be 0.

    Flags - reserved, must be 0.

Return Value:

    If successful, returns a handle to a new disk space list.
    NULL if failure; GetLastError() returns extended error info.

--*/

{
    PDISK_SPACE_LIST OldSpaceList;
    PDISK_SPACE_LIST NewSpaceList = NULL; // shut up preFast
    DWORD d;
    BOOL b;
    XDRIVE xDrive;

    //
    // Validate args.
    //
    if(Reserved1 || Reserved2 || Flags) {
        d = ERROR_INVALID_PARAMETER;
        goto c0;
    }

    //
    // Allocate space for a new structure and create a locking structure.
    //
    NewSpaceList = MyMalloc(sizeof(DISK_SPACE_LIST));
    if(!NewSpaceList) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }
    ZeroMemory(NewSpaceList,sizeof(DISK_SPACE_LIST));

    if(!InitializeSynchronizedAccess(&NewSpaceList->Lock)) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c1;
    }

    //
    // Lock down the existing space list.
    //
    OldSpaceList = DiskSpace;
    d = NO_ERROR;
    try {
        if(!LockIt(OldSpaceList)) {
            d = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_HANDLE;
    }

    if(d != NO_ERROR) {
        goto c2;
    }

    //
    // Duplicate the top-level string table. After we do this, we'll have
    // a string table whose items' extra data is XDRIVE structures,
    // which will each contain a string table handle for a string table for
    // directories. But we don't want to share that string table between
    // the old and new disk space tables. So start by zeroing the DirsTable
    // members of all the XDRIVE structures. This will let us clean up
    // more easily later in the error path.
    //
    MYASSERT(OldSpaceList->DrivesTable);
    NewSpaceList->DrivesTable = pStringTableDuplicate(OldSpaceList->DrivesTable);
    if(!NewSpaceList->DrivesTable) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c3;
    }

    pStringTableEnum(
        NewSpaceList->DrivesTable,
        &xDrive,
        sizeof(XDRIVE),
        pStringTableCBZeroDirsTableMember,
        0
        );

    //
    // Now we enumerate the old drives table and duplicate each directory
    // string table into the new drives table. We take heavy advantage
    // of the fact that the ids are the same between the old and new tables.
    //
    b = pStringTableEnum(
            OldSpaceList->DrivesTable,
            &xDrive,
            sizeof(XDRIVE),
            pStringTableCBDupMemberStringTable,
            (LPARAM)NewSpaceList->DrivesTable
            );

    if(!b) {
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(d != NO_ERROR) {
        pStringTableEnum(
            NewSpaceList->DrivesTable,
            &xDrive,
            sizeof(XDRIVE),
            pStringTableCBDelDrives,
            0
            );
        pStringTableDestroy(NewSpaceList->DrivesTable);
    }
c3:
    //
    // Unlock the existing space list.
    //
    try {
        UnlockIt(OldSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Don't worry if the pointer went bad, we're already done
        // with the important work.
        //
        ;
    }
c2:
    if(d != NO_ERROR) {
        DestroySynchronizedAccess(&NewSpaceList->Lock);
    }
c1:
    if(d != NO_ERROR) {
        MyFree(NewSpaceList);
    }
c0:
    SetLastError(d);
    return((d == NO_ERROR) ? NewSpaceList : NULL);
}

//
// Ansi version.
//
HDSKSPC
SetupDuplicateDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN PVOID   Reserved1,
    IN DWORD   Reserved2,
    IN UINT    Flags
    )
{
    //
    // Nothing actually ansi/unicode specific now
    //
    return(SetupDuplicateDiskSpaceListW(DiskSpace,Reserved1,Reserved2,Flags));
}

BOOL
SetupDestroyDiskSpaceList(
    IN OUT HDSKSPC DiskSpace
    )

/*++

Routine Description:

    This routine destryos a disk space list which was created
    with SetupCreateDiskSpaceList() and releases all resources
    used thereby.

Arguments:

    DiskSpace - supplies handle to space list to be deconstructed.

Return Value:

    Boolean value indicating outcome. If FALSE, extended error info
    is available from GetLastError().

--*/

{
    PDISK_SPACE_LIST DiskSpaceList;
    DWORD rc;
    XDRIVE xDrive;

    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    try {
        DestroySynchronizedAccess(&DiskSpaceList->Lock);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Just swallow this.
        //
        ;
    }

    try {

        MYASSERT(DiskSpaceList->DrivesTable);
        //
        // Enumerate the drives string table. This in turn causes
        // all directory and file string tables to get destroyed.
        //
        pStringTableEnum(
            DiskSpaceList->DrivesTable,
            &xDrive,
            sizeof(XDRIVE),
            pStringTableCBDelDrives,
            0
            );

        pStringTableDestroy(DiskSpaceList->DrivesTable);

        //
        // Free the disk space list guy.
        //
        MyFree(DiskSpaceList);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}


BOOL
SetupAdjustDiskSpaceList(
    IN HDSKSPC  DiskSpace,
    IN LPCTSTR  DriveRoot,
    IN LONGLONG Amount,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    )

/*++

Routine Description:

    This routine is used to add an absolute amount of required disk space
    for a drive.

Arguments:

    DiskSpace - supplies a handle to a disk space list.

    DriveRoot - specifies a valid Win32 drive root. If this drive is not
        currently represented in the disk space list then an entry for it
        is added.

    Amount - supplies the amount of disk space by which to adjust space
        required on the drive. Use a negative number to remove space.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

Return Value:

--*/

{
    DWORD rc;
    BOOL b;

    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = NO_ERROR;

    try {
        if(!LockIt(((PDISK_SPACE_LIST)DiskSpace))) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    //
    // pSetupAddToDiskSpaceList does all the work. That routine
    // uses SEH so no need for try/excepts here.
    //
    b = pSetupAddToDiskSpaceList(DiskSpace,DriveRoot,Amount,(UINT)(-1));
    rc = GetLastError();

    //
    // The try/except around the unlock simply prevents us from faulting
    // but we don't return error if the pointer goes bad.
    //
    try {
        UnlockIt(((PDISK_SPACE_LIST)DiskSpace));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    SetLastError(rc);
    return(b);
}


//
// ANSI version
//
BOOL
SetupAdjustDiskSpaceListA(
    IN HDSKSPC  DiskSpace,
    IN LPCSTR   DriveRoot,
    IN LONGLONG Amount,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    )
{
    LPCWSTR p;
    BOOL b;
    DWORD rc;

    rc = pSetupCaptureAndConvertAnsiArg(DriveRoot,&p);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = SetupAdjustDiskSpaceListW(DiskSpace,p,Amount,Reserved1,Reserved2);
    rc = GetLastError();

    MyFree(p);

    SetLastError(rc);
    return(b);
}


BOOL
SetupAddToDiskSpaceList(
    IN HDSKSPC  DiskSpace,
    IN PCTSTR   TargetFilespec,
    IN LONGLONG FileSize,
    IN UINT     Operation,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    )

/*++

Routine Description:

    This routine adds a single delete or copy operation to a
    disk space list.

    Note that disk compression is completely ignored by this routine.
    Files are assumed to occupy their full size on the disk.

Arguments:

    DiskSpace - specifies handle to disk space list created by
        SetupCreateDiskSpaceList().

    TargetFilespec - specifies filename of the file to add
        to the disk space list. This will generally be a full win32
        path, though this is not a requirement. If it is not then
        standard win32 path semantics apply.

    FileSize - supplies the (uncompressed) size of the file as it will
        exist on the target when copied. Ignored for FILEOP_DELETE.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    DWORD rc;
    BOOL b;

    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = NO_ERROR;

    try {
        if(!LockIt(((PDISK_SPACE_LIST)DiskSpace))) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = pSetupAddToDiskSpaceList(DiskSpace,TargetFilespec,FileSize,Operation);
    rc = GetLastError();

    //
    // The try/except around the unlock simply prevents us from faulting
    // but we don't return error if the pointer goes bad.
    //
    try {
        UnlockIt(((PDISK_SPACE_LIST)DiskSpace));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    SetLastError(rc);
    return(b);
}


//
// ANSI version
//
BOOL
SetupAddToDiskSpaceListA(
    IN HDSKSPC  DiskSpace,
    IN PCSTR    TargetFilespec,
    IN LONGLONG FileSize,
    IN UINT     Operation,
    IN PVOID    Reserved1,
    IN UINT     Reserved2
    )
{
    PWSTR targetFilespec;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(TargetFilespec,&targetFilespec);
    if(rc != NO_ERROR) {
        return(rc);
    }

    b = SetupAddToDiskSpaceListW(DiskSpace,targetFilespec,FileSize,Operation,Reserved1,Reserved2);
    rc = GetLastError();

    MyFree(targetFilespec);

    SetLastError(rc);
    return(b);
}


BOOL
_SetupAddSectionToDiskSpaceList(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    ListInfHandle,  OPTIONAL
    IN PCTSTR                  SectionName,
    IN UINT                    Operation,
    IN PVOID                   Reserved1,
    IN UINT                    Reserved2,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    )

/*++

Routine Description:

    This routine adds a delete or copy section to a disk space list.

    Note that disk compression is completely ignored by this routine.
    Files are assumed to occupy their full size on the disk.

Arguments:

    DiskSpace - specifies handle to disk space list created by
        SetupCreateDiskSpaceList().

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] section, and, if ListInfHandle is not specified,
        contains the section named by SectionName. This handle must be for
        a win95-style inf.

    ListInfHandle - if specified, supplies a handle to an open inf file
        containing the section to be added to the disk space list.
        Otherwise InfHandle is assumed to contain the section.

    SectionName - supplies the name of the section to be added to
        the disk space list.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

    AltPlatformInfo - optionally, supplies alternate platform info to be used
        in determining the appropriately-decorated [SourceDisksFiles] section
        containing file size information.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PDISK_SPACE_LIST DiskSpaceList;
    LONG LineCount;
    PCTSTR TargetFilename;
    BOOL b;
    INFCONTEXT LineContext;
    TCHAR FullTargetPath[MAX_PATH];
    DWORD FileSize;
    DWORD rc;

    //
    // Note throughout this routine that very little structured exception handling
    // is needed, since most of the work is performed by subroutines that are
    // properly guarded.
    //

    if(Reserved1 || Reserved2) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
        goto c0;
    }

    //
    // Lock down the DiskSpace handle/structure.
    //
    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        b = FALSE;
        goto c0;
    }

    if(!ListInfHandle) {
        ListInfHandle = InfHandle;
    }

    //
    // The section must at least exist; an empty section is
    // a trivial success case.
    //
    LineCount = SetupGetLineCount(ListInfHandle,SectionName);
    if(LineCount == -1) {
        rc = ERROR_SECTION_NOT_FOUND;
        b = FALSE;
        goto c1;
    }
    if(!LineCount) {
        b = TRUE;
        goto c1;
    }

    //
    // Find the first line. We know there is at least one since the line count
    // was checked above. Sanity check it anyway.
    //
    b = SetupFindFirstLine(ListInfHandle,SectionName,NULL,&LineContext);
    MYASSERT(b);
    if(!b) {
        rc = ERROR_SECTION_NOT_FOUND;
        goto c1;
    }

    //
    // Find the target path for this section.
    //
    if(!SetupGetTargetPath(NULL,&LineContext,NULL,FullTargetPath,MAX_PATH,NULL)) {
        rc = GetLastError();
        goto c1;
    }

    //
    // Process each line in the section.
    //
    do {

        b = pAddOrRemoveFileFromSectionToDiskSpaceList(
                DiskSpaceList,
                InfHandle,
                &LineContext,
                NULL,
                FullTargetPath,
                Operation,
                TRUE,
                AltPlatformInfo
                );

        if(!b) {
            rc = GetLastError();
        }

    } while(b && SetupFindNextLine(&LineContext,&LineContext));

c1:
    try {
        UnlockIt(DiskSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
c0:
    SetLastError(rc);
    return(b);
}

//
// ANSI version
//
BOOL
SetupAddSectionToDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCSTR   SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    PWSTR sectionName;
    BOOL b;
    DWORD rc;

    rc = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    if(rc == NO_ERROR) {

        b = _SetupAddSectionToDiskSpaceList(
                DiskSpace,
                InfHandle,
                ListInfHandle,
                sectionName,
                Operation,
                Reserved1,
                Reserved2,
                NULL
               );

        rc = GetLastError();

        MyFree(sectionName);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}

BOOL
SetupAddSectionToDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCTSTR  SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    return _SetupAddSectionToDiskSpaceList(DiskSpace,
                                           InfHandle,
                                           ListInfHandle,
                                           SectionName,
                                           Operation,
                                           Reserved1,
                                           Reserved2,
                                           NULL
                                          );
}


BOOL
SetupAddInstallSectionToDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCTSTR  SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )

/*++

Routine Description:

    Processes an install section, looking for CopyFiles and DelFiles
    lines, and adds those sections to a disk space list.

Arguments:

Return Value:

    Win32 error code indicating outcome.

--*/

{
    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    return(pAddOrRemoveInstallSection(DiskSpace,
                                      InfHandle,
                                      LayoutInfHandle,
                                      SectionName,
                                      TRUE,
                                      NULL
                                     ));
}

//
// ANSI version
//
BOOL
SetupAddInstallSectionToDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCSTR   SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    PWSTR sectionName;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    if(rc == NO_ERROR) {

        b = SetupAddInstallSectionToDiskSpaceListW(
                DiskSpace,
                InfHandle,
                LayoutInfHandle,
                sectionName,
                Reserved1,
                Reserved2
                );

        rc = GetLastError();

        MyFree(sectionName);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}


BOOL
SetupRemoveFromDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN PCTSTR  TargetFilespec,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )

/*++

Routine Description:

    This routine removes a single delete or copy operation from a
    disk space list.

Arguments:

    DiskSpace - specifies handle to disk space list created by
        SetupCreateDiskSpaceList().

    TargetFilespec - specifies filename of the file to remove from
        the disk space list. This will generally be a full win32
        path, though this is not a requirement. If it is not then
        standard win32 path semantics apply.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

Return Value:

    If the file was not in the list, the routine returns TRUE and
    GetLastError() returns ERROR_INVALID_DRIVE or ERROR_INVALID_NAME.
    If the file was in the list then upon success the routine returns
    TRUE and GetLastError() returns NO_ERROR.

    If the routine fails for some other reason it returns FALSE and GetLastError()
    can be used to fetch extended error info.

--*/

{
    DWORD rc;
    BOOL b;

    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = NO_ERROR;

    try {
        if(!LockIt(((PDISK_SPACE_LIST)DiskSpace))) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = pSetupRemoveFromDiskSpaceList(DiskSpace,TargetFilespec,Operation);
    rc = GetLastError();

    //
    // The try/except around the unlock simply prevents us from faulting
    // but we don't return error if the pointer goes bad.
    //
    try {
        UnlockIt(((PDISK_SPACE_LIST)DiskSpace));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    SetLastError(rc);
    return(b);
}


//
// ANSI version
//
BOOL
SetupRemoveFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN PCSTR   TargetFilespec,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    PWSTR targetFilespec;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(TargetFilespec,&targetFilespec);
    if(rc != NO_ERROR) {
        return(rc);
    }

    b = SetupRemoveFromDiskSpaceListW(DiskSpace,targetFilespec,Operation,Reserved1,Reserved2);
    rc = GetLastError();

    MyFree(targetFilespec);

    SetLastError(rc);
    return(b);
}


BOOL
_SetupRemoveSectionFromDiskSpaceList(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    ListInfHandle,  OPTIONAL
    IN PCTSTR                  SectionName,
    IN UINT                    Operation,
    IN PVOID                   Reserved1,
    IN UINT                    Reserved2,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    )

/*++

Routine Description:

    This routine removes a delete or copy section from a disk space list.
    The section is presumed to have been added via SetupAddSectionToDiskSpaceList,
    though this is not a requirement. Files that have not actually been added
    will not be removed.

    Note that disk compression is completely ignored by this routine.
    Files are assumed to occupy their full size on the disk.

Arguments:

    DiskSpace - specifies handle to disk space list created by
        SetupCreateDiskSpaceList().

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] section, and, if ListInfHandle is not specified,
        contains the section named by SectionName. This handle must be for
        a win95-style inf.

    ListInfHandle - if specified, supplies a handle to an open inf file
        containing the section to be removed from the disk space list.
        Otherwise InfHandle is assumed to contain the section.

    SectionName - supplies the name of the section to be added to
        the disk space list.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

    AltPlatformInfo - optionally, supplies alternate platform info to be used
        in determining the appropriately-decorated [SourceDisksFiles] section
        containing file size information.


Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PDISK_SPACE_LIST DiskSpaceList;
    LONG LineCount;
    PCTSTR TargetFilename;
    BOOL b;
    INFCONTEXT LineContext;
    TCHAR FullTargetPath[MAX_PATH];
    DWORD rc;

    //
    // Note throughout this routine that very little structured exception handling
    // is needed, since most of the work is performed by subroutines that are
    // properly guarded.
    //

    if(Reserved1 || Reserved2) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
        goto c0;
    }

    //
    // Lock down the DiskSpace handle/structure.
    //
    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        b = FALSE;
        goto c0;
    }

    if(!ListInfHandle) {
        ListInfHandle = InfHandle;
    }

    //
    // The section must at least exist; an empty section is
    // a trivial success case.
    //
    LineCount = SetupGetLineCount(ListInfHandle,SectionName);
    if(LineCount == -1) {
        rc = ERROR_SECTION_NOT_FOUND;
        b = FALSE;
        goto c1;
    }
    if(!LineCount) {
        b = TRUE;
        goto c1;
    }

    //
    // Find the first line. We know there is at least one since the line count
    // was checked above. Sanity check it anyway.
    //
    b = SetupFindFirstLine(ListInfHandle,SectionName,NULL,&LineContext);
    MYASSERT(b);
    if(!b) {
        rc = ERROR_SECTION_NOT_FOUND;
        b = FALSE;
        goto c1;
    }

    //
    // Find the target path for this section.
    //
    if(!SetupGetTargetPath(NULL,&LineContext,NULL,FullTargetPath,MAX_PATH,NULL)) {
        rc = GetLastError();
        b = FALSE;
        goto c1;
    }

    //
    // Process each line in the section.
    //
    do {

        b = pAddOrRemoveFileFromSectionToDiskSpaceList(
                DiskSpaceList,
                InfHandle,
                &LineContext,
                NULL,
                FullTargetPath,
                Operation,
                FALSE,
                AltPlatformInfo
               );

        if(!b) {
            rc = GetLastError();
        }
    } while(b && SetupFindNextLine(&LineContext,&LineContext));

c1:
    try {
        UnlockIt(DiskSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

c0:
    SetLastError(rc);
    return(b);
}

//
// ANSI version
//
BOOL
SetupRemoveSectionFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCSTR   SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    PWSTR sectionName;
    BOOL b;
    DWORD rc;

    rc = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    if(rc == NO_ERROR) {

        b = _SetupRemoveSectionFromDiskSpaceList(
                DiskSpace,
                InfHandle,
                ListInfHandle,
                sectionName,
                Operation,
                Reserved1,
                Reserved2,
                NULL
               );

        rc = GetLastError();

        MyFree(sectionName);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}

BOOL
SetupRemoveSectionFromDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    ListInfHandle,  OPTIONAL
    IN PCTSTR  SectionName,
    IN UINT    Operation,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    return _SetupRemoveSectionFromDiskSpaceList(DiskSpace,
                                                InfHandle,
                                                ListInfHandle,
                                                SectionName,
                                                Operation,
                                                Reserved1,
                                                Reserved2,
                                                NULL
                                               );
}


BOOL
SetupRemoveInstallSectionFromDiskSpaceList(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCTSTR  SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )

/*++

Routine Description:

    Processes an install section, looking for CopyFiles and DelFiles
    lines, and removes those sections from a disk space list.

Arguments:

    DiskSpace - supplies a handle to a disk space list.

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] section, and, if ListInfHandle is not specified,
        contains the section named by SectionName. This handle must be for
        a win95-style inf.

    ListInfHandle - if specified, supplies a handle to an open inf file
        containing the section to be removed from the disk space list.
        Otherwise InfHandle is assumed to contain the section.

    SectionName - supplies the name of the section to be added to
        the disk space list.

    Reserved1 - must be 0.

    Reserved2 - must be 0.

Return Value:

    Boolean value indicating outcome. If FALSE, extended error info
    is available via GetLastError().


--*/

{
    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    return(pAddOrRemoveInstallSection(DiskSpace,
                                      InfHandle,
                                      LayoutInfHandle,
                                      SectionName,
                                      FALSE,
                                      NULL
                                     ));
}

//
// ANSI version
//
BOOL
SetupRemoveInstallSectionFromDiskSpaceListA(
    IN HDSKSPC DiskSpace,
    IN HINF    InfHandle,
    IN HINF    LayoutInfHandle,     OPTIONAL
    IN PCSTR   SectionName,
    IN PVOID   Reserved1,
    IN UINT    Reserved2
    )
{
    PWSTR sectionName;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    if(rc == NO_ERROR) {

        b = SetupRemoveInstallSectionFromDiskSpaceListW(
                DiskSpace,
                InfHandle,
                LayoutInfHandle,
                sectionName,
                Reserved1,
                Reserved2
                );

        rc = GetLastError();

        MyFree(sectionName);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}


BOOL
SetupQuerySpaceRequiredOnDrive(
    IN  HDSKSPC   DiskSpace,
    IN  PCTSTR    DriveSpec,
    OUT LONGLONG *SpaceRequired,
    IN  PVOID     Reserved1,
    IN  UINT      Reserved2
    )

/*++

Routine Description:

    Examine a disk space list to determine the space required on a
    particular drive.

Arguments:

    DiskSpace - supplies a handle to a disk space list.

    DriveSpec - specifies the drive for which space info is desired.
        This should be in the form x: or \\server\share.

    SpaceRequired - if the function succeeds, receives the amount
        of space required. This may be 0 or a negative number!

    Reserved1 - reserved, must be 0.

    Reserved2 - reserved, must be 0.

Return Value:

    Boolean value indicating outcome. If TRUE, SpaceRequired is filled in.

    If FALSE, extended error info is available via GetLastError():

    ERROR_INVALID_HANDLE - the specified DiskSpace handle is invalid.
    ERROR_INVALID_DRIVE - the given drive is not in the disk space list.

--*/

{
    PDISK_SPACE_LIST DiskSpaceList;
    DWORD rc;
    BOOL b;
    LONG l;
    DWORD Hash;
    DWORD StringLength;
    XDRIVE xDrive;
    TCHAR drive[MAX_PATH];

    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Lock down the DiskSpace handle/structure.
    //
    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    try {
        lstrcpyn(drive,DriveSpec,MAX_PATH);

        MYASSERT(DiskSpaceList->DrivesTable);

        l = pStringTableLookUpString(
                DiskSpaceList->DrivesTable,
                drive,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                NULL,
                0
                );

        if(l != -1) {
            //
            // Found the drive. Recalc space and return it.
            //
            pRecalcSpace(DiskSpaceList,l);
            pStringTableGetExtraData(DiskSpaceList->DrivesTable,l,&xDrive,sizeof(XDRIVE));
            *SpaceRequired = xDrive.SpaceRequired + xDrive.Slop;
            b = TRUE;
        } else {
            rc = ERROR_INVALID_DRIVE;
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
    }

    try {
        UnlockIt(DiskSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    SetLastError(rc);
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQuerySpaceRequiredOnDriveA(
    IN  HDSKSPC   DiskSpace,
    IN  PCSTR     DriveSpec,
    OUT LONGLONG *SpaceRequired,
    IN  PVOID     Reserved1,
    IN  UINT      Reserved2
    )
{
    PCWSTR drivespec;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(DriveSpec,&drivespec);
    if(rc == NO_ERROR) {

        b = SetupQuerySpaceRequiredOnDrive(DiskSpace,drivespec,SpaceRequired,Reserved1,Reserved2);
        rc = GetLastError();

        MyFree(drivespec);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQuerySpaceRequiredOnDriveW(
    IN  HDSKSPC   DiskSpace,
    IN  PCWSTR    DriveSpec,
    OUT LONGLONG *SpaceRequired,
    IN  PVOID     Reserved1,
    IN  UINT      Reserved2
    )
{
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(DriveSpec);
    UNREFERENCED_PARAMETER(SpaceRequired);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupQueryDrivesInDiskSpaceListA(
    IN  HDSKSPC DiskSpace,
    OUT PSTR    ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
    )

/*++

Routine Description:

    This routine fills a caller-supplied buffer with drive specs for each
    drive currently represented in the given disk space list.

Arguments:

    DiskSpace - supplies a disk space list handle.

    ReturnBuffer - if supplied, points to a buffer that gets packed with
        the drive specs, followed by a final terminating nul. If not specified
        and not other error occurs, the function succeeds and fills in
        RequiredSize.

    ReturnBufferSize - supplies the size (chars for Unicode, bytes for ANSI)
        of the buffer pointed by ReturnBuffer. Ingored if ReturnBuffer
        is not specified.

    RequiredSize - if specified, receives the size of the buffer required
        to hold the list of drives and terminating nul.

Return Value:

    Boolean value indicating outcome. If the function returns FALSE,
    extended error info is available via GetLastError(). If GetLastError()
    returns ERROR_INSUFFICIENT_BUFFER then ReturnBuffer was specified but
    ReturnBufferSize indicated that the supplied buffer was too small.

--*/

{
    BOOL b;

    b = pSetupQueryDrivesInDiskSpaceList(
            DiskSpace,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
#ifdef UNICODE
           ,FALSE
#endif
            );

    return(b);
}


BOOL
SetupQueryDrivesInDiskSpaceListW(
    IN  HDSKSPC DiskSpace,
    OUT PWSTR   ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
    )

/*++

Routine Description:

    See SetupQueryDrivesInDiskSpaceListA.

Arguments:

    See SetupQueryDrivesInDiskSpaceListA.

Return Value:

    See SetupQueryDrivesInDiskSpaceListA.

--*/

{
    BOOL b;

#ifdef UNICODE
    b = pSetupQueryDrivesInDiskSpaceList(
            DiskSpace,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize,
            TRUE
            );
#else
    UNREFERENCED_PARAMETER(DiskSpace);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    b = FALSE;
#endif

    return(b);
}


BOOL
pSetupQueryDrivesInDiskSpaceList(
    IN  HDSKSPC DiskSpace,
    OUT PVOID   ReturnBuffer,       OPTIONAL
    IN  DWORD   ReturnBufferSize,
    OUT PDWORD  RequiredSize        OPTIONAL
#ifdef UNICODE
    IN ,BOOL    IsUnicode
#endif
    )

/*++

Routine Description:

    Worker routine for SetupQueryDrivesInDiskSpaceList.

Arguments:

    Same as SetupQueryDrivesInDiskSpaceListA/W.

    IsUnicode - for Unicode DLL, specifies whether buffer args
        are ansi or unicode.

Return Value:

    Same as SetupQueryDrivesInDiskSpaceListA/W.

--*/

{
    PDISK_SPACE_LIST DiskSpaceList;
    DWORD rc;
    BOOL b;
    XDRIVE xDrive;
    RETURN_BUFFER_INFO ReturnBufferInfo;

    //
    // Lock down the DiskSpace handle/structure.
    //
    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    try {
        ReturnBufferInfo.ReturnBuffer = ReturnBuffer;
        ReturnBufferInfo.ReturnBufferSize = ReturnBufferSize;
        ReturnBufferInfo.RequiredSize = 0;
        #ifdef UNICODE
        ReturnBufferInfo.IsUnicode = IsUnicode;
        #endif

        MYASSERT(DiskSpaceList->DrivesTable);

        b = pStringTableEnum(
                DiskSpaceList->DrivesTable,
                &xDrive,
                sizeof(XDRIVE),
                pStringTableCBEnumDrives,
                (LPARAM)&ReturnBufferInfo
                );

        if(b) {
            //
            // Need one more char slot for the extra terminating nul.
            //
            ReturnBufferInfo.RequiredSize++;
            if(RequiredSize) {
                *RequiredSize = ReturnBufferInfo.RequiredSize;
            }

            if(ReturnBuffer) {

                if(ReturnBufferInfo.RequiredSize <= ReturnBufferSize) {

                    #ifdef UNICODE
                    if(!IsUnicode) {
                        ((PSTR)ReturnBuffer)[ReturnBufferInfo.RequiredSize-1] = 0;
                    } else
                    #endif
                    ((PTSTR)ReturnBuffer)[ReturnBufferInfo.RequiredSize-1] = 0;

                } else {
                    rc = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                }
            }
        } else {
            rc = ERROR_INSUFFICIENT_BUFFER;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
    }

    try {
        UnlockIt(DiskSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    SetLastError(rc);
    return(b);
}


BOOL
pAddOrRemoveInstallSection(
    IN HDSKSPC                 DiskSpace,
    IN HINF                    InfHandle,
    IN HINF                    LayoutInfHandle, OPTIONAL
    IN PCTSTR                  SectionName,
    IN BOOL                    Add,
    IN PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo  OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD rc;
    BOOL b;
    unsigned i;
    unsigned numops;
    UINT operation;
    PDISK_SPACE_LIST DiskSpaceList;
    INFCONTEXT LineContext;
    DWORD FieldCount;
    DWORD Field;
    PCTSTR SectionSpec;
    PCTSTR Operations[1] = { TEXT("Copyfiles") };
    INFCONTEXT SectionLineContext;
    TCHAR DefaultTarget[MAX_PATH];

    //
    // Delfiles causes too many issues
    // removed to give a good "worst case" scenario
    // however we intend to add it back along with
    // RenFiles When this issue is revisited, change numops
    // The Operations array and the switch to convert i to operation
    //
    // PCTSTR Operations[2] = { TEXT("Delfiles"),TEXT("Copyfiles") };
    //

    //
    // Lock down the DiskSpace handle/structure.
    //
    DiskSpaceList = DiskSpace;
    rc = NO_ERROR;
    b = TRUE;
    DefaultTarget[0] = 0;

    //
    // only handle Copyfiles at the moment
    //
    numops = 1;

    try {
        if(!LockIt(DiskSpaceList)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        b = FALSE;
        goto c0;
    }
    if(!LayoutInfHandle) {
        LayoutInfHandle = InfHandle;
    }

    //
    // see if install section exists for diagnostics (this will also check InfHandle)
    // however proceed so that we don't break existing broken code :-(
    //
    if (!SetupFindFirstLine(InfHandle,SectionName,NULL,&LineContext)) {
        DWORD x;
        x = GetLastError();
        pSetupLogSectionError(InfHandle,NULL,NULL,NULL,SectionName,MSG_LOG_NOSECTION_SPACE,x,NULL);
    }

    b = TRUE;
    for(i=0; b && (i < numops); i++) {

        //
        // Find the relevent line in the given install section.
        // If not present then we're done with this operation.
        //
        if(!SetupFindFirstLine(InfHandle,SectionName,Operations[i],&LineContext)) {
            continue;
        }

        switch(i) {
        case 0:
            operation = FILEOP_COPY;
            break;
        default:
            //
            // if we get here, someone changed numops
            // without changing this switch
            //
            MYASSERT(FALSE);
            break;
        }


        do {
            //
            // Each value on the line in the given install section
            // is the name of another section.
            //
            FieldCount = SetupGetFieldCount(&LineContext);
            for(Field=1; b && (Field<=FieldCount); Field++) {

                if(SectionSpec = pSetupGetField(&LineContext,Field)) {

                    //
                    // Handle single-file copy specially.
                    //
                    if((operation == FILEOP_COPY) && (*SectionSpec == TEXT('@'))) {

                        if(!DefaultTarget[0]) {
                            //
                            // Fetch the default target path for this inf, for use with
                            // single-file copy specs.
                            //
                            b = SetupGetTargetPath(
                                    InfHandle,
                                    NULL,
                                    NULL,
                                    DefaultTarget,
                                    MAX_PATH,
                                    NULL
                                    );
                        }

                        if(b) {
                            b = pAddOrRemoveFileFromSectionToDiskSpaceList(
                                    DiskSpace,
                                    LayoutInfHandle,
                                    NULL,
                                    SectionSpec+1,
                                    DefaultTarget,
                                    operation,
                                    Add,
                                    AltPlatformInfo
                                    );
                        }

                        if(!b) {
                            rc = GetLastError();
                        }
                    } else if(SetupGetLineCount(InfHandle,SectionSpec) > 0) {
                        //
                        // The section exists and is not empty.
                        // Add/remove it to the space list.
                        //
                        if(Add) {
                            b = _SetupAddSectionToDiskSpaceList(
                                    DiskSpace,
                                    LayoutInfHandle,
                                    InfHandle,
                                    SectionSpec,
                                    operation,
                                    0,0,
                                    AltPlatformInfo
                                    );
                        } else {
                            b = _SetupRemoveSectionFromDiskSpaceList(
                                    DiskSpace,
                                    LayoutInfHandle,
                                    InfHandle,
                                    SectionSpec,
                                    operation,
                                    0,0,
                                    AltPlatformInfo
                                    );
                        }

                        if(!b) {
                            rc = GetLastError();
                        }
                    }
                }
            }
        } while(b && SetupFindNextMatchLine(&LineContext,Operations[i],&LineContext));
    }

    try {
        UnlockIt(DiskSpaceList);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
c0:
    SetLastError(rc);
    return(b);
}


BOOL
pAddOrRemoveFileFromSectionToDiskSpaceList(
    IN OUT PDISK_SPACE_LIST        DiskSpaceList,
    IN     HINF                    LayoutInf,
    IN     PINFCONTEXT             LineInSection,   OPTIONAL
    IN     PCTSTR                  FileName,        OPTIONAL
    IN     PCTSTR                  TargetDirectory,
    IN     UINT                    Operation,
    IN     BOOL                    Add,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo  OPTIONAL
    )
{
    PCTSTR TargetFilename;
    TCHAR FullTargetPath[MAX_PATH];
    DWORD FileSize;
    BOOL b;
    DWORD rc;

    //
    // Get the target filename out of the line.
    // Field 1 is the target so there must be one for the line to be valid.
    //
    if(TargetFilename = LineInSection ? pSetupFilenameFromLine(LineInSection,FALSE) : FileName) {

        //
        // Form the full target path by concatenating the target dir
        // for this section and the target filename.
        //
        lstrcpyn(FullTargetPath,TargetDirectory,MAX_PATH);
        pSetupConcatenatePaths(FullTargetPath,TargetFilename,MAX_PATH,NULL);

        if(Add) {
            //
            // Fetch the size of the target file and add the operation
            // to the disk space list.
            //
            if(_SetupGetSourceFileSize(LayoutInf,
                                       LineInSection,
                                       FileName,
                                       NULL,
                                       AltPlatformInfo,
                                       &FileSize,
                                       0)) {

                b = pSetupAddToDiskSpaceList(
                        DiskSpaceList,
                        FullTargetPath,
                        (LONGLONG)(LONG)FileSize,
                        Operation
                        );

                if(!b) {
                    rc = GetLastError();
                }
            } else {
                b = FALSE;
                rc = GetLastError();
            }
        } else {
            //
            // Remove the operation from the disk space list.
            //
            b = pSetupRemoveFromDiskSpaceList(
                    DiskSpaceList,
                    FullTargetPath,
                    Operation
                    );

            if (!b) {
                rc = GetLastError();
            }
        }
    } else {
        b = FALSE;
        rc = ERROR_INVALID_DATA;
    }

    SetLastError(rc);
    return(b);
}


BOOL
pSetupAddToDiskSpaceList(
    IN  PDISK_SPACE_LIST DiskSpaceList,
    IN  PCTSTR           TargetFilespec,
    IN  LONGLONG         FileSize,
    IN  UINT             Operation
    )

/*++

Routine Description:

    Worker routine to add an item to a disk space list.
    Assumes locking is done by the caller.

Arguments:

    DiskSpaceList - specifies pointer to disk space list structure
        created by SetupCreateDiskSpaceList().

    TargetFilespec - specifies filename of the file to add
        to the disk space list. This will generally be a full win32
        path, though this is not a requirement. If it is not then
        standard win32 path semantics apply.

    FileSize - supplies the (uncompressed) size of the file as it will
        exist on the target when copied. Ignored for FILEOP_DELETE.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    TCHAR Buffer[MAX_PATH];
    DWORD rc;
    BOOL b;
    PTSTR DirPart;
    PTSTR FilePart;
    PTSTR drivespec;
    TCHAR drivelet[4];
    LONGLONG ExistingFileSize;
    XDRIVE xDrive;
    XDIRECTORY xDir;
    XFILE xFile;
    DWORD StringLength;
    DWORD Hash;
    LONG l;
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD TotalClusters;
    DWORD FreeClusters;

    if((Operation != FILEOP_DELETE) && (Operation != FILEOP_COPY) && (Operation != (UINT)(-1))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = NO_ERROR;

    try {
        rc = pParsePath(
                TargetFilespec,
                Buffer,
                &DirPart,
                &FilePart,
                &ExistingFileSize,
                DiskSpaceList->Flags
                );

        if(rc != NO_ERROR) {
            goto c0;
        }

        //
        // If we're not just doing the adjust case, drivespecs are not
        // acceptable.
        //
        if((Operation != (UINT)(-1)) && (*FilePart == 0)) {
            rc = ERROR_INVALID_PARAMETER;
            goto c0;
        }

        //
        // See whether the drive is already present in the drive list.
        //

        MYASSERT(DiskSpaceList->DrivesTable);

        l = pStringTableLookUpString(
                DiskSpaceList->DrivesTable,
                Buffer,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xDrive,
                sizeof(XDRIVE)
                );

        if(l == -1) {
            //
            // Determine cluster size for the drive and then add the drive
            // to the drive list and create a string table for the
            // directory list for this drive.
            //
            if(xDrive.DirsTable = pStringTableInitialize(sizeof(XDIRECTORY))) {
                //
                // The API is a little picky about what it is passed.
                // For the local drive case we have to use x:\ but pParsePath
                // sets things up so it's x:.
                //
                if(Buffer[1] == TEXT(':')) {
                    drivelet[0] = Buffer[0];
                    drivelet[1] = Buffer[1];
                    drivelet[2] = TEXT('\\');
                    drivelet[3] = 0;
                    drivespec = drivelet;
                } else {
                    drivespec = Buffer;
                }

                b = GetDiskFreeSpace(
                        drivespec,
                        &SectorsPerCluster,
                        &BytesPerSector,
                        &FreeClusters,
                        &TotalClusters
                        );

                if(!b) {
                    //
                    // This should probably be an error but there could be
                    // cases where people want to queue files say to a UNC path
                    // that isn't accessible now or something. Use reasonable defaults.
                    //
                    SectorsPerCluster = 1;
                    BytesPerSector = 512;
                    FreeClusters = 0;
                    TotalClusters = 0;
                }

                xDrive.SpaceRequired = 0;
                xDrive.Slop = 0;
                xDrive.BytesPerCluster = SectorsPerCluster * BytesPerSector;

                l = pStringTableAddString(
                        DiskSpaceList->DrivesTable,
                        Buffer,
                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                        &xDrive,
                        sizeof(XDRIVE)
                        );

                if(l == -1) {
                    pStringTableDestroy(xDrive.DirsTable);
                }
            }
        }

        if(l == -1) {
            //
            // Assume OOM.
            //
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }

        if(Operation == (UINT)(-1)) {
            //
            // Only want to add the drive. Adjust the slop for the drive.
            // rc is already set to NO_ERROR.
            //
            xDrive.Slop += FileSize;
            if((DiskSpaceList->Flags & SPDSL_DISALLOW_NEGATIVE_ADJUST) && (xDrive.Slop < 0)) {
                xDrive.Slop = 0;
            }

            pStringTableSetExtraData(
                DiskSpaceList->DrivesTable,
                l,
                &xDrive,
                sizeof(XDRIVE)
                );

            goto c0;
        }

        //
        // Adjust sizes to account for cluster size.
        //
        FileSize = _AdjustSpace(FileSize,xDrive.BytesPerCluster);
        if(ExistingFileSize != -1) {
            ExistingFileSize = _AdjustSpace(ExistingFileSize,xDrive.BytesPerCluster);
        }

        //
        // OK, xDrive has the drive info relevent for this file.
        // Now handle the directory part. First see whether the directory
        // is already present in the drive list.
        //
        l = pStringTableLookUpString(
                xDrive.DirsTable,
                DirPart,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xDir,
                sizeof(XDIRECTORY)
                );

        if(l == -1) {
            //
            // Add the directory to the directory string table.
            //
            if(xDir.FilesTable = pStringTableInitialize(sizeof(XFILE))) {

                xDir.SpaceRequired = 0;

                l = pStringTableAddString(
                        xDrive.DirsTable,
                        DirPart,
                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                        &xDir,
                        sizeof(XDIRECTORY)
                        );

                if(l == -1) {
                    pStringTableDestroy(xDir.FilesTable);
                }
            }
        }

        if(l == -1) {
            //
            // Assume OOM.
            //
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }

        //
        // Finally, deal with the file itself.
        // First see if it's in the list already.
        //
        l = pStringTableLookUpString(
                xDir.FilesTable,
                FilePart,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xFile,
                sizeof(XFILE)
                );

        if(l == -1) {
            //
            // The file is not already in there so put it in.
            //
            xFile.CurrentSize = ExistingFileSize;
            xFile.NewSize = (Operation == FILEOP_DELETE) ? -1 : FileSize;

            l = pStringTableAddString(
                    xDir.FilesTable,
                    FilePart,
                    STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                    &xFile,
                    sizeof(XFILE)
                    );

            if(l == -1) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                goto c0;
            }

        } else {

            if((xFile.CurrentSize == -1) && (xFile.NewSize == -1)) {
                //
                // This is a special "no-op" coding.
                //
                // The file is in there, but either the file was previously added
                // for a delete op but it didn't exist on the disk, or it was removed
                // via SetupRemoveFromDiskSpaceList().
                //
                xFile.CurrentSize = ExistingFileSize;
                xFile.NewSize = (Operation == FILEOP_DELETE) ? -1 : FileSize;

            } else {

                //
                // File is already in there. Remembering that deletes are done
                // before copies when a file queue is committed and assuming
                // that operations are put on the disk list in the same order they
                // will eventually be done on the file queue, there are 4 cases:
                //
                // 1) On list as delete, caller wants to delete. Just refresh
                //    the existing file size in case it changed.
                //
                // 2) On list as delete, caller wants to copy. We treat this case
                //    as a copy and override the existing info on the disk space list.
                //
                // 3) On list as copy, caller wants to delete. At commit time the file
                //    will be deleted but then later copied; just refresh the existing
                //    file size, in case it changed.
                //
                // 4) On list as copy, caller wants to copy. Override existing
                //    info in this case.
                //
                // This actually boils down to the following: Always refresh the
                // existing file size, and if the caller wants a copy, then
                // remember the new size.
                //
                xFile.CurrentSize = ExistingFileSize;
                if(Operation == FILEOP_COPY) {

                    xFile.NewSize = FileSize;
                }
            }

            pStringTableSetExtraData(xDir.FilesTable,l,&xFile,sizeof(XFILE));
        }

        c0:

        ;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}


BOOL
pSetupRemoveFromDiskSpaceList(
    IN  PDISK_SPACE_LIST DiskSpace,
    IN  PCTSTR           TargetFilespec,
    IN  UINT             Operation
    )

/*++

Routine Description:

    Worker routine to remove a single delete or copy operation from a
    disk space list.

    Assumes locking is handled by the caller.

Arguments:

    DiskSpaceList - specifies pointer to disk space list structure created by
        SetupCreateDiskSpaceList().

    TargetFilespec - specifies filename of the file to remove from
        the disk space list. This will generally be a full win32
        path, though this is not a requirement. If it is not then
        standard win32 path semantics apply.

    Operation - one of FILEOP_DELETE or FILEOP_COPY.

Return Value:

    If the file was not in the list, the routine returns TRUE and
    GetLastError() returns ERROR_INVALID_DRIVE or ERROR_INVALID_NAME.
    If the file was in the list then upon success the routine returns
    TRUE and GetLastError() returns NO_ERROR.

    If the routine fails for some other reason it returns FALSE and GetLastError()
    can be used to fetch extended error info.

--*/

{
    DWORD rc;
    BOOL b;
    TCHAR Buffer[MAX_PATH];
    PTSTR DirPart;
    PTSTR FilePart;
    LONGLONG ExistingFileSize;
    LONG l;
    DWORD StringLength;
    DWORD Hash;
    XDRIVE xDrive;
    XDIRECTORY xDir;
    XFILE xFile;

    if((Operation != FILEOP_DELETE) && (Operation != FILEOP_COPY)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = NO_ERROR;
    b = TRUE;

    try {
        //
        // Split up the path into its constituent components.
        //
        rc = pParsePath(
                TargetFilespec,
                Buffer,
                &DirPart,
                &FilePart,
                &ExistingFileSize,
                DiskSpace->Flags
                );

        if(rc != NO_ERROR) {
            goto c0;
        }

        //
        // Drivespecs alone are not acceptable.
        //
        if(*FilePart == 0) {
            rc = ERROR_INVALID_PARAMETER;
            goto c0;
        }

        //
        // Follow the trail down to the file string table.
        //

        MYASSERT(DiskSpace->DrivesTable);

        l = pStringTableLookUpString(
                DiskSpace->DrivesTable,
                Buffer,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xDrive,
                sizeof(XDRIVE)
                );

        if(l == -1) {
            //
            // Return success but set last error to indicate condition.
            //
            rc = ERROR_INVALID_DRIVE;
            goto c0;
        }

        MYASSERT(xDrive.DirsTable);

        l = pStringTableLookUpString(
                xDrive.DirsTable,
                DirPart,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xDir,
                sizeof(XDIRECTORY)
                );

        if(l == -1) {
            //
            // Return success but set last error to indicate condition.
            //
            rc = ERROR_INVALID_NAME;
            goto c0;
        }

        MYASSERT(xDir.FilesTable);

        l = pStringTableLookUpString(
                xDir.FilesTable,
                FilePart,
                &StringLength,
                &Hash,
                NULL,
                STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                &xFile,
                sizeof(XFILE)
                );

        if(l == -1) {
            //
            // Return success but set last error to indicate condition.
            //
            rc = ERROR_INVALID_NAME;
            goto c0;
        }

        //
        // Set special 'no-op' code for this file if the operations match.
        //
        if(Operation == FILEOP_DELETE) {
            if(xFile.NewSize == -1) {
                xFile.CurrentSize = -1;
            }
        } else {
            if(xFile.NewSize != -1) {
                xFile.NewSize = -1;
                xFile.CurrentSize = -1;
            }
        }

        pStringTableSetExtraData(xDir.FilesTable,l,&xFile,sizeof(XFILE));

        c0:

        ;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}


BOOL
pStringTableCBEnumDrives(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Internal routine used as the callback when enumerating drives
    in the disk space list. Writes the drivespec into a buffer
    supplies to the enumeration routine.

Arguments:

Return Value:

--*/

{
    PRETURN_BUFFER_INFO p;
    UINT Length;
    BOOL b;
    PCVOID string;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(ExtraData);
    UNREFERENCED_PARAMETER(ExtraDataSize);

    p = (PRETURN_BUFFER_INFO)lParam;

#ifdef UNICODE
    if(!p->IsUnicode) {
        if(string = pSetupUnicodeToAnsi(String)) {
            Length = lstrlenA(string) + 1;
        } else {
            return(FALSE);
        }
    } else
#endif
    {
        string = String;
        Length = lstrlen(string) + 1;
    }

    p->RequiredSize += Length;

    if(p->ReturnBuffer) {

        if(p->RequiredSize <= p->ReturnBufferSize) {

            //
            // There's still room in the caller's buffer for this drive spec.
            //
#ifdef UNICODE
            if(!p->IsUnicode) {
                lstrcpyA((PSTR)p->ReturnBuffer+p->RequiredSize-Length,string);
            } else
#endif
            lstrcpy((PTSTR)p->ReturnBuffer+p->RequiredSize-Length,string);

            b = TRUE;

        } else {
            //
            // Buffer is too small. Abort the enumeration.
            //
            b = FALSE;
        }
    } else {
        //
        // No buffer: just update the length required.
        //
        b = TRUE;
    }

#ifdef UNICODE
    if(string != String) {
        MyFree(string);
    }
#endif
    return(b);
}


BOOL
pStringTableCBDelDrives(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Internal routine used as the callback when calling pStringTableEnum
    to determine which drives are part of a disk space list.
    Enumerates directories on the drive, and then deletes the drives
    string table.

Arguments:

Return Value:

--*/

{
    PXDRIVE xDrive;
    XDIRECTORY xDir;
    BOOL b;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(ExtraDataSize);
    UNREFERENCED_PARAMETER(lParam);

    //
    // The extra data for the drives table is an XDRIVE structure.
    //
    xDrive = ExtraData;

    //
    // Enumerate the directory table for this drive. This destroys
    // all of *those* string tables.
    //
    if(xDrive->DirsTable) {
        b = pStringTableEnum(
                xDrive->DirsTable,
                &xDir,
                sizeof(XDIRECTORY),
                pStringTableCBDelDirs,
                0
                );

        pStringTableDestroy(xDrive->DirsTable);
    } else {
        b = FALSE;
    }

    return(b);
}


BOOL
pStringTableCBDelDirs(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Internal routine used as the callback when calling pStringTableEnum
    to determine which directories on a given drive are part of a
    disk space list. Basically we just destroy the directory's file string table.

Arguments:

Return Value:

--*/

{
    PXDIRECTORY xDir;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(ExtraDataSize);
    UNREFERENCED_PARAMETER(lParam);

    //
    // The extra data for the dirs table is an XDIRECTORY structure.
    //
    xDir = ExtraData;

    if(xDir->FilesTable) {
        pStringTableDestroy(xDir->FilesTable);
    }

    return(TRUE);
}


DWORD
pParsePath(
    IN  PCTSTR    PathSpec,
    OUT PTSTR     Buffer,
    OUT PTSTR    *DirectoryPart,
    OUT PTSTR    *FilePart,
    OUT LONGLONG *FileSize,
    IN  UINT      Flags
    )

/*++

Routine Description:

    Given a (possibly relative or incomplete) pathspec, determine
    the drive part, the directory part, and the filename parts and
    return pointers thereto.

Arguments:

    PathSpec - supplies the (possible relative) filename.

    Buffer - must be MAX_PATH TCHAR elements. Receives the full win32
        path, which is then carved up into drive, dir, and file parts.
        When the function returns, the first part of Buffer is the
        0-terminated drive spec, not including a terminating \ char.

    DirectoryPart - receives a pointer within Buffer to the first char
        in the full path (which will not be \). The string starting
        with that char will be nul-terminated.

    FilePart - receives a pointer within Buffer to the nul-terminated
        filename part (ie, the final component) of the win32 path
        (no path sep chars are involved in that part of the path).

    FileSize - receives the size of the file if it exists or -1 if not.

    Flags - specifies flags.
        SPDSL_IGNORE_DISK: this forces the routine to behave as if the file
            does not exist on-disk.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD rc;
    WIN32_FIND_DATA FindData;
    LPTSTR p;

    rc = GetFullPathName(PathSpec,
                         MAX_PATH,
                         Buffer,
                         FilePart
                        );

    if(!rc) {
        return(GetLastError());
    } else if(rc >= MAX_PATH) {
        MYASSERT(0);
        return(ERROR_BUFFER_OVERFLOW);
    }

    //
    // Get the file size, if the file exists.
    //
    if(Flags & SPDSL_IGNORE_DISK) {
        *FileSize = -1;
    } else {
        *FileSize = FileExists(Buffer,&FindData)
                  ? ((LONGLONG)FindData.nFileSizeHigh << 32) | FindData.nFileSizeLow
                  : -1;
    }

    //
    // Figure the drive part. We have no choice but to assume that
    // full paths are either x:\... or \\server\share\... because
    // there isn't any solid way to ask win32 itself what the drive
    // part of the path is.
    //
    // Stick a nul-terminator into the buffer to set off the drive part
    // once we've found it. Note that drive roots are acceptable in
    // the following forms:
    //
    //      x:
    //      x:\
    //      \\server\share
    //      \\server\share\
    //
    if(Buffer[0] && (Buffer[1] == TEXT(':'))) {
        if(Buffer[2] == 0) {
            p = &Buffer[2];
        } else {
            if(Buffer[2] == TEXT('\\')) {
                Buffer[2] = 0;
                p = &Buffer[3];
            } else {
                return(ERROR_INVALID_DRIVE);
            }
        }
    } else {
        if((Buffer[0] == TEXT('\\')) && (Buffer[1] == TEXT('\\')) && Buffer[2]
        && (p = _tcschr(&Buffer[3],TEXT('\\'))) && *(p+1) && (*(p+1) != TEXT('\\'))) {
            //
            // Dir part starts at next \, or it could be a drive root.
            //
            if(p = _tcschr(p+2,TEXT('\\'))) {
                *p++ = 0;
            } else {
                p = _tcschr(p+2,0);
            }
        } else {
            return(ERROR_INVALID_DRIVE);
        }
    }

    //
    // If we have a drive root, we're done. Set the dir and file parts
    // to point at an empty string and return.
    //
    if(*p == 0) {
        *DirectoryPart = p;
        *FilePart = p;
        return(NO_ERROR);
    }

    if(_tcschr(p,TEXT('\\'))) {
        //
        // There are at least 2 path components, so we have
        // a directory and filename. We need to nul-terminate
        // the directory part.
        //
        *DirectoryPart = p;
        *(*FilePart - 1) = 0;
    } else {
        //
        // There's only the one path component, so we have a file
        // at the root of the drive. FilePart is already set from
        // the call to GetFullPathName above. Set DirectoryPart
        // to a nul-terminator to make it an empty string.
        //
        *DirectoryPart = Buffer+lstrlen(Buffer);
    }

    return(NO_ERROR);
}


BOOL
pStringTableCBRecalcFiles(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PXFILE xFile;
    LONGLONG Delta;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(ExtraDataSize);
    UNREFERENCED_PARAMETER(lParam);

    //
    // Extra data points to an XFILE.
    //
    xFile = ExtraData;

    //
    // Calculate the additional space the new file will require
    // or the space that will be freed after the file is copied/deleted.
    //
    if(xFile->NewSize == -1) {
        //
        // File is being deleted. Account for the special 'no-op' coding.
        //
        Delta = (xFile->CurrentSize == -1) ? 0 : (0 - xFile->CurrentSize);

    } else {
        //
        // File is being copied. Account for the fact that the file might not
        // already exist on the disk.
        //
        Delta = (xFile->CurrentSize == -1) ? xFile->NewSize : (xFile->NewSize - xFile->CurrentSize);
    }

    //
    // Update running accumulated total.
    //
    *(LONGLONG *)lParam += Delta;

    return(TRUE);
}


BOOL
pStringTableCBRecalcDirs(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PXDIRECTORY xDir;
    XFILE xFile;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(ExtraDataSize);
    UNREFERENCED_PARAMETER(lParam);

    //
    // Extra data points to an XDIRECTORY.
    //
    xDir = ExtraData;

    xDir->SpaceRequired = 0;

    pStringTableEnum(
        xDir->FilesTable,
        &xFile,
        sizeof(XFILE),
        pStringTableCBRecalcFiles,
        (LPARAM)&xDir->SpaceRequired
        );

    //
    // Update running accumulated total.
    //
    *(LONGLONG *)lParam += xDir->SpaceRequired;

    return(TRUE);
}


BOOL
pStringTableCBZeroDirsTableMember(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

    Standard string table callback arguments.

Return Value:

--*/

{
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(lParam);

    if(lParam) {
        ((PXDIRECTORY)ExtraData)->FilesTable = NULL;
    } else {
        ((PXDRIVE)ExtraData)->DirsTable = NULL;
    }

    MYASSERT(StringTable);

    pStringTableSetExtraData(StringTable,StringId,ExtraData,ExtraDataSize);
    return(TRUE);
}


BOOL
pStringTableCBDupMemberStringTable2(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

    Standard string table callback arguments.

Return Value:

--*/

{
    PXDIRECTORY xDir;
    BOOL b;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(String);

    //
    // Extra data is the XDIRECTORY structure in the old string table.
    //
    xDir = ExtraData;

    //
    // Duplicate the old FilesTable string table into the new table.
    // We can reuse the xDir buffer.
    //
    xDir->FilesTable = pStringTableDuplicate(xDir->FilesTable);
    if(!xDir->FilesTable) {
        return(FALSE);
    }

    pStringTableSetExtraData((PVOID)lParam,StringId,ExtraData,ExtraDataSize);
    return(TRUE);
}


BOOL
pStringTableCBDupMemberStringTable(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

Arguments:

    Standard string table callback arguments.

Return Value:

--*/

{
    PXDRIVE xDrive;
    XDIRECTORY xDir;
    BOOL b;
    PVOID OldTable;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(String);

    //
    // Extra data is the XDRIVE structure in the old string table.
    //
    xDrive = ExtraData;

    //
    // Duplicate the old DirsTable string table into the new table.
    // We can reuse the xDrive buffer.
    //
    OldTable = xDrive->DirsTable;
    xDrive->DirsTable = pStringTableDuplicate(xDrive->DirsTable);
    if(!xDrive->DirsTable) {
        return(FALSE);
    }

    pStringTableSetExtraData((PVOID)lParam,StringId,ExtraData,ExtraDataSize);

    //
    // Now zero out the FilesTable members of the XDIRECTORY extra data
    // items in DirsTable string table.
    //
    pStringTableEnum(
        xDrive->DirsTable,
        &xDir,
        sizeof(XDIRECTORY),
        pStringTableCBZeroDirsTableMember,
        1
        );

    //
    // Finally, take advantage of the fact that the ids in the table we just
    // duplicated are the same in the old and new tables, to iterate the
    // old table to duplicate its FilesTable string tables into the new
    // string table. Clean up if failure.
    //
    b = pStringTableEnum(
            OldTable,
            &xDir,
            sizeof(XDIRECTORY),
            pStringTableCBDupMemberStringTable2,
            (LPARAM)xDrive->DirsTable
            );

    if(!b) {
        //
        // Clean up.
        //
        pStringTableEnum(
            xDrive->DirsTable,
            &xDir,
            sizeof(XDIRECTORY),
            pStringTableCBDelDirs,
            0
            );
    }

    return(b);
}


VOID
pRecalcSpace(
    IN OUT PDISK_SPACE_LIST DiskSpaceList,
    IN     LONG             DriveStringId
    )

/*++

Routine Description:

    Recalcuates the disk space required for a given drive by
    traversing all the dirs and files that are on the space list
    for the drive and performing additions/subtractions as necessary.

    Assumes locking is handled by the caller and does not guard args.

Arguments:

    DiskSpaceList - supplies the disk space list structure created
        by SetupCreateDiskSpaceList().

    DriveStringId - supplies the string id for the drive
        (in DiskSpaceList->DrivesTable) for the drive to be updated.

Return Value:

    None.

--*/

{
    XDRIVE xDrive;
    XDIRECTORY xDir;

    if(DriveStringId == -1) {
        return;
    }

    MYASSERT(DiskSpaceList->DrivesTable);

    pStringTableGetExtraData(DiskSpaceList->DrivesTable,DriveStringId,&xDrive,sizeof(XDRIVE));

    xDrive.SpaceRequired = 0;

    pStringTableEnum(
        xDrive.DirsTable,
        &xDir,
        sizeof(XDIRECTORY),
        pStringTableCBRecalcDirs,
        (LPARAM)&xDrive.SpaceRequired
        );

    pStringTableSetExtraData(DiskSpaceList->DrivesTable,DriveStringId,&xDrive,sizeof(XDRIVE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\fileq.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fileq.h

Abstract:

    Private header file for setup file queue routines.
    A setup file queue is a list of pending rename, delete,
    and copy operations.

Author:

    Ted Miller (tedm) 15-Feb-1995

Revision History:

    Jamie Hunter (jamiehun) 13-Jan-1998
        Added backup & un-windable copying
    Gabe Schaffer (t-gabes) 19-Jul-1998
        Added LogCotext to SP_FILE_QUEUE

--*/

//
// Declare this forward reference here so structures below can use it
// before it's defined.
//
struct _SP_FILE_QUEUE;
struct _SP_FILE_QUEUE_NODE;

//
// Define structure that describes a source media in use
// in a particular file queue.
//
typedef struct _SOURCE_MEDIA_INFO {

    struct _SOURCE_MEDIA_INFO *Next;

    //
    // String IDs for description and tagfile.
    //
    LONG Description;
    LONG DescriptionDisplayName; // case-sensitive form for display.

    LONG Tagfile;                // Tagfile & Cabfile would be the same string
    LONG Cabfile;                // unless an explicit cabfile has been given

    //
    // String ID for source root path
    //
    LONG SourceRootPath;

    //
    // Copy queue for this media.
    //
    struct _SP_FILE_QUEUE_NODE *CopyQueue;
    UINT CopyNodeCount;

    //
    // Flags for this source media descriptor
    //
    DWORD Flags;

} SOURCE_MEDIA_INFO, *PSOURCE_MEDIA_INFO;

//
// Define valid flags for SOURCE_MEDIA_INFO.Flags
//
#define SMI_FLAG_NO_SOURCE_ROOT_PATH            0x1
#define SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH   0x2
#define SMI_FLAG_USE_LOCAL_SOURCE_CAB           0x4
#define SMI_FLAG_USE_LOCAL_SPCACHE              0x8

//
// Define structure that describes a catalog, used for signing
// and file verification.
//
typedef struct _SPQ_CATALOG_INFO {

    struct _SPQ_CATALOG_INFO *Next;

    //
    // String ID for original filename of the catalog file,
    // such as specified in CatalogFile= in the [Version] section
    // of an inf file.
    //
    // This field may be -1, which indicates no CatalogFile= line
    // was specified in the INF.
    //
    LONG CatalogFileFromInf;

    //
    // String ID for original filename of the catalog file specified by the
    // INF for an alternate platform (the alternate platform having been setup
    // by a call to SetupSetFileQueueAlternatePlatform).  This field is only
    // valid when the containing file queue has the FQF_USE_ALT_PLATFORM flag
    // set.
    //
    // This field may be -1, which indicates that no CatalogFile= line was
    // specified in the INF (or at least not one that can be used given the
    // currently active alternate platform parameters).
    //
    LONG AltCatalogFileFromInf;
    //
    // Also, maintain a temporary storage for the new alternate catalog string
    // ID to be used while we're processing the catalog list, retrieving the
    // platform-specific entries associated with each INF.  This is done so that
    // if we encounter an error part-way through (e.g, out-of-memory or couldn't
    // load INF), then we don't have to maintain a separate list in order to do
    // a rollback.
    //
    LONG AltCatalogFileFromInfPending;

    //
    // String ID for the full (source) path of the INF.
    //
    LONG InfFullPath;

    //
    // String ID for the source INF's original (simple) name (may be -1 if the
    // source INF's original name is the same as its current name.
    //
    LONG InfOriginalName;

    //
    // String ID for the INF's final resting place (i.e., its name in the INF
    // directory, unless it's been part of an alternate catalog install, in
    // which case it will be the same as InfFullPath).  This value will be -1
    // until the catalog node has been processed by _SetupVerifyQueuedCatalogs.
    // After that, its value will be equal to InfFullPath if the INF was in the
    // Inf directory in the first place, or was part of an alternate catalog
    // installation.  Otherwise, it'll be the string ID for the unique name we
    // used when copying the INF into the Inf directory.
    //
    LONG InfFinalPath;

#if 0
    //
    // Pointer to media descriptor for first file that caused this
    // catalog node to be enqueued. This gives a pretty good indicator
    // of which media we expect the catalog file to be on.
    //
    PSOURCE_MEDIA_INFO SourceMediaInfo;
#endif

    //
    // Error code indicating the cause of failure to validate the catalog.
    //
    DWORD VerificationFailureError;

    //
    // CATINFO_FLAG flags containing information about this catalog node such
    // as whether it is the 'primary device INF' for a device installation.
    //
    DWORD Flags;

    //
    // If the CATINFO_FLAG_PROMPT_FOR_TRUST flag is set, then this handle
    // contains the WinVerifyTrust state data necessary to prompt the user in
    // establishing trust in the Authenticode publisher.  Once trust (or lack
    // thereof) has been established, this handle must be freed via
    // pSetupCloseWVTStateData.
    //
    HANDLE hWVTStateData;

    //
    // Full filepath of catalog file. This is the catalog file as
    // it's been installed on the system.
    //
    TCHAR CatalogFilenameOnSystem[MAX_PATH];

} SPQ_CATALOG_INFO, *PSPQ_CATALOG_INFO;

//
// Catalog node flags.
//
#define CATINFO_FLAG_PRIMARY_DEVICE_INF  0x00000001 // primary device INF for a
                                                    // device installation queue

#define CATINFO_FLAG_NEWLY_COPIED        0x00000002 // indicates whether INF/CAT
                                                    // were newly copied when
                                                    // this catalog node was
                                                    // verified.

#define CATINFO_FLAG_AUTHENTICODE_SIGNED 0x00000004 // INF signed with an
                                                    // Authenticode catalog.

#define CATINFO_FLAG_PROMPT_FOR_TRUST    0x00000008 // INF signed with an
                                                    // Authenticode catalog,
                                                    // but cannot be trusted
                                                    // until user confirms that
                                                    // they trust the publisher

//
// Define structure that describes a node in a file queue.
//
typedef struct _SP_FILE_QUEUE_NODE {

    struct _SP_FILE_QUEUE_NODE *Next;

    //
    // Operation: copy, delete, rename
    //
    UINT Operation;

    //
    // Copy:
    //
    // String ID for source root path
    // (such as F:\ or \\SERVER\SHARE\SUBDIR).
    //
    // Delete: unused
    // Rename: unused
    //
    LONG SourceRootPath;

    //
    // Copy:
    //
    // String ID for rest of the path (between the root and the filename).
    // Generally this is the directory specified for the source media
    // in [SourceDisksNames].
    //
    // Not always specified (-1 if not specified).
    //
    // Delete: unused
    //
    // Rename: source path of file to be renamed
    //
    LONG SourcePath;

    //
    // Copy: String ID for source filename (filename only, no path).
    // Delete: unused
    // Rename: source filename of file to be renamed. If not specified
    //         SourcePath contains complete full path of file.
    //
    LONG SourceFilename;

    //
    // Copy: String ID for the target directory (no filename).
    // Delete: part 1 of the full path of the file to delete (ie, path part)
    // Rename: Target directory for file (ie, rename is actually a move).
    //         If not specified rename is a rename only (TargetFilename
    //         contains the new filename).
    //
    LONG TargetDirectory;

    //
    // Copy: String ID for the target filename (filename only, no path),
    // Delete: part 2 of the full path of the file to delete (ie, file part)
    //         If not specified then TargetDirectory contains complete full path.
    // Rename: supplies new filename for rename/move operation. Filename part only.
    //
    LONG TargetFilename;

    //
    //  Copy  : String ID for Security Descriptor information
    //  Delete: Unused
    //  Rename: Unused
    LONG SecurityDesc;


    //
    // Copy: Information about the source media on which this file can be found.
    // Delete: unused
    // Rename: unused
    //
    PSOURCE_MEDIA_INFO SourceMediaInfo;

    //
    // Style flags for file operation
    //
    DWORD StyleFlags;

    //
    // Internal-use flags: In-use disposition, etc.
    //
    UINT InternalFlags;

    //
    // Pointer to catalog info for this file, used for file signing.
    // May be NULL.
    //
    PSPQ_CATALOG_INFO CatalogInfo;

} SP_FILE_QUEUE_NODE, *PSP_FILE_QUEUE_NODE;

//
// Internal flags.
//
#define INUSE_IN_USE            0x00000001  // file was in use
#define INUSE_INF_WANTS_REBOOT  0x00000002  // file was in use and inf file
                                            // want reboot if this file was in use
#define IQF_PROCESSED           0x00000004  // queue node was already processed
#define IQF_DELAYED_DELETE_OK   0x00000008  // Use delayed delete if delete fails
#define IQF_MATCH               0x00000010  // Node matches current file in cabinet
#define IQF_LAST_MATCH          0x00000020  // Node is last in chain of matches
#define IQF_FROM_BAD_OEM_INF    0x00000040  // Copynode from invalid (w.r.t. codesigning) OEM INF
#define IQF_ALLOW_UNSIGNED      0x00000080  // node is unsigned but allow installation
                                            //   (w.r.t. system file protection)
#define IQF_TARGET_PROTECTED    0x00000100  // node is replacing a system file

#define ST_SCE_SET 0
#define ST_SCE_DELETE 1
#define ST_SCE_RENAME 2
#define ST_SCE_UNWIND 3
#define ST_SCE_SERVICES 4


//
// Define structure describing a setup file operation queue.
//
typedef struct _SP_FILE_QUEUE {
    //
    // We'll maintain separate lists internally for each type
    // of queued operation. Each source media has its own copy queue.
    //
    //
    PSP_FILE_QUEUE_NODE BackupQueue;
    PSP_FILE_QUEUE_NODE DeleteQueue;
    PSP_FILE_QUEUE_NODE RenameQueue;

    //
    // Number of nodes in the various queues.
    //
    UINT CopyNodeCount;
    UINT DeleteNodeCount;
    UINT RenameNodeCount;
    UINT BackupNodeCount;

    //
    // Pointer to first source media descriptor.
    //
    PSOURCE_MEDIA_INFO SourceMediaList;

    //
    // Number of source media descriptors.
    //
    UINT SourceMediaCount;

    //
    // Pointer to head of linked list of catalog descriptor structures.
    // There will be one item in this list for each catalog file
    // referenced in any file's (copy) queue node.
    //
    PSPQ_CATALOG_INFO CatalogList;

    //
    // Specifies what driver signing policy was in effect when this file queue
    // was created.  This will have been retrieved from the registry, or from
    // the DS, if applicable.  This field can take one of three values:
    //
    //   DRIVERSIGN_NONE    -  silently succeed installation of unsigned/
    //                         incorrectly-signed files.  A PSS log entry will
    //                         be generated, however (as it will for all 3 types)
    //   DRIVERSIGN_WARNING -  warn the user, but let them choose whether or not
    //                         they still want to install the problematic file
    //   DRIVERSIGN_BLOCKING - do not allow the file to be installed
    //
    // The above values may be OR'ed with the DRIVERSIGN_ALLOW_AUTHENTICODE
    // flag, if it's acceptable to check for Authenticode signatures.
    //
    // Note:  the use of the term "file" above refers generically to both
    // individual files and packages (i.e., INF/CAT/driver file combinations)
    //
    DWORD DriverSigningPolicy;

    //
    // Specifies the window handle that owns any UI dealing with driver signing.
    // This is filled in based on the Owner argument passed into
    // _SetupVerifyQueuedCatalogs.
    //
    HWND hWndDriverSigningUi;

    //
    // If this queue has been marked as a device install queue, store the
    // description of the device being installed in case we need to popup a
    // digital signature verification failure dialog.
    //
    // (This value may be -1)
    //
    LONG DeviceDescStringId;

    //
    // Structure that contains alternate platform information that was
    // associated with the queue via SetupSetFileQueueAlternatePlatform.  This
    // embedded structure is only valid if the FQF_USE_ALT_PLATFORM flag is set.
    //
    SP_ALTPLATFORM_INFO_V2 AltPlatformInfo;

    //
    // String ID of override catalog file to use (typically, goes hand-in-hand
    // with an AltPlatformInfo).  If no catalog override is in effect, this
    // string ID will be -1.
    //
    LONG AltCatalogFile;

    //
    // Pointer to platform info structure to be used for digital signature
    // verification when there is no AltPlatformInfo associated with this file
    // queue.  This is used when certclas.inf identifies a range of valid OS
    // versions to be used when validating drivers of a particular device setup
    // class.  This field may be NULL, indicating that certclas.inf didn't
    // specify such an override, or that the queue isn't related to device
    // installation at all.
    //
    // This pointer must be freed when the structure is destroyed.
    //
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;

    //
    // String table that all data structures associated with
    // this queue make use of.
    //
    // (NOTE: Since there is no locking mechanism on the enclosing
    // SP_FILE_QUEUE structure, this StringTable must handle its own
    // synchronization.  Therefore, this string table contains 'live'
    // locks, and must be accessed with the public versions (in spapip.h)
    // of the StringTable* APIs.)
    //
    PVOID StringTable;

    //
    // Maintain a lock refcount for user-supplied queues contained in device
    // information elements.  This ensures that the queue can't be deleted as
    // long as its being referenced in at least one device installation parameter
    // block.
    //
    DWORD LockRefCount;

    //
    // Queue flags.
    //
    DWORD Flags;

    //
    // SIS-related fields.
    //
    HANDLE SisSourceHandle;
    PCTSTR SisSourceDirectory;

    //
    // Backup and unwind fields
    //
    LONG BackupInfID;               // stringID (relative to StringTable) of Inf file associated with backup
    LONG BackupInstanceID;
    LONG BackupDisplayNameID;
    LONG BackupDeviceInstanceID;
    LONG BackupDeviceDescID;
    LONG BackupMfgID;
    LONG BackupProviderNameID;
    LONG RestorePathID;             // restore-point
    PVOID TargetLookupTable;        // all entries here have associated data
    PSP_UNWIND_NODE UnwindQueue;    // order of restore and file info
    PSP_DELAYMOVE_NODE DelayMoveQueue;    // order of delayed renames
    PSP_DELAYMOVE_NODE DelayMoveQueueTail; // last of delayed renames

    //
    // Signature used for a primitive form of validation.
    //
    DWORD Signature;

    //
    // Pointer to log context for error logging
    //
    PSETUP_LOG_CONTEXT LogContext;

    //
    // Cache various verification handles for performance.
    //
    VERIFY_CONTEXT VerifyContext;

} SP_FILE_QUEUE, *PSP_FILE_QUEUE;


#define SP_FILE_QUEUE_SIG   0xc78e1098

//
// Internal-use queue commit routine.
//
BOOL
_SetupCommitFileQueue(
    IN HWND     Owner,         OPTIONAL
    IN HSPFILEQ QueueHandle,
    IN PVOID    MsgHandler,
    IN PVOID    Context,
    IN BOOL     IsMsgHandlerNativeCharWidth
    );
//
// Internal-use, add a single copy to the queue
//
BOOL
pSetupQueueSingleCopy(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCTSTR   SectionName,    OPTIONAL
    IN PCTSTR   SourceRootPath,
    IN PCTSTR   SourceFilename,
    IN PCTSTR   TargetFilename,
    IN DWORD    CopyStyle,
    IN PCTSTR   SecurityDescriptor,
    IN PCTSTR   CacheName
    );

//
// Internal-use
//

PTSTR
pSetupFormFullPath(
    IN PVOID  StringTable,
    IN LONG   PathPart1,
    IN LONG   PathPart2,    OPTIONAL
    IN LONG   PathPart3     OPTIONAL
    );

DWORD
pGetInfOriginalNameAndCatalogFile(
    IN  PLOADED_INF             Inf,                     OPTIONAL
    IN  LPCTSTR                 CurrentName,             OPTIONAL
    OUT PBOOL                   DifferentName,           OPTIONAL
    OUT LPTSTR                  OriginalName,            OPTIONAL
    IN  DWORD                   OriginalNameSize,
    OUT LPTSTR                  OriginalCatalogName,     OPTIONAL
    IN  DWORD                   OriginalCatalogNameSize,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo          OPTIONAL
    );


DWORD
_SetupVerifyQueuedCatalogs(
    IN  HWND           Owner,
    IN  PSP_FILE_QUEUE Queue,
    IN  DWORD          Flags,
    OUT PTSTR          DeviceInfFinalName,  OPTIONAL
    OUT PBOOL          DeviceInfNewlyCopied OPTIONAL
    );

BOOL
pSetupProtectedRenamesFlag(
    BOOL bSet
    );


#ifdef UNICODE

DWORD
pSetupCallSCE(
    IN DWORD Operation,
    IN PCWSTR FullName,
    IN PSP_FILE_QUEUE Queue,
    IN PCWSTR String1,
    IN DWORD Index1,
    IN PSECURITY_DESCRIPTOR SecDesc  OPTIONAL
    );

#endif





#define VERCAT_INSTALL_INF_AND_CAT          0x00000001
#define VERCAT_NO_PROMPT_ON_ERROR           0x00000002
#define VERCAT_PRIMARY_DEVICE_INF_FROM_INET 0x00000004


#define FILEOP_INTERNAL_FAILED              ((UINT)(-1)) // not a valid fileop, GetLastError has status
#define FILEOP_RETURN_STATUS                ((UINT)(-2)) // convert error to return value
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\fileq1.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fileq1.c

Abstract:

    Miscellaneous setup file queue routines.

Author:

    Ted Miller (tedm) 15-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


HSPFILEQ
WINAPI
SetupOpenFileQueue(
    VOID
    )

/*++

Routine Description:

    Create a setup file queue.

Arguments:

    None.

Return Value:

    Handle to setup file queue. INVALID_HANDLE_VALUE if error occurs (GetLastError reports the error)

--*/

{
    PSP_FILE_QUEUE Queue = NULL;
    DWORD rc;
    DWORD status = ERROR_INVALID_DATA;

    try {
        //
        // Allocate a queue structure.
        //
        Queue = MyMalloc(sizeof(SP_FILE_QUEUE));
        if(!Queue) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }
        ZeroMemory(Queue,sizeof(SP_FILE_QUEUE));

        //
        // Create a string table for this queue.
        //
        Queue->StringTable = pSetupStringTableInitialize();
        if(!Queue->StringTable) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        Queue->TargetLookupTable = pSetupStringTableInitializeEx( sizeof(SP_TARGET_ENT), 0 );
        if(!Queue->TargetLookupTable) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }
        Queue->BackupInfID = -1;        // no Backup INF
        Queue->BackupInstanceID = -1;   // no Backup INF
        Queue->RestorePathID = -1;      // no Restore directory

        Queue->Flags = FQF_TRY_SIS_COPY;
        Queue->SisSourceDirectory = NULL;
        Queue->SisSourceHandle = INVALID_HANDLE_VALUE;

        Queue->Signature = SP_FILE_QUEUE_SIG;

        //
        // Retrieve the codesigning policy currently in effect (policy in
        // effect is for non-driver signing behavior until we are told
        // otherwise).
        //
        Queue->DriverSigningPolicy = pSetupGetCurrentDriverSigningPolicy(FALSE);

        //
        // If and when we discover that this is a device installation for a
        // WHQL-logoable class (or if we discover we're dealing with an
        // exception package, or an INF that's replacing system-protected
        // files), then we'll clear this bit that allows for Authenticode
        // signatures.
        //
        Queue->DriverSigningPolicy |= DRIVERSIGN_ALLOW_AUTHENTICODE;

        //
        // Initialize the device description field to the null string id.
        //
        Queue->DeviceDescStringId = -1;

        //
        // Initialize the override catalog filename to the null string id.
        //
        Queue->AltCatalogFile = -1;

        //
        // Createa a generic log context
        //
        rc = CreateLogContext(NULL, TRUE, &Queue->LogContext);
        if (rc != NO_ERROR) {
            status = rc;
            leave;
        }

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }

    if (status == NO_ERROR) {
        //
        // The address of the queue structure is the queue handle.
        //
        return(Queue);
    }
    //
    // failure cleanup
    //
    if (Queue != NULL) {
        if (Queue->StringTable) {
            pSetupStringTableDestroy(Queue->StringTable);
        }
        if (Queue->TargetLookupTable) {
            pSetupStringTableDestroy(Queue->TargetLookupTable);
        }
        if(Queue->LogContext) {
            DeleteLogContext(Queue->LogContext);
        }
        MyFree(Queue);
    }
    //
    // return with this on error
    //
    SetLastError(status);
    return (HSPFILEQ)INVALID_HANDLE_VALUE;
}


BOOL
WINAPI
SetupCloseFileQueue(
    IN HSPFILEQ QueueHandle
    )

/*++

Routine Description:

    Destroy a setup file queue. Enqueued operations are not performed.

Arguments:

    QueueHandle - supplies handle to setup file queue to be destroyed.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.  Presently, the only error that can be
    encountered is ERROR_INVALID_HANDLE or ERROR_FILEQUEUE_LOCKED, which will occur if someone (typically,
    a device installation parameter block) is referencing this queue handle.

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE Node,NextNode;
    PSP_DELAYMOVE_NODE DelayMoveNode,NextDelayMoveNode;
    PSP_UNWIND_NODE UnwindNode,NextUnwindNode;
    PSOURCE_MEDIA_INFO Media,NextMedia;
    BOOL b;
    PSPQ_CATALOG_INFO Catalog,NextCatalog;

    DWORD status = ERROR_INVALID_HANDLE;

    if (QueueHandle == NULL || QueueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    //
    // Primitive queue validation.
    //
    b = TRUE;
    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    try {
        //
        // Don't close the queue if someone is still referencing it.
        //
        if(Queue->LockRefCount) {
            WriteLogEntry(
                Queue->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_FILEQUEUE_IN_USE,
                NULL);       // text message

            status = ERROR_FILEQUEUE_LOCKED;
            leave;
        }

        //
        // we may have some unwinding to do, but assume we succeeded
        // ie, delete temp files and cleanup memory used
        //
        pSetupUnwindAll(Queue, TRUE);

        //
        // If the queue wasn't committed and we are backup aware and this is
        // a device install then we need to clean up any backup directories and
        // registry entries that we created since we have already unwound the
        // queue up above.
        //
        if (!(Queue->Flags & FQF_QUEUE_ALREADY_COMMITTED) &&
            (Queue->Flags & FQF_DEVICE_BACKUP)) {

            pSetupCleanupBackup(Queue);
        }

        Queue->Signature = 0;

        //
        // Free the DelayMove list
        //
        for(DelayMoveNode = Queue->DelayMoveQueue; DelayMoveNode; DelayMoveNode = NextDelayMoveNode) {
            NextDelayMoveNode = DelayMoveNode->NextNode;
            MyFree(DelayMoveNode);
        }
        //
        // Free the queue nodes.
        //
        for(Node=Queue->DeleteQueue; Node; Node=NextNode) {
            NextNode = Node->Next;
            MyFree(Node);
        }
        for(Node=Queue->RenameQueue; Node; Node=NextNode) {
            NextNode = Node->Next;
            MyFree(Node);
        }
        // Free the backup queue nodes
        for(Node=Queue->BackupQueue; Node; Node=NextNode) {
            NextNode = Node->Next;
            MyFree(Node);
        }
        // Free the unwind queue nodes
        for(UnwindNode=Queue->UnwindQueue; UnwindNode; UnwindNode=NextUnwindNode) {
            NextUnwindNode = UnwindNode->NextNode;
            MyFree(UnwindNode);
        }

        //
        // Free the media structures and associated copy queues.
        //
        for(Media=Queue->SourceMediaList; Media; Media=NextMedia) {

            for(Node=Media->CopyQueue; Node; Node=NextNode) {
                NextNode = Node->Next;
                MyFree(Node);
            }

            NextMedia = Media->Next;
            MyFree(Media);
        }

        //
        // Free the catalog nodes.
        //
        for(Catalog=Queue->CatalogList; Catalog; Catalog=NextCatalog) {

            NextCatalog = Catalog->Next;

            if(Catalog->hWVTStateData) {
                MYASSERT(Catalog->Flags & CATINFO_FLAG_PROMPT_FOR_TRUST);
                pSetupCloseWVTStateData(Catalog->hWVTStateData);
            }

            MyFree(Catalog);
        }

        //
        // Free the validation platform information (if any)
        //
        if(Queue->ValidationPlatform) {
            MyFree(Queue->ValidationPlatform);
        }

        //
        // Free the string table.
        //
        pSetupStringTableDestroy(Queue->StringTable);
        //
        // (jamiehun) Free the target lookup table.
        //
        pSetupStringTableDestroy(Queue->TargetLookupTable);

        //
        // Free SIS-related fields.
        //
        if (Queue->SisSourceHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(Queue->SisSourceHandle);
        }
        if (Queue->SisSourceDirectory != NULL) {
            MyFree(Queue->SisSourceDirectory);
        }

        //
        // Unreference log context
        //
        DeleteLogContext(Queue->LogContext);

        //
        // Free any context handles that may have been allocated during the
        // lifetime of this queue.
        //
        pSetupFreeVerifyContextMembers(&(Queue->VerifyContext));

        //
        // Free the queue structure itself.
        //
        MyFree(Queue);

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }

    if(status != NO_ERROR) {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupSetFileQueueAlternatePlatformA(
    IN HSPFILEQ                QueueHandle,
    IN PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo,      OPTIONAL
    IN PCSTR                   AlternateDefaultCatalogFile OPTIONAL
    )
{
    PWSTR UAlternateDefaultCatalogFile;
    DWORD Err;

    if(AlternateDefaultCatalogFile) {
        Err = pSetupCaptureAndConvertAnsiArg(AlternateDefaultCatalogFile,
                                             &UAlternateDefaultCatalogFile
                                            );
        if(Err != NO_ERROR) {
            SetLastError(Err);
            return FALSE;
        }
    } else {
        UAlternateDefaultCatalogFile = NULL;
    }

    if(SetupSetFileQueueAlternatePlatformW(QueueHandle,
                                           AlternatePlatformInfo,
                                           UAlternateDefaultCatalogFile)) {
        Err = NO_ERROR;
    } else {
        Err = GetLastError();
        MYASSERT(Err != NO_ERROR);
    }

    if(UAlternateDefaultCatalogFile) {
        MyFree(UAlternateDefaultCatalogFile);
    }

    SetLastError(Err);

    return (Err == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupSetFileQueueAlternatePlatformW(
    IN HSPFILEQ                QueueHandle,
    IN PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo,      OPTIONAL
    IN PCWSTR                  AlternateDefaultCatalogFile OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(AlternatePlatformInfo);
    UNREFERENCED_PARAMETER(AlternateDefaultCatalogFile);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupSetFileQueueAlternatePlatform(
    IN HSPFILEQ                QueueHandle,
    IN PSP_ALTPLATFORM_INFO_V2 AlternatePlatformInfo,      OPTIONAL
    IN PCTSTR                  AlternateDefaultCatalogFile OPTIONAL
    )

/*++

Routine Description:

    This API associates the specified file queue with an alternate platform in
    order to allow for non-native signature verification (e.g., verifying Win98
    files on Windows NT, verifying x86 Windows NT files on Amd64, etc.).  The
    verification is done using the corresponding catalog files specified via
    platform-specific CatalogFile= entries in the source media descriptor INFs
    (i.e., INFs containing [SourceDisksNames] and [SourceDisksFiles] sections
    used when queueing files to be copied).

    The caller may also optionally specify a default catalog file, to be used
    for verification of files that have no associated catalog, thus would
    otherwise be globally validated (e.g., files queued up from the system
    layout.inf).  A side-effect of this is that INFs with no CatalogFile= entry
    are considered valid, even if they exist outside of %windir%\Inf.

    If this file queue is subsequently committed, the nonnative catalogs will be
    installed into the system catalog database, just as native catalogs would.

Arguments:

    QueueHandle - supplies a handle to the file queue with which the alternate
        platform is to be associated.

    AlternatePlatformInfo - optionally, supplies the address of a structure
        containing information regarding the alternate platform that is to be
        used for subsequent validation of files contained in the specified file
        queue.  If this parameter is not supplied, then the queue's association
        with an alternate platform is reset, and is reverted back to the default
        (i.e., native) environment.  This information is also used in
        determining the appropriate platform-specific CatalogFile= entry to be
        used when finding out which catalog file is applicable for a particular
        source media descriptor INF.

        (NOTE: caller may actually pass in a V1 struct instead--we detect this
        case and convert the V1 struct into a V2 one.)

    AlternateDefaultCatalogFile - optionally, supplies the full path to the
        catalog file to be used for verification of files contained in the
        specified file queue that are not associated with any particular catalog
        (hence would normally be globally validated).

        If this parameter is NULL, then the file queue will no longer be
        associated with any 'override' catalog, and all validation will take
        place normally (i.e., using the standard rules for digital signature
        verification via system-supplied and 3rd-party provided INFs/CATs).

        If this alternate default catalog is still associated with the file
        queue at commit time, it will be installed using its present name, and
        will overwrite any existing installed catalog file having that name.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PSP_FILE_QUEUE Queue;
    DWORD Err;
    TCHAR PathBuffer[MAX_PATH];
    DWORD RequiredSize;
    PTSTR TempCharPtr;
    LONG AltCatalogStringId;
    PSPQ_CATALOG_INFO CatalogNode;
    LPCTSTR InfFullPath;
    SP_ALTPLATFORM_INFO_V2 AltPlatformInfoV2;

    Err = NO_ERROR; // assume success

    try {
        Queue = (PSP_FILE_QUEUE)QueueHandle;

        //
        // Now validate the AlternatePlatformInfo parameter.
        //
        if(AlternatePlatformInfo) {

            if(AlternatePlatformInfo->cbSize != sizeof(SP_ALTPLATFORM_INFO_V2)) {
                //
                // The caller may have passed us in a Version 1 struct, or they
                // may have passed us in bad data...
                //
                if(AlternatePlatformInfo->cbSize == sizeof(SP_ALTPLATFORM_INFO_V1)) {
                    //
                    // Flags/Reserved field is reserved in V1
                    //
                    if(AlternatePlatformInfo->Reserved) {
                        Err = ERROR_INVALID_PARAMETER;
                        goto clean0;
                    }
                    //
                    // Convert the caller-supplied data into Version 2 format.
                    //
                    ZeroMemory(&AltPlatformInfoV2, sizeof(AltPlatformInfoV2));

                    AltPlatformInfoV2.cbSize                = sizeof(SP_ALTPLATFORM_INFO_V2);
                    AltPlatformInfoV2.Platform              = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->Platform;
                    AltPlatformInfoV2.MajorVersion          = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->MajorVersion;
                    AltPlatformInfoV2.MinorVersion          = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->MinorVersion;
                    AltPlatformInfoV2.ProcessorArchitecture = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->ProcessorArchitecture;
                    AltPlatformInfoV2.Flags                 = 0;
                    AlternatePlatformInfo = &AltPlatformInfoV2;

                } else {
                    Err = ERROR_INVALID_USER_BUFFER;
                    goto clean0;
                }
            }

            //
            // Gotta be either Windows or Windows NT
            //
            if((AlternatePlatformInfo->Platform != VER_PLATFORM_WIN32_WINDOWS) &&
               (AlternatePlatformInfo->Platform != VER_PLATFORM_WIN32_NT)) {

                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // Processor had better be either i386, amd64, or ia64.
            //
            if((AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_IA64) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_AMD64)) {

                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // MajorVersion field must be non-zero (MinorVersion field can be
            // anything)
            //
            if(!AlternatePlatformInfo->MajorVersion) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            //
            // Validate structure parameter flags (bits indicating what
            // parts of the structure are valid).
            //
            if((AlternatePlatformInfo->Flags & ~ (SP_ALTPLATFORM_FLAGS_VERSION_RANGE)) != 0) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            //
            // fill in version validation range if none supplied by caller
            //
            if((AlternatePlatformInfo->Flags & SP_ALTPLATFORM_FLAGS_VERSION_RANGE) == 0) {
                //
                // If caller does not know about FirstValidate*Version,
                // version upper and lower bounds are equal.
                //
                AlternatePlatformInfo->FirstValidatedMajorVersion = AlternatePlatformInfo->MajorVersion;
                AlternatePlatformInfo->FirstValidatedMinorVersion = AlternatePlatformInfo->MinorVersion;
                AlternatePlatformInfo->Flags |= SP_ALTPLATFORM_FLAGS_VERSION_RANGE;
            }


        }

        //
        // OK, the platform info structure checks out.  Now, associate the
        // default catalog (if supplied) with the file queue, otherwise reset
        // any existing association with a default catalog.
        //
        if(AlternateDefaultCatalogFile) {

            RequiredSize = GetFullPathName(AlternateDefaultCatalogFile,
                                           SIZECHARS(PathBuffer),
                                           PathBuffer,
                                           &TempCharPtr
                                          );

            if(!RequiredSize) {
                Err = GetLastError();
                goto clean0;
            } else if(RequiredSize >= SIZECHARS(PathBuffer)) {
                MYASSERT(0);
                Err = ERROR_BUFFER_OVERFLOW;
                goto clean0;
            }

            AltCatalogStringId = pSetupStringTableAddString(Queue->StringTable,
                                            PathBuffer,
                                            STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                           );
            if(AltCatalogStringId == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

        } else {
            //
            // Caller has not supplied an alternate default catalog, so reset
            // any existing association.
            //
            AltCatalogStringId = -1;
        }

        //
        // If we've been passed an AltPlatformInfo structure, then we need to
        // process each existing catalog node in our file queue and retrieve the
        // appropriate platform-specific CatalogFile= entry.
        //
        if(AlternatePlatformInfo) {

            for(CatalogNode = Queue->CatalogList; CatalogNode; CatalogNode = CatalogNode->Next) {
                //
                // Get the INF name associated with this catalog node.
                //
                InfFullPath = pSetupStringTableStringFromId(Queue->StringTable,
                                                      CatalogNode->InfFullPath
                                                     );

                Err = pGetInfOriginalNameAndCatalogFile(NULL,
                                                        InfFullPath,
                                                        NULL,
                                                        NULL,
                                                        0,
                                                        PathBuffer,
                                                        SIZECHARS(PathBuffer),
                                                        AlternatePlatformInfo
                                                       );
                if(Err != NO_ERROR) {
                    goto clean0;
                }

                if(*PathBuffer) {
                    //
                    // We retrieved a CatalogFile= entry that's pertinent for
                    // the specified platform from the INF.
                    //
                    CatalogNode->AltCatalogFileFromInfPending = pSetupStringTableAddString(
                                                                  Queue->StringTable,
                                                                  PathBuffer,
                                                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                                 );

                    if(CatalogNode->AltCatalogFileFromInfPending == -1) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }

                } else {
                    //
                    // The INF doesn't specify a CatalogFile= entry for this
                    // platform.
                    //
                    CatalogNode->AltCatalogFileFromInfPending = -1;
                }
            }

            //
            // OK, if we get to this point, then we've added all the strings to
            // the string table we need to, and we're done opening INFs.  We
            // should encounter no problems from this point forward, so it's
            // safe to commit our changes.
            //
            for(CatalogNode = Queue->CatalogList; CatalogNode; CatalogNode = CatalogNode->Next) {
                CatalogNode->AltCatalogFileFromInf = CatalogNode->AltCatalogFileFromInfPending;
            }
        }

        Queue->AltCatalogFile = AltCatalogStringId;

        //
        // Finally, update (or reset) the AltPlatformInfo structure in the queue
        // with the data the caller specified.
        //
        if(AlternatePlatformInfo) {
            CopyMemory(&(Queue->AltPlatformInfo),
                       AlternatePlatformInfo,
                       sizeof(SP_ALTPLATFORM_INFO_V2)
                      );
            Queue->Flags |= FQF_USE_ALT_PLATFORM;
        } else {
            Queue->Flags &= ~FQF_USE_ALT_PLATFORM;
        }

        //
        // Clear the "catalog verifications done" flags in the queue, so that
        // we'll redo them the next time _SetupVerifyQueuedCatalogs is called.
        // Also, clear the FQF_DIGSIG_ERRORS_NOUI flag so that the next
        // verification error we encounter will relayed to the user (based on
        // policy).
        //
        Queue->Flags &= ~(FQF_DID_CATALOGS_OK | FQF_DID_CATALOGS_FAILED | FQF_DID_CATALOGS_PROMPT_FOR_TRUST | FQF_DIGSIG_ERRORS_NOUI);

        //
        // Additionally, clear the Authenticode flags from any catalog nodes
        // that may have had them.
        //
        for(CatalogNode = Queue->CatalogList; CatalogNode; CatalogNode = CatalogNode->Next) {

            CatalogNode->Flags &= 
                ~(CATINFO_FLAG_AUTHENTICODE_SIGNED | CATINFO_FLAG_PROMPT_FOR_TRUST);

            if(CatalogNode->hWVTStateData) {
                pSetupCloseWVTStateData(CatalogNode->hWVTStateData);
                CatalogNode->hWVTStateData = NULL;
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);

    return (Err == NO_ERROR);
}


BOOL
pSetupSetQueueFlags(
    IN HSPFILEQ QueueHandle,
    IN DWORD flags
    )
{
    PSP_FILE_QUEUE Queue;
    DWORD Err = NO_ERROR;

    try {
        Queue = (PSP_FILE_QUEUE)QueueHandle;
        Queue->Flags = flags;

        if (Queue->Flags & FQF_QUEUE_FORCE_BLOCK_POLICY) {
            Queue->DriverSigningPolicy = DRIVERSIGN_BLOCKING;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
          Err = GetExceptionCode();
    }

    SetLastError(Err);
    return (Err == NO_ERROR);

}


DWORD
pSetupGetQueueFlags(
    IN HSPFILEQ QueueHandle
    )
{
    PSP_FILE_QUEUE Queue;

    try {
        Queue = (PSP_FILE_QUEUE)QueueHandle;
        return Queue->Flags;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    return 0;

}


WINSETUPAPI
BOOL
WINAPI
SetupGetFileQueueCount(
    IN  HSPFILEQ            FileQueue,
    IN  UINT                SubQueueFileOp,
    OUT PUINT               NumOperations
    )
/*++

Routine Description:

    This API obtains a count of a sub-queue in advance of submitting the queue

Arguments:

    FileQueue      - Queue to query
    SubQueueFileOp - operation
                      FILEOP_COPY FILEOP_DELETE FILEOP_RENAME FILEOP_BACKUP
    NumOperations  - ptr to hold the return value - number of files in that queue

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PSP_FILE_QUEUE Queue;
    BOOL b;
    DWORD status = ERROR_INVALID_HANDLE;

    if (FileQueue == NULL || FileQueue == (HSPFILEQ)INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    Queue = (PSP_FILE_QUEUE)FileQueue;

    b = TRUE;

    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    try {

        //
        // Invalid/NULL NumOperations ptr will be caught by exception handling
        //
        switch (SubQueueFileOp) {
            case FILEOP_COPY:
                *NumOperations=Queue->CopyNodeCount;
                status = NO_ERROR;
                break;

            case FILEOP_RENAME:
                *NumOperations=Queue->RenameNodeCount;
                status = NO_ERROR;
                break;

            case FILEOP_DELETE:
                *NumOperations=Queue->DeleteNodeCount;
                status = NO_ERROR;
                break;

            case FILEOP_BACKUP:
                *NumOperations=Queue->BackupNodeCount;
                status = NO_ERROR;
                break;

            default:
                status = ERROR_INVALID_PARAMETER;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
          status = ERROR_INVALID_DATA;
    }
    SetLastError(status);
    return (status==NO_ERROR);
}


WINSETUPAPI
BOOL
WINAPI
SetupGetFileQueueFlags(
    IN  HSPFILEQ            FileQueue,
    OUT PDWORD              Flags
    )
/*++

Routine Description:

    This API obtains public viewable flags for FileQueue

Arguments:

    FileQueue      - Queue to query
    Flags          - ptr to hold the return value - flags, includes:
                     SPQ_FLAG_BACKUP_AWARE
                     SPQ_FLAG_ABORT_IF_UNSIGNED

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PSP_FILE_QUEUE Queue;
    BOOL b;
    DWORD status = ERROR_INVALID_HANDLE;

    if (FileQueue == NULL || FileQueue == (HSPFILEQ)INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    Queue = (PSP_FILE_QUEUE)FileQueue;

    b = TRUE;

    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    try {

        //
        // Invalid/NULL Flags ptr will be caught by exception handling
        //
        *Flags = (((Queue->Flags & FQF_BACKUP_AWARE)      ? SPQ_FLAG_BACKUP_AWARE      : 0)  |
                  ((Queue->Flags & FQF_ABORT_IF_UNSIGNED) ? SPQ_FLAG_ABORT_IF_UNSIGNED : 0)  |
                  ((Queue->Flags & FQF_FILES_MODIFIED   ) ? SPQ_FLAG_FILES_MODIFIED    : 0));

        status = NO_ERROR;

    } except(EXCEPTION_EXECUTE_HANDLER) {
          status = ERROR_INVALID_DATA;
    }
    SetLastError(status);
    return (status==NO_ERROR);
}


VOID
ResetQueueState(
    IN PSP_FILE_QUEUE Queue
    )

/*++

Routine Description:

    This routine resets an aborted filequeue so that it can be committed yet
    again.  This is used when a client (e.g., newdev) requests that queue
    committal be aborted when unsigned files are encountered (i.e., so they can
    set a system restore point), then they want to re-commit the file queue
    once the restore point has been established.

Arguments:

    Queue - supplies a pointer to the file queue to be reset.

Return Value:

    none.

--*/

{
    PSP_DELAYMOVE_NODE DelayMoveNode, NextDelayMoveNode;
    PSP_UNWIND_NODE UnwindNode, NextUnwindNode;
    PSP_FILE_QUEUE_NODE QueueNode;
    PSOURCE_MEDIA_INFO Media;
    SP_TARGET_ENT TargetInfo;

    //
    // There should be no need to unwind the queue here, as that should've
    // already happened when we failed during _SetupCommitFileQueue.
    //

    //
    // Free the DelayMove list
    //
    for(DelayMoveNode = Queue->DelayMoveQueue; DelayMoveNode; DelayMoveNode = NextDelayMoveNode) {
        NextDelayMoveNode = DelayMoveNode->NextNode;
        MyFree(DelayMoveNode);
    }
    Queue->DelayMoveQueue = Queue->DelayMoveQueueTail = NULL;

    //
    // Free the unwind queue nodes
    //
    for(UnwindNode = Queue->UnwindQueue; UnwindNode; UnwindNode = NextUnwindNode) {
        NextUnwindNode = UnwindNode->NextNode;
        MyFree(UnwindNode);
    }
    Queue->UnwindQueue = NULL;

    //
    // Clear the "catalog verifications done" flags in the queue, so that we'll
    // redo them the next time _SetupVerifyQueuedCatalogs is called.
    //
    Queue->Flags &= ~(FQF_DID_CATALOGS_OK | FQF_DID_CATALOGS_FAILED);

    //
    // Clear the flag that indicates we've already committed the file queue.
    //
    Queue->Flags &= ~FQF_QUEUE_ALREADY_COMMITTED;

    //
    // Clear the flag that indicates we didn't successfully back-up all files.
    // Since we already unwound out of that queue committal, this flag is no
    // longer relevant (although we'll quite likely hit this problem again when
    // the client re-commits the file queue).
    //
    Queue->Flags &= ~FQF_BACKUP_INCOMPLETE;

    //
    // Clear certain internal flags on all the file queue nodes.
    //
#define QUEUE_NODE_BITS_TO_RESET (  INUSE_IN_USE           \
                                  | INUSE_INF_WANTS_REBOOT \
                                  | IQF_PROCESSED          \
                                  | IQF_MATCH              \
                                  | IQF_LAST_MATCH )
    //
    // Note:  neither the IQF_ALLOW_UNSIGNED nor IQF_TARGET_PROTECTED flags
    // should be set for any queue nodes, because we should only do this if we
    // previously committed the queue with the SPQ_FLAG_ABORT_IF_UNSIGNED flag
    // was set.  In this scenario, we never check to see if a file is protected,
    // nor do we request that an exception be granted).
    //

    for(QueueNode = Queue->BackupQueue; QueueNode; QueueNode = QueueNode->Next) {
        QueueNode->InternalFlags &= ~QUEUE_NODE_BITS_TO_RESET;
        MYASSERT(!(QueueNode->InternalFlags & (IQF_ALLOW_UNSIGNED | IQF_TARGET_PROTECTED)));
    }

    for(QueueNode = Queue->DeleteQueue; QueueNode; QueueNode = QueueNode->Next) {
        QueueNode->InternalFlags &= ~QUEUE_NODE_BITS_TO_RESET;
        MYASSERT(!(QueueNode->InternalFlags & (IQF_ALLOW_UNSIGNED | IQF_TARGET_PROTECTED)));
    }

    for(QueueNode = Queue->RenameQueue; QueueNode; QueueNode = QueueNode->Next) {
        QueueNode->InternalFlags &= ~QUEUE_NODE_BITS_TO_RESET;
        MYASSERT(!(QueueNode->InternalFlags & (IQF_ALLOW_UNSIGNED | IQF_TARGET_PROTECTED)));
    }

    for(Media = Queue->SourceMediaList; Media; Media = Media->Next) {
        for(QueueNode = Media->CopyQueue; QueueNode; QueueNode = QueueNode->Next) {
            QueueNode->InternalFlags &= ~QUEUE_NODE_BITS_TO_RESET;
            MYASSERT(!(QueueNode->InternalFlags & (IQF_ALLOW_UNSIGNED | IQF_TARGET_PROTECTED)));
        }
    }

    //
    // Iterate through all the entries in the TargetLookupTable string table,
    // and clear some flags in their associated SP_TARGET_ENT data.
    //
    pSetupStringTableEnum(Queue->TargetLookupTable,
                          &TargetInfo,
                          sizeof(TargetInfo),
                          pSetupResetTarget,
                          (LPARAM)0
                         );

}


WINSETUPAPI
BOOL
WINAPI
SetupSetFileQueueFlags(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               FlagMask,
    IN  DWORD               Flags
    )
/*++

Routine Description:

    This API modifies public settable flags for FileQueue

Arguments:

    FileQueue      - Queue in which flags are to be set.
    FlagMask       - Flags to modify, must not be zero
    Flags          - New value of flags, must be a subset of FlagMask

                     FlagMask and Flags include:
                     SPQ_FLAG_BACKUP_AWARE
                     SPQ_FLAG_ABORT_IF_UNSIGNED

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PSP_FILE_QUEUE Queue;
    BOOL b;
    DWORD status = ERROR_INVALID_HANDLE;
    DWORD RemapFlags = 0;
    DWORD RemapFlagMask = 0;

    if (FileQueue == NULL || FileQueue == (HSPFILEQ)INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    Queue = (PSP_FILE_QUEUE)FileQueue;

    b = TRUE;

    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    try {

        //
        // validate FlagMask and Flags
        //
        if (!FlagMask
            || (FlagMask & ~SPQ_FLAG_VALID)
            || (Flags & ~FlagMask)) {
            status = ERROR_INVALID_PARAMETER;
            leave;
        }
        //
        // remap SPQ_FLAG_BACKUP_AWARE to FQF_BACKUP_AWARE
        //
        if (FlagMask & SPQ_FLAG_BACKUP_AWARE) {
            RemapFlagMask |= FQF_BACKUP_AWARE;
            if (Flags & SPQ_FLAG_BACKUP_AWARE) {
                RemapFlags |= FQF_BACKUP_AWARE;
            }
        }
        //
        // remap SPQ_FLAG_ABORT_IF_UNSIGNED to FQF_ABORT_IF_UNSIGNED
        //
        if (FlagMask & SPQ_FLAG_ABORT_IF_UNSIGNED) {
            RemapFlagMask |= FQF_ABORT_IF_UNSIGNED;
            if (Flags & SPQ_FLAG_ABORT_IF_UNSIGNED) {
                RemapFlags |= FQF_ABORT_IF_UNSIGNED;
            } else {
                //
                // If we're clearing this flag, then we also need to go reset
                // the queue state so that it can be committed again, just like
                // it was the very first time (except that no driver signing UI
                // will happen in the subsequent queue committal).
                //
                if(Queue->Flags & FQF_ABORT_IF_UNSIGNED) {
                    ResetQueueState(Queue);
                }
            }
        }
        //
        // remap SPQ_FLAG_FILES_MODIFIED to FQF_FILES_MODIFIED
        // allows explicit setting/resetting of this state
        // which is informational only
        //
        if (FlagMask & SPQ_FLAG_FILES_MODIFIED) {
            RemapFlagMask |= FQF_FILES_MODIFIED;
            if (Flags & SPQ_FLAG_FILES_MODIFIED) {
                RemapFlags |= FQF_FILES_MODIFIED;
            }
        }

        //
        // now modify real flags
        //
        Queue->Flags = (Queue->Flags & ~RemapFlagMask) | RemapFlags;

        status = NO_ERROR;

    } except(EXCEPTION_EXECUTE_HANDLER) {
          status = ERROR_INVALID_DATA;
    }

    SetLastError(status);
    return (status==NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\fileq3.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fileq3.c

Abstract:

    Setup file queue routines for enqueing delete and rename
    operations.

Author:

    Ted Miller (tedm) 15-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


BOOL
_SetupQueueDelete(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   PathPart1,
    IN PCTSTR   PathPart2,      OPTIONAL
    IN UINT     Flags
    )

/*++

Routine Description:

    Place a delete operation on a setup file queue.

    Note that delete operations are assumed to be on fixed media.
    No prompting will be performed for delete operations when the
    queue is committed.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    PathPart1 - Supplies the first part of the path of
        the file to be deleted. If PathPart2 is not specified, then
        this is the full path of the file to be deleted.

    PathPart2 - if specified, supplies the second part of the path
        of the file to be deleted. This is concatenated to PathPart1
        to form the full pathname.

    Flags - specified flags controlling delete operation.

        DELFLG_IN_USE - if the file is in use, queue it for delayed
            delete, on next reboot. Otherwise in-use files are not deleted.

        DELFLG_IN_USE1 - same behavior as DELFLG_IN_USE--used when the
            same file list section is used for both a CopyFiles and DelFiles.
            (Since DELFLG_IN_USE (0x1) is also COPYFLG_WARN_IF_SKIP!)

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode, TempNode, PrevQueueNode;

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    //
    // Allocate a queue structure.
    //
    QueueNode = MyMalloc(sizeof(SP_FILE_QUEUE_NODE));
    if(!QueueNode) {
        goto clean0;
    }

    ZeroMemory(QueueNode, sizeof(SP_FILE_QUEUE_NODE));

    //
    // Operation is delete.
    //
    QueueNode->Operation = FILEOP_DELETE;

    //
    // Initialize unused fields.
    //
    QueueNode->SourceRootPath = -1;
    QueueNode->SourcePath = -1;
    QueueNode->SourceFilename = -1;

    //
    // Set internal flag to indicate whether we should queue a delayed delete
    // for this file if it's in-use.
    //
    QueueNode->InternalFlags = (Flags & (DELFLG_IN_USE|DELFLG_IN_USE1)) ?
        IQF_DELAYED_DELETE_OK : 0;

    //
    // NOTE: When adding the following strings to the string table, we cast away
    // their CONST-ness to avoid a compiler warning.  Since we are adding them
    // case-sensitively, we are guaranteed they will not be modified.
    //

    //
    // Set up the target directory.
    //
    QueueNode->TargetDirectory = pSetupStringTableAddString(Queue->StringTable,
                                                      (PTSTR)PathPart1,
                                                      STRTAB_CASE_SENSITIVE
                                                     );
    if(QueueNode->TargetDirectory == -1) {
        goto clean1;
    }

    //
    // Set up the target filename.
    //
    if(PathPart2) {
        QueueNode->TargetFilename = pSetupStringTableAddString(Queue->StringTable,
                                                         (PTSTR)PathPart2,
                                                         STRTAB_CASE_SENSITIVE
                                                        );
        if(QueueNode->TargetFilename == -1) {
            goto clean1;
        }
    } else {
        QueueNode->TargetFilename = -1;
    }

    //
    // Link the node onto the end of the delete queue.
    //
    QueueNode->Next = NULL;
    if(Queue->DeleteQueue) {
        //
        // Check to see if this same rename operation has already been enqueued,
        // and if so, get rid of the new one, to avoid duplicates.  NOTE: We
        // don't check the "InternalFlags" field, since if the node already
        // exists in the queue (based on all the other relevant fields comparing
        // successfully), then any internal flags that were set on the
        // previously-existing node should be preserved (i.e., our new node
        // always is created with InternalFlags set to zero).
        //
        for(TempNode=Queue->DeleteQueue, PrevQueueNode = NULL;
            TempNode;
            PrevQueueNode = TempNode, TempNode=TempNode->Next) {

            if((TempNode->TargetDirectory == QueueNode->TargetDirectory) &&
               (TempNode->TargetFilename == QueueNode->TargetFilename)) {
                //
                // We've found a duplicate.  However, we need to make sure that
                // if our new node specifies "delayed delete OK", then the
                // existing node has that internal flag set as well.
                //
                MYASSERT(!(QueueNode->InternalFlags & ~IQF_DELAYED_DELETE_OK));

                if(QueueNode->InternalFlags & IQF_DELAYED_DELETE_OK) {
                    TempNode->InternalFlags |= IQF_DELAYED_DELETE_OK;
                }

                //
                // Kill the newly-created queue node and return success.
                //
                MyFree(QueueNode);
                return TRUE;
            }
        }
        MYASSERT(PrevQueueNode);
        PrevQueueNode->Next = QueueNode;
    } else {
        Queue->DeleteQueue = QueueNode;
    }

    Queue->DeleteNodeCount++;

    return(TRUE);

clean1:
    MyFree(QueueNode);
clean0:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return(FALSE);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueDeleteA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    PathPart1,
    IN PCSTR    PathPart2       OPTIONAL
    )
{
    PWSTR p1,p2;
    DWORD d;
    BOOL b;

    b = FALSE;
    d = pSetupCaptureAndConvertAnsiArg(PathPart1,&p1);
    if(d == NO_ERROR) {

        if(PathPart2) {
            d = pSetupCaptureAndConvertAnsiArg(PathPart2,&p2);
        } else {
            p2 = NULL;
        }

        if(d == NO_ERROR) {

            b = _SetupQueueDelete(QueueHandle,p1,p2,0);
            d = GetLastError();

            if(p2) {
                MyFree(p2);
            }
        }

        MyFree(p1);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueDeleteW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   PathPart1,
    IN PCWSTR   PathPart2       OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(PathPart1);
    UNREFERENCED_PARAMETER(PathPart2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueDelete(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   PathPart1,
    IN PCTSTR   PathPart2       OPTIONAL
    )

/*++

Routine Description:

    Place a delete operation on a setup file queue.

    Note that delete operations are assumed to be on fixed media.
    No prompting will be performed for delete operations when the
    queue is committed.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    PathPart1 - Supplies the first part of the path of
        the file to be deleted. If PathPart2 is not specified, then
        this is the full path of the file to be deleted.

    PathPart2 - if specified, supplies the second part of the path
        of the file to be deleted. This is concatenated to PathPart1
        to form the full pathname.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PTSTR p1,p2;
    DWORD d;
    BOOL b;

    b = FALSE;
    d = CaptureStringArg(PathPart1,&p1);
    if(d == NO_ERROR) {

        if(PathPart2) {
            d = CaptureStringArg(PathPart2,&p2);
        } else {
            p2 = NULL;
        }

        if(d == NO_ERROR) {

            b = _SetupQueueDelete(QueueHandle,p1,p2,0);
            d = GetLastError();

            if(p2) {
                MyFree(p2);
            }
        }

        MyFree(p1);
    }

    SetLastError(d);
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueDeleteSectionA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCSTR    Section
    )
{
    PWSTR section;
    DWORD d;
    BOOL b;

    d = pSetupCaptureAndConvertAnsiArg(Section,&section);
    if(d == NO_ERROR) {

        b = SetupQueueDeleteSectionW(QueueHandle,InfHandle,ListInfHandle,section);
        d = GetLastError();

        MyFree(section);

    } else {
        b = FALSE;
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueDeleteSectionW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCWSTR   Section
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(ListInfHandle);
    UNREFERENCED_PARAMETER(Section);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueDeleteSection(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCTSTR   Section
    )

/*++

Routine Description:

    Queue an entire section in an inf file for delete. The section must be
    in delete-section format and the inf file must contain [DestinationDirs].

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    InfHandle - supplies a handle to an open inf file, that contains the
        [DestinationDirs] section.

    ListInfHandle - if specified, supplies a handle to the open inf file
        containing the section named by Section. If not specified this
        section is assumed to be in InfHandle.

    Section - supplies the name of the section to be queued for delete.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information. Some files may have been queued successfully.

--*/

{
    BOOL b;
    PTSTR TargetDirectory;
    PCTSTR TargetFilename;
    INFCONTEXT LineContext;
    DWORD SizeRequired;
    DWORD rc;
    UINT Flags;

    if(!ListInfHandle) {
        ListInfHandle = InfHandle;
    }

    //
    // The section has to exist and there sas to be at least one line in it.
    //
    b = SetupFindFirstLine(ListInfHandle,Section,NULL,&LineContext);
    if(!b) {
        rc = GetLastError();
        pSetupLogSectionError(ListInfHandle,NULL,NULL,QueueHandle,Section,MSG_LOG_NOSECTION_DELETE,rc,NULL);
        SetLastError(ERROR_SECTION_NOT_FOUND); // this is not the real error, but might be what caller expects
        return(FALSE);
    }

    //
    // Iterate every line in the section.
    //
    do {
        //
        // Get the target filename out of the line.
        //
        TargetFilename = pSetupFilenameFromLine(&LineContext,FALSE);
        if(!TargetFilename) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }

        //
        // Determine the target path for the file.
        //
        b = SetupGetTargetPath(InfHandle,&LineContext,NULL,NULL,0,&SizeRequired);
        if(!b) {
            return(FALSE);
        }
        TargetDirectory = MyMalloc(SizeRequired*sizeof(TCHAR));
        if(!TargetDirectory) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }
        SetupGetTargetPath(InfHandle,&LineContext,NULL,TargetDirectory,SizeRequired,NULL);

        //
        // If present flags are field 4
        //
        if(!SetupGetIntField(&LineContext,4,(PINT)&Flags)) {
            Flags = 0;
        }

        //
        // Add to queue.
        //
        b = _SetupQueueDelete(QueueHandle,TargetDirectory,TargetFilename,Flags);

        rc = GetLastError();
        MyFree(TargetDirectory);

        if(!b) {
            SetLastError(rc);
            return(FALSE);
        }

    } while(SetupFindNextLine(&LineContext,&LineContext));

    return(TRUE);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueRenameA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourcePath,
    IN PCSTR    SourceFilename, OPTIONAL
    IN PCSTR    TargetPath,     OPTIONAL
    IN PCSTR    TargetFilename
    )
{
    PWSTR sourcepath = NULL;
    PWSTR sourcefilename = NULL;
    PWSTR targetpath = NULL;
    PWSTR targetfilename = NULL;
    DWORD d;
    BOOL b;

    b = FALSE;
    d = pSetupCaptureAndConvertAnsiArg(SourcePath,&sourcepath);
    if((d == NO_ERROR) && SourceFilename) {
        d = pSetupCaptureAndConvertAnsiArg(SourceFilename,&sourcefilename);
    }
    if((d == NO_ERROR) && TargetPath) {
        d = pSetupCaptureAndConvertAnsiArg(TargetPath,&targetpath);
    }
    if(d == NO_ERROR) {
        d = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetfilename);
    }

    if(d == NO_ERROR) {

        b = SetupQueueRenameW(QueueHandle,sourcepath,sourcefilename,targetpath,targetfilename);
        d = GetLastError();
    }

    if(sourcepath) {
        MyFree(sourcepath);
    }
    if(sourcefilename) {
        MyFree(sourcefilename);
    }
    if(targetpath) {
        MyFree(targetpath);
    }
    if(targetfilename) {
        MyFree(targetfilename);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueRenameW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourcePath,
    IN PCWSTR   SourceFilename, OPTIONAL
    IN PCWSTR   TargetPath,     OPTIONAL
    IN PCWSTR   TargetFilename
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(SourcePath);
    UNREFERENCED_PARAMETER(SourceFilename);
    UNREFERENCED_PARAMETER(TargetPath);
    UNREFERENCED_PARAMETER(TargetFilename);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueRename(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourcePath,
    IN PCTSTR   SourceFilename, OPTIONAL
    IN PCTSTR   TargetPath,     OPTIONAL
    IN PCTSTR   TargetFilename
    )

/*++

Routine Description:

    Place a rename operation on a setup file queue.

    Note that rename operations are assumed to be on fixed media.
    No prompting will be performed for rename operations when the
    queue is committed.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    SourcePath - Supplies the source path of the file to be renamed.
        If SourceFilename is specified, this is the part part only.
        If SourceFilename is not specified, this is the fully-qualified
        path.

    SourceFilename - if specified, supplies the filename part of the
        file to be renamed. If not specified, SourcePath is the fully-
        qualified path of the file to be renamed.

    TargetPath - if specified, supplies the target directory, and the rename
        is actually a move operation. If not specified, then the rename
        takes place without moving the file.

    TargetFilename - supplies the new name (no path) of the file.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode, TempNode, PrevQueueNode;
    DWORD err = NO_ERROR;

    //
    // validate parameters so that we return correct error
    //
    if(SourcePath == NULL || TargetFilename == NULL) {
        err = ERROR_INVALID_PARAMETER;
        goto clean0;
    }

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    //
    // Allocate a queue structure.
    //
    QueueNode = MyMalloc(sizeof(SP_FILE_QUEUE_NODE));
    if(!QueueNode) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    ZeroMemory(QueueNode, sizeof(SP_FILE_QUEUE_NODE));

    //
    // Operation is rename.
    //
    QueueNode->Operation = FILEOP_RENAME;

    //
    // Initialize unused SourceRootPath field.
    //
    QueueNode->SourceRootPath = -1;

    //
    // NOTE: When adding the following strings to the string table, we cast away
    // their CONST-ness to avoid a compiler warning.  Since we are adding them
    // case-sensitively, we are guaranteed they will not be modified.
    //

    //
    // Set up the source path.
    //
    QueueNode->SourcePath = pSetupStringTableAddString(Queue->StringTable,
                                                 (PTSTR)SourcePath,
                                                 STRTAB_CASE_SENSITIVE
                                                );
    if(QueueNode->SourcePath == -1) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    //
    // Set up the source filename.
    //
    if(SourceFilename) {
        QueueNode->SourceFilename = pSetupStringTableAddString(Queue->StringTable,
                                                         (PTSTR)SourceFilename,
                                                         STRTAB_CASE_SENSITIVE
                                                        );
        if(QueueNode->SourceFilename == -1) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;
        }
    } else {
        QueueNode->SourceFilename = -1;
    }

    //
    // Set up the target directory.
    //
    if(TargetPath) {
        QueueNode->TargetDirectory = pSetupStringTableAddString(Queue->StringTable,
                                                          (PTSTR)TargetPath,
                                                          STRTAB_CASE_SENSITIVE
                                                         );
        if(QueueNode->TargetDirectory == -1) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;
        }
    } else {
        QueueNode->TargetDirectory = -1;
    }

    //
    // Set up the target filename.
    //
    QueueNode->TargetFilename = pSetupStringTableAddString(Queue->StringTable,
                                                     (PTSTR)TargetFilename,
                                                     STRTAB_CASE_SENSITIVE
                                                    );
    if(QueueNode->TargetFilename == -1) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }


    //
    // Link the node onto the end of the rename queue.
    //
    QueueNode->Next = NULL;
    if(Queue->RenameQueue) {
        //
        // Check to see if this same rename operation has already been enqueued,
        // and if so, get rid of the new one, to avoid duplicates.  NOTE: We
        // don't check the "InternalFlags" field, since if the node already
        // exists in the queue (based on all the other relevant fields comparing
        // successfully), then any internal flags that were set on the
        // previously-existing node should be preserved (i.e., our new node
        // always is created with InternalFlags set to zero).
        //
        for(TempNode=Queue->RenameQueue, PrevQueueNode = NULL;
            TempNode;
            PrevQueueNode = TempNode, TempNode=TempNode->Next) {

            if((TempNode->SourcePath == QueueNode->SourcePath) &&
               (TempNode->SourceFilename == QueueNode->SourceFilename) &&
               (TempNode->TargetDirectory == QueueNode->TargetDirectory) &&
               (TempNode->TargetFilename == QueueNode->TargetFilename)) {
                //
                // We have a duplicate--kill the newly-created queue node and
                // return success.
                //
                MYASSERT(TempNode->StyleFlags == 0);
                MyFree(QueueNode);
                return TRUE;
            }
        }
        MYASSERT(PrevQueueNode);
        PrevQueueNode->Next = QueueNode;
    } else {
        Queue->RenameQueue = QueueNode;
    }

    Queue->RenameNodeCount++;

    return(TRUE);

clean1:
    MyFree(QueueNode);
clean0:
    SetLastError(err);
    return(FALSE);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueRenameSectionA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCSTR    Section
    )
{
    PWSTR section;
    DWORD d;
    BOOL b;

    d = pSetupCaptureAndConvertAnsiArg(Section,&section);
    if(d == NO_ERROR) {

        b = SetupQueueRenameSectionW(QueueHandle,InfHandle,ListInfHandle,section);
        d = GetLastError();

        MyFree(section);
    } else {
        b = FALSE;
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueRenameSectionW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCWSTR   Section
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(ListInfHandle);
    UNREFERENCED_PARAMETER(Section);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueRenameSection(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCTSTR   Section
    )

/*++

Routine Description:

    Queue an entire section in an inf file for delete. The section must be
    in delete-section format and the inf file must contain [DestinationDirs].

    The format of a rename list section dictates that only renames within the
    same directory is supported (ie, you cannot queue file moves with this API).

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    InfHandle - supplies a handle to an open inf file, that contains the
        [DestinationDirs] section.

    ListInfHandle - if specified, supplies a handle to the open inf file
        containing the section named by Section. If not specified this
        section is assumed to be in InfHandle.

    Section - supplies the name of the section to be queued for delete.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    BOOL b;
    INFCONTEXT LineContext;
    PCTSTR TargetFilename;
    PCTSTR SourceFilename;
    PTSTR Directory;
    DWORD SizeRequired;
    DWORD rc;

    if(!ListInfHandle) {
        ListInfHandle = InfHandle;
    }

    //
    // The section has to exist and there has to be at least one line in it.
    //
    b = SetupFindFirstLine(ListInfHandle,Section,NULL,&LineContext);
    if(!b) {
        rc = GetLastError();
        pSetupLogSectionError(ListInfHandle,NULL,NULL,QueueHandle,Section,MSG_LOG_NOSECTION_RENAME,rc,NULL);
        SetLastError(ERROR_SECTION_NOT_FOUND); // this is not the real error, but might be what caller expects
        return(FALSE);
    }

    //
    // Iterate every line in the section.
    //
    do {
        //
        // Get the target filename out of the line.
        //
        TargetFilename = pSetupFilenameFromLine(&LineContext,FALSE);
        if(!TargetFilename) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }
        //
        // Get source filename out of the line.
        //
        SourceFilename = pSetupFilenameFromLine(&LineContext,TRUE);
        if(!SourceFilename || (*SourceFilename == 0)) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }

        //
        // Determine the path of the file.
        //
        b = SetupGetTargetPath(InfHandle,&LineContext,NULL,NULL,0,&SizeRequired);
        if(!b) {
            return(FALSE);
        }
        Directory = MyMalloc(SizeRequired*sizeof(TCHAR));
        if(!Directory) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }
        SetupGetTargetPath(InfHandle,&LineContext,NULL,Directory,SizeRequired,NULL);

        //
        // Add to queue.
        //
        b = SetupQueueRename(
                QueueHandle,
                Directory,
                SourceFilename,
                NULL,
                TargetFilename
                );

        rc = GetLastError();
        MyFree(Directory);

        if(!b) {
            SetLastError(rc);
            return(FALSE);
        }

    } while(SetupFindNextLine(&LineContext,&LineContext));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\fileq5.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fileq5.c

Abstract:

    Default queue callback function.

Author:

    Ted Miller (tedm) 24-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define QUEUECONTEXT_SIGNATURE (DWORD)(0x43515053) // 'CQPS'

typedef struct _QUEUECONTEXT {
    DWORD Signature; // an attempt to catch re-use of deleted queuecontext
    HWND OwnerWindow;
    DWORD MainThreadId;
    HWND ProgressDialog;
    HWND ProgressBar;
    BOOL Cancelled;
    PTSTR CurrentSourceName;
    BOOL ScreenReader;
    BOOL MessageBoxUp;
    WPARAM  PendingUiType;
    PVOID   PendingUiParameters;
    UINT    CancelReturnCode;
    BOOL DialogKilled;
    //
    // If the SetupInitDefaultQueueCallbackEx is used, the caller can
    // specify an alternate handler for progress. This is useful to
    // get the default behavior for disk prompting, error handling, etc,
    // but to provide a gas gauge embedded, say, in a wizard page.
    //
    // The alternate window is sent ProgressMsg once when the copy queue
    // is started (wParam = 0. lParam = number of files to copy).
    // It is then also sent once per file copied (wParam = 1. lParam = 0).
    //
    // NOTE: a silent installation (i.e., no progress UI) can be accomplished
    // by specifying an AlternateProgressWindow handle of INVALID_HANDLE_VALUE.
    //
    HWND AlternateProgressWindow;
    UINT ProgressMsg;
    UINT NoToAllMask;

    HANDLE UiThreadHandle;
    //
    // instead of posting responses to main thread, use an event with flags
    //
    HANDLE hEvent;
    BOOL bDialogExited;
    LPARAM lParam;

#ifdef NOCANCEL_SUPPORT
    BOOL AllowCancel;
#endif

} QUEUECONTEXT, *PQUEUECONTEXT;

typedef struct _VERDLGCONTEXT {
    PQUEUECONTEXT QueueContext;
    UINT Notification;
    UINT_PTR Param1;
    UINT_PTR Param2;
} VERDLGCONTEXT, *PVERDLGCONTEXT;

#define WMX_PROGRESSTHREAD  (WM_APP+0)
#define WMX_KILLDIALOG      (WM_APP+1)
#define WMX_HELLO           (WM_APP+2)
#define WMX_PERFORMUI       (WM_APP+3)

#define UI_NONE             0
#define UI_COPYERROR        1
#define UI_DELETEERROR      2
#define UI_RENAMEERROR      3
#define UI_NEEDMEDIA        4
#define UI_MISMATCHERROR    5
#define UI_BACKUPERROR      6


typedef struct _COPYERRORUI {
    TCHAR       Buffer[MAX_PATH];
    PTCHAR      Filename;
    PFILEPATHS  FilePaths;
    DWORD       Flags;
    PTSTR       PathOut;
} COPYERRORUI, *PCOPYERRORUI;

typedef struct _NEEDMEDIAUI {
    PSOURCE_MEDIA   SourceMedia;
    DWORD           Flags;
    PTSTR           PathOut;
} NEEDMEDIAUI, *PNEEDMEDIAUI;


PCTSTR DialogPropName = TEXT("_context");

INT_PTR
pSetupProgressDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

LPARAM
pPerformUi (
    IN  PQUEUECONTEXT   Context,
    IN  UINT            UiType,
    IN  PVOID           UiParameters
    );


VOID
__cdecl
pSetupProgressThread(
    IN PVOID Context
    )

/*++

Routine Description:

    Thread entry point for setup file progress indicator.
    Puts up a dialog box.

Arguments:

    Context - supplies queue context.

Return Value:

    0 if unsuccessful, non-0 if successful.

--*/

{
    PQUEUECONTEXT context;
    INT_PTR i;
    MSG msg;

    //
    // Force this thread to have a message queue, just in case.
    //
    PeekMessage(&msg,NULL,0,0,PM_NOREMOVE);

    //
    // The thread parameter is the queue context.
    //
    context = Context;

    //
    // Create the progress dialog box.
    //
    i = DialogBoxParam(
            MyDllModuleHandle,
            MAKEINTRESOURCE(IDD_FILEPROGRESS),
            context->OwnerWindow,
            pSetupProgressDlgProc,
            (LPARAM)context
            );

    //
    // flag that this is the very last time hEvent will be set
    //
    context->bDialogExited = TRUE;
    SetEvent(context->hEvent);

    //
    // Done.
    //
    _endthread();
}

BOOL
pWaitForUiResponse(
    IN OUT PQUEUECONTEXT Context
    )
/*++

Routine Description:

    Waits for UI event to be set

Arguments:

    Context - supplies queue-context structure

Return Value:

    FALSE = failure

--*/
{
    BOOL KeepWaiting = TRUE;
    DWORD WaitProcStatus;

    if (Context->hEvent == NULL) {
        MYASSERT(Context->hEvent);
        return FALSE;
    }
    if (Context->bDialogExited) {
        //
        // dialog has already exited, we wont get another event
        //
        return FALSE;
    }

    while (KeepWaiting) {
        WaitProcStatus = MyMsgWaitForMultipleObjectsEx(
            1,
            &Context->hEvent,
            INFINITE,
            QS_ALLINPUT,
            MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);
        switch (WaitProcStatus) {
        case WAIT_OBJECT_0 + 1: { // Process gui messages
            MSG msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            // fall through ...
        }
        case WAIT_IO_COMPLETION:
            break;

        case WAIT_OBJECT_0:
        case WAIT_TIMEOUT:
        default:
            KeepWaiting = FALSE;
            break;
        }
    }

    return TRUE;
}

UINT
PostUiMessage (
    IN      PQUEUECONTEXT Context,
    IN      UINT          UiType,
    IN      UINT          CancelCode,
    IN OUT  PVOID         UiParameters
    )
{
    MSG msg;

    if(IsWindow(Context->ProgressDialog)) {
        //
        // Let progress ui thread handle it.
        //
        Context->lParam = FILEOP_ABORT; // in case nobody gets chance to set Context->lParam
        PostMessage(
            Context->ProgressDialog,
            WMX_PERFORMUI,
            MAKEWPARAM(UiType,CancelCode),
            (LPARAM)UiParameters
            );
        pWaitForUiResponse(Context);
        return (UINT)Context->lParam;
    } else {
        //
        // There is no progress thread so do it synchronously.
        //
        return (UINT)pPerformUi(Context,UiType,UiParameters);
    }

    return 0;
}


UINT
pNotificationStartQueue(
    IN PQUEUECONTEXT Context
    )

/*++

Routine Description:

    Handle SPFILENOTIFY_STARTQUEUE.

    Creates a progress dialog in a separate thread.

Arguments:

    Context - supplies queue context.

Return Value:

    0 if unsuccessful, non-0 if successful.

--*/

{
    ULONG_PTR Thread;
    MSG msg;

    //
    // SetupCommitFileQueue could have been called in a different
    // thread. Adjust the thread id.
    //
    Context->MainThreadId = GetCurrentThreadId();

    //
    // Force this thread to have a message queue. If we don't do this,
    // then PostMessage, PostThreadMessage, etc can fail, which results
    // in hangs in some cases since we rely heavily on these for
    // progress, synchronization, etc.
    //
    PeekMessage(&msg,NULL,0,0,PM_NOREMOVE);

    if(Context->AlternateProgressWindow) {
        //
        // Either the caller is supplying their own window for progress UI,
        // or this is a silent install (AlternateProgressWindow is
        // INVALID_HANDLE_VALUE).
        //
        return(TRUE);
    } else {
        //
        // Fire up the progress dialog in a separate thread.
        // This allows it to be responsive without suspending
        // the file operations.
        //
        Thread = _beginthread(
                    pSetupProgressThread,
                    0,
                    Context
                    );

        if(Thread == -1) {
            //
            // assume OOM
            //
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(0);
        }

        //
        // Wait for notification from the thread about the state
        // of the dialog. Assume out of memory if we fail
        //
        if(!pWaitForUiResponse(Context) || Context->bDialogExited) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        } else {
            return TRUE;
        }
    }
}


UINT
pNotificationStartEndSubqueue(
    IN PQUEUECONTEXT Context,
    IN BOOL          Start,
    IN UINT_PTR      Operation,
    IN UINT_PTR      OpCount
    )

/*++

Routine Description:

    Handle SPFILENOTIFY_STARTSUBQUEUE, SPFILENOTIFY_ENDSUBQUEUE.

    Initializes/terminates a progress control.
    Also sets progress dialog caption.

Arguments:

    Context - supplies queue context.

    Start - if TRUE, then this routine is being called to handle
        a subqueue start notification. Otherwise it's supposed to
        handle a subqueue end notification.

    Operation - one of FILEOP_COPY, FILEOP_DELETE, FILEOP_RENAME.

    OpCount - supplies number of copies, renames, or deletes.

Return Value:

    0 if unsuccessful, non-0 if successful.

--*/

{
    UINT rc;
    UINT CaptionStringId;
    TCHAR ParentText[256];
    BOOL GotParentText;
    PCTSTR CaptionText;
    UINT AnimationId;
    HWND Animation;

    rc = 1;         // assume success.

    if(Context->Cancelled) {
        SetLastError(ERROR_CANCELLED);
        return(0);
    }

    if(Start) {

        if(IsWindow(Context->OwnerWindow)
        && GetWindowText(Context->OwnerWindow,ParentText,256)) {
            GotParentText = TRUE;
        } else {
            GotParentText = FALSE;
        }

        //
        // Clean out the text fields first.
        //
        if(IsWindow(Context->ProgressDialog)) {
            SetDlgItemText(Context->ProgressDialog,IDT_TEXT1,TEXT(""));
            SetDlgItemText(Context->ProgressDialog,IDT_TEXT2,TEXT(""));
        }

        switch(Operation) {

        case FILEOP_COPY:
            //
            // IDT_TEXT1 = target name sans path
            // IDT_TEXT2 = target name with path
            //
            if(IsWindow(Context->ProgressDialog)) {
                ShowWindow(GetDlgItem(Context->ProgressDialog,IDT_TEXT2),SW_SHOW);
            }
            CaptionStringId = GotParentText ? IDS_COPY_CAPTION1 : IDS_COPY_CAPTION2;
            AnimationId = IDA_FILECOPY;
            break;

        case FILEOP_RENAME:
            if(IsWindow(Context->ProgressDialog)) {
                ShowWindow(GetDlgItem(Context->ProgressDialog,IDT_TEXT2),SW_SHOW);
            }
            CaptionStringId = GotParentText ? IDS_RENAME_CAPTION1 : IDS_RENAME_CAPTION2;
            AnimationId = IDA_FILECOPY;
            break;

        case FILEOP_DELETE:
            //
            // IDT_TEXT1 = target name sans path
            // IDT_TEXT2 = path
            //
            if(IsWindow(Context->ProgressDialog)) {
                ShowWindow(GetDlgItem(Context->ProgressDialog,IDT_TEXT2),SW_HIDE);
            }
            CaptionStringId = GotParentText ? IDS_DELETE_CAPTION1 : IDS_DELETE_CAPTION2;
            AnimationId = IDA_FILEDEL;
            break;

        case FILEOP_BACKUP:
            // handle the new backup case (this is for a backup queue as opposed to on demand
            if(IsWindow(Context->ProgressDialog)) {
                ShowWindow(GetDlgItem(Context->ProgressDialog,IDT_TEXT2),SW_SHOW);
            }
            CaptionStringId = GotParentText ? IDS_BACKUP_CAPTION1 : IDS_BACKUP_CAPTION2;
            AnimationId = IDA_FILECOPY;
            break;

        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            rc = 0;
            break;
        }

        if(rc) {
            //
            // Set dialog caption.
            //
            if(GotParentText) {
                CaptionText = FormatStringMessage(CaptionStringId,ParentText);
            } else {
                CaptionText = MyLoadString(CaptionStringId);
            }
            if(CaptionText) {
                if(IsWindow(Context->ProgressDialog)) {
                    if(!SetWindowText(Context->ProgressDialog,CaptionText)) {
                        SetWindowText(Context->ProgressDialog,TEXT(""));
                    }
                }
                MyFree(CaptionText);
            }

            if(Context->AlternateProgressWindow) {
                //
                // If this is really an alternate progress window, notify it
                // about the number of operations. Copy only.
                //
                if((Operation == FILEOP_COPY) &&
                   (Context->AlternateProgressWindow != INVALID_HANDLE_VALUE)) {

                    SendMessage(Context->AlternateProgressWindow,
                                Context->ProgressMsg,
                                0,
                                OpCount
                               );
                }
            } else {
                //
                // Set up the progress control. Each file will be 1 tick.
                //
                if(IsWindow(Context->ProgressBar)) {
                    SendMessage(Context->ProgressBar,PBM_SETRANGE,0,MAKELPARAM(0,OpCount));
                    SendMessage(Context->ProgressBar,PBM_SETSTEP,1,0);
                    SendMessage(Context->ProgressBar,PBM_SETPOS,0,0);
                }

                //
                // And set up the animation control based on the operation type.
                //
                if(OpCount && IsWindow(Context->ProgressDialog)) {

                    Animation = GetDlgItem(Context->ProgressDialog,IDA_ANIMATION);

                    if(Animation) {
                        Animate_Open(Animation,MAKEINTRESOURCE(AnimationId));
                        Animate_Play(Animation,0,-1,-1);
                    }
                }
            }
        }
    } else {
        //
        // Stop the animation control. Note that if the op count was 0
        // then we never started it, so stopping/unloading will give an error,
        // which we ignore. It's not harmful.
        //
        if(!Context->AlternateProgressWindow && IsWindow(Context->ProgressDialog)) {

            Animation = GetDlgItem(Context->ProgressDialog,IDA_ANIMATION);
            if (Animation) {
                Animate_Stop(Animation);
                Animate_Close(Animation);
            }
        }
    }

    return(rc);
}


UINT
pNotificationStartOperation(
    IN PQUEUECONTEXT Context,
    IN PFILEPATHS    FilePaths,
    IN UINT_PTR      Operation
    )

/*++

Routine Description:

    Handle SPFILENOTIFY_STARTRENAME, SPFILENOTIFY_STARTDELETE,
    SPFILENOTIFY_STARTCOPY or SPFILENOTIFY_STARTBACKUP.

    Updates text in the progress dialog to indicate the files
    involved in the operation.

Arguments:

    Context - supplies queue context.

    Start - if TRUE, then this routine is being called to handle
        a subqueue start notification. Otherwise it's supposed to
        handle a subqueue end notification.

    Operation - one of FILEOP_COPY, FILEOP_DELETE, FILEOP_RENAME.

    OpCount - supplies number of copies, renames, or deletes.

Return Value:

    FILEOP_ABORT if error, otherwise FILEOP_DOIT.
--*/

{
    PCTSTR Text1,Text2;
    PTSTR p;
    TCHAR Target[MAX_PATH];
    UINT rc;
    DWORD ec;

    if(Context->Cancelled) {
        SetLastError(ERROR_CANCELLED);
        return(FILEOP_ABORT);
    }

    Text1 = Text2 = NULL;
    rc = FILEOP_ABORT;
    ec = ERROR_NOT_ENOUGH_MEMORY;

    switch(Operation) {
    case FILEOP_COPY:
        lstrcpyn(Target,FilePaths->Target,MAX_PATH);
        if(p = _tcsrchr(Target,TEXT('\\'))) {
            //
            // Ignore the source filename completely.
            //
            *p++ = 0;
            Text1 = DuplicateString(p);
            Text2 = FormatStringMessage(IDS_FILEOP_TO,Target);
        } else {
            //
            // Assume not full path -- strange case, but deal with it anyway.
            //
            Text1 = DuplicateString(FilePaths->Target);
            Text2 = DuplicateString(TEXT(""));
        }
        break;

    case FILEOP_RENAME:

        Text1 = DuplicateString(FilePaths->Source);
        if(p = _tcsrchr(FilePaths->Target,TEXT('\\'))) {
            p++;
        } else {
            p = (PTSTR)FilePaths->Target;
        }
        Text2 = FormatStringMessage(IDS_FILEOP_TO,p);
        break;

    case FILEOP_DELETE:

        lstrcpyn(Target,FilePaths->Target,MAX_PATH);
        if(p = _tcsrchr(Target,TEXT('\\'))) {
            *p++ = 0;
            Text1 = DuplicateString(p);
            Text2 = FormatStringMessage(IDS_FILEOP_FROM,Target);
        } else {
            //
            // Assume not full path -- strange case, but deal with it anyway.
            //
            Text1 = DuplicateString(FilePaths->Target);
            Text2 = DuplicateString(TEXT(""));
        }
        break;

    case FILEOP_BACKUP:
        lstrcpyn(Target,FilePaths->Source,MAX_PATH);
        if(p = _tcsrchr(Target,TEXT('\\'))) {
            //
            // FilePaths->Source = what we're backing up (which is target of a restore)
            // FilePaths->Target = where we're backing up to (block backup) or NULL (demand backup)
            //
            *p++ = 0;
            if (FilePaths->Target == NULL) {
                // Backing up <Filename>
                Text1 = FormatStringMessage(IDS_FILEOP_BACKUP,p);
            } else {
                // <Filename> (title already says Backing up)
                Text1 = DuplicateString(p);
            }
            // From <Directory>
            Text2 = FormatStringMessage(IDS_FILEOP_FROM,Target);
        } else {
            //
            // Assume not full path -- strange case, but deal with it anyway.
            //
            if (FilePaths->Source == NULL) {
                Text1 = FormatStringMessage(IDS_FILEOP_BACKUP,Target);
            } else {
                Text1 = DuplicateString(Target);
            }
            Text2 = DuplicateString(TEXT(""));
        }
        break;


    default:
        ec = ERROR_INVALID_PARAMETER;
        break;
    }

    if(Text1 && Text2) {
        if(IsWindow(Context->ProgressDialog)) {
            SetDlgItemText(Context->ProgressDialog,IDT_TEXT1,Text1);
            SetDlgItemText(Context->ProgressDialog,IDT_TEXT2,Text2);
        }
        rc = FILEOP_DOIT;
    }

    if(Text1) {
        MyFree(Text1);
    }
    if(Text2) {
        MyFree(Text2);
    }
    SetLastError(ec);
    return(rc);
}


UINT
pNotificationErrorCopy(
    IN  PQUEUECONTEXT Context,
    IN  PFILEPATHS    FilePaths,
    OUT PTSTR         PathOut
    )
{
    UINT rc;
    COPYERRORUI CopyError;


    CopyError.FilePaths = FilePaths;
    CopyError.PathOut = PathOut;

    //
    // Buffer gets the pathname part of the source
    // and p points to the filename part of the source.
    //
    lstrcpyn(CopyError.Buffer,FilePaths->Source,MAX_PATH);
    CopyError.Filename = _tcsrchr(CopyError.Buffer,TEXT('\\'));
    *CopyError.Filename++ = 0;

    //
    // The noskip and warnifskip flags are really mutually exclusive
    // but we don't try to enforce that here. Just pass through as
    // appropriate.
    //
    CopyError.Flags = 0;
    if(FilePaths->Flags & SP_COPY_NOSKIP) {
        CopyError.Flags |= IDF_NOSKIP;
    }
    if(FilePaths->Flags & SP_COPY_WARNIFSKIP) {
        CopyError.Flags |= IDF_WARNIFSKIP;
    }
    //
    // Also pass through the 'no browse' flag.
    //
    if(FilePaths->Flags & SP_COPY_NOBROWSE) {
        CopyError.Flags |= IDF_NOBROWSE;
    }

    rc = PostUiMessage (Context, UI_COPYERROR, DPROMPT_CANCEL, &CopyError);

    switch(rc) {

    case DPROMPT_SUCCESS:
        //
        // If a new path is indicated, verify that it actually changed.
        //
        if(CopyError.PathOut[0] &&
            !lstrcmpi(CopyError.Buffer,CopyError.PathOut)) {
            CopyError.PathOut[0] = 0;
        }
        rc = FILEOP_RETRY;
        break;

    case DPROMPT_SKIPFILE:
        rc = FILEOP_SKIP;
        break;

    case DPROMPT_CANCEL:
        SetLastError(ERROR_CANCELLED);
        rc = FILEOP_ABORT;
        break;

    default:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        rc = FILEOP_ABORT;
        break;
    }

    return(rc);
}

UINT
pNotificationStartRegistration(
    IN  PQUEUECONTEXT Context,
    IN  PSP_REGISTER_CONTROL_STATUS ControlStatus,
    IN  BOOL Register
    )
{

    return FILEOP_DOIT;
}


UINT
pNotificationErrorDelete(
    IN  PQUEUECONTEXT Context,
    IN  PFILEPATHS    FilePaths
    )
{
    UINT rc;

    //
    // Certain errors are not actually errors.
    //
    if((FilePaths->Win32Error == ERROR_FILE_NOT_FOUND)
    || (FilePaths->Win32Error == ERROR_PATH_NOT_FOUND)) {
        return(FILEOP_SKIP);
    }

    rc = PostUiMessage (Context, UI_DELETEERROR, DPROMPT_CANCEL, FilePaths);

    switch(rc) {

    case DPROMPT_SUCCESS:
        return(FILEOP_RETRY);

    case DPROMPT_SKIPFILE:
        return(FILEOP_SKIP);

    case DPROMPT_CANCEL:
        SetLastError(ERROR_CANCELLED);
        return(FILEOP_ABORT);

    default:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FILEOP_ABORT);
    }
}


UINT
pNotificationErrorRename(
    IN  PQUEUECONTEXT Context,
    IN  PFILEPATHS    FilePaths
    )
{
    UINT rc;

    rc = PostUiMessage (Context, UI_RENAMEERROR, DPROMPT_CANCEL, FilePaths);

    switch(rc) {

    case DPROMPT_SUCCESS:
        return(FILEOP_RETRY);

    case DPROMPT_SKIPFILE:
        return(FILEOP_SKIP);

    case DPROMPT_CANCEL:
        SetLastError(ERROR_CANCELLED);
        return(FILEOP_ABORT);

    default:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FILEOP_ABORT);
    }
}

UINT
pNotificationErrorBackup(
    IN  PQUEUECONTEXT Context,
    IN  PFILEPATHS    FilePaths
    )
{
    UINT rc;

    if(!(FilePaths->Flags & SP_BACKUP_SPECIAL)) {
        return FILEOP_SKIP;
    }

    rc = PostUiMessage (Context, UI_BACKUPERROR, DPROMPT_CANCEL, FilePaths);

    switch(rc) {

    case DPROMPT_SUCCESS:
        return(FILEOP_RETRY);

    case DPROMPT_SKIPFILE:
        return(FILEOP_SKIP);

    case DPROMPT_CANCEL:
        SetLastError(ERROR_CANCELLED);
        return(FILEOP_ABORT);

    default:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FILEOP_ABORT);
    }
}


UINT
pNotificationNeedMedia(
    IN  PQUEUECONTEXT Context,
    IN  PSOURCE_MEDIA SourceMedia,
    OUT PTSTR         PathOut
    )
{
    UINT rc;
    TCHAR Buffer[MAX_PATH];
    NEEDMEDIAUI NeedMedia;

    if(Context->Cancelled) {
        SetLastError(ERROR_CANCELLED);
        return(FILEOP_ABORT);
    }

    NeedMedia.SourceMedia = SourceMedia;
    NeedMedia.PathOut = PathOut;

    //
    // Remember the name of this media.
    //
    if(Context->CurrentSourceName) {
        MyFree(Context->CurrentSourceName);
        Context->CurrentSourceName = NULL;
    }
    if(SourceMedia->Description) {
        Context->CurrentSourceName = DuplicateString(SourceMedia->Description);
        if(!Context->CurrentSourceName) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FILEOP_ABORT);
        }
    }

    //
    // Set the source file in the progress dialog
    // so it matches the file being sought.
    //
    if(!(SourceMedia->Flags & SP_FLAG_CABINETCONTINUATION)) {
        if(IsWindow(Context->ProgressDialog) && !Context->ScreenReader) {
            DWORD chars;
            lstrcpyn(Buffer,SourceMedia->SourcePath,MAX_PATH);
            pSetupConcatenatePaths(Buffer,SourceMedia->SourceFile,MAX_PATH,NULL);
            SetTruncatedDlgItemText(Context->ProgressDialog,IDT_TEXT1,Buffer);
            SetDlgItemText(Context->ProgressDialog,IDT_TEXT2,TEXT(""));
        }
    }

    //
    // The noskip and warnifskip flags are really mutually exclusive
    // but we don't try to enforce that here. Just pass through as
    // appropriate.
    //
    // Allow skip if this is not a cabinet continuation and
    // the noskip flag is not set.
    //
    NeedMedia.Flags = IDF_CHECKFIRST;
    if(SourceMedia->Flags & (SP_FLAG_CABINETCONTINUATION | SP_COPY_NOSKIP)) {
        NeedMedia.Flags |= IDF_NOSKIP;
    }
    if(SourceMedia->Flags & SP_COPY_WARNIFSKIP) {
        NeedMedia.Flags |= IDF_WARNIFSKIP;
    }
    if(SourceMedia->Flags & SP_COPY_NOBROWSE) {
        NeedMedia.Flags |= IDF_NOBROWSE;
    }

    rc = PostUiMessage (Context, UI_NEEDMEDIA, DPROMPT_CANCEL, &NeedMedia);

    switch(rc) {

    case DPROMPT_SUCCESS:
        //
        // If the path really has changed, then return NEWPATH.
        // Otherwise return DOIT. Account for trailing backslash
        // differences.
        //
        lstrcpyn(Buffer,SourceMedia->SourcePath,MAX_PATH);

        rc = lstrlen(Buffer);
        if(rc && (*CharPrev(Buffer,Buffer+rc) == TEXT('\\'))) {
            Buffer[rc-1] = TEXT('\0'); // valid to do if last char is '\'
        }

        rc = lstrlen(NeedMedia.PathOut);
        if(rc && (*CharPrev(NeedMedia.PathOut,NeedMedia.PathOut+rc) == TEXT('\\'))) {
            NeedMedia.PathOut[rc-1] = TEXT('\0'); // valid to do if last char is '\'
        }

        rc = (lstrcmpi(SourceMedia->SourcePath,NeedMedia.PathOut) ?
            FILEOP_NEWPATH : FILEOP_DOIT);

        //
        // Make sure <drive>: ends with a \.
        //
        if(NeedMedia.PathOut[0] && (NeedMedia.PathOut[1] == TEXT(':')) &&
            !NeedMedia.PathOut[2]) {
            NeedMedia.PathOut[2] = TEXT('\\');
            NeedMedia.PathOut[3] = TEXT('\0');
        }

        break;

    case DPROMPT_SKIPFILE:
        rc = FILEOP_SKIP;
        break;

    case DPROMPT_CANCEL:
        SetLastError(ERROR_CANCELLED);
        rc = FILEOP_ABORT;
        break;

    default:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        rc = FILEOP_ABORT;
        break;
    }

    return(rc);
}


INT_PTR
pNotificationVersionDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    PVERDLGCONTEXT context;
    PFILEPATHS filePaths;
    HWND hwnd;
    TCHAR text[128];
    TCHAR Buffer[MAX_PATH*2];
    PCTSTR message;
    int i;
    TCHAR SourceLangName[128];
    TCHAR TargetLangName[128];

    switch(msg) {

    case WM_INITDIALOG:

        context = (PVERDLGCONTEXT)lParam;
        MYASSERT(context != NULL);

        filePaths = (PFILEPATHS)context->Param1;

        if(!SetProp(hdlg,DialogPropName,(HANDLE)context)) {
            goto no_memory;
        }

        //
        // Set the source and target filenames. Hack: if the source filename
        // looks like one of our temporary filenames from a cabinet extraction,
        // hide it.
        //
        message = pSetupGetFileTitle(filePaths->Source);
        i = lstrlen(message);
        if((i > 8)
        && (_totupper(message[0]) == TEXT('S'))
        && (_totupper(message[1]) == TEXT('E'))
        && (_totupper(message[2]) == TEXT('T'))
        && (_totupper(message[3]) == TEXT('P'))
        && !_tcsicmp(message+(i-4),TEXT(".TMP"))) {

            ShowWindow(GetDlgItem(hdlg,IDT_TEXT7),SW_HIDE);

        } else {
            GetDlgItemText(hdlg,IDT_TEXT7,text,SIZECHARS(text));
            message = FormatStringMessageFromString(text,filePaths->Source);
            if (message == NULL) goto no_memory;
            SetTruncatedDlgItemText(hdlg,IDT_TEXT7,message);
            MyFree(message);
        }

        GetDlgItemText(hdlg,IDT_TEXT8,text,SIZECHARS(text));
        message = FormatStringMessageFromString(text,filePaths->Target);
        if (message == NULL) goto no_memory;
        SetTruncatedDlgItemText(hdlg,IDT_TEXT8,message);
        MyFree(message);

        if (context->Notification & SPFILENOTIFY_LANGMISMATCH) {
            //
            // Language mismatch has the highest priority.
            //
            context->Notification = SPFILENOTIFY_LANGMISMATCH; // force other bits off, for NoToAll

            //
            // Format the overwrite question.
            //
            if(PRIMARYLANGID(LOWORD(context->Param2))==LANG_NEUTRAL) {
                LoadString(
                    MyDllModuleHandle,
                    IDS_LANG_NEUTRAL,
                    SourceLangName,
                    SIZECHARS(SourceLangName)
                    );
            } else {
                i = GetLocaleInfo(
                        MAKELCID(LOWORD(context->Param2),SORT_DEFAULT),
                        LOCALE_SLANGUAGE,
                        SourceLangName,
                        SIZECHARS(SourceLangName)
                        );
                if(!i) {
                    LoadString(
                        MyDllModuleHandle,
                        IDS_LANG_UNKNOWN,
                        SourceLangName,
                        SIZECHARS(SourceLangName)
                        );
                }
            }


            if(PRIMARYLANGID(HIWORD(context->Param2))==LANG_NEUTRAL) {
                LoadString(
                    MyDllModuleHandle,
                    IDS_LANG_NEUTRAL,
                    TargetLangName,
                    SIZECHARS(TargetLangName)
                    );
            } else {
                i = GetLocaleInfo(
                        MAKELCID(HIWORD(context->Param2),SORT_DEFAULT),
                        LOCALE_SLANGUAGE,
                        TargetLangName,
                        SIZECHARS(TargetLangName)
                        );
                if(!i) {
                    LoadString(
                        MyDllModuleHandle,
                        IDS_LANG_UNKNOWN,
                        TargetLangName,
                        SIZECHARS(TargetLangName)
                        );
                }
            }
            GetDlgItemText(hdlg,IDT_TEXT4,text,SIZECHARS(text));
            message = FormatStringMessageFromString(text,TargetLangName,SourceLangName);
            if (message == NULL) goto no_memory;
            SetDlgItemText(hdlg,IDT_TEXT4,message);
            MyFree(message);

            //
            // Turn off the TARGETNEWER and TARGETEXISTS messages.
            //
            hwnd = GetDlgItem(hdlg,IDT_TEXT2);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT3);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT5);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT6);
            ShowWindow(hwnd,SW_HIDE);

        } else if (context->Notification & SPFILENOTIFY_TARGETNEWER) {
            //
            // Target being newer has second highest priority.
            //
            context->Notification = SPFILENOTIFY_TARGETNEWER; // force other bits off, for NoToAll

            //
            // Turn off the LANGMISMATCH and TARGETEXISTS messages.
            //
            hwnd = GetDlgItem(hdlg,IDT_TEXT1);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT3);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT4);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT6);
            ShowWindow(hwnd,SW_HIDE);

        } else {            // must be exactly SPFILENOTIFY_TARGETEXISTS
            //
            // Target existing has the lowest priority.
            //
            // Turn off the LANGMISMATCH and TARGETNEWER messages.
            //
            hwnd = GetDlgItem(hdlg,IDT_TEXT1);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT2);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT4);
            ShowWindow(hwnd,SW_HIDE);
            hwnd = GetDlgItem(hdlg,IDT_TEXT5);
            ShowWindow(hwnd,SW_HIDE);

        }

        PostMessage(hdlg,WMX_HELLO,0,0);
        break;

    case WMX_HELLO:
        //
        // If this guy has no owner force him to the foreground.
        // This catches cases where people are using a series of
        // dialogs and then some setup apis, because when they
        // close a dialog focus switches away from them.
        //
        hwnd = GetWindow(hdlg,GW_OWNER);
        if(!IsWindow(hwnd)) {
            SetForegroundWindow(hdlg);
        }
        break;

    case WM_COMMAND:
        context = (PVERDLGCONTEXT)GetProp(hdlg,DialogPropName);
        MYASSERT(context != NULL);
        switch (GET_WM_COMMAND_ID(wParam,lParam)) {

        case IDYES:
            EndDialog(hdlg,IDYES);  // copy this file
            break;

        case IDNO:
            EndDialog(hdlg,IDNO);   // skip this file
            break;

        case IDB_NOTOALL:
            //
            // No to All was selected.  Add this notification type to the
            // NoToAllMask so that we don't ask about it again.
            //
            context->QueueContext->NoToAllMask |= context->Notification;
            EndDialog(hdlg,IDNO);   // skip this file
            break;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;

no_memory:
    pSetupOutOfMemory(
        IsWindow(context->QueueContext->ProgressDialog) ?
            context->QueueContext->ProgressDialog : context->QueueContext->OwnerWindow
        );
    EndDialog(hdlg,IDNO);   // skip this file
    return TRUE;
}


LPARAM
pPerformUi (
    IN  PQUEUECONTEXT   Context,
    IN  UINT            UiType,
    IN  PVOID           UiParameters
    )
{
    PCOPYERRORUI    CopyError;
    PFILEPATHS      FilePaths;
    PNEEDMEDIAUI    NeedMedia;
    INT_PTR         rc;
    HWND            Animation;

    if(!Context->AlternateProgressWindow && IsWindow(Context->ProgressDialog)) {
        Animation = GetDlgItem(Context->ProgressDialog,IDA_ANIMATION);
    } else {
        Animation = NULL;
    }

    switch (UiType) {

    case UI_COPYERROR:
        CopyError = (PCOPYERRORUI)UiParameters;
        if (Animation) {
            Animate_Stop(Animation);
        }
        rc = SetupCopyError(
                IsWindow(Context->ProgressDialog) ? Context->ProgressDialog : Context->OwnerWindow,
                NULL,
                Context->CurrentSourceName,
                CopyError->Buffer,
                CopyError->Filename,
                CopyError->FilePaths->Target,
                CopyError->FilePaths->Win32Error,
                CopyError->Flags,
                CopyError->PathOut,
                MAX_PATH,
                NULL
                );
        if (Animation) {
            Animate_Play(Animation,0,-1,-1);
        }
        break;

    case UI_DELETEERROR:
        FilePaths = (PFILEPATHS)UiParameters;

        if (Animation) {
            Animate_Stop(Animation);
        }
        rc = SetupDeleteError(
                IsWindow(Context->ProgressDialog) ? Context->ProgressDialog : Context->OwnerWindow,
                NULL,
                FilePaths->Target,
                FilePaths->Win32Error,
                0
                );
        if (Animation) {
            Animate_Play(Animation,0,-1,-1);
        }

        break;

    case UI_RENAMEERROR:
        FilePaths = (PFILEPATHS)UiParameters;

        if(Animation) {
            Animate_Stop(Animation);
        }
        rc = SetupRenameError(
                IsWindow(Context->ProgressDialog) ? Context->ProgressDialog : Context->OwnerWindow,
                NULL,
                FilePaths->Source,
                FilePaths->Target,
                FilePaths->Win32Error,
                0
                );
        if(Animation) {
            Animate_Play(Animation,0,-1,-1);
        }

        break;

    case UI_BACKUPERROR:
        FilePaths = (PFILEPATHS)UiParameters;

        if(Animation) {
            Animate_Stop(Animation);
        }
        rc = SetupBackupError(
                IsWindow(Context->ProgressDialog) ? Context->ProgressDialog : Context->OwnerWindow,
                NULL,
                FilePaths->Source,
                FilePaths->Target,
                FilePaths->Win32Error,
                0
                );
        if(Animation) {
            Animate_Play(Animation,0,-1,-1);
        }

        break;

    case UI_NEEDMEDIA:
        NeedMedia = (PNEEDMEDIAUI)UiParameters;

        if(Animation) {
            Animate_Stop(Animation);
        }
        rc = SetupPromptForDisk(
                IsWindow(Context->ProgressDialog) ? Context->ProgressDialog : Context->OwnerWindow,
                NULL,
                NeedMedia->SourceMedia->Description,
                NeedMedia->SourceMedia->SourcePath,
                NeedMedia->SourceMedia->SourceFile,
                NeedMedia->SourceMedia->Tagfile,
                NeedMedia->Flags,
                NeedMedia->PathOut,
                MAX_PATH,
                NULL
                );
        if(Animation) {
            Animate_Play(Animation,0,-1,-1);
        }

        break;

    case UI_MISMATCHERROR:
        if(Animation) {
            Animate_Stop(Animation);
        }
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            rc = DPROMPT_CANCEL;
        } else {
            rc = DialogBoxParam(
                     MyDllModuleHandle,
                     MAKEINTRESOURCE(IDD_REPLACE),
                     IsWindow(Context->ProgressDialog) ?
                        Context->ProgressDialog : Context->OwnerWindow,
                     pNotificationVersionDlgProc,
                     (LPARAM)UiParameters
                     );
        }
        if(Animation) {
            Animate_Play(Animation,0,-1,-1);
        }
        break;

    default:
        MYASSERT (0);
        rc = 0;
    }

    return rc;
}


INT_PTR
pSetupProgressDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    PQUEUECONTEXT Context;
    HWND hwnd;
    PTSTR p;
    INT_PTR i;
    MSG m;
    BOOL Cancelled;
    HANDLE h;
    static UINT uQueryCancelAutoPlay = 0;

    switch(msg) {

    case WM_INITDIALOG:

#ifdef PRERELEASE
        if (GuiSetupInProgress) {
            MYASSERT( FALSE && TEXT("bringing up file progress dialog (IDD_FILEPROGRESS) during gui-mode setup, which is a UI violation.  Click yes and retrive a stack trace to determine errant caller.\n"));
        }
#endif

        Context = (PQUEUECONTEXT)lParam;
        MYASSERT(Context != NULL);
        if(!SetProp(hdlg,DialogPropName,(HANDLE)Context)) {
            //
            // running out of resources, kill this dialog
            //
            EndDialog(hdlg, -1);
            return TRUE;            // TRUE or FALSE, it really doesn't matter
        }

        #ifdef NOCANCEL_SUPPORT
        //
        // If cancel is not allowed, disable the cancel button.
        //
        if(!Context->AllowCancel) {

            RECT rect;
            RECT rect2;

            hwnd = GetDlgItem(hdlg,IDCANCEL);

            ShowWindow(hwnd,SW_HIDE);
            EnableWindow(hwnd,FALSE);

            GetWindowRect(hdlg,&rect);
            GetWindowRect(hwnd,&rect2);

            SetWindowPos(
                hdlg,
                NULL,
                0,0,
                rect.right - rect.left,
                (rect.bottom - rect.top) - (rect.bottom - rect2.top),
                SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOZORDER
                );
        }
#endif

        //
        // Center the progress dialog relative to the parent window.
        //
        pSetupCenterWindowRelativeToParent(hdlg);

        SetFocus(GetDlgItem(hdlg,IDCANCEL));

        //
        // The main thread is processing SPFILENOTIFY_STARTQUEUE and is
        // waiting for some notification about the state of the UI thread.
        // Let the main thread know we succeeded, and pass back a real
        // handle to this thread that can be used to wait for it to terminate.
        //
        b = DuplicateHandle(
                GetCurrentProcess(),    // source process
                GetCurrentThread(),     // source handle
                GetCurrentProcess(),    // target process
                &h,                     // new handle
                0,                      // ignored with DUPLICATE_SAME_ACCESS
                FALSE,                  // not inheritable
                DUPLICATE_SAME_ACCESS
                );

        if(!b) {
            //
            // Since we cannot duplicate the handle, we must kill this dialog,
            // because otherwise the inter-thread communication will be broken
            // and things go horribly wrong.
            //
            EndDialog(hdlg, -1);
            return TRUE;            // TRUE or FALSE, it really doesn't matter
        }

        //
        // Store the dialog and progress bar handles in the context structure.
        //
        Context->ProgressDialog = hdlg;
        Context->ProgressBar = GetDlgItem(hdlg,IDC_PROGRESS);

        Context->UiThreadHandle = h;
        PostMessage(hdlg,WMX_HELLO,0,0); // put WMX_HELLO on our message queue
        SetEvent(Context->hEvent); // inform caller we've done initialization

        b = FALSE;
        break;

    case WMX_HELLO:
        //
        // If this guy has no owner force him to the foreground.
        // This catches cases where people are using a series of
        // dialogs and then some setup apis, because when they
        // close a dialog focus switches away from them.
        //
        hwnd = GetWindow(hdlg,GW_OWNER);
        if(!IsWindow(hwnd)) {
            SetForegroundWindow(hdlg);
        }

        b = TRUE;

        break;

    case WMX_PERFORMUI:
        b = TRUE;
        Context = (PQUEUECONTEXT)GetProp(hdlg,DialogPropName);
        MYASSERT(Context != NULL);

        //
        // We'd better not already have any UI pending...
        //
        MYASSERT(Context->PendingUiType == UI_NONE);

        if (Context->MessageBoxUp == TRUE) {
            Context->PendingUiType = LOWORD (wParam);
            Context->CancelReturnCode = HIWORD (wParam);
            Context->PendingUiParameters = (PVOID)lParam;
        } else {
            Context->lParam = pPerformUi (Context, LOWORD(wParam), (PVOID)lParam);
            SetEvent(Context->hEvent); // wakeup main thread (lParam has Ui result)
        }

        break;

    case WM_COMMAND:
        Context = (PQUEUECONTEXT)GetProp(hdlg,DialogPropName);
        MYASSERT(Context != NULL);
        if((HIWORD(wParam) == BN_CLICKED) && (LOWORD(wParam) == IDCANCEL)) {
            p = MyLoadString(IDS_CANCELFILEOPS);
            Cancelled = FALSE;
            if(p) {
                //
                // While the message box is up, the main thread is still copying files,
                // and it might just complete. If that happens, the main thread will
                // post us WMX_KILLDIALOG, which would cause this dialog to nuke itself
                // out from under the message box. The main thread would then continue
                // executing while the message box is sitting there. Some components
                // actually unload setupapi.dll at that point, and so when the user
                // dismisses the message box, an AV results.
                //
                // We can't freeze the main thread via SuspendThread because then
                // that thread, which probably owns this dialog's parent window,
                // will not be able to process messages that result from the message box's
                // creation. Result is that the message box never comes up and the process
                // is deadlocked.
                //
                // We'd better not already have a message box up!
                //
                MYASSERT(!Context->MessageBoxUp);

                Context->MessageBoxUp = TRUE;
                i = MessageBox(
                        hdlg,
                        p,
                        TEXT(""),
                        MB_YESNO | MB_APPLMODAL | MB_DEFBUTTON2 | MB_SETFOREGROUND | MB_ICONQUESTION
                        );

                Context->MessageBoxUp = FALSE;

                //
                // We set b to TRUE if the dialog is going away.
                // We set Cancelled to TRUE if the user clicked the CANCEL button.
                //
                if(Context->DialogKilled) {
                    b = TRUE;
                    Cancelled = (i == IDYES);
                } else {
                    b = (i == IDYES);
                    Cancelled = b;
                }
                MyFree(p);
            } else {
                pSetupOutOfMemory(hdlg);
                Cancelled = TRUE;
                b = TRUE;
            }

            if(b) {
                if(Cancelled) {
                    Context->Cancelled = TRUE;
                }
                PostMessage(hdlg,WMX_KILLDIALOG,0,0);

                if (Context->PendingUiType != UI_NONE) {

                    //
                    // We now allow the main thread to continue.  Once we do
                    // so, the UI parameters that we passed to us are invalid.
                    // Cancel the pending UI.
                    //
                    Context->PendingUiType = UI_NONE;
                    Context->lParam = Context->CancelReturnCode;
                    SetEvent(Context->hEvent); // wake up main thread (lParam has UI result)
                }

            } else {
                if (Context->PendingUiType != UI_NONE) {
                    Context->lParam = pPerformUi(Context,
                                                 (UINT)Context->PendingUiType,
                                                 Context->PendingUiParameters);

                    Context->PendingUiType = UI_NONE;
                    SetEvent(Context->hEvent); // wake up main thread (lParam has UI result)
                }
            }
            b = TRUE;
        } else {
            b = FALSE;
        }
        break;

    case WMX_KILLDIALOG:
        //
        // Exit unconditionally. Clean up first.
        //
        b = TRUE;
        Context = (PQUEUECONTEXT)GetProp(hdlg, DialogPropName);
        MYASSERT(Context != NULL);
        if(Context->MessageBoxUp) {
            //
            // The user was still interacting with the "are you sure you
            // want to cancel" dialog and the copying finished. So we don't want
            // to nuke the dialog out from under the message box.
            //
            Context->DialogKilled = TRUE;
            break;
        }

        DestroyWindow(Context->ProgressBar);
        EndDialog(hdlg, 0);

        break;

    default:
        //
        // we disable autorun because it confuses the user.
        //
        if (!uQueryCancelAutoPlay) {
            uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
        }

        if (msg == uQueryCancelAutoPlay) {
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 1 );
            return 1;       // cancel auto-play
        }

        b = FALSE;
        break;
    }

    return(b);
}


PVOID
SetupInitDefaultQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    )
{
    PQUEUECONTEXT Context;
    BOOL b;

    Context = MyMalloc(sizeof(QUEUECONTEXT));
    if(Context) {
        ZeroMemory(Context,sizeof(QUEUECONTEXT));

        Context->Signature = QUEUECONTEXT_SIGNATURE;
        Context->hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
        if (Context->hEvent == NULL) {
            MyFree(Context);
            return NULL;
        }
        Context->OwnerWindow = OwnerWindow;
        Context->MainThreadId = GetCurrentThreadId();
        Context->ProgressMsg = ProgressMessage;
        Context->NoToAllMask = 0;

        //
        // If the caller specified NULL for the alternate progress window, and
        // we're running non-interactively, we want to treat this just as if
        // they'd specified INVALID_HANDLE_VALUE (i.e., suppress all progress
        // UI).
        //
        if((GlobalSetupFlags & PSPGF_NONINTERACTIVE) && !AlternateProgressWindow) {
            Context->AlternateProgressWindow = INVALID_HANDLE_VALUE;
        } else {
            Context->AlternateProgressWindow = AlternateProgressWindow;
        }

        if(SystemParametersInfo(SPI_GETSCREENREADER,0,&b,0) && b) {
            Context->ScreenReader = TRUE;
        } else {
            Context->ScreenReader = FALSE;
        }

#ifdef PRERELEASE
        //
        // if we're running in gui-mode setup, we suppress all setupapi progress UI
        // and only allow AlternateProgressWindow UI
        //
        if (GuiSetupInProgress
            && (Context->AlternateProgressWindow != (HWND)INVALID_HANDLE_VALUE)
            && !IsWindow(Context->AlternateProgressWindow)) {
            MYASSERT( FALSE && TEXT("SetupInitDefaultQueueCallbackEx() called in gui-setup without INVALID_HANDLE_VALUE, which means UI may be presented.  Click yes and retrieve the stack trace to detect errant caller.\n"));
        }
#endif

    }

    return(Context);
}


PVOID
SetupInitDefaultQueueCallback(
    IN HWND OwnerWindow
    )
{
#ifdef PRERELEASE
    if (GuiSetupInProgress) {
        MYASSERT( FALSE && TEXT("SetupInitDefaultQueueCallback() called in gui-setup, which means UI may be presented.  Click yes and retrieve the stack trace to detect the errant caller.\n"));
    }
#endif
    return(SetupInitDefaultQueueCallbackEx(OwnerWindow,NULL,0,0,NULL));
}


VOID
SetupTermDefaultQueueCallback(
    IN PVOID Context
    )
{
    PQUEUECONTEXT context;

    context = Context;

    try {
        if(context && context->Signature == QUEUECONTEXT_SIGNATURE) {
            if(context->CurrentSourceName) {
                MyFree(context->CurrentSourceName);
            }
            if (context->hEvent) {
                CloseHandle(context->hEvent);
            }
            context->Signature = 0;
        }
        MyFree(Context);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}


#ifdef UNICODE
//
// ANSI version
//
UINT
SetupDefaultQueueCallbackA(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT u;

    u = pSetupCallDefaultMsgHandler(
            Context,
            Notification,
            Param1,
            Param2
            );

    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupDefaultQueueCallbackW(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Notification);
    UNREFERENCED_PARAMETER(Param1);
    UNREFERENCED_PARAMETER(Param2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(0);
}
#endif

UINT
SetupDefaultQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT rc;
    DWORD err;
    PQUEUECONTEXT context = Context;
    MSG msg;
    VERDLGCONTEXT dialogContext;
    DWORD waitResult;

    //
    // a little sanity check on context
    //
    err = NO_ERROR;
    try {
        if (context == NULL || context->Signature != QUEUECONTEXT_SIGNATURE) {
            err = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        err = ERROR_INVALID_PARAMETER;
    }
    if (err != NO_ERROR) {
        return pGetCallbackErrorReturn(Notification,err);
    }

    switch(Notification) {

    case SPFILENOTIFY_STARTQUEUE:
        rc = pNotificationStartQueue(context);
        break;

    case SPFILENOTIFY_ENDQUEUE:
        //
        // Make sure the progress dialog is dead.
        //
        if(context->AlternateProgressWindow) {
            //
            // If we have an alternate progress window, then we'd better not
            // have our own progress dialog, nor should we have a UI thread
            // handle.
            //
            MYASSERT(!context->ProgressDialog);
            MYASSERT(!context->UiThreadHandle);

        } else {

            if(IsWindow(context->ProgressDialog)) {
                //
                // Post a message to the dialog, instructing it to terminate,
                // then wait for it to confirm.
                //
                PostMessage(context->ProgressDialog, WMX_KILLDIALOG, 0, 0);
            }
            //
            // The dialog may have been marked for delete (thus IsWindow() fails),
            // and yet the dialog has not yet been destroyed.  Therefore, we always
            // want to wait for the thread message that assures us that everything
            // has been cleaned up in the other thread.
            //
            // Also, before returning we need to make sure that the UI thread is
            // really gone, or else there's a hole where our caller could unload
            // the library and then the UI thread would fault.
            // We have seen this happen in stress.
            //
            while (pWaitForUiResponse(context)) /* nothing */;
            if(context->UiThreadHandle) {
                waitResult = WaitForSingleObject(context->UiThreadHandle,INFINITE);
                MYASSERT(waitResult != WAIT_FAILED);
                CloseHandle(context->UiThreadHandle);
            }
        }
        rc = TRUE;  // return value for this notification is actually ignored.
        break;

    case SPFILENOTIFY_STARTSUBQUEUE:
        rc = pNotificationStartEndSubqueue(context,TRUE,Param1,Param2);
        break;

    case SPFILENOTIFY_ENDSUBQUEUE:
        rc = pNotificationStartEndSubqueue(context,FALSE,Param1,0);
        break;

    case SPFILENOTIFY_STARTDELETE:
    case SPFILENOTIFY_STARTRENAME:
    case SPFILENOTIFY_STARTCOPY:
    case SPFILENOTIFY_STARTBACKUP:
        //
        // Update display to indicate the files involved
        // in the operation, unless a screen reader is active.
        //
        if(context->ScreenReader) {
            rc = FILEOP_DOIT;
        } else {
            rc = pNotificationStartOperation(context,(PFILEPATHS)Param1,Param2);
        }
        break;

    case SPFILENOTIFY_ENDDELETE:
    case SPFILENOTIFY_ENDRENAME:
    case SPFILENOTIFY_ENDCOPY:
    case SPFILENOTIFY_ENDBACKUP:
    case SPFILENOTIFY_ENDREGISTRATION:

        if(context->AlternateProgressWindow) {
            //
            // If this is really is an alternate progress window, then 'tick' it.
            // Copy only.
            //
            if((Notification == SPFILENOTIFY_ENDCOPY) &&
               (context->AlternateProgressWindow != INVALID_HANDLE_VALUE)) {

                SendMessage(context->AlternateProgressWindow, context->ProgressMsg, 1, 0);
            }
        } else {
            if(IsWindow(context->ProgressBar)) {
                //
                // Update gas gauge.
                //
                SendMessage(context->ProgressBar,PBM_STEPIT,0,0);
            }
        }
        rc = TRUE;  // return value for these notifications is actually ignored.
        break;

    case SPFILENOTIFY_DELETEERROR:
        rc = pNotificationErrorDelete(context,(PFILEPATHS)Param1);
        break;

    case SPFILENOTIFY_RENAMEERROR:
        rc = pNotificationErrorRename(context,(PFILEPATHS)Param1);
        break;

    case SPFILENOTIFY_BACKUPERROR:
        rc = pNotificationErrorBackup(context,(PFILEPATHS)Param1);
        break;

    case SPFILENOTIFY_COPYERROR:
        rc = pNotificationErrorCopy(context,(PFILEPATHS)Param1,(PTSTR)Param2);
        break;

    case SPFILENOTIFY_NEEDMEDIA:
        //
        // Perform prompt.
        //
        rc = pNotificationNeedMedia(context,(PSOURCE_MEDIA)Param1,(PTSTR)Param2);
        break;

    case SPFILENOTIFY_STARTREGISTRATION:
        rc = pNotificationStartRegistration(context,(PSP_REGISTER_CONTROL_STATUS)Param1,(BOOL)Param2);
        break;

    default:
        //
        // The notification is either an unknown ordinal or a version mismatch.
        //
        if(Notification & (SPFILENOTIFY_LANGMISMATCH | SPFILENOTIFY_TARGETNEWER | SPFILENOTIFY_TARGETEXISTS)) {
            //
            // It's one or more of our known version mismatches.  First
            // check to see whether No to All has already been specified
            // for the mismatch(es).  Turn off the bits in the notification
            // that are set in NoToAllMask; if there are still bits set,
            // we need to notify about this mismatch.  If there are no
            // longer any bits set, then don't copy this file.
            //
            Notification &= ~context->NoToAllMask;
            if (Notification != 0) {
                //
                // Notify about this mismatch.
                //
                dialogContext.QueueContext = context;
                dialogContext.Notification = Notification;
                dialogContext.Param1 = Param1;
                dialogContext.Param2 = Param2;
                rc = PostUiMessage (
                    context, UI_MISMATCHERROR, DPROMPT_CANCEL, &dialogContext);
                rc = (rc == IDYES);
            } else {
                //
                // No To All has already been specified for this notification type.
                // Skip the file.
                //
                rc = 0;
            }

        } else {
            //
            // Unknown notification. Skip the file.
            //
            rc = 0;
        }
        break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\fileq6.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fileq6.c

Abstract:

    Copy list scanning functions.

Author:

    Ted Miller (tedm) 24-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define mask that isolates the action to be performed on the file queue.
//
#define SPQ_ACTION_MASK (SPQ_SCAN_FILE_PRESENCE | SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_USE_CALLBACK | SPQ_SCAN_USE_CALLBACKEX | SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
#define SPQ_SCAN_USE_CALLBACKEX_PRESENCE (SPQ_SCAN_FILE_PRESENCE|SPQ_SCAN_USE_CALLBACKEX)

BOOL
_SetupMarkFileNodeTargetFlags(
    IN  PSP_FILE_QUEUE      FileQueue,
    IN  LONG                RootID,
    IN  LONG                DirID,
    IN  LONG                FileID,
    IN  DWORD               MaskFlags,
    IN  DWORD               Flags,
    OUT PDWORD              PriorFlags
    )
{
    SP_TARGET_ENT TargetInfo;
    LONG TargetID;
    DWORD rc;
    DWORD OldFlags;

    MYASSERT(Flags == (MaskFlags&Flags));

    rc = pSetupBackupGetTargetByPath((HSPFILEQ)FileQueue,
                                     NULL, // use Queue's string table
                                     NULL,
                                     RootID,
                                     DirID,
                                     FileID,
                                     &TargetID,
                                     &TargetInfo
                                    );

    if (rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }
    OldFlags = TargetInfo.InternalFlags;
    TargetInfo.InternalFlags = (TargetInfo.InternalFlags&~MaskFlags)|Flags;

    if(OldFlags != TargetInfo.InternalFlags) {
        rc = pSetupBackupSetTargetByID((HSPFILEQ)FileQueue,
                                       TargetID,
                                       &TargetInfo
                                       );
    }
    if(PriorFlags) {
        *PriorFlags = OldFlags;
    }

    if (rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }
    return TRUE;
}

BOOL
_SetupScanFileQueue(
    IN  HSPFILEQ FileQueue,
    IN  DWORD    Flags,
    IN  HWND     Window,            OPTIONAL
    IN  PVOID    CallbackRoutine,   OPTIONAL
    IN  PVOID    CallbackContext,   OPTIONAL
    OUT PDWORD   Result,
    IN  BOOL     IsNativeCharWidth
    )

/*++

Routine Description:

    Implementation for SetupScanFileQueue, handles ANSI and Unicode
    callback functions.

Arguments:

    Same as SetupScanFileQueue().

    IsNativeCharWidth - supplies flag indicating whether callback routine is
        expecting unicode params. Meaningful only in UNICODE version of DLL.

Return Value:

    Same as SetupScanFileQueue().

--*/

{
    DWORD Action;
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode, TempNode, NextNode;
    PSP_FILE_QUEUE_NODE CheckNode;
    PSOURCE_MEDIA_INFO SourceMedia;
    BOOL Continue;
    TCHAR TargetPath[MAX_PATH];
    BOOL Err;
    int i;
    PTSTR Message;
    DWORD flags;
    DWORD Win32Error;
    SetupapiVerifyProblem Problem;
    TCHAR TempCharBuffer[MAX_PATH];
    TCHAR SourcePath[MAX_PATH];
    TCHAR DigitalSigner[MAX_PATH];
    TCHAR SignerVersion[MAX_PATH];
    TCHAR CatalogFile[MAX_PATH];
    DWORD rc;
    UINT Notification;
    UINT_PTR CallbackParam1;
    FILEPATHS FilePaths;
    FILEPATHS_SIGNERINFO FilePathsSignerInfo;
    BOOL DoPruning, PruneNode;
    PSPQ_CATALOG_INFO CatalogNode;
    PSETUP_LOG_CONTEXT lc = NULL;
    DWORD slot_fileop = 0;
    HANDLE hWVTStateData;
    PCRYPT_PROVIDER_DATA ProviderData;
    PCRYPT_PROVIDER_SGNR ProviderSigner;
    PCRYPT_PROVIDER_CERT ProviderCert;

    Queue = (PSP_FILE_QUEUE)FileQueue;

    rc = NO_ERROR;
    try {
        if (Queue->Signature != SP_FILE_QUEUE_SIG) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
       rc = ERROR_INVALID_HANDLE;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    lc = Queue->LogContext;

    //
    // Validate arguments. Exactly one action flag must be specified.
    //
    if(Result) {
        *Result = 0;
    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    Action = (Flags & SPQ_ACTION_MASK);
    switch(Action) {
        case SPQ_SCAN_FILE_PRESENCE:
        case SPQ_SCAN_FILE_VALIDITY:
            break;
        case SPQ_SCAN_USE_CALLBACK:
        case SPQ_SCAN_USE_CALLBACKEX:
        case SPQ_SCAN_USE_CALLBACKEX_PRESENCE:
        case SPQ_SCAN_USE_CALLBACK_SIGNERINFO:
            if(CallbackRoutine) {
                break;
            }
            // else fall through to invalid arg case
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
    }

    DoPruning = Flags & SPQ_SCAN_PRUNE_COPY_QUEUE;
    if(DoPruning) {
        if(Queue->Flags & FQF_QUEUE_ALREADY_COMMITTED) {
            //
            // If we've been asked to prune the copy queue, then make sure the queue
            // hasn't been committed yet.
            //
            SetLastError(ERROR_NO_MORE_ITEMS);
            return FALSE;
        }

        if((Action == SPQ_SCAN_USE_CALLBACK)
           || (Action == SPQ_SCAN_USE_CALLBACKEX)
           || (Action == SPQ_SCAN_USE_CALLBACKEX_PRESENCE)
           || (Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
           || (Flags & SPQ_SCAN_INFORM_USER)) {
            //
            // Presently, pruning the queue is not supported when using a callback.
            // Also, SPQ_SCAN_INFORM_USER and SPQ_SCAN_PRUNE_COPY_QUEUE don't play well
            // together...
            //
            SetLastError(ERROR_INVALID_FLAGS);
            return FALSE;
        }
    }

    //
    // If the caller asked for UI, make sure we're running interactively.
    //
    if((Flags & SPQ_SCAN_INFORM_USER) && (GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP))) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return FALSE;
    }

    //
    // If we're verifying the digital signatures of the files, then first make
    // sure that we've processed the catalog nodes for this queue.  However, we
    // don't want any copying to take place if there are OEM INFs in the list.
    //
    if((Action == SPQ_SCAN_FILE_VALIDITY) ||
       (Action == SPQ_SCAN_USE_CALLBACKEX) ||
       (Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)) {

        WriteLogEntry(
            lc,
            SETUP_LOG_TIME,
            MSG_LOG_BEGIN_VERIFY4_CAT_TIME,
            NULL);       // text message

        rc = _SetupVerifyQueuedCatalogs(Window,
                                        Queue,
                                        VERCAT_NO_PROMPT_ON_ERROR,
                                        NULL,
                                        NULL
                                       );

        WriteLogEntry(
            lc,
            SETUP_LOG_TIME,
            MSG_LOG_END_VERIFY4_CAT_TIME,
            NULL);       // text message

        if((Action == SPQ_SCAN_FILE_VALIDITY) && (rc != NO_ERROR)) {
            WriteLogEntry(
                lc,
                (rc == ERROR_CANNOT_COPY ? SETUP_LOG_VVERBOSE : SETUP_LOG_WARNING) | SETUP_LOG_BUFFER,
                MSG_LOG_SCANQUEUE_VERIFY_FAILED,
                NULL);
            WriteLogError(
                lc,
                (rc == ERROR_CANNOT_COPY ? SETUP_LOG_VVERBOSE : SETUP_LOG_WARNING),
                rc);

            //
            // Result output param has already been initialized to zero
            // above.
            //
            return TRUE;
        }
    } else {
        rc = NO_ERROR;
    }

    //
    // Regardless of whether or not the catalog validation succeeded
    // above, we still want to call the callback for each file.  The
    // failed catalog verifications will be reflected in the failed
    // file verifications that the caller gets informed of via the
    // Win32Error field of the FILEPATHS struct we give the callback.
    //
    // Initialize the static fields of that structure here so we don't
    // have to each pass through the loop below.
    //
    FilePaths.Target = TargetPath;
    FilePaths.Source = SourcePath;
    FilePathsSignerInfo.Target = TargetPath;
    FilePathsSignerInfo.Source = SourcePath;


    //
    // markup delete/rename usage
    // we don't need to do this if we have SPQ_SCAN_PRUNE_DELREN set
    //
    if(!(Flags & SPQ_SCAN_PRUNE_DELREN)) {
        for(TempNode=Queue->DeleteQueue; TempNode; TempNode=TempNode->Next) {
            if(!_SetupMarkFileNodeTargetFlags(Queue,
                                              TempNode->TargetDirectory,
                                              -1,
                                              TempNode->TargetFilename,
                                              SP_TEFLG_PRUNE_DEL,SP_TEFLG_PRUNE_DEL,
                                              NULL)) {
                //
                // this would indicate an out-of-memory condition
                // last error is set
                //
                return FALSE;
            }
        }
        for(TempNode=Queue->RenameQueue; TempNode; TempNode=TempNode->Next) {
            if(!_SetupMarkFileNodeTargetFlags(Queue,
                                              TempNode->SourcePath,
                                              -1,
                                              TempNode->SourceFilename,
                                              SP_TEFLG_PRUNE_RENSRC,SP_TEFLG_PRUNE_RENSRC,
                                              NULL)) {
                //
                // this would indicate an out-of-memory condition
                // last error is set
                //
                return FALSE;
            }
            if(!_SetupMarkFileNodeTargetFlags(Queue,
                                              TempNode->TargetDirectory == -1 ? TempNode->SourcePath : TempNode->TargetDirectory,
                                              -1,
                                              TempNode->TargetFilename,
                                              SP_TEFLG_PRUNE_RENTARG,SP_TEFLG_PRUNE_RENTARG,
                                              NULL)) {
                //
                // this would indicate an out-of-memory condition
                // last error is set
                //
                return FALSE;
            }
        }
    }

    //
    // Process all nodes in the copy queue.
    //
    Err = FALSE;
    Continue = TRUE;
    for(SourceMedia=Queue->SourceMediaList; Continue && SourceMedia; SourceMedia=SourceMedia->Next) {

        TempNode = NULL;
        QueueNode = SourceMedia->CopyQueue;

        while(Continue && QueueNode) {
            DWORD PrevNodeFlags;
            //
            // markup copy usage
            //
            if(!_SetupMarkFileNodeTargetFlags(Queue,
                                              QueueNode->TargetDirectory,
                                              -1,
                                              QueueNode->TargetFilename,
                                              SP_TEFLG_PRUNE_COPY,SP_TEFLG_PRUNE_COPY,
                                              &PrevNodeFlags)) {
                //
                // this would indicate an out-of-memory condition
                // last error is set
                //
                rc = GetLastError();
                Err = TRUE;
                Continue = FALSE;
                break;
            }

            //
            // Form target path.
            //
            lstrcpyn(
                TargetPath,
                pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetDirectory),
                MAX_PATH
                );

            pSetupConcatenatePaths(
                TargetPath,
                pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetFilename),
                MAX_PATH,
                NULL
                );


            if((PrevNodeFlags & (SP_TEFLG_PRUNE_DEL|SP_TEFLG_PRUNE_RENSRC|SP_TEFLG_PRUNE_RENTARG))
               && !((Flags & SPQ_SCAN_PRUNE_DELREN) || (QueueNode->StyleFlags & SP_COPY_NOPRUNE))) {
                DWORD msg;
                //
                // this file is touched in source/target
                // but the INF author forgot to mark it as SP_COPY_NOPRUNE
                // this typically indicates a mistake on the author's part
                // so we try and handle it best as we can
                // if SPQ_SCAN_PRUNE_DELREN is set, we'll kill the delete/rename entries
                // if it's not set, we enforce the SP_COPY_NOPRUNE
                //
                QueueNode->StyleFlags |= SP_COPY_NOPRUNE;

                if(PrevNodeFlags & SP_TEFLG_PRUNE_DEL) {
                    msg = MSG_LOG_CHANGEPRUNE_DEL;
                } else if(PrevNodeFlags & SP_TEFLG_PRUNE_RENSRC) {
                    msg = MSG_LOG_CHANGEPRUNE_RENSRC;
                } else {
                    msg = MSG_LOG_CHANGEPRUNE_RENTARG;
                }

                WriteLogEntry(
                    lc,
                    SETUP_LOG_WARNING,
                    msg,
                    NULL,
                    TargetPath);
            }

            //
            // Perform check on file.
            //
            PruneNode = FALSE;
            switch(Action) {

            case SPQ_SCAN_FILE_PRESENCE:

                Continue = FileExists(TargetPath,NULL);
                if(DoPruning) {
                    //
                    // File's presence should result in this copy node's removal
                    // from the queue--it's absence should be ignored.
                    //
                    if(Continue) {
                        PruneNode = TRUE;
                    } else {
                        //
                        // Leave copy node alone.
                        //
                        PruneNode = FALSE;
                        Continue = TRUE;
                    }
                } else {
                    if (Continue) {
                        //
                        // we should not continue if the copy node is marked as a "no prune" node
                        //
                        if (QueueNode->StyleFlags & SP_COPY_NOPRUNE) {
                            Continue = FALSE;
                        }
                    }
                }
                break;

            case SPQ_SCAN_FILE_VALIDITY:

                //
                // If we are going to prune the copy queue then:
                //
                // (a) only validate the file against the system catalogs (not
                //     against any OEM catalogs), and
                // (b) don't validate self-signed files.
                //
                // (Note: we will never consider an INF in %windir%\Inf to be
                // signed, since it is invalid to copy an INF there via a file
                // queue.  SetupCopyOEMInf must be used instead.)
                //
                if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
                    //
                    // If we're pruning, then we don't want to consider any
                    // existing files as valid, otherwise we'd never copy
                    // anything!
                    //
                    Continue = !DoPruning;

                    //
                    // We want to prune the queue node if the target exists and 
                    // the source doesn't
                    //
                    if(DoPruning && FileExists(TargetPath, NULL)) {
                        //
                        // The target exists!  Now build the path the source 
                        // file...
                        //
                        lstrcpyn(SourcePath,
                                 pSetupStringTableStringFromId(Queue->StringTable, 
                                                               QueueNode->SourceRootPath),
                                 SIZECHARS(SourcePath)
                                );

                        if(QueueNode->SourcePath != -1) {
                            pSetupConcatenatePaths(SourcePath,
                                                   pSetupStringTableStringFromId(
                                                       Queue->StringTable, 
                                                       QueueNode->SourcePath),
                                                   SIZECHARS(SourcePath),
                                                   NULL
                                                  );
                        }

                        pSetupConcatenatePaths(SourcePath,
                                               pSetupStringTableStringFromId(
                                                   Queue->StringTable, 
                                                   QueueNode->SourceFilename),
                                               SIZECHARS(SourcePath),
                                               NULL
                                              );

                        //
                        // If there's no source file to copy, prune this node
                        //
                        Continue = !FileExists(SourcePath, NULL);
                    }

                } else {

                    if(QueueNode->CatalogInfo &&
                       ((QueueNode->CatalogInfo->Flags & CATINFO_FLAG_AUTHENTICODE_SIGNED) ||
                        (QueueNode->CatalogInfo->Flags & CATINFO_FLAG_PROMPT_FOR_TRUST))) {
                        //
                        // Validate using Authenticode policy.  At this point,
                        // we've already established that the user trusts the
                        // publisher.
                        //
                        Win32Error = VerifySourceFile(lc,
                                                      Queue,
                                                      QueueNode,
                                                      pSetupGetFileTitle(TargetPath),
                                                      TargetPath,
                                                      NULL,
                                                      ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                                          ? &(Queue->AltPlatformInfo)
                                                          : Queue->ValidationPlatform),
                                                      (VERIFY_FILE_IGNORE_SELFSIGNED
                                                       | VERIFY_FILE_USE_AUTHENTICODE_CATALOG),
                                                      &Problem,
                                                      TempCharBuffer,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      NULL
                                                     );

                        if((Win32Error == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                           (Win32Error == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {

                            Continue = TRUE;

                        } else {
                            Continue = FALSE;
                        }

                    } else {
                        //
                        // Validate using normal driver signing policy.
                        //
                        Continue = (NO_ERROR == VerifySourceFile(lc,
                                                                 Queue,
                                                                 QueueNode,
                                                                 pSetupGetFileTitle(TargetPath),
                                                                 TargetPath,
                                                                 NULL,
                                                                 ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                                                     ? &(Queue->AltPlatformInfo)
                                                                     : Queue->ValidationPlatform),
                                                                 (DoPruning ? VERIFY_FILE_IGNORE_SELFSIGNED 
                                                                            : 0),
                                                                 &Problem,
                                                                 TempCharBuffer,
                                                                 NULL,
                                                                 NULL,
                                                                 NULL,
                                                                 NULL
                                                                ));
                    }
                }

                if(DoPruning) {
                    //
                    // File's validity should result in this copy node's removal
                    // from the queue--it's invalidity should be ignored.
                    //
                    if(Continue) {
                        PruneNode = TRUE;
                    } else {
                        //
                        // Leave copy node alone.
                        //
                        PruneNode = FALSE;
                        Continue = TRUE;
                    }
                } else {
                    if (Continue) {
                        //
                        // we should not continue if the copy node is marked as a "no prune" node
                        //
                        if (QueueNode->StyleFlags & SP_COPY_NOPRUNE) {
                            Continue = FALSE;
                        }
                    }
                }
                break;

            case SPQ_SCAN_USE_CALLBACK:
            case SPQ_SCAN_USE_CALLBACKEX:
            case SPQ_SCAN_USE_CALLBACKEX_PRESENCE:
            case SPQ_SCAN_USE_CALLBACK_SIGNERINFO:

                flags = (QueueNode->InternalFlags & (INUSE_INF_WANTS_REBOOT | INUSE_IN_USE))
                      ? SPQ_DELAYED_COPY
                      : 0;

                if((Action == SPQ_SCAN_USE_CALLBACKEX) ||
                   (Action == SPQ_SCAN_USE_CALLBACKEX_PRESENCE) ||
                   (Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)) {

                    //
                    // The caller requested the extended version of the queue
                    // scan callback--we need to build the source file path.
                    //
                    lstrcpyn(SourcePath,
                             pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourceRootPath),
                             SIZECHARS(SourcePath)
                            );

                    if(QueueNode->SourcePath != -1) {

                        pSetupConcatenatePaths(SourcePath,
                                         pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourcePath),
                                         SIZECHARS(SourcePath),
                                         NULL
                                        );
                    }

                    pSetupConcatenatePaths(SourcePath,
                                     pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourceFilename),
                                     SIZECHARS(SourcePath),
                                     NULL
                                    );

                    if((Action == SPQ_SCAN_USE_CALLBACKEX_PRESENCE)) {
                        Win32Error = NO_ERROR;
                    } else {

                        CatalogFile[0] = TEXT('\0');
                        DigitalSigner[0] = TEXT('\0');
                        SignerVersion[0] = TEXT('\0');

                        if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
                            //
                            // We can't call our internal VerifySourceFile
                            // routine, because it doesn't expect to be asked
                            // for signer info when in "minimal embedded" mode
                            // (plus, it doesn't make sense to ask for such
                            // info anyway, since we have no idea who signed
                            // the file, or even if it was signed).
                            //
                            Win32Error = NO_ERROR;

                        } else {

                            if(QueueNode->CatalogInfo &&
                               ((QueueNode->CatalogInfo->Flags & CATINFO_FLAG_AUTHENTICODE_SIGNED) ||
                                (QueueNode->CatalogInfo->Flags & CATINFO_FLAG_PROMPT_FOR_TRUST))) {

                                Win32Error = VerifySourceFile(
                                                 lc,
                                                 Queue,
                                                 QueueNode,
                                                 pSetupGetFileTitle(TargetPath),
                                                 TargetPath,
                                                 NULL,
                                                 ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                                       ? &(Queue->AltPlatformInfo)
                                                       : Queue->ValidationPlatform),
                                                 VERIFY_FILE_USE_AUTHENTICODE_CATALOG,
                                                 &Problem,
                                                 TempCharBuffer,
                                                 ((Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
                                                     ? CatalogFile
                                                     : NULL),
                                                 NULL,
                                                 NULL,
                                                 &hWVTStateData
                                                 );

                                if((Win32Error == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                                   (Win32Error == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                                    
                                    ProviderData = WTHelperProvDataFromStateData(hWVTStateData);
                                    MYASSERT(ProviderData);
                                    if (ProviderData) {
                                        ProviderSigner = WTHelperGetProvSignerFromChain(ProviderData,
                                                                                        0,
                                                                                        FALSE,
                                                                                        0);
                                        MYASSERT(ProviderSigner);
                                        if (ProviderSigner) {
                                            ProviderCert = WTHelperGetProvCertFromChain(ProviderSigner, 
                                                                                        0);
                                            MYASSERT(ProviderCert);
                                            if (ProviderCert) {
                                                //
                                                // Get the publisher and add this
                                                // as the DigitalSigner.
                                                //
                                                CertGetNameString(ProviderCert->pCert,
                                                                  CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                                                  0,
                                                                  NULL,
                                                                  DigitalSigner,
                                                                  SIZECHARS(DigitalSigner));
                                            }
                                        }
                                    }

                                    MYASSERT(hWVTStateData);
                                    pSetupCloseWVTStateData(hWVTStateData);
                                    hWVTStateData = NULL;
                                }

                            } else {
                                //
                                // Validate using normal driver signing policy.
                                //
                                Win32Error = VerifySourceFile(
                                                 lc,
                                                 Queue,
                                                 QueueNode,
                                                 pSetupGetFileTitle(TargetPath),
                                                 TargetPath,
                                                 NULL,
                                                 ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                                       ? &(Queue->AltPlatformInfo)
                                                       : Queue->ValidationPlatform),
                                                 0,
                                                 &Problem,
                                                 TempCharBuffer,
                                                 ((Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
                                                     ? CatalogFile
                                                     : NULL),
                                                 ((Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
                                                     ? DigitalSigner
                                                     : NULL),
                                                 ((Action == SPQ_SCAN_USE_CALLBACK_SIGNERINFO)
                                                     ? SignerVersion
                                                     : NULL),
                                                 NULL
                                                 );
                            }
                        }
                    }

                    if ((Action == SPQ_SCAN_USE_CALLBACKEX) ||
                        (Action == SPQ_SCAN_USE_CALLBACKEX_PRESENCE)) {
                        FilePaths.Win32Error = Win32Error;
                        FilePaths.Flags  = QueueNode->StyleFlags;
                        CallbackParam1 = (UINT_PTR)(&FilePaths);
                        Notification = SPFILENOTIFY_QUEUESCAN_EX;
                    } else {
                        FilePathsSignerInfo.Win32Error = Win32Error;
                        FilePathsSignerInfo.Flags  = QueueNode->StyleFlags;
                        FilePathsSignerInfo.DigitalSigner = (DigitalSigner[0] != TEXT('\0'))
                                                                ? DigitalSigner
                                                                : NULL;
                        FilePathsSignerInfo.Version = (SignerVersion[0] != TEXT('\0'))
                                                                ? SignerVersion
                                                                : NULL;
                        FilePathsSignerInfo.CatalogFile = (CatalogFile[0] != TEXT('\0'))
                                                                ? CatalogFile
                                                                : NULL;
                        CallbackParam1 = (UINT_PTR)(&FilePathsSignerInfo);
                        Notification = SPFILENOTIFY_QUEUESCAN_SIGNERINFO;
                    }
                } else {
                    CallbackParam1 = (UINT_PTR)TargetPath;
                    Notification = SPFILENOTIFY_QUEUESCAN;
                }

                rc = (DWORD)pSetupCallMsgHandler(
                                    lc,
                                    CallbackRoutine,
                                    IsNativeCharWidth,
                                    CallbackContext,
                                    Notification,
                                    CallbackParam1,
                                    flags
                                    );
                *Result = rc;
                Err = (rc != NO_ERROR);
                Continue = !Err;
                break;
            }

            if(DoPruning && PruneNode) {
                BOOL ReallyPrune = TRUE;
                MYASSERT(Continue == TRUE);

                //
                // before we remove the item from the queue, we must check if the copy item
                // also exists in the rename or delete queues.  if it does, then we cannot
                // prune the item from the copy queue
                //
                if (QueueNode->StyleFlags & SP_COPY_NOPRUNE) {
                    ReallyPrune = FALSE;
                    TempNode = QueueNode;
                    QueueNode = QueueNode->Next;
                }

                if (ReallyPrune) {

                    WriteLogEntry(
                        lc,
                        SETUP_LOG_VERBOSE,
                        MSG_LOG_PRUNE,
                        NULL,
                        TargetPath);

                    NextNode = QueueNode->Next;
                    if(TempNode) {
                        TempNode->Next = NextNode;
                    } else {
                        SourceMedia->CopyQueue = NextNode;
                    }
                    MyFree(QueueNode);
                    QueueNode = NextNode;

                    //
                    // Adjust the queue node counts.
                    //
                    Queue->CopyNodeCount--;
                    SourceMedia->CopyNodeCount--;
                }


            } else {
                TempNode = QueueNode;
                QueueNode = QueueNode->Next;
            }
        }
    }

    if(Flags & SPQ_SCAN_PRUNE_DELREN) {
        //
        // flag tells us to rip out of Delete/Rename queues
        // files that are (or was) in the copy queue.
        // we'll only be asked to do this in limited cases
        // (eg, GUI setup)
        //
        TempNode = NULL;
        QueueNode = Queue->DeleteQueue;
        while(QueueNode) {
            DWORD PrevFlags;
            NextNode = QueueNode->Next;

            if(_SetupMarkFileNodeTargetFlags(Queue,
                                              QueueNode->TargetDirectory,
                                              -1,
                                              QueueNode->TargetFilename,
                                              0,0,
                                              &PrevFlags)) {
                if(PrevFlags & SP_TEFLG_PRUNE_COPY) {
                    //
                    // warn about this
                    //
                    lstrcpyn(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetDirectory),
                        MAX_PATH
                        );
                    pSetupConcatenatePaths(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetFilename),
                        MAX_PATH,
                        NULL
                        );
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_WARNING,
                        MSG_LOG_PRUNE_DEL,
                        NULL,
                        TargetPath);

                    if(TempNode) {
                        TempNode->Next = NextNode;
                    } else {
                        Queue->DeleteQueue = NextNode;
                    }
                    MyFree(QueueNode);
                    Queue->DeleteNodeCount--;
                    QueueNode = NextNode;
                    continue;
                }
            }
            TempNode = QueueNode;
            QueueNode = NextNode;
        }
        TempNode = NULL;
        QueueNode = Queue->RenameQueue;
        while(QueueNode) {
            DWORD PrevFlags;
            NextNode = QueueNode->Next;

            if(_SetupMarkFileNodeTargetFlags(Queue,
                                              QueueNode->SourcePath,
                                              -1,
                                              QueueNode->SourceFilename,
                                              0,0,
                                              &PrevFlags)) {
                if(PrevFlags & SP_TEFLG_PRUNE_COPY) {
                    //
                    // warn about this
                    //
                    lstrcpyn(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourcePath),
                        MAX_PATH
                        );
                    pSetupConcatenatePaths(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourceFilename),
                        MAX_PATH,
                        NULL
                        );
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_WARNING,
                        MSG_LOG_PRUNE_RENSRC,
                        NULL,
                        TargetPath);

                    if(TempNode) {
                        TempNode->Next = NextNode;
                    } else {
                        Queue->RenameQueue = NextNode;
                    }
                    MyFree(QueueNode);
                    Queue->RenameNodeCount--;
                    QueueNode = NextNode;
                    continue;
                }
            }
            if(_SetupMarkFileNodeTargetFlags(Queue,
                                              QueueNode->TargetDirectory == -1 ? QueueNode->SourcePath : QueueNode->TargetDirectory,
                                              -1,
                                              QueueNode->TargetFilename,
                                              0,0,
                                              &PrevFlags)) {
                if(PrevFlags & SP_TEFLG_PRUNE_COPY) {
                    //
                    // warn about this
                    //
                    lstrcpyn(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetDirectory == -1 ? QueueNode->SourcePath : QueueNode->TargetDirectory),
                        MAX_PATH
                        );
                    pSetupConcatenatePaths(
                        TargetPath,
                        pSetupStringTableStringFromId(Queue->StringTable,QueueNode->TargetFilename),
                        MAX_PATH,
                        NULL
                        );
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_WARNING,
                        MSG_LOG_PRUNE_RENTARG,
                        NULL,
                        TargetPath);

                    if(TempNode) {
                        TempNode->Next = NextNode;
                    } else {
                        Queue->RenameQueue = NextNode;
                    }
                    MyFree(QueueNode);
                    Queue->RenameNodeCount--;
                    QueueNode = NextNode;
                    continue;
                }
            }
            TempNode = QueueNode;
            QueueNode = NextNode;
        }
    }
    //
    // If the case of SPQ_SCAN_USE_CALLBACK(EX), *Result is already set up
    // when we get here. If Continue is TRUE then we visited all nodes
    // and the presence/validity check passed on all of them. Note that
    // if Continue is TRUE then Err must be FALSE.
    //
    if((Action == SPQ_SCAN_FILE_PRESENCE) || (Action == SPQ_SCAN_FILE_VALIDITY)) {

        if(DoPruning) {
            //
            // Set result based on whether any of the queues have nodes in them.
            //
            if(Queue->CopyNodeCount) {
                *Result = 0;
            } else {
                *Result = (Queue->DeleteNodeCount || Queue->RenameNodeCount || Queue->BackupNodeCount) ? 2 : 1;
            }
        } else {
            //
            // If we weren't doing pruning, then we know that the Continue
            // variable indicates whether or not we bailed partway through.
            //
            if(Continue) {
                //
                // Need to set up Result.
                //
                if((Flags & SPQ_SCAN_INFORM_USER) && Queue->CopyNodeCount
                && (Message = RetreiveAndFormatMessage(MSG_NO_NEED_TO_COPY))) {

                    //
                    // Overload TargetPath for use as the caption string.
                    //
                    GetWindowText(Window,TargetPath,sizeof(TargetPath)/sizeof(TargetPath[0]));

                    i = MessageBox(
                            Window,
                            Message,
                            TargetPath,
                            MB_APPLMODAL | MB_YESNO | MB_ICONINFORMATION
                            );

                    MyFree(Message);

                    if(i == IDYES) {
                        //
                        // User wants to skip copying.
                        //
                        *Result = (Queue->DeleteNodeCount || Queue->RenameNodeCount || Queue->BackupNodeCount) ? 2 : 1;
                    } else {
                        //
                        // User wants to perform copy.
                        //
                        *Result = 0;
                    }
                } else {
                    //
                    // Don't want to ask user. Set up Result based on whether
                    // there are items in the delete, rename or backup queues.
                    //
                    *Result = (Queue->DeleteNodeCount || Queue->RenameNodeCount || Queue->BackupNodeCount) ? 2 : 1;
                }
            } else {
                //
                // Presence/validity check failed.
                //
                *Result = 0;
            }

            //
            // Empty the copy queue if necessary.
            //
            if(*Result) {
                for(SourceMedia=Queue->SourceMediaList; Continue && SourceMedia; SourceMedia=SourceMedia->Next) {
                    for(QueueNode=SourceMedia->CopyQueue; QueueNode; QueueNode=TempNode) {
                        TempNode = QueueNode->Next;
                        MyFree(QueueNode);
                    }
                    Queue->CopyNodeCount -= SourceMedia->CopyNodeCount;
                    SourceMedia->CopyQueue = NULL;
                    SourceMedia->CopyNodeCount = 0;
                }
                //
                // We think we just removed all files in all copy queues.
                // The 2 counts we maintain should be in sync -- meaning that
                // the total copy node count should now be 0.
                //
                MYASSERT(Queue->CopyNodeCount == 0);
            }
        }
    }

    SetLastError(rc);
    return(!Err);
}

#ifdef UNICODE
//
// ANSI version for UNICODE
//
BOOL
SetupScanFileQueueA(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               Flags,
    IN  HWND                Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK_A CallbackRoutine,   OPTIONAL
    IN  PVOID               CallbackContext,   OPTIONAL
    OUT PDWORD              Result
    )
{
    BOOL b;

    try {
        b = _SetupScanFileQueue(
                FileQueue,
                Flags,
                Window,
                CallbackRoutine,
                CallbackContext,
                Result,
                FALSE
                );
    } except(EXCEPTION_EXECUTE_HANDLER) {
       b = FALSE;
       SetLastError(ERROR_INVALID_DATA);
    }

    return(b);
}

#else
//
// UNICODE version for Win9x
//
BOOL
SetupScanFileQueueW(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               Flags,
    IN  HWND                Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK_W CallbackRoutine,   OPTIONAL
    IN  PVOID               CallbackContext,   OPTIONAL
    OUT PDWORD              Result
    )
{
    UNREFERENCED_PARAMETER(FileQueue);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(Window);
    UNREFERENCED_PARAMETER(CallbackRoutine);
    UNREFERENCED_PARAMETER(CallbackContext);
    UNREFERENCED_PARAMETER(Result);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

#endif


BOOL
SetupScanFileQueue(
    IN  HSPFILEQ          FileQueue,
    IN  DWORD             Flags,
    IN  HWND              Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK CallbackRoutine,   OPTIONAL
    IN  PVOID             CallbackContext,   OPTIONAL
    OUT PDWORD            Result
    )

/*++

Routine Description:

    This routine scans a setup file queue, performing an operation on each
    node in its copy list. The operation is specified by a set of flags.

    A caller can use this API to determine whether all files that have been
    enqueued for copy already exist on the target, and if so, to inform the
    user, who may elect to skip the file copying. This can spare the user from
    having to furnish Setup media in many cases.

Arguments:

    FileQueue - supplies handle to Setup file queue whose copy list is to
        be scanned/iterated.

    Flags - supplies a set of values that control operation of the API. A
        combination of the following values:

        SPQ_SCAN_FILE_PRESENCE - determine whether all target files in the
            copy queue are already present on the target.

        SPQ_SCAN_FILE_VALIDITY - determine whether all target files in the
            copy queue are already present on the target, and verify their
            digital signatures.

        SPQ_SCAN_USE_CALLBACK - for each node in the queue, call the
            callback routine with SPFILENOTIFY_QUEUESCAN.  If the callback
            routine returns non-0 then queue processing is stopped and this
            routine returns FALSE immediately.

        SPQ_SCAN_USE_CALLBACKEX - same as SPQ_SCAN_USE_CALLBACK except that
            SPFILENOTIFY_QUEUESCAN_EX is used instead.  This supplies a pointer
            to a FILEPATHS structure in Param1, thus you get both source and
            destination info.  You also get the results of the file presence
            check (and if present, of its digital signature verification) in
            the Win32Error field, and the CopyStyle flags in effect for that
            copy queue node in the Flags field.

        SPQ_SCAN_USE_CALLBACK_SIGNERINFO - same as SPQ_SCAN_USE_CALLBACK except
            that SPFILENOTIFY_QUEUESCAN_SIGNERINFO is used instead.  This
            supplies a pointer to a FILEPATHS_SIGNERINFO structure in Param1,
            thus you get both source and destination info.  You also get the
            results of the file presence check (and if present, of its digital
            signature verification) in the Win32Error field, and the CopyStyle
            flags in effect for that copy queue node in the Flags field. In
            addition you get who digitaly signed the file in the DigitalSigner
            field and the SHA1 key in the SignerId field.

        Exactly one of SPQ_SCAN_FILE_PRESENCE, SPQ_SCAN_FILE_VALIDITY,
        SPQ_SCAN_USE_CALLBACK, SPQ_SCAN_USE_CALLBACKEX, or
        SPQ_SCAN_USE_CALLBACK_SIGNERINFO must be specified.

        SPQ_SCAN_INFORM_USER - if specified and all files in the queue
            pass the presence/validity check, then this routine will inform
            the user that the operation he is attempting requires files but
            that we believe all files are already present. Ignored if
            SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY is not specified.
            Not valid if specified in combination with SPQ_SCAN_PRUNE_COPY_QUEUE.

        SPQ_SCAN_PRUNE_COPY_QUEUE - if specified, the copy queue will be pruned
            of any nodes that are deemed unnecessary.  This determination is
            made based on the type of queue scan being performed:

            If SPQ_SCAN_FILE_PRESENCE, then the presence of a file having the
            destination filename is sufficient to consider this copy operation
            unnecessary.

            If SPQ_SCAN_FILE_VALIDITY, then the destination file must not only
            be present, but also valid in order for the copy operation to be
            considered unnecessary.

            If SPQ_SCAN_USE_CALLBACK, SPQ_SCAN_USE_CALLBACKEX or
            SPQ_SCAN_USE_CALLBACK_SIGNERINFO, then the queue callback routine
            should return zero to mark the copy node as unnecessary, or non-zero
            to leave the node in the copy queue.

            NOTE: This flag may only be specified _before_ the queue has been
            committed.  This means that the flags contained in Param2 will
            always be zero.  If SetupScanFileQueue is called with
            SPQ_SCAN_PRUNE_COPY_QUEUE after committing the queue, the API will
            fail and GetLastError() will return
            ERROR_NO_MORE_ITEMS.

            This flag is not valid if specified in combination with
            SPQ_SCAN_INFORM_USER.

    Window - specifies the window to own any dialogs, etc, that may be
        presented. Unused if Flags does not contain one of
        SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY, or if Flags does not
        contain SPQ_SCAN_INFORM_USER.

    CallbackRoutine - required if Flags includes SPQ_SCAN_USE_CALLBACK.
        Specifies a callback function to be called on each node in
        the copy queue. The notification code passed to the callback is
        SPFILENOTIFY_QUEUESCAN.

    CallbackContext - caller-defined data to be passed to CallbackRoutine.

    Result - receives result of routine. See below.

Return Value:

    If FALSE, then an error occurred or the callback function returned non-0.
    Check Result -- if it is non-0, then it is the value returned by
    the callback function which stopped queue processing.
    If Result is 0, then extended error information is available from
    GetLastError().

    If TRUE, then all nodes were processed. Result is 0 if a callback was
    specified. If SPQ_SCAN_USE_CALLBACK(EX) or SPQ_SCAN_USE_CALLBACK_SIGNERINFO
    was not specified, then Result indicates whether the queue passed the
    presence/validity check:

        Result = 0: queue failed the check, or the queue passed the
        check but SPQ_SCAN_INFORM_USER was specified and the user indicated
        that he wants new copies of the files.  There are still nodes in the
        copy queue, although if SPQ_SCAN_PRUNE_COPY_QUEUE is specified, then
        any nodes that were validated have been pruned.

        Result = 1: queue passed the check, and, if SPQ_SCAN_INFORM_USER was
        specified, the user indicated that no copying is required. If Result is
        1, the copy queue has been emptied, and there are no elements on the
        delete or rename queues, so the caller may skip queue commit.

        Result = 2: queue passed the check, and, if SPQ_SCAN_INFORM_USER was
        specified, the user indicated that no copying is required. In this case,
        the copy queue has been emptied, however there are elements on the
        delete or rename queues, so the caller may not skip queue commit.

--*/

{
    BOOL b;

    try {
        b = _SetupScanFileQueue(
                FileQueue,
                Flags,
                Window,
                CallbackRoutine,
                CallbackContext,
                Result,
                TRUE
                );
    } except(EXCEPTION_EXECUTE_HANDLER) {
       b = FALSE;
       SetLastError(ERROR_INVALID_DATA);
    }

    return(b);
}


INT
SetupPromptReboot(
    IN HSPFILEQ FileQueue,  OPTIONAL
    IN HWND     Owner,
    IN BOOL     ScanOnly
    )

/*++

Routine Description:

    This routine asks the user whether he wants to reboot the system,
    optionally dependent on whether any files in a committed file queue
    were in use (and are thus now pending operations via MoveFileEx()).
    A reboot is also required if any files were installed as boot files
    (e.g., marked as COPYFLG_REPLACE_BOOT_FILE in the INF).

    If the user answers yes to the prompt, shutdown is initiated
    before this routine returns.

Arguments:

    FileQueue - if specified, supplies a file queue upon which
        to base the decision about whether shutdown is necessary.
        If not specified, then this routine assumes shutdown is
        necessary and asks the user what to do.

    Owner - supplies window handle for parent window to own windows
        created by this routine.

    ScanOnly - if TRUE, then the user is never asked whether he wants
        to reboot and no shutdown is initiated. In this case FileQueue
        must be specified. If FALSE then this routine functions as
        described above.

        This flags is used when the caller wants to determine whether
        shutdown is necessary separately from actually performing
        the shutdown.

Return Value:

    A combination of the following flags or -1 if an error occured:

    SPFILEQ_FILE_IN_USE: at least one file was in use and thus there are
        delayed file operations pending. This flag will never be set
        when FileQueue is not specified.

    SPFILEQ_REBOOT_RECOMMENDED: it is recommended that the system
        be rebooted. Depending on other flags and user response to
        the shutdown query, shutdown may already be happening.

    SPFILEQ_REBOOT_IN_PROGRESS: shutdown is in progress.

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode;
    PSOURCE_MEDIA_INFO SourceMedia;
    INT Flags;
    int i;
    DWORD Reason = REASON_PLANNED_FLAG;

    //
    // If only scanning, there must be a FileQueue to scan!
    //
    if(ScanOnly && !FileQueue) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    //
    // If we're not just scanning (i.e., we're potentially going to popup UI,
    // then we'd better be interactive.
    //
    if(!ScanOnly && (GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP))) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return -1;
    }

    Queue = (PSP_FILE_QUEUE)FileQueue;
    Flags = 0;

    //
    // Scan file queue if the caller so desires.
    //
    if(FileQueue) {
        try {
            if(Queue->Flags & FQF_DEVICE_INSTALL) {
                Reason |= REASON_HWINSTALL;
            }
            //
            // Check delete queue for in-use files.
            //
            for(QueueNode=Queue->DeleteQueue; QueueNode; QueueNode=QueueNode->Next) {

                if(QueueNode->InternalFlags & INUSE_INF_WANTS_REBOOT) {
                    Flags |= SPFILEQ_REBOOT_RECOMMENDED;
                }

                if(QueueNode->InternalFlags & INUSE_IN_USE) {
                    Flags |= SPFILEQ_FILE_IN_USE;
                }
            }

            //
            // Check copy queues for in-use files.
            //
            for(SourceMedia=Queue->SourceMediaList; SourceMedia; SourceMedia=SourceMedia->Next) {
                for(QueueNode=SourceMedia->CopyQueue; QueueNode; QueueNode=QueueNode->Next) {

                    if(QueueNode->InternalFlags & INUSE_INF_WANTS_REBOOT) {
                        Flags |= SPFILEQ_REBOOT_RECOMMENDED;
                    }

                    if(QueueNode->InternalFlags & INUSE_IN_USE) {
                        Flags |= SPFILEQ_FILE_IN_USE;
                    }
                }
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(ERROR_INVALID_PARAMETER);
            Flags = -1;
        }
    } else {
        Flags = SPFILEQ_REBOOT_RECOMMENDED;
    }

    //
    // Ask the user if he wants to shut down, if necessary.
    //
    if(!ScanOnly &&
       (Flags & (SPFILEQ_REBOOT_RECOMMENDED | SPFILEQ_FILE_IN_USE)) &&
       (Flags != -1)) {
        if(RestartDialogEx(Owner,NULL,EWX_REBOOT,Reason) == IDYES) {
            Flags |= SPFILEQ_REBOOT_IN_PROGRESS;
        }
    }

    return(Flags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\fileqcb.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    fileqcb.c

Abstract:

    Routines to call out to file queue callbacks, translating
    character types as necessary.

Author:

    Ted Miller (tedm) Feb-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define structure that describes, for a given structure, how to
// thunk it back and forth between ANSI and Unicode.
//
typedef struct _STRUCT_THUNK_DATA {
    //
    // Size of the structure
    //
    unsigned StructureSize;
    //
    // Offsets of members that are pointers to strings
    // that need conversion before calling the callback function.
    // A -1 terminates the list.
    //
    int StringMemberOffsets[5];
    //
    // Offsets of DWORD members that need to be copied back from
    // the temporary structure back into the caller's one.
    //
    int OutputDwordOffsets[2];
    //
    // Offsets of strings that need to be converted in place
    // after the callback has occurred.
    //
    int OutputStringOffsets[2];

} STRUCT_THUNK_DATA, *PSTRUCT_THUNK_DATA;

//
// Define enum for data types we care about for the setup message
// notification mechanism.
//
typedef enum {
    FileMsgFilepaths,           // FILEPATHS
    FileMsgSourcemedia,         // SOURCE_MEDIA
    FileMsgCabinetinfo,         // CABINET_INFO
    FileMsgFileincabinfo,       // FILE_IN_CABINET_INFO
    FileMsgControlStatus,       // SP_REGISTER_CONTROL_STATUS
    FileMsgNone,                // No translation (special case)
    FileMsgString,              // Plain string (special case)
    FileMsgStringOut            // String written by callback (special case)
} FileMsgStruct;

//
// Instantiate structure thunk data for structures we care about.
//
STRUCT_THUNK_DATA StructThunkData[] = {

                //
                // FILEPATHS structure
                //
                {
                    sizeof(FILEPATHS),

                    {
                        offsetof(FILEPATHS,Target),
                        offsetof(FILEPATHS,Source),
                        -1
                    },

                    { offsetof(FILEPATHS,Win32Error),-1 }, { -1 }
                },

                //
                // SOURCE_MEDIA structure
                //
                {
                    sizeof(SOURCE_MEDIA),

                    {
                        offsetof(SOURCE_MEDIA,Tagfile),
                        offsetof(SOURCE_MEDIA,Description),
                        offsetof(SOURCE_MEDIA,SourcePath),
                        offsetof(SOURCE_MEDIA,SourceFile),
                        -1
                    },

                    { -1 }, { -1 }
                },

                //
                // CABINET_INFO structure
                //
                {
                    sizeof(CABINET_INFO),

                    {
                        offsetof(CABINET_INFO,CabinetPath),
                        offsetof(CABINET_INFO,CabinetFile),
                        offsetof(CABINET_INFO,DiskName),
                        -1
                    },

                    { -1 }, { -1 }
                },

                //
                // FILE_IN_CABINET_INFO structure
                //
                {
                    sizeof(FILE_IN_CABINET_INFO),

                    {
                        offsetof(FILE_IN_CABINET_INFO,NameInCabinet),
                        -1
                    },

                    { offsetof(FILE_IN_CABINET_INFO,Win32Error),-1 },
                    { offsetof(FILE_IN_CABINET_INFO,FullTargetName),-1 }
                },

                //
                // SP_REGISTER_CONTROL_STATUS structure
                //
                {
                    sizeof(SP_REGISTER_CONTROL_STATUS),

                    {
                        offsetof(SP_REGISTER_CONTROL_STATUS,FileName),
                        -1
                    },

                    { -1 }, { -1 }

                }
            };


//
// Define structure that describes how to translate messages
// from ANSI<-->Unicode for all notification messages that we send out.
// and special return codes
//
typedef struct _MSG_THUNK_DATA {
    DWORD Notification;
    BOOL UseMask;
    FileMsgStruct Param1Type;
    FileMsgStruct Param2Type;
    UINT ExceptionReturn;
} MSG_THUNK_DATA, *PMSG_THUNK_DATA;

//
// Instantiate message thunk data.
// Entries marked as FILEOP_RETURN_STATUS indicate that the return value is a
// windows error code.
//
MSG_THUNK_DATA MsgThunkData[] =
{
 { SPFILENOTIFY_STARTQUEUE,        FALSE,FileMsgNone         ,FileMsgNone     ,FALSE               },
 { SPFILENOTIFY_ENDQUEUE,          FALSE,FileMsgNone         ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_STARTSUBQUEUE,     FALSE,FileMsgNone         ,FileMsgNone     ,FALSE               },
 { SPFILENOTIFY_ENDSUBQUEUE,       FALSE,FileMsgNone         ,FileMsgNone     ,FALSE               },
 { SPFILENOTIFY_STARTDELETE,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_ENDDELETE,         FALSE,FileMsgFilepaths    ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_DELETEERROR,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_STARTRENAME,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_ENDRENAME,         FALSE,FileMsgFilepaths    ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_RENAMEERROR,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_STARTCOPY,         FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_ENDCOPY,           FALSE,FileMsgFilepaths    ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_COPYERROR,         FALSE,FileMsgFilepaths    ,FileMsgStringOut,FILEOP_ABORT        },
 { SPFILENOTIFY_NEEDMEDIA,         FALSE,FileMsgSourcemedia  ,FileMsgStringOut,FILEOP_ABORT        },
 { SPFILENOTIFY_QUEUESCAN,         FALSE,FileMsgString       ,FileMsgNone     ,FILEOP_RETURN_STATUS},
 { SPFILENOTIFY_QUEUESCAN_EX,      FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_RETURN_STATUS},
 { SPFILENOTIFY_CABINETINFO,       FALSE,FileMsgCabinetinfo  ,FileMsgNone     ,FILEOP_RETURN_STATUS},
 { SPFILENOTIFY_FILEINCABINET,     FALSE,FileMsgFileincabinfo,FileMsgString   ,FILEOP_INTERNAL_FAILED},
 { SPFILENOTIFY_NEEDNEWCABINET,    FALSE,FileMsgCabinetinfo  ,FileMsgStringOut,FILEOP_RETURN_STATUS},
 { SPFILENOTIFY_FILEEXTRACTED,     FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_RETURN_STATUS},
 { SPFILENOTIFY_FILEOPDELAYED,     FALSE,FileMsgFilepaths    ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_STARTBACKUP,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_ENDBACKUP,         FALSE,FileMsgFilepaths    ,FileMsgNone     ,0                   },
 { SPFILENOTIFY_BACKUPERROR,       FALSE,FileMsgFilepaths    ,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_STARTREGISTRATION, FALSE,FileMsgControlStatus,FileMsgNone     ,FILEOP_ABORT        },
 { SPFILENOTIFY_ENDREGISTRATION,   FALSE,FileMsgControlStatus,FileMsgNone     ,FILEOP_ABORT        },

 { SPFILENOTIFY_LANGMISMATCH
 | SPFILENOTIFY_TARGETEXISTS
 | SPFILENOTIFY_TARGETNEWER,       TRUE ,FileMsgFilepaths    ,FileMsgNone     ,FALSE               }
};

//
// Forward references.
//
BOOL
pSetupConvertMsgHandlerArgs(
    IN  UINT  Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2,
    OUT PUINT_PTR NewParam1,
    OUT PUINT_PTR NewParam2,
    IN  BOOL  ToAnsi,
    OUT PMSG_THUNK_DATA *ThunkData
    );

BOOL
pThunkSetupMsgParam(
    IN  FileMsgStruct StructType,
    IN  UINT_PTR      Param,
    OUT UINT_PTR     *NewParam,
    IN  BOOL          ToAnsi
    );

VOID
pUnthunkSetupMsgParam(
    IN     FileMsgStruct StructType,
    IN OUT UINT_PTR      OriginalParam,
    IN OUT UINT_PTR      ThunkedParam,
    IN     BOOL          FreeOnly,
    IN     BOOL          ThunkedToAnsi
    );

UINT
pGetCallbackErrorReturn(
    IN UINT Notification,
    IN DWORD ReturnStatus
    )
/*++

Routine Description:

    Determine return value for given notification and given ReturnStatus.

Arguments:

    Notification - supplies notification

Return Value:

    Return code specific to the notification.

--*/
{
    unsigned u;
    PMSG_THUNK_DATA thunkData;
    BOOL KnownMessage;

    MYASSERT(ReturnStatus);

    //
    // Locate the msg-specific thunk data descriptor.
    //
    KnownMessage = FALSE;
    for(u=0; !KnownMessage && (u<(sizeof(MsgThunkData)/sizeof(MsgThunkData[0]))); u++) {

        thunkData = &MsgThunkData[u];

        if(thunkData->UseMask) {
            KnownMessage = ((thunkData->Notification & Notification) != 0);
        } else {
            KnownMessage = (thunkData->Notification == Notification);
        }
    }
    SetLastError(ReturnStatus);
    if (!KnownMessage) {
        MYASSERT(KnownMessage);
        SetLastError(ReturnStatus);
        return 0;
    } else if(thunkData->ExceptionReturn == FILEOP_RETURN_STATUS) {
        return ReturnStatus;
    } else {
        return thunkData->ExceptionReturn;
    }
}

#ifdef UNICODE

UINT
pSetupCallMsgHandler(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PVOID MsgHandler,
    IN BOOL  MsgHandlerIsNativeCharWidth,
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )

/*++

Routine Description:

    Call out to a SP_FILE_CALLBACK routine, translating arguments from
    Unicode to ANSI as necessary, and marshalling data back into Unicode
    as necessary.

    Conversions and marshalling occur only for messages we recognize
    (ie, that are in the MsgThunkData array). Unrecognized messages
    are assumed to be private and are passed through unchanged.

    If a Unicode->ANSI conversion fails due to an out of memory condition,
    this routine sets last error to ERROR_NOT_ENOUGH_MEMORY and returns
    the value specified in the relevent MsgThunkData structure.

Arguments:

    LogContext - context for logging errors

    MsgHandler - supplies pointer to callback routine. Can be either
        a routine expecting ANSI args or Unicode args, as specified
        by MsgHandlerIsNativeCharWidth.

    MsgHandlerIsNativeCharWidth - supplies flag indicating whether callback
        functionexpects Unicode (TRUE) or ANSI (FALSE) arguments.

    Context - supplies context data meaningful to the callback
        routine. Not interpreted by this routine, merely passed on.

    Notification - supplies notification code to be passed to the callback.

    Param1 - supplies first notification-specific parameter to be passed
        to the callback.

    Param2 - supplies second notification-specific parameter to be passed
        to the callback.

Return Value:

    Return code specific to the notification.

--*/

{
    PSP_FILE_CALLBACK_A MsgHandlerA;
    PSP_FILE_CALLBACK_W MsgHandlerW;
    UINT rc,ec;
    UINT_PTR Param1A,Param2A;
    BOOL b;
    PMSG_THUNK_DATA ThunkData;

    //
    // If already unicode, nothing to do, just call the msghandler.
    //
    if(MsgHandlerIsNativeCharWidth) {
        MsgHandlerW = (PSP_FILE_CALLBACK_W)MsgHandler;
        try {
            SetLastError(NO_ERROR);
            rc = MsgHandlerW(Context,Notification,Param1,Param2);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            WriteLogEntry(
              LogContext,
              SETUP_LOG_ERROR,
              MSG_LOG_QUEUE_CALLBACK_FAILED,
              NULL,
              GetExceptionCode());
            rc = pGetCallbackErrorReturn(Notification,ERROR_INVALID_DATA);
        }
        return rc;
    }

    //
    // Optimization: if we are going to call the ANSI version of the
    // default queue callback routine SetupDefaultQueueCallbackA(),
    // we can avoid converting the args, since they'll just be converted
    // right back again by that API as a prelude to calling the
    // actual implementation SetupDefaultQueueCallbackW().
    //
    if(MsgHandler == SetupDefaultQueueCallbackA) {
        SetLastError(NO_ERROR);
        return(SetupDefaultQueueCallbackW(Context,Notification,Param1,Param2));
    }

    //
    // Target callback function is expecting ANSI arguments.
    //
    b = pSetupConvertMsgHandlerArgs(
            Notification,
            Param1,
            Param2,
            &Param1A,
            &Param2A,
            TRUE,
            &ThunkData
            );

    if(!b) {
        return pGetCallbackErrorReturn(Notification,ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Agrs are ready; call out to the ANSI callback.
    //
    MsgHandlerA = MsgHandler;
    try {
        SetLastError(NO_ERROR);
        rc = MsgHandlerA(Context,Notification,Param1A,Param2A);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WriteLogEntry(
            LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_QUEUE_CALLBACK_FAILED,
            NULL,
            GetExceptionCode());
        rc = pGetCallbackErrorReturn(Notification,ERROR_INVALID_DATA);
    }
    ec = GetLastError();

    //
    // Free the temporary thunk structs and marshall data back into
    // the original structures as necessary.
    //
    if(ThunkData) {
        pUnthunkSetupMsgParam(ThunkData->Param1Type,Param1,Param1A,FALSE,TRUE);
        pUnthunkSetupMsgParam(ThunkData->Param2Type,Param2,Param2A,FALSE,TRUE);
    }

    SetLastError(ec);
    return(rc);
}


UINT
pSetupCallDefaultMsgHandler(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT_PTR Param1U,Param2U;
    BOOL b;
    PMSG_THUNK_DATA ThunkData;
    UINT rc,ec;

    //
    // Thunk args to Unicode.
    //
    b = pSetupConvertMsgHandlerArgs(
            Notification,
            Param1,
            Param2,
            &Param1U,
            &Param2U,
            FALSE,
            &ThunkData
            );

    if(!b) {
        return pGetCallbackErrorReturn(Notification,ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Agrs are ready; call the default queue callback.
    //
    rc = SetupDefaultQueueCallbackW(Context,Notification,Param1U,Param2U);
    ec = GetLastError();

    //
    // Free the temporary thunk structs and marshall data back into
    // the original structures as necessary.
    //
    if(ThunkData) {
        pUnthunkSetupMsgParam(ThunkData->Param1Type,Param1,Param1U,FALSE,FALSE);
        pUnthunkSetupMsgParam(ThunkData->Param2Type,Param2,Param2U,FALSE,FALSE);
    }

    SetLastError(ec);
    return(rc);
}



BOOL
pSetupConvertMsgHandlerArgs(
    IN  UINT  Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2,
    OUT PUINT_PTR NewParam1,
    OUT PUINT_PTR NewParam2,
    IN  BOOL  ToAnsi,
    OUT PMSG_THUNK_DATA *ThunkData
    )

/*++

Routine Description:

    Locate thunk description data for a given notification and convert
    parameters from Unicode to ANSI or ANSI to Unicode.

Arguments:

    Notification - supplies notification code to be passed to the callback.

    Param1 - supplies first notification-specific parameter to be passed
        to the callback, which is to be converted.

    Param2 - supplies second notification-specific parameter to be passed
        to the callback, which is to be converted.

    NewParam1 - receives first notification-specific parameter to be passed
        to the callback.

    NewParam2 - receives second notification-specific parameter to be passed
        to the callback.

    ToAnsi - supplies flag indicating whether parameters are to be converted
        from ANSI to Unicode or Unicode to ANSI.

    ThunkData - if the Notification is recognized, receives a pointer to
        the MSG_THUNK_DATA for the given Notification. If not recognized,
        receives NULL.

Return Value:

    Boolean value indicating whether conversion was successful.
    If FALSE, the caller can assume out of memory.

--*/

{
    unsigned u;
    PMSG_THUNK_DATA thunkData;
    BOOL KnownMessage;

    //
    // Locate the msg-specific thunk data descriptor.
    //
    KnownMessage = FALSE;
    for(u=0; !KnownMessage && (u<(sizeof(MsgThunkData)/sizeof(MsgThunkData[0]))); u++) {

        thunkData = &MsgThunkData[u];

        if(thunkData->UseMask) {
            KnownMessage = ((thunkData->Notification & Notification) != 0);
        } else {
            KnownMessage = (thunkData->Notification == Notification);
        }
    }

    if(!KnownMessage) {
        //
        // Unknown message; must be private. Just pass args on as-is.
        //
        *NewParam1 = Param1;
        *NewParam2 = Param2;
        *ThunkData = NULL;
    } else {
        //
        // Got a message we understand. Thunk it.
        //
        *ThunkData = thunkData;

        if(!pThunkSetupMsgParam(thunkData->Param1Type,Param1,NewParam1,ToAnsi)) {
            return(FALSE);
        }

        if(!pThunkSetupMsgParam(thunkData->Param2Type,Param2,NewParam2,ToAnsi)) {
            pUnthunkSetupMsgParam(thunkData->Param1Type,Param1,*NewParam1,TRUE,ToAnsi);
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL
pThunkSetupMsgParam(
    IN  FileMsgStruct StructType,
    IN  UINT_PTR      Param,
    OUT UINT_PTR     *NewParam,
    IN  BOOL          ToAnsi
    )

/*++

Routine Description:

    Convert a parameter to a setup notification callback from ANSI to
    Unicode or Unicode to ANSI as necessary. Allocates all required memory
    and performs conversions.

Arguments:

    StructType - supplies type of data represented by Param.

    Param - supplies parameter to be converted.

    NewParam - receives new parameter. Caller should free via
        pUnthunkSetupMsgParam when done.

    ToAnsi - if FALSE, Param is to be converted from ANSI to Unicode.
        If TRUE, Param is to be converted from Unicode to ANSI.

Return Value:

    Boolean value indicating whether conversion occured successfully.
    If FALSE, the caller can assume out of memory.

--*/

{
    unsigned u,v;
    PUCHAR newStruct;
    PVOID OldString;
    PVOID NewString;

    //
    // Handle special cases here.
    //
    switch(StructType) {

    case FileMsgNone:
        *NewParam = Param;
        return(TRUE);

    case FileMsgStringOut:
        //
        // Callee will write string data which we will convert later.
        //
        if(*NewParam = (UINT_PTR)MyMalloc(MAX_PATH * (ToAnsi ? sizeof(CHAR) : sizeof(WCHAR)))) {
            if(ToAnsi) {
                *(PCHAR)(*NewParam) = 0;
            } else {
                *(PWCHAR)(*NewParam) = 0;
            }
        }
        return(*NewParam != 0);

    case FileMsgString:
        if(ToAnsi) {
            *NewParam = (UINT_PTR)pSetupUnicodeToAnsi((PCWSTR)Param);
        } else {
            *NewParam = (UINT_PTR)pSetupAnsiToUnicode((PCSTR)Param);
        }
        return(*NewParam != 0);
    }

    newStruct = MyMalloc(StructThunkData[StructType].StructureSize);
    if(!newStruct) {
        return(FALSE);
    }

    CopyMemory(newStruct,(PVOID)Param,StructThunkData[StructType].StructureSize);

    for(u=0; StructThunkData[StructType].StringMemberOffsets[u] != -1; u++) {

        OldString = *(PVOID *)((PUCHAR)Param + StructThunkData[StructType].StringMemberOffsets[u]);

        if(OldString) {
            if(ToAnsi) {
                NewString = pSetupUnicodeToAnsi(OldString);
            } else {
                NewString = pSetupAnsiToUnicode(OldString);
            }

            if(!NewString) {
                for(v=0; v<u; v++) {
                    MyFree(*(PVOID *)(newStruct + StructThunkData[StructType].StringMemberOffsets[v]));
                }

                MyFree(newStruct);
                return(FALSE);
            }

            *(PVOID *)(newStruct + StructThunkData[StructType].StringMemberOffsets[u]) = NewString;
        }
    }

    *NewParam = (UINT_PTR)newStruct;
    return(TRUE);
}


VOID
pUnthunkSetupMsgParam(
    IN     FileMsgStruct StructType,
    IN OUT UINT_PTR      OriginalParam,
    IN OUT UINT_PTR      ThunkedParam,
    IN     BOOL          FreeOnly,
    IN     BOOL          ThunkedToAnsi
    )

/*++

Routine Description:

    Marshal data output by a callback function back into the original
    Unicode or ANSI structure. Also, free the temporary structure and all
    its resources.

Arguments:

    StructType - supplies type of data being operated on.

    OriginalParam - supplies original parameter. DWORD fields and
        in-place strings in this structure will be updated by this routine.

    ThunkedParam - supplies temporary ANSI or Unicode parameter.

    FreeOnly - if TRUE, no marshalling occurs but ThunkedParam will be freed.

Return Value:

    None.

--*/

{
    unsigned u;
    PVOID String;
    PVOID SourceString;
    DWORD d;

    //
    // Special cases here.
    //
    switch(StructType) {

    case FileMsgNone:
        //
        // Nothing to do for this one.
        //
        return;

    case FileMsgStringOut:
        //
        // Callee wrote string data; convert as appropriate.
        //
        if(!FreeOnly) {

            if(ThunkedToAnsi) {

                MultiByteToWideChar(
                    CP_ACP,
                    0,
                    (PCSTR)ThunkedParam,
                    -1,
                    (PWCHAR)OriginalParam,
                    MAX_PATH
                    );

            } else {

                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    (PCWSTR)ThunkedParam,
                    -1,
                    (PCHAR)OriginalParam,
                    MAX_PATH,
                    NULL,
                    NULL
                    );
            }
        }
        MyFree((PVOID)ThunkedParam);
        return;

    case FileMsgString:
        //
        // Simple string.
        //
        MyFree((PVOID)ThunkedParam);
        return;
    }

    //
    // Free all strings.
    //
    for(u=0; StructThunkData[StructType].StringMemberOffsets[u] != -1; u++) {

        String = *(PVOID *)((PUCHAR)ThunkedParam + StructThunkData[StructType].StringMemberOffsets[u]);

        if(String) {
            MyFree(String);
        }
    }

    //
    // Marshall data back to Unicode structure
    //
    if(!FreeOnly) {
        //
        // Copy DWORD data from the thunk struct back to the original struct.
        //
        for(u=0; StructThunkData[StructType].OutputDwordOffsets[u] != -1; u++) {

            d = *(DWORD *)((PUCHAR)ThunkedParam + StructThunkData[StructType].OutputDwordOffsets[u]);

            *(DWORD *)((PUCHAR)OriginalParam + StructThunkData[StructType].OutputDwordOffsets[u]) = d;
        }

        //
        // Convert output strings.
        //
        for(u=0; StructThunkData[StructType].OutputStringOffsets[u] != -1; u++) {

            SourceString = (PUCHAR)ThunkedParam  + StructThunkData[StructType].OutputStringOffsets[u];
            String       = (PUCHAR)OriginalParam + StructThunkData[StructType].OutputStringOffsets[u];

            if(ThunkedToAnsi) {
                MultiByteToWideChar(
                    CP_ACP,
                    0,
                    SourceString,
                    -1,
                    String,
                    MAX_PATH
                    );
            } else {
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    SourceString,
                    -1,
                    String,
                    MAX_PATH,
                    NULL,
                    NULL
                    );
            }
        }
    }

    MyFree((PVOID)ThunkedParam);
}



#else

UINT
pSetupCallMsgHandler(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PVOID MsgHandler,
    IN BOOL  MsgHandlerIsNativeCharWidth,
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    PSP_FILE_CALLBACK_A msghandler;
    UINT result = 0;

    UNREFERENCED_PARAMETER(MsgHandlerIsNativeCharWidth);
    MYASSERT(MsgHandlerIsNativeCharWidth);

    //
    // ANSI version has no thunking
    //
    try {

        msghandler = (PSP_FILE_CALLBACK_A)MsgHandler;
        result = msghandler(Context,Notification,Param1,Param2);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        WriteLogEntry(
            LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_QUEUE_CALLBACK_FAILED,
            NULL,
            GetExceptionCode());
        result = pGetCallbackErrorReturn(Notification,ERROR_INVALID_DATA);
    }

    return result;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\fileq2.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fileq2.c

Abstract:

    Setup file queue routines for enqueing copy operations.

Author:

    Ted Miller (tedm) 15-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#define STR_DRIVERCACHEINF  TEXT("drvindex.inf")


//
// Structure used with _SetupQueueCopy
//
typedef struct _SP_FILE_COPY_PARAMS_AEX {
    DWORD    cbSize;
    HSPFILEQ QueueHandle;
    PCSTR    SourceRootPath;     OPTIONAL
    PCSTR    SourcePath;         OPTIONAL
    PCSTR    SourceFilename;
    PCSTR    SourceDescription;  OPTIONAL
    PCSTR    SourceTagfile;      OPTIONAL
    PCSTR    TargetDirectory;
    PCSTR    TargetFilename;     OPTIONAL
    DWORD    CopyStyle;
    HINF     LayoutInf;          OPTIONAL
    PCSTR    SecurityDescriptor; OPTIONAL
    DWORD    SourceFlags;        OPTIONAL
    BOOL     SourceFlagsSet;     OPTIONAL // we need this flag since SourceFlags may be zero
    PCSTR    CacheName;
} SP_FILE_COPY_PARAMS_AEX, *PSP_FILE_COPY_PARAMS_AEX;

typedef struct _SP_FILE_COPY_PARAMS_WEX {
    DWORD    cbSize;
    HSPFILEQ QueueHandle;
    PCWSTR   SourceRootPath;     OPTIONAL
    PCWSTR   SourcePath;         OPTIONAL
    PCWSTR   SourceFilename;
    PCWSTR   SourceDescription;  OPTIONAL
    PCWSTR   SourceTagfile;      OPTIONAL
    PCWSTR   TargetDirectory;
    PCWSTR   TargetFilename;     OPTIONAL
    DWORD    CopyStyle;
    HINF     LayoutInf;          OPTIONAL
    PCWSTR   SecurityDescriptor; OPTIONAL
    DWORD    SourceFlags;        OPTIONAL
    BOOL     SourceFlagsSet;     OPTIONAL // we need this flag since SourceFlags may be zero
    PCWSTR   CacheName;
} SP_FILE_COPY_PARAMS_WEX, *PSP_FILE_COPY_PARAMS_WEX;

#ifdef UNICODE
typedef SP_FILE_COPY_PARAMS_WEX SP_FILE_COPY_PARAMSEX;
typedef PSP_FILE_COPY_PARAMS_WEX PSP_FILE_COPY_PARAMSEX;
#else
typedef SP_FILE_COPY_PARAMS_AEX SP_FILE_COPY_PARAMSEX;
typedef PSP_FILE_COPY_PARAMS_AEX PSP_FILE_COPY_PARAMSEX;
#endif




BOOL
_SetupQueueCopy(
    IN PSP_FILE_COPY_PARAMSEX CopyParams,
    IN PINFCONTEXT          LayoutLineContext, OPTIONAL
    IN HINF                 AdditionalInfs     OPTIONAL
    );

PSOURCE_MEDIA_INFO
pSetupQueueSourceMedia(
    IN OUT PSP_FILE_QUEUE      Queue,
    IN OUT PSP_FILE_QUEUE_NODE QueueNode,
    IN     LONG                SourceRootStringId,
    IN     PCTSTR              SourceDescription,   OPTIONAL
    IN     PCTSTR              SourceTagfile,       OPTIONAL
    IN     PCTSTR              SourceCabfile,       OPTIONAL
    IN     DWORD               MediaFlags
    );

BOOL
pSetupQueueSingleCopy(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,  OPTIONAL
    IN PCTSTR   SectionName,    OPTIONAL
    IN PCTSTR   SourceRootPath,
    IN PCTSTR   SourceFilename,
    IN PCTSTR   TargetFilename,
    IN DWORD    CopyStyle,
    IN PCTSTR   SecurityDescriptor,
    IN PCTSTR   CacheName
    );

BOOL
pSetupGetSourceAllInfo(
    IN  HINF                     InfHandle,
    IN  PINFCONTEXT              LayoutLineContext, OPTIONAL
    IN  UINT                     SourceId,
    IN  PSP_ALTPLATFORM_INFO_V2  AltPlatformInfo,   OPTIONAL
    OUT PCTSTR                  *Description,
    OUT PCTSTR                  *Tagfile,
    OUT PCTSTR                  *RelativePath,
    OUT PUINT                    SourceFlags
    );

BOOL
pIsDriverCachePresent(
    IN PCTSTR DriverName,
    IN PCTSTR SubDirectory,
    OUT PTSTR DriverBuffer
    );

BOOL
pIsFileInDriverCache(
    IN  HINF   CabInf,
    IN  PCTSTR TargetFilename,
    IN  PCTSTR SubDirectory,
    OUT PCTSTR *CacheName
    );

BOOL
pIsFileInServicePackCache(
    IN  PCTSTR SourceFilename,
    IN  PCTSTR SubDirectory
    );


//
// HACK ALERT!!! HACK HACK HACK!!!!
//
// There might be an override platform specified. If this is so,
// we will look for \i386, \mips, etc as the final component of the
// specified path when queuing files, and replace it with the
// override path. This is a TOTAL HACK.
//
PCTSTR PlatformPathOverride;

VOID
pSetupInitPlatformPathOverrideSupport(
    IN BOOL Init
    )
{
    if(Init) {
        PlatformPathOverride = NULL;
    } else {
        if( PlatformPathOverride ) {
            MyFree(PlatformPathOverride);
            PlatformPathOverride = NULL;
        }
    }
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupSetPlatformPathOverrideA(
    IN PCSTR Override   OPTIONAL
    )
{
    BOOL b;
    DWORD rc;
    PCWSTR p;

    if(Override) {
        rc = pSetupCaptureAndConvertAnsiArg(Override,&p);
    } else {
        p = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {
        b = SetupSetPlatformPathOverrideW(p);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    if(p) {
        MyFree(p);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupSetPlatformPathOverrideW(
    IN PCWSTR Override  OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Override);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupSetPlatformPathOverride(
    IN PCTSTR Override  OPTIONAL
    )
{
    BOOL b = FALSE;
    DWORD rc = ERROR_NOT_ENOUGH_MEMORY;
    BOOL locked = FALSE;

    try {
        EnterCriticalSection(&PlatformPathOverrideCritSect);
        locked = TRUE;
        rc = ERROR_INVALID_DATA;

        if(Override) {
            if(PlatformPathOverride) {
                MyFree(PlatformPathOverride);
                PlatformPathOverride = NULL;
            }

            try {
                b = ((PlatformPathOverride = DuplicateString(Override)) != NULL);
                if(!b) {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                b = FALSE;
                rc = ERROR_INVALID_PARAMETER;
            }
        } else {
            if(PlatformPathOverride) {
                MyFree(PlatformPathOverride);
                PlatformPathOverride = NULL;
            }
            b = TRUE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if(locked) {
        LeaveCriticalSection(&PlatformPathOverrideCritSect);
    } else {
        b = FALSE;
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(!b) {
        SetLastError(rc);
    }
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueCopyA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourceRootPath,     OPTIONAL
    IN PCSTR    SourcePath,         OPTIONAL
    IN PCSTR    SourceFilename,
    IN PCSTR    SourceDescription,  OPTIONAL
    IN PCSTR    SourceTagfile,      OPTIONAL
    IN PCSTR    TargetDirectory,
    IN PCSTR    TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    )
{
    PCWSTR sourceRootPath;
    PCWSTR sourcePath;
    PCWSTR sourceFilename;
    PCWSTR sourceDescription;
    PCWSTR sourceTagfile;
    PCWSTR targetDirectory;
    PCWSTR targetFilename;
    BOOL b;
    DWORD rc;
    SP_FILE_COPY_PARAMS_WEX CopyParams = {0};

    sourceRootPath = NULL;
    sourcePath = NULL;
    sourceFilename = NULL;
    sourceDescription = NULL;
    sourceTagfile = NULL;
    targetDirectory = NULL;
    targetFilename = NULL;
    rc = NO_ERROR;
    b = FALSE;

    if(SourceRootPath) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceRootPath,&sourceRootPath);
    }
    if((rc == NO_ERROR) && SourcePath) {
        rc = pSetupCaptureAndConvertAnsiArg(SourcePath,&sourcePath);
    }
    if((rc == NO_ERROR) && SourceFilename) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceFilename,&sourceFilename);
    }
    if((rc == NO_ERROR) && SourceDescription) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceDescription,&sourceDescription);
    }
    if((rc == NO_ERROR) && SourceTagfile) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceTagfile,&sourceTagfile);
    }
    if((rc == NO_ERROR) && TargetDirectory) {
        rc = pSetupCaptureAndConvertAnsiArg(TargetDirectory,&targetDirectory);
    }
    if((rc == NO_ERROR) && TargetFilename) {
        rc = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetFilename);
    }

    if(rc == NO_ERROR) {

        CopyParams.cbSize = sizeof(SP_FILE_COPY_PARAMS_WEX);
        CopyParams.QueueHandle = QueueHandle;
        CopyParams.SourceRootPath = sourceRootPath;
        CopyParams.SourcePath = sourcePath;
        CopyParams.SourceFilename = sourceFilename;
        CopyParams.SourceDescription = sourceDescription;
        CopyParams.SourceTagfile = sourceTagfile;
        CopyParams.TargetDirectory = targetDirectory;
        CopyParams.TargetFilename = targetFilename;
        CopyParams.CopyStyle = CopyStyle;
        CopyParams.LayoutInf = NULL;
        CopyParams.SecurityDescriptor= NULL;

        b = _SetupQueueCopy(&CopyParams, NULL, NULL);
        rc = GetLastError();
    }

    if(sourceRootPath) {
        MyFree(sourceRootPath);
    }
    if(sourcePath) {
        MyFree(sourcePath);
    }
    if(sourceFilename) {
        MyFree(sourceFilename);
    }
    if(sourceDescription) {
        MyFree(sourceDescription);
    }
    if(sourceTagfile) {
        MyFree(sourceTagfile);
    }
    if(targetDirectory) {
        MyFree(targetDirectory);
    }
    if(targetFilename) {
        MyFree(targetFilename);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueCopyW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourceRootPath,     OPTIONAL
    IN PCWSTR   SourcePath,         OPTIONAL
    IN PCWSTR   SourceFilename,
    IN PCWSTR   SourceDescription,  OPTIONAL
    IN PCWSTR   SourceTagfile,      OPTIONAL
    IN PCWSTR   TargetDirectory,
    IN PCWSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(SourceRootPath);
    UNREFERENCED_PARAMETER(SourcePath);
    UNREFERENCED_PARAMETER(SourceFilename);
    UNREFERENCED_PARAMETER(SourceDescription);
    UNREFERENCED_PARAMETER(SourceTagfile);
    UNREFERENCED_PARAMETER(TargetDirectory);
    UNREFERENCED_PARAMETER(TargetFilename);
    UNREFERENCED_PARAMETER(CopyStyle);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueCopy(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourceRootPath,     OPTIONAL
    IN PCTSTR   SourcePath,         OPTIONAL
    IN PCTSTR   SourceFilename,
    IN PCTSTR   SourceDescription,  OPTIONAL
    IN PCTSTR   SourceTagfile,      OPTIONAL
    IN PCTSTR   TargetDirectory,
    IN PCTSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    )

/*++

Routine Description:

    Place a copy operation on a setup file queue.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    SourceRootPath - Supplies the root of the source for this copy,
        such as A:\ or \\FOO\BAR\BAZ.  If this parameter isn't supplied, then
        this queue node will be added to a media descriptor's queue that
        matches on SourceDescription and SourceTagfile.  (This merge will take
        place regardless of whether or not the media descriptor entry was
        already in the queue prior to calling SetupQueueCopy.)

        If there is no matching media descriptor that contains SourceRootPath
        information, the path will be set to the directory where the system was
        installed from.

    SourcePath - if specified, supplies the path relative to SourceRootPath
        where the file can be found.

    SourceFilename - supplies the filename part of the file to be copied.

    SourceDescription - if specified, supplies a description of the source
        media, to be used during disk prompts.

    SourceTagfile - if specified, supplies a tag file whose presence at
        SourceRootPath indicates the presence of the source media.
        If not specified, the file itself will be used as the tag file
        if required (tagfiles are used only for removable media).

    TargetDirectory - supplies the directory where the file is to be copied.

    TargetFilename - if specified, supplies the name of the target file.
        If not specified, the target file will have the same name as the source.

    CopyStyle - supplies flags that control the behavior of the copy operation
        for this file.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    SP_FILE_COPY_PARAMSEX CopyParams = {0};

    //
    // Work is done by common worker routine
    //
    CopyParams.cbSize = sizeof(SP_FILE_COPY_PARAMSEX);
    CopyParams.QueueHandle = QueueHandle;
    CopyParams.SourceRootPath = SourceRootPath;
    CopyParams.SourcePath = SourcePath;
    CopyParams.SourceFilename = SourceFilename;
    CopyParams.SourceDescription = SourceDescription;
    CopyParams.SourceTagfile = SourceTagfile;
    CopyParams.TargetDirectory = TargetDirectory;
    CopyParams.TargetFilename = TargetFilename;
    CopyParams.CopyStyle = CopyStyle;
    CopyParams.LayoutInf = NULL;
    CopyParams.SecurityDescriptor= NULL;
    CopyParams.CacheName = NULL;

    return(_SetupQueueCopy(&CopyParams, NULL, NULL));
}


BOOL
_SetupQueueCopy(
    IN PSP_FILE_COPY_PARAMSEX CopyParams,
    IN PINFCONTEXT            LayoutLineContext, OPTIONAL
    IN HINF                   AdditionalInfs     OPTIONAL
    )

/*++

Routine Description:

    Worker routine for SetupQueueCopy and friends.

Arguments:

    CopyParams - supplies a structure with information about the file
        to be queued. Fields are used as follows.

        cbSize - must be sizeof(SP_FILE_COPY_PARAMS). The caller should
            have verified this before calling this routine.

        QueueHandle - supplies a handle to a setup file queue, as returned
            by SetupOpenFileQueue.

        SourceRootPath - Supplies the root of the source for this copy,
            such as A:\ or \\FOO\BAR\BAZ.   If this field is NULL, then this
            queue node will be added to a media descriptor's queue that matches
            on SourceDescription and SourceTagfile.  (This merge will take
            place regardless of whether or not the media descriptor entry was
            already in the queue prior to calling SetupQueueCopy.)

            If there is no matching media descriptor that contains
            SourceRootPath information, the path will be set to the directory
            where the system was installed from.

        SourcePath - if specified, supplies the path relative to SourceRootPath
            where the file can be found.

        SourceFilename - supplies the filename part of the file to be copied.

        SourceDescription - if specified, supplies a description of the source
            media, to be used during disk prompts.

        SourceTagfile - if specified, supplies a tag file whose presence at
            SourceRootPath indicates the presence of the source media.
            If not specified, the file itself will be used as the tag file
            if required (tagfiles are used only for removable media).

        TargetDirectory - supplies the directory where the file is to be copied.

        TargetFilename - if specified, supplies the name of the target file.  If
            not specified, the target file will have the same name as the source.

        CopyStyle - supplies flags that control the behavior of the copy
            operation for this file.

        LayoutInf - supplies the handle to the inf which contains the source
            layout info for this file, if any.

    LayoutLineContext - if specified, this argument provides the INF context
        for the [SourceDisksFiles] entry pertaining to the file to be copied.
        If not specified, the relevant [SourceDisksFiles] entry will be searched
        for in the LayoutInf handle specified in the CopyParams structure.  This
        context must be contained within either the CopyParams->LayoutInf or
        AdditionalInfs loaded INF handles (because those are the two INFs we're
        gonna lock).  The argument is used to prevent us from having to search
        for the file to be copied in a [SourceDisksFiles] section.  The caller
        has already done that, and is either handing us the context to that INF
        entry, or has passed -1 to indicate that there is no [SourceDisksFiles]
        entry.

    AdditionalInfs - if specified, supplies an additional HINF (potentially
        containing multiple append-loaded INFs) that need to be added to our
        SPQ_CATALOG_INFO list for later validation.  Do not supply this parameter
        if it is identical to the value of the LayoutInf field in the CopyParams
        structure.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode, TempNode, PrevQueueNode;
    PSOURCE_MEDIA_INFO Source;
    TCHAR TempBuffer[MAX_PATH];
    TCHAR TempSubDir[MAX_PATH];
    TCHAR SourceCabfileBuffer[MAX_PATH];
    TCHAR SourceTagfile2Buffer[MAX_PATH];
    TCHAR DriverCache[MAX_PATH] = {0};
    PCTSTR LastPathPart;
    PCTSTR p;
    int Size;
    DWORD d;
    HINF LayoutInfHandle;
    INFCONTEXT LineContext;
    BOOL b;
    PSPQ_CATALOG_INFO CatalogNode, PrevCatalogNode, LastOldCatalogNode;
    LONG l1,l2, l3, l4;
    PLOADED_INF pLoadedInfs[2];
    DWORD LoadedInfCount, i;
    PLOADED_INF pCurLoadedInf;
    DWORD MediaFlags;
    PCTSTR SourcePath, SourceRootPath;
    PCTSTR SourceTagfile = NULL;
    PCTSTR SourceCabfile = NULL;
#if defined(_X86_)
    BOOL ForcePlatform = FALSE;
#endif
    UINT SourceFlags = 0;
    PINFCONTEXT pContext = LayoutLineContext;
    INFCONTEXT tmpContext,tmpContext2;
    UINT SourceId = 0;
    BOOL locked = FALSE;
    DWORD CopyStyle = 0;

    d = NO_ERROR;
    LoadedInfCount = 0;
    MediaFlags = 0;

    try {
        MYASSERT(CopyParams->cbSize == sizeof(SP_FILE_COPY_PARAMSEX));
        Queue = (PSP_FILE_QUEUE)CopyParams->QueueHandle;
        if (Queue->Signature != SP_FILE_QUEUE_SIG) {
            d = ERROR_INVALID_PARAMETER;
        }

        LayoutInfHandle = CopyParams->LayoutInf;
        CopyStyle = CopyParams->CopyStyle;

        //
        // Maintain local pointers to the SourceRootPath and SourcePath strings,
        // since we may be modifying them, and we don't want to muck with the
        // caller-supplied buffer.
        //
        SourcePath = CopyParams->SourcePath;
        if(CopyParams->SourceRootPath) {
            SourceRootPath = CopyParams->SourceRootPath;
        } else {
            SourceRootPath = SystemSourcePath;
            MediaFlags |= SMI_FLAG_NO_SOURCE_ROOT_PATH;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }
    if(d != NO_ERROR) {
        goto clean0;
    }

    //
    // Make sure that we weren't passed the same HINF in both CopyParams->LayoutInf
    // and AdditionalInfs (just adds redundant work to process the same
    // LOADED_INF list twice).
    //
    MYASSERT(!LayoutInfHandle || (LayoutInfHandle != AdditionalInfs));

    //
    // Lock inf(s). We do a whole bunch of operations on the inf later,
    // and we don't want anything changing out from under us.
    //
    if(LayoutInfHandle) {
        if(LockInf((PLOADED_INF)LayoutInfHandle)) {
            pLoadedInfs[LoadedInfCount++] = (PLOADED_INF)LayoutInfHandle;
        } else {
            d = ERROR_INVALID_HANDLE;
            goto clean0;
        }
    }

    if(AdditionalInfs) {
        if(LockInf((PLOADED_INF)AdditionalInfs)) {
            pLoadedInfs[LoadedInfCount++] = (PLOADED_INF)AdditionalInfs;
        } else {
            d = ERROR_INVALID_HANDLE;
            goto clean0;
        }
    }

    if(!(Queue->Flags & FQF_DEVICE_INSTALL)) {
        //
        // Look through all the INFs to see if any of them are device INFs.
        //
        for(i = 0; i < LoadedInfCount; i++) {

            if(IsInfForDeviceInstall(Queue->LogContext,
                                     NULL,
                                     pLoadedInfs[i],
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     TRUE // use non-driver signing policy unless it's a WHQL class
                                     ))
            {
                //
                // There be device INFs here!  Mark the queue accordingly.
                //
                d = MarkQueueForDeviceInstall(CopyParams->QueueHandle,
                                              (HINF)(pLoadedInfs[i]),
                                              NULL
                                             );
                if(d == NO_ERROR) {
                    break;
                } else {
                    goto clean0;
                }
            }
        }
    }

    //
    // check if we already have a line context for the file we're adding
    // and if we don't, then try to fetch it
    //
    if (!LayoutLineContext || LayoutLineContext == (PINFCONTEXT) -1) {
        if ((LayoutInfHandle == (PINFCONTEXT) -1) || (LayoutInfHandle == NULL)) {
            pContext = NULL;
        } else {
            //
            // find the sourcerootpaths section
            //
            b = _SetupGetSourceFileLocation(
                    LayoutInfHandle,
                    NULL,
                    CopyParams->SourceFilename,
                    (Queue->Flags & FQF_USE_ALT_PLATFORM)
                       ? &(Queue->AltPlatformInfo)
                       : NULL,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    &tmpContext // location in SourceDisksFiles
                    );

            pContext = b ? &tmpContext : NULL;
        }
    }
    if(pContext) {
        //
        // now obtain the source id (file,*disk*,...)
        //
        SetupGetIntField(pContext,1,&SourceId);
    }

    //
    // if we have a NULL source path, then we should check 2 things:
    // 1) source flag information, which indicates if we have a service
    //    pack or CDM source location.
    // 2) if the relative source path is null, we'll go looking for
    //    a relative path in the inf file, just in case the caller didn't
    //    supply it
    //
    // note that we use the SourceFlagsSet item in the COPY_FILE structure
    // to optimize this path -- the first item contains the source flags,
    // and the second item indicates that we shouldn't bother looking for
    // any information, we've already done a search
    //
    if (CopyParams->SourceFlagsSet) {
        SourceFlags = CopyParams->SourceFlags;
    } else if (pContext && LayoutInfHandle) {
        TCHAR data[32];

        if(pSetupGetSourceInfo(LayoutInfHandle,
                               pContext,
                               SourceId,
                               (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                  ? &(Queue->AltPlatformInfo)
                                  : NULL,
                               SRCINFO_FLAGS,
                               data,
                               SIZECHARS(data),
                               NULL)) {

            pAToI(data,&SourceFlags);
        }
    }

    if (MediaFlags & SMI_FLAG_NO_SOURCE_ROOT_PATH) {
        if(pContext
           && LayoutInfHandle
           && !CopyParams->SourceFlagsSet
           && !SourcePath
           && pSetupGetSourceInfo(LayoutInfHandle,
                                  pContext,
                                  SourceId,
                                  (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                     ? &(Queue->AltPlatformInfo)
                                     : NULL,
                                  SRCINFO_PATH,
                                  TempSubDir,
                                  SIZECHARS(TempSubDir),
                                  NULL)) {

           SourcePath = TempSubDir;
        }
        //
        // override the system source path with the servicepack source path
        // if the flags are set
        //
        if (SourceFlags & SRC_FLAGS_SVCPACK_SOURCE) {
            MediaFlags |= SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH;
            SourceRootPath = ServicePackSourcePath;
            //
            // always safe to use SPCACHE in preference to SPROOT
            //
            CopyStyle |= PSP_COPY_USE_SPCACHE;
        }

        if(ServicePackCachePath) {
            //
            // anything in-box that doesn't specify SourceRootPath
            // really needs to be using SetupQueueCopyIndirect
            // we can't safely fix-up software that uses
            // SetupQueueCopy to copy in-box files
            //
            // this is no worse than the SRC_FLAGS_SVCPACK_SOURCE story
            //
            if(pContext) {
                if((((PLOADED_INF)pContext->CurrentInf)->OriginalInfName == NULL)
                   && !pSetupInfIsFromOemLocation( ((PLOADED_INF)pContext->CurrentInf)->VersionBlock.Filename,TRUE)) {
                    //
                    // consider getting this from SP CACHE instead
                    //
                    CopyStyle |= PSP_COPY_USE_SPCACHE;
                }
            }
        }
    }
    //
    // now determine tag file vs cab file
    //
    SourceTagfile = CopyParams->SourceTagfile;
    if (LayoutInfHandle && pContext && (SourceFlags & SRC_FLAGS_CABFILE)) {
        //
        // the given tagfile is really a cabfile, we may have optionally a real tagfile
        //
        SourceCabfile = CopyParams->SourceTagfile;
        if(SourceCabfile == NULL || SourceCabfile[0]==TEXT('\0')) {
            //
            // cab name hasn't been determined yet
            //
            if(pSetupGetSourceInfo(LayoutInfHandle,
                                   pContext,
                                   SourceId,
                                   (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                      ? &(Queue->AltPlatformInfo)
                                      : NULL,
                                   SRCINFO_TAGFILE,
                                   SourceCabfileBuffer,
                                   SIZECHARS(SourceCabfileBuffer),
                                   NULL
                                   )) {
                SourceCabfile = SourceCabfileBuffer;
            }
        }

        if(SourceCabfile == NULL || SourceCabfile[0]==TEXT('\0')) {
            //
            // cabfilename is erroneous
            //
            SourceCabfile = SourceTagfile = NULL;

        } else if(pSetupGetSourceInfo(LayoutInfHandle,
                               pContext,
                               SourceId,
                               (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                  ? &(Queue->AltPlatformInfo)
                                  : NULL,
                               SRCINFO_TAGFILE2,
                               SourceTagfile2Buffer,
                               SIZECHARS(SourceTagfile2Buffer),
                               NULL
                               )) {
            SourceTagfile = SourceTagfile2Buffer;
        }
    }

    //
    // Allocate a queue structure.
    //
    QueueNode = MyMalloc(sizeof(SP_FILE_QUEUE_NODE));
    if(!QueueNode) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // Operation is copy.
    //
    QueueNode->Operation = FILEOP_COPY;
    QueueNode->InternalFlags = 0;

    //
    // HACK ALERT!!! HACK HACK HACK!!!!
    //
    // There might be an override platform specified. If this is so,
    // we will look for \i386, \mips, etc as the final component of the
    // specified path, and replace it with the override path.
    // This is a TOTAL HACK.
    //
    try {
        EnterCriticalSection(&PlatformPathOverrideCritSect);
        locked = TRUE;
        if(PlatformPathOverride) {
            p = SourcePath ? SourcePath : SourceRootPath;
            if(LastPathPart = _tcsrchr(p,L'\\')) {
                LastPathPart++;
            } else {
                LastPathPart = p;
            }
#if defined(_AMD64_)
            if(!_tcsicmp(LastPathPart,TEXT("amd64"))) {
#elif defined(_X86_)
            //
            // NEC98
            //
            // During GUI setup, source path on local disk must be "nec98",
            // so we don't override "i386".
            //
            if (IsNEC98()) {
                HKEY    hKey;
                DWORD   DataType, DataSize;
                PTSTR   ForceOverride;
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\Setup"), 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
                    if (QueryRegistryValue(hKey, TEXT("ForcePlatform"), &ForceOverride, &DataType, &DataSize)
                        == NO_ERROR) {
                        ForcePlatform = TRUE;
                        MyFree(ForceOverride);
                    }
                    RegCloseKey(hKey);
                }
                // If use driver cache, There is not i386 driver cache on NEC98.
                if ((CopyStyle & PSP_COPY_USE_DRIVERCACHE) && !_tcsicmp(PlatformPathOverride,TEXT("i386"))) {
                    ForcePlatform = TRUE;
                }
            }
            if((!IsNEC98() && (!_tcsicmp(LastPathPart,TEXT("x86")) || !_tcsicmp(LastPathPart,TEXT("i386"))))
            || (IsNEC98()  && (!_tcsicmp(LastPathPart,TEXT("nec98")) && !ForcePlatform))) {
#elif defined(_IA64_)
            if(!_tcsicmp(LastPathPart,TEXT("ia64"))) {
#endif
                Size = (int)(LastPathPart - p);
                Size = min(Size,MAX_PATH-1);

                CopyMemory(TempBuffer,p,Size*sizeof(TCHAR));
                TempBuffer[Size] = 0;

                //
                // If the path was something like "mips" then TempBuffer
                // will be empty and we don't want to introduce any extra
                // backslashes.
                //
                if(*TempBuffer) {
                    pSetupConcatenatePaths(TempBuffer,PlatformPathOverride,MAX_PATH,NULL);
                } else {
                    lstrcpyn(TempBuffer,PlatformPathOverride,MAX_PATH);
                }

                if(SourcePath) {
                    SourcePath = TempBuffer;
                } else {
                    SourceRootPath = TempBuffer;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }
    if(locked) {
        LeaveCriticalSection(&PlatformPathOverrideCritSect);
    } else {
        //
        // if lock not grabbed, this is the cause
        //
        d = ERROR_NOT_ENOUGH_MEMORY;
    }
    if(d != NO_ERROR) {
        goto clean1;
    }

    if((CopyStyle & PSP_COPY_USE_SPCACHE) && ServicePackCachePath) {
        //
        // consider getting this from SP CACHE instead
        // overrides our decision to check/use drivercache
        // note that we will use whatever Tag/Cab file
        // we previously determined
        // just changing SourceRootPath
        //
        if(pIsFileInServicePackCache(CopyParams->SourceFilename,SourcePath)) {
            SourceRootPath = ServicePackCachePath;
            MediaFlags |= SMI_FLAG_USE_LOCAL_SPCACHE;
            SourceTagfile = ServicePackCachePath;
            SourceCabfile = NULL;
        }
    }

    //
    // check here if the cab-file is present on the disk.
    // if it isn't, then we fall back on the current
    // sourcerootpath
    //
    if ((CopyStyle & PSP_COPY_USE_DRIVERCACHE) && !(MediaFlags & SMI_FLAG_USE_LOCAL_SPCACHE)) {
        if (pIsDriverCachePresent(CopyParams->CacheName,
                                  SourcePath,
                                  DriverCache)) {
            SourceRootPath = DriverCache;
            MediaFlags |= SMI_FLAG_USE_LOCAL_SOURCE_CAB;
        }

        SourceTagfile = CopyParams->CacheName;
        SourceCabfile = NULL;
    }



    //
    // NOTE: When adding the following strings to the string table, we cast away
    // their CONST-ness to avoid a compiler warning.  Since we are adding them
    // case-sensitively, we are guaranteed they will not be modified.
    //
    try {
        //
        // Set up the source root path.
        //
        QueueNode->SourceRootPath = pSetupStringTableAddString(
                                        Queue->StringTable,
                                        (PTSTR)SourceRootPath,
                                        STRTAB_CASE_SENSITIVE
                                        );

        if(QueueNode->SourceRootPath == -1) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Set up the source path.
        //
        if(d == NO_ERROR) {
            if(SourcePath) {
                QueueNode->SourcePath = pSetupStringTableAddString(
                                            Queue->StringTable,
                                            (PTSTR)SourcePath,
                                            STRTAB_CASE_SENSITIVE
                                            );

                if(QueueNode->SourcePath == -1) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                QueueNode->SourcePath = -1;
            }
        }

        //
        // Set up the source filename.
        //
        if(d == NO_ERROR) {
            QueueNode->SourceFilename = pSetupStringTableAddString(
                                            Queue->StringTable,
                                            (PTSTR)CopyParams->SourceFilename,
                                            STRTAB_CASE_SENSITIVE
                                            );

            if(QueueNode->SourceFilename == -1) {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Set up the target directory.
        //
        if(d == NO_ERROR) {
            QueueNode->TargetDirectory = pSetupStringTableAddString(
                                            Queue->StringTable,
                                            (PTSTR)CopyParams->TargetDirectory,
                                            STRTAB_CASE_SENSITIVE
                                            );

            if(QueueNode->TargetDirectory == -1) {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Set up the target filename.
        //
        if(d == NO_ERROR) {
            QueueNode->TargetFilename = pSetupStringTableAddString(
                                            Queue->StringTable,
                                            (PTSTR)(CopyParams->TargetFilename ? CopyParams->TargetFilename
                                                                               : CopyParams->SourceFilename),
                                            STRTAB_CASE_SENSITIVE
                                            );

            if(QueueNode->TargetFilename == -1) {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Set up the Security Descriptor
        //
        if(d == NO_ERROR) {
            if( CopyParams->SecurityDescriptor){

                QueueNode->SecurityDesc = pSetupStringTableAddString(
                                              Queue->StringTable,
                                              (PTSTR)(CopyParams->SecurityDescriptor),
                                                STRTAB_CASE_SENSITIVE
                                                );

                if(QueueNode->SecurityDesc == -1) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                QueueNode->SecurityDesc = -1;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    if(d != NO_ERROR) {
        goto clean1;
    }

    //
    // Initialize a pointer to the end of the queue's current catalog info list.
    // We do this so that later, we can easily back-out our changes by truncating
    // the list after this node, and freeing all subsequent elements.
    //
    LastOldCatalogNode = Queue->CatalogList;
    if(LastOldCatalogNode) {
        while(LastOldCatalogNode->Next) {
            LastOldCatalogNode = LastOldCatalogNode->Next;
        }
    }

    //
    // Now process all members of our pLoadedInfs lists, adding each one to the
    // SPQ_CATALOG_INFO list (avoiding duplicates entries, of course).
    //
    for(i = 0; i < LoadedInfCount; i++) {

        for(pCurLoadedInf = pLoadedInfs[i]; pCurLoadedInf; pCurLoadedInf = pCurLoadedInf->Next) {
            //
            // First, get the (native) CatalogFile= entry from the version block
            // of this INF member.
            //
            if(pSetupGetCatalogFileValue(&(pCurLoadedInf->VersionBlock),
                                         TempBuffer,
                                         SIZECHARS(TempBuffer),
                                         NULL)) {

                l1 = pSetupStringTableAddString(Queue->StringTable,
                                          TempBuffer,
                                          STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                         );
                if(l1 == -1) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean2;
                }
            } else {
                //
                // This INF doesn't have a CatalogFile= entry.
                //
                l1 = -1;
            }

            //
            // If this file queue is currently setup for a platform override,
            // then retrieve that CatalogFile= entry as well.
            //
            if(Queue->Flags & FQF_USE_ALT_PLATFORM) {

                if(pSetupGetCatalogFileValue(&(pCurLoadedInf->VersionBlock),
                                             TempBuffer,
                                             SIZECHARS(TempBuffer),
                                             &(Queue->AltPlatformInfo))) {

                    l3 = pSetupStringTableAddString(Queue->StringTable,
                                              TempBuffer,
                                              STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                             );
                    if(l3 == -1) {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean2;
                    }
                } else {
                    //
                    // This INF doesn't have a CatalogFile= entry.
                    //
                    l3 = -1;
                }
            } else {
                //
                // We're not in a platform override scenario.
                //
                l3 = -1;
            }

            //
            // Now, get the INF's full path.
            //
            lstrcpyn(TempBuffer, pCurLoadedInf->VersionBlock.Filename, SIZECHARS(TempBuffer));
            l2 = pSetupStringTableAddString(Queue->StringTable,
                                      TempBuffer,
                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                     );
            if(l2 == -1) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto clean2;
            }

            //
            // Finally, retrieve the INF's original name, if different than the
            // current name.
            //
            if(pCurLoadedInf->OriginalInfName) {
                lstrcpyn(TempBuffer, pCurLoadedInf->OriginalInfName, SIZECHARS(TempBuffer));
                l4 = pSetupStringTableAddString(Queue->StringTable,
                                          TempBuffer,
                                          STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                         );
                if(l4 == -1) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean2;
                }

            } else {
                //
                // The INF's original name is the same as its current name.
                //
                l4 = -1;
            }

            b = TRUE;
            for(PrevCatalogNode=NULL, CatalogNode=Queue->CatalogList;
                CatalogNode;
                CatalogNode=CatalogNode->Next) {

                if(CatalogNode->InfFullPath == l2) {
                    //
                    // Already in there. No need to create a new node.
                    // Break out here, with CatalogNode pointing at the
                    // proper node for this catalog file.
                    //
                    // In this case, PrevCatalogNode should not be used later,
                    // but it shouldn't need to be used, since we won't be
                    // adding anything new onto the list of catalog nodes.
                    //
                    MYASSERT(CatalogNode->CatalogFileFromInf == l1);
                    MYASSERT(CatalogNode->InfOriginalName == l4);
                    b = FALSE;
                    break;
                }

                //
                // PrevCatalogNode will end up pointing to the final node
                // currently in the linked list, in the case where we need
                // to allocate a new node. This is useful so we don't have to
                // traverse the list again later when we add the new catalog
                // node to the list for this queue.
                //
                PrevCatalogNode = CatalogNode;
            }

            if(b) {
                //
                // Need to create a new catalog node.
                //
                CatalogNode = MyMalloc(sizeof(SPQ_CATALOG_INFO));
                if(!CatalogNode) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean2;
                }
                ZeroMemory(CatalogNode, sizeof(SPQ_CATALOG_INFO));
                CatalogNode->CatalogFileFromInf = l1;
                CatalogNode->InfFullPath = l2;
                CatalogNode->AltCatalogFileFromInf = l3;
                CatalogNode->InfOriginalName = l4;
                CatalogNode->AltCatalogFileFromInfPending = -1;
                CatalogNode->InfFinalPath = -1;
                //
                // Go ahead and link the new node into the list.  If we
                // encounter a failure later, we can easily back out of this by
                // truncating the list, since we know we always append, and we
                // remembered the original list tail.
                //
                if(Queue->CatalogList) {
                    PrevCatalogNode->Next = CatalogNode;
                } else {
                    Queue->CatalogList = CatalogNode;
                }

                //
                // We've successfully added a new, as yet unvalidated, catalog
                // node.  We must therefore reset the "catalog verifications
                // done" flags so that we'll redo them later.
                //
                Queue->Flags &= ~(FQF_DID_CATALOGS_OK | FQF_DID_CATALOGS_FAILED);
            }
        }
    }

    //
    // At this point, all the INFs involved in this installation (i.e., all INFs
    // in the HINFs we were passed in) have been added to our catalog info list,
    // if they weren't already present.  Now we need to figure out which one of
    // them should be associated with the file to be copied.
    //
    // Note that we want to get the CatalogFile= line from the actual inf
    // that contains source layout information for the file being queued.
    // If the layout inf handle references multiple append-loaded infs,
    // the simple mechanism of just looking up CatalogFile= in the [Version]
    // section using the given handle might give us the value from the
    // wrong inf.
    //
    // To deal with this, we attempt to locate the file in a [SourceDisksFiles]
    // section using the given inf handle, which gives us back a line context.
    // From the line context we can easily get at the [Version] section of the
    // actual inf where the file's layout info is contained.
    //
    // This handles all cases properly. For example, a file that is shipped by
    // a vendor that replaces one of our files. If the OEM's inf has a
    // SourceDisksFiles section with the file in it, it will be found first
    // when we look the file up using the given inf handle because of the way
    // inf append-loading works.
    //
    // If we cannot find the file in a [SourceDisksFiles] section (such as
    // if there is no such section), then we can't associate the file to be
    // copied with any INF/CAT.  If we do find a [SourceDisksFiles] entry, but
    // the containing INF doesn't specify a CatalogFile= entry, then we'll go
    // ahead and associate that with a SPQ_CATALOG_INFO node for that INF, but
    // that catalog info node will have a CatalogFileFromInf field of -1.
    // That's OK for system-provided INFs, but it will fail validation if it's
    // an OEM INF (this check is done later in _SetupVerifyQueuedCatalogs).
    //
    if(LayoutInfHandle || LayoutLineContext) {
        //
        // If we already have a valid layout line context, we don't need to go
        // looking for the file in [SourceDisksFiles] again (the caller is
        // assumed to have done that already). The caller might also have told
        // us that he *knows* that there is no [SourceDisksFiles] by passing us
        // a LayoutLineContext of -1.
        //
        if(LayoutLineContext == (PINFCONTEXT)(-1)) {
            //
            // For driver signing purposes, this may be an invalid file copy,
            // because it's being copied by an INF that contains no source
            // media information, nor does it use a layout file to supply such
            // information.
            //
            // Since we don't have a LayoutLineContext, we don't know exactly
            // which INF contained the CopyFile directive that initiated this
            // copy.  However, since the context is -1, that means that it was
            // INF based (i.e., as opposed to being manually queued up via
            // SetupQueueCopy).  Therefore, we scan all the INFs passed into
            // this routine (i.e., all the INFs in the pLoadedInfs lists), and
            // check to see if they're all located in %windir%\Inf.  If any of
            // them aren't, then we mark this copynode such that later it will
            // result in a signature verification failure of
            // ERROR_NO_CATALOG_FOR_OEM_INF.
            //
            for(i = 0; i < LoadedInfCount; i++) {

                for(pCurLoadedInf = pLoadedInfs[i]; pCurLoadedInf; pCurLoadedInf = pCurLoadedInf->Next) {

                    if(pSetupInfIsFromOemLocation(pCurLoadedInf->VersionBlock.Filename,
                                            TRUE)) {
                        //
                        // INF doesn't exist in %windir%\Inf--mark the copynode
                        // for codesigning verification failure.
                        //
                        QueueNode->InternalFlags |= IQF_FROM_BAD_OEM_INF;
                        break;
                    }

                    //
                    // Even if the INF does exist in %windir%\Inf, it might have
                    // originally been an OEM INF that was installed here--check
                    // its original filename to be sure...
                    //
                    if(pCurLoadedInf->OriginalInfName &&
                       pSetupInfIsFromOemLocation(pCurLoadedInf->OriginalInfName, TRUE)) {
                        //
                        // INF was an OEM INF--in this case, too, we need to
                        // mark the copynode for codesigning verification failure.
                        //
                        QueueNode->InternalFlags |= IQF_FROM_BAD_OEM_INF;
                        break;
                    }
                }

                if(QueueNode->InternalFlags & IQF_FROM_BAD_OEM_INF) {
                    //
                    // We found an OEM INF--no need to look any further.
                    //
                    break;
                }
            }

            LayoutLineContext = NULL;

        } else {
            if(!LayoutLineContext) {
                b = _SetupGetSourceFileLocation(
                        LayoutInfHandle,
                        NULL,
                        CopyParams->SourceFilename,
                        (Queue->Flags & FQF_USE_ALT_PLATFORM)
                           ? &(Queue->AltPlatformInfo)
                           : NULL,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        &LineContext
                        );

                LayoutLineContext = b ? &LineContext : NULL;
            }
        }
    }

    //
    // At this point, a non-NULL LayoutLineContext indicates that we found an
    // INF to associate with the file to be copied (via a [SourceDisksFiles]
    // entry).
    //
    if(LayoutLineContext) {

        pSetupGetPhysicalInfFilepath(LayoutLineContext,
                                     TempBuffer,
                                     SIZECHARS(TempBuffer)
                                    );

        l2 = pSetupStringTableAddString(Queue->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                 );
        //
        // This INF path should already be in the string table, and since we're
        // supplying a writeable buffer, there's no need for memory allocation.
        // Thus the addition of this string can't fail.
        //
        MYASSERT(l2 != -1);

        for(CatalogNode=Queue->CatalogList; CatalogNode; CatalogNode=CatalogNode->Next) {
            if(CatalogNode->InfFullPath == l2) {
                break;
            }
        }

        //
        // This node had better already be in the list!
        //
        MYASSERT(CatalogNode);

        QueueNode->CatalogInfo = CatalogNode;

    } else {
        //
        // There really is no catalog info.
        //
        QueueNode->CatalogInfo = NULL;
    }

    //
    // Unlock the INF(s) here, since the code below potentially returns without
    // hitting the final clean-up code at the bottom of the routine.
    //
    for(i = 0; i < LoadedInfCount; i++) {
        UnlockInf(pLoadedInfs[i]);
    }
    LoadedInfCount = 0;

    //
    // Set up the copy style flags
    //
    QueueNode->StyleFlags = CopyStyle;
    QueueNode->Next = NULL;

    //
    // Set up the source media.
    //
    try {
        Source = pSetupQueueSourceMedia(
                    Queue,
                    QueueNode,
                    QueueNode->SourceRootPath,
                    CopyParams->SourceDescription,
                    SourceTagfile,
                    SourceCabfile,
                    MediaFlags
                    );
        if(!Source) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    if(d != NO_ERROR) {
        goto clean2;
    }

    //
    // Link the node onto the end of the copy queue for this source media.
    //
    if(Source->CopyQueue) {
        //
        // Check to see if this same copy operation has already been enqueued
        // for this source media, and if so, get rid of the new one, to avoid
        // duplicates.  NOTE: We don't check the "InternalFlags" field, since
        // if the node already exists in the queue (based on all the other
        // fields comparing successfully), then any internal flags that were set
        // on the previously-existing node should be preserved.  (I.e., our new
        // node always is created with InternalFlags set to zero, except for
        // possibly IQF_FROM_BAD_OEM_INF, which we'll OR into the original
        // queue node's InternalFlags, if necessary.)
        //
        for(TempNode=Source->CopyQueue, PrevQueueNode = NULL;
            TempNode;
            PrevQueueNode = TempNode, TempNode=TempNode->Next) {

            if((TempNode->SourceRootPath == QueueNode->SourceRootPath) &&
               (TempNode->SourcePath == QueueNode->SourcePath) &&
               (TempNode->SourceFilename == QueueNode->SourceFilename) &&
               (TempNode->TargetDirectory == QueueNode->TargetDirectory) &&
               (TempNode->TargetFilename == QueueNode->TargetFilename) &&
               (TempNode->StyleFlags == QueueNode->StyleFlags) &&
               (TempNode->CatalogInfo == QueueNode->CatalogInfo)) {
                //
                // We have a duplicate.  OR in the IQF_FROM_BAD_OEM_INF flag
                // from our present queue node, if necessary, into the existing
                // queue node's InternalFlags.
                //
                if(QueueNode->InternalFlags & IQF_FROM_BAD_OEM_INF) {
                    TempNode->InternalFlags |= IQF_FROM_BAD_OEM_INF;
                }

                //
                // Now kill the newly-created queue node and return success.
                //
                MyFree(QueueNode);
                return TRUE;
            }
        }
        MYASSERT(PrevQueueNode);
        PrevQueueNode->Next = QueueNode;
    } else {
        Source->CopyQueue = QueueNode;
    }

    Queue->CopyNodeCount++;
    Source->CopyNodeCount++;

    return TRUE;

clean2:
    //
    // Truncate the catalog info node list at its original tail, and free all
    // subsequent (newly-added) nodes.
    //
    if(LastOldCatalogNode) {
        while(LastOldCatalogNode->Next) {
            CatalogNode = LastOldCatalogNode->Next;
            LastOldCatalogNode->Next = CatalogNode->Next;
            MyFree(CatalogNode);
        }
    }

clean1:
    MyFree(QueueNode);

clean0:
    for(i = 0; i < LoadedInfCount; i++) {
        UnlockInf(pLoadedInfs[i]);
    }

    SetLastError(d);
    return FALSE;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueCopyIndirectA(
    IN PSP_FILE_COPY_PARAMS_A CopyParams
    )
{
    SP_FILE_COPY_PARAMS_WEX copyParams;
    DWORD rc;
    BOOL b;

    ZeroMemory(&copyParams,sizeof(SP_FILE_COPY_PARAMS_W));
    rc = NO_ERROR;
    b = FALSE;

    try {
        if(CopyParams->cbSize == sizeof(SP_FILE_COPY_PARAMS_W)) {
            copyParams.QueueHandle = CopyParams->QueueHandle;
            copyParams.CopyStyle = CopyParams->CopyStyle;
            copyParams.LayoutInf = CopyParams->LayoutInf;
            copyParams.SecurityDescriptor = NULL;
        } else {
            rc = ERROR_INVALID_PARAMETER;
        }
        if((rc == NO_ERROR) && CopyParams->SourceRootPath) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->SourceRootPath,&copyParams.SourceRootPath);
        }
        if((rc == NO_ERROR) && CopyParams->SourcePath) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->SourcePath,&copyParams.SourcePath);
        }
        if((rc == NO_ERROR) && CopyParams->SourceFilename) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->SourceFilename,&copyParams.SourceFilename);
        }
        if((rc == NO_ERROR) && CopyParams->SourceDescription) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->SourceDescription,&copyParams.SourceDescription);
        }
        if((rc == NO_ERROR) && CopyParams->SourceTagfile) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->SourceTagfile,&copyParams.SourceTagfile);
        }
        if((rc == NO_ERROR) && CopyParams->TargetDirectory) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->TargetDirectory,&copyParams.TargetDirectory);
        }
        if((rc == NO_ERROR) && CopyParams->TargetFilename) {
            rc = pSetupCaptureAndConvertAnsiArg(CopyParams->TargetFilename,&copyParams.TargetFilename);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // This is to catch the case where the CopyParams pointer goes bad.
        //
        rc = ERROR_INVALID_PARAMETER;
    }

    if(rc == NO_ERROR) {

        copyParams.cbSize = sizeof(SP_FILE_COPY_PARAMS_WEX);

        b = _SetupQueueCopy(&copyParams, NULL, NULL);
        rc = GetLastError();
    }

    if(copyParams.SourceRootPath) {
        MyFree(copyParams.SourceRootPath);
    }
    if(copyParams.SourcePath) {
        MyFree(copyParams.SourcePath);
    }
    if(copyParams.SourceFilename) {
        MyFree(copyParams.SourceFilename);
    }
    if(copyParams.SourceDescription) {
        MyFree(copyParams.SourceDescription);
    }
    if(copyParams.SourceTagfile) {
        MyFree(copyParams.SourceTagfile);
    }
    if(copyParams.TargetDirectory) {
        MyFree(copyParams.TargetDirectory);
    }
    if(copyParams.TargetFilename) {
        MyFree(copyParams.TargetFilename);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueCopyIndirectW(
    IN PSP_FILE_COPY_PARAMS_W CopyParams
    )
{
    UNREFERENCED_PARAMETER(CopyParams);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueCopyIndirect(
    IN PSP_FILE_COPY_PARAMS CopyParams
    )
{
    BOOL b;
    SP_FILE_COPY_PARAMSEX copyParamsEx = {0};

    //
    // All work is done by an internal subroutine.
    // The only thing we need to do here is validate the size
    // of the structure we've been given by the caller.
    //
    try {
        b = (CopyParams->cbSize == sizeof(SP_FILE_COPY_PARAMS));
        if (b) {
            CopyMemory(&copyParamsEx,CopyParams,sizeof(SP_FILE_COPY_PARAMS));
            copyParamsEx.cbSize = sizeof(SP_FILE_COPY_PARAMSEX);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }

    if(b) {
        b = _SetupQueueCopy(&copyParamsEx, NULL, NULL);
    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueCopySectionA(
    IN HSPFILEQ QueueHandle,
    IN PCSTR    SourceRootPath,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,      OPTIONAL
    IN PCSTR    Section,
    IN DWORD    CopyStyle
    )
{
    PWSTR sourcerootpath;
    PWSTR section;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(SourceRootPath,&sourcerootpath);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }
    rc = pSetupCaptureAndConvertAnsiArg(Section,&section);
    if(rc != NO_ERROR) {
        MyFree(sourcerootpath);
        SetLastError(rc);
        return(FALSE);
    }

    b = SetupQueueCopySectionW(
            QueueHandle,
            sourcerootpath,
            InfHandle,
            ListInfHandle,
            section,
            CopyStyle
            );

    rc = GetLastError();

    MyFree(sourcerootpath);
    MyFree(section);

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueCopySectionW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourceRootPath,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,      OPTIONAL
    IN PCWSTR   Section,
    IN DWORD    CopyStyle
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(SourceRootPath);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(ListInfHandle);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(CopyStyle);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueueCopySection(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR   SourceRootPath,
    IN HINF     InfHandle,
    IN HINF     ListInfHandle,   OPTIONAL
    IN PCTSTR   Section,
    IN DWORD    CopyStyle
    )

/*++

Routine Description:

    Queue an entire section in an inf file for copy. The section must be
    in copy-section format and the inf file must contain [SourceDisksFiles]
    and [SourceDisksNames] sections.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    SourceRootPath - supplies the root directory for the intended source.
        This should be a sharepoint or a device root such as a:\ or g:\.

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] and [SourceDisksNames] sections, and, if
        ListInfHandle is not specified, contains the section names by Section.
        This handle must be for a win95-style inf.

    ListInfHandle - if specified, supplies a handle to an open inf file
        containing the section to be queued for copy. Otherwise InfHandle
        is assumed to contain the section.

    Section - supplies the name of the section to be queued for copy.

    CopyStyle - supplies flags that control the behavior of the copy operation
        for this file.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information. Some of the files may have been queued.

--*/

{
    BOOL b;
    INFCONTEXT LineContext;
    PCTSTR SourceFilename;
    PCTSTR TargetFilename;
    PCTSTR SecurityDescriptor = NULL;
    PCTSTR CacheName = NULL;
    UINT Flags;
    DWORD CopyStyleLocal;
    LONG LineCount;
    HINF CabInf = INVALID_HANDLE_VALUE;
    DWORD rc;

    //
    // Note that there are no potential faults here so no try/excepts
    // are necessary. pSetupQueueSingleCopy does all validation.
    //

    if(!ListInfHandle || (ListInfHandle == INVALID_HANDLE_VALUE)) {
        ListInfHandle = InfHandle;
    }

    //
    // Check for missing section
    //
    LineCount = SetupGetLineCount (ListInfHandle, Section);
    if(LineCount == -1) {
        rc = GetLastError();
        pSetupLogSectionError(ListInfHandle,NULL,NULL,QueueHandle,Section,MSG_LOG_NOSECTION_COPY,rc,NULL);
        SetLastError(ERROR_SECTION_NOT_FOUND); // maintain existing error code, log contains correct error code
        return(FALSE);
    }

    //
    // if section is empty, do nothing.
    //
    if(LineCount == 0) {
        return(TRUE);
    }

    //
    // The section has to exist and there has to be at least one line in it.
    //
    b = SetupFindFirstLine(ListInfHandle,Section,NULL,&LineContext);
    if(!b) {
        rc = GetLastError();
        pSetupLogSectionError(ListInfHandle,NULL,NULL,QueueHandle,Section,MSG_LOG_NOSECTION_COPY,rc,NULL);
        SetLastError(ERROR_SECTION_NOT_FOUND); // maintain existing error code, log contains correct error code
        return(FALSE);
    }

    //
    //Get the Security descriptor
    //

    if( !pSetupGetSecurityInfo( ListInfHandle, Section, &SecurityDescriptor ) )
        SecurityDescriptor = NULL;


    //
    // load driver cache inf
    //
    CabInf = SetupOpenInfFile( STR_DRIVERCACHEINF , NULL, INF_STYLE_WIN4, NULL );
    if (CabInf != INVALID_HANDLE_VALUE) {
        CopyStyle |= PSP_COPY_USE_DRIVERCACHE;
    }

    //
    // Iterate every line in the section.
    //
    do {
        CopyStyleLocal = CopyStyle;
        //
        // Get the target filename out of the line.
        // Field 1 is the target so there must be one for the line to be valid.
        //
        TargetFilename = pSetupFilenameFromLine(&LineContext,FALSE);
        if(!TargetFilename) {
            if (CabInf != INVALID_HANDLE_VALUE) {
                SetupCloseInfFile(CabInf);
            }
            try {
                if (QueueHandle != NULL
                    && QueueHandle != (HSPFILEQ)INVALID_HANDLE_VALUE
                    && ((PSP_FILE_QUEUE)QueueHandle)->Signature == SP_FILE_QUEUE_SIG) {

                    WriteLogEntry(
                        ((PSP_FILE_QUEUE)QueueHandle)->LogContext,
                        SETUP_LOG_ERROR,
                        MSG_LOG_COPY_TARGET,
                        NULL,
                        Section);
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
            }
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }

        //
        // Get source filename out of the line. If there is none, use
        // the target name as the source name.
        //
        SourceFilename = pSetupFilenameFromLine(&LineContext,TRUE);
        if(!SourceFilename || (*SourceFilename == 0)) {
            SourceFilename = TargetFilename;
        }

        //
        // if we were asked to use the driver cache, then check if the file
        // is in the associated INF for the cab.
        //
        if (CabInf != INVALID_HANDLE_VALUE) {
            if (!pIsFileInDriverCache(CabInf, SourceFilename, NULL, &CacheName)) {
                CopyStyleLocal &= ~PSP_COPY_USE_DRIVERCACHE;
            }
        }

        //
        // If present, flags are field 3.
        //
        if(SetupGetIntField(&LineContext,4,(PINT)&Flags)) {

            if(Flags & COPYFLG_WARN_IF_SKIP) {
                CopyStyleLocal |= SP_COPY_WARNIFSKIP;
            }

            if(Flags & COPYFLG_NOSKIP) {
                CopyStyleLocal |= SP_COPY_NOSKIP;
            }

            if(Flags & COPYFLG_NOVERSIONCHECK) {
                CopyStyleLocal &= ~SP_COPY_NEWER;
            }

            if(Flags & COPYFLG_FORCE_FILE_IN_USE) {
                CopyStyleLocal |= SP_COPY_FORCE_IN_USE;
                CopyStyleLocal |= SP_COPY_IN_USE_NEEDS_REBOOT;
            }

            if(Flags & COPYFLG_NO_OVERWRITE) {
                CopyStyleLocal |= SP_COPY_FORCE_NOOVERWRITE;
            }

            if(Flags & COPYFLG_NO_VERSION_DIALOG) {
                CopyStyleLocal |= SP_COPY_FORCE_NEWER;
            }

            if(Flags & COPYFLG_OVERWRITE_OLDER_ONLY) {
                CopyStyleLocal |= SP_COPY_NEWER_ONLY;
            }

            if(Flags & COPYFLG_REPLACEONLY) {
                CopyStyleLocal |= SP_COPY_REPLACEONLY;
            }

            if(Flags & COPYFLG_NODECOMP) {
                CopyStyleLocal |= SP_COPY_NODECOMP;
            }

            if(Flags & COPYFLG_REPLACE_BOOT_FILE) {
                CopyStyleLocal |= SP_COPY_REPLACE_BOOT_FILE;
            }

            if(Flags & COPYFLG_NOPRUNE) {
                CopyStyleLocal |= SP_COPY_NOPRUNE;
            }

        }

        b = pSetupQueueSingleCopy(
                QueueHandle,
                InfHandle,
                ListInfHandle,
                Section,
                SourceRootPath,
                SourceFilename,
                TargetFilename,
                CopyStyleLocal,
                SecurityDescriptor,
                CacheName
                );

        if (CacheName) {
            MyFree( CacheName );
            CacheName = NULL;
        }

        if(!b) {
            DWORD LastError = GetLastError();

            if (CabInf != INVALID_HANDLE_VALUE) {
                SetupCloseInfFile(CabInf);
            }

            SetLastError( LastError );

            return(FALSE);
        }
    } while(SetupFindNextLine(&LineContext,&LineContext));

    if (CabInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(CabInf);
    }
    return(TRUE);
}


BOOL
pSetupQueueSingleCopy(
    IN HSPFILEQ    QueueHandle,
    IN HINF        InfHandle,
    IN HINF        ListInfHandle,  OPTIONAL
    IN PCTSTR      SectionName,    OPTIONAL
    IN PCTSTR      SourceRootPath,
    IN PCTSTR      SourceFilename,
    IN PCTSTR      TargetFilename,
    IN DWORD       CopyStyle,
    IN PCTSTR      SecurityDescriptor,
    IN PCTSTR      CacheName
    )

/*++

Routine Description:

    Add a single file to the copy queue, using the default source media
    and destination as specified in an inf file.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] and [SourceDisksNames] sections.
        This handle must be for a win95-style inf.

    ListInfHandle - if specified, supplies handle to the inf in which
        the file being copied appears (such as in a file copy list section).
        If not specified, this is assumed to be the same inf as InfHandle.

    SourceRootPath - supplies the root directory for the intended source.
        This should be a sharepoint or a device root such as a:\ or g:\.

    SourceFilename - supplies the filename of the source file. Filename part
        only.

    TargetFilename - supplies t