maNamespace(useNS, _xns.Assem);
					String ns = methodXns.Namespace;
					String nsPrefix = methodXns.Prefix;
					for (int i=0;i<_methods.Length;i++)
					{
						MethodInfo method = _methods[i];
						bool bOneWay = RemotingServices.IsOneWay(method);
						String methodName = method.Name;
						sb.Length = 0;
						sb.Append(indent1);
						if (bOneWay)
							sb.Append("<oneway name='");
						else
							sb.Append("<requestResponse name='");
						sb.Append(methodName);
						sb.Append("'>");
						textWriter.WriteLine(sb);                       
						sb.Length = 0;
						sb.Append(indent2);
						sb.Append("<soap:operation soapAction='");

						String soapAction = SoapServices.GetSoapActionFromMethodBase(method);
						if ((soapAction != null) || (soapAction.Length > 0))
						{
							sb.Append(soapAction);
						}
						else
						{
							sb.Append(ns);
							sb.Append('#');
							sb.Append(methodName);
						}
						sb.Append("'/>");
						textWriter.WriteLine(sb);

						sb.Length = 0;
						sb.Append(indent2);
						sb.Append("<request ref='");
						sb.Append(nsPrefix);
						sb.Append(':');
						sb.Append(_methodTypes[2*i]);
						sb.Append("'/>");
						textWriter.WriteLine(sb);

						if (!bOneWay)
						{
							sb.Length = 0;
							sb.Append(indent2);
							sb.Append("<response ref='");
							sb.Append(nsPrefix);
							sb.Append(':');
							sb.Append(_methodTypes[2*i+1]);
							sb.Append("'/>");
							textWriter.WriteLine(sb);
						}

						textWriter.Write(indent1);
						if (bOneWay)
							textWriter.WriteLine("</oneway>");
						else
							textWriter.WriteLine("</requestResponse>");
					}
				}

				if ((_typeToServiceEndpoint != null) && (_typeToServiceEndpoint.ContainsKey(_type.Name)))
				{
					textWriter.Write(indent1);
					textWriter.WriteLine("<addresses>");
					foreach (String url in (ArrayList)_typeToServiceEndpoint[_type.Name])
					{
						sb.Length = 0;
						sb.Append(indent2);
						sb.Append("<address uri='");
						sb.Append(url);
						sb.Append("'/>");
						textWriter.WriteLine(sb);
					}
					textWriter.Write(indent1);
					textWriter.WriteLine("</addresses>");
				}
				else if (_serviceEndpoint != null)
				{
					textWriter.Write(indent1);
					textWriter.WriteLine("<addresses>");
					sb.Length = 0;
					sb.Append(indent2);
					sb.Append("<address uri='");
					sb.Append(_serviceEndpoint);
					sb.Append("'/>");
					textWriter.WriteLine(sb);
					textWriter.Write(indent1);
					textWriter.WriteLine("</addresses>");
				}

				textWriter.Write(indent);
				textWriter.WriteLine(_type.IsInterface ? "</interface>" : "</service>");
				return;
			}

			internal static String TypeName(Type type, bool bEmbedded, XMLNamespace thisxns)
			{
				Util.Log("RealSchemaType.TypeName "+type+" bEmbedded "+bEmbedded);              
				String typeName;
				Type uType;
				if (type.HasElementType && ((uType = type.GetElementType()) != null))
				{
					while (uType.HasElementType)
						uType = uType.GetElementType();
					String uTypeName = TypeName(uType, type.IsArray, thisxns);
					String suffix = type.Name.Substring(uType.Name.Length);
					// Escape the compiler warning
					typeName = " suds:refType='";
					if (type.IsArray)
					{
						StringBuilder sb = new StringBuilder(256);
						if (bEmbedded)
							sb.Append("soap:Array'");
						else
							sb.Append("soap:Reference'");
						sb.Append(typeName);
						sb.Append(uTypeName);
						sb.Append(suffix);
						typeName = sb.ToString();
					}
					else if (type.IsByRef)
					{
						typeName = uTypeName;
					}
					else if (type.IsPointer)
					{
						typeName = uTypeName;
					}
					else
					{
						Debug.Assert(false, "Should not have reached here");
					}
				}
				else if (type.IsPrimitive)
				{
					typeName = "xsd:" + MapURTTypesToSchemaTypes(type.Name);
				}
				else if (type.FullName == "System.String")
				{
					typeName = "xsd:string";
				}
				else if (type.FullName == "System.Object")
				{
					if (bEmbedded)
						typeName = "xsd:ur-type"; //null;
					else
						typeName = "soap:Reference' suds:refType='xsd:ur-type";
				}
				else if (type.FullName == "System.Void")
				{
					typeName = "void";
				}
				else
				{
					String ns = type.Namespace;
					Assembly assem = type.Module.Assembly;
					XMLNamespace xns = thisxns.LookupSchemaNamespace(ns, assem);
					StringBuilder sb = new StringBuilder(256);
					if (bEmbedded == false && type.IsValueType == false)
						sb.Append("soap:Reference' suds:refType='");
					sb.Append(xns.Prefix);
					sb.Append(':');
					sb.Append(type.Name);
					typeName = sb.ToString();
				}

				return(typeName);
			}

			static private Type[] GetIntroducedInterfaces(Type type)
			{
				Util.Log("RealSchemaType.GetIntroducedInterfaces "+type);               
				// Count of all implemented interfaces
				Type[] intfs = type.GetInterfaces();
				int actualLength = intfs.Length;
				if (actualLength == 0)
					return(emptyTypeSet);
				if (type.IsInterface == false)
				{
					// Remove the interfaces implemented by its base type
					Type[] baseIntfs = type.BaseType.GetInterfaces();
					for (int i=0;i<baseIntfs.Length;i++)
					{
						for (int j=0;j<intfs.Length;j++)
						{
							if (intfs[j] == baseIntfs[i])
							{
								--actualLength;
								intfs[j] = intfs[actualLength];
								intfs[actualLength] = null;
								break;
							}
						}
					}
				}

				// Remove interfaces implemented by the given type
				// through interface inheritence
				for (int i=0;i<actualLength;i++)
				{
					Type[] inheritedIntfs = intfs[i].GetInterfaces();
					for (int j=0;j<inheritedIntfs.Length;j++)
					{
						for (int k=0;k<actualLength;k++)
						{
							if (intfs[k] == inheritedIntfs[j])
							{
								if (k <= i)
								{
									intfs[k] = intfs[i];
									k = i;
									--i;
								}
								--actualLength;
								intfs[k] = intfs[actualLength];
								intfs[actualLength] = null;
								break;
							}
						}
					}
				}

				for (int i=0;i<intfs.Length;i++)
				{
					if (i < actualLength)
						Debug.Assert(intfs[i] != null, "Invariant failure");
					else
						Debug.Assert(intfs[i] == null, "Invariant failure");
				}

				if (actualLength < intfs.Length)
				{
					//Array.Clear(intfs, actualLength, intfs.Length - actualLength);
					Type[] iFaces = new Type[actualLength];
					Array.Copy(intfs, iFaces, actualLength);
					return(iFaces);
				}

				return(intfs);
			}

			static private MethodInfo[] GetIntroducedMethods(Type type)
			{
				Util.Log("RealSchemaType.GetIntroducedMethods "+type);                              
				// Count of implemented methods
				BindingFlags bFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance |
									  BindingFlags.Public; // | BindingFlags.NonPublic;
				MethodInfo[] methods = type.GetMethods(bFlags);
				int actualLength = methods.Length;
				if (actualLength == 0)
					return(emptyMethodSet);
				if (type.IsInterface)
					return(methods);

				// Eliminate interface methods
				Type[] iFaces = type.GetInterfaces();
				for (int i=0;i<iFaces.Length;i++)
				{
					InterfaceMapping map = type.GetInterfaceMap(iFaces[i]);
					for (int j=0;j<map.TargetMethods.Length;j++)
					{
						for (int k=0;k<actualLength;k++)
						{
							if (methods[k] == map.TargetMethods[j])
							{
								--actualLength;
								methods[k] = methods[actualLength];
								methods[actualLength] = null;
								break;
							}
						}
					}
				}

				if (actualLength < methods.Length)
				{
					MethodInfo[] imethods = new MethodInfo[actualLength];
					Array.Copy(methods, imethods, actualLength);
					return(imethods);
				}

				return(methods);
			}

			static private FieldInfo[] GetInstanceFields(Type type)
			{
				Util.Log("RealSchemaType.GetIntroducedFields "+type);                               
				BindingFlags bFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance |
									  BindingFlags.Public | BindingFlags.NonPublic;
				FieldInfo[] fields = type.GetFields(bFlags);
				int actualLength = fields.Length;
				if (actualLength == 0)
					return(emptyFieldSet);

				for (int i=0;i<fields.Length;i++)
				{
					if (fields[i].IsStatic)
					{
						Debug.Assert(false, "Static Field");
						--actualLength;
						fields[i] = fields[actualLength];
						fields[actualLength] = null;
					}
				}

				if (actualLength < fields.Length)
				{
					FieldInfo[] ifields = new FieldInfo[actualLength];
					Array.Copy(fields, ifields, actualLength);
					return(ifields);
				}

				return(fields);
			}

			// Instance fields
			private Type _type;
			private String _serviceEndpoint;
			private Hashtable _typeToServiceEndpoint;
			private bool _bUnique;
			private XMLNamespace _xns;
			private bool _bStruct;
			private String[] _implIFaces;

			private Type[] _iFaces;
			private MethodInfo[] _methods;
			private String[] _methodTypes;
			private FieldInfo[] _fields;

			// Static fields
			private static Type[] emptyTypeSet = new Type[0];
			private static MethodInfo[] emptyMethodSet = new MethodInfo[0];
			private static FieldInfo[] emptyFieldSet = new FieldInfo[0];
		} // End RealSchema

		private class XMLNamespace
		{
			internal XMLNamespace(String name, Assembly assem, String serviceEndpoint, Hashtable typeToServiceEndpoint, String prefix, bool bInteropType)
			{
				Util.Log("XMLNamespace.XMLNamespace "+name+" serviceEndpoint "+serviceEndpoint+" prefix "+prefix+" bInteropType "+bInteropType);
				_name = name;
				_assem = assem;
				_bUnique = false;
				_bInteropType = bInteropType;
				StringBuilder sb = new StringBuilder(256);
				Assembly systemAssembly = typeof(String).Module.Assembly;

				if (assem == systemAssembly)
				{
					sb.Append(SoapServices.CodeXmlNamespaceForClrTypeNamespace(name, null));
					//sb.Append("http://Schemas.microsoft.com/urt/NS/");
					//sb.Append(name);
				}
				else if (assem != null)
				{
					sb.Append(SoapServices.CodeXmlNamespaceForClrTypeNamespace(name, assem.GetName().Name));
					/*
					if (name == null || name.Length == 0)
					{
					sb.Append("http://Schemas.microsoft.com/urt/Assem/");
					}
					else
					{
					sb.Append("http://Schemas.microsoft.com/urt/NSAssem/");
					sb.Append(name);
					sb.Append('/');
					}

					sb.Append(assem.GetName().Name);
*/
				}
				else
				{
					sb.Append(name);
				}

				_namespace = sb.ToString();
				_prefix = prefix;
				_dependsOnSchemaNS = new ArrayList();
				_realSUDSTypes = new ArrayList();
				_dependsOnSUDSNS = new ArrayList();
				_realSchemaTypes = new ArrayList();
				_phonySchemaTypes = new ArrayList();
				_simpleSchemaTypes = new ArrayList();
				_serviceEndpoint = serviceEndpoint;
				_typeToServiceEndpoint = typeToServiceEndpoint;
			}


			internal String Name
			{
				get { return(_name);}
			}
			internal Assembly Assem
			{
				get { return(_assem);}
			}
			internal String Prefix
			{
				get { return(_prefix);}
			}
			internal String Namespace
			{
				get { return(_namespace);}
			}

			internal bool IsInteropType
			{
				get {return(_bInteropType);}
			}


			internal Type LookupSchemaType(String name)
			{
				Util.Log("XMLNamespace.LookupSchemaType "+name);
				RealSchemaType rsType = LookupRealSchemaType(name);
				if (rsType != null)
					return(rsType.Type);

				SimpleSchemaType ssType = LookupSimpleSchemaType(name);
				if (ssType != null)
					return(ssType.Type);

				return(null);
			}

			internal SimpleSchemaType LookupSimpleSchemaType(String name)
			{
				Util.Log("XMLNamespace.LookupSimpleSchemaType "+name);              
				for (int i=0;i<_simpleSchemaTypes.Count;i++)
				{
					SimpleSchemaType ssType = (SimpleSchemaType) _simpleSchemaTypes[i];
					if (ssType.Type.Name == name)
						return(ssType);
				}

				return(null);
			}

			internal RealSchemaType LookupRealSchemaType(String name)
			{
				Util.Log("XMLNamespace.LookupRealSchemaType "+name);                                
				Debug.Assert(_phonySchemaTypes.Count == 0, "PhonyTypes present");
				for (int i=0;i<_realSchemaTypes.Count;i++)
				{
					RealSchemaType rsType = (RealSchemaType) _realSchemaTypes[i];
					if (rsType.Name == name)
						return(rsType);
				}

				return(null);
			}

			internal void AddRealSUDSType(RealSchemaType rsType)
			{
				Util.Log("XMLNamespace.AddRealSUDSType ");                              
				_realSUDSTypes.Add(rsType);
				return;
			}

			internal void AddRealSchemaType(RealSchemaType rsType)
			{
				Debug.Assert(LookupRealSchemaType(rsType.Name) == null, "Duplicate Type found");
				_realSchemaTypes.Add(rsType);
				if (rsType.IsUnique)
					_bUnique = true;

				return;
			}

			internal void AddSimpleSchemaType(SimpleSchemaType ssType)
			{
				Util.Log("XMLNamespace.AddSimpleSchemaType ");                              
				Debug.Assert(LookupSimpleSchemaType(ssType.Type.Name) == null, "Duplicate Type found");
				_simpleSchemaTypes.Add(ssType);

				return;
			}

			private PhonySchemaType LookupPhonySchemaType(String name)
			{
				Util.Log("XMLNamespace.LookupPhonySchemaType "+name);                                               
				for (int i=0;i<_phonySchemaTypes.Count;i++)
				{
					PhonySchemaType type = (PhonySchemaType) _phonySchemaTypes[i];
					if (type.Name == name)
						return(type);
				}

				return(null);
			}

			internal void AddPhonySchemaType(PhonySchemaType phType)
			{
				Util.Log("XMLNamespace.AddPhonySchemaType ");                                                               
				PhonySchemaType overloadedType = LookupPhonySchemaType(phType.Name);
				if (overloadedType != null)
					phType.ElementName = phType.Name + overloadedType.OverloadedType();
				_phonySchemaTypes.Add(phType);

				return;
			}

			internal XMLNamespace LookupSchemaNamespace(String ns, Assembly assem)
			{
				Util.Log("XMLNamespace.LookupSchemaNamespace "+ns);                                                             
				for (int i=0;i<_dependsOnSchemaNS.Count;i++)
				{
					XMLNamespace xns = (XMLNamespace) _dependsOnSchemaNS[i];
					if ((xns.Name == ns) && (xns.Assem == assem))
						return(xns);
				}

				return(null);
			}

			internal void DependsOnSchemaNS(XMLNamespace xns)
			{
				Util.Log("XMLNamespace.DependsOnSchemaNS ");                                                                
				if (LookupSchemaNamespace(xns.Name, xns.Assem) != null)
					return;

				_dependsOnSchemaNS.Add(xns);
				return;
			}

			private XMLNamespace LookupSUDSNamespace(String ns, Assembly assem)
			{
				Util.Log("XMLNamespace.LookupSUDSNamespace "+ns);                                                               
				for (int i=0;i<_dependsOnSUDSNS.Count;i++)
				{
					XMLNamespace xns = (XMLNamespace) _dependsOnSUDSNS[i];
					if ((xns.Name == ns) && (xns.Assem == assem))
						return(xns);
				}

				return(null);
			}

			internal void DependsOnSUDSNS(XMLNamespace xns)
			{
				Util.Log("XMLNamespace.DpendsOnSUDSNS "+xns.Name+" "+xns.Assem);
				if (LookupSUDSNamespace(xns.Name, xns.Assem) != null)
					return;

				_dependsOnSUDSNS.Add(xns);
				return;
			}

			internal void Resolve()
			{
				Util.Log("XMLNamespace.Resolve");                                                               
				StringBuilder sb = new StringBuilder(256);
				for (int i=0;i<_realSchemaTypes.Count;i++)
					((RealSchemaType) _realSchemaTypes[i]).Resolve(sb);

				return;
			}

			internal void PrintDependsOn(TextWriter textWriter, StringBuilder sb, String indent)
			{
				if (_realSchemaTypes.Count > 0 ||
					  _phonySchemaTypes.Count > 0 ||
					  _simpleSchemaTypes.Count > 0)
				{
					Util.Log("XMLNamespace.PrintDependsOn "+_name+" targetNameSpace "+Namespace);                                                                                                   
					if (_dependsOnSchemaNS.Count > 0)
					{
						for (int i=0;i<_dependsOnSchemaNS.Count;i++)
						{
							XMLNamespace xns = (XMLNamespace) _dependsOnSchemaNS[i];
							sb.Length = 0;
							sb.Append(indent);
							sb.Append("xmlns:");                            
							sb.Append(xns.Prefix);
							sb.Append("='");
							sb.Append(xns.Namespace);
							sb.Append("'");
							textWriter.WriteLine(sb);
						}
					}
				}
			}

			internal void PrintSdl(TextWriter textWriter, String indent)
			{
				Util.Log("XMLNamespace.PrintSdl ");
				StringBuilder sb = new StringBuilder(256);
				String endSuds = null;

				sb.Append(indent);
				// Print suds types
				if (_realSUDSTypes.Count > 0)
				{
					//endSuds = indentation + "</suds>";
					endSuds = indent + "</soap>";
					indent = IndentP(indent);
					if (_bUnique)
					{
						sb.Append("<soap xmlns='urn:schemas-xmlsoap-org:soap-sdl-2000-01-25'");
					}
					else
					{
						//sb.Append("<suds targetNamespace='");
						sb.Append("<soap targetNamespace='");
						sb.Append(Namespace);
						sb.Append('\'');
						textWriter.WriteLine(sb);

						sb.Length = 0;
						sb.Append(indent);
						//sb.Append("xmlns='urn:schemas-xmlsoap-org:suds.v1'");
						sb.Append("xmlns='urn:schemas-xmlsoap-org:soap-sdl-2000-01-25'");
					}
					textWriter.WriteLine(sb);

					sb.Length = 0;
					sb.Append(indent);
					sb.Append("xmlns:soap='urn:schemas-xmlsoap-org:soap.v1'");
					textWriter.WriteLine(sb);

					for (int i=0;i<_dependsOnSUDSNS.Count;i++)
					{
						XMLNamespace xns = (XMLNamespace) _dependsOnSUDSNS[i];
						sb.Length = indent.Length;
						sb.Append("xmlns:");
						sb.Append(xns.Prefix);
						sb.Append("='");
						sb.Append(xns.Namespace);
						if (i == _dependsOnSUDSNS.Count-1)
							sb.Append("'>");
						else
							sb.Append('\'');

						textWriter.WriteLine(sb);
					}

					for (int i=0;i<_realSUDSTypes.Count;i++)
						((RealSchemaType) _realSUDSTypes[i]).PrintSUDSType(textWriter, sb, indent);

				}

				bool bReal = false;
				for (int i=0;i<_realSchemaTypes.Count;i++)
				{
					RealSchemaType rsType = (RealSchemaType) _realSchemaTypes[i];
					if (!rsType.Type.IsInterface && !rsType.IsSUDSType)
						bReal = true;
				}

				// Print schema types
				if ( bReal ||
					 _phonySchemaTypes.Count > 0 ||
					 _simpleSchemaTypes.Count > 0)
				{

					sb.Length = indent.Length;
					sb.Append("<schema targetNamespace='");
					sb.Append(Namespace);
					sb.Append('\'');
					textWriter.WriteLine(sb);

					String endSchema = indent + "</schema>";
					indent = IndentP(indent);

					sb.Length = 0;
					sb.Append(indent);
					sb.Append("xmlns='http://www.w3.org/2000/10/XMLSchema'");
					textWriter.WriteLine(sb);

					sb.Length = 0;
					sb.Append(indent);
					sb.Append("xmlns:xsd='http://www.w3.org/2000/10/XMLSchema'");
					textWriter.WriteLine(sb);

					sb.Length = indent.Length;
					sb.Append("xmlns:xsi='http://www.w3.org/2000/10/XMLSchema-instance'");
					textWriter.WriteLine(sb);

					sb.Length = indent.Length;
					//sb.Append("xmlns:suds='urn:schemas-xmlsoap-org:suds.v1'");
					sb.Append("xmlns:suds='urn:schemas-xmlsoap-org:soap-sdl-2000-01-25'");
					textWriter.WriteLine(sb);

					sb.Length = indent.Length;
					sb.Append("xmlns:soap='urn:schemas-xmlsoap-org:soap.v1'");
					textWriter.Write(sb);

					if (_dependsOnSchemaNS.Count > 0)
					{
						sb.Length = 0;
						sb.Append(textWriter.NewLine);
						sb.Append(indent);
						sb.Append("xmlns:");
						String cachedString = sb.ToString();
						for (int i=0;i<_dependsOnSchemaNS.Count;i++)
						{
							XMLNamespace xns = (XMLNamespace) _dependsOnSchemaNS[i];
							sb.Length = cachedString.Length;
							sb.Append(xns.Prefix);
							sb.Append("='");
							sb.Append(xns.Namespace);
							sb.Append('\'');
							textWriter.Write(sb);
						}
					}
					textWriter.WriteLine(" elementFormDefault='unqualified' attributeFormDefault='unqualified'>");

					for (int i=0;i<_simpleSchemaTypes.Count;i++)
					{
						SimpleSchemaType ssType = (SimpleSchemaType) _simpleSchemaTypes[i];
						ssType.PrintSchemaType(textWriter, sb, indent, false);
					}

					for (int i=0;i<_realSchemaTypes.Count;i++)
					{
						RealSchemaType rsType = (RealSchemaType) _realSchemaTypes[i];
						if (!rsType.Type.IsInterface && !rsType.IsSUDSType)
							rsType.PrintSchemaType(textWriter, sb, indent, false);
					}

					for (int i=0;i<_phonySchemaTypes.Count;i++)
					{
						PhonySchemaType psType = (PhonySchemaType) _phonySchemaTypes[i];
						psType.PrintSchemaType(textWriter, sb, indent, true);
					}

					textWriter.WriteLine(endSchema);
				}

				if (endSuds != null)
					textWriter.WriteLine(endSuds);

				return;
			}

			// Fields
			private String _name;
			private Assembly _assem;
			private String _namespace;
			private String _prefix;
			private bool _bUnique;
			private ArrayList _dependsOnSUDSNS;
			private ArrayList _realSUDSTypes;
			private ArrayList _dependsOnSchemaNS;
			private ArrayList _realSchemaTypes;
			private ArrayList _phonySchemaTypes;
			private ArrayList _simpleSchemaTypes;
			private bool _bInteropType;
			private String _serviceEndpoint;
			private Hashtable _typeToServiceEndpoint;

		}

		internal static String IndentP(String indentStr)
		{
			return indentStr+"    ";
		}

		internal static String IndentM(String indentStr)
		{
			return indentStr.Substring(0, indentStr.Length-4);
		}
		}
		}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\smtp\adodb.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ADODB.cs
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: Implements ADODB interfaces that are used by Smtp to
**          deliver mail messages.
**          
**
** Date:    October 12, 2000
**
===========================================================*/

using System.Runtime.InteropServices;
using System.Reflection;
using System.Collections;

namespace System.Runtime.Remoting.Channels.Smtp
{
    /*
        [
          uuid(00000569-0000-0010-8000-00AA006D2EA4),
          helpcontext(0x0012c908),
          dual,
          nonextensible
        ]
     */
    /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field"]/*' />
    [     
     ComImport,
     Guid("00000569-0000-0010-8000-00AA006D2EA4"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)
    ]
    public interface Field
    {
        
        /*
            [id(0x000001f4), propget, helpcontext(0x0012c900)]
            Properties* Properties();
         */
        
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Properties"]/*' />
        Object Properties
        {
            get;
        }

        /*
            [id(0x00000455), propget, helpcontext(0x0012c90c)]
            long ActualSize();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.ActualSize"]/*' />
        long ActualSize
        {
            get;
        }
        
        /*
            [id(0x0000045a), propget, helpcontext(0x0012c90d)]
            long Attributes();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Attributes_One"]/*' />
        long Attributes_One
        {
            get;
        }

        /*
            [id(0x0000044f), propget, helpcontext(0x0012c91e)]
            long DefinedSize();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.DefinedSize_One"]/*' />
        long DefinedSize_One
        {
            get;
        }

        /*
            [id(0x0000044c), propget, helpcontext(0x0012c92f)]
            BSTR Name();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Name"]/*' />
        String Name
        {
            get;
        }

        /*
            [id(0x0000044e), propget, helpcontext(0x0012c94a)]
            DataTypeEnum Type();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Type_One"]/*' />
        Object Type_One
        {
            get;
        }
        
        /*
            [id(00000000), propget, helpcontext(0x0012c94d)]
            VARIANT Value();
         */
        /*
            [id(00000000), propput, helpcontext(0x0012c94d)]
            void Value([in] VARIANT rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Value"]/*' />
        Object Value
        {
            get;

            set;
        }

        /*
            [id(0x00000458), propget, helpcontext(0x0012c938)]
            unsigned char Precision();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Precision_One"]/*' />
        char Precision_One
        {
            get;
        }

        /*
            [id(0x00000459), propget, helpcontext(0x0012c932)]
            unsigned char NumericScale();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.NumericScale_One"]/*' />
        char NumericScale_One
        {
            get;
        }

        /*
            [id(0x00000453), helpcontext(0x0012c8b6)]
            void AppendChunk([in] VARIANT Data);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.AppendChunk"]/*' />
        void AppendChunk(Object o);

        /*
            [id(0x00000454), helpcontext(0x0012c8ce)]
            VARIANT GetChunk([in] long Length);
        */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.GetChunk"]/*' />
        Object GetChunk(long length);

        /*
            [id(0x00000450), propget, helpcontext(0x0012c934)]
            VARIANT OriginalValue();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.OriginalValue"]/*' />
        Object OriginalValue
        {
            get;
        }

        /*
            [id(0x00000451), propget, helpcontext(0x0012c94b)]
            VARIANT UnderlyingValue();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.UnderlyingValue"]/*' />
        Object UnderlyingValue
        {
            get;
        }

        /*
            [id(0x0000045b), propget]
            IUnknown* DataFormat();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.DataFormat_One"]/*' />
        Object DataFormat_One();

        /*
            [id(0x0000045b), propputref]
            void DataFormat([in] IUnknown* rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.DataFormat_Two"]/*' />
        Object DataFormat_Two
        {
            set;
        }

        /*
            [id(0x00000458), propput, helpcontext(0x0012c938)]
            void Precision([in] unsigned char rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Precision_Two"]/*' />
        char Precision_Two
        {
            set;
        }

        /*
            [id(0x00000459), propput, helpcontext(0x0012c932)]
            void NumericScale([in] unsigned char rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.NumericScale_Two"]/*' />
        char NumericScale_Two
        {
            set;
        }
        
        /*
            [id(0x0000044e), propput, helpcontext(0x0012c94a)]
            void Type([in] DataTypeEnum rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Type_Two"]/*' />
        Object Type_Two
        {
            set;
        }

        /*
            [id(0x0000044f), propput, helpcontext(0x0012c91e)]
            void DefinedSize([in] long rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.DefinedSize_Two"]/*' />
        long DefinedSize_Two
        {
            set;
        }

        /*
            [id(0x0000045a), propput, helpcontext(0x0012c90d)]
            void Attributes([in] long rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Attributes_Two"]/*' />
        long Attributes_Two
        {
            set;
        }

        /*
            [id(0x0000045c), propget, helpcontext(0x0012c90e)]
            long Status();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Status"]/*' />
        long Status
        {
            get;
        }
     }


    /*
        [
            uuid(00000564-0000-0010-8000-00AA006D2EA4),
            helpcontext(0x0012c8fe),
            dual,
            nonextensible
        ]
    */
    /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields"]/*' />
    [     
     ComImport,
     Guid("00000564-0000-0010-8000-00AA006D2EA4"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)
     //DefaultMemberAttribute("Item")
    ]
    public interface Fields
    {

       /*
            [id(0x00000001), propget, helpcontext(0x0012c91a)]
            long Count();
        */        
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Count"]/*' />
        long Count
        {
            get;
        }
        
        /*
            [id(0xfffffffc), restricted]
            IUnknown* _NewEnum();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.GetEnumerator"]/*' />
        IEnumerator GetEnumerator();
        
        /*
            [id(0x00000002), helpcontext(0x0012c8da)]
            void Refresh();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Refresh"]/*' />
        void Refresh();

        /*  
            [id(00000000), propget, helpcontext(0x0012c8d1)]
            Field* Item([in] VARIANT Index);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.this"]/*' />
        Field this[Object key]
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }

        /*
            [id(0x60040000), hidden]
            void _Append(
                        [in] BSTR Name, 
                        [in] DataTypeEnum Type, 
                        [in, optional, defaultvalue(0)] long DefinedSize, 
                        [in, optional, defaultvalue(-1)] FieldAttributeEnum Attrib);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields._Append"]/*' />
        void Append_One();

        /*  
            [id(0x00000004), helpcontext(0x0012f05c)]
            void Delete([in] VARIANT Index);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Delete"]/*' />
        void Delete();

        /*
            [id(0x00000003), helpcontext(0x0012f05d)]
            void Append(
                        [in] BSTR Name, 
                        [in] DataTypeEnum Type, 
                        [in, optional, defaultvalue(0)] long DefinedSize, 
                        [in, optional, defaultvalue(-1)] FieldAttributeEnum Attrib, 
                        [in, optional] VARIANT FieldValue);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Append"]/*' />
        void Append();

        /*  
            [id(0x00000005), helpcontext(0x0012f05e)]
            void Update();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Update"]/*' />
        void Update();

        /*
            [id(0x00000006), helpcontext(0x0012f05f)]
            void Resync([in, optional, defaultvalue(2)] ResyncEnum ResyncValues);            
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Resync"]/*' />
        void Resync();

        /*
            [id(0x00000007), helpcontext(0x0012f060)]
            void CancelUpdate();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.CancelUpdate"]/*' />
        void CancelUpdate();
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\services\remotingclientproxy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.Remoting.Services
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.IO;
    using System.Reflection;
    using System.Net;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Channels.Http;
    using System.Runtime.Remoting.Messaging;

    /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy"]/*' />
    public abstract class RemotingClientProxy : Component
    {
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy._type"]/*' />
        protected Type _type;
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy._tp"]/*' />
        protected Object _tp;
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy._url"]/*' />
        protected String _url;

        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.ConfigureProxy"]/*' />
        protected void ConfigureProxy(Type type, String url)
        {
            lock(this)
            {               
                // Initial URL Address embedded during codegen i.e. SUDSGenerator
                // User use in stockQuote.Url = "http://............." which reconnects the tp
                _type = type;
                this.Url = url;
            }
        }

        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.ConnectProxy"]/*' />
        protected void ConnectProxy()
        {
            lock(this)
            {
                _tp = null;
                _tp = Activator.GetObject(_type, _url);
            }
        }

        //[DefaultValue(false), Description("Enable automatic handling of server redirects.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.AllowAutoRedirect"]/*' />
        public bool AllowAutoRedirect
        {
            get { return(bool)ChannelServices.GetChannelSinkProperties(_tp)["AllowAutoRedirect"];}
            set { ChannelServices.GetChannelSinkProperties(_tp)["AllowAutoRedirect"] = value;}
        }

        //[Browsable(false), Persistable(PersistableSupport.None), Description("The cookies received from the server that will be sent back on requests that match the cookie's path.  EnableCookies must be true.")]
        //public CookieCollection Cookies
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.Cookies"]/*' />
        public Object Cookies
        {
            get { return null; }
        }

        //[DefaultValue(true), Description("Enables handling of cookies received from the server.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.EnableCookies"]/*' />
        public bool EnableCookies
        {
            get { return false; }
            set { throw new NotSupportedException(); }
        }

        //[DefaultValue(false), Description("Enables pre authentication of the request.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.PreAuthenticate"]/*' />
        public bool PreAuthenticate
        {
            get { return(bool)ChannelServices.GetChannelSinkProperties(_tp)["PreAuthenticate"];}
            set { ChannelServices.GetChannelSinkProperties(_tp)["PreAuthenticate"] = value;}
        }

        //[DefaultValue(""), RecommendedAsConfigurable(true), Description("The base URL to the server to use for requests.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.Path"]/*' />
        public String Path
        {
            get { return Url; }
            set { Url = value; }
        }

        //[DefaultValue(-1), RecommendedAsConfigurable(true), Description("Sets the timeout in milliseconds to be used for synchronous calls.  The default of -1 means infinite.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.Timeout"]/*' />
        public int Timeout
        {
            get { return (int)ChannelServices.GetChannelSinkProperties(_tp)["Timeout"];}
            set { ChannelServices.GetChannelSinkProperties(_tp)["Timeout"] = value;}
        }

//
//@@TODO if the Url is change redo Connect
//
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.Url"]/*' />
        public String Url
        {
            get
            {
                //return (String)ChannelServices.GetChannelSinkProperties(_tp)["Url"];
                return _url;
            }
            set
            {
                lock(this)
                {
                    _url = value;
                }
                ConnectProxy();
                ChannelServices.GetChannelSinkProperties(_tp)["Url"] = value;
            }
        }

        //[Description("Sets the user agent http header for the request.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.UserAgent"]/*' />
        public String UserAgent
        {
            get { return HttpClientTransportSink.UserAgent;}
            set { throw  new NotSupportedException(); }
        }

        //[DefaultValue(""), Description("The user name to be sent for basic and digest authentication.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.Username"]/*' />
        public String Username
        {
            get { return(String)ChannelServices.GetChannelSinkProperties(_tp)["UserName"];}
            set { ChannelServices.GetChannelSinkProperties(_tp)["UserName"] = value;}
        }

        //[DefaultValue(""), Description("The password to be used for basic and digest authentication.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.Password"]/*' />
        public String Password
        {
            get { return(String)ChannelServices.GetChannelSinkProperties(_tp)["Password"];}
            set { ChannelServices.GetChannelSinkProperties(_tp)["Password"] = value;}
        }

        //[DefaultValue(""), Description("The domain to be used for basic and digest authentication.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.Domain"]/*' />
        public String Domain
        {
            get { return(String)ChannelServices.GetChannelSinkProperties(_tp)["Domain"];}
            set { ChannelServices.GetChannelSinkProperties(_tp)["Domain"] = value;}
        }

        //[DefaultValue(""), Description("The name of the proxy server to use for requests.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.ProxyName"]/*' />
        public String ProxyName
        {
            get { return(String)ChannelServices.GetChannelSinkProperties(_tp)["ProxyName"];}
            set { ChannelServices.GetChannelSinkProperties(_tp)["ProxyName"] = value;}
        }

        //[DefaultValue(80), Description("The port number of the proxy server to use for requests.")]
        /// <include file='doc\RemotingClientProxy.uex' path='docs/doc[@for="RemotingClientProxy.ProxyPort"]/*' />
        public int ProxyPort {
            get { return(int)ChannelServices.GetChannelSinkProperties(_tp)["ProxyPort"];}
            set { ChannelServices.GetChannelSinkProperties(_tp)["ProxyPort"] = value;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\services\remotingservice.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.Remoting.Services 
{
    using System.Diagnostics;
    using System.Web;
    using System.ComponentModel;
    using System.Web.SessionState;
    using System.Security.Principal;
    using System.Runtime.Remoting.Channels;

    /// <include file='doc\RemotingService.uex' path='docs/doc[@for="RemotingService"]/*' />
    public class RemotingService : Component 
	{
        /// <include file='doc\RemotingService.uex' path='docs/doc[@for="RemotingService.Application"]/*' />
        public HttpApplicationState Application 
		{
            get {
                return Context.Application;
            }
        }

        /// <include file='doc\RemotingService.uex' path='docs/doc[@for="RemotingService.Context"]/*' />
        public HttpContext Context 
		{
            get {            
                HttpContext context = HttpContext.Current;
                if (context == null)
                    throw new RemotingException(CoreChannel.GetResourceString("Remoting_HttpContextNotAvailable"));
                return context;
            }
        }

        /// <include file='doc\RemotingService.uex' path='docs/doc[@for="RemotingService.Session"]/*' />
        public HttpSessionState Session 
		{
            get {
                return Context.Session;
            }
        }

        /// <include file='doc\RemotingService.uex' path='docs/doc[@for="RemotingService.Server"]/*' />
        public HttpServerUtility Server 
		{
            get {
                return Context.Server;
            }
        }       

        /// <include file='doc\RemotingService.uex' path='docs/doc[@for="RemotingService.User"]/*' />
        public IPrincipal User 
		{
            get {
                return Context.User;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\smtp\smtpmessagesink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SmtpMessageSink.cool
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: Implements a Smtp message sink which transmits method calls
**          as Smtp messages.
**          
**
** Date:    June 26, 2000
**
===========================================================*/

using System;
using System.Text;
using System.Threading;
using System.Collections;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Soap;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;

namespace System.Runtime.Remoting.Channels.Smtp
{
  /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink"]/*' />
  public class SmtpMessageSink : IMessageSink, IDictionary
  {        
        private SmtpChannel     m_channel;
        private String          m_channelURI;
        private String          m_mimeType;
        private IDictionary     m_items;             

        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.SmtpMessageSink"]/*' />
        public SmtpMessageSink(SmtpChannel smtpChannel, String smtpchannelURI,  String mimeType)
        {
            m_items = new Hashtable();
        
            m_channel = smtpChannel;
            m_channelURI = smtpchannelURI;
            m_mimeType = mimeType;

            InternalRemotingServices.RemotingTrace("SmtpMessageSink ctor channel: " + m_channel);                                                                                     
            InternalRemotingServices.RemotingTrace("SmtpMessageSink ctor channelURI: " + m_channelURI);
            InternalRemotingServices.RemotingTrace("SmtpMessageSink ctor mimeType: " + m_mimeType);
        }

        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.SyncProcessMessage"]/*' />
        public IMessage SyncProcessMessage(IMessage reqMsg)
        {
            return m_channel.SyncProcessMessage(reqMsg, m_channelURI); 
        }

        
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.AsyncProcessMessage"]/*' />
        public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            InternalRemotingServices.RemotingTrace("SmtpMessageSink::AsyncProcessMessage");
            return m_channel.AsyncProcessMessage(msg, replySink, m_channelURI);
        }


        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.NextSink"]/*' />
        public IMessageSink NextSink
        {
          get
          {
            return NextSink;
          }
        }

        /// <include file='doc\SMTPMessageSink.uex' path='docs/doc[@for="SMTPMessageSink.Finalize"]/*' />
        ~SmtpMessageSink()
        {
              // @TODO use this for safe cleanup at for now
        }


        //IDictionary
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.this"]/*' />
        public Object this[Object key] 
        {
            get { return m_items[key];}
            set { m_items[key] = value;}
        }
    
        // Returns a collections of the keys in this dictionary.
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Keys"]/*' />
        public ICollection Keys {
            get { return m_items.Keys;}
        }
    
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Values"]/*' />
        public ICollection Values {
            get {return m_items.Values;}
        }
    
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Contains"]/*' />
        public bool Contains(Object key)
        { 
          return m_items.Contains(key);
        }
    
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Add"]/*' />
        public void Add(Object key, Object value)
        {
          m_items.Add(key, value);
        }
    
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Clear"]/*' />
        public void Clear()
        {
          m_items.Clear();
        }
    
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.GetEnumerator"]/*' />
        public virtual IDictionaryEnumerator GetEnumerator() 
        {
          return m_items.GetEnumerator();
        }

        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Remove"]/*' />
        public void Remove(Object key)
        {
          m_items.Remove(key);
        }

        //ICollection

          /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.CopyTo"]/*' />
          public void CopyTo(Array array, int index)
          {
            m_items.CopyTo(array, index);
          }
        
          /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Count"]/*' />
          public int Count
        { get {return m_items.Count;} }
        
        
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.SyncRoot"]/*' />
        public Object SyncRoot
        { get {return m_items.SyncRoot;} }
    
      /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.IsReadOnly"]/*' />
      public  bool IsReadOnly 
        { get {return m_items.IsReadOnly;} }

		/// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.IsFixedSize"]/*' />
		public  bool IsFixedSize 
        { get {return m_items.IsFixedSize;} }


        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.IsSynchronized"]/*' />
        public bool IsSynchronized
        { get {return m_items.IsSynchronized;} }

      //IEnumerable
      IEnumerator IEnumerable.GetEnumerator() 
      {
          return m_items.GetEnumerator();
      }


    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\smtp\cdo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    CDO.cool
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: Defines the managed versions of classic COM interfaces 
**          that is used to communicate with CDO (Collaboration Data Objects)
**          
**          
**
** Date:    June 26, 2000
**
===========================================================*/
using System;
using System.Runtime.InteropServices;

namespace System.Runtime.Remoting.Channels.Smtp
{
    //[helpstring("Passed to Smtp-NNTP transport event sinks through corresponding event methods and used by sinks to indicate to the event source whether or not they have consumed the event.")] 
    /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoEventStatus"]/*' />
	[Serializable]
    public enum CdoEventStatus
    {
        //[helpstring("Proceed to run the next sink.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoEventStatus.cdoRunNextSink"]/*' />
        CdoRunNextSink  = 0,
        
        //[helpstring("Do not notify (skip) any remaining sinks for the event (i.e. this sink has consumed the event).")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoEventStatus.cdoSkipRemainingSinks"]/*' />
        CdoSkipRemainingSinks  = 1    
    }
    
    // [helpstring("Used to set or examine the IMessage.DSNOptions property, the value of which identifies the condition(s) under which Delivery Status Notifications (DSNs) are to be sent.")] 
    /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions"]/*' />
	[Serializable]
    public enum CdoDSNOptions
    {
        //[helpstring("No DSN commands are issued.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNDefault"]/*' />
        CdoDSNDefault  = 0,
        
        //[helpstring("No DSNs are issued.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNNever"]/*' />
        CdoDSNNever  = 1,
        
        //[helpstring("Return an DSN if delivery fails.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNFailure"]/*' />
        CdoDSNFailure  = 2,
        
        //[helpstring("Return a DSN if delivery succeeds.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNSuccess"]/*' />
        CdoDSNSuccess  = 4,
        
        //[helpstring("Return a DSN if delivery is delayed.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNDelay"]/*' />
        CdoDSNDelay  = 8,
        
        //[helpstring("Return a DSN if delivery succeeds, fails, or is delayed.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNSuccessFailOrDelay"]/*' />
        CdoDSNSuccessFailOrDelay  = 14
     };

    /*
    *   [ object, uuid(CD000026-8B95-11D1-82DB-00C04FB1625D), dual, nonextensible, helpstring("The interface to implement when creating Smtp OnArrival event sinks"), helpcontext(0x00000200), pointer_default(unique) ] interface ISmtpOnArrival : IDispatch
    */
    /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpOnArrival"]/*' />
    [     
     ComImport,
     Guid("CD000026-8B95-11D1-82DB-00C04FB1625D"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)
    ]
    public interface ISmtpOnArrival
    {
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpOnArrival.OnArrival"]/*' />
        // [ id( 256 ), helpstring ( "Called by the Smtp event source when a message arrives" ), helpcontext( 0x00000201 ) ] 
        // HRESULT OnArrival([In] IMessage *Msg, [In,Out]CdoEventStatus *EventStatus);
        void OnArrival(ISmtpMessage Msg,
                       [In, Out] ref CdoEventStatus EventStatus);
    }

    //    [ object, uuid(CD000020-8B95-11D1-82DB-00C04FB1625D), dual, nonextensible, helpstring("Defines abstract methods and properties used to manage a complete message"), helpcontext(0x00000110), pointer_default(unique) ] interface IMessage : IDispatch
    /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage"]/*' />
    [     
     ComImport,
     Guid("CD000020-8B95-11D1-82DB-00C04FB1625D"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)
    ]
    public interface ISmtpMessage
    {
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.BCC"]/*' />
        // [ id( 101 ), propget, helpstring( "The intended blind carbon copy (BCC header) recipients" ), helpcontext(0x00000111) ] 
        // HRESULT BCC ([Out,retval] BSTR* pBCC); 
        //
        // [ id( 101 ), propput, helpstring( "The intended blind carbon copy (BCC header) recipients" ), helpcontext(0x00000111) ] 
        // HRESULT BCC ([In] BSTR varBCC);
         String BCC 
         {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
         }
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.CC"]/*' />
           
         // [ id( 103 ), propget, helpstring( "The intended secondary (carbon copy) recipients" ), helpcontext(0x00000112) ] 
         // HRESULT CC ([Out,retval] BSTR* pCC); 
         // [ id( 103 ), propput, helpstring( "The intended secondary (carbon copy) recipients" ), helpcontext(0x00000112) ] 
         // HRESULT CC ([In] BSTR varCC);         
         String CC
         {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
         }          
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.FollowUpTo"]/*' />
         
        // [ id( 105 ), propget, helpstring( "The recipient to which follow up messages should be sent" ), helpcontext(0x00000113) ] 
        // HRESULT FollowUpTo ([Out,retval] BSTR* pFollowUpTo); 
        // [ id( 105 ), propput, helpstring( "The recipient to which follow up messages should be sent" ), helpcontext(0x00000113) ] 
        // HRESULT FollowUpTo ([In] BSTR varFollowUpTo);                  
         String FollowUpTo
         {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
         }  
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.From"]/*' />
                
         // [ id( 106 ), propget, helpstring( "The principle recipients from which the message is sent" ), helpcontext(0x00000114) ] 
         // HRESULT From ([Out,retval] BSTR* pFrom); 
         // [ id( 106 ), propput, helpstring( "The principle recipients from which the message is sent" ), helpcontext(0x00000114) ] 
         // HRESULT From ([In] BSTR varFrom);         
         String From
         {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
         }            
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Keywords"]/*' />
         
        // [ id( 107 ), propget, helpstring( "The keywords for the message" ), helpcontext(0x00000115) ] 
        // HRESULT Keywords ([Out,retval] BSTR* pKeywords); 
        // [ id( 107 ), propput, helpstring( "The keywords for the message" ), helpcontext(0x00000115) ]
        // HRESULT Keywords ([In] BSTR varKeywords);
         String Keywords
         {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
         }            
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.MimeFormatted"]/*' />
         
        // [ id( 110 ), propget, helpstring( "Specifies whether or not the message is to be formatted using MIME (True) or UUEncode (False)" ), helpcontext(0x00000116) ] 
        // HRESULT MimeFormatted ([Out,retval] VARIANT_BOOL* pMimeFormatted); 
        // [ id( 110 ), propput, helpstring( "Specifies whether or not the message is to be formatted using MIME (True) or UUEncode (False)" ), helpcontext(0x00000116) ] 
        // HRESULT MimeFormatted ([In] VARIANT_BOOL varMimeFormatted);
        //
         bool MimeFormatted
         {
            [return : MarshalAs(UnmanagedType.VariantBool)]
            get;
            [param : MarshalAs(UnmanagedType.VariantBool)]
            set;
         }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Newsgroups"]/*' />
        //[ id( 111 ), propget, helpstring( "The names of newsgroups (NewsGroups header) to which the message is to be posted" ), helpcontext(0x00000117) ] HRESULT Newsgroups ([Out,retval] BSTR* pNewsgroups); 
        //[ id( 111 ), propput, helpstring( "The names of newsgroups (NewsGroups header) to which the message is to be posted" ), helpcontext(0x00000117) ] HRESULT Newsgroups ([In] BSTR varNewsgroups);
        String Newsgroups
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Organization"]/*' />
        //[ id( 112 ), propget, helpstring( "The organization of the sender" ), helpcontext(0x00000118) ] HRESULT Organization ([Out,retval] BSTR* pOrganization); 
        //[ id( 112 ), propput, helpstring( "The organization of the sender" ), helpcontext(0x00000118) ] HRESULT Organization ([In] BSTR varOrganization);
        String Organization
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.ReceivedTime"]/*' />
        
        //[ id( 114 ), propget, helpstring( "Returns the time the message was received" ), helpcontext( 0x00000119 ), readonly ] 
        // HRESULT ReceivedTime ([Out,retval] DATE* varReceivedTime);
        Object ReceivedTime
        {
            get;
        } 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.ReplyTo"]/*' />
        
        //[ id( 115 ), propget, helpstring( "The addresses (Reply-To header) to which to reply" ), helpcontext(0x0000011a) ] HRESULT ReplyTo ([Out,retval] BSTR* pReplyTo); 
        //[ id( 115 ), propput, helpstring( "The addresses (Reply-To header) to which to reply" ), helpcontext(0x0000011a) ] HRESULT ReplyTo ([In] BSTR varReplyTo);
        String ReplyTo
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.DSNOptions"]/*' />
        
        // [ id( 116 ), propget, helpstring( "The delivery status notification options for the message" ), helpcontext(0x0000011b) ]
        // HRESULT DSNOptions ([Out,retval] CdoDSNOptions* pDSNOptions); 
        // [ id( 116 ), propput, helpstring( "The delivery status notification options for the message" ), helpcontext(0x0000011b) ] 
        // HRESULT DSNOptions ([In] CdoDSNOptions varDSNOptions);
        CdoDSNOptions DSNOptions
        {
            get;
            set;
        }            
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.SentOn"]/*' />
        
        // [ id( 119 ), propget, helpstring( "The date on which the message was sent" ), helpcontext( 0x0000011c ), readonly ] HRESULT SentOn ([Out,retval] DATE* varSentOn);
        Object SentOn
        {
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Subject"]/*' />
        
        // [ id( 120 ), propget, helpstring( "The subject (Subject header) of the message" ), helpcontext(0x0000011d) ] HRESULT Subject ([Out,retval] BSTR* pSubject); 
        // [ id( 120 ), propput, helpstring( "The subject (Subject header) of the message" ), helpcontext(0x0000011d) ] HRESULT Subject ([In] BSTR varSubject);
        String Subject
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.To"]/*' />
        
        // [ id( 121 ), propget, helpstring( "The principle (To header) recipients of the message" ), helpcontext(0x0000011e) ] HRESULT To ([Out,retval] BSTR* pTo); 
        // [ id( 121 ), propput, helpstring( "The principle (To header) recipients of the message" ), helpcontext(0x0000011e) ] HRESULT To ([In] BSTR varTo);
        String To
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.TextBody"]/*' />
        
        // [ id( 123 ), propget, helpstring( "The text/plain portion of the message body" ), helpcontext(0x0000011f) ] HRESULT TextBody ([Out,retval] BSTR* pTextBody); 
        // [ id( 123 ), propput, helpstring( "The text/plain portion of the message body" ), helpcontext(0x0000011f) ] HRESULT TextBody ([In] BSTR varTextBody);
        String TextBody
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.HTMLBody"]/*' />
        
        // [ id( 124 ), propget, helpstring( "The text/html portion of the message body" ), helpcontext(0x00000120) ] HRESULT HTMLBody ([Out,retval] BSTR* pHTMLBody); 
        // [ id( 124 ), propput, helpstring( "The text/html portion of the message body" ), helpcontext(0x00000120) ] HRESULT HTMLBody ([In] BSTR varHTMLBody);
        String HTMLBody
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Attachments"]/*' />

        // [ id( 125 ), propget, helpstring( "Returns the message's Attachments collection" ), helpcontext( 0x00000121 ), readonly ] 
        // HRESULT Attachments ([Out,retval] IBodyParts ** varAttachments);
        Object Attachments
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Sender"]/*' />

        // [ id( 126 ), propget, helpstring( "The sender of the message" ), helpcontext(0x00000122) ] HRESULT Sender ([Out,retval] BSTR* pSender); 
        // [ id( 126 ), propput, helpstring( "The sender of the message" ), helpcontext(0x00000122) ] HRESULT Sender ([In] BSTR varSender);
        String Sender
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Configuration"]/*' />
            
        // [ id( 127 ), propget, helpstring( "The object's associated Configuration object" ), helpcontext( 0x00000123) ] HRESULT Configuration ([Out,retval] IConfiguration ** pConfiguration); [ id( 127 ), propput, helpstring( "The object's associated Configuration object" ), helpcontext( 0x00000123 ) ] HRESULT Configuration ([In] IConfiguration * varConfiguration); 
        // [ id( 127 ), propputref, helpstring( "The object's associated Configuration object" ), helpcontext( 0x00000123 ) ] HRESULT Configuration ([In] IConfiguration * varConfiguration);
        Object Configuration
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
            [param : MarshalAs(UnmanagedType.Interface)]
            set;        
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.let_Configuration"]/*' />
        
        // NOTE: Dummy method to mimic let_Configuration
        Object let_Configuration(Object obj);
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.AutoGenerateTextBody"]/*' />
        
            
        // [ id( 128 ), propget, helpstring( "Specifies whether a text/plain alternate representation should automatically be generated from the text/html part of the message body" ), helpcontext(0x00000124) ] HRESULT AutoGenerateTextBody ([Out,retval] VARIANT_BOOL* pAutoGenerateTextBody); 
        // [ id( 128 ), propput, helpstring( "Specifies whether a text/plain alternate representation should automatically be generated from the text/html part of the message body" ), helpcontext(0x00000124) ] HRESULT AutoGenerateTextBody ([In] VARIANT_BOOL varAutoGenerateTextBody);
        bool AutoGenerateTextBody
        {
            [return : MarshalAs(UnmanagedType.VariantBool)]
            get;
            [param : MarshalAs(UnmanagedType.VariantBool)]
            set;
        }            
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.EnvelopeFields"]/*' />

        // [ id( 129 ), propget, helpstring( "Returns the transport envelope Fields collection for the message (transport event sinks only) " ), helpcontext( 0x00000125 ), readonly ] HRESULT EnvelopeFields ([out,retval] Fields ** varEnvelopeFields);
        Smtp.Fields EnvelopeFields
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.TextBodyPart"]/*' />
            
        // [ id( 130 ), propget, helpstring( "Returns the BodyPart object (IBodyPart interface) containing the text/plain part of the message body" ), helpcontext( 0x00000126 ), readonly ] HRESULT TextBodyPart ([Out,retval] IBodyPart ** varTextBodyPart);
        Object TextBodyPart
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.HTMLBodyPart"]/*' />

        // [ id( 131 ), propget, helpstring( "Returns the BodyPart object (IBodyPart interface) containing the text/html portion of the message body" ), helpcontext( 0x00000127 ), readonly ] HRESULT HTMLBodyPart ([Out,retval] IBodyPart ** varHTMLBodyPart);
        Object HTMLBodyPart
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.BodyPart"]/*' />
            
        // [ id( 132 ), propget, helpstring( "Returns the IBodyPart interface on the object" ), helpcontext( 0x00000128 ), readonly ] HRESULT BodyPart ([Out,retval] IBodyPart ** varBodyPart);
        Object BodyPart
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.DataSource"]/*' />

        // [ id( 133 ), propget, helpstring( "Returns the IDataSource interface on the object" ), helpcontext( 0x00000129 ), readonly ] HRESULT DataSource ([Out,retval] IDataSource ** varDataSource);
        Object DataSource
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Fields"]/*' />
        
        // [ id( 134 ), propget, helpstring( "Returns the Fields collection for the message" ), helpcontext( 0x0000012a ), readonly ] HRESULT Fields ([out,retval] Fields ** varFields);
        Smtp.Fields Fields
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.MDNRequested"]/*' />
        
        // [ id( 135 ), propget, helpstring( "Specifies whether or not mail delivery notifications should be sent when the message is received" ), helpcontext(0x0000012b) ] HRESULT MDNRequested ([Out,retval] VARIANT_BOOL* pMDNRequested); [ id( 135 ), propput, helpstring( "Specifies whether or not mail delivery notifications should be sent when the message is received" ), helpcontext(0x0000012b) ] HRESULT MDNRequested ([In] VARIANT_BOOL varMDNRequested);
        bool MDNRequested
        {
            [return : MarshalAs(UnmanagedType.VariantBool)]
            get;
            [param : MarshalAs(UnmanagedType.VariantBool)]
            set;
       }         
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.AddRelatedBodyPart"]/*' />
            
       // [ id( 150 ), helpstring ( "Adds a BodyPart object with content referenced within the text/html portion of the message body" ), helpcontext( 0x0000012c ) ] HRESULT AddRelatedBodyPart(
       //               [In]            BSTR URL, 
       //               [In]            BSTR Reference,
       //               [In]            CdoReferenceType ReferenceType,
       //               [In, optional]  BSTR UserName,
       //               [In, optional]  BSTR Password,
       //               [Out,retval]    IBodyPart **ppBody);
        Object AddRelatedBodyPart();
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.AddAttachment"]/*' />
                                
       // [ id( 151 ), helpstring ( "Adds an attachment (BodyPart) to the message" ), helpcontext( 0x0000012d ) ] HRESULT AddAttachment(
       //               [In]            BSTR URL,
       //               [In, optional]  BSTR UserName,
       //               [In, optional]  BSTR Password,
       //               [Out,retval]    IBodyPart **ppBody);
        Object AddAttachment();                        
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.CreateMHTMLBody"]/*' />
                    
       // [ id( 152 ), helpstring ( "Creates an MHTML-formatted message body using the contents at the specified URL" ), helpcontext( 0x0000012e ) ] HRESULT CreateMHTMLBody(
       //            [In]                   BSTR URL, 
       //            [In, defaultvalue(cdoSuppressNone)]    CdoMHTMLFlags Flags,
       //            [In, optional] BSTR UserName,
       //            [In, optional] BSTR Password);
        void CreateMHTMLBody();                           
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Forward"]/*' />
                        
       // [ id( 153 ), helpstring ( "Returns a Message object that can be used to forward the message" ), helpcontext( 0x0000012f ) ] HRESULT Forward(
       //            [Out,retval]   IMessage **ppMsg);
        void Forward();
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Post"]/*' />
        
            
       // [ id( 154 ), helpstring ( "Post the message using the method specified in the associated Configuration object" ), helpcontext( 0x00000130 ) ] HRESULT Post();
        void Post();            
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.PostReply"]/*' />
        
       // [ id( 155 ), helpstring ( "Returns a Message object that can be used to post a reply to the message" ), helpcontext( 0x00000131 ) ] HRESULT PostReply(
       //               [Out,retval]    IMessage **ppMsg);
        void PostReply();                        
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Reply"]/*' />
                        
        //   [ id( 156 ), helpstring ( "Returns a Message object that can be used to reply to the message" ), helpcontext( 0x00000132 ) ] HRESULT Reply(
        //            [Out,retval]    IMessage//*ppMsg);
         Object Reply();
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.ReplyAll"]/*' />
                        
        // [ id( 157 ), helpstring ( "Returns a Message object that can be used to post a reply to all recipients of the message" ), helpcontext( 0x00000133 ) ] HRESULT ReplyAll(
        //              [Out,retval] IMessage **ppMsg);
         Object ReplyAll();
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Send"]/*' />
                        
        //[ id( 158 ), helpstring ( "Send the message using the method specified in the associated Configuration object" ), helpcontext( 0x00000136 ) ] HRESULT Send();
         void Send();
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.GetStream"]/*' />
        
       // [ id( 159 ), helpstring ( "Returns a Stream object containing the message in serialized format" ), helpcontext( 0x00000134 ) ] HRESULT GetStream(
       //               [Out,retval] _Stream **ppStream);
        Object GetStream();
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.GetInterface"]/*' />
        
        // [ id( 160 ), helpstring ( "Returns the specified interface on the object" ), helpcontext( 0x00000135 ) ] HRESULT GetInterface(
        //           [In] BSTR Interface,
        //           [Out, retval] IDispatch** ppUnknown);
        Object GetInterface();       
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\smtp\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_sign: $(COOL_TARGET)
        gacutil -i $(TARGETPATH)\$(TARGETNAME)

$(O)\System.Runtime.Remoting.resources: ..\resources.txt
    $(TARGETPATH)\InternalResGen.Exe ..\resources.txt $(TARGETPATH)\System.Runtime.Remoting.resources

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\System.Runtime.Remoting.Channels.Smtp.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\smtp\smtpmail.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SmtpMail.cool
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: Implements a managed wrapper to send mail messages via Smtp
**          
**          
**
** Date:    June 26, 2000
**
===========================================================*/

using System.Runtime.Serialization.Formatters;
using System.Collections;
using System.Reflection;
using System.Runtime.Remoting.Channels;

namespace System.Runtime.Remoting.Channels.Smtp
{

// Class that sends MailMessage using CDO
/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="SmtpMail"]/*' />
public class SmtpMail
{
    private static Type _newMailType; // cached Type of CDONTS.NewMail

    private static Type GetNewMailType()
    {
        if (_newMailType == null)
        {
            try { _newMailType = Type.GetTypeFromProgID("CDONTS.NewMail"); }
            catch(Exception) {}

            if (_newMailType == null)
                throw new Exception(String.Format(CoreChannel.GetResourceString("Remoting_UnableToCreateProgID"), "CDONTS.NewMail"));
        }

        return _newMailType;
    }

    private static void CallNewMail(Object newMail, String methodName, Object[] args)
    {
        try
        {
            GetNewMailType().InvokeMember(methodName, 
                                          BindingFlags.InvokeMethod, 
                                          null, 
                                          newMail,
                                          args);
        }
        catch (Exception e)
        {
            throw new Exception("Could_not_access_cdo_newmail_object", e);
        }
    }

    private static void SetNewMailProp(Object newMail, String propName, Object propValue)
    {
        try
        {
            GetNewMailType().InvokeMember(propName, 
                                          BindingFlags.SetProperty, 
                                          null, 
                                          newMail,
                                          new Object[1] { propValue });
        }
        catch (Exception e)
        {
            throw new Exception("Could_not_access_cdo_newmail_object", e);
        }
    }

    private static void SetNewMailProp(Object newMail, String propName, Object propKey, Object propValue)
    {
        try
        {
            GetNewMailType().InvokeMember(propName, 
                                          BindingFlags.SetProperty, 
                                          null, 
                                          newMail,
                                          new Object[2] { propKey, propValue });
        }
        catch (Exception e)
        {
            throw new Exception("Could_not_access_cdo_newmail_object", e);
        }
    }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="SmtpMail.Send"]/*' />
    public static void Send(String from, String to, String subject, String messageText)
    {
        Object newMail = Activator.CreateInstance(GetNewMailType());

        CallNewMail(newMail, 
                    "Send",
                    new Object[5] { from, to, subject, messageText, (Object)1 });
    }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="SmtpMail.Send1"]/*' />
    public static void Send(MailMessage message)
    {
        // create mail object

        Object newMail = Activator.CreateInstance(GetNewMailType());

        // set properties

        if (message.From != null)
            SetNewMailProp(newMail, "From", message.From);

        if (message.To != null)
            SetNewMailProp(newMail, "To", message.To);

        if (message.Cc != null)
            SetNewMailProp(newMail, "Cc", message.Cc);

        if (message.Bcc != null)
            SetNewMailProp(newMail, "Bcc", message.Bcc);

        if (message.Subject != null)
            SetNewMailProp(newMail, "Subject", message.Subject);

        if (message.Priority != MailPriority.Normal)
        {
            int p = 0;
            switch (message.Priority)
            {
            case MailPriority.Low:      p = 0;  break;
            case MailPriority.Normal:   p = 1;  break;
            case MailPriority.High:     p = 2;  break;
            }
            SetNewMailProp(newMail, "Importance", p);
        }

        if (message.UrlContentBase != null)
            SetNewMailProp(newMail, "ContentBase", message.UrlContentBase);

        if (message.UrlContentLocation != null)
            SetNewMailProp(newMail, "ContentLocation", message.UrlContentLocation);

        int numHeaders = message.Headers.Count;
        if (numHeaders > 0)
        {
            IDictionaryEnumerator e = message.Headers.GetEnumerator();
            while (e.MoveNext())
            {
                String k = (String)e.Key;
                String v = (String)e.Value;
                SetNewMailProp(newMail, "Value", k, v);
            }
        }

        if (message.BodyFormat == MailFormat.Html)
        {
            SetNewMailProp(newMail, "BodyFormat", 0);
            SetNewMailProp(newMail, "MailFormat", 0);
        }

        if (message.Body != null)
            SetNewMailProp(newMail, "Body", message.Body);

        for (IEnumerator e = message.Attachments.GetEnumerator(); e.MoveNext(); )
        {
            MailAttachment a = (MailAttachment)e.Current;

            int c = 0;
            switch (a.Encoding)
            {
            case MailEncoding.UUEncode: c = 0;  break;
            case MailEncoding.Base64:   c = 1;  break;
            }

            CallNewMail(newMail, "AttachFile", new Object[3] { a.Filename, null, (Object)c });
        }

        // send mail

        CallNewMail(newMail, 
                    "Send",
                    new Object[5] { null, null, null, null, null });

    }
}

//
// Enums for message elements
//

/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailFormat"]/*' />
[Serializable]
public enum MailFormat
{
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailFormat.Text"]/*' />
    Text = 0,       // note - different from CDONTS.NewMail
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailFormat.Html"]/*' />
    Html = 1
}

/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority"]/*' />
[Serializable]
public enum MailPriority
{
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority.Normal"]/*' />
    Normal = 0,     // note - different from CDONTS.NewMail
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority.Low"]/*' />
    Low = 1,
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority.High"]/*' />
    High = 2
}

/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailEncoding"]/*' />
[Serializable]
public enum MailEncoding
{
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailEncoding.UUEncode"]/*' />
    UUEncode = 0,   // note - same as CDONTS.NewMail
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailEncoding.Base64"]/*' />
    Base64 = 1
}

// Immutable struct that holds a single attachment
/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment"]/*' />
public class MailAttachment
{
    private String _filename;
    private MailEncoding _encoding;

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.Filename"]/*' />
    public String Filename { get { return _filename; } }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.Encoding"]/*' />
    public MailEncoding Encoding { get { return _encoding; } }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.MailAttachment"]/*' />
    public MailAttachment(String filename)
    {
        _filename = filename;
        _encoding = MailEncoding.UUEncode;
    }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.MailAttachment1"]/*' />
    public MailAttachment(String filename, MailEncoding encoding)
    {
        _filename = filename;
        _encoding = encoding;
    }
}

// Struct that holds a single message
/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage"]/*' />
public class MailMessage
{
    private Hashtable _headers = new Hashtable();
    private ArrayList _attachments = new ArrayList();

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.From"]/*' />
    public String       From;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.To"]/*' />
    public String       To;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Cc"]/*' />
    public String       Cc;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Bcc"]/*' />
    public String       Bcc;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Subject"]/*' />
    public String       Subject;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Priority"]/*' />
    public MailPriority Priority = MailPriority.Normal;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.UrlContentBase"]/*' />
    public String       UrlContentBase;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.UrlContentLocation"]/*' />
    public String       UrlContentLocation;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Body"]/*' />
    public String       Body;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.BodyFormat"]/*' />
    public MailFormat   BodyFormat = MailFormat.Text;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Headers"]/*' />
    public IDictionary  Headers { get { return _headers; } }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Attachments"]/*' />
    public IList        Attachments { get { return _attachments; } }
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

####################################################################################
#
# This rule is always run and it is run before $(COOL_TARGET):: is run.
#
####################################################################################
SETUP:
    $(TARGETPATH)\InternalResGen $(COOL_SOURCE_DIR)\resources.txt $(TARGETPATH)\system.security.resources

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\System.Security.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc

        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\smtp\smtpregistersink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SmtpRegisterSink.cool
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: (1) Creates registry entries for the given mailbox if one has
**              not been created yet.
**          (2) Registers the mailbox with the Smtp service so that 
**              incoming or outgoing messages can be intercepted.
**          
**
** Date:    June 26, 2000
**
===========================================================*/
using System;
using Microsoft.Win32;
using System.IO;
using System.Runtime.Remoting.Channels;
using System.Globalization;


namespace System.Runtime.Remoting.Channels.Smtp
{

/// <include file='doc\SmtpRegisterSink.uex' path='docs/doc[@for="SmtpRegisterSink"]/*' />
public class SmtpRegisterSink
{
    private const String s_strSink = "SmtpSink";
    private const String s_eventSourceName = "smtpsvc 1";   // ServiceName + Virtual service instance number
    private static Guid s_onArrivalGuid = new Guid("{ff3caa23-00b9-11d2-9dfb-00C04FA322BA}");
    private static Object s_lockObject = new Object();
    //private static String s_strRuleTemplate = "RCPT TO=";
    
    // Creates registry entries for the given mailbox if one has
    // not been created yet.
    // NOTE: The process name is the name of the process qualified with the 
    // path. This process handles all the messages addressed to the mailbox.
    /// <include file='doc\SmtpRegisterSink.uex' path='docs/doc[@for="SmtpRegisterSink.CreateRegistryEntryForMailbox"]/*' />
    public static Guid CreateRegistryEntryForMailbox(String processName, String mailbox)
    {
        Guid regGuid = Guid.Empty;
        
        // Sanity check
        if(null == processName)
        {
            throw new ArgumentNullException("processName");
        }        
        if(null == mailbox)
        {
            throw new ArgumentNullException("mailbox");
        }
                
        // Try to find an existing ProgID with this name
        lock(s_lockObject)
        {
            regGuid = GetGuidForMailbox(mailbox);
            
            // If we do not have a guid for this mailbox then create
            // one and put the appropriate entries in the registry
            if(regGuid.Equals(Guid.Empty))
            {                
                regGuid = Guid.NewGuid();
                Console.WriteLine("Creating new Entry " + regGuid);
                String strClsId = "{" + regGuid.ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
                
                //
                // Write the actual type information in the registry.
                //
    
                // Create the HKEY_CLASS_ROOT\<wzProgId> key.
                RegistryKey TypeNameKey = Registry.ClassesRoot.CreateSubKey(mailbox);
                TypeNameKey.SetValue("", s_strSink);
    
                // Create the HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
                RegistryKey ProgIdClsIdKey = TypeNameKey.CreateSubKey("CLSID");
                ProgIdClsIdKey.SetValue("", strClsId);
                // Close HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
                ProgIdClsIdKey.Close();
    
                // Close HKEY_CLASS_ROOT\<wzProgId> key.
                TypeNameKey.Close();
                
                // Create the HKEY_CLASS_ROOT\CLSID\<CLSID> key.
                RegistryKey ClsIdKey = Registry.ClassesRoot.OpenSubKey("CLSID", true).CreateSubKey(strClsId);
                ClsIdKey.SetValue("", s_strSink);
                ClsIdKey.SetValue("AppID", strClsId);
    
                // Create the HKEY_CLASS_ROOT\CLSID\<CLSID>\LocalServer32 key.
                RegistryKey LocalServerKey = ClsIdKey.CreateSubKey("LocalServer32");
                // The value is ProcessName.exe <mailbox>
                LocalServerKey.SetValue("", processName + " " + mailbox);                
                
                // Close HKEY_CLASS_ROOT\CLSID\<CLSID>\LocalServer32 key.
                LocalServerKey.Close();
    
                // Create the HKEY_CLASS_ROOT\CLSID\<CLSID>\ProgId key.
                RegistryKey ProgIdKey = ClsIdKey.CreateSubKey("ProgId");
                ProgIdKey.SetValue("", mailbox);
                
                // Close HKEY_CLASS_ROOT\CLSID\<CLSID>\ProgId key.
                ProgIdKey.Close();
                
                // Close HKEY_CLASS_ROOT\CLSID\<CLSID> key.
                ClsIdKey.Close();
                
                // Create the HKEY_CLASS_ROOT\APPID\<APPID> key.
                RegistryKey AppIdKey = Registry.ClassesRoot.OpenSubKey("AppID", true).CreateSubKey(strClsId);
                AppIdKey.SetValue("", s_strSink);
                AppIdKey.SetValue("RunAs", "Interactive User");                                
                
                // Close HKEY_CLASS_ROOT\APPID\<APPID> key.
                AppIdKey.Close();
            }
        }
        
        return regGuid;
    }
    
     
    // Creates registry entries for the given mailbox if one has
    // not been created yet.
    // NOTE: The process name is the name of the `current' process qualified 
    // with the path. This process handles all the messages addressed to the mailbox.
    /// <include file='doc\SmtpRegisterSink.uex' path='docs/doc[@for="SmtpRegisterSink.CreateRegistryEntryForMailbox1"]/*' />
    public static Guid CreateRegistryEntryForMailbox(String mailbox)
    {
        // Get the fully qualified name of the executable which launched the
        // current process
        String processName = Path.GetFullPath(System.Environment.GetCommandLineArgs()[0]);
        Console.WriteLine("The full path to the executable is " + processName);
        return CreateRegistryEntryForMailbox(processName, mailbox);
    }
    
    // Deletes the registry entries for a given mailbox if one exists, otherwise
    // it returns.
    /// <include file='doc\SmtpRegisterSink.uex' path='docs/doc[@for="SmtpRegisterSink.DeleteRegistryEntryForMailbox"]/*' />
    public static void DeleteRegistryEntryForMailbox(String mailbox)
    {
        
        // Sanity check
        if(null == mailbox)
        {
            throw new ArgumentNullException("mailbox");
        }
                
        // Try to find an existing ProgID with this name
        lock(s_lockObject)
        {
            // Get the CLSID for the mailbox
            Guid regGuid = GetGuidForMailbox(mailbox);
            
            if(!regGuid.Equals(Guid.Empty))
            {
                String strClsId = null;
                
                // Open the HKEY_CLASS_ROOT\<wzProgId> key.
                RegistryKey TypeNameKey = Registry.ClassesRoot.OpenSubKey(mailbox, true);
                if(null != TypeNameKey)
                {
                    // Get the CLSID
                    RegistryKey ProgIdClsIdKey = TypeNameKey.OpenSubKey("CLSID", false);
                    if(null != ProgIdClsIdKey)
                    {
                        strClsId = (String)ProgIdClsIdKey.GetValue("");
                    }
                    // Close the type name key
                    TypeNameKey.Close();
                    
                    // Delete the type name key and all its keys
                    Registry.ClassesRoot.DeleteSubKeyTree(mailbox);
                }
                
                if(null != strClsId)
                {
                    // Open the HKEY_CLASSES_ROOT\CLSID key
                    RegistryKey ClsIdRootKey = Registry.ClassesRoot.OpenSubKey("CLSID", true);
                    // Open the HKEY_CLASS_ROOT\CLSID\<CLSID> key.
                    RegistryKey ClsIdKey = ClsIdRootKey.OpenSubKey(strClsId, true);
                    if(null != ClsIdKey)
                    {
                        // Close the CLSID Key
                        ClsIdKey.Close();
                        
                        // Delete the CLSID Key and all its keys
                        ClsIdRootKey.DeleteSubKeyTree(strClsId);
                    }
                    
                    // Close the HKEY_CLASSES_ROOT\CLSID key
                    ClsIdRootKey.Close();
                    
                    // Open the HKEY_CLASSES_ROOT\AppID key
                    RegistryKey AppIdRootKey = Registry.ClassesRoot.OpenSubKey("AppID", true);
                    // Open the HKEY_CLASS_ROOT\AppID\<CLSID> key.
                    RegistryKey AppIdKey = AppIdRootKey.OpenSubKey(strClsId, true);
                    if(null != AppIdKey)
                    {
                        // Close the AppID Key
                        AppIdKey.Close();
                        
                        // Delete the CLSID Key and all its keys
                        AppIdRootKey.DeleteSubKeyTree(strClsId);
                    }
                    
                    // Close the HKEY_CLASSES_ROOT\AppID key
                    AppIdRootKey.Close();                    
                }
            }
        }
    }
    
    // Looks up a guid for a given mailbox (essentially CLSIDFromProgID)
    // Returns an empty guid if one is not found.
    // Assumes that a lock is held by the calling function
    internal static Guid GetGuidForMailbox(String mailbox)
    {
        Guid regGuid = Guid.Empty;
        
        // Open the HKEY_CLASS_ROOT\<wzProgId> key.
        RegistryKey TypeNameKey = Registry.ClassesRoot.OpenSubKey(mailbox, false);
        if(null != TypeNameKey)
        {
            // Open the HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
            RegistryKey ProgIdClsIdKey = TypeNameKey.OpenSubKey("CLSID", false);
            String strClsId = (String)ProgIdClsIdKey.GetValue("");
            if(null != strClsId)
            {
                Console.WriteLine("Found Entry " + strClsId);
                regGuid = new Guid(strClsId);
            }
            
            // Close HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
            ProgIdClsIdKey.Close();
            
            // Close HKEY_CLASS_ROOT\<wzProgId> key.
            TypeNameKey.Close();
        }
        
        return regGuid;
    }
    
    // Register a sink with Smtp service so that incoming or outgoing messages
    // can be intercepted
    /// <include file='doc\SmtpRegisterSink.uex' path='docs/doc[@for="SmtpRegisterSink.RegisterSinkWithSmtp"]/*' />
    public static void RegisterSinkWithSmtp(String mailbox)
    {
        /*Guid regGuid = CreateRegistryEntryForMailbox(mailbox);
        RemotingServices.RegisterTypeForComClients(typeof(SmtpChannel), ref regGuid);
        */
                
        /*// Create an instance of the event manager object
        IEventManager manager = (IEventManager)Type.CreateInstanceFromProgID("Event.Manager");
        
        // Get the source types
        IEventSourceTypes sourceTypes = manager.SourceTypes();
        
        // Get the source type for Smtp 
        IEventSourceType sourceType = sourceTypes.Source(s_onArrivalGuid);
        
        // Get the sources for Smtp
        IEventSources sources = sourceType.Sources();
        
        // Iterate over the sources till we reach the Smtp source
        for(int i = 0; i < sources.Count; i++)
        {
            IEventSource source = sources[i];
            if(s_eventSourceName.Equals(source.DisplayName))
            {
                String strRule = s_strRuleTemplate + mailbox;        
                
                // we've found the desired instance.  now add a new binding
                // with the right event GUID.  by not specifying a GUID to the
                // Add method we get server events to create a new ID for this
                // event
                IEventBinding binding = source.GetBindingManager().Bindings(s_onArrivalGuid).Add("");
                
                // set the binding properties                
                binding.DisplayName = mailbox;
                binding.SinkClass = mailbox;
                // register a rule with the binding
                binding.SourceProperties.Add("Rule", strRule);
                // register a priority with the binding
                int prioVal = GetNextPriority(source, GUIDComCat);
                
                if(prioVal < 0 )
                {
                    Console.WriteLine("assigning priority to default value (24575)")
                    binding.SourceProperties.Add ("Priority", 24575);
                }
                else    
                {
                    Console.WriteLine("assigning priority (" + prioVal + " of 32767)");
                    binding.SourceProperties.Add("Priority", prioVal);
                }
            }
        }*/
    }
}

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "System.Security.dll"
#define VER_FILEDESCRIPTION_STR "System.Security.dll\0"
#define VER_ORIGFILENAME_STR    "System.Security.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\smtp\smtpchannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SmtpChannel.cool
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: Implements a channel that transmits method calls in the 
**          SOAP format over Smtp.
**          
**
** Date:    June 26, 2000
**
===========================================================*/

using System;
using System.Text;
using System.Threading;
using System.Collections;
using System.Reflection;
using System.Globalization;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Soap;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;
using System.Net;
using System.Net.Sockets;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Channels;
using System.Runtime.InteropServices;


namespace System.Runtime.Remoting.Channels.Smtp
{

//
// URL format
//
// Smtp://host@domainname/uri
//

    /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase"]/*' />
    public class SmtpChannelBase
    {
        const int     DefaultChannelPriority=1;
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.DefaultChannelName"]/*' />
        protected const String  DefaultChannelName = "Smtp";        
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.DefaultMimeType"]/*' />
        protected const String  DefaultMimeType = CoreChannel.SOAPMimeType;

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.m_mimeType"]/*' />
        protected String m_mimeType;

        
        internal SmtpChannelBase() 
        {
                m_mimeType = DefaultMimeType;
        }

        internal bool IsMimeTypeSupported(String mimeType)
        {
            return (    mimeType.Equals(CoreChannel.SOAPMimeType)
                    ||  mimeType.Equals(CoreChannel.BinaryMimeType)
                    );
        }

        // IChannel
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.ChannelPriority"]/*' />
        public int ChannelPriority
        {
            get 
            {
                return DefaultChannelPriority;
                }
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.ChannelName"]/*' />
        public String ChannelName
        {
            get
            {
                return  DefaultChannelName;
            }
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.MimeType"]/*' />
        public String MimeType
        {
            get 
            { 
                return m_mimeType; 
            }
            set 
            { 
                m_mimeType = value; 
            }
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.Parse"]/*' />
        public String Parse(String url, out String objectURI)
        {
            return InternalParse(url, out objectURI);
        }

        //------------------------ I_CHANNEL_SENDER ------------------
        // IChannelSender
        internal static String InternalParse(String url, out String objectURI)
        {
            InternalRemotingServices.RemotingTrace("SmtpChannel.Parse URL in: " + url);
            
            // Set the out parameters
            objectURI = null;
            String trm = DefaultChannelName + "://";  

            // Find the starting point of channelName + ://
            int separator = String.Compare(url, 0, trm, 0, trm.Length, true, CultureInfo.InvariantCulture);
            if ((-1 == separator) || (0 != separator))
            {
                throw new ArgumentException("Argument_InvalidValue");
            }
            String suffix = url.Substring(separator + trm.Length);

            separator = suffix.IndexOf('/');

            if (-1 == separator)
            {
                throw new ArgumentException("Argument_InvalidValue");
            }

            // Extract the channel URI which is the prefix
            String channelURI = suffix.Substring(0, separator);

            // Extract the object URI which is the suffix
            objectURI = suffix.Substring(separator+1);

            InternalRemotingServices.RemotingTrace("SmtpChannel.Parse URI in: " + url);
            InternalRemotingServices.RemotingTrace("SmtpChannel.Parse channelURI: " + channelURI);
            InternalRemotingServices.RemotingTrace("SmtpChannel.Parse objectURI: " + objectURI);
            
            return channelURI;      
        }

    }

    /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel"]/*' />
    public class SmtpChannel 
        :   SmtpChannelBase, 
            IChannelSender, IChannelReceiver, IDictionary,            
            ISmtpOnArrival
    {        
        // ----------------- Sender data -------------------
        private const String s_defaultSenderSubject = "SOAPRequest";
        private static long s_msgSequenceNumber = 0; 
        private static String s_prefixGuid = Guid.NewGuid().ToString() + "/";
        private Hashtable m_hashTable;
        // ----------------- End-Sender data ---------------


        // ----------------- Receiver data -----------------
        private const String s_defaultReceiverSubject = "SOAPResponse";
        private static Hashtable s_receiverTable = new Hashtable();
        private String m_mailboxName;
        private Guid m_receiverGuid;
        private IDictionary m_items;             

        // ----------------- End-Receiver data --------------

        // CTOR used to implicitly create and register a channel.
        // It assumes that the mailbox name is passed in as a command line
        // argument
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.SmtpChannel"]/*' />
        public SmtpChannel()
        {
            String[] args = System.Environment.GetCommandLineArgs();
            if(1 <= args.Length)
            {
                Init(args[1]);
            }
            else
            {
                throw new ArgumentNullException("Must specify the mailbox name as the first command line parameter");
            }
            InternalRemotingServices.RemotingTrace("Finished default const");
        }   
                             
        // CTOR used to manually register the channel
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.SmtpChannel1"]/*' />
        public SmtpChannel(String mailbox)
        {
            InternalRemotingServices.RemotingTrace("Reached common constr " + mailbox);
            
            // This constructor is used when messages are sent and received
            // from a mailbox
            Init(mailbox);

            InternalRemotingServices.RemotingTrace("Finished common constr");
        }
                
        // CTOR used via the configuration file
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.SmtpChannel2"]/*' />
        public SmtpChannel(String[] data)
        {
            if((null != data) && (0 != data.Length))
            {
                for(int i = 0; i < data.Length; i++)
                {
                    Init(data[i]);
                }
            }
            else
            {
                throw new ArgumentNullException("Must specify a mailbox name");
            }
        }

        // All the ctors delegate to this function to do the initialization
        private void Init(String mailbox)
        {
            if(null == mailbox)
            {
                throw new ArgumentNullException("mailbox");
            }
            m_mailboxName = mailbox;
            
            m_hashTable = new Hashtable();
            
            m_items = Hashtable.Synchronized(new Hashtable());
            
            InternalRemotingServices.RemotingTrace("SmtpChannel::Init Register the smtp listener");

            // Register the smtp listener                        
            lock(s_receiverTable)
            {
                InternalRemotingServices.RemotingTrace("SmtpChannel::Init Register the smtp listener - lock acquired");
                // Check if we have already registered a listener for this 
                // guid
                if(!s_receiverTable.Contains(m_mailboxName))
                {
                    InternalRemotingServices.RemotingTrace("SmtpChannel::Init Creating registry entry and registering guid");
                    m_receiverGuid = SmtpRegisterSink.CreateRegistryEntryForMailbox(mailbox);
                    InternalRemotingServices.RemotingTrace("Registering receiver for  " + m_receiverGuid);
                    s_receiverTable.Add(m_mailboxName, this);
                    new RegistrationServices().RegisterTypeForComClients(typeof(SmtpChannel), ref m_receiverGuid);
                }
            }
        }
               
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.CreateMessageSink"]/*' />
        public virtual IMessageSink CreateMessageSink(String url, Object data, out String objectURI)
        {

            // Set the out parameters
            objectURI = null;
            String channelURI = null;
            if ((null != url))
            {
                if (0 == String.Compare(url, 0, ChannelName, 0, ChannelName.Length, true, CultureInfo.InvariantCulture))
                {
                    channelURI = Parse(url, out objectURI);
                }
            }
            else
            {
                if ((null != data) && (data is String))
                {
                  channelURI = (String)data; 
                }
            }            

            if (null != channelURI)
            {                
                IMessageSink sink = new SmtpMessageSink(this, channelURI, m_mimeType);
                InternalRemotingServices.RemotingTrace("SmtpChannel::CreateMessageSink ChnlURI: " + channelURI + " ObjURI: " + objectURI);

                return sink;          
            }

            return null;
        }

        
        //------------------------ END: I_CHANNEL_SENDER --------------
        
        //------------------------ I_CHANNEL_RECEIVER -----------------
        // IChannelReceiver
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.ChannelData"]/*' />
        public Object ChannelData
        {
            get
            {
                if (null != m_mailboxName)
                {
                    StartListening(null);
                    return GetChannelUri();
                }
                else
                {                    
                    return null;
                }
            }
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.GetChannelUri"]/*' />
        public String GetChannelUri()
        {
            return m_mailboxName;
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.GetUrlsForUri"]/*' />
        public virtual String[] GetUrlsForUri(String objectURI)
        {
            String[] retVal = new String[1];
            
            retVal[0] = "smtp://" + GetChannelUri() + "/" + objectURI;
            
            return retVal;
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.StartListening"]/*' />
        public void StartListening(Object data)
        {
            InternalRemotingServices.RemotingTrace("SmtpChannel.StartListening");
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.StopListening"]/*' />
        public void StopListening(Object data)
        {
            InternalRemotingServices.RemotingTrace("SmtpChannel.StopListening");
        }

        
        //------------------------ END: I_CHANNEL_RECEIVER ------------
        
        // DICTIONARY IMPLEMENTION        
        //Properties
        
        //IDictionary
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.this"]/*' />
        public Object this[Object key] 
        {                
            get { return m_items[key];}
            set 
            { 
                 m_items[key] = value;                 
            }                
        }
    
        // Returns a collections of the keys in this dictionary.
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Keys"]/*' />
        public ICollection Keys 
        {
            get { return m_items.Keys;}
        }
    
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Values"]/*' />
        public ICollection Values 
        {        
            get {return m_items.Values;}
        }
    
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Contains"]/*' />
        public bool Contains(Object key)
        { 
            return m_items.Contains(key);
        }
    
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Add"]/*' />
        public void Add(Object key, Object value)
        {
            m_items.Add(key, value);
        }
    
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Clear"]/*' />
        public void Clear()
        {
            m_items.Clear();
        }
    
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.GetEnumerator"]/*' />
        public virtual IDictionaryEnumerator GetEnumerator() 
        {
            return m_items.GetEnumerator();
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Remove"]/*' />
        public void Remove(Object key)
        {
            m_items.Remove(key);
        }

        //ICollection

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.CopyTo"]/*' />
        public void CopyTo(Array array, int index)
        {
            m_items.CopyTo(array, index);
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Count"]/*' />
        public int Count
        { 
            get {return m_items.Count;} 
        }


        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.SyncRoot"]/*' />
        public Object SyncRoot
        {   
            get {return m_items.SyncRoot;} 
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.IsReadOnly"]/*' />
        public  bool IsReadOnly 
        { 
            get {return m_items.IsReadOnly;} 
        }

		/// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.IsFixedSize"]/*' />
		public  bool IsFixedSize 
        { 
            get {return m_items.IsFixedSize;} 
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.IsSynchronized"]/*' />
        public bool IsSynchronized
        { 
            get {return m_items.IsSynchronized;} 
        }

        //IEnumerable
        IEnumerator IEnumerable.GetEnumerator() 
        {
            return m_items.GetEnumerator();
        }    
        // END: DICTIONARY IMPLEMENTION                        

        // ISmtpOnArrival 
        // Receives incoming messages which can either be a request to dispatch
        // a call or a response to a call
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.OnArrival"]/*' />
        public virtual void OnArrival(ISmtpMessage  smtpMessage, ref CdoEventStatus EventStatus)        
        {
           bool fIsOneWay = false;
           try
           {
                InternalRemotingServices.RemotingTrace("Reached OnArrival");                
                
                ISmtpOnArrival receiver = null;
                // Get the global receiver. If this instance is the global 
                // receiver then proceed else delegate to it.
                if(IsReceiver(smtpMessage, ref receiver))
                {
                    // Check whether this message is a SOAP request message or a
                    // SOAP response message
                    String subject = smtpMessage.Subject;
                    bool fRequest = false;                    
                    // Proceed only if this is a SOAP request or response
                    if(s_defaultSenderSubject.Equals(subject))
                    {
                        fRequest = true;
                    }
                    else if(!s_defaultReceiverSubject.Equals(subject))
                    {
                        throw new Exception("Invalid subject type " + subject);
                    }
                    
                    // Extract the releavant mail headers                            
                    String contentType = null;
                    Smtp.Fields headers = null;
                    Header[] msgHeaders = null;
                    String seqNum = GetHeaders(smtpMessage, ref headers, ref contentType, ref msgHeaders);
                    
                    // Create a stream out of the body of the mail
                    MemoryStream stm = new MemoryStream(Encoding.ASCII.GetBytes(smtpMessage.TextBody));
                    InternalRemotingServices.RemotingTrace("Created memory stream");
                    
                    // Check whether this is a request or a response message
                    if(fRequest)
                    {
                        // Dispatch this method and determine whether this 
                        // method is one way. 
                        ProcessRequest(smtpMessage, headers, msgHeaders, contentType, seqNum, stm, ref fIsOneWay);
                    }
                    else
                    {
                        ProcessResponse(smtpMessage, contentType, seqNum, stm);
                    }                            
                }
                else
                {
                    if(null != receiver)
                    {
                        // A message was addressed to us .. delegate to the
                        // global receiver
                        receiver.OnArrival(smtpMessage, ref EventStatus);
                    }
                }
                        
                InternalRemotingServices.RemotingTrace("Success!");                                
            }
            catch(Exception e)
            {
                InternalRemotingServices.RemotingTrace("Reached an exception " + e.StackTrace);
                InternalRemotingServices.RemotingTrace("Exception message " + e.Message);
                if(!fIsOneWay)
                {
                    //@TODO
                    //ProcessException(smtpMessage, contentType, headers, seqNum);
                }
            }
            finally
            {
                EventStatus = CdoEventStatus.CdoSkipRemainingSinks;
            }
        }
        
        
        // Internal methods         
        internal IMessage SyncProcessMessage(IMessage reqMsg, String receiver)
        {
            IMessage desResMsg = null;
            bool fAdded = true;
            String seqNum = null;
            try
            {
                InternalRemotingServices.RemotingTrace("SmtpChannel::SyncProcessMessage");
    
                // HACKALERT::
                // we are going to temporarily not send the call context
                Object callContext = reqMsg.Properties["__CallContext"];
                if (callContext != null)
                {
                    reqMsg.Properties["__CallContext"] = null;
                }
    
                //
                // Create a new wait object which will wait for the
                // response to arrive 
                //
                WaitObject obj = new WaitObject(reqMsg, null);                
                seqNum = GetNextSequenceNumber();
                m_hashTable.Add(seqNum, obj);
                fAdded = true;
                
                //
                // Serialize the message and send it using Smtp 
                //
                SendMessage(reqMsg, receiver, seqNum);
    
                //
                // Receive server response
                //
                InternalRemotingServices.RemotingTrace("SmtpMessageSink::SyncProcessMessage before ReceiveResponse");            
            
                desResMsg = ReceiveMessage(obj);
                
                if (callContext != null)
                {
                    desResMsg.Properties["__CallContext"] = callContext;
                }                
                
                InternalRemotingServices.RemotingTrace("SmtpChannel::Returning successfully from SyncProcessMessage");
            }
            catch(Exception e)
            {
                InternalRemotingServices.RemotingTrace("SmtpChannel::SyncProcessMessage threw exception " + e.StackTrace);
                try
                {
                    if(fAdded)
                    {
                        m_hashTable.Remove(seqNum);
                    }
                    desResMsg = new ReturnMessage(e, null);
                }
                catch(Exception )
                {
                    // Fatal error.. return null
                }            
            }
            return desResMsg;
        }
        
        internal IMessageCtrl AsyncProcessMessage(IMessage msg,
                                                  IMessageSink replySink,
                                                  String receiver)        
        {
            IMessage desResMsg = null;
            bool fAdded = true;
            String seqNum = null;
            try
            {
                //
                // Create a new wait object which will wait for the
                // response to arrive 
                //
                if(null != replySink)
                {
                    WaitObject obj = new WaitObject(msg, replySink);
                    seqNum = GetNextSequenceNumber();
                    m_hashTable.Add(seqNum, obj);
                    fAdded = true;
                }

                SendMessage(msg, receiver, seqNum);

                // Note: The response will be deliverd to the OnArrival method
                // which is responsible for notifying the sink.                                                           
            }
            catch(Exception e)
            {
                InternalRemotingServices.RemotingTrace("SmtpChannel::AsyncProcessMessage threw exception " + e.StackTrace);
                try
                {
                    // Cleanup state
                    if(fAdded)
                    {
                        m_hashTable.Remove(seqNum);
                    }
                                        
                    // Notify the sink
                    if(null != replySink)
                    {
                        // Create a message which encapsulates an exception
                        desResMsg = new ReturnMessage(e, null);
                        replySink.SyncProcessMessage(desResMsg);
                    }
                }
                catch(Exception )
                {
                    // Fatal error.. return null
                }            
            }
            
            return null;
        }        
        
        void SendMessage(IMessage msg, String receiver, String seqNum)
        {
            if (msg == null)
                throw new ArgumentNullException("msg");            

            InternalRemotingServices.RemotingTrace("SmtpMessageSink::ProcessAndSend 1");

            //
            // Serialize the message
            //
            byte [] byteMessage;
            int byteMessageLength = 0;

            InternalRemotingServices.RemotingTrace("SmtpMessageSink::ProcessAndSend 2");

            MemoryStream stm = (MemoryStream)CoreChannel.SerializeMessage(m_mimeType, msg);

            InternalRemotingServices.RemotingTrace("SmtpMessageSink::ProcessAndSend 3");
            // reset stream to beginning
            stm.Position = 0;
            byteMessage = stm.ToArray();
            byteMessageLength = byteMessage.Length;

            //
            // Create a new mail message
            //
            MailMessage mail = new MailMessage();
            
            // Add the required and optional headers
            PutHeaders(mail, (IMethodCallMessage)msg, receiver, seqNum, byteMessageLength);
            
            // Add the body of the message
            mail.Body = System.Text.Encoding.ASCII.GetString(byteMessage, 0, byteMessage.Length);
            
            //
            // Send request
            //
            InternalRemotingServices.RemotingTrace("SmtpMessageSink::ProcessAndSend before Send");
            SmtpMail.Send(mail);                
        }
        
        IMessage ReceiveMessage(WaitObject obj)
        {
            IMessage desResMsg = null;
            
            InternalRemotingServices.RemotingTrace("SmtpChannel::RecieveMessage IN");            
            lock(obj)
            {
                if(obj.ShouldWait)
                {
                    InternalRemotingServices.RemotingTrace("ReceiveMessage Staring wait...");
                    
                    // This will release the lock and wait till the
                    // receiving thread signals it
                    Monitor.Wait(obj);
                }
                
                // Extract the response object which is set by the
                // thread which received the response
                desResMsg = obj.Response;
            }
            
            InternalRemotingServices.RemotingTrace("Received message");            
            return desResMsg;
        }
        
        // Generates a reply to an incoming Smtp message and sends it
        void ReplyMessage(IMessage replyMsg, ISmtpMessage smtpInMsg, 
                          String seqNum, Smtp.Fields headers)
        {
            MemoryStream stm = (MemoryStream)CoreChannel.SerializeMessage(m_mimeType, replyMsg);
            // reset stream to beginning
            stm.Position = 0;
            byte[] byteMessage = stm.ToArray();
            int byteMessageLength = byteMessage.Length;
            String reply = System.Text.Encoding.ASCII.GetString(byteMessage, 0, byteMessage.Length);

            // Create a reply message
            MailMessage smtpOutMsg = new MailMessage();
            
            // Fill in the headers
            PutHeaders(smtpOutMsg, smtpInMsg, (IMethodMessage)replyMsg, seqNum, reply.Length);
         
            // Set the body
            smtpOutMsg.Body = reply;
               
            // Send the message 
            SmtpMail.Send(smtpOutMsg);
        }
        
        // Generate headers for request message
        void PutHeaders(MailMessage mail, IMethodCallMessage mcMessage,
                        String receiver, String seqNum, int msgLength)
        {
            String sender = (String)ChannelData;
            String action = SoapServices.GetSoapActionFromMethodBase(mcMessage.MethodBase);
            PutHeaders(mail, sender, receiver, s_defaultSenderSubject, action,
                       mcMessage.Uri, seqNum, msgLength); 
        }
        
        // Generate headers for reply message
        void PutHeaders(MailMessage mail, ISmtpMessage inMessage, 
                        IMethodMessage replyMsg, String seqNum, int msgLength)
        {            
            String sender = inMessage.To;
            String receiver = inMessage.From;
            String action = SoapServices.GetSoapActionFromMethodBase(replyMsg.MethodBase);
            String uri = replyMsg.Uri;
            
            PutHeaders(mail, sender, receiver, s_defaultReceiverSubject, 
                       action, uri, seqNum, msgLength);
        }
        
        // Common routine for adding SOAP headers in a mail
        void PutHeaders(MailMessage mail, String sender, String receiver, 
                        String subject, String action, String uri, 
                        String seqNum, int msgLength)        
        {
                        
            // Set the required Smtp headers
            mail.From = sender;
            mail.To = receiver;
            
            // Set the optional Smtp headers
            mail.Subject = subject;
            //MailPriority Priority = MailPriority.Normal;
            //String       UrlContentBase;
            //String       UrlContentLocation;
            //MailFormat   BodyFormat = MailFormat.Text;
            //IList        Attachments 
            
            //
            // Add additional headers which is used by SOAP to dispatch calls
            // 
            IDictionary  smtpHeaders = mail.Headers; 
            
            // Action
            smtpHeaders.Add("SOAPAction", action);
            
            // Content-type 
            smtpHeaders.Add("ContentType", m_mimeType);
            
            // Message sequence number            
            if(null != seqNum)
            {
                smtpHeaders.Add("SOAPMsgSeqNum", seqNum);
            }
            
            // Request type
            smtpHeaders.Add("SOAPRequestType", "POST");
            
            // URI
            smtpHeaders.Add("RequestedURI", uri);

            //@TODO Version number
                                    
            // Content-length
            smtpHeaders.Add("Content-length", (msgLength).ToString());                        
        }                         
        
        bool IsReceiver(ISmtpMessage smtpMessage, ref ISmtpOnArrival receiver)
        {
            bool fReceive = false;
            
            // Get the one and only receiver 
            //BCLDebug.Assert(m_receiverGuid != Guid.Empty, "m_receiverGuid != Guid.Empty");                
            receiver = (ISmtpOnArrival)s_receiverTable[m_mailboxName];
            if(null == receiver)
            {
                throw new Exception(CoreChannel.GetResourceString("Remoting_NoReceiverRegistered"));
            }                 
            
            if(receiver == this)
            {
                String mailbox = smtpMessage.To;
                
                // Only process those messages which are addressed to us
                InternalRemotingServices.RemotingTrace("mailbox " + m_mailboxName + " receiver " + mailbox);
                if((null != m_mailboxName) && 
                   (-1 != CultureInfo.CurrentCulture.CompareInfo.IndexOf(mailbox, m_mailboxName, CompareOptions.IgnoreCase)))
                {
                    InternalRemotingServices.RemotingTrace("Mailboxes match");
                    fReceive = true;
                }
                else
                {
                    // We don't do anything with messages not addressed to us
                    receiver = null;
                }    
            }
            
            return fReceive;
        }
        
        String GetHeaders(ISmtpMessage smtpMessage, ref Smtp.Fields headers, ref String contentType, ref Header[] msgHeaders)
        {
            // Get the headers from the message object
            headers = smtpMessage.Fields;
#if _DEBUG                            
            long count = headers.Count;
            InternalRemotingServices.RemotingTrace(" Count of fields " + count);
            for(long i = 0; i < count; i++)
            {
                //InternalRemotingServices.RemotingTrace(" Field " + i + " " + headers[i].Name + " " + headers[i].Value);
            }
#endif                            
                            
            // Get the content type string
            Field typeField = headers["urn:schemas:mailheader:contenttype"];
            if(null == typeField)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_MissingContentType"));
            }
            contentType = (String)(typeField.Value);     
            InternalRemotingServices.RemotingTrace("Content type " + typeField.Name + " " + contentType);

            // Extract the requested uri from the mail header
            Field uriField = headers["urn:schemas:mailheader:requesteduri"];    
            if(null == uriField)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_MissingRequestedURIHeader"));
            }
            String uriValue = (String)uriField.Value;
            if(null == uriValue)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_MissingRequestedURIHeader"));
            }
        
            // process SoapAction (extract the type and the name of the method to be invoked)
            Field actionField = headers["urn:schemas:mailheader:soapaction"];   
            if(null == actionField)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_SoapActionMissing"));
            }
            String actionValue = (String)actionField.Value;
            if(null == actionValue)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_SoapActionMissing"));
            }

            String typeName, methodName;
            if (!SoapServices.GetTypeAndMethodNameFromSoapAction(actionValue, out typeName, out methodName))
            {
                // This means there are multiple methods for this soap action, so we will have to
                // settle for the type based off of the uri.
                Type type = RemotingServices.GetServerTypeForUri(uriValue);
                typeName = type.FullName + ", " + type.Module.Assembly.GetName().Name;
            }
            
            // BUGBUG: need code to verify soap action after the message has been deserialized.
            //   this will probably be done once we have the new activation scenario working.
            
            msgHeaders = new Header[3];
            msgHeaders[0] = new Header("__Uri", uriValue);
            msgHeaders[1] = new Header("__TypeName", typeName);
            msgHeaders[2] = new Header("__MethodName", methodName);

            // Extract the message sequence number field from the 
            // mail header
            Field seqField = headers["urn:schemas:mailheader:soapmsgseqnum"];
            if(null == seqField)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_MissingSoapMsgSeqNum"));
            }
            String seqValue = (String)(seqField.Value);
            InternalRemotingServices.RemotingTrace("Guid value " + seqValue);            
            
            return seqValue;
        }
        
        void ProcessRequest(ISmtpMessage smtpMessage, Smtp.Fields headers,
                            Header[] msgHeaders, String contentType, String seqNum, 
                            MemoryStream stm, ref bool fIsOneWay)
        {
            IMessage outMsg = null;
            fIsOneWay = false;    
            
            // Deserialize - Stream to IMessage
            IMessage inMsg = CoreChannel.DeserializeMessage(contentType, stm, true, null, msgHeaders);
            InternalRemotingServices.RemotingTrace("Deserialized message");
            
            if (inMsg == null)
            {
                throw new Exception(CoreChannel.GetResourceString("Remoting_DeserializeMessage"));
            }
            
            // Set URI - BUGBUG: temp hack
            String url = ((IMethodMessage)inMsg).Uri;
            String objectURL = null;
            try
            {
                Parse(url, out objectURL);
            }
            catch(Exception )
            {
                objectURL = url;
            }
            inMsg.Properties["__Uri"] = objectURL;
            
            // Dispatch Call
            InternalRemotingServices.RemotingTrace("ChannelServices.SyncDispatchMessage - before");
            outMsg = ChannelServices.SyncDispatchMessage(inMsg);
            InternalRemotingServices.RemotingTrace("ChannelServices.SyncDispatchMessage - after");
            
            // We do not send a reply for one way messages. If the message
            // is not one way and we have a null return message then we 
            // throw an exception
            if (null == outMsg)
            {
                MethodBase method = ((IMethodMessage)inMsg).MethodBase;
                fIsOneWay = RemotingServices.IsOneWay(method);
                if(!fIsOneWay)
                {
                    throw new Exception(CoreChannel.GetResourceString("Remoting_DispatchMessage"));
                }
            }
            else
            {                            
                ReplyMessage(outMsg, smtpMessage, seqNum, headers);
                InternalRemotingServices.RemotingTrace("Reply sent");        
            }                            
        }
        
        void ProcessResponse(ISmtpMessage smtpMessage, String contentType, 
                             String seqNum, MemoryStream stm)
        {
            InternalRemotingServices.RemotingTrace("Received response");
            
            // Notify the waiting object that its response
            // has arrived
            WaitObject obj = (WaitObject)m_hashTable[seqNum];
            if(null != obj)
            {
                InternalRemotingServices.RemotingTrace("Found an object waiting");
                
                // First remove the object in a threadsafe manner
                // so that we do not deliver the response twice
                // due to duplicate replies or other errors from
                // Smtp
                
                lock(obj)
                {
                    if(m_hashTable.Contains(seqNum))
                    {
                        InternalRemotingServices.RemotingTrace("Found an object to notify");
                        m_hashTable.Remove(seqNum);
                        
                        IMethodCallMessage request = (IMethodCallMessage)obj.Request;
                        Header[] h = new Header[3];
                        h[0] = new Header("__TypeName", request.TypeName);
                        h[1] = new Header("__MethodName", request.MethodName);
                        h[2] = new Header("__MethodSignature", request.MethodSignature);
                        
                        IMessage response = CoreChannel.DeserializeMessage(contentType, stm, false, request, h);
                        InternalRemotingServices.RemotingTrace("Deserialized message");
        
                        if (response == null)
                        {
                            throw new Exception(CoreChannel.GetResourceString("Remoting_DeserializeMessage"));
                        }
                                                                                                                                                 
                        // Notify the object
                        obj.Notify(response);
                    }
                }
                
            }
            else
            {
                InternalRemotingServices.RemotingTrace("No object waiting");
            }
        }
        
        private void ProcessException(ISmtpMessage smtpMessage, Smtp.Fields headers,
                                      String contentType, String seqNum)
        {
            try
            {
            }
            catch(Exception )
            {
                // Fatal error .. ignore
            }
        }
                                              
        private static String GetNextSequenceNumber()
        {
            return s_prefixGuid + (Interlocked.Increment(ref s_msgSequenceNumber)).ToString();
        }
    }

    // Class used to rendezvous request and response messages
    internal class WaitObject
    {
        private bool m_fWait;
        private IMessage m_response;
        private IMessage m_request;
        private IMessageSink m_sink;
        
        internal WaitObject(IMessage request, IMessageSink sink)
        {
            m_fWait = true;
            m_request = request;
            m_sink = sink;
        }
        
        internal bool ShouldWait
        {
            get { return m_fWait; }
            set { m_fWait = value; } 
        }
        
        internal IMessage Response 
        {
            get { return m_response; }
            set { m_response = value; }
        }
        
        internal IMessage Request
        {
            get { return m_request; }
        }
        
        internal void Notify(IMessage response)
        {
            // Set a flag to indicate that
            // it is no longer necessary to wait if one
            // hasn't started waiting yet
            m_fWait = false;                                                
            
            // Set the response message
            m_response = response;
            
            // Check whether we have to pulse the object 
            // or call on a sink            
            if(null == m_sink)
            {                
                // Pulse the object if it is waiting
                Monitor.Pulse(this);               
            }
            else
            {
                // Notify the sink that the response has arrived
                m_sink.SyncProcessMessage(response);
            }
        }
    }
    
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\system\security\securityresources.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: SecurityResources
**
** Author: Rudi Martin
**
** Purpose: Internal class providing access to resources in
**          System.Security.dll.
**
** Date: July 14, 2000
**
============================================================*/

namespace System.Security {

    using System;
    using System.Resources;

    internal class SecurityResources
    {
        private static ResourceManager s_resMgr = null;

        public static String GetResourceString(String key)
        {
            if (s_resMgr == null)
                s_resMgr = new ResourceManager("system.security", typeof(SecurityResources).Module.Assembly);
            return s_resMgr.GetString(key, null);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\system\security\cryptography\xml\dataobject.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------
//
// CLASS:    DataObject.cool
//
// AUTHOR:   Christian Caron (t-ccaron)
//
// PURPOSE:  This class implements the http://www.w3.org/2000/02/xmldsig#Object
//           element.
// 
// DATE:     21 March 2000
// 
//---------------------------------------------------------------------------

namespace System.Security.Cryptography.Xml
{
    using System;
    using System.IO;
    using System.Text;
    using System.Xml;
    using System.Security;

    /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject"]/*' />
    public class DataObject
    {
        private String m_strId;
        private String m_strMimeType;
        private String m_strEncoding;
        private CanonicalXmlNodeList m_elData;
        private XmlElement m_cachedXml;

        //-------------------------- Constructors ---------------------------

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.DataObject"]/*' />
        public DataObject()
        {
            m_cachedXml = null;
            m_elData = new CanonicalXmlNodeList();
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.DataObject1"]/*' />
        public DataObject(String id, String mimeType, String encoding, XmlElement data) {
            if (data == null) throw new ArgumentNullException("data");
            m_strId = id;
            m_strMimeType = mimeType;
            m_strEncoding = encoding;
            m_elData = new CanonicalXmlNodeList();
            m_elData.Add(data);
            m_cachedXml = null;
        }

        //-------------------------- Properties -----------------------------

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.Id"]/*' />
        public String Id
        {
            get { return m_strId; }
            set { 
                m_strId = value;
                m_cachedXml = null;
            }
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.MimeType"]/*' />
        public String MimeType
        {
            get { return m_strMimeType; }
            set { 
                m_strMimeType = value; 
                m_cachedXml = null;
            }
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.Encoding"]/*' />
        public String Encoding
        {
            get { return m_strEncoding; }
            set { 
                m_strEncoding = value;
                m_cachedXml = null;
            }
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.Data"]/*' />
        public XmlNodeList Data
        {
            get { return m_elData; }
            set { 
                // Guard against null
                if (value == null)
                    throw new ArgumentNullException("value");
                    
                // Reset the node list
                m_elData = new CanonicalXmlNodeList();                
                foreach (XmlNode node in value) {
                    m_elData.Add(node);
                }
                m_cachedXml = null;
            }
        }

        internal bool CacheValid {
            get { 
                return(m_cachedXml != null);
            }
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetXml"]/*' />
        public XmlElement GetXml() {
            if (CacheValid) {
                return(m_cachedXml);
            } else {
                XmlDocument document = new XmlDocument();
                XmlElement objectElement = document.CreateElement("Object",SignedXml.XmlDsigNamespaceUrl);
                //objectElement.SetAttribute("xmlns","");
                
                if ((m_strId != null) && (m_strId != ""))
                    objectElement.SetAttribute("Id", m_strId);
                
                if ((m_strMimeType != null) && (m_strMimeType != ""))
                    objectElement.SetAttribute("MimeType", m_strMimeType);

                if ((m_strEncoding != null) && (m_strEncoding != ""))
                    objectElement.SetAttribute("Encoding", m_strEncoding);

                if (m_elData != null) {
                    foreach (XmlNode node in m_elData) {
                        objectElement.AppendChild(document.ImportNode(node,true));
                    }    
                }

                return objectElement;
            }
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.LoadXml"]/*' />
        public void LoadXml(XmlElement value) {
            // Guard against nulls
            if (value == null)
                throw new ArgumentNullException("value");
            m_strId = value.GetAttribute("Id");
            m_strMimeType = value.GetAttribute("MimeType");
            m_strEncoding = value.GetAttribute("Encoding");

            foreach (XmlNode node in value.ChildNodes) {
                m_elData.Add(node);
            }

            // Save away the cached value
            m_cachedXml = value;
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\metadata\wsdlwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** File:    WsdlWriter.cs
 **
 ** Author:  Peter de Jong (pdejong)
 **
 ** Purpose: Defines WsdlWriter that parses a given Wsdl document
 **          and generates types defined in it.
 **
 ** Date:    November 15, 2000
 **
 ===========================================================*/
namespace System.Runtime.Remoting.MetadataServices
{
    using System;
    using System.Threading;
    using System.Collections;
    using System.Reflection;
    using System.Xml;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Net;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Metadata; 
    using System.Runtime.Serialization;
    using System.Runtime.Remoting.Channels; // This is so we can get the resource strings.
    using System.Globalization;

    // This class generates SUDS documents
    internal class WsdlGenerator
    {
        // Constructor
        internal WsdlGenerator(Type[] types, TextWriter output)
        {
            Util.Log("WsdlGenerator.WsdlGenerator 1");
            _textWriter = output;
            _queue = new Queue();
            _name = null;
            _namespaces = new ArrayList();
            _dynamicAssembly = null;
            _serviceEndpoint = null;
            for (int i=0;i<types.Length;i++)
            {
                if (types[i] != null)
                {
                    if (types[i].BaseType != null)
                    {
                        Util.Log("WsdlGenerator.WsdlGenerator ProcessTypeAttributes 1 "+types[i]);
                        ProcessTypeAttributes(types[i]);
                        _queue.Enqueue(types[i]);
                    }
                }
            }
        }

        // Constructor
        internal WsdlGenerator(Type[] types, SdlType sdlType, TextWriter output)
        {
            Util.Log("WsdlGenerator.WsdlGenerator 2");
            _textWriter = output;
            _queue = new Queue();
            _name = null;
            _namespaces = new ArrayList();
            _dynamicAssembly = null;
            _serviceEndpoint = null;
            for (int i=0;i<types.Length;i++)
            {
                if (types[i] != null)
                {
                    if (types[i].BaseType != null)
                    {
                        Util.Log("WsdlGenerator.WsdlGenerator ProcessTypeAttributes 2 "+types[i].BaseType);
                        ProcessTypeAttributes(types[i]);
                        _queue.Enqueue(types[i]);
                    }
                }
            }
        }

        // Constructor
        internal WsdlGenerator(Type[] types, TextWriter output, Assembly assembly, String url)
        : this(types, output)
        {
            Util.Log("WsdlGenerator.WsdlGenerator 3 "+url);         
            _dynamicAssembly = assembly;
            _serviceEndpoint = url;
        }

        // Constructor
        internal WsdlGenerator(Type[] types, SdlType sdlType, TextWriter output, Assembly assembly, String url)
        : this(types, output)
        {
            Util.Log("WsdlGenerator.WsdlGenerator 4 "+url);         
            _dynamicAssembly = assembly;
            _serviceEndpoint = url;
        }

        internal WsdlGenerator(ServiceType[] serviceTypes, SdlType sdlType, TextWriter output)
        {
            Util.Log("WsdlGenerator.WsdlGenerator 5 ");
            _textWriter = output;
            _queue = new Queue();
            _name = null;
            _namespaces = new ArrayList();
            _dynamicAssembly = null;
            _serviceEndpoint = null;

            for (int i=0; i<serviceTypes.Length; i++)
            {
                if (serviceTypes[i] != null)
                {
                    if (serviceTypes[i].ObjectType.BaseType != null)
                    {
                        Util.Log("WsdlGenerator.WsdlGenerator ProcessTypeAttributes 3 objectType "+serviceTypes[i].ObjectType+" basetype "+serviceTypes[i].ObjectType.BaseType);
                        ProcessTypeAttributes(serviceTypes[i].ObjectType);
                        _queue.Enqueue(serviceTypes[i].ObjectType);
                    }
                }

                // Associate serviceEndpoint with type. A type can have multiple serviceEndpoints
                if (serviceTypes[i].Url != null)
                {
                    if (_typeToServiceEndpoint == null)
                        _typeToServiceEndpoint = new Hashtable(10);
                    if (_typeToServiceEndpoint.ContainsKey(serviceTypes[i].ObjectType.Name))
                    {
                        ArrayList serviceEndpoints = (ArrayList)_typeToServiceEndpoint[serviceTypes[i].ObjectType.Name];
                        serviceEndpoints.Add(serviceTypes[i].Url);
                    }
                    else
                    {
                        ArrayList serviceEndpoints = new ArrayList(10);
                        serviceEndpoints.Add(serviceTypes[i].Url);
                        _typeToServiceEndpoint[serviceTypes[i].ObjectType.Name] = serviceEndpoints;
                    }

                }
            }
        }

        internal static void QualifyName(StringBuilder sb, String ns, String name)
        {
            if (!(ns == null || ns.Length == 0))
            {
                sb.Append(ns);
                sb.Append('.');
            }
            sb.Append(name);
        }


        internal static String RefName(Type type)
        {
            String refName = type.Name;

            if (!(type.IsPublic || type.IsNotPublic))
            {
                Util.Log("WsdlGenerator.WsdlGenerator RefName nested "+type);
                // nested name
                refName = type.FullName;
                int index = refName.LastIndexOf('.');
                if (index > 0)
                {
                    // nested type, type.Name returns full type rather then simple type
                    refName = refName.Substring(index+1);
                }
                refName = refName.Replace('+', '.');
            }

            return refName;
        }

        internal void ProcessTypeAttributes(Type type)
        {
            // Check to see if the xsd and xsi schema types should be 1999 instead of 2000. This is a temporary fix for an interop problem
            SoapTypeAttribute att = InternalRemotingServices.GetCachedSoapAttribute(type) as SoapTypeAttribute;
            if (att != null)
            {
                SoapOption soapOption = att.SoapOptions;
                if ((soapOption &= SoapOption.Option1) == SoapOption.Option1)
                    _xsdVersion = XsdVersion.V1999;
                else if ((soapOption &= SoapOption.Option2) == SoapOption.Option2)
                    _xsdVersion = XsdVersion.V2000;
                else
                    _xsdVersion = XsdVersion.V2001;
            }
            Util.Log("WsdlGenerator.ProcessTypeAttributes "+type+" SoapOptions "+((Enum)att.SoapOptions).ToString()+" _xsdVersion "+((Enum)_xsdVersion).ToString());         

        }


        // Generates SUDS
        internal void Generate()
        {
            Util.Log("WsdlGenerator.Generate");         
            // Generate the trasitive closure of the types reachable from
            // the supplied types
            while (_queue.Count > 0)
            {
                // Dequeue from not yet seen queue
                Type type = (Type) _queue.Dequeue();
                ProcessType(type);
            }

            // At this point we have the complete list of types
            // to be processed. Resolve cross references between
            // them
            Resolve();

            // At this stage, we are ready to print the schemas
            PrintWsdl();

            // Flush cached buffers
            _textWriter.Flush();

            return;
        }

        internal void ProcessType(Type type)
        {
            // Check if the type was encountered earlier
            String ns;
            Assembly assem;
            bool bInteropType = GetNSAndAssembly(type, out ns, out assem);
            Util.Log("WsdlGenerator.ProcessType Dequeue "+type+" ns "+ns+" assem "+assem);                         
            XMLNamespace xns = LookupNamespace(ns, assem);
            if (xns != null)
            {
                String searchName = WsdlGenerator.RefName(type);

                if (xns.LookupSchemaType(searchName) != null)
                {
                    return;
                }
            }
            else
            {
                xns = AddNamespace(ns, assem, bInteropType);
            }
            _typeToInteropNS[type] = xns;
            
            if (!type.IsArray)
            {
                // Check if type needs to be represented as a SimpleSchemaType
                SimpleSchemaType ssType = SimpleSchemaType.GetSimpleSchemaType(type, xns, false);
                Util.Log("WsdlGenerator.ProcessType simpleType "+ssType);

                if (ssType != null)
                {
                    // Add to namespace as a SimpleSchemaType
                    xns.AddSimpleSchemaType(ssType);
                }
                else
                {
                    // Check for the first MarshalByRef type
                    bool bUnique = false;
                    String connectURL = null;
                    Hashtable connectTypeToServiceEndpoint = null;
                    if (_name == null && s_marshalByRefType.IsAssignableFrom(type))
                    {
                        Util.Log("WsdlGenerator.ProcessType need new type "+type+" typename "+type.Name);          
                        _name = type.Name;
                        _targetNS = xns.Namespace;
                        _targetNSPrefix = xns.Prefix;
                        connectURL = _serviceEndpoint;
                        connectTypeToServiceEndpoint = _typeToServiceEndpoint;
                        bUnique = true;
                    }


                    RealSchemaType rsType = new RealSchemaType(type, xns, connectURL, connectTypeToServiceEndpoint, bUnique, this);
                    // Add to namespace as a RealSchemaType
                    xns.AddRealSchemaType(rsType);
                    // Enqueue types reachable from this type
                    EnqueueReachableTypes(rsType);
                }
            }
        }

        // Adds types reachable from the given type
        private void EnqueueReachableTypes(RealSchemaType rsType)
        {
            Util.Log("WsdlGenerator.EnqueueReachableTypes "+rsType.Name+" "+rsType.XNS.Name);           
            // Get the XML namespace object
            XMLNamespace xns = rsType.XNS;

            // Process base type
            if (rsType.Type.BaseType != null)
            {
                if (rsType.Type.BaseType != s_valueType || rsType.Type.BaseType != s_objectType)
                    AddType(rsType.Type.BaseType, GetNamespace(rsType.Type.BaseType));
            }

            // Check if this is a suds type
            bool bSUDSType = rsType.Type.IsInterface ||
                             s_marshalByRefType.IsAssignableFrom(rsType.Type) ||
                             
                             s_delegateType.IsAssignableFrom(rsType.Type);
            if (bSUDSType)
            {
                Util.Log("WsdlGenerator.EnqueueReachableTypes suds type "+rsType.Name+" "+rsType.XNS.Name);           
                // Process fields
                FieldInfo[] fields = rsType.GetInstanceFields();
                for (int i=0;i<fields.Length;i++)
                {
                    if (fields[i].FieldType == null)
                        continue;
                    AddType(fields[i].FieldType, xns);
                }

                // Process implemented interfaces
                Type[] interfaces = rsType.GetIntroducedInterfaces();
                if (interfaces.Length > 0)
                {
                    for (int i=0;i<interfaces.Length;i++)
                    {
                        Util.Log("WsdlGenerator.EnqueueReachableTypes Interfaces "+interfaces[i].Name+" "+xns.Name);                        
                        AddType(interfaces[i], xns);
                    }
                }

                ProcessMethods(rsType);

            }
            else
            {
                // Process fields
                FieldInfo[] fields = rsType.GetInstanceFields();
                for (int i=0;i<fields.Length;i++)
                {
                    if (fields[i].FieldType == null)
                        continue;
                    AddType(fields[i].FieldType, xns);
                }
            }

            return;
        }

        private void ProcessMethods(RealSchemaType rsType)
        {
            Util.Log("WsdlGenerator.ProcessMethods "+rsType);                       
            XMLNamespace xns = rsType.XNS;
            MethodInfo[] methods = rsType.GetIntroducedMethods();
            if (methods.Length > 0)
            {
                String methodNSString = null;
                XMLNamespace methodXNS = null;  

                if (xns.IsInteropType)
                {
                    methodNSString = xns.Name;
                    methodXNS = xns;
                }
                else
                {
                    StringBuilder sb = new StringBuilder();
                    WsdlGenerator.QualifyName(sb, xns.Name, rsType.Name);
                    methodNSString = sb.ToString();
                    methodXNS = AddNamespace(methodNSString, xns.Assem);
                    xns.DependsOnSchemaNS(methodXNS, false);
                }

                for (int i=0;i<methods.Length;i++)
                {
                    MethodInfo method = methods[i];
                    Util.Log("WsdlGenerator.ProcessMethods methods "+method.Name+" "+methodXNS.Name);
                    AddType(method.ReturnType, methodXNS);
                    ParameterInfo[] parameters = method.GetParameters();
                    for (int j=0;j<parameters.Length;j++)
                        AddType(parameters[j].ParameterType, methodXNS); 
                }
            }
        }


        // Adds the given type if it has not been encountered before
        private void AddType(Type type, XMLNamespace xns)
        {
            Util.Log("WsdlGenerator.AddType "+type+" ns "+xns.Namespace);                      
            //  System.Array says that it has element type, but returns null
            //         when asked for the element type. IMO, System.Array should not
            //         say that it has an element type. I have already pointed this
            //         out to David Mortenson


            // Need to get underlying element type
            // For arrays of arrays, want element, not embedded array
            Type elementType = type.GetElementType();
            Type nextelementType = elementType;
            while(nextelementType != null)
            {
                nextelementType = elementType.GetElementType();
                if (nextelementType != null)
                    elementType = nextelementType;
                
            }
            Util.Log("WsdlGenerator.AddType elementType "+type+" elementType "+elementType);                      

            if (elementType != null)
                EnqueueType(elementType, xns);


            if (!type.IsArray && !type.IsByRef)
                EnqueueType(type, xns);

            if (!(type.IsPublic || type.IsNotPublic))
            {
                // nested type, enqueue parent
                String refTypeName = type.FullName;
                int index = refTypeName.IndexOf("+");
                if (index > 0)
                {
                    String parentName = refTypeName.Substring(0, index);
                    Assembly assembly = type.Module.Assembly;
                    Util.Log("WsdlGenerator.AddType parentName "+parentName+" assembly "+assembly);
                    Type parentType = assembly.GetType(parentName, true);
                    Util.Log("WsdlGenerator.AddType parentType "+parentType);
                    if (parentType == null)
                    {
                        //Error nested type
                    }
                    EnqueueType(parentType, xns);
                }
            }
        }

        private void EnqueueType(Type type, XMLNamespace xns)
        {
            Util.Log("WsdlGenerator.EnqueueType "+type+" ns "+xns.Namespace);                      
            if (!type.IsPrimitive || type == s_charType) //char is not a xsd type
            {
                String ns;
                Assembly assem;
                XMLNamespace dependsOnNS = null;

                bool bInteropType = GetNSAndAssembly(type, out ns, out assem);

                // Lookup the namespace
                dependsOnNS = LookupNamespace(ns, assem);
                // Creat a new namespace if neccessary
                if (dependsOnNS == null)
                    dependsOnNS = AddNamespace(ns, assem, bInteropType);

                // The supplied namespace depends directly on the namespace of the type
                String typeString = SudsConverter.MapClrTypeToXsdType(type); //see if this is a xsd type
                if (type.IsInterface || typeString != null || type == s_voidType)
                {
                    // Interfaces aren't in schema section
                    // Any xsd type
                    xns.DependsOnSchemaNS(dependsOnNS, false); 
                }
                else
                    xns.DependsOnSchemaNS(dependsOnNS, true);



                // Enqueue the type if does not belong to system namespace
                if (!type.FullName.StartsWith("System."))
                {
                    Util.Log("WsdlGenerator.EnqueueType place on queue "+type+" ns "+xns.Namespace);                      
                    _queue.Enqueue(type);
                }
            }
        }

        private static bool GetNSAndAssembly(Type type, out String ns, out Assembly assem)
        {
            Util.Log("WsdlGenerator.GetNSAndAssembly enter "+type);

            String xmlNamespace = null;
            String xmlElement = null;
            bool bInterop = false;
            SoapServices.GetXmlElementForInteropType(type, out xmlElement, out xmlNamespace);
            if (xmlNamespace != null)
            {
                ns = xmlNamespace;
                assem = type.Module.Assembly;
                bInterop = true;
            }
            else
            {
                // Return the namespace and assembly in which the type is defined
                ns = type.Namespace;
                assem = type.Module.Assembly;
                bInterop = false;
            }

            Util.Log("WsdlGenerator.GetNSAndAssembly exit ns "+ns+" assem "+assem+" bInterop "+bInterop);
            return bInterop;
        }

        private XMLNamespace LookupNamespace(String name, Assembly assem)
        {
            Util.Log("WsdlGenerator.LookupNamespace "+name);                        
            for (int i=0;i<_namespaces.Count;i++)
            {
                XMLNamespace xns = (XMLNamespace) _namespaces[i];

                if (name == xns.Name)
                    return(xns);
            }

            return(null);
        }

        private XMLNamespace AddNamespace(String name, Assembly assem)
        {
            return AddNamespace(name, assem, false);
        }

        private XMLNamespace AddNamespace(String name, Assembly assem, bool bInteropType)
        {
            Util.Log("WsdlGenerator.AddNamespace "+name);                       
            Debug.Assert(LookupNamespace(name, assem) == null, "Duplicate Type found");

            XMLNamespace xns = new XMLNamespace(name, assem,
                                                _serviceEndpoint,
                                                _typeToServiceEndpoint,
                                                "ns" + _namespaces.Count,
                                                bInteropType, this);
            _namespaces.Add(xns);

            return(xns);
        }

        private XMLNamespace GetNamespace(Type type)
        {
            Util.Log("WsdlGenerator.GetNamespace "+type);
            String ns = null;
            Assembly assem = null;
            bool bInteropType = GetNSAndAssembly(type, out ns, out assem);

            XMLNamespace xns = LookupNamespace(ns, assem);
            if (xns == null)
            {
                xns = AddNamespace(ns, assem, bInteropType);
            }
            return xns;
        }


        private void Resolve()
        {
            Util.Log("WsdlGenerator.Resolve ");                     
            for (int i=0;i<_namespaces.Count;i++)
                ((XMLNamespace) _namespaces[i]).Resolve();

            return;
        }

        private void PrintWsdl()
        {
            if (_targetNS == null || _targetNS.Length == 0)
            {
                // No marshalbyRef object so use another target
                // Find a namespace
                if (_namespaces.Count > 0)
                    _targetNS =  ((XMLNamespace)_namespaces[0]).Namespace;
                else
                    _targetNS = "http://schemas.xmlsoap.org/wsdl/";
            }


            String indent = "";
            String indent1 = IndentP(indent);
            String indent2 = IndentP(indent1);
            String indent3 = IndentP(indent2);
            String indent4 = IndentP(indent3);

            StringBuilder sb = new StringBuilder(256);          
            Util.Log("WsdlGenerator.PrintWsdl");
            _textWriter.WriteLine("<?xml version='1.0' encoding='UTF-8'?>");
            sb.Length = 0;
            sb.Append("<definitions ");
            if (_name != null)
            {
                sb.Append("name='");
                sb.Append(_name);
                sb.Append("' ");
            }
            sb.Append("targetNamespace='");
            sb.Append(_targetNS);
            sb.Append("'");
            _textWriter.WriteLine(sb);              

            PrintWsdlNamespaces(_textWriter, sb, indent3);

	    // See if there are any schema information to print.

	    bool bPrintTypeSection = false;
            for (int i=0;i<_namespaces.Count;i++)
            {
               if (((XMLNamespace) _namespaces[i]).CheckForSchemaContent())
	       {	
		   bPrintTypeSection = true;
		   break;
	       }
            }


	    if (bPrintTypeSection)
	    {
		PrintTypesBeginWsdl(_textWriter, sb, indent1);

		ArrayList realSchemaTypes = new ArrayList();            
		for (int i=0;i<_namespaces.Count;i++)
		{
		    if (((XMLNamespace) _namespaces[i]).CheckForSchemaContent())
		    {
			Util.Log("WsdlGenerator.PrintWsdl call PrintWsdlNamespaces "+((XMLNamespace) _namespaces[i]).Namespace);                            
			((XMLNamespace) _namespaces[i]).PrintSchemaWsdl(_textWriter, sb, indent2);
		    }
		}
		
		PrintTypesEndWsdl(_textWriter, sb, indent1);
	    }

            ArrayList refNames = new ArrayList(25);

            for (int i=0;i<_namespaces.Count;i++)
                ((XMLNamespace) _namespaces[i]).PrintMessageWsdl(_textWriter, sb, indent1, refNames);

            PrintServiceWsdl(_textWriter, sb, indent1, refNames);

            _textWriter.WriteLine("</definitions>");

            return;
        }


        private void PrintWsdlNamespaces(TextWriter textWriter, StringBuilder sb, String indent)
        {
            Util.Log("WsdlGenerator.PrintWsdlNamespaces");          
            sb.Length = 0;
            sb.Append(indent);
            sb.Append("xmlns='http://schemas.xmlsoap.org/wsdl/'");
            textWriter.WriteLine(sb);

            sb.Length = 0;
            sb.Append(indent);
            sb.Append("xmlns:tns='");
            sb.Append(_targetNS);
            sb.Append("'");
            textWriter.WriteLine(sb);

            sb.Length = 0;
            sb.Append(indent);          
            sb.Append("xmlns:xsd='");
            sb.Append(SudsConverter.GetXsdVersion(_xsdVersion));
            sb.Append("'");
            textWriter.WriteLine(sb);

            sb.Length = 0;
            sb.Append(indent);          
            sb.Append("xmlns:xsi='");
            sb.Append(SudsConverter.GetXsiVersion(_xsdVersion));
            sb.Append("'");
            textWriter.WriteLine(sb);

            sb.Length = 0;
            sb.Append(indent);          
            sb.Append("xmlns:suds='http://www.w3.org/2000/wsdl/suds'");
            textWriter.WriteLine(sb);

            sb.Length = 0;
            sb.Append(indent);          
            sb.Append("xmlns:wsdl='http://schemas.xmlsoap.org/wsdl/'");
            textWriter.WriteLine(sb);

            sb.Length = 0;
            sb.Append(indent);          
            sb.Append("xmlns:soapenc='http://schemas.xmlsoap.org/soap/encoding/'");
            textWriter.WriteLine(sb);


            Hashtable usedNames = new Hashtable(10);
            for (int i=0;i<_namespaces.Count;i++)
                ((XMLNamespace) _namespaces[i]).PrintDependsOnWsdl(_textWriter, sb, indent, usedNames);

            // This should be last because it closes off the definitions element
            sb.Length = 0;
            sb.Append(indent);                      
            sb.Append("xmlns:soap='http://schemas.xmlsoap.org/wsdl/soap/'>");
            textWriter.WriteLine(sb);


        }

        private void PrintTypesBeginWsdl(TextWriter textWriter, StringBuilder sb, String indent)
        {
            Util.Log("WsdlGenerator.PrintTypesBeginWsdl");          
            sb.Length = 0;
            sb.Append(indent);
            sb.Append("<types>");
            textWriter.WriteLine(sb);
        }

        private void PrintTypesEndWsdl(TextWriter textWriter, StringBuilder sb, String indent)
        {
            Util.Log("WsdlGenerator.PrintTypesEndWsdl");            
            sb.Length = 0;
            sb.Append(indent);          
            sb.Append("</types>");
            textWriter.WriteLine(sb);           
        }

        internal void PrintServiceWsdl(TextWriter textWriter, StringBuilder sb, String indent, ArrayList refNames)
        {
            Util.Log("WsdlGenerator.PrintServiceWsdl");         
            String indent1 = IndentP(indent);               
            String indent2 = IndentP(indent1);
            String indent3 = IndentP(indent2);                                                      
            sb.Length = 0;
            sb.Append("\n");
            sb.Append(indent);
            sb.Append("<service name='");
            sb.Append(_name);
            sb.Append("Service'");
            sb.Append(">");
            textWriter.WriteLine(sb);

            for (int i=0; i<refNames.Count; i++)
            {
                if (((_typeToServiceEndpoint != null) && (_typeToServiceEndpoint.ContainsKey(refNames[i]))) ||
                    (_serviceEndpoint != null))
                {
                    sb.Length = 0;
                    sb.Append(indent1);
                    sb.Append("<port name='");
                    sb.Append(refNames[i]);
                    sb.Append("Port'");
                    sb.Append(" ");
                    sb.Append("binding='tns:");
                    sb.Append(refNames[i]);
                    sb.Append("Binding");
                    sb.Append("'>");
                    textWriter.WriteLine(sb);               

                    if ((_typeToServiceEndpoint != null) && (_typeToServiceEndpoint.ContainsKey(refNames[i])))
                    {
                        foreach (String url in (ArrayList)_typeToServiceEndpoint[refNames[i]])
                        {
                            sb.Length = 0;
                            sb.Append(indent2);
                            sb.Append("<soap:address location='");
                            sb.Append(UrlEncode(url));
                            sb.Append("'/>");
                            textWriter.WriteLine(sb);
                        }

                    }
                    else if (_serviceEndpoint != null)
                    {
                        sb.Length = 0;
                        sb.Append(indent2);
                        sb.Append("<soap:address location='");
                        sb.Append(_serviceEndpoint);
                        sb.Append("'/>");
                        textWriter.WriteLine(sb);
                    }

                    sb.Length = 0;
                    sb.Append(indent1);
                    sb.Append("</port>");
                    textWriter.WriteLine(sb);
                }
            }

            sb.Length = 0;
            sb.Append(indent);
            sb.Append("</service>");
            textWriter.WriteLine(sb);               
        }

        private String UrlEncode(String url)
        {
            if (url == null || url.Length == 0)
                return url;

            int index = url.IndexOf("&amp;");
            if (index > -1)
            {
                // Assume its encoded
                return url;
            }

            index = url.IndexOf('&');
            if (index > -1)
            {
                return url.Replace("&", "&amp;");
            }

            return url;
        }


        // Private fields
        private TextWriter _textWriter;
        internal Queue _queue;
        private String _name;
        private String _targetNS;
        private String _targetNSPrefix;
        private ArrayList _namespaces;
        private Assembly _dynamicAssembly;
        private String _serviceEndpoint; //service endpoint for all types
        private XsdVersion _xsdVersion; // Temporary, specifies what xsd and xsi schema to put out
        internal Hashtable _typeToServiceEndpoint; //service endpoint for each type
        internal Hashtable _typeToInteropNS = new Hashtable(); // If interop type, then XMLNamespace the type is in.

        private static Type s_marshalByRefType = typeof(System.MarshalByRefObject);
        private static Type s_contextBoundType = typeof(System.ContextBoundObject);
        private static Type s_delegateType = typeof(System.Delegate);
        private static Type s_valueType = typeof(System.ValueType);
        private static Type s_objectType = typeof(System.Object);
        private static Type s_charType = typeof(System.Char);
        private static Type s_voidType = typeof(void);

        private static Type s_remotingClientProxyType = typeof(System.Runtime.Remoting.Services.RemotingClientProxy);
        private static SchemaBlockType blockDefault = SchemaBlockType.SEQUENCE;

        /***************************************************************
         **
         ** Private classes used by SUDS generator
         **
         ***************************************************************/
        private interface IAbstractElement
        {
            void Print(TextWriter textWriter, StringBuilder sb, String indent);
        }

        private class EnumElement : IAbstractElement
        {
            internal EnumElement(String value)
            {
                Util.Log("EnumElement.EnumElement "+value);
                _value = value;
            }

            public void Print(TextWriter textWriter, StringBuilder sb, String indent)
            {
                Util.Log("EnumElement.Print");
                sb.Length = 0;
                sb.Append(indent);
                sb.Append("<enumeration value='");
                sb.Append(_value);
                sb.Append("'/>");
                textWriter.WriteLine(sb);
                return;
            }

            // Fields
            private String _value;
        }

        /*
        private class ComplexContent : IAbstractElement
        {
            internal ComplexContent()
            {
            }

            internal void Add(Restriction restriction)
            {
                _restriction = restriction;
            }

            public void Print(TextWriter textWriter, StringBuilder sb, String indent)
            {
                Util.Log("EnumElement.Print");
                sb.Length = 0;
                sb.Append(indent);
                sb.Append("<enumeration value='");
                sb.Append(_value);
                sb.Append("'/>");
                textWriter.WriteLine(sb);
                return;
            }

            Restriction _restriction;
        }
        */


        private class Restriction : Particle
        {
            internal enum RestrictionType 
            {
                None = 0,
                Array = 1,
                Enum = 2
            }

            internal Restriction()
            {
                Util.Log("Restriction.Restriction ");
            }

            internal Restriction(String baseName, XMLNamespace baseNS)
            {
                Util.Log("Restriction.Restriction "+baseName+" "+baseNS.Namespace);
                _baseName = baseName;
                _baseNS = baseNS;
            }

            internal void AddArray(SchemaAttribute attribute)
            {
                Util.Log("Restriction.AddArray ");
                _rtype = RestrictionType.Array;
                _attribute = attribute;
            }

            internal void AddAttribute(SchemaAttribute attribute)
            {
                Util.Log("Restriction.AddAttribute ");
                _attribute = attribute;
            }

            internal void AddEnumeration(SchemaAttribute attribute)
            {
                Util.Log("Restriction.AddEnumeration ");
                _rtype = RestrictionType.Enum;
                _attribute = attribute;
            }

            public override String Name()
            {
                return _baseName;
            }

            public override void Print(TextWriter textWriter, StringBuilder sb, String indent)
            {
                Util.Log("Restriction.Print "+_baseName);
                String indent1 = IndentP(indent);
                sb.Length = 0;
                sb.Append(indent);
                if (_rtype == RestrictionType.Array)
                    sb.Append("<restriction base='soapenc:Array'>");
                else if (_rtype == RestrictionType.Enum)
                {
                    sb.Append("<restriction base='xsd:string'>");
                }
                else
                {
                    sb.Append("<restriction base='");
                    sb.Append(_baseNS.Prefix);
                    sb.Append(':');
                    sb.Append(_baseName);
                    sb.Append("'>");
                }
                textWriter.WriteLine(sb);
                foreach (IAbstractElement elem in _abstractElms)
                  elem.Print(textWriter, sb, IndentP(indent1));

                if (_attribute != null)
                    _attribute.Print(textWriter, sb, IndentP(indent1));
                sb.Length = 0;
                sb.Append(indent);
                sb.Append("</restriction>");
                textWriter.WriteLine(sb);
            }

            String _baseName;
            XMLNamespace _baseNS;
            internal RestrictionType _rtype;
            SchemaAttribute _attribute;
            internal ArrayList _abstractElms = new ArrayList();
        }

        private class EncodingElement : IAbstractElement
        {
            internal EncodingElement(String value)
            {
                Util.Log("EncodingElement.EncodingElement "+value);
                _value = value;
            }

            public void Print(TextWriter textWriter, StringBuilder sb, String indent)
            {
                Util.Log("EncodingElement.Print");
                sb.Length = 0;
                sb.Append(indent);
                sb.Append("<encoding value='");
                sb.Append(_value);
                sb.Append("'/>");
                textWriter.WriteLine(sb);
                return;
            }

            // Fieldsa
            private String _value;
        }

        private class SchemaAttribute : IAbstractElement
        {
            internal SchemaAttribute()
            {
                Util.Log("SchemaAttribute ");
            }

            internal SchemaAttribute(String name, String type)
            {
                Util.Log("SchemaAttribute "+name+" type "+type);
                _name = name;
                _type = type;
            }

            internal void AddArray(String wireQname)
            {
                Util.Log("SchemaAttribute wireQname "+wireQname);
                _barray = true;
                _wireQname = wireQname;
            }

            public void Print(TextWriter textWriter, StringBuilder sb, String indent)
            {
                Util.Log("SchemaAttribute.Print barray "+_barray);
                if (!_barray)
                {
                    sb.Length = 0;
                    sb.Append(indent);
                    sb.Append("<attribute name='");
                    sb.Append(_name);
                    sb.Append("' type='");
                    sb.Append(_type);
                    sb.Append("'/>");
                    textWriter.WriteLine(sb);
                }
                else
                {
                    sb.Length = 0;
                    sb.Append(indent);
                    sb.Append("<attribute ref='soapenc:arrayType'");
                    sb.Append(" wsdl:arrayType ='");
                    sb.Append(_wireQname);
                    sb.Append("'/>");
                    textWriter.WriteLine(sb);
                }
                return;
            }

            // Fields
            private String _name;
            private String _type;
            private bool _barray = false;
            private String _wireQname;

        }

        private abstract class Particle : IAbstractElement
        {
            protected Particle(){}
            public abstract String Name();
            public abstract void Print(TextWriter textWriter, StringBuilder sb, String indent);
        }

        private class SchemaElement : Particle
        {
            internal SchemaElement(String name, Type type, bool bEmbedded, XMLNamespace xns)
            : base(){
                Util.Log("SchemaElement.SchemaElement Particle "+name+" type "+type+" bEmbedded "+bEmbedded);
                _name = name;
                _typeString = null;
                _schemaType = SimpleSchemaType.GetSimpleSchemaType(type, xns, true);
                _typeString = RealSchemaType.TypeName(type, bEmbedded, xns);
            }

            public override String Name()
            {
                return _name;
            }

            public override void Print(TextWriter textWriter, StringBuilder sb, String indent){
                Util.Log("SchemaElement.Print "+_name+" _schemaType "+_schemaType+" _typeString "+_typeString );
                String indent1 = IndentP(indent);
                sb.Length = 0;
                sb.Append(indent);
                sb.Append("<element name='");
                sb.Append(_name);
                if (_schemaType != null && !(_schemaType is SimpleSchemaType && ((SimpleSchemaType)_schemaType).Type.IsEnum))
                {
                    sb.Append("'>");
                    textWriter.WriteLine(sb);
                    _schemaType.PrintSchemaType(textWriter, sb, IndentP(indent1), true);

                    sb.Length = 0;
                    sb.Append(indent);
                    sb.Append("</element>");
                }
                else
                {
                    if (_typeString != null)
                    {
                        sb.Append("' type='");
                        sb.Append(_typeString);
                        sb.Append('\'');
                    }
                    sb.Append("/>");
                }
                textWriter.WriteLine(sb);

                return;
            }

            // Fields
            private String _name;
            private String _typeString;
            private SchemaType _schemaType;
        }

        private abstract class SchemaType
        {
            internal abstract void PrintSchemaType(TextWriter textWriter, StringBuilder sb, String indent, bool bAnonymous);
        }

        private class SimpleSchemaType : SchemaType
        {
            private SimpleSchemaType(Type type, XMLNamespace xns)
            {
                Util.Log("SimpleSchemaType.SimpleSchemaType "+type+" xns "+((xns != null) ? xns.Name : "Null"));
                _type = type;
                _xns = xns;
                _abstractElms = new ArrayList();

                _fullRefName = WsdlGenerator.RefName(type);
            }

            internal Type Type
            {
                get{ return(_type);}
            }

            internal String FullRefName
            {
                get{ return _fullRefName;}
            }

            internal String BaseName{
                get{ return(_baseName);}
            }

            internal XMLNamespace XNS{
                get{ return(_xns);}
            }

            internal override void PrintSchemaType(TextWriter textWriter, StringBuilder sb, String indent, bool bAnonymous){
                Util.Log("SimpleSchemaType.PrintSchemaType _type.Name "+_type.Name);
                sb.Length = 0;
                sb.Append(indent);
                if (bAnonymous == false)
                {
                    sb.Append("<simpleType name='");
                    sb.Append(FullRefName);
                    sb.Append("'");
                    if (BaseName != null)
                    {
                        sb.Append(" base='");
                        sb.Append(BaseName);
                        sb.Append("'");
                    }

                    if (_restriction._rtype == Restriction.RestrictionType.Enum)
                    {
                        sb.Append(" suds:enumType='");
                        sb.Append(_restriction.Name());
                        sb.Append("'");
                    }
                }
                else
                {
                    if (BaseName != null)
                    {
                        sb.Append("<simpleType base='");
                        sb.Append(BaseName);
                        sb.Append("'");
                    }
                    else
                        sb.Append("<simpleType");
                }

                bool bEmpty = (_abstractElms.Count == 0 && _restriction == null);
                if (bEmpty)
                    sb.Append("/>");
                else
                    sb.Append(">");
                textWriter.WriteLine(sb);
                if (bEmpty)
                    return;

                if (_abstractElms.Count > 0)
                {
                    for (int i=0;i<_abstractElms.Count; i++)
                        ((IAbstractElement) _abstractElms[i]).Print(textWriter, sb, IndentP(indent));
                }

                if (_restriction != null)
                    _restriction.Print(textWriter, sb, IndentP(indent));

                textWriter.Write(indent);
                textWriter.WriteLine("</simpleType>");

                return;
            }


            internal static SimpleSchemaType GetSimpleSchemaType(Type type, XMLNamespace xns, bool fInline)
            {
                Util.Log("SimpleSchemaType.GetSimpleSchemaType "+type+" xns "+xns.Name);                

                SimpleSchemaType ssType = null;
                if (type.IsEnum)
                {
                    ssType = new SimpleSchemaType(type, xns);
                    String baseName = RealSchemaType.TypeName(Enum.GetUnderlyingType(type), true, xns);
                    ssType._restriction = new Restriction(baseName, xns);
                    String[] values = Enum.GetNames(type);
                    for (int i=0;i<values.Length;i++)
                        ssType._restriction._abstractElms.Add(new EnumElement(values[i]));
                    ssType._restriction._rtype = Restriction.RestrictionType.Enum;
                }
                else
                {
                }
                return(ssType);
            }


            private Type _type;
            internal String _baseName = null; //get rid of warning, not used for now
            private XMLNamespace _xns;
            internal Restriction _restriction;
            private String _fullRefName;
            private ArrayList _abstractElms = new ArrayList();
        }


        private abstract class ComplexSchemaType : SchemaType
        {
            internal ComplexSchemaType(String name, bool bSealed)
            {
                _name = name;
                _fullRefName = _name;
                _blockType = SchemaBlockType.ALL;
                _baseName = null;
                _elementName = name;
                _bSealed = bSealed;
                _particles = new ArrayList();
                _abstractElms = new ArrayList();
            }

            internal ComplexSchemaType(String name, SchemaBlockType blockType, bool bSealed)
            {
                _name = name;
                _fullRefName = _name;
                _blockType = blockType;
                _baseName = null;
                _elementName = name;
                _bSealed = bSealed;
                _particles = new ArrayList();
                _abstractElms = new ArrayList();
            }

            internal ComplexSchemaType(Type type)
            {
                Util.Log("ComplexSchemaType.ComplexSchemaType "+type);              
                _blockType = SchemaBlockType.ALL;
                _type = type;
                Init();
            }

            internal ComplexSchemaType(Type type, SchemaBlockType blockType)
            {
                Util.Log("ComplexSchemaType.ComplexSchemaType "+type+" blockType "+((Enum)blockType).ToString());              
                _blockType = blockType;
                _type = type;
                Init();
            }

            private void Init()
            {
                _name = _type.Name;
                _bSealed = _type.IsSealed;
                _baseName = null;
                _elementName = _name;
                _particles = new ArrayList();
                _abstractElms = new ArrayList();
                _fullRefName = WsdlGenerator.RefName(_type);
                if (!(_type.IsPublic || _type.IsNotPublic))
                {

                    // Nested class
                    _bNested = true;
                }
                else
                {
                    _bNested = false;
                }

            }

            internal String Name{
                get{ return(_name);}
                set{ _name = value;}
            }

            internal String FullRefName
            {
                get{ return(_fullRefName);}
            }

            internal bool IsNested
            {
                get{ return _bNested; }
            }

            protected String BaseName{
                get{ return(_baseName);}
                set{ _baseName = value;}
            }

            internal String ElementName{
                get{ return(_elementName);}
                set{ _elementName = value;}
            }


            protected SchemaBlockType BlockType{
                get{ return(_blockType);}
                set{ _blockType = value;}
            }

            protected bool IsSealed{
                get{ return(_bSealed);}
            }

            protected bool IsEmpty{
                get{
                    return((_abstractElms.Count == 0) &&
                           (_particles.Count == 0));
                }
            }

            internal void AddParticle(Particle particle){
                Util.Log("ComplexSchemaType.AddParticle "+particle.Name());                
                _particles.Add(particle);
            }

            internal void AddAbstractElement(IAbstractElement elm){
                Util.Log("ComplexSchemaType.AddAbstractElement ");               
                _abstractElms.Add(elm);
            }

            protected void PrintBody(TextWriter textWriter, StringBuilder sb, String indent){
                Util.Log("ComplexSchemaType.PrintBody "+_name);             
                int particleCount = _particles.Count;
                String indent1 = IndentP(indent);
                String indent2 = IndentP(indent1);
                if (particleCount > 0)
                {
                    bool bPrintBlockElms = /*(particleCount > 1) && */(WsdlGenerator.blockDefault != _blockType);
                    if (bPrintBlockElms)
                    {
                        sb.Length = 0;
                        sb.Append(indent1);
                        sb.Append(schemaBlockBegin[(int) _blockType]);
                        textWriter.WriteLine(sb);
                    }

                    for (int i=0;i<particleCount; i++)
                        ((Particle) _particles[i]).Print(textWriter, sb, IndentP(indent2));

                    if (bPrintBlockElms)
                    {
                        sb.Length = 0;
                        sb.Append(indent1);
                        sb.Append(schemaBlockEnd[(int) _blockType]);
                        textWriter.WriteLine(sb);
                    }
                }

                int abstractElmCount = _abstractElms.Count;
                for (int i=0;i<abstractElmCount; i++)
                    ((IAbstractElement) _abstractElms[i]).Print(textWriter, sb, IndentP(indent));

                return;
            }

            private String _name;
            private Type _type;
            private String _fullRefName;
            private bool _bNested = false;
            private String _baseName;
            private String _elementName;
            private bool _bSealed;
            private SchemaBlockType _blockType;
            private ArrayList _particles;
            private ArrayList _abstractElms;

            static private String[] schemaBlockBegin = { "<all>", "<sequence>", "<choice>", "<complexContent>"};
            static private String[] schemaBlockEnd = { "</all>", "</sequence>", "</choice>", "</complexContent>"};
        }

        private class PhonySchemaType : ComplexSchemaType
        {
            internal PhonySchemaType(String name) : base(name, true)
            {
                Util.Log("PhonySchemaType.PhonySchemaType "+name);              
                _numOverloadedTypes = 0;
            }

            internal int OverloadedType(){
                Util.Log("PhonySchemaType.OverLoadedTypeType");             
                return(++_numOverloadedTypes);
            }

            internal override void PrintSchemaType(TextWriter textWriter, StringBuilder sb, String indent, bool bAnonymous){
                Util.Log("PhonySchemaType.PrintSchemaType"); 
                Debug.Assert(bAnonymous == true, "PhonySchemaType should always be printed as anonymous types");

                // Wsdl Phony is not printed, instead the message section contains the parameters.
                return;
            }
            private int _numOverloadedTypes;
            internal ArrayList _inParamTypes;
            internal ArrayList _inParamNames;
            internal ArrayList _outParamTypes;
            internal ArrayList _outParamNames;
            internal ArrayList _paramNamesOrder;
            internal String _returnType;
            internal String _returnName;
        }

        private class ArraySchemaType : ComplexSchemaType
        {
            internal ArraySchemaType(Type type, String name, SchemaBlockType blockType, bool bSealed)
            : base(name, blockType, bSealed)
            {
                Util.Log("ArraySchemaType.ArrayComplexSchemaType");  
                _type = type;
            }

            internal Type Type
            {
                get { return _type;}
            }


            internal override void PrintSchemaType(TextWriter textWriter, StringBuilder sb, String indent, bool bAnonymous)
            {
                Util.Log("ArrayType.PrintSchemaType");   
                String indent1 = IndentP(indent);
                sb.Length = 0;
                sb.Append(indent); 
                sb.Append("<complexType name='");
                sb.Append(FullRefName);
                sb.Append("\'>");
                textWriter.WriteLine(sb);
                PrintBody(textWriter, sb, indent1);
                sb.Length = 0;
                sb.Append(indent); 
                sb.Append("</complexType>");
                textWriter.WriteLine(sb);

                return;
            }

            private Type _type;
        }

        private class RealSchemaType : ComplexSchemaType
        {
            internal RealSchemaType(Type type, XMLNamespace xns, String serviceEndpoint, Hashtable typeToServiceEndpoint, bool bUnique, WsdlGenerator WsdlGenerator)
            : base(type)
            {
                Util.Log("RealSchemaType.RealSchemaType "+type+" xns "+xns.Name+" serviceEndpoint "+serviceEndpoint+" bUnique "+bUnique);               
                _type = type;
                _serviceEndpoint = serviceEndpoint;
                _typeToServiceEndpoint = typeToServiceEndpoint;
                _bUnique = bUnique;
                _WsdlGenerator = WsdlGenerator;
                _bStruct = type.IsValueType;
                _xns = xns;
                _implIFaces = null;
                _iFaces = null;
                _methods = null;
                _fields = null;
                _methodTypes = null;

                _nestedTypes = type.GetNestedTypes();
                if (_nestedTypes != null)
                {
                    foreach (Type ntype in _nestedTypes)
                    {
                        Util.Log("RealSchemaType.RealSchemaType nested classes"+ntype);
                        _WsdlGenerator.AddType(ntype, xns);
                    }
                }
            }

            internal Type Type{
                get{ return(_type);}
            }

            internal XMLNamespace XNS{
                get{ return(_xns);}
            }

            internal bool IsStruct{
                get{ return(_bStruct);}
            }

            internal bool IsUnique{
                get{ return(_bUnique);}
            }

            internal bool IsSUDSType{
                /*
                get{ return((_fields == null) &&
                            ((_iFaces.Length > 0) || (_methods.Length > 0) ||
                             (_type.IsInterface) || (s_delegateType.IsAssignableFrom(_type))));}
                             */
                get{ return((_iFaces != null && _iFaces.Length > 0) || 
                            (_methods != null && _methods.Length > 0) ||
                             (_type != null && _type.IsInterface) || 
                            (s_delegateType != null && s_delegateType.IsAssignableFrom(_type)));}
            }

            internal Type[] GetIntroducedInterfaces(){
                Util.Log("RealSchemaType.GetIntroducedInterfaces");
                Debug.Assert(_iFaces == null, "variable set");
                _iFaces = GetIntroducedInterfaces(_type);
                return(_iFaces);
            }

            internal MethodInfo[] GetIntroducedMethods(){
                Util.Log("RealSchemaType.GetIntroducedMethods");                
                Debug.Assert(_methods == null, "variable set");
                _methods = GetIntroducedMethods(_type, ref _methodAttributes);
                _methodTypes = new String[2*_methods.Length];
                return(_methods);
            }

            internal FieldInfo[] GetInstanceFields(){
                Util.Log("RealSchemaType.GetInstanceFields");               
                Debug.Assert(_fields == null, "variable set");
                Debug.Assert(!WsdlGenerator.s_marshalByRefType.IsAssignableFrom(_type), "Invalid Type");
                _fields = GetInstanceFields(_type);
                return(_fields);
            }

            private bool IsNotSystemDefinedRoot(Type type, Type baseType)
            {
                if (!type.IsInterface &&
                    !type.IsValueType &&
                    baseType != null &&
                    baseType.BaseType != null &&
                    baseType != WsdlGenerator.s_marshalByRefType &&
                    baseType != WsdlGenerator.s_valueType &&
                    baseType != WsdlGenerator.s_objectType &&
                    baseType != WsdlGenerator.s_contextBoundType &&
                    baseType != WsdlGenerator.s_remotingClientProxyType &&
                    baseType.FullName != "System.EnterpriseServices.ServicedComponent" &&
                    baseType.FullName != "System.__ComObject")
                    return true;
                else 
                    return false;
            }

            internal void Resolve(StringBuilder sb){
                Util.Log("RealSchemaType.Resolve "+_type);             
                sb.Length = 0;

                // Check if this is a suds type
                bool bSUDSType = IsSUDSType;


                // Resolve base type eliminating system defined roots of the class heirarchy

                Type baseType = _type.BaseType;
                if (IsNotSystemDefinedRoot(_type, baseType))
                {
                    Util.Log("RealSchemaType.Resolve Not System Defined root "+baseType);                                 
                    XMLNamespace xns = _WsdlGenerator.GetNamespace(baseType);
                    Debug.Assert(xns != null, "Namespace should have been found");
                    sb.Append(xns.Prefix);
                    sb.Append(':');
                    sb.Append(baseType.Name);
                    BaseName = sb.ToString();
                    if (bSUDSType)
                        _xns.DependsOnSUDSNS(xns);
                    Type ltype= _type; 
                    Type lbaseType = ltype.BaseType;
                    while(lbaseType != null && IsNotSystemDefinedRoot(ltype, lbaseType))
                    {
                        if (_typeToServiceEndpoint != null && !_typeToServiceEndpoint.ContainsKey(lbaseType.Name) && _typeToServiceEndpoint.ContainsKey(ltype.Name))
                        {
                            // type contains endpoints, but baseType doesn't, so assign the type's endpoints to the baseType.
                            // This is needed when a child has endpoints but the parent doesn't. A cast to the parent won't 
                            // find the objects endpoint
                            _typeToServiceEndpoint[lbaseType.Name] = _typeToServiceEndpoint[ltype.Name];
                        }
                        ltype = lbaseType;
                        lbaseType = ltype.BaseType;
                    }

                    Util.Log("RealSchemaType.Resolve Not System Defined root BaseName "+BaseName);                                 
                }

                // The element definition of this type depends on itself
                _xns.DependsOnSchemaNS(_xns, false);

                if (bSUDSType)
                {
                    Util.Log("RealSchemaType.Resolve AddRealSUDSType  "+_type);                                                     
                    _xns.AddRealSUDSType(this);

                    // Resolve interfaces introduced by this type
                    if (_iFaces.Length > 0)
                    {
                        _implIFaces = new String[_iFaces.Length];
                        for (int i=0;i<_iFaces.Length;i++)
                        {
                            String ns;
                            Assembly assem;
                            Util.Log("RealSchemaType.Resolve iFace  "+_iFaces[i].Name);                                                                                     
                            bool bInteropType = WsdlGenerator.GetNSAndAssembly(_iFaces[i], out ns, out assem);
                            XMLNamespace xns = _xns.LookupSchemaNamespace(ns, assem);
                            Debug.Assert(xns != null, "SchemaType should have been found");
                            sb.Length = 0;
                            sb.Append(xns.Prefix);
                            sb.Append(':');
                            sb.Append(_iFaces[i].Name);
                            _implIFaces[i] = sb.ToString();
                            _xns.DependsOnSUDSNS(xns);
                        }
                    }

                    // Resolve methods introduced by this type
                    if (_methods.Length > 0)
                    {
                        String useNS = null;
                        if (_xns.IsInteropType)
                            useNS = _xns.Name;
                        else
                        {
                            sb.Length = 0;
                            WsdlGenerator.QualifyName(sb, _xns.Name, Name);
                            useNS = sb.ToString();
                        }
                        XMLNamespace methodXNS = _xns.LookupSchemaNamespace(useNS, _xns.Assem);
                        Debug.Assert(methodXNS != null, "Namespace is null");
                        _xns.DependsOnSUDSNS(methodXNS);
                        _phony = new PhonySchemaType[_methods.Length];
                        for (int i=0;i<_methods.Length;i++)
                        {
                            // Process the request
                            MethodInfo method = _methods[i];
                            String methodRequestName = method.Name;

                            ParameterInfo[] parameters = method.GetParameters();
                            PhonySchemaType methodRequest = new PhonySchemaType(methodRequestName);

                            // Wsdl 
                            Util.Log("RealSchemaType.Resolve Wsdl  "+methodRequestName);
                            methodRequest._inParamTypes = new ArrayList(10); 
                            methodRequest._inParamNames = new ArrayList(10); 
                            methodRequest._outParamTypes = new ArrayList(10);
                            methodRequest._outParamNames = new ArrayList(10);
                            methodRequest._paramNamesOrder = new ArrayList(10);

                            int paramNameCnt = 0;
                            foreach (ParameterInfo param in parameters){
                                bool bmarshalIn = false;
                                bool bmarshalOut = false;
                                methodRequest._paramNamesOrder.Add(param.Name);
                                ParamInOut(param, out bmarshalIn, out bmarshalOut);

                                Type type = param.ParameterType;
                                String paramName = param.Name;
                                if (paramName == null || paramName.Length == 0)
                                    paramName = "param"+paramNameCnt++;

                                // Find the Wsdl type name

                                String stringType = TypeName(type, true, methodXNS);
                                // add to the method parameters
                                if (bmarshalIn)
                                {
                                    methodRequest._inParamNames.Add(paramName);
                                    methodRequest._inParamTypes.Add(stringType);
                                }

                                if (bmarshalOut)
                                {
                                    methodRequest._outParamNames.Add(paramName);
                                    methodRequest._outParamTypes.Add(stringType);
                                }
                            }


                            methodXNS.AddPhonySchemaType(methodRequest);
                            _phony[i] = methodRequest;
                            _methodTypes[2*i] = methodRequest.ElementName;

                            if (!RemotingServices.IsOneWay(method))
                            {
                                // Process response (look at custom attributes to get values

                                String returnName = null;
                                SoapMethodAttribute soapAttribute = (SoapMethodAttribute)InternalRemotingServices.GetCachedSoapAttribute(method);
                                if (soapAttribute.ReturnXmlElementName != null)
                                    returnName = soapAttribute.ReturnXmlElementName;
                                else
                                    returnName = "return";

                                String responseName = null;
                                if (soapAttribute.ResponseXmlElementName != null)
                                    responseName = soapAttribute.ResponseXmlElementName;
                                else
                                    responseName = methodRequestName + "Response";

                                PhonySchemaType methodResponse = new PhonySchemaType(responseName);

                                //Wsdl type
                                // out paramters alread processed above.
                                // return name stored in methodRequest PhonySchemaType
                                methodRequest._returnName = returnName;
                                Type returnType = method.ReturnType;

                                if (!((returnType == null) || (returnType == typeof(void))))
                                {
                                    methodRequest._returnType = TypeName(returnType, true, methodXNS);
                                }
                                methodXNS.AddPhonySchemaType(methodResponse);
                                _methodTypes[2*i+1] = methodResponse.ElementName;
                            }
                        }
                    }
                }

                // Resolve fields
                if (_fields != null)
                {
                    for (int i=0;i<_fields.Length;i++)
                    {
                        FieldInfo field = _fields[i];
                        Debug.Assert(!field.IsStatic, "Static field");
                        Type fieldType = field.FieldType;
                        if (fieldType == null)
                            fieldType = typeof(Object);
                        Util.Log("RealSchemaType.Resolve fields  "+field.Name+" type "+fieldType);                                                                                                              
                        AddParticle(new SchemaElement(field.Name, fieldType, false, _xns));
                    }
                }

                // Resolve attribute elements
                return;
            }

            private void ParamInOut(ParameterInfo param, out bool bMarshalIn, out bool bMarshalOut)
            {
                bool bIsIn = param.IsIn;    // [In]
                bool bIsOut = param.IsOut;  // [Out]  note: out int a === [Out] ref int b

                bool bIsByRef = param.ParameterType.IsByRef; // (ref or normal)      

                bMarshalIn = false;
                bMarshalOut = false;
                if (bIsByRef)
                {
                    if (bIsIn == bIsOut)
                    {
                        // "ref int a" or "[In, Out] ref int a"
                        bMarshalIn = true;
                        bMarshalOut = true;
                    }
                    else
                    {
                        // "[In] ref int a" or "out int a"
                        bMarshalIn = bIsIn;     
                        bMarshalOut = bIsOut;  
                    }
                }
                else
                {
                    // "int a" or "[In, Out] a"
                    bMarshalIn = true;     
                    bMarshalOut = bIsOut;
                }
                Util.Log("RealSchemaType.ParamInOut "+param.Name+" ref,in,out "+bIsByRef+","+bIsIn+","+bIsOut+" bMarshalIn,bMarshalOut "+bMarshalIn+","+bMarshalOut);             
            }


            internal override void PrintSchemaType(TextWriter textWriter, StringBuilder sb, String indent, bool bAnonymous)
            {
                Util.Log("RealSchemaType.PrintSchemaType");             
                if (bAnonymous == false)
                {
                    sb.Length = 0;
                    sb.Append(indent);
                    sb.Append("<element name='");
                    sb.Append(ElementName);
                    sb.Append("' type='");
                    sb.Append(_xns.Prefix);
                    sb.Append(':');
                    sb.Append(FullRefName);
                    sb.Append("'/>");
                    textWriter.WriteLine(sb);
                }

                sb.Length = 0;
                sb.Append(indent);
                if (bAnonymous == false)
                {
                    sb.Append("<complexType name='");
                    sb.Append(FullRefName);
                    sb.Append('\'');
                }
                else
                {
                    sb.Append("<complexType ");
                }
                if (BaseName != null)
                {
                    sb.Append(" base='");
                    sb.Append(BaseName);
                    sb.Append('\'');
                }
                if ((IsSealed == true) &&
                    (bAnonymous == false))
                    sb.Append(" final='#all'");
                bool bEmpty = IsEmpty;
                if (bEmpty)
                    sb.Append("/>");
                else
                    sb.Append('>');
                textWriter.WriteLine(sb);
                if (bEmpty)
                    return;

                base.PrintBody(textWriter, sb, indent);

                textWriter.Write(indent);
                textWriter.WriteLine("</complexType>");

                return;
            }


            internal void PrintMessageWsdl(TextWriter textWriter, StringBuilder sb, String indent, ArrayList refNames)
            {
                Util.Log("RealSchemaType.PrintMessageWsdl "+Name);

                String indent1 = IndentP(indent);
                String indent2 = IndentP(indent1);
                String indent3 = IndentP(indent2);
                String ns = null;
                String nsPrefix = null;
                MethodInfo method = null;
                String methodName = null;
                String overloadedName = null;
                bool bIsOneWay = false;

                String useNS = null;
                if (_xns.IsInteropType)
                    useNS = _xns.Name;
                else
                {
                    sb.Length = 0;

                    WsdlGenerator.QualifyName(sb, _xns.Name, Name);
                    useNS = sb.ToString();
                }
                XMLNamespace methodXns = _xns.LookupSchemaNamespace(useNS, _xns.Assem);

                Debug.Assert(methodXns != null, "Namespace is null");

                int methodsLength = 0;
                if (_methods != null)
                    methodsLength = _methods.Length;

                if (methodsLength > 0)
                {
                    ns = methodXns.Namespace;
                    nsPrefix = methodXns.Prefix;
                }

                refNames.Add(Name);

                for (int i=0;i<methodsLength;i++)
                {
                    method = _methods[i];
                    bIsOneWay = RemotingServices.IsOneWay(method);
                    methodName = PrintMethodName(method);
                    sb.Length = 0;
                    WsdlGenerator.QualifyName(sb, Name, _methodTypes[2*i]);
                    overloadedName = sb.ToString();

                    // Message element
                    sb.Length = 0;
                    sb.Append("\n");
                    sb.Append(indent);
                    sb.Append("<message name='");
                    sb.Append(overloadedName+"Input");
                    sb.Append("'>");
                    textWriter.WriteLine(sb);

                    PhonySchemaType phony = _phony[i];


                    if (phony._inParamTypes != null)
                    {
                        for (int iparam=0; iparam<phony._inParamTypes.Count; iparam++)
                        {
                            sb.Length = 0;
                            sb.Append(indent1);
                            sb.Append("<part name='");
                            sb.Append(phony._inParamNames[iparam]);
                            sb.Append("' type='");
                            sb.Append(phony._inParamTypes[iparam]);
                            sb.Append("'/>");
                            textWriter.WriteLine(sb);
                        }

                        sb.Length = 0;
                        sb.Append(indent);
                        sb.Append("</message>");
                        textWriter.WriteLine(sb);

                        if (!bIsOneWay)
                        {
                            sb.Length = 0;
                            sb.Append(indent);
                            sb.Append("<message name='");
                            sb.Append(overloadedName+"Output");
                            sb.Append("'>");
                            textWriter.WriteLine(sb);

                            if (phony._returnType != null || phony._outParamTypes != null)
                            {
                                if (phony._returnType != null)
                                {
                                    sb.Length = 0;
                                    sb.Append(indent1);
                                    sb.Append("<part name='");
                                    sb.Append(phony._returnName);
                                    sb.Append("' type='");
                                    sb.Append(phony._returnType);
                                    sb.Append("'/>");
                                    textWriter.WriteLine(sb);
                                }

                                if (phony._outParamTypes != null)
                                {
                                    for (int iparam=0; iparam<phony._outParamTypes.Count; iparam++)
                                    {
                                        sb.Length = 0;
                                        sb.Append(indent1);
                                        sb.Append("<part name='");
                                        sb.Append(phony._outParamNames[iparam]);
                                        sb.Append("' type='");
                                        sb.Append(phony._outParamTypes[iparam]);
                                        sb.Append("'/>");
                                        textWriter.WriteLine(sb);
                                    }
                                }
                            }

                            sb.Length = 0;
                            sb.Append(indent);
                            sb.Append("</message>");
                            textWriter.WriteLine(sb);
                        }
                    }
                }

                // PortType Element
                sb.Length = 0;
                sb.Append("\n");                    
                sb.Append(indent);
                sb.Append("<portType name='");
                sb.Append(Name);
                sb.Append("PortType");
                sb.Append("'>");
                textWriter.WriteLine(sb);

                for (int i=0;i<methodsLength;i++)
                {
                    method = _methods[i];
                    PhonySchemaType phony = _phony[i];

                    bIsOneWay = RemotingServices.IsOneWay(method);                  
                    methodName = PrintMethodName(method);
                    sb.Length = 0;
                    sb.Append("tns:");
                    WsdlGenerator.QualifyName(sb, Name, _methodTypes[2*i]);
                    overloadedName = sb.ToString();

                    sb.Length = 0;
                    sb.Append(indent1);
                    sb.Append("<operation name='");
                    sb.Append(methodName);
                    sb.Append("'");
                    if (phony != null && phony._paramNamesOrder.Count > 0)
                    {

                        sb.Append(" parameterOrder='");
                        bool bfirst = true;
                        foreach (String param in phony._paramNamesOrder)
                        {
                            if (!bfirst)
                                sb.Append(" ");
                            sb.Append(param);
                            bfirst = false;
                        }
                        sb.Append("'");
                    }

                    sb.Append(">");
                    textWriter.WriteLine(sb);

                    sb.Length = 0;
                    sb.Append(indent2);
                    sb.Append("<input name='");
                    sb.Append(_methodTypes[2*i]);
                    sb.Append("Request' ");                 
                    sb.Append("message='");
                    sb.Append(overloadedName);
                    sb.Append("Input");
                    sb.Append("'/>");
                    textWriter.WriteLine(sb);

                    if (!bIsOneWay)
                    {
                        sb.Length = 0;
                        sb.Append(indent2);
                        sb.Append("<output name='");
                        sb.Append(_methodTypes[2*i]);
                        sb.Append("Response' ");                    

                        sb.Append("message='");
                        sb.Append(overloadedName);
                        sb.Append("Output");
                        sb.Append("'/>");
                        textWriter.WriteLine(sb);
                    }

                    sb.Length = 0;
                    sb.Append(indent1);
                    sb.Append("</operation>");
                    textWriter.WriteLine(sb);
                }

                sb.Length = 0;
                sb.Append(indent);
                sb.Append("</portType>");
                textWriter.WriteLine(sb);


                // Binding 
                sb.Length = 0;
                sb.Append("\n");                    
                sb.Append(indent);
                sb.Append("<binding name='");
                sb.Append(Name);
                sb.Append("Binding");
                sb.Append("' ");
                sb.Append("type='tns:");
                sb.Append(Name);
                sb.Append("PortType");
                sb.Append("'>");
                textWriter.WriteLine(sb);

                sb.Length = 0;
                sb.Append(indent1);
                sb.Append("<soap:binding style='rpc' transport='http://schemas.xmlsoap.org/soap/http'/>");
                textWriter.WriteLine(sb);

                if (_type.IsInterface || IsSUDSType)
                    PrintSuds(_type, _implIFaces, _nestedTypes, textWriter, sb, indent); // Some namespaces have no suds types


                if (!_xns.IsClassesPrinted)
                {
                    for (int i=0;i<_xns._realSchemaTypes.Count;i++)
                    {
                        RealSchemaType rsType = (RealSchemaType) _xns._realSchemaTypes[i];
                        Type type = rsType._type;
                        Util.Log("RealSchemaType.PrintMessageWsd suds realSchemaType "+type);
                        if (!rsType.Type.IsInterface && !rsType.IsSUDSType)
                        {
                            Util.Log("RealSchemaType.PrintMessageWsd suds realSchemaType 2 "+type.BaseType+" "+typeof(MulticastDelegate).IsAssignableFrom(type));;

                            Type[] iFaces = GetIntroducedInterfaces(rsType._type);
                            String[] implIFaces = null;
                            bool bUsedFaces = false;
                            if (iFaces.Length > 0)
                            {
                                implIFaces = new String[iFaces.Length];
                                for (int j=0;i<iFaces.Length;i++)
                                {
                                    String fns;
                                    Assembly fassem;
                                    Util.Log("RealSchemaType.PrintMessageWsdl iFace  "+iFaces[j].Name);
                                    bool bInteropType = WsdlGenerator.GetNSAndAssembly(iFaces[j], out fns, out fassem);
                                    XMLNamespace xns = _xns.LookupSchemaNamespace(fns, fassem);
                                    Debug.Assert(xns != null, "SchemaType should have been found");
                                    sb.Length = 0;
                                    sb.Append(xns.Prefix);
                                    sb.Append(':');
                                    sb.Append(iFaces[j].Name);
                                    implIFaces[j] = sb.ToString();
                                    if (implIFaces[j].Length > 0)
                                        bUsedFaces = true;
                                }
                            }
                            if (!bUsedFaces)
                                implIFaces = null;

                            PrintSuds(type, implIFaces, rsType._nestedTypes, textWriter, sb, indent);
                        }
                    }
                    _xns.IsClassesPrinted = true;
                }


                for (int i=0;i<methodsLength;i++)
                {
                    method = _methods[i];
                    methodName = PrintMethodName(method);
                    bIsOneWay = RemotingServices.IsOneWay(method);                  

                    //binding operation
                    sb.Length = 0;
                    sb.Append(indent1);
                    sb.Append("<operation name='");
                    sb.Append(methodName);
                    sb.Append("'>");
                    textWriter.WriteLine(sb);

                    sb.Length = 0;
                    sb.Append(indent2);
                    sb.Append("<soap:operation soapAction='");
                    String soapAction = SoapServices.GetSoapActionFromMethodBase(method);
                    if ((soapAction != null) || (soapAction.Length > 0))
                    {
                        sb.Append(soapAction);
                    }
                    else
                    {
                        sb.Append(ns);
                        sb.Append('#');
                        sb.Append(methodName);
                    }
                    sb.Append("'/>");
                    textWriter.WriteLine(sb);

                    if (_methodAttributes != null && (i < _methodAttributes.Length) && _methodAttributes[i] != null)
                    {
                        // Suds for method attributes
                        // Attributes are only for public methods,
                        //  _method contains public and additional qualified interface methods
                        // The public methods are at the beginning of _methods
                        sb.Length = 0;
                        sb.Append(indent2);
                        sb.Append("<suds:method attributes='");
                        sb.Append(_methodAttributes[i]);
                        sb.Append("'/>");
                        textWriter.WriteLine(sb);
                    }

                    sb.Length = 0;
                    sb.Append(indent2);
                    sb.Append("<input name='");
                    sb.Append(_methodTypes[2*i]);
                    sb.Append("Request'>");                 
                    textWriter.WriteLine(sb);

                    sb.Length = 0;
                    sb.Append(indent3);
                    sb.Append("<soap:body use='encoded' encodingStyle='http://schemas.xmlsoap.org/soap/encoding/' namespace='");
		    String interopNamespace = SoapServices.GetXmlNamespaceForMethodCall(method);
		    if (interopNamespace == null)
			sb.Append(ns);
		    else
			sb.Append(interopNamespace);
                    sb.Append("'/>");
                    textWriter.WriteLine(sb);

                    sb.Length = 0;
                    sb.Append(indent2);
                    sb.Append("</input>");
                    textWriter.WriteLine(sb);

                    if (!bIsOneWay)
                    {
                        sb.Length = 0;
                        sb.Append(indent2);
                        sb.Append("<output name='");
                        sb.Append(_methodTypes[2*i]);
                        sb.Append("Response'>");                                        
                        textWriter.WriteLine(sb);

                        sb.Length = 0;
                        sb.Append(indent3);
                        sb.Append("<soap:body use='encoded' encodingStyle='http://schemas.xmlsoap.org/soap/encoding/' namespace='");
			interopNamespace = SoapServices.GetXmlNamespaceForMethodResponse(method);
			if (interopNamespace == null)
			    sb.Append(ns);
			else
			    sb.Append(interopNamespace);
                        sb.Append("'/>");
                        textWriter.WriteLine(sb);

                        sb.Length = 0;
                        sb.Append(indent2);
                        sb.Append("</output>");
                        textWriter.WriteLine(sb);
                    }

                    sb.Length = 0;
                    sb.Append(indent1);
                    sb.Append("</operation>");
                    textWriter.WriteLine(sb);
                }

                sb.Length=0;
                sb.Append(indent);
                sb.Append("</binding>");
                textWriter.WriteLine(sb);                       
            }

            private void PrintSuds(Type type, String[] implIFaces, Type[] nestedTypes, TextWriter textWriter, StringBuilder sb, String indent)
            {
                Util.Log("RealSchemaType.PrintSuds  "+type+" implIFaces "+implIFaces+" nestedTypes "+nestedTypes);
                String indent1 = IndentP(indent);
                String indent2 = IndentP(indent1);
                String indent3 = IndentP(indent2);

                String sudsEnd = null;
                // Type, interface, extends information
                sb.Length = 0;
                sb.Append(indent1);
                if (type.IsInterface)
                {
                    sb.Append("<suds:interface type='");
                    sudsEnd = "</suds:interface>";


                }
                else if (type.IsValueType)
                {
                    sb.Append("<suds:struct type='");
                    sudsEnd = "</suds:struct>";
                }
                else
                {
                    sb.Append("<suds:class type='");
                    sudsEnd = "</suds:class>";
                }
                sb.Append(_xns.Prefix);
                sb.Append(':');
                sb.Append(WsdlGenerator.RefName(type));
                sb.Append("'");

                Type baseType = type.BaseType;
                if (IsNotSystemDefinedRoot(type, baseType))
                {
                    XMLNamespace xns = _WsdlGenerator.GetNamespace(baseType);
                    sb.Append(" extends='");
                    sb.Append(xns.Prefix);
                    sb.Append(':');
                    sb.Append(baseType.Name);
                    sb.Append("'");

                }

                if (baseType != null && baseType.FullName == "System.EnterpriseServices.ServicedComponent")
                    sb.Append(" rootType='ServicedComponent'");
                else if (typeof(Delegate).IsAssignableFrom(type) || typeof(MulticastDelegate).IsAssignableFrom(type))
                    sb.Append(" rootType='Delegate'");
                else if (typeof(MarshalByRefObject).IsAssignableFrom(type))
                    sb.Append(" rootType='MarshalByRefObject'");
                else if (typeof(ISerializable).IsAssignableFrom(type))
                    sb.Append(" rootType='ISerializable'");

                if (implIFaces == null && nestedTypes == null)
                    sb.Append("/>");
                else
                    sb.Append(">");

                textWriter.WriteLine(sb);

                String extendAttribute = null;
                if (type.IsInterface)
                    extendAttribute = "<suds:extends type='";
                else
                    extendAttribute = "<suds:implements type='";


                if (implIFaces != null)
                {
                    for (int j=0;j<implIFaces.Length;j++)
                    {
                        if (!(implIFaces[j] == null || implIFaces[j] == String.Empty))
                        {
                            sb.Length = 0;
                            sb.Append(indent2);                                 
                            sb.Append(extendAttribute);
                            sb.Append(implIFaces[j]);
                            sb.Append("'/>");
                            textWriter.WriteLine(sb);
                        }
                    }
                }

                if (nestedTypes != null)
                {
                    for (int j=0;j<nestedTypes.Length;j++)
                    {
                            sb.Length = 0;
                            sb.Append(indent2);                                 
                            sb.Append("<suds:nestedType name='");
                            sb.Append(nestedTypes[j].Name);
                            sb.Append("' type='");
                            sb.Append(_xns.Prefix);
                            sb.Append(':');
                            sb.Append(WsdlGenerator.RefName(nestedTypes[j]));
                            sb.Append("'/>");
                            textWriter.WriteLine(sb);
                    }
                }

                if (implIFaces != null || nestedTypes != null)
                {
                    sb.Length = 0;
                    sb.Append(indent1);
                    sb.Append(sudsEnd);
                    textWriter.WriteLine(sb);
                }
            }


            private static String ProcessArray(Type type, XMLNamespace xns)
            {
                Util.Log("RealSchemaType.ProcessArray Enter "+type);
                String qname = null;
                bool bbinary = false;
                Type elementType = type.GetElementType();
                String elementTypeName = "ArrayOf";
                while (elementType.IsArray)
                {
                    elementTypeName = elementTypeName+"ArrayOf";
                    elementType = elementType.GetElementType();
                }

                qname = RealSchemaType.TypeName(elementType, true, xns);
                int index = qname.IndexOf(":");
                String prefix = qname.Substring(0, index);
                String wireName = qname.Substring(index+1);
                Util.Log("RealSchemaType.ProcessArray qname "+qname+" wirename "+wireName);
                int rank =  type.GetArrayRank();
                String rankStr = "";
                if (rank > 1)
                    rankStr = rank.ToString();
                String csname =elementTypeName+wireName.Substring(0,1).ToUpper(CultureInfo.InvariantCulture)+wireName.Substring(1)+rankStr;
                csname = csname.Replace('+','N'); // need to get rid of + in nested classes
                ArraySchemaType ast = xns.LookupArraySchemaType(csname); 
                if (ast == null)
                {
                    ArraySchemaType cstype = new ArraySchemaType(type, csname, SchemaBlockType.ComplexContent, false);
                    Restriction restriction = new Restriction();
                    SchemaAttribute attribute = new SchemaAttribute();
                    if (bbinary)
                        attribute.AddArray(qname);
                    else
                    {
                        String arrayTypeName = type.Name;
                        index = arrayTypeName.IndexOf("[");
                        attribute.AddArray(qname+arrayTypeName.Substring(index));
                    }

                    restriction.AddArray(attribute);
                    cstype.AddParticle(restriction);
                    xns.AddArraySchemaType(cstype);
                }

                String returnStr = xns.Prefix+":"+csname;
                Util.Log("RealSchemaType.ProcessArray Exit "+returnStr);
                return returnStr;
            }



            internal static String TypeName(Type type, bool bEmbedded, XMLNamespace thisxns)
            {
                Util.Log("RealSchemaType.TypeName entry "+type+" bEmbedded "+bEmbedded+" xns "+thisxns.Name);              
                String typeName = null;
                if (type.IsArray)
                    return ProcessArray(type, thisxns);

                String clrTypeName = WsdlGenerator.RefName(type);
                Type clrType = type;

                // If ref type the name ends in &
                if (type.IsByRef)
                {
                    clrType = type.GetElementType(); 
                    clrTypeName = WsdlGenerator.RefName(clrType);
                    if (clrType.IsArray)
                        return ProcessArray(clrType, thisxns);
                }

                typeName = SudsConverter.MapClrTypeToXsdType(clrType);

                if (typeName == null)
                {
                    String ns = type.Namespace;
                    Assembly assem = type.Module.Assembly; 
                    XMLNamespace xns = null;
                    Util.Log("RealSchemaType.TypeName realNS "+ns);
                    xns = (XMLNamespace)thisxns.Generator._typeToInteropNS[type];

                    if (xns == null)
                    {
                        xns = thisxns.LookupSchemaNamespace(ns, assem);
                        if (xns == null)
                        {
                            xns = thisxns.Generator.LookupNamespace(ns,assem);
                            if (xns == null)
                            {
                                xns = thisxns.Generator.AddNamespace(ns, assem);
                            }
                            thisxns.DependsOnSchemaNS(xns, false);
                        }
                        Util.Log("RealSchemaType.TypeName depended NS with assem equals "+xns.Name);
                    }
                    StringBuilder sb = new StringBuilder(256);

                    sb.Append(xns.Prefix);
                    sb.Append(':');
                    sb.Append(clrTypeName);
                    typeName = sb.ToString();
                }

                Util.Log("RealSchemaType.TypeName exit "+typeName);
                return typeName;
            }
            

            static private Type[] GetIntroducedInterfaces(Type type)
            {
                ArrayList ifaceA = new ArrayList();
                Type[] typeA = type.GetInterfaces();
                // remove system interfaces.
                foreach (Type itype in typeA)
                {
                    if (!itype.FullName.StartsWith("System."))
                    {
                        ifaceA.Add(itype);
                        Util.Log("RealSchemaType.GetIntroducedInterfaces "+type+" Interfaces "+itype);
                    }
                }

                Util.Log("RealSchemaType.GetIntroducedInterfaces "+type+" typeInterface? "+type.IsInterface+" number of interfaces "+typeA.Length);               

                Type[] ifaceTypes = new Type[ifaceA.Count];
                for(int i=0; i<ifaceA.Count; i++)
                   ifaceTypes[i] = (Type)ifaceA[i];
                return ifaceTypes;
            }

            static private void FindMethodAttributes(Type type, MethodInfo[] infos, ref String[] methodAttributes, BindingFlags bFlags)
            {
                Util.Log("RealSchemaType.FindMethodAttributes Enter "+type);
                Type baseType = type;
                ArrayList inherit = new ArrayList();
                while (true)
                {
                    baseType = baseType.BaseType;

                    Util.Log("RealSchemaType.FindMethodAttributes baseType "+baseType);
                    if (baseType != null && !baseType.FullName.StartsWith("System."))
                        inherit.Add(baseType);
                    else
                        break;
                }

                StringBuilder sb = new StringBuilder();
                for(int i=0; i<infos.Length; i++)
                {
                    MethodBase info = (MethodBase)infos[i];
                    sb.Length = 0;
                    MethodAttributes ma = info.Attributes;
                    bool bVirtual = info.IsVirtual;
                    bool bNewSlot = ((ma & MethodAttributes.NewSlot) == MethodAttributes.NewSlot);
                    Util.Log("RealSchemaType.FindMethodAttributes "+info.Name+" bVirtual "+bVirtual+" bNewSlot "+bNewSlot+" hidebysig "+info.IsHideBySig);
                    if (info.IsPublic)
                        sb.Append("public");
                    else if (info.IsFamily)
                        sb.Append("protected");
                    else if (info.IsAssembly)
                        sb.Append("internal");
                    
                    // See if method hides inherited methods
                    bool bHides = false;
                    for (int j=0; j<inherit.Count; j++)
                    {
                        baseType = (Type)inherit[j];
                        ParameterInfo[] paramInfos = info.GetParameters();
                        Type[] types = new Type[paramInfos.Length];
                        for (int itype=0; itype<types.Length; itype++)
                        {
                            types[itype] = paramInfos[itype].ParameterType;
                        }
                        MethodInfo baseInfo = baseType.GetMethod(info.Name, types);
                        if (baseInfo != null)
                        {
                            // Hides
                            if (sb.Length > 0)
                                sb.Append(" ");
                            if (bNewSlot || baseInfo.IsFinal)
                                sb.Append("new");
                            else if (baseInfo.IsVirtual && bVirtual)
                                sb.Append("override");
                            else 
                                sb.Append("new");
                            bHides = true;
                            break;
                        }
                    }
                    if (!bHides && bVirtual)
                    {
                        if (sb.Length > 0)
                            sb.Append(" ");
                        sb.Append("virtual");
                    }

                    if (sb.Length > 0)
                    {
                        methodAttributes[i] = sb.ToString();
                        Util.Log("RealSchemaType.FindMethodAttributes Exit "+info.Name+" "+methodAttributes[i]);     
                    }
                }
            }

            static private MethodInfo[] GetIntroducedMethods(Type type, ref String[] methodAttributes)
            {
                Util.Log("RealSchemaType.GetIntroducedMethods "+type);     


                // Methods in the class are either the class public methods or interface qualified methods

                BindingFlags bFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public;
                MethodInfo[] methodInfos = type.GetMethods(bFlags); //public methods (including unqualified interface methods)

                if (type.IsInterface)
                    return methodInfos;

                // Find method attributes for public  methods
                methodAttributes = new String[methodInfos.Length];
                FindMethodAttributes(type, methodInfos, ref methodAttributes, bFlags);

                // Get any class methods which are interface qualifed methods.
                // interface qualified methods are not public in the metadata.
                ArrayList additionalInfos = new ArrayList();
                Type[] itypeA = type.GetInterfaces();
                foreach (Type itype in itypeA )
                {
                    InterfaceMapping im = type.GetInterfaceMap(itype);
                    foreach (MethodInfo mi in im.TargetMethods)
                    {
                        if (!mi.IsPublic && type.GetMethod(mi.Name, bFlags | BindingFlags.NonPublic) != null)
                        {
                            additionalInfos.Add(mi);
                        }
                    }
                }

                // Combine all the methodinfos into one structure
                MethodInfo[] finalMethodInfos = null;
                if (additionalInfos.Count > 0)
                {
                    finalMethodInfos = new MethodInfo[methodInfos.Length + additionalInfos.Count];
                    for(int i=0; i<methodInfos.Length; i++)
                        finalMethodInfos[i] = methodInfos[i];
                    for(int i=0; i<additionalInfos.Count; i++)
                        finalMethodInfos[methodInfos.Length+i] = (MethodInfo)additionalInfos[i];
                }
                else
                    finalMethodInfos = methodInfos;

                return finalMethodInfos;
            }

            internal static String PrintMethodName(MethodInfo methodInfo)
            {
                String methodName = methodInfo.Name;
                int lastDot = 0;
                int prevDot = 0;

                for (int i=0; i<methodName.Length; i++)
                {
                    if (methodName[i] == '.')
                    {
                        prevDot = lastDot;
                        lastDot = i;
                    }
                }

                String iname = methodName;

                if (prevDot > 0)
                    iname = methodName.Substring(prevDot+1);

                return iname;
            }

            static private FieldInfo[] GetInstanceFields(Type type){
                Util.Log("RealSchemaType.GetIntroducedFields "+type);                               

                BindingFlags bFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance |
                                      BindingFlags.Public;

                if (!s_marshalByRefType.IsAssignableFrom(type))
                    bFlags |= BindingFlags.NonPublic;

                FieldInfo[] fields = type.GetFields(bFlags);
                Util.Log("RealSchemaType.GetIntroducedFields length "+fields.Length);                               
                int actualLength = fields.Length;
                if (actualLength == 0)
                    return(emptyFieldSet);

                for (int i=0;i<fields.Length;i++)
                {
                    Util.Log("RealSchemaType.GetInstanceFields field "+fields[i].Name+" "+fields[i].FieldType+" type "+type);
                    if (fields[i].IsStatic)
                    {
                        Debug.Assert(false, "Static Field");
                        Util.Log("RealSchemaType.GetInstanceFields field  static "+fields[i].FieldType);
                        --actualLength;
                        fields[i] = fields[actualLength];
                        fields[actualLength] = null;
                    }
                }

                if (actualLength < fields.Length)
                {
                    FieldInfo[] ifields = new FieldInfo[actualLength];
                    Array.Copy(fields, ifields, actualLength);
                    Util.Log("RealSchemaType.GetInstanceFields adjust length "+actualLength);
                    return(ifields);
                }

                return(fields);
            }

            // Instance fields
            private WsdlGenerator _WsdlGenerator;
            private Type _type;
            private String _serviceEndpoint;
            private Hashtable _typeToServiceEndpoint;
            private bool _bUnique;
            private XMLNamespace _xns;
            private bool _bStruct;
            private String[] _implIFaces;

            private Type[] _iFaces;
            private MethodInfo[] _methods;
            private String[] _methodAttributes;
            private String[] _methodTypes;
            private FieldInfo[] _fields;
            private PhonySchemaType[] _phony;
            internal Type[] _nestedTypes;

            // Static fields
            private static Type[] emptyTypeSet = new Type[0];
            private static MethodInfo[] emptyMethodSet = new MethodInfo[0];
            private static FieldInfo[] emptyFieldSet = new FieldInfo[0];
        }

        private class XMLNamespace
        {
            internal XMLNamespace(String name, Assembly assem, String serviceEndpoint, Hashtable typeToServiceEndpoint, String prefix, bool bInteropType, WsdlGenerator generator ){
                Util.Log("XMLNamespace.XMLNamespace Enter "+name+" serviceEndpoint "+serviceEndpoint+" prefix "+prefix+" bInteropType "+bInteropType);
                _name = name;
                _assem = assem;
                _bUnique = false;
                _bInteropType = bInteropType;
                _generator = generator;
                StringBuilder sb = new StringBuilder(256);
                Assembly systemAssembly = typeof(String).Module.Assembly;

                // Remove leading . for an empty namespace

                if (!_bInteropType)
                {
                    if (assem == systemAssembly)
                    {
                        sb.Append(SoapServices.CodeXmlNamespaceForClrTypeNamespace(name, null));
                    }
                    else if (assem != null)
                    {
                        sb.Append(SoapServices.CodeXmlNamespaceForClrTypeNamespace(name, assem.FullName));
                    }
                }
                else
                {
                    sb.Append(name);
                }
                _namespace = sb.ToString();
                _prefix = prefix;
                _dependsOnSchemaNS = new ArrayList();
                _realSUDSTypes = new ArrayList();
                _dependsOnSUDSNS = new ArrayList();
                _realSchemaTypes = new ArrayList();
                _phonySchemaTypes = new ArrayList();
                _simpleSchemaTypes = new ArrayList();
                _arraySchemaTypes = new ArrayList();
                _xnsImports = new ArrayList();
                _serviceEndpoint = serviceEndpoint;
                _typeToServiceEndpoint = typeToServiceEndpoint;
                Util.Log("XMLNamespace.XMLNamespace exit "+_namespace);
            }

            internal String Name{
                get{ return(_name);}
            }
            internal Assembly Assem{
                get{ return(_assem);}
            }
            internal String Prefix{
                get{ return(_prefix);}
            }
            internal String Namespace{
                get{ return(_namespace);}
            }

            internal bool IsInteropType{
                get{return(_bInteropType);}
            }

            internal WsdlGenerator Generator
            {
                get {return (_generator);}
            }

            internal bool IsClassesPrinted
            {
                get {return _bClassesPrinted;}
                set {_bClassesPrinted = value;}
            }


            //internal XMLNamespace(String name, Assembly assem, String serviceEndpoint, Hashtable typeToServiceEndpoint, String prefix, bool bInteropType, WsdlGenerator generator ){

            /*
            internal SchemaType LookupSchemaType(Type type)
            {
                return (SchemaType)_typeToSchemaType[type];
            }

            internal Type LookupType(SchemaType stype)
            {
                return (Type)_schemaTypeToType[stype];
            }
            */

            internal Type LookupSchemaType(String name)
            {
                Type returnType = null;
                RealSchemaType rsType = LookupRealSchemaType(name);
                if (rsType != null)
                    returnType = rsType.Type;

                SimpleSchemaType ssType = LookupSimpleSchemaType(name);
                if (ssType != null)
                    returnType = ssType.Type;

                ArraySchemaType asType = LookupArraySchemaType(name);
                if (asType != null)
                    returnType = asType.Type;

                Util.Log("XMLNamespace.LookupSchemaType "+name+" return "+returnType);
                return(returnType);
            }

            internal SimpleSchemaType LookupSimpleSchemaType(String name){
                Util.Log("XMLNamespace.LookupSimpleSchemaType "+name);              
                for (int i=0;i<_simpleSchemaTypes.Count;i++)
                {
                    SimpleSchemaType ssType = (SimpleSchemaType) _simpleSchemaTypes[i];
                    if (ssType.FullRefName == name)
                        return(ssType);
                }

                return(null);
            }

	    internal bool CheckForSchemaContent()
	    {
                if (_arraySchemaTypes.Count > 0 ||
                    _simpleSchemaTypes.Count > 0)
		    return true;

		if (_realSchemaTypes.Count ==  0)
		    return false;

		bool bRealSchema = false;
		for (int i=0;i<_realSchemaTypes.Count;i++)
		{
		    RealSchemaType rsType = (RealSchemaType) _realSchemaTypes[i];
		    if (!rsType.Type.IsInterface && !rsType.IsSUDSType)
		    {
			bRealSchema = true;
			break;
		    }
		}

		if (bRealSchema)
		    return true;
		else
		    return false;
	    }

            internal RealSchemaType LookupRealSchemaType(String name){
                Util.Log("XMLNamespace.LookupRealSchemaType "+name);                                
                Debug.Assert(_phonySchemaTypes.Count == 0, "PhonyTypes present");
                for (int i=0;i<_realSchemaTypes.Count;i++)
                {
                    RealSchemaType rsType = (RealSchemaType) _realSchemaTypes[i];
                    if (rsType.FullRefName == name)
                        return(rsType);
                }

                return(null);
            }

            internal ArraySchemaType LookupArraySchemaType(String name){
                Util.Log("XMLNamespace.LookupArraySchemaType "+name);                                
                Debug.Assert(_phonySchemaTypes.Count == 0, "PhonyTypes present");
                for (int i=0;i<_arraySchemaTypes.Count;i++)
                {
                    ArraySchemaType asType = (ArraySchemaType) _arraySchemaTypes[i];
                    if (asType.Name == name)
                        return(asType);
                }

                return(null);
            }

            internal void AddRealSUDSType(RealSchemaType rsType){
                Util.Log("XMLNamespace.AddRealSUDSType "+rsType.Type);                              
                _realSUDSTypes.Add(rsType);
                //_typeToSchemaType[rsType.Type] = rsType;
                //_schemaTypeToType[rsType] = rsType.Type;
                return;
            }

            internal void AddRealSchemaType(RealSchemaType rsType){
                Util.Log("XMLNamespace.AddRealSchemaType "+rsType.Type);                              
                Debug.Assert(LookupRealSchemaType(rsType.Name) == null, "Duplicate Type found");
                _realSchemaTypes.Add(rsType);
                if (rsType.IsUnique)
                    _bUnique = true;
                //_typeToSchemaType[rsType.Type] = rsType;
                //_schemaTypeToType[rsType] = rsType.Type;
                return;
            }

            internal void AddArraySchemaType(ArraySchemaType asType){
                Debug.Assert(LookupArraySchemaType(asType.Name) == null, "Duplicate Type found");
                _arraySchemaTypes.Add(asType);
                //_typeToSchemaType[asType.Type] = asType;
                //_schemaTypeToType[asType] = asType.Type;
                return;
            }
            
            internal void AddSimpleSchemaType(SimpleSchemaType ssType){
                Util.Log("XMLNamespace.AddSimpleSchemaType "+ssType.Type);                              
                Debug.Assert(LookupSimpleSchemaType(ssType.Type.Name) == null, "Duplicate Type found");
                _simpleSchemaTypes.Add(ssType);
                //_typeToSchemaType[ssType.Type] = ssType;
                //_schemaTypeToType[ssType] = ssType.Type;
                return;
            }

            internal PhonySchemaType LookupPhonySchemaType(String name){
                Util.Log("XMLNamespace.LookupPhonySchemaType "+name);                                               
                for (int i=0;i<_phonySchemaTypes.Count;i++)
                {
                    PhonySchemaType type = (PhonySchemaType) _phonySchemaTypes[i];
                    if (type.Name == name)
                        return(type);
                }

                return(null);
            }

            internal void AddPhonySchemaType(PhonySchemaType phType){
                Util.Log("XMLNamespace.AddPhonySchemaType "+phType.Name);                                                               
                PhonySchemaType overloadedType = LookupPhonySchemaType(phType.Name);
                if (overloadedType != null)
                    phType.ElementName = phType.Name + overloadedType.OverloadedType();
                _phonySchemaTypes.Add(phType);

                return;
            }

            internal XMLNamespace LookupSchemaNamespace(String ns, Assembly assem){
                Util.Log("XMLNamespace.LookupSchemaNamespace "+ns);                                                             
                for (int i=0;i<_dependsOnSchemaNS.Count;i++)
                {
                    XMLNamespace xns = (XMLNamespace) _dependsOnSchemaNS[i];
                    if ((xns.Name == ns) && (xns.Assem == assem))
                        return(xns);
                }

                return(null);
            }

            internal void DependsOnSchemaNS(XMLNamespace xns, bool bImport){
                Util.Log("XMLNamespace.DependsOnSchemaNS "+Namespace+" depends on "+xns.Namespace+" bImport "+bImport);                                                              
                if (LookupSchemaNamespace(xns.Name, xns.Assem) != null)
                    return;

                _dependsOnSchemaNS.Add(xns);
                if (bImport && Namespace != xns.Namespace)
                    _xnsImports.Add(xns);
                return;
            }

            private XMLNamespace LookupSUDSNamespace(String ns, Assembly assem){
                Util.Log("XMLNamespace.LookupSUDSNamespace "+ns);                                                               
                for (int i=0;i<_dependsOnSUDSNS.Count;i++)
                {
                    XMLNamespace xns = (XMLNamespace) _dependsOnSUDSNS[i];
                    if ((xns.Name == ns) && (xns.Assem == assem))
                        return(xns);
                }

                return(null);
            }

            internal void DependsOnSUDSNS(XMLNamespace xns){
                Util.Log("XMLNamespace.DependsOnSUDSNS "+xns.Name+" "+xns.Assem);
                if (LookupSUDSNamespace(xns.Name, xns.Assem) != null)
                    return;

                _dependsOnSUDSNS.Add(xns);
                return;
            }

            internal void Resolve(){
                Util.Log("XMLNamespace.Resolve");                                                               
                StringBuilder sb = new StringBuilder(256);
                for (int i=0;i<_realSchemaTypes.Count;i++)
                    ((RealSchemaType) _realSchemaTypes[i]).Resolve(sb);

                return;
            }

            internal void PrintDependsOnWsdl(TextWriter textWriter, StringBuilder sb, String indent, Hashtable usedNames)
	    {
		Util.Log("XMLNamespace.PrintDependsOn "+_name+" targetNameSpace "+Namespace);     

		if (_dependsOnSchemaNS.Count > 0)
		{
		    for (int i=0;i<_dependsOnSchemaNS.Count;i++)
		    {
			XMLNamespace xns = (XMLNamespace) _dependsOnSchemaNS[i];
			if (!usedNames.ContainsKey(xns.Prefix))
			{
			    usedNames[xns.Prefix] = null;

			    sb.Length = 0;
			    sb.Append(indent);
			    sb.Append("xmlns:");                            
			    sb.Append(xns.Prefix);
			    sb.Append("='");
			    sb.Append(xns.Namespace);
			    sb.Append("'");
			    textWriter.WriteLine(sb);
			}
		    }
		}
            }


            internal void PrintSchemaWsdl(TextWriter textWriter, StringBuilder sb, String indent){
                Util.Log("XMLNamespace.PrintSchemaWsdl "+Namespace+" _realSchemaTypes.Count "+_realSchemaTypes.Count);                      
                // Print schema types

                bool bReal = false; 

                /*
                for(int i=0;i<_realSchemaTypes.Count;i++)
                {
                    RealSchemaType rsType = (RealSchemaType) _realSchemaTypes[i];
                    if(!rsType.Type.IsInterface && !rsType.IsSUDSType)
                        bReal = true;
                }
                */

                if ((_simpleSchemaTypes.Count > 0) || (_realSchemaTypes.Count > 0) || (_arraySchemaTypes.Count > 0))
                {
                    bReal = true;
                }

                // Print schema types
                if (bReal)
                {
                    // schema begin
                    String indent1 = IndentP(indent);
                    String indent2 = IndentP(indent1);
                    String indent3 = IndentP(indent2);
                    String indent4 = IndentP(indent3);                                  
                    sb.Length = 0;
                    sb.Append(indent);
                    sb.Append("<schema ");
                    sb.Append("targetNamespace='");
                    sb.Append(Namespace);
                    sb.Append("'");
                    textWriter.WriteLine(sb);

                    sb.Length = 0;
                    sb.Append(indent2);
                    sb.Append("xmlns='");
                    sb.Append(SudsConverter.GetXsdVersion(_generator._xsdVersion));
                    sb.Append("'");
                    textWriter.WriteLine(sb);

                    sb.Length = 0;
                    sb.Append(indent2);         
                    sb.Append("elementFormDefault='unqualified' attributeFormDefault='unqualified'>");
                    textWriter.WriteLine(sb);

                    // Write import statements
                    foreach (XMLNamespace xns in _xnsImports)
                    {
                        sb.Length = 0;
                        sb.Append(indent1);
                        sb.Append("<import namespace='");
                        sb.Append(xns.Namespace);
                        sb.Append("'/>");
                        textWriter.WriteLine(sb);
                    }


                    for (int i=0;i<_simpleSchemaTypes.Count;i++)
                    {
                        SimpleSchemaType ssType = (SimpleSchemaType) _simpleSchemaTypes[i];
                        ssType.PrintSchemaType(textWriter, sb, indent1, false);
                    }

                    for (int i=0;i<_realSchemaTypes.Count;i++)
                    {
                        RealSchemaType rsType = (RealSchemaType) _realSchemaTypes[i];
                        if (!rsType.Type.IsInterface && !rsType.IsSUDSType)
                            rsType.PrintSchemaType(textWriter, sb, indent1, false);
                    }

                    for (int i=0;i<_arraySchemaTypes.Count;i++)
                    {
                        ArraySchemaType asType = (ArraySchemaType) _arraySchemaTypes[i];
                        asType.PrintSchemaType(textWriter, sb, indent1, false);
                    }


                    /*
                    for(int i=0;i<_phonySchemaTypes.Count;i++)
                    {
                        PhonySchemaType psType = (PhonySchemaType) _phonySchemaTypes[i];
                        psType.PrintSchemaType(textWriter, sb, indent1, true);
                    }
                    */

                    sb.Length = 0;
                    sb.Append(indent);
                    sb.Append("</schema>");
                    textWriter.WriteLine(sb);


                }
            }

            internal void PrintMessageWsdl(TextWriter textWriter, StringBuilder sb, String indent, ArrayList refNames)
            {
                Util.Log("XmlNamespace.PrintMessageWsdl");
                for (int i=0;i<_realSUDSTypes.Count;i++)
                    ((RealSchemaType) _realSUDSTypes[i]).PrintMessageWsdl(textWriter, sb, indent, refNames);
                
                if (_realSUDSTypes.Count == 0 && _realSchemaTypes.Count > 0)
                {
                    // If no suds type, we still generate a binding section to print the Suds Extendsions
                    // We only need to do this once, because all the realschema types will be placed into
                    // one binding
                    ((RealSchemaType) _realSchemaTypes[0]).PrintMessageWsdl(textWriter, sb, indent, new ArrayList());
                }
            }

            // Fields
            private String _name;
            private Assembly _assem;
            private String _namespace;
            private String _prefix;
            internal bool _bUnique; 
            private ArrayList _dependsOnSUDSNS;
            private ArrayList _realSUDSTypes;
            private ArrayList _dependsOnSchemaNS;
            internal ArrayList _realSchemaTypes;
            private ArrayList _phonySchemaTypes;
            private ArrayList _simpleSchemaTypes;
            private ArrayList _arraySchemaTypes;
            private bool _bInteropType;
            private String _serviceEndpoint;
            private Hashtable _typeToServiceEndpoint;
            private WsdlGenerator _generator;
            private ArrayList _xnsImports;
            private bool _bClassesPrinted = false;
            //private Hashtable _typeToSchemaType = new Hashtable();
            //private Hashtable _schemaTypeToType = new Hashtable();


        }

        internal static String IndentP(String indentStr){
            return indentStr+"    ";
        }

        internal static String IndentM(String indentStr){
            return indentStr.Substring(0, indentStr.Length-4);
        }
                        }
                        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\system\security\cryptography\xml\canonicalxml.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// CanonicalXml.cs
//
// Implementation of W3C Canonical XML 1.0 Candidate Recommendation
//
// Author: bal
//

namespace System.Security.Cryptography.Xml {
    using System;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.XPath;
    using System.IO;
    using System.Text;
    using System.Collections;

    // This class accepts as input either a Stream or an XmlNodeList and and
    // returns a Stream that contains the canonical form of the input
    internal class CanonicalXml {

        // private members
        private CanonicalXmlDocument _c14ndoc = null;
        private String _xpathexpr;
        private bool _includeComments = false;

        // -1 == before root element, 0 == inside root element, 1 == after root element
        // for fragment processing, default to 0
        private int _insideDocumentElement = 0;  
#if _DEBUG
        private static bool debug = false;
#endif

        // Constructors
        // We provide a variety of constructors here, but the end
        // result is to set/create _c14ndoc to be a CanonicalXmlDocument over the
        // content with the to-be-canonicalized nodes properly marked.

        // We use the following default XPath expressions as
        // defined in Section 2.1 if one isn't specified:
        // Canonicalization w/o comments: (//. | //@* | //namespace::*)[not(self::comment())]
        // Canonicalization w/ comments: (//. | //@* | //namespace::*)

        // When we determine that a node in the _c14ndoc is part of the selected set we set the 
        // C14NState property on the node with a value of CanonicalizationState.ToBeCanonicalized. 
        // When we later canonicalize a node in we set the C14NState property on the node to be 
        // CanonicalizationState.AlreadyCanonicalized.
        // That way we can do an XPath selection and iterate through the nodes
        // and not canonicalize a node twice..

        // Comment processing by XPath expression seems busted at the moment, so work-around in the
        // CanonicalizeCommentNode routine
        private static String defaultXPathWithoutComments = "(//. | //@* | //namespace::*)[not(self::comment())]";
        //private static String defaultXPathWithoutComments = "(//. | //@* | //namespace::*)";
        //private static String defaultXPathWithComments = "(//. | //@* | //namespace::*)";
        private static String defaultXPathWithComments = "(//. | //@* | //namespace::*)";

        // 

        //
        // Constructors
        //

        public CanonicalXml(Stream inputStream, XmlResolver resolver, string strBaseUri)
            : this(inputStream, false, resolver, strBaseUri) {
        }

        public CanonicalXml(Stream inputStream, bool includeComments, XmlResolver resolver, string strBaseUri) {
            _c14ndoc = new CanonicalXmlDocument();
            _c14ndoc.PreserveWhitespace = true;
            XmlValidatingReader valReader = SignedXml.PreProcessStreamInput(inputStream, resolver, strBaseUri);
            _c14ndoc.Load(valReader);

            if (includeComments) {
                // hack b/c of XPath problems
                _includeComments = true;
                _xpathexpr = defaultXPathWithComments;
            } else {
                _xpathexpr = defaultXPathWithoutComments;
            }
            MarkNodesForCanonicalization();
        }

        public CanonicalXml(XmlReader xmlReader) :
            this(xmlReader, false) {
        }

        public CanonicalXml(XmlReader xmlReader, bool includeComments) {
            _c14ndoc = new CanonicalXmlDocument();
            _c14ndoc.PreserveWhitespace = true;
            _c14ndoc.Load(xmlReader);
            if (includeComments) {
                // hack b/c of XPath problems
                _includeComments = true;
                _xpathexpr = defaultXPathWithComments;
            } else {
                _xpathexpr = defaultXPathWithoutComments;
            }
            MarkNodesForCanonicalization();
        }

        public CanonicalXml(XmlDocument document) 
            : this(document, false) {
        }

        public CanonicalXml(XmlDocument document, bool includeComments) {
            _c14ndoc = new CanonicalXmlDocument();
            _c14ndoc.PreserveWhitespace = true;
            _c14ndoc.Load(new XmlNodeReader(document));
            if (includeComments) {
                // hack b/c of XPath problems
                _includeComments = true;
                _xpathexpr = defaultXPathWithComments;
            } else {
                _xpathexpr = defaultXPathWithoutComments;
            }
            MarkNodesForCanonicalization();
        }

        public CanonicalXml(XmlNodeList nodeList, bool includeComments) {
            XmlNode root = null;
            CanonicalXmlNodeList elementList = new CanonicalXmlNodeList();
            CanonicalXmlNodeList elementListCanonical = new CanonicalXmlNodeList();

            if (includeComments) {
                // hack b/c of XPath problems
                _includeComments = true;
                _xpathexpr = defaultXPathWithComments;
            } else {
                _xpathexpr = defaultXPathWithoutComments;
            }

            _c14ndoc = new CanonicalXmlDocument();
            _c14ndoc.PreserveWhitespace = true;

            if (nodeList != null) {
                foreach (XmlNode node in nodeList) {
                    if (node == null) continue;
                    root = node.OwnerDocument;
                    if (root != null) break;
                }
            }
            if (root == null) return;

            _c14ndoc.Load(new XmlNodeReader(root));

            // Now Create the hierarchy
            int index = 0;
            elementList.Add(root);
            elementListCanonical.Add(_c14ndoc);
                
            do {
                XmlNode rootNode = (XmlNode) elementList[index];
                XmlNode rootNodeCanonical = (XmlNode) elementListCanonical[index];
                // Add the children nodes
                XmlNodeList childNodes = rootNode.ChildNodes;
                XmlNodeList childNodesCanonical = rootNodeCanonical.ChildNodes;
                for (int i=0; i<childNodes.Count; i++) {
                    elementList.Add(childNodes[i]);
                    elementListCanonical.Add(childNodesCanonical[i]);
                    if (NodeInList(childNodes[i], nodeList)) {
                        // Add the attribute nodes
                        XmlAttributeCollection attribNodes = childNodes[i].Attributes;
                        if (attribNodes != null) {
                            for (int j=0; j<attribNodes.Count; j++) {
                                if (NodeInList(attribNodes[j], nodeList))
                                    MarkNodeForCanonicalization(childNodesCanonical[i].Attributes.Item(j), CanonicalizationState.ToBeCanonicalized);
                            }
                        }

                        // propagate namespaces through the node-set
                        if (childNodesCanonical[i] is XmlElement) {
                            XmlElement elem = childNodesCanonical[i] as XmlElement;
                            CanonicalXmlNodeList nodeListNS = GetAttributesInScope(elem);
                            if (nodeListNS != null) {
                                foreach (XmlNode attr in nodeListNS) {
                                    XmlAttribute attribute = attr as XmlAttribute;
                                    string name = ((attribute.Prefix != String.Empty) ? attribute.Prefix + ":" + attribute.LocalName : attribute.LocalName);
                                    // Skip the attribute if one with the same qualified name already exists
                                    if (elem.HasAttribute(name)) continue;
                                    CanonicalXmlAttribute nsattrib = (CanonicalXmlAttribute) _c14ndoc.CreateAttribute(name);
                                    nsattrib.Value = attribute.Value;
                                    elem.SetAttributeNode(nsattrib);
                                    MarkNodeForCanonicalization(nsattrib, CanonicalizationState.ToBeCanonicalized);
                                }
                            } 
                        }
                        MarkNodeForCanonicalization(childNodesCanonical[i], CanonicalizationState.ToBeCanonicalized);
                    } 
                }
                index++;
            } while (index < elementList.Count);
        }

        private bool NodeInList (XmlNode node, XmlNodeList nodeList) {
            foreach (XmlNode nodeElem in nodeList) {
                if (nodeElem == node) return true;
            }
            return false;
        }

        //
        // Methods
        //

        private void MarkNodeForCanonicalization(XmlNode node, CanonicalizationState state) {
#if _DEBUG                
                if (debug) {
                    Console.WriteLine("marking node of type: "+node.NodeType.ToString());
                }
#endif

            switch (node.NodeType) {
            case (XmlNodeType.Element):
                ((CanonicalXmlElement) node).C14NState = state;
                return;
            case (XmlNodeType.Attribute):
                ((CanonicalXmlAttribute) node).C14NState = state;
                return;
            case (XmlNodeType.Text):
                ((CanonicalXmlText) node).C14NState = state;
                return;
            case (XmlNodeType.Whitespace):
                ((CanonicalXmlWhitespace) node).C14NState = state;
                return;
            case (XmlNodeType.SignificantWhitespace):
                ((CanonicalXmlSignificantWhitespace) node).C14NState = state;
                return;
            case (XmlNodeType.Comment):
                ((CanonicalXmlComment) node).C14NState = state;
                return;
            case (XmlNodeType.ProcessingInstruction):
                ((CanonicalXmlProcessingInstruction) node).C14NState = state;
                return;
            case (XmlNodeType.CDATA):
                ((CanonicalXmlCDataSection) node).C14NState = state;
                return;
            case (XmlNodeType.EntityReference):
                ((CanonicalXmlEntityReference) node).C14NState = state;
                return;
            default:
                return;
            }
        }

        private void MarkNodesForCanonicalization() {
            XmlNodeList nodelist;
            // for now, we can't do namespaces in XPath expressions, so hack around it
            if (_includeComments) {
                nodelist = AllDescendantNodes(_c14ndoc, true);
            } else {
                nodelist = AllDescendantNodes(_c14ndoc, false);
            }
#if _DEBUG
            if (debug) {
                Console.WriteLine("MarkNodesForCanonicalization: found {0} nodes",nodelist.Count);
            }
#endif
            foreach (XmlNode node in nodelist) {
                MarkNodeForCanonicalization(node, CanonicalizationState.ToBeCanonicalized);
            }
        }

        public StringBuilder CanonicalizeNode(XmlNode node) {
#if _DEBUG
            if (debug) {
                Console.WriteLine("Canonicalizing node: "+ node.NodeType +": " +node.OuterXml);
            }
#endif
            switch (node.NodeType) {
            case (XmlNodeType.Element):
                return CanonicalizeElementNode((CanonicalXmlElement) node);
            case (XmlNodeType.Attribute):
                return CanonicalizeAttributeNode((CanonicalXmlAttribute) node);
            case (XmlNodeType.Text):
                return CanonicalizeTextNode((CanonicalXmlText) node);
            case (XmlNodeType.Whitespace):
                return CanonicalizeWhitespaceNode((CanonicalXmlWhitespace) node);
            case (XmlNodeType.SignificantWhitespace):
                return CanonicalizeSignificantWhitespaceNode((CanonicalXmlSignificantWhitespace) node);
            case (XmlNodeType.Comment):
                // hack hack for now
                return CanonicalizeCommentNode((CanonicalXmlComment) node, _includeComments);
            case (XmlNodeType.ProcessingInstruction):
                return CanonicalizeProcessingInstructionNode((CanonicalXmlProcessingInstruction) node);
            case (XmlNodeType.Document):
                return CanonicalizeDocumentNode(node);
            case (XmlNodeType.EntityReference):
                return CanonicalizeEntityReferenceNode((CanonicalXmlEntityReference) node);
            case (XmlNodeType.CDATA):
                return CanonicalizeCDataSection((CanonicalXmlCDataSection) node);
            default:
                return CanonicalizeOtherNode(node);
            }
        }

        //
        // NodeType-specific utilities
        //

        // StringBuilder utilities
        
        private static void SBReplaceCharWithString(StringBuilder sb, char oldChar, String newString) {
            int i = 0;
            int newStringLength = newString.Length;
            while (i < sb.Length) {
                if (sb[i] == oldChar) {
                    sb.Remove(i,1);
                    sb.Insert(i,newString);
                    i += newStringLength;
                } else i++;
            }
        }

        // Canonicalize the Document node
        // We handle this case special because whitespace and linefeed processing is different
        // if we are before, inside or after the single element child of the Document node.

        public StringBuilder CanonicalizeDocumentNode(XmlNode node) {
            if (node == null) throw new ArgumentNullException("node");
            if (node.NodeType != XmlNodeType.Document) {
                throw new ArgumentException("node");
            }

            // For the Document nodes, we never have anything to output for the node
            // directly.  All we want to do is recursively canonicalize its children,
            // setting state on _insideDocumentElement accordingly

            _insideDocumentElement = -1;
            StringBuilder sb = new StringBuilder();

            // Recursively process the children..
            XmlNodeList childNodes = node.ChildNodes;
            foreach (XmlNode childNode in childNodes) {
                if (childNode.NodeType == XmlNodeType.Element) {
                    _insideDocumentElement = 0;
                    sb.Append(CanonicalizeNode(childNode));
                    _insideDocumentElement = 1;
                } else {
                    sb.Append(CanonicalizeNode(childNode));
                }
            }

            // since we don't know the node type we can't mark the node as fully Canonicalized
            // but that's OK because there's nothing to output
            //node.C14NState = CanonicalizationState.AlreadyCanonicalized;

            return sb;
        }

        // Canonicalize an "Other" node -- something we don't explicitly know about

        internal StringBuilder CanonicalizeOtherNode(XmlNode node) {
            if (node == null) throw new ArgumentNullException("node");

            // For other types of nodes, we never have anything to output for the node
            // directly.  All we want to do is recursively canonicalize its children.

            StringBuilder sb = new StringBuilder();

            // Recursively process the children..
            XmlNodeList childNodes = node.ChildNodes;
            foreach (XmlNode childNode in childNodes) {
                sb.Append(CanonicalizeNode(childNode));
            }

            // since we don't know the node type we can't mark the node as fully Canonicalized
            // but that's OK because there's nothing to output
            //node.C14NState = CanonicalizationState.AlreadyCanonicalized;

            return sb;
        }

        // Canonicalize an Entity Reference node

        internal StringBuilder CanonicalizeEntityReferenceNode(CanonicalXmlEntityReference node) {
            if (node == null)
                throw new ArgumentNullException("node");

            // Check to see that this node is in the canonicalization set
            // For text nodes, if it isn't ignore it.
            if (node.C14NState == CanonicalizationState.DoNotCanonicalize) {
                return new StringBuilder();
            }           

            // An entity reference has a text node which resolves it, so 
            // the behavior of CanonicalizeOtherNode is acceptable
            StringBuilder sb = CanonicalizeOtherNode(node as XmlNode);

            // mark the node as fully Canonicalized
            node.C14NState = CanonicalizationState.AlreadyCanonicalized;

            return sb;
        }

        // Canonicalize a CData section
        internal StringBuilder CanonicalizeCDataSection(CanonicalXmlCDataSection node) {
            if (node == null)
                throw new ArgumentNullException("node");

            // Check to see that this node is in the canonicalization set
            // For text nodes, if it isn't ignore it.
            if (node.C14NState == CanonicalizationState.DoNotCanonicalize) {
                return new StringBuilder();
            }           

            // Canonicalize the CData section (just like a text node)
            StringBuilder sb = new StringBuilder();
            sb.Append(node.Data);
            sb.Replace("&","&amp;");
            sb.Replace("<","&lt;");
            sb.Replace(">","&gt;");
            SBReplaceCharWithString(sb, (char) 13,"&#xD;");

            // mark the node as fully Canonicalized
            node.C14NState = CanonicalizationState.AlreadyCanonicalized;

            return sb;  
        }

        // Canonicalize a Text node

        internal StringBuilder CanonicalizeTextNode(CanonicalXmlText node) {
            if (node == null) throw new ArgumentNullException("node");

            // Check to see that this node is in the canonicalization set
            // For text nodes, if it isn't ignore it.
            if (node.C14NState == CanonicalizationState.DoNotCanonicalize) {
                return new StringBuilder();
            }           

            StringBuilder sb = new StringBuilder();
            sb.Append(node.Value);
            sb.Replace("&","&amp;");
            sb.Replace("<","&lt;");
            sb.Replace(">","&gt;");
            SBReplaceCharWithString(sb, (char) 13,"&#xD;");

            // mark the node as fully Canonicalized
            node.C14NState = CanonicalizationState.AlreadyCanonicalized;

            return sb;
        }

        // Canonicalize a PI node

        internal StringBuilder CanonicalizeProcessingInstructionNode(CanonicalXmlProcessingInstruction node) {
            if (node == null) throw new ArgumentNullException("node");

            // Check to see that this node is in the canonicalization set
            // For PI nodes, if it isn't ignore it.
            if (node.C14NState == CanonicalizationState.DoNotCanonicalize) {
                return new StringBuilder();
            }

            StringBuilder sb = new StringBuilder();

            // add a leading #xA if we're outside & after the DocumentElement
            if (_insideDocumentElement == 1) {
                sb.Append((char) 10);
            }
            sb.Append("<?");
            sb.Append(node.Name);
            if ((node.Value != null) && (!node.Value.Equals(""))) {
                sb.Append(" "+node.Value);
            }
            sb.Append("?>");
            // add a trailing #xA if we're outside & before the DocumentElement
            if (_insideDocumentElement == -1) {
                sb.Append((char) 10);
            }

            // mark the node as fully Canonicalized
            node.C14NState = CanonicalizationState.AlreadyCanonicalized;

            return sb;
        }

        // Canonicalize a Comment node

        internal StringBuilder CanonicalizeCommentNode(CanonicalXmlComment node, bool _includeComments) {
            if (node == null) throw new ArgumentNullException("node");
            if (node.NodeType != XmlNodeType.Comment) {
                throw new ArgumentException("node");
            }

            // Check to see that this node is in the canonicalization set
            // For comment nodes, if it isn't ignore it.
            if (node.C14NState == CanonicalizationState.DoNotCanonicalize) {
                return new StringBuilder();
            }
            
            
            StringBuilder sb = new StringBuilder();

            // Hack Hack: since XPath processing for comment() tests isn't working, work
            // around it here
            if (_includeComments) {
                // add a leading #xA if we're outside & after the DocumentElement
                if (_insideDocumentElement == 1) {
                    sb.Append((char) 10);
                }
                sb.Append("<!--");
                sb.Append(node.Value);
                sb.Append("-->");
                // add a trailing #xA if we're outside & before the DocumentElement
                if (_insideDocumentElement == -1) {
                    sb.Append((char) 10);
                }
            }

            // mark the node as fully Canonicalized
            node.C14NState = CanonicalizationState.AlreadyCanonicalized;

            return sb;
        }

        // Canonicalize Whitespace/SignificantWhitespace nodes

        internal StringBuilder CanonicalizeWhitespaceNode(CanonicalXmlWhitespace node) {
            if (node == null) throw new ArgumentNullException("node");
            // Check to see that this node is in the canonicalization set
            // For whitespace nodes, if it isn't ignore it.
            if (node.C14NState == CanonicalizationState.DoNotCanonicalize) {
                return new StringBuilder();
            }

            // mark the node as fully Canonicalized
            node.C14NState = CanonicalizationState.AlreadyCanonicalized;

            // Canonicalizing whitespace nodes is easy.  
            // If we're inside the DocumentElement just return the value,
            // otherwise return nothing
            if (_insideDocumentElement == 0) {
                StringBuilder sb = new StringBuilder(node.Value);
                SBReplaceCharWithString(sb, (char) 13,"&#xD;");
                return sb;
            }
            return new StringBuilder();
        }

        internal StringBuilder CanonicalizeSignificantWhitespaceNode(CanonicalXmlSignificantWhitespace node) {
            if (node == null) throw new ArgumentNullException("node");
            // Check to see that this node is in the canonicalization set
            // For whitespace nodes, if it isn't ignore it.
            if (node.C14NState == CanonicalizationState.DoNotCanonicalize) {
                return new StringBuilder();
            }

            // mark the node as fully Canonicalized
            node.C14NState = CanonicalizationState.AlreadyCanonicalized;

            // Canonicalizing whitespace nodes is easy.  
            // If we're inside the DocumentElement just return the value,
            // otherwise return nothing
            if (_insideDocumentElement == 0) {
                StringBuilder sb = new StringBuilder(node.Value);
                SBReplaceCharWithString(sb, (char) 13,"&#xD;");
                return sb;
            }
            return new StringBuilder();
        }

        // CanonicalizeNamespaceNode
        // This routine is a wrapper around CanonicalizeAttributeNode.
        // We have to filter out namepsace nodes that should be ignored per
        // Section 2.3 -- Namespace nodes processing.

        private static CanonicalXmlNodeList GetAttributesInScope (XmlElement elem) {
            if (elem == null) 
                throw new ArgumentNullException("elem");
            
            CanonicalXmlNodeList namespaces = new CanonicalXmlNodeList();
            XmlNode ancestorNode = elem.ParentNode;

            if (ancestorNode == null) return null;
            bool bDefNamespaceToAdd = !(elem.HasAttribute("xmlns"));

            while (ancestorNode != null) {
                if (ancestorNode is XmlElement && ((XmlElement)ancestorNode).HasAttributes) {
                    XmlAttributeCollection attribs = ancestorNode.Attributes;
                    foreach (XmlAttribute attrib in attribs) {
                        if (IsDuplicateAttribute(attrib)) continue;
                        // Add a default namespace if necessary
                        if (bDefNamespaceToAdd && attrib.LocalName == "xmlns") {
                            XmlAttribute nsattrib = elem.OwnerDocument.CreateAttribute("xmlns");
                            nsattrib.Value = attrib.Value;
                            namespaces.Add(nsattrib);
                            bDefNamespaceToAdd = false;
                            continue;
                        }
                        // retain the declarations of type 'xml:*' as well
                        if (attrib.Prefix == "xmlns" || attrib.Prefix == "xml") {
                            namespaces.Add(attrib);
                            continue;
                        }
                    }
                }
                ancestorNode = ancestorNode.ParentNode;
            } 

            return namespaces;
        }

        // A helper function to determine whether a namespace is duplicate or not
        private static bool IsDuplicateAttribute (XmlAttribute attribute) {
            if (attribute == null)
                throw new ArgumentNullException("attribute");

            XmlNode ancestorNode = ((XmlNode)attribute.OwnerElement).ParentNode;
            while (ancestorNode != null)
            {
                // Check first if the ancestor is in the node-set
                if (ancestorNode is XmlElement && ((CanonicalXmlElement) ancestorNode).C14NState != CanonicalizationState.DoNotCanonicalize
                        && ((XmlElement)ancestorNode).HasAttributes) {
                    XmlAttributeCollection attribs = ancestorNode.Attributes;
                    foreach (XmlAttribute attrib in attribs) {
                        // Check first to see if it's been marked for canonicalization
                        if (((CanonicalXmlAttribute)attrib).C14NState == CanonicalizationState.DoNotCanonicalize) continue;
                        // default namespace: the nearest default namespace should be different
                        if (attribute.LocalName == "xmlns") {
                            if (attrib.LocalName == "xmlns") {
                                return (attribute.Value == attrib.Value);
                            }
                        }
                        // for 'xml:*' declarations the nearest xml:* should be different
                        else if (attribute.Prefix == "xml") {
                            if (attrib.Prefix == "xml" && attrib.LocalName == attribute.LocalName) {
                                return (attribute.Value == attrib.Value);
                            }
                        }
                        // Non-default namespace attributes
                        else if (attribute.Prefix == "xmlns") {
                            if (attrib.Prefix == attribute.Prefix && attrib.LocalName == attribute.LocalName && attrib.Value == attribute.Value) {
                                return true;
                            }
                        }
                    }
                }
                ancestorNode = ancestorNode.ParentNode;
            }

            // Empty namespace is duplicate if it's not in the scope of another default attribute
            if (attribute.LocalName == "xmlns" && attribute.Value == String.Empty) 
                return true;

            return false;
        }

        internal StringBuilder CanonicalizeNamespaceNode(CanonicalXmlAttribute node) {
            // argument checking
            if (node == null) throw new ArgumentNullException("node");
            if (node.NodeType != XmlNodeType.Attribute) {
                throw new ArgumentException("node");
            }

#if _DEBUG                
            if (debug) {
                Console.WriteLine("Canonicalizing namespace node: "+node.OuterXml);
            }
#endif

            // Check to see that this node is in the canonicalization set
            // For attributes, if it isn't ignore it.
            if (node.C14NState == CanonicalizationState.DoNotCanonicalize) {
                return new StringBuilder();
            }

            // Check to see if we should ignore this node.
            if (IsDuplicateAttribute(node)) {
#if _DEBUG                
                if (debug) {
                    Console.WriteLine("Skipping namespace node b/c of ancestor: "+node.OuterXml);
                }
#endif
                return new StringBuilder();
            }

            // OK, no duplication, go canonicalize as normal
            return CanonicalizeAttributeNode(node);
        }

        // Canonicalize a specified attribute
        internal StringBuilder CanonicalizeAttributeNode(CanonicalXmlAttribute node) {
            // argument checking
            if (node == null) throw new ArgumentNullException("node");
            if (node.NodeType != XmlNodeType.Attribute) {
                throw new ArgumentException("node");
            }

#if _DEBUG                
            if (debug) {
                Console.WriteLine("Canonicalizing attribute node: "+node.OuterXml);
            }
#endif

            // Check to see that this node is in the canonicalization set
            // For attributes, if it isn't ignore it.
            if (node.C14NState == CanonicalizationState.DoNotCanonicalize) {
                return new StringBuilder();
            }

            
            // Canonicalize the node
            StringBuilder sb = new StringBuilder();

            // If it's an attribute in the xml namespace, then canonicalize it as if it were a non-default attribute
            if (!(node.Prefix.Equals("xml") && IsDuplicateAttribute(node))) {
                String qname = node.Name;
                sb.Append(node.Value);
                sb.Replace("&","&amp;");
                sb.Replace("<","&lt;");
                sb.Replace("\"","&quot;");
                SBReplaceCharWithString(sb, (char) 9, "&#x9;");
                SBReplaceCharWithString(sb, (char) 10, "&#xA;");
                SBReplaceCharWithString(sb, (char) 13, "&#xD;");
                sb.Insert(0," "+qname+"=\"");
                sb.Append("\"");
            }

            // mark the node as fully Canonicalized
            node.C14NState = CanonicalizationState.AlreadyCanonicalized;
            return sb;
        }

        // Canonicanize an Element node
        
        internal StringBuilder CanonicalizeElementNode(CanonicalXmlElement node) {
            // argument checking
            if (node == null) throw new ArgumentNullException("node");
            if (node.NodeType != XmlNodeType.Element) {
                throw new ArgumentException("node");
            }
#if _DEBUG                
            if (debug) {
                Console.WriteLine("Canonicalizing element node: "+node.OuterXml);
            }
#endif
            SortedList namespaceChildren = new SortedList(new NamespaceSortOrder());
            SortedList attributeChildren = new SortedList(new AttributeSortOrder());
            
            // It's possible that this node isn't in the node set, yet its
            // children are.  So, find out if it's included
            
            CanonicalizationState propval = node.C14NState;
            bool outputThisNode = true;
            if (propval == CanonicalizationState.DoNotCanonicalize) {
                // in this case the node isn't part of the node set, but
                // we still have to process its children
                outputThisNode = false;
            } else if (propval == CanonicalizationState.AlreadyCanonicalized) {
                // in this case the node has already been canonicalized, so return
                return new StringBuilder();
            }

            StringBuilder sb = new StringBuilder();
            if (outputThisNode) sb.Append("<"+node.Name);
            // Accumulate all the matching attributes
            XmlAttributeCollection rawAttributes = node.Attributes;
            foreach (XmlAttribute attr in rawAttributes) {
                // What we do here is determine if the attribute is a namespace attribute (by NamespaceURI & Prefix)
                // and sort into the two buckets namespaceChildren & attributeChildren.
                // Then we canonicalize each bucket in turn.
                if (attr.Prefix.Equals("xmlns") || attr.LocalName.Equals("xmlns")) {
                    namespaceChildren.Add(attr, null);
                } else {
                    attributeChildren.Add(attr, null);
                }
            }
#if _DEBUG                
            if (debug) {
                Console.WriteLine("Node: "+node.OuterXml+" has "+namespaceChildren.GetKeyList().Count+" namespace attributes");
                Console.WriteLine("Node's default namespace is "+node.GetNamespaceOfPrefix(""));
                Console.WriteLine("Node's xmlns attribute is "+node.GetAttribute("xmlns"));
            }
#endif

            foreach (Object attr in namespaceChildren.GetKeyList()) {
                sb.Append(CanonicalizeNamespaceNode(attr as CanonicalXmlAttribute).ToString());
            }
            // Canonicalize the other attributes
            foreach (Object attr in attributeChildren.GetKeyList()) {
                sb.Append(CanonicalizeAttributeNode(attr as CanonicalXmlAttribute).ToString());
            }

            // Accumulate all the matching namespaceChildren
            if (outputThisNode) sb.Append(">");

            // Recursively process the children
            XmlNodeList childNodes = node.ChildNodes;
            foreach (XmlNode childNode in childNodes) {
                sb.Append(CanonicalizeNode(childNode));
            }

            // Close this element
            if (outputThisNode) sb.Append("</"+node.Name+">");

            // mark the node as canonicalized
            node.C14NState = CanonicalizationState.AlreadyCanonicalized;
            return sb;
        }

#if _DEBUG                
        public String GetString() {
            StringBuilder canonicalSB = CanonicalizeNode(_c14ndoc);
            return canonicalSB.ToString();
        }
#endif

        public byte[] GetBytes() {
            StringBuilder canonicalSB = CanonicalizeNode(_c14ndoc);
            UTF8Encoding utf8 = new UTF8Encoding(false);
            byte[] result = utf8.GetBytes(canonicalSB.ToString());
#if _DEBUG                
            if (debug) {
                Console.WriteLine(canonicalSB.ToString());
                Console.WriteLine("returning from GetBytes: "+canonicalSB.ToString());
            }
#endif
            return result;
        }
        
        public static XmlDocument DiscardComments(XmlDocument document) {
            XmlDocument result = new XmlDocument();
            result.PreserveWhitespace = true;
            result.Load(new XmlNodeReader(document));
            XmlNodeList nodeList = result.SelectNodes("//comment()");
            if (nodeList != null) {
                foreach (XmlNode node1 in nodeList) {
                    node1.ParentNode.RemoveChild(node1);
                }
            }
            return result;
        }

        public static XmlNodeList AllDescendantNodesExceptComments(XmlNode node) {
            return AllDescendantNodes(node,false);
        }

        public static XmlNodeList AllDescendantNodes(XmlNode node, bool includeComments) {
            CanonicalXmlNodeList nodeList = new CanonicalXmlNodeList();
            CanonicalXmlNodeList elementList = new CanonicalXmlNodeList();
            CanonicalXmlNodeList attribList = new CanonicalXmlNodeList();
            CanonicalXmlNodeList namespaceList = new CanonicalXmlNodeList();

            int index = 0;
            elementList.Add(node);
                
            do {
                XmlNode rootNode = (XmlNode) elementList[index];
                // Add the children nodes
                XmlNodeList childNodes = rootNode.ChildNodes;
                if (childNodes != null) {
                    foreach (XmlNode node1 in childNodes) {
                        if (includeComments || (!(node1 is XmlComment))) {
                            elementList.Add(node1);
                        }
                    }
                }
                // Add the attribute nodes
                XmlAttributeCollection attribNodes = rootNode.Attributes;
                if (attribNodes != null) {
                    foreach (XmlNode attribNode in rootNode.Attributes) {
                        if (attribNode.LocalName == "xmlns" || attribNode.Prefix == "xmlns")
                            namespaceList.Add(attribNode);
                        else
                            attribList.Add(attribNode);
                    }
                }
                index++;
            } while (index < elementList.Count);
            foreach (XmlNode elementNode in elementList) {
                nodeList.Add(elementNode);
            }
            foreach (XmlNode attribNode in attribList) {
                nodeList.Add(attribNode);
            }
            foreach (XmlNode namespaceNode in namespaceList) {
                nodeList.Add(namespaceNode);
            }

#if _DEBUG                
            if (debug) {
                Console.WriteLine("AllDescendantNodes = "+ nodeList.Count);
            }
#endif
            return nodeList;
        }
    }

    internal class CanonicalXmlNodeList : XmlNodeList, IList {
        private ArrayList m_nodeArray;

        public CanonicalXmlNodeList() {
            m_nodeArray = new ArrayList();
        }

        public override XmlNode Item(int index) {
            return (XmlNode) m_nodeArray[index];
        }

        public override IEnumerator GetEnumerator() {
            return m_nodeArray.GetEnumerator();
        }

        public override int Count {
            get { return m_nodeArray.Count; }
        }

        // IList methods

        public int Add(Object value) {
            if (!(value is XmlNode)) {
                throw new ArgumentException("node");
            }
            return m_nodeArray.Add(value);
        }

        public void Clear() {
            m_nodeArray.Clear();
        }

        public bool Contains(Object value) {
            return m_nodeArray.Contains(value);
        }

        public int IndexOf(Object value) {
            return m_nodeArray.IndexOf(value);
        }

        public void Insert(int index, Object value) {
            if (!(value is XmlNode)) throw new ArgumentException("value");
            m_nodeArray.Insert(index,value);
        }

        public void Remove(Object value) {
            m_nodeArray.Remove(value);
        }

        public void RemoveAt(int index) {
            m_nodeArray.RemoveAt(index);
        }

        public Boolean IsFixedSize {
            get { return m_nodeArray.IsFixedSize; }
        }

        public Boolean IsReadOnly {
            get { return m_nodeArray.IsReadOnly; }
        }

        Object IList.this[int index] {
            get { return m_nodeArray[index]; }
            set { 
                if (!(value is XmlNode)) throw new ArgumentException("value");
                m_nodeArray[index] = value;
            }
        }

        public void CopyTo(Array array, int index) {
            m_nodeArray.CopyTo(array, index);
        }

        public Object SyncRoot {
            get { return m_nodeArray.SyncRoot; }
        }

        public bool IsSynchronized {
            get { return m_nodeArray.IsSynchronized; }
        }

    }

    // This class does lexicographic sorting by NamespaceURI first and then by 
    // LocalName.
    internal class AttributeSortOrder : IComparer {
        public AttributeSortOrder() {
        }

        public int Compare(Object a, Object b) {
            XmlNode nodeA = a as XmlNode;
            XmlNode nodeB = b as XmlNode;
            if ((a == null) || (b == null)) {
                throw new ArgumentException();
            }
            int namespaceCompare = String.CompareOrdinal(nodeA.NamespaceURI, nodeB.NamespaceURI);
            if (namespaceCompare != 0) return namespaceCompare;
            return String.CompareOrdinal(nodeA.LocalName, nodeB.LocalName);
        }
    }

    internal class NamespaceSortOrder : IComparer {
        public NamespaceSortOrder() {
        }

        private bool IsDefaultNamespaceNode(XmlNode node) {
            if (node == null) return false;
            if (!(node.LocalName.Equals("xmlns"))) return false;
            if (!(node.Prefix.Equals(""))) return false;
            return true;
        }

        public int Compare(Object a, Object b) {
            XmlNode nodeA = a as XmlNode;
            XmlNode nodeB = b as XmlNode;
            if ((a == null) || (b == null)) {
                throw new ArgumentException();
            }
            bool nodeAdefault = IsDefaultNamespaceNode(nodeA);
            bool nodeBdefault = IsDefaultNamespaceNode(nodeB);
            if (nodeAdefault && nodeBdefault) return 0;
            if (nodeAdefault) return -1;
            if (nodeBdefault) return 1;
            return String.CompareOrdinal(nodeA.LocalName, nodeB.LocalName);
        }
    }

    internal enum CanonicalizationState {
            DoNotCanonicalize = 0,
            ToBeCanonicalized = 1,
            AlreadyCanonicalized = 2
    }

    internal class CanonicalXmlDocument : XmlDocument {
        public override XmlElement CreateElement(String prefix, String localName, String namespaceURI) {
            return new CanonicalXmlElement(prefix, localName, namespaceURI, this);
        }

        public override XmlAttribute CreateAttribute(String prefix, String localName, String namespaceURI) {
            return new CanonicalXmlAttribute(prefix, localName, namespaceURI, this);
        }

        protected override XmlAttribute CreateDefaultAttribute(String prefix, String localName, String namespaceURI) {
            return new CanonicalXmlAttribute(prefix, localName, namespaceURI, this);
        }

        public override XmlText CreateTextNode(String prefix) {
            return new CanonicalXmlText(prefix, this);
        }

        public override XmlWhitespace CreateWhitespace(String prefix) {
            return new CanonicalXmlWhitespace(prefix, this);
        }

        public override XmlSignificantWhitespace CreateSignificantWhitespace(String prefix) {
            return new CanonicalXmlSignificantWhitespace(prefix, this);
        }

        public override XmlProcessingInstruction CreateProcessingInstruction(String target, String data) {
            return new CanonicalXmlProcessingInstruction(target, data, this);
        }

        public override XmlComment CreateComment(String data) {
            return new CanonicalXmlComment(data, this);
        }

        public override XmlEntityReference CreateEntityReference(String name) {
            return new CanonicalXmlEntityReference( name, this );
        }

        public override XmlCDataSection CreateCDataSection(String data) {
            return new CanonicalXmlCDataSection( data, this );
        }
    }

    internal class CanonicalXmlElement : XmlElement {
        private CanonicalizationState _state = CanonicalizationState.DoNotCanonicalize;

        public CanonicalXmlElement(String prefix,
                                     String localName,
                                     String namespaceURI,
                                     System.Xml.XmlDocument doc)
            : base(prefix, localName, namespaceURI, doc) {
        }

        public CanonicalizationState C14NState {
            get { return _state; }
            set { _state = value; }
        }

    }

    internal class CanonicalXmlAttribute : XmlAttribute {
        private CanonicalizationState _state = CanonicalizationState.DoNotCanonicalize;

        public CanonicalXmlAttribute(String prefix,
                                     String localName,
                                     String namespaceURI,
                                     System.Xml.XmlDocument doc)
            : base(prefix, localName, namespaceURI, doc) {
        }

        public CanonicalizationState C14NState {
            get { return _state; }
            set { _state = value; }
        }

    }

    internal class CanonicalXmlText : XmlText {
        private CanonicalizationState _state = CanonicalizationState.DoNotCanonicalize;

        public CanonicalXmlText(String value,
                                System.Xml.XmlDocument doc)
            : base(value, doc) {
        }

        public CanonicalizationState C14NState {
            get { return _state; }
            set { _state = value; }
        }

    }

    internal class CanonicalXmlWhitespace : XmlWhitespace {
        private CanonicalizationState _state = CanonicalizationState.DoNotCanonicalize;

        public CanonicalXmlWhitespace(String prefix,
                                System.Xml.XmlDocument doc)
            : base(prefix, doc) {
        }

        public CanonicalizationState C14NState {
            get { return _state; }
            set { _state = value; }
        }

    }

    internal class CanonicalXmlSignificantWhitespace : XmlSignificantWhitespace {
        private CanonicalizationState _state = CanonicalizationState.DoNotCanonicalize;

        public CanonicalXmlSignificantWhitespace(String prefix,
                                System.Xml.XmlDocument doc)
            : base(prefix, doc) {
        }

        public CanonicalizationState C14NState {
            get { return _state; }
            set { _state = value; }
        }

    }

    internal class CanonicalXmlComment : XmlComment {
        private CanonicalizationState _state = CanonicalizationState.DoNotCanonicalize;

        public CanonicalXmlComment(String prefix,
                                System.Xml.XmlDocument doc)
            : base(prefix, doc) {
        }

        public CanonicalizationState C14NState {
            get { return _state; }
            set { _state = value; }
        }

    }

    internal class CanonicalXmlProcessingInstruction : XmlProcessingInstruction {
        private CanonicalizationState _state = CanonicalizationState.DoNotCanonicalize;

        public CanonicalXmlProcessingInstruction(String prefix,
                                                 String namespaceURI,
                                                 System.Xml.XmlDocument doc)
            : base(prefix, namespaceURI, doc) {
        }

        public CanonicalizationState C14NState {
            get { return _state; }
            set { _state = value; }
        }
    }

    internal class CanonicalXmlEntityReference : XmlEntityReference {
        private CanonicalizationState _state = CanonicalizationState.DoNotCanonicalize;

        public CanonicalXmlEntityReference(String name,
                                           System.Xml.XmlDocument doc)
            : base(name, doc) {
        }

        public CanonicalizationState C14NState {
            get { return _state; }
            set { _state = value; }
        }
    }

    internal class CanonicalXmlCDataSection: XmlCDataSection {
        private CanonicalizationState _state = CanonicalizationState.DoNotCanonicalize;

        public CanonicalXmlCDataSection(String name,
                                        System.Xml.XmlDocument doc)
            : base(name, doc) {
        }

        public CanonicalizationState C14NState {
            get { return _state; }
            set { _state = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\system\security\cryptography\xml\signature.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------
//
// CLASS:    Signature.cs
//
// AUTHOR:   Christian Caron (t-ccaron)
//
// PURPOSE:  This object implements the http://www.w3.org/2000/02/xmldsig#Signature
//           element.
// 
// DATE:     21 March 2000
// 
//---------------------------------------------------------------------------

namespace System.Security.Cryptography.Xml
{
    using System;
    using System.Xml;
    using System.Collections;
    using System.Security;

    /// <include file='doc\Signature.uex' path='docs/doc[@for="Signature"]/*' />
    public class Signature
    {
        private String m_strId;
        private SignedInfo m_signedInfo;
        private byte[] m_rgbSignatureValue;
        private KeyInfo m_keyInfo;
        private IList m_embeddedObjects;
        private CanonicalXmlNodeList m_referencedItems;

        //-------------------------- Constructors ---------------------------

        /// <include file='doc\Signature.uex' path='docs/doc[@for="Signature.Signature"]/*' />
        public Signature()
        {
            m_embeddedObjects = new ArrayList();
            m_referencedItems = new CanonicalXmlNodeList();
        }

        //-------------------------- Properties -----------------------------

        /// <include file='doc\Signature.uex' path='docs/doc[@for="Signature.Id"]/*' />
        public String Id
        {
            get { return m_strId; }
            set { m_strId = value; }
        }

        /// <include file='doc\Signature.uex' path='docs/doc[@for="Signature.SignedInfo"]/*' />
        public SignedInfo SignedInfo
        {
            get { return m_signedInfo; }
            set { m_signedInfo = value; }
        }

        /// <include file='doc\Signature.uex' path='docs/doc[@for="Signature.SignatureValue"]/*' />
        public byte[] SignatureValue
        {
            get { return m_rgbSignatureValue; }
            set { m_rgbSignatureValue = value; }
        }

        /// <include file='doc\Signature.uex' path='docs/doc[@for="Signature.KeyInfo"]/*' />
        public KeyInfo KeyInfo
        {
            get { return m_keyInfo; }
            set { m_keyInfo = value; }
        }

        /// <include file='doc\Signature.uex' path='docs/doc[@for="Signature.ObjectList"]/*' />
        public IList ObjectList
        {
            get { return m_embeddedObjects; }
            set { m_embeddedObjects = value; }
        }

        internal CanonicalXmlNodeList ReferencedItems 
        {
            get { return m_referencedItems; }
            set { m_referencedItems = value; }
        }

        /// <include file='doc\Signature.uex' path='docs/doc[@for="Signature.GetXml"]/*' />
        public XmlElement GetXml() {
            XmlDocument document = new XmlDocument();

            // Create the Signature
            XmlElement signatureElement = (XmlElement)document.CreateElement("Signature",SignedXml.XmlDsigNamespaceUrl);
            //XmlElement signatureElement = (XmlElement)document.CreateElement("Signature");
                
            if (m_strId != null)
                signatureElement.SetAttribute("Id", m_strId);

                // Add the SignedInfo
            if (m_signedInfo == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignedInfoRequired"));

            signatureElement.AppendChild(document.ImportNode(m_signedInfo.GetXml(),true));

            // Add the SignatureValue
            if (m_rgbSignatureValue == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureValueRequired"));

            XmlElement signatureValueElement = document.CreateElement("SignatureValue",SignedXml.XmlDsigNamespaceUrl);
            signatureValueElement.AppendChild(document.CreateTextNode(Convert.ToBase64String(m_rgbSignatureValue)));
            signatureElement.AppendChild(signatureValueElement);

            // Add the KeyInfo
            if (m_keyInfo != null)
                signatureElement.AppendChild(document.ImportNode(m_keyInfo.GetXml(),true));
                
            // Add the Objects
            foreach (Object obj in m_embeddedObjects) {
                DataObject dataObj = obj as DataObject;
                if (dataObj != null) {
                    signatureElement.AppendChild(document.ImportNode(dataObj.GetXml(),true));
                }
            }
            return signatureElement;

        }

        /// <include file='doc\Signature.uex' path='docs/doc[@for="Signature.LoadXml"]/*' />
        public void LoadXml(XmlElement value) {
             // Make sure we don't get passed null
            if (value == null)
                throw new ArgumentNullException("value");
                
            // Signature
            XmlElement signatureElement = value;
            if (!signatureElement.LocalName.Equals("Signature"))
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Signature");

            XmlAttributeCollection signatureAttributes = signatureElement.Attributes;
            XmlNode idAttribute = signatureAttributes["Id"];
            if (idAttribute == null)
                m_strId = null;
            //throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_XML_MalformedXML"),"Signature"));

            // Look for SignedInfo and SignatureValue. There may optionally be
            // a KeyInfo and some Objects

            XmlNamespaceManager nsm = new XmlNamespaceManager(value.OwnerDocument.NameTable);
            nsm.AddNamespace("ds",SignedXml.XmlDsigNamespaceUrl);

            // SignedInfo
            //XmlNodeList signatureChilds = signatureElement.GetElementsByTagName("SignedInfo", SignedXml.XmlDsigNamespaceUrl);
            XmlNodeList signatureChilds = signatureElement.SelectNodes("ds:SignedInfo",nsm);
            if (signatureChilds.Count == 0) {
              throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"),"SignedInfo");
            }
            XmlElement signedInfoElement = (XmlElement) signatureChilds.Item(0);
            m_signedInfo = new SignedInfo();
            m_signedInfo.LoadXml(signedInfoElement);

                // SignatureValue
            XmlNodeList signatureValueNodes = signatureElement.SelectNodes("ds:SignatureValue",nsm);
            if (signatureValueNodes.Count == 0) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"),"SignedInfo/SignatureValue");
            }
            XmlElement signatureValueElement = (XmlElement) signatureValueNodes.Item(0);
            m_rgbSignatureValue = Convert.FromBase64String(SignedXml.DiscardWhiteSpaces(signatureValueElement.InnerText));

            XmlNodeList keyInfoNodes = signatureElement.SelectNodes("ds:KeyInfo",nsm);
            if (keyInfoNodes.Count != 0) {
                XmlElement keyInfoElement = (XmlElement) keyInfoNodes.Item(0);
                m_keyInfo = new KeyInfo();
                m_keyInfo.LoadXml(keyInfoElement);
            }

            XmlNodeList objectNodes = signatureElement.SelectNodes("ds:Object",nsm);
            for (int i = 0; i < objectNodes.Count; ++i) {
                XmlElement objectElement = (XmlElement) objectNodes.Item(i);
                DataObject dataObj = new DataObject();
                dataObj.LoadXml(objectElement);
                m_embeddedObjects.Add(dataObj);
            }

            // Select all elements that have Id attributes
            XmlNodeList nodeList = signatureElement.SelectNodes("//*[@Id]", nsm);
            if (nodeList != null) {
                foreach (XmlNode node in nodeList) {
                    m_referencedItems.Add(node);
                }
            }
        }

        //-------------------------- Public Methods -----------------------------

        /// <include file='doc\Signature.uex' path='docs/doc[@for="Signature.AddObject"]/*' />
        public void AddObject(DataObject dataObject)
        {
            m_embeddedObjects.Add(dataObject);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\system\security\cryptography\xml\reference.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------
//
// CLASS:    Reference.cool
//
// AUTHOR:   Christian Caron (t-ccaron)
//
// PURPOSE:  This class implements the http://www.w3.org/2000/02/xmldsig#Reference
//           element.
// 
// DATE:     21 March 2000
// 
//---------------------------------------------------------------------------

namespace System.Security.Cryptography.Xml
{
    using System;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;
    using System.Security;
    using System.Security.Cryptography;
    using System.IO;
    using System.Text;
    using System.Net;

    internal enum ReferenceTargetType {
        Stream = 1,
        XmlElement = 2,
        UriReference = 3
    }

    /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference"]/*' />
    public class Reference {
        private String m_strId;
        private String m_strUri;
        private String m_strType;
        private TransformChain m_transformChain;
        private String m_strDigestMethod;
        private byte[] m_rgbDigestValue;
        private HashAlgorithm m_hashAlgorithm;
        // We may point to either an embedded Object or an external resource
        // (represented as a Stream)
        private Object m_refTarget;
        private ReferenceTargetType m_refTargetType;
        private XmlElement m_cachedXml;
        private XmlElement m_originalNode;
        private CanonicalXmlNodeList m_namespaces = null;
        private SignedXml m_signedXml = null;

        //-------------------------- Constructors ---------------------------

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.Reference"]/*' />
        public Reference()
        {
            m_transformChain = new TransformChain();
            m_refTarget = null;
            m_refTargetType = ReferenceTargetType.UriReference;
            m_cachedXml = null;
            m_strDigestMethod = SignedXml.XmlDsigSHA1Url;
        }

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.Reference1"]/*' />
        public Reference(Stream stream)
        {
            m_transformChain = new TransformChain();
            m_refTarget = stream;
            m_refTargetType = ReferenceTargetType.Stream;
            m_cachedXml = null;
            m_strDigestMethod = SignedXml.XmlDsigSHA1Url;
        }

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.Reference2"]/*' />
        public Reference(String uri)
        {
            m_transformChain = new TransformChain();
            m_refTarget = uri;
            m_strUri = uri;
            m_refTargetType = ReferenceTargetType.UriReference;
            m_cachedXml = null;
            m_strDigestMethod = SignedXml.XmlDsigSHA1Url;
        }

        internal Reference(XmlElement element)
        {
            m_transformChain = new TransformChain();
            m_refTarget = element;
            m_refTargetType = ReferenceTargetType.XmlElement;
            m_cachedXml = null;
            m_strDigestMethod = SignedXml.XmlDsigSHA1Url;
        }

        //-------------------------- Properties -----------------------------

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.Id"]/*' />
        public String Id
        {
            get { return m_strId; }
            set { m_strId = value; }
        }

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.Uri"]/*' />
        public String Uri
        {
            get { return m_strUri; }
            set { 
                m_strUri = value;
                m_cachedXml = null;
            }
        }

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.Type"]/*' />
        public String Type
        {
            get { return m_strType; }
            set { 
                m_strType = value;
                m_cachedXml = null;
            }
        }

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.DigestMethod"]/*' />
        public String DigestMethod
        {
            get { return m_strDigestMethod; }
            set { 
                m_strDigestMethod = value;
                m_cachedXml = null;
            }
        }

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.DigestValue"]/*' />
        public byte[] DigestValue
        {
            get { return m_rgbDigestValue; }
            set { 
                m_rgbDigestValue = value;
                m_cachedXml = null;
            }
        }

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.TransformChain"]/*' />
        public TransformChain TransformChain {
            get { return m_transformChain; }
        }

        internal bool CacheValid {
            get {
                return (m_cachedXml != null);
            }
        }

        internal SignedXml SignedXml {
            get { return m_signedXml; }
            set { m_signedXml = value; }
        }

        internal CanonicalXmlNodeList Namespaces {
            get { return m_namespaces; }
            set { m_namespaces = value; }
        }

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.GetXml"]/*' />
        public XmlElement GetXml()
        {
            if (CacheValid) return(m_cachedXml);
                
            XmlDocument document = new XmlDocument();

            // Create the Reference
            XmlElement referenceElement = document.CreateElement("Reference",SignedXml.XmlDsigNamespaceUrl);

            if ((m_strId != null) && (m_strId != "")) 
                referenceElement.SetAttribute("Id", m_strId);
            
            if (m_strUri != null)
                referenceElement.SetAttribute("URI", m_strUri);

            if ((m_strType != null) && (m_strType != ""))
                referenceElement.SetAttribute("Type", m_strType);

            // Add the transforms to the Reference
            if (m_transformChain.Count != 0)
            {
                XmlElement transformsElement = document.CreateElement("Transforms",SignedXml.XmlDsigNamespaceUrl);
                foreach (Transform trans in m_transformChain) {
                    if (trans != null) {
                        // Construct the individual transform element
                        XmlElement theTransformElement = trans.GetXml();
                        if (theTransformElement != null) {
                            transformsElement.AppendChild(document.ImportNode(theTransformElement,true));
                        }
                    }
                }
                referenceElement.AppendChild(transformsElement);
            }

            // Add the DigestMethod
            if (DigestMethod == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_DigestMethodRequired"));

            // If the stream has not been yet closed, it's time to do so now
            //if (m_eStreamState != StreamState.Finalized)
            //CloseStream();

            XmlElement digestMethodElement = document.CreateElement("DigestMethod",SignedXml.XmlDsigNamespaceUrl);
            digestMethodElement.SetAttribute("Algorithm",m_strDigestMethod);
            referenceElement.AppendChild(digestMethodElement);
            
            if (DigestValue == null)
            {
                if (m_hashAlgorithm.Hash == null)
                    throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_DigestValueRequired"));
                else
                    DigestValue = m_hashAlgorithm.Hash;
            }                

            XmlElement digestValueElement = document.CreateElement("DigestValue",SignedXml.XmlDsigNamespaceUrl);
            digestValueElement.AppendChild(document.CreateTextNode(Convert.ToBase64String(m_rgbDigestValue)));
            referenceElement.AppendChild(digestValueElement);

            return referenceElement;
        }

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.LoadXml"]/*' />
        public void LoadXml(XmlElement value) {
            // Guard against nulls
            if (value == null)
                throw new ArgumentNullException("value");

            XmlNamespaceManager nsm = new XmlNamespaceManager(value.OwnerDocument.NameTable);
            nsm.AddNamespace("ds",SignedXml.XmlDsigNamespaceUrl);

            // cache the Xml
            m_cachedXml = value;
            m_originalNode = value;

            m_strId = value.GetAttribute("Id");
            m_strUri = value.GetAttribute("URI");
            m_strType = value.GetAttribute("Type");

            // Transforms
            m_transformChain = new TransformChain();

            XmlNodeList transformsNodes = value.SelectNodes("ds:Transforms", nsm);
            if (transformsNodes.Count != 0) {
                XmlElement transformsElement = (XmlElement) transformsNodes.Item(0);
                XmlNodeList transformNodes = transformsElement.SelectNodes("ds:Transform", nsm);
                if (transformNodes.Count == 0) {
                    throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"),"Transforms");
                }
                for (int i = 0; i < transformNodes.Count; ++i)
                {
                    XmlElement transformElement = (XmlElement) transformNodes.Item(i);
                    String strAlgorithm = transformElement.GetAttribute("Algorithm");
                    Transform transform = (Transform) CryptoConfig.CreateFromName(strAlgorithm);
                    if (transform == null) {
                        throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
                    }
                    // Hack! this is done to get around the lack of here() function support in XPath
                    if (transform is XmlDsigEnvelopedSignatureTransform) {
                        // Walk back to the Signature tag. Find the nearest signature ancestor
                        // Signature-->SignedInfo-->Reference-->Transforms-->Transform
                        XmlNode signatureTag = transformElement.SelectSingleNode("ancestor::ds:Signature[1]", nsm);
                        XmlNodeList signatureList = transformElement.SelectNodes("//ds:Signature", nsm);
                        if (signatureList != null) {
                            int position = 0;
                            foreach(XmlNode node in signatureList) {
                                position++;
                                if (node == signatureTag) {
                                    ((XmlDsigEnvelopedSignatureTransform)transform).SignaturePosition = position; 
                                    break;                               
                                }
                            }
                        }
                    }
                    // let the transform read the children of the transformElement for data
                    transform.LoadInnerXml(transformElement.ChildNodes);
                    AddTransform(transform);
                }
            }

            // DigestMethod
            XmlNodeList digestMethodNodes = value.SelectNodes("ds:DigestMethod", nsm);
            if (digestMethodNodes.Count == 0) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference/DigestMethod");
            }
            XmlElement digestMethodElement = (XmlElement) digestMethodNodes.Item(0);
            m_strDigestMethod = digestMethodElement.GetAttribute("Algorithm");

            // DigestValue
            XmlNodeList digestValueNodes = value.SelectNodes("ds:DigestValue", nsm);
            if (digestValueNodes.Count == 0) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "Reference/DigestValue");
            }
            XmlElement digestValueElement = (XmlElement) digestValueNodes.Item(0);
            m_rgbDigestValue = Convert.FromBase64String(SignedXml.DiscardWhiteSpaces(digestValueElement.InnerText));
        }

        //------------------------- Public Methods --------------------------

        /// <include file='doc\Reference.uex' path='docs/doc[@for="Reference.AddTransform"]/*' />
        public void AddTransform(Transform transform)
        {
            m_transformChain.Add(transform);
        }


        internal void UpdateHashValue(XmlDocument document, CanonicalXmlNodeList refList) {
            DigestValue = CalculateHashValue(document, refList);
        }

        // What we want to do is pump the input throug the TransformChain and then 
        // hash the output of the chain
        // document is the document context for resolving relative references
        internal byte[] CalculateHashValue(XmlDocument document, CanonicalXmlNodeList refList) {
            // refList is a list of elements that might be targets of references
            // Now's the time to create our hashing algorithm
            m_hashAlgorithm = (HashAlgorithm) CryptoConfig.CreateFromName(DigestMethod);
            if (m_hashAlgorithm == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CreateHashAlgorithmFailed"));

            string strBaseUri = (document == null ? null : document.BaseURI);
            // For interop w/ Petteri & IBM -- may not be required by the spec
            //if (m_transforms.Count == 0) {
            //if (DataObject != null && DataObject.Data != null) {
            //AddTransform(new W3cCanonicalization());
            //}
            //}

            // Let's go get the target.
            Stream hashInputStream;
            WebRequest theRequest = null;
            WebResponse theResponse = null;
            Stream inputStream = null;
            XmlResolver resolver = null;

            switch (m_refTargetType) {
            case ReferenceTargetType.Stream:
                // This is the easiest case.  We already have a stream, so just pump it through
                // the TransformChain
                resolver = (m_signedXml.ResolverSet ? m_signedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), strBaseUri));
                hashInputStream = m_transformChain.TransformToOctetStream((Stream) m_refTarget, resolver, strBaseUri);
                break;
            case ReferenceTargetType.UriReference:
                // Second-easiest case -- dereference the URI & pump through the TransformChain
                // handle the special cases where the URI is null (meaning whole doc)
                // or the URI is just a fragment (meaning a reference to an embedded Object)
                if (m_strUri == "") {
                    // This is the self-referential case. 
                    // The Enveloped Signature does not discard comments as per spec; those will be omitted during the transform chain process
                    // First, check that we have a document context.
                   if (document == null) 
                        throw new CryptographicException(String.Format(SecurityResources.GetResourceString("Cryptography_Xml_SelfReferenceRequiresContext"),m_strUri));

                    // Normalize the containing document
                    resolver = (m_signedXml.ResolverSet ? m_signedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), strBaseUri));
                    XmlDocument docWithNoComments = CanonicalXml.DiscardComments(SignedXml.PreProcessDocumentInput(document, resolver, strBaseUri));
                    hashInputStream = m_transformChain.TransformToOctetStream(docWithNoComments, resolver, strBaseUri);
                } else if (m_strUri[0] == '#') {
                    // If we get here, then we are constructing a Reference to an embedded DataObject
                    // referenced by an Id= attribute.  Go find the relevant object
                    String idref = m_strUri.Substring(1);
                    bool bDiscardComments = true;

                    // Deal with XPointer of types #xpointer(/) and #xpointer(id("ID")). Other XPointer support isn't handled here and is anyway optional 
                    if (idref == "xpointer(/)") {
                        // This is a self referencial case
                        if (document == null) 
                            throw new CryptographicException(String.Format(SecurityResources.GetResourceString("Cryptography_Xml_SelfReferenceRequiresContext"),m_strUri));

                        // We should not discard comments here!!!
                        resolver = (m_signedXml.ResolverSet ? m_signedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), strBaseUri));
                        hashInputStream = m_transformChain.TransformToOctetStream(SignedXml.PreProcessDocumentInput(document, resolver, strBaseUri), resolver, strBaseUri);
                        goto end;
                    } 
                    else if (idref.StartsWith("xpointer(id(")) {
                        int startId = idref.IndexOf("id(");
                        int endId = idref.IndexOf(")");
                        if (endId < 0 || endId < startId + 3) 
                            throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidReference"));
                        idref = idref.Substring(startId + 3, endId - startId - 3);
                        idref = idref.Replace("\'", "");
                        idref = idref.Replace("\"", "");
                        bDiscardComments = false;
                    }
                    
                    XmlElement elem = m_signedXml.GetIdElement(document, idref);

                    if (elem == null) {
                        // Go throw the referenced items passed in
                        if (refList != null) {
                            foreach (XmlNode node in refList) {
                                XmlElement tempElem = node as XmlElement;
                                if ((tempElem != null) && (tempElem.HasAttribute("Id")) && (tempElem.GetAttribute("Id").Equals(idref))) {
                                    elem = tempElem;
                                    break;
                                }
                            }
                        }
                    }

                    if (elem == null)
                        throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidReference"));

                    // Add the propagated attributes, clone the element first
                    XmlElement elemClone = elem.Clone() as XmlElement;
                    if (m_namespaces != null) {
                        foreach (XmlNode attrib in m_namespaces) {
                            string name = ((attrib.Prefix != String.Empty) ? attrib.Prefix + ":" + attrib.LocalName : attrib.LocalName);
                            // Skip the attribute if one with the same qualified name already exists
                            if (elemClone.HasAttribute(name) || (name.Equals("xmlns") && elemClone.NamespaceURI != String.Empty)) continue;
                            XmlAttribute nsattrib = (XmlAttribute) elemClone.OwnerDocument.CreateAttribute(name);
                            nsattrib.Value = attrib.Value;
                            elemClone.SetAttributeNode(nsattrib);       
                        }       
                    } 

                    if (bDiscardComments) {
                        // We should discard comments before going into the transform chain
                        resolver = (m_signedXml.ResolverSet ? m_signedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), strBaseUri));
                        XmlDocument docWithNoComments = CanonicalXml.DiscardComments(SignedXml.PreProcessElementInput(elemClone, resolver, strBaseUri));
                        hashInputStream = m_transformChain.TransformToOctetStream(docWithNoComments, resolver, strBaseUri);
                    } else {
                        // This is an XPointer reference, do not discard comments!!!
                        resolver = (m_signedXml.ResolverSet ? m_signedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), strBaseUri));
                        hashInputStream = m_transformChain.TransformToOctetStream(SignedXml.PreProcessElementInput(elemClone, resolver, strBaseUri), resolver, strBaseUri);
                    }
                } else {
                    theRequest = WebRequest.Create(m_strUri);
                    if (theRequest == null) goto default;
                    theResponse = theRequest.GetResponse();
                    if (theResponse == null) goto default;
                    inputStream = theResponse.GetResponseStream();
                    if (inputStream == null) goto default;
                    resolver = (m_signedXml.ResolverSet ? m_signedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), m_strUri));
                    hashInputStream = m_transformChain.TransformToOctetStream(inputStream, resolver, m_strUri);
                }
                break;
            case ReferenceTargetType.XmlElement:
                // We need to create a DocumentNavigator out of the XmlElement
                resolver = (m_signedXml.ResolverSet ? m_signedXml.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), strBaseUri));
                hashInputStream = m_transformChain.TransformToOctetStream(SignedXml.PreProcessElementInput((XmlElement) m_refTarget, resolver, strBaseUri), resolver, strBaseUri);
                break;
            default:
                throw new CryptographicException();
            }

end:            
            // Compute the new hash value
            byte[] hashval = m_hashAlgorithm.ComputeHash(hashInputStream);

            // Close the response to free resources, before returning
            if (theResponse != null)
                theResponse.Close();
            if (inputStream != null)
                inputStream.Close();

            return hashval;
        }

        //------------------------ Private Methods --------------------------

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\metadata\sdlparser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SdlParser.cool
**
** Author:  Gopal Kakivaya (GopalK)
**
** Purpose: Defines SdlParser that parses a given SUDS document
**          and generates types defined in it.
**
** Date:    April 01, 2000
** Revised: November 15, 2000 (Wsdl) pdejong
**
===========================================================*/
namespace System.Runtime.Remoting.MetadataServices
{
    using System;
    using System.Threading;
    using System.Collections;
    using System.Reflection;
    using System.Xml;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Net;
    using System.Runtime.Remoting.Channels; // This is so we can get the resource strings.
    using System.Runtime.Remoting;
    using System.Globalization;


    // This class parses SUDS documents
    internal class SdlParser
    {

        // XML document validation callback
        private void ValidationCallback(int hr, String reason)
        {
            StringBuilder sb = new StringBuilder("Validation Error:", 256);
            sb.Append(reason);
            sb.Append('(');
            sb.Append(hr);
            sb.Append(')');
            Console.WriteLine(sb);
        }

        // Main parser
        internal SdlParser(TextReader input, String outputDir, ArrayList outCodeStreamList, String locationURL, bool bWrappedProxy)
        {
            Util.Log("SdlParser.SdlParser outputDir "+outputDir+" locationURL "+locationURL+" bWrappedProxy "+bWrappedProxy);
            // Initialize member variables
            _XMLReader = null;
            _readerStreams = new ReaderStream(locationURL);
            _readerStreams.InputStream = input;
            _writerStreams = null;
            _outputDir = outputDir;
            _outCodeStreamList = outCodeStreamList;
            _bWrappedProxy = bWrappedProxy;
            if (outputDir == null)
                outputDir = ".";

            int length = outputDir.Length;
            if(length > 0)
            {
                char endChar = outputDir[length-1];
                if(endChar != '\\' && endChar != '/')
                    _outputDir = _outputDir + '\\';
            }
            //_namespaceStack = null;
            _URTNamespaces = new ArrayList();
            _blockDefault = SchemaBlockType.ALL;
        }

        // Prints an XML node
        private void PrintNode(TextWriter textWriter)
        {
            Util.Log("SdlParser.PrintNode");            
            if(textWriter == null)
                textWriter = Console.Out;
            _XMLReader.MoveToElement();
            textWriter.WriteLine("===========================");
            textWriter.WriteLine("LineNum   : " + _XMLReader.LineNumber);
            StringBuilder sb = new StringBuilder("NodeType  : ", 256);
            sb.Append((int) _XMLReader.NodeType);
            textWriter.WriteLine(sb);
            sb.Length = 0;
            sb.Append("Name      : ");
            sb.Append(_XMLReader.LocalName);
            textWriter.WriteLine(sb);
            sb.Length = 0;
            sb.Append("Namespace : ");
            sb.Append(_XMLReader.NamespaceURI);
            textWriter.WriteLine(sb);
            sb.Length = 0;
            sb.Append("Prefix    : ");
            sb.Append(_XMLReader.Prefix);
            textWriter.WriteLine(sb);
            sb.Length = 0;
            sb.Append("Hasvalue  : ");
            sb.Append(_XMLReader.HasValue);
            textWriter.WriteLine(sb);
            if(_XMLReader.HasValue)
            {
                sb.Length = 0;
                sb.Append("Value     : ");
                sb.Append(_XMLReader.Value);
                textWriter.WriteLine(sb);
            }
            sb.Length = 0;
            sb.Append("IsEmpty   : ");
            sb.Append(_XMLReader.IsEmptyElement);
            textWriter.WriteLine(sb);
            sb.Length = 0;
            sb.Append("Depth     : ");
            sb.Append(_XMLReader.Depth);
            textWriter.WriteLine(sb);
            sb.Length = 0;
            sb.Append("AttributeCount: ");
            sb.Append(_XMLReader.AttributeCount);
            textWriter.WriteLine(sb);
            while(_XMLReader.MoveToNextAttribute())
            {
                textWriter.WriteLine("      =========================");
                sb.Length = 0;
                sb.Append("      AttributeName: ");
                sb.Append(_XMLReader.LocalName);
                textWriter.WriteLine(sb);
                sb.Length = 0;
                sb.Append("      Prefix       : ");
                sb.Append(_XMLReader.Prefix);
                textWriter.WriteLine(sb);
                sb.Length = 0;
                sb.Append("      Namespace    : ");
                sb.Append(_XMLReader.NamespaceURI);
                textWriter.WriteLine(sb);
                sb.Length = 0;
                sb.Append("      Value        : ");
                sb.Append(_XMLReader.Value);
                textWriter.WriteLine(sb);
            }
            _XMLReader.MoveToElement();

            return;
        }

        // Skips past endtags and non content tags
        private bool SkipXmlElement()
        {
            Util.Log("SdlParser.SkipXmlElement");           
            //PrintNode(Console.Out);
            _XMLReader.Skip();
            XmlNodeType nodeType = _XMLReader.MoveToContent();
            while(nodeType == XmlNodeType.EndElement)
            {
                _XMLReader.Read();
                nodeType = _XMLReader.MoveToContent();
                if(nodeType == XmlNodeType.None)
                    break;
            }

            return(nodeType != XmlNodeType.None);
        }

        // Reads past endtags and non content tags
        private bool ReadNextXmlElement()
        {
            Util.Log("SdlParser.ReadNextXmlElement");                       
            _XMLReader.Read();
            XmlNodeType nodeType = _XMLReader.MoveToContent();
            while(nodeType == XmlNodeType.EndElement)
            {
                _XMLReader.Read();
                nodeType = _XMLReader.MoveToContent();
                if(nodeType == XmlNodeType.None)
                    break;
            }

            //PrintNode(Console.Out);
            return(nodeType != XmlNodeType.None);
        }

        // Parses complex types
        private URTComplexType ParseComplexType(URTNamespace parsingNamespace, String typeName)
        {
            Util.Log("SdlParser.ParseComplexType NS "+parsingNamespace+" typeName "+typeName);                                  
            // Lookup the name of the type and the base type from which it derives
            if(typeName == null)
                typeName = LookupAttribute(s_nameString, null, true);
            URTComplexType parsingComplexType = parsingNamespace.LookupComplexType(typeName);
            if(parsingComplexType == null)
            {
                parsingComplexType = new URTComplexType(typeName, parsingNamespace.Namespace,
                    parsingNamespace.EncodedNS, _blockDefault,
                    false, typeName != null);
                parsingNamespace.AddComplexType(parsingComplexType);
            }
            String baseType = LookupAttribute(s_baseString, null, false);
            if(!MatchingStrings(baseType, s_emptyString))
            {
                String baseNS = ParseQName(ref baseType);
                //if the type exists can this occur twice.
                parsingComplexType.Extends(baseType, baseNS);
            }

            if(parsingComplexType.Fields.Count > 0)
            {
                SkipXmlElement();
            }
            else
            {
                int curDepth = _XMLReader.Depth;
                ReadNextXmlElement();

                int fieldNum = 0;
                String elementName;
                while(_XMLReader.Depth > curDepth)
                {
                    elementName = _XMLReader.LocalName;
                    if(MatchingStrings(elementName, s_elementString))
                    {
                        ParseElementField(parsingNamespace, parsingComplexType, fieldNum);
                        ++fieldNum;
                        continue;
                    }
                    else if(MatchingStrings(elementName, s_attributeString))
                    {
                        ParseAttributeField(parsingNamespace, parsingComplexType);
                        continue;
                    }
                    else if(MatchingStrings(elementName, s_allString))
                    {
                        parsingComplexType.BlockType = SchemaBlockType.ALL;
                    }
                    else if(MatchingStrings(elementName, s_sequenceString))
                    {
                        parsingComplexType.BlockType = SchemaBlockType.SEQUENCE;
                    }
                    else if(MatchingStrings(elementName, s_choiceString))
                    {
                        parsingComplexType.BlockType = SchemaBlockType.CHOICE;
                    }
                    else
                    {
                        // Ignore others elements such as annotations
                        // Future: Be strict about what is getting ignored
                        SkipXmlElement();
                        continue;
                    }

                    // Read next element
                    ReadNextXmlElement();
                }
            }

            return(parsingComplexType);
        }

        // Parses simple types
        private URTSimpleType ParseSimpleType(URTNamespace parsingNamespace, String typeName)
        {
            Util.Log("SdlParser.ParseSimpleType NS "+parsingNamespace+" typeName "+typeName);                                               
            // Lookup the name of the type and the base type from which it derives
            if(typeName == null)
                typeName = LookupAttribute(s_nameString, null, true);
            URTSimpleType parsingSimpleType = parsingNamespace.LookupSimpleType(typeName);
            if(parsingSimpleType == null)
            {
                parsingSimpleType = new URTSimpleType(typeName, parsingNamespace.Namespace,
                                                      parsingNamespace.EncodedNS, typeName != null);
                String baseType = LookupAttribute(s_baseString, null, false);
                if(!MatchingStrings(baseType, s_emptyString))
                {
                    String baseNS = ParseQName(ref baseType);
                    parsingSimpleType.Extends(baseType, baseNS);
                }
                parsingNamespace.AddSimpleType(parsingSimpleType);

                int curDepth = _XMLReader.Depth;
                ReadNextXmlElement();

                int enumFacetNum = 0;
                string elementName;
                while(_XMLReader.Depth > curDepth)
                {
                    elementName = _XMLReader.LocalName;

                    // The only facet we currently support is enumeration
                    if(MatchingStrings(elementName, s_enumerationString))
                    {
                        ParseEnumeration(parsingSimpleType, enumFacetNum);
                        ++enumFacetNum;
                    }
                    else if(MatchingStrings(elementName, s_encodingString))
                    {
                        ParseEncoding(parsingSimpleType);
                    }
                    else
                    {
                        // Future: Ignore others facets
                        SkipXmlElement();
                    }
                }
            }
            else
            {
                SkipXmlElement();
            }

            return(parsingSimpleType);
        }

        // Parses encoding
        private void ParseEncoding(URTSimpleType parsingSimpleType)
        {
            Util.Log("SdlParser.ParseEncoding URTSimpleType "+parsingSimpleType);                                               
            if(_XMLReader.IsEmptyElement == true)
            {
                // Get the encoding value
                String valueString = LookupAttribute(s_valueString, null, true);
                parsingSimpleType.Encoding = valueString;
            }
            else
            {
                throw new SUDSParserException(
                    CoreChannel.GetResourceString("Remoting_Suds_EncodingMustBeEmpty"));
            }

            ReadNextXmlElement();
            return;
        }

       // Parses enumeration
        private void ParseEnumeration(URTSimpleType parsingSimpleType, int enumFacetNum)
        {
            Util.Log("SdlParser.ParseEnumeration facitNum "+enumFacetNum);
            if(_XMLReader.IsEmptyElement == true)
            {
                // Get the enum value
                String valueString = LookupAttribute(s_valueString, null, true);

                // Future: Explore way to obtain the integer value the enum value
                parsingSimpleType.IsEnum = true;
                parsingSimpleType.AddFacet(new EnumFacet(valueString, enumFacetNum));
            }
            else
            {
                throw new SUDSParserException(
                    CoreChannel.GetResourceString("Remoting_Suds_EnumMustBeEmpty"));
            }

            ReadNextXmlElement();
            return;
        }


        // Parses element fields
        private void ParseElementField(URTNamespace parsingNamespace,
                                       URTComplexType parsingComplexType,
                                       int fieldNum)
        {
            Util.Log("SdlParser.ParseElementField NS "+parsingNamespace+" fieldNum "+fieldNum);         
            // Determine the field name
            String fieldTypeName, fieldTypeXmlNS;
            String fieldName = LookupAttribute(s_nameString, null, true);

            // Look for array bounds
            String minOccurs = LookupAttribute(s_minOccursString, null, false);
            String maxOccurs = LookupAttribute(s_maxOccursString, null, false);

            // Check if the field is optional
            bool bOptional = false;
            if(MatchingStrings(minOccurs, s_zeroString))
                bOptional = true;

            // Check if the field is an inline array
            bool bArray = false;
            String arraySize = null;
            if(!MatchingStrings(maxOccurs, s_emptyString) &&
               !MatchingStrings(maxOccurs, s_oneString))
            {
                if(MatchingStrings(maxOccurs, s_unboundedString))
                    arraySize = String.Empty;
                else
                    arraySize = maxOccurs;
                bArray = true;
            }

            // Handle anonymous types
            bool bEmbedded, bPrimitive;
            if(_XMLReader.IsEmptyElement == true)
            {
                // Non-anonymous type case
                fieldTypeName = LookupAttribute(s_typeString, null, false);

                // Handle the absense of type attribute (Object case)
                ResolveTypeAttribute(ref fieldTypeName, out fieldTypeXmlNS,
                                     out bEmbedded, out bPrimitive);

                // Read next element
                ReadNextXmlElement();
            }
            else
            {
                // Anonymous type case
                fieldTypeXmlNS = parsingNamespace.Namespace;
                fieldTypeName = parsingNamespace.GetNextAnonymousName();
                bPrimitive = false;
                bEmbedded = true;
                int curDepth = _XMLReader.Depth;
                ReadNextXmlElement();

                // Parse the type
                String elementName;
                while(_XMLReader.Depth > curDepth)
                {
                    elementName = _XMLReader.LocalName;
                    if(MatchingStrings(elementName, s_complexTypeString))
                    {
                        URTComplexType complexType = ParseComplexType(parsingNamespace, fieldTypeName);
                        if(complexType.IsEmittableFieldType)
                        {
                            fieldTypeXmlNS = complexType.FieldNamespace;
                            fieldTypeName = complexType.FieldName;
                            bPrimitive = complexType.PrimitiveField;
                            parsingNamespace.RemoveComplexType(complexType);
                        }
                    }
                    else if(MatchingStrings(elementName, s_simpleTypeString))
                    {
                        URTSimpleType simpleType = ParseSimpleType(parsingNamespace, fieldTypeName);
                        if(simpleType.IsEmittableFieldType)
                        {
                            fieldTypeXmlNS = simpleType.FieldNamespace;
                            fieldTypeName = simpleType.FieldName;
                            bPrimitive = simpleType.PrimitiveField;
                            parsingNamespace.RemoveSimpleType(simpleType);
                        }
                    }
                    else
                    {
                        // Ignore others elements such as annotations
                        // Future: Be strict about what is getting ignored
                        SkipXmlElement();
                    }
                }
            }

            // Add field to the type being parsed
            parsingComplexType.AddField(new URTField(fieldName, fieldTypeName, fieldTypeXmlNS,
                                                     this, bPrimitive, bEmbedded, false,
                                                     bOptional, bArray, arraySize));
            return;
        }

        // Parses attribute fields
        private void ParseAttributeField(URTNamespace parsingNamespace,
                                         URTComplexType parsingComplexType)
        {
            Util.Log("SdlParser.ParseAttributeField NS "+parsingNamespace);
            // Lookup field name
            String attrTypeName, attrTypeNS;
            String attrName = LookupAttribute(s_nameString, null, true);

            // Check if the field is optional
            bool bOptional = false;
            String minOccurs = LookupAttribute(s_minOccursString, null, false);
            if(MatchingStrings(minOccurs, s_zeroString))
                bOptional = true;

            // Handle anonymous types
            bool bEmbedded, bPrimitive;
            if(_XMLReader.IsEmptyElement == true)
            {
                // Non-anonymous type case and type has to present
                attrTypeName = LookupAttribute(s_typeString, null, true);
                ResolveTypeAttribute(ref attrTypeName, out attrTypeNS,
                                     out bEmbedded, out bPrimitive);

                // Read next element
                ReadNextXmlElement();

                // Check for xsd:ID type
                if(MatchingStrings(attrTypeName, s_idString) &&
                   MatchingStrings(attrTypeNS, s_schemaNamespaceString))
                {
                    parsingComplexType.IsStruct = false;
                    return;
                }
            }
            else
            {
                // Anonymous type case
                attrTypeNS = parsingNamespace.Namespace;
                attrTypeName = parsingNamespace.GetNextAnonymousName();
                bPrimitive = false;
                bEmbedded = true;
                int curDepth = _XMLReader.Depth;
                ReadNextXmlElement();

                // Parse the type
                String elementName;
                while(_XMLReader.Depth > curDepth)
                {
                    elementName = _XMLReader.LocalName;
                    if(MatchingStrings(elementName, s_simpleTypeString))
                    {
                        URTSimpleType simpleType = ParseSimpleType(parsingNamespace, attrTypeName);
                        if(simpleType.IsEmittableFieldType)
                        {
                            attrTypeNS = simpleType.FieldNamespace;
                            attrTypeName = simpleType.FieldName;
                            bPrimitive = simpleType.PrimitiveField;
                            parsingNamespace.RemoveSimpleType(simpleType);
                        }
                    }
                    else
                    {
                        // Ignore others elements such as annotations
                        // Future: Be strict about what is getting ignored
                        SkipXmlElement();
                    }
                }
            }

            // Add field to the type being parsed
            parsingComplexType.AddField(new URTField(attrName, attrTypeName, attrTypeNS,
                                                     this, bPrimitive, bEmbedded, true,
                                                     bOptional, false, null));
            return;
        }

        // Parses a class
        private void ParseClass(URTNamespace parsingNamespace)
        {
            Util.Log("SdlParser.ParseClass");
            String className = LookupAttribute(s_nameString, null, false);
            bool bUnique = false;
            if((className == s_emptyString) && (_parsingInput.UniqueType == null))
            {
                className = _parsingInput.Name;
                bUnique = true;
            }
            URTComplexType parsingComplexType = parsingNamespace.LookupComplexType(className);
            if(parsingComplexType == null)
            {
                parsingComplexType = new URTComplexType(className, parsingNamespace.Namespace,
                                                        parsingNamespace.EncodedNS, _blockDefault,
                                                        true, false);
                if(_bWrappedProxy)
                {
                    parsingComplexType.SUDSType = SUDSType.ClientProxy;

                    if (_parsingInput.Location.Length > 0)
                    {
                        if (parsingComplexType.ConnectURLs == null)
                            parsingComplexType.ConnectURLs = new ArrayList(10);
                        parsingComplexType.ConnectURLs.Add(_parsingInput.Location);
                    }
                }
                
                parsingNamespace.AddComplexType(parsingComplexType);
            }
            if(bUnique)
            {
                _parsingInput.UniqueType = parsingComplexType;
            }
            if(parsingComplexType.Methods.Count > 0)
            {
                SkipXmlElement();
            }
            else
            {
                parsingComplexType.IsSUDSType = true;
                int curDepth = _XMLReader.Depth;
                ReadNextXmlElement();
                while(_XMLReader.Depth > curDepth)
                {
                    if(MatchingNamespace(s_sudsNamespaceString))
                    {
                        String elmName = _XMLReader.LocalName;
                        if(MatchingStrings(elmName, s_extendsString))
                        {
                            String nameValue = LookupAttribute(s_nameString, null, true);
                            String nameValueNS = ParseQName(ref nameValue);
                            parsingComplexType.Extends(nameValue, nameValueNS);

                            //Set up extend class so that it is marked as the corrent SUDSType
                            URTNamespace extendsNamespace = LookupNamespace(nameValueNS);                   
                            if (extendsNamespace == null)
                                extendsNamespace = new URTNamespace(nameValueNS, this);                     

                            URTComplexType extendsComplexType = extendsNamespace.LookupComplexType(nameValue);                  
                            if(extendsComplexType == null)
                            {
                                extendsComplexType = new URTComplexType(nameValue, extendsNamespace.Namespace, extendsNamespace.EncodedNS, _blockDefault ,true, false);
                                extendsNamespace.AddComplexType(extendsComplexType);
                            }
                            else
                                extendsComplexType.IsSUDSType = true;

                            if (_bWrappedProxy)
                                extendsComplexType.SUDSType = SUDSType.ClientProxy;
                            else
                                extendsComplexType.SUDSType = SUDSType.MarshalByRef;

                            // Only top of inheritance hierarchy is marked
                            //parsingComplexType.SUDSType = SUDSType.None;  

                        }
                        else if(MatchingStrings(elmName, s_implementsString))
                        {
                            String nameValue = LookupAttribute(s_nameString, null, true);
                            String nameValueNS = ParseQName(ref nameValue);
                            parsingComplexType.Implements(nameValue, nameValueNS, this);
                        }
                        else if(MatchingStrings(elmName, s_addressesString))
                        {
                            ParseAddresses(parsingComplexType);
                            continue;
                        }
                        else if(MatchingStrings(elmName, s_requestResponseString))
                        {
                            ParseRRMethod(parsingComplexType, null);
                            continue;
                        }
                        else if(MatchingStrings(elmName, s_onewayString))
                        {
                            ParseOnewayMethod(parsingComplexType, null);
                            continue;
                        }
                        else
                            goto SkipXMLNode;
                    }
                    else
                        goto SkipXMLNode;

                    // Read next element
                    ReadNextXmlElement();
                    continue;

        SkipXMLNode:
                    // Ignore others elements such as annotations
                    // Future: Be strict about what is getting ignored
                    SkipXmlElement();
                }
            }

            return;
        }


        // Parses an interface
        private void ParseInterface(URTNamespace parsingNamespace)
        {
            Util.Log("SdlParser.ParseInterface");           
            String intfName = LookupAttribute(s_nameString, null, true);
            URTInterface parsingInterface = parsingNamespace.LookupInterface(intfName);

            if (parsingInterface == null)
            {
                parsingInterface = new URTInterface(intfName, parsingNamespace.Namespace, parsingNamespace.EncodedNS);              
                parsingNamespace.AddInterface(parsingInterface);                
            }

            int curDepth = _XMLReader.Depth;
            ReadNextXmlElement();
            while(_XMLReader.Depth > curDepth)
            {
                if(MatchingNamespace(s_sudsNamespaceString))
                {
                    String elmName = _XMLReader.LocalName;
                    if(MatchingStrings(elmName, s_extendsString))
                    {
                        String nameValue = LookupAttribute(s_nameString, null, true);
                        String nameValueNS = ParseQName(ref nameValue);
                        parsingInterface.Extends(nameValue, nameValueNS, this);
                        ReadNextXmlElement();
                        continue;
                    }
                    else if(MatchingStrings(elmName, s_requestResponseString))
                    {
                        ParseRRMethod(null, parsingInterface);
                        continue;
                    }
                    else if(MatchingStrings(elmName, s_onewayString))
                    {
                        ParseOnewayMethod(null, parsingInterface);
                        continue;
                    }
                }

                // Ignore others elements such as annotations
                // Future: Be strict about what is getting ignored
                SkipXmlElement();
            }

            return;
        }

        // Parses an address
        private void ParseAddresses(URTComplexType parsingComplexType)
        {
            Util.Log("SdlParser.ParseAddress");         
            int curDepth = _XMLReader.Depth;
            ReadNextXmlElement();
            while(_XMLReader.Depth > curDepth)
            {
                if(MatchingNamespace(s_sudsNamespaceString))
                {
                    String elmName = _XMLReader.LocalName;
                    if(MatchingStrings(elmName, s_addressString))
                    {
                        String uriValue = LookupAttribute(s_uriString, null, true);
                        if(_bWrappedProxy)
                        {
                            parsingComplexType.SUDSType = SUDSType.ClientProxy;
                            if (parsingComplexType.ConnectURLs == null)
                                parsingComplexType.ConnectURLs = new ArrayList(10);
                            parsingComplexType.ConnectURLs.Add(uriValue);
                        }
                        ReadNextXmlElement();
                        continue;
                    }
                }

                // Ignore others elements such as annotations
                // Future: Be strict about what is getting ignored
                SkipXmlElement();
            }

            return;
        }

        // Parses a request-response method
        private void ParseRRMethod(URTComplexType parsingComplexType, URTInterface parsingInterface)
        {
            Util.Log("SdlParser.ParseRRMethod ns "+_XMLReader.NamespaceURI);            
            String methodName = LookupAttribute(s_nameString, null, true);
            String soapAction = null;
            RRMethod parsingMethod = new RRMethod(methodName, soapAction);
            int curDepth = _XMLReader.Depth;
            ReadNextXmlElement();
            while(_XMLReader.Depth > curDepth)
            {
                String elmName = _XMLReader.LocalName;              
                if ((MatchingNamespace(s_soapNamespaceString)) && (MatchingStrings(elmName, s_operationString)))
                {
                    soapAction = LookupAttribute(s_soapActionString, null, false);
                    parsingMethod.SoapAction = soapAction;
                }
                else if (MatchingNamespace(s_sudsNamespaceString))
                {
                    if(MatchingStrings(elmName, s_requestString))
                    {
                        String refValue = LookupAttribute(s_refString, null, true);
                        String refNS = ParseQName(ref refValue);
                        parsingMethod.AddRequest(refValue, refNS);
                        ReadNextXmlElement();
                        continue;
                    }
                    else if(MatchingStrings(elmName, s_responseString))
                    {
                        String refValue = LookupAttribute(s_refString, null, true);
                        String refNS = ParseQName(ref refValue);
                        parsingMethod.AddResponse(refValue, refNS);
                        ReadNextXmlElement();
                        continue;
                    }
                }

                // Ignore others elements such as annotations
                // Future: Be strict about what is getting ignored
                SkipXmlElement();
            }
            if(parsingComplexType != null)
                parsingComplexType.AddMethod(parsingMethod);
            else
                parsingInterface.AddMethod(parsingMethod);

            return;
        }

        // Parses a oneway method
        private void ParseOnewayMethod(URTComplexType parsingComplexType, URTInterface parsingInterface)
        {
            Util.Log("SdlParser.ParseOnewayMethod");            
            String methodName = LookupAttribute(s_nameString, null, true);
            String soapAction = LookupAttribute(s_soapActionString, null, false);
            OnewayMethod parsingMethod = new OnewayMethod(methodName, soapAction);
            int curDepth = _XMLReader.Depth;
            ReadNextXmlElement();
            while(_XMLReader.Depth > curDepth)
            {
                if (MatchingNamespace(s_sudsNamespaceString))
                {
                    String elmName = _XMLReader.LocalName;
                    if(MatchingStrings(elmName, s_requestString))
                    {
                        String refValue = LookupAttribute(s_refString, null, true);
                        String refNS = ParseQName(ref refValue);
                        parsingMethod.AddMessage(refValue, refNS);
                        ReadNextXmlElement();
                        continue;
                    }
                }

                // Ignore others elements such as annotations
                // Future: Be strict about what is getting ignored
                SkipXmlElement();
            }
            if(parsingComplexType != null)
                parsingComplexType.AddMethod(parsingMethod);
            else
                parsingInterface.AddMethod(parsingMethod);

            return;
        }

        // Parses a global element declaration
        private void ParseElementDecl(URTNamespace parsingNamespace)
        {
            Util.Log("SdlParser.ParseElementDecl");         
            // Obtain element name and its type
            String elmName = LookupAttribute(s_nameString, null, true);
            String elmNS = parsingNamespace.Name;
            String typeName = LookupAttribute(s_typeString, null, false);

            // Handle the anonymous types
            String typeNS;
            bool bEmbedded, bPrimitive;
            if(_XMLReader.IsEmptyElement == true)
            {
                // Non-anonymous type case
                // We cannot assert that the type attribute must have been present
                // due to the Object/ur-type case
                ResolveTypeAttribute(ref typeName, out typeNS, out bEmbedded, out bPrimitive);

                // Position to the next element
                ReadNextXmlElement();
            }
            else
            {
                // Anonymous type case
                typeNS = parsingNamespace.Name;
                typeName = parsingNamespace.GetNextAnonymousName();
                bEmbedded = true;
                bPrimitive = false;

                // Parse the type
                int curDepth = _XMLReader.Depth;
                ReadNextXmlElement();
                String elementName;
                while(_XMLReader.Depth > curDepth)
                {
                    elementName = _XMLReader.LocalName;
                    if(MatchingStrings(elementName, s_complexTypeString))
                    {
                        ParseComplexType(parsingNamespace, typeName);
                    }
                    else if(MatchingStrings(elementName, s_simpleTypeString))
                    {
                        ParseSimpleType(parsingNamespace, typeName);
                    }
                    else
                    {
                        // Ignore others elements such as annotations
                        // Future: Be strict about what is getting ignored
                        SkipXmlElement();
                    }
                }
            }

            // Create a new global element under the current namespace
            parsingNamespace.AddElementDecl(new ElementDecl(elmName, elmNS, typeName, typeNS,
                                                            bPrimitive));

            return;
        }

        // Checks for reference and array types and resolves to
        // actual types. It returns true if the type needs [Embedded] attribute
        private void ResolveTypeNames(ref String typeNS, ref String typeName,
                                      out bool bEmbedded, out bool bPrimitive)
        {
            Util.Log("SdlParser.ResolveTypeNames typeNS "+typeNS+" typeName "+typeName);            
            // Check for reference and array types
            bEmbedded = true;
            bool bArrayType = false;
            if (MatchingStrings(typeNS, s_soapNamespaceString))
            {
                if(MatchingStrings(typeName, s_referenceString))
                    bEmbedded = false;
                else if(MatchingStrings(typeName, s_arrayString))
                    bArrayType = true;
            }

            Util.Log("SdlParser.ResolveTypeNames typeNS 1 bEmbedded "+bEmbedded+" bArrayType "+bArrayType);
            // Resolve to the actual type in the case of reference and array types
            if((bEmbedded == false) || (bArrayType == true))
            {
                Util.Log("SdlParser.ResolveTypeNames typeNS 2 ");
                typeName = LookupAttribute(s_refTypeString, s_sudsNamespaceString, true);
                Util.Log("SdlParser.ResolveTypeNames typeNS 3  typeName "+typeName);                                                        
                typeNS = ParseQName(ref typeName);
            }

            // Primitive types do not need the [Embedded] attribute;
            bPrimitive = IsPrimitiveType(typeNS, typeName);
            if(bPrimitive)
            {
                typeName = MapSchemaTypesToCSharpTypes(typeName);
                bEmbedded = false;
            }
            else if(MatchingStrings(typeName, s_urTypeString) &&
                    MatchingStrings(typeNS, s_schemaNamespaceString))
            {
                typeName = s_objectString;
            }

            return;
        }

        // Parses namespace declaration elements
        private URTNamespace ParseNamespace()
        {
            Util.Log("SdlParser.ParseNamespace");           
            // Determine the new namespace encountered
            String name = (String) LookupAttribute(s_targetNamespaceString, null, false);
            bool bUnique = false;
            if(MatchingStrings(name, s_emptyString) &&
               MatchingStrings(_XMLReader.LocalName, s_sudsString) &&
               _parsingInput.UniqueNS == null)
            {
                name = _parsingInput.TargetNS;
                bUnique = true;
            }

            // Add the namespace being parsed to the list if neccessary
            URTNamespace parsingNamespace = LookupNamespace(name);
            if(parsingNamespace == null)
            {
                parsingNamespace = new URTNamespace(name, this);
                _URTNamespaces.Add(parsingNamespace);
            }
            if(bUnique)
                _parsingInput.UniqueNS = parsingNamespace;
            //_namespaceStack = NamespaceStack.Push(_namespaceStack, _parsingNamespace, _XMLReader.Depth);

            // Parse schema defaults
            //if(MatchingStrings(_XMLReader.LocalName, s_sudsString))
            //{

            //}

            // Read the next record
            ReadNextXmlElement();

            return(parsingNamespace);
        }

       private void ParseReaderStreamLocation(ReaderStream reader)
        {
            Util.Log("SdlParser.ParseReaderStreamLocation");            
            String location = reader.Location;
            int index = location.IndexOf(':');
            if(index != -1)
            {
                String protocol = location.Substring(0, index).ToLower(CultureInfo.InvariantCulture);
                String value = location.Substring(index+1);
                if(protocol == "file")
                {
                    //Console.WriteLine("Loading file:" + value);
                    reader.InputStream = new StreamReader(value);
                }
                else if(protocol.StartsWith("http"))
                {
                    //Console.WriteLine("Loading " + protocol + ':' + value);
                    /*
                    // Replace "itgproxy" with the name http proxy server
                    String defaultProxyName = "itgproxy";
                    int defaultProxyPort = 80;

                    // Setup proxy settings
                    DefaultControlObject proxyObject = new DefaultControlObject();
                    proxyObject.ProxyNoLocal = true;
                    GlobalProxySelection.Select = proxyObject;
                    */
                    WebRequest request = WebRequest.Create(location);
                    WebResponse response = request.GetResponse();
                    Stream responseStream = response.GetResponseStream();
                    reader.InputStream = new StreamReader(responseStream);
                }
            }

            return;
        }

        private void ParseImport()
        {
            Util.Log("SdlParser.ParseImport");          
            String ns = LookupAttribute(s_namespaceString, null, true);
            String location = LookupAttribute(s_locationString, null, true);
            ReaderStream reader = ReaderStream.GetReaderStream(_readerStreams, location);
            if(reader.InputStream == null)
                ParseReaderStreamLocation(reader);
            ReadNextXmlElement();
            return;
        }

        internal void Parse()
        {
            Util.Log("SdlParser.Parse");                        
            XmlNameTable primedNametable = CreatePrimedNametable();
            ReaderStream input = _readerStreams;
            do
            {
                // Initialize the parser
                _XMLReader = new XmlTextReader(input.InputStream, primedNametable);
                // | XmlReader.NamespaceAttributes;
                //_XMLReader.Flags &= ~(XmlReader.IgnoreCharacterEntities | XmlReader.TokenView);
                //_XMLReader.EntityHandling |= EntityHandling.ExpandEntities;  set temp for Xml change, needs to be set in XmlTextReader
                _XMLReader.WhitespaceHandling = WhitespaceHandling.None;
                //_XMLReader.ValidationCallback = new ValidationDelegate(ValidationCallback);
                ParseInput(input);
                input = ReaderStream.GetNextReaderStream(input);
            } while(input != null);


            if (null != _writerStreams)
            {
                WriterStream.Close(_writerStreams);
            }

            return;
        }

        // Starts the parser
        private void ParseInput(ReaderStream input)
        {
            Util.Log("SdlParser.ParseInput");                                   
            _parsingInput = input;
            try
            {
                ReadNextXmlElement();
                String elementName = _XMLReader.LocalName;
                if(MatchingNamespace(s_serviceNamespaceString) &&
                   MatchingStrings(elementName, s_serviceDescString))
                {
                    ParseSdl();
                }
                else
                    throw new SUDSParserException(CoreChannel.GetResourceString("Remoting_Suds_UnknownElementAtRootLevel"));
            }
            finally
            {
                WriterStream.Flush(_writerStreams);
            }
        }

        // Parse Sdl
        private void ParseSdl()
        {
            Util.Log("SdlParser.ParseSdl");
            _parsingInput.Name = LookupAttribute(s_nameString, null, false);
            _parsingInput.TargetNS = LookupAttribute(s_targetNamespaceString, null, false);

            int curDepth = _XMLReader.Depth;
            ReadNextXmlElement();
            while(_XMLReader.Depth > curDepth)
            {
                String elementName = _XMLReader.LocalName;
                if(MatchingNamespace(s_schemaNamespaceString))
                {
                    if(MatchingStrings(elementName, s_schemaString))
                    {
                        ParseSchema();
                        continue;
                    }
                }
                else if(MatchingNamespace(s_sudsNamespaceString))
                {
                    if(MatchingStrings(elementName, s_sudsString))
                    {
                        ParseSUDS();
                        continue;
                    }
                }

                // Ignore others elements such as annotations
                SkipXmlElement();
            }

            Resolve();
            Util.Log("SdlParser.ParseSdl Invoke PrintCSC");         
            PrintCSC();
        }

        // Parse Schema
        private void ParseSchema()
        {
            Util.Log("SdlParser.ParseSchema");                                  
            // Remember the current depth
            int curDepth = _XMLReader.Depth;

            // Parse the target namespace first
            URTNamespace parsingNamespace = ParseNamespace();

            // Parse schema elements
            while(_XMLReader.Depth > curDepth)
            {
                String elementName = _XMLReader.LocalName;
                if(MatchingNamespace(s_schemaNamespaceString))
                {
                    if(MatchingStrings(elementName, s_complexTypeString))
                        ParseComplexType(parsingNamespace, null);
                    else if(MatchingStrings(elementName, s_simpleTypeString))
                        ParseSimpleType(parsingNamespace, null);
                    else if(MatchingStrings(elementName, s_schemaString))
                        ParseSchema();
                    else if(MatchingStrings(elementName, s_elementString))
                        ParseElementDecl(parsingNamespace);
                    else if(MatchingStrings(elementName, s_importString))
                        ParseImport();
                    else
                        goto SkipXMLNode;

                    continue;
                }

            SkipXMLNode:
                // Ignore others elements such as annotations
                SkipXmlElement();
            }

            return;
        }

        // Parse SUDS
        private void ParseSUDS()
        {
            Util.Log("SdlParser.ParseSUDS");                                    
            // Remember the current depth
            int curDepth = _XMLReader.Depth;

            // Parse the target namespace first
            URTNamespace parsingNamespace = ParseNamespace();

            // Parse schema elements
            while(_XMLReader.Depth > curDepth)
            {
                String elementName = _XMLReader.LocalName;
                if(MatchingNamespace(s_sudsNamespaceString))
                {
                    if(MatchingStrings(elementName, s_interfaceString))
                        ParseInterface(parsingNamespace);
                    else if(MatchingStrings(elementName, s_serviceString))
                        ParseClass(parsingNamespace);
                    else if(MatchingStrings(elementName, s_importString))
                        ParseImport();
                    else
                        goto SkipXMLNode;

                    continue;
                }
                else if(MatchingNamespace(s_schemaNamespaceString) &&
                        MatchingStrings(elementName, s_schemaString))
                {
                    ParseSchema();
                    continue;
                }

            SkipXMLNode:
                // Ignore others elements such as annotations
                SkipXmlElement();
           }

           return;
        }

        // Resolves internal references
        private void Resolve()
        {
            Util.Log("SdlParser.Resolve");                                  
            for(int i=0;i<_URTNamespaces.Count;i++)
                ((URTNamespace)_URTNamespaces[i]).ResolveElements(this);

            for(int i=0;i<_URTNamespaces.Count;i++)
                ((URTNamespace)_URTNamespaces[i]).ResolveTypes(this);

            for(int i=0;i<_URTNamespaces.Count;i++)
                ((URTNamespace)_URTNamespaces[i]).ResolveMethods();
        }

        // Lookup a given attribute position.
        // Note that the supplied strings must have been atomized
        private String LookupAttribute(String attrName, String attrNS, bool throwExp)
        {
            String value = s_emptyString;
            bool bPresent;
            if(attrNS != null)
                bPresent = _XMLReader.MoveToAttribute(attrName, attrNS);
            else
                bPresent = _XMLReader.MoveToAttribute(attrName);

            if(bPresent)
                value = Atomize(_XMLReader.Value.Trim());
            _XMLReader.MoveToElement();

            if((bPresent == false) && (throwExp == true))
            {
                throw new SUDSParserException(
                    String.Format(CoreChannel.GetResourceString("Remoting_Suds_AttributeNotFound"),
                        attrName));
            }
            Util.Log("SdlParser.LookupAttribute "+attrName+"="+value+", NS "+attrNS+", Exp "+throwExp);                                 
            return(value);
        }

        // Resolves type attribute into its constituent parts
        private void ResolveTypeAttribute(ref String typeName, out String typeNS,
                                          out bool bEmbedded, out bool bPrimitive)
        {
            Util.Log("SdlParser.ResolveTypeAttribute typeName "+typeName);                                  
            if(MatchingStrings(typeName, s_emptyString))
            {
                typeName = s_objectString;
                typeNS = s_schemaNamespaceString;
                bEmbedded = true;
                bPrimitive = false;
            }
            else
            {
                // The type field is a QName
                typeNS = ParseQName(ref typeName);

                // Check for reference and array types
                ResolveTypeNames(ref typeNS, ref typeName, out bEmbedded, out bPrimitive);
            }

            return;
        }

        // Parses a qname
        private String ParseQName(ref String qname)
        {
            Util.Log("SdlParser.ParseQName Enter qname "+qname);
            int colonIndex = qname.IndexOf(":");
            if(colonIndex == -1)
            {
                //textWriter.WriteLine("DefaultNS: " + _XMLReader.LookupNamespace(s_emptyString) + '\n' +
                //                     "ElementNS: " + _XMLReader.Namespace);
                // Should this be element namespace or default namespace
                // For attributes names, element namespace makes more sense
                // For QName values, default namespace makes more sense
                // I am currently returning default namespace
                return(_XMLReader.LookupNamespace(s_emptyString));
            }

            // Get the suffix and atmoize it
            String prefix = qname.Substring(0, colonIndex);
            qname = Atomize(qname.Substring(colonIndex+1));

            String ns = _XMLReader.LookupNamespace(prefix);
            if(ns == null)
                PrintNode(Console.Out);
            ns = Atomize(ns);
            Util.Log("SdlParser.ParseQName Exit qname "+qname+" ns "+ns);           
            return(ns);
        }

        // Returns true if the type needs to be qualified with namespace
        private static bool Qualify(String typeNS, String curNS)
        {
            Util.Log("SdlParser.Qualify typeNS "+typeNS+" curNS "+curNS);                                   
            if(MatchingStrings(typeNS, s_schemaNamespaceString) ||
               MatchingStrings(typeNS, s_soapNamespaceString) ||
               MatchingStrings(typeNS, "System") ||
               MatchingStrings(typeNS, curNS))
               return(false);

            return(true);
        }

        // Returns true if the current element node namespace has matching namespace
        private bool MatchingNamespace(String elmNS)
        {
            //Util.Log("SdlParser.MathcingNamespace "+elmNS);                                               
            if(MatchingStrings(_XMLReader.NamespaceURI, elmNS))
            // ||
            //   MatchingStrings(_XMLReader.Prefix, s_emptyString))
               return(true);

            return(false);
        }

        // Returns true if the atomized strings match
        private static bool MatchingStrings(String left, String right)
        {
            //Util.Log("SdlParser.MatchingStrings left "+left+" right "+right);
            return((Object) left == (Object) right);
        }

        // Atmozie the given string
        internal String Atomize(String str)
        {
            // Always atmoize using the table defined on the
            // current XML parser
            return(_XMLReader.NameTable.Add(str));
        }

        // Maps URT types to cool types
        private static String MapSchemaTypesToCSharpTypes(String fullTypeName)
        {
            Util.Log("SdlParser.MapSchemaTypesToCSharpTypes Enter fullTypeName "+fullTypeName);
            // Check for array types
            String typeName = fullTypeName;
            int index = fullTypeName.IndexOf('[');
            if(index != -1)
                typeName = fullTypeName.Substring(0, index);

            String newTypeName = typeName;
            // Handle byte and sbyte
            if(typeName == "unsigned-byte" || typeName == "binary")
                newTypeName = "byte";
            else if(typeName == "byte")
                newTypeName = "sbyte";
            // Handle unsigned versions
            // short, int, long, float, double, decimal are the same
            else if(typeName.StartsWith("unsigned-"))
                newTypeName = 'u' + typeName.Substring("unsigned-".Length);
            // Handle bool type
            else if(typeName == "boolean")
                newTypeName = "bool";
            // Schemas have not yet defined char type
            else if(typeName == "string")
                newTypeName = "String";
            else if(typeName == "character")
                newTypeName = "char";
            else if(typeName == "ur-type")
                newTypeName = "Object";
            else if(typeName == "timeInstant")
                newTypeName = "DateTime";

            // Handle array types
            if(index != -1)
                newTypeName = newTypeName + fullTypeName.Substring(index);
            Util.Log("SdlParser.MapSchemaTypesToCSharpTypes Exit Type "+newTypeName);           
            return(newTypeName);
        }

        // Return true if the given type is a primitive type
        private static bool IsPrimitiveType(String typeNS, String typeName)
        {
            Util.Log("SdlParser.IsPrimitiveType typeNS "+typeNS+" typeName "+typeName);         
            bool fReturn = false;
            if(MatchingStrings(typeNS, s_schemaNamespaceString))
            {
                if(!MatchingStrings(typeName, s_urTypeString))
                    fReturn = true;
            }

            return(fReturn);
        }

        // Looksup a matching namespace
        private URTNamespace LookupNamespace(String name)
        {
            //Util.Log("SdlParser.lookupNamespace name "+name);         
            for(int i=0;i<_URTNamespaces.Count;i++)
            {
                URTNamespace urtNS = (URTNamespace) _URTNamespaces[i];
                if(SdlParser.MatchingStrings(urtNS.Name, name))
                    return(urtNS);
            }

            return(null);
        }

        // Prints the parsed entities
        private void PrintCSC()
        {
            Util.Log("SdlParser.PrintCSC ");
            for(int i=0;i<_URTNamespaces.Count;i++)
            {
                URTNamespace urtNS = (URTNamespace) _URTNamespaces[i];
                if ((urtNS.IsEmpty == false) && (urtNS.UrtType != UrtType.UrtSystem))
                {
                    String fileName = urtNS.IsURTNamespace ? urtNS.AssemName : urtNS.EncodedNS;
                    Util.Log("SdlParser.PrintCSC fileName "+fileName+" "+urtNS.Namespace);                  
                    String completeFileName = "";

                    WriterStream output = WriterStream.GetWriterStream(ref _writerStreams,
                                                                       _outputDir, fileName, ref completeFileName);
                    if (completeFileName.Length > 0)
                        _outCodeStreamList.Add(completeFileName);
                    urtNS.PrintCSC(output.OutputStream);
                }
            }
            return;
        }

        internal UrtType IsURTExportedType(String name, out String ns, out String assemName)
        {
            Util.Log("SdlParser.IsURTExportedType Enter "+name);            
            //Console.WriteLine("Parsing " + name);
            UrtType urtType = UrtType.None;
            ns = null;
            assemName = null;
            if (SoapServices.IsClrTypeNamespace(name))
            {
                SoapServices.DecodeXmlNamespaceForClrTypeNamespace(name, out ns, out assemName);
                if (assemName == null)
                {
                    assemName = typeof(String).Module.Assembly.GetName().Name;
                    urtType = UrtType.UrtSystem;
                }
                else
                    urtType = UrtType.UrtUser;
            }
            if(urtType == UrtType.None)
            {
                ns = name;
                assemName = ns;
                if(NeedsEncoding(name))
                    urtType = UrtType.Interop;
            }

            ns = Atomize(ns);
            assemName = Atomize(assemName);

            //Console.WriteLine("NS: " + ns + " Assembly: " + assemName);
            Util.Log("SdlParser.IsURTExportedType Exit "+((Enum)urtType).ToString());
            return(urtType);
        }

        private static bool NeedsEncoding(String ns)
        {
            bool bEncode = false;
            if(MatchingStrings(ns, s_schemaNamespaceString) ||
               MatchingStrings(ns, s_instanceNamespaceString) ||
               MatchingStrings(ns, s_soapNamespaceString) ||
               MatchingStrings(ns, s_sudsNamespaceString) ||
               MatchingStrings(ns, s_serviceNamespaceString))
                bEncode = false;
            else
                bEncode = true;

            Util.Log("SdlParser.NeedsEncoding ns "+ns+" "+bEncode); 
            return bEncode;
        }

        // Finalizer
        /*protected override void Finalize()
        {
            Interlocked.Decrement(ref s_counter);
            return;
        }

        // Timer callback
        private static void Cleanup(Object state)
        {
            // Check if there are existing instances using the nametable
            if(s_counter == 0)
            {
                // Null the name table so that it can get garbage collected
                Object table = s_atomizedTable;
                s_atomizedTable = null;

                // Check for new instances
                if(s_counter > 0)
                {
                    // A new instance got created and it might be using the
                    // name table that we hold now. Update the satic if that
                    // was indeed the case
                    Interlocked.CompareExchange(ref s_atomizedTable, table, null);
                }
            }

            return;
        }*/

        // Creates and initializes the name table if neccessary
        static private XmlNameTable CreatePrimedNametable()
        {
            Util.Log("SdlParser.CreatePrimedNametable");            

            //Interlocked.Increment(ref s_counter);
            /*if(s_atomizedTable == null)
            {
                // Create a new nametable
                //MTNameTable newTable = new MTNameTable(true);
            }*/
            NameTable newTable = new NameTable();

                // Atomically update static location to point to the current table
                /*Object oldTable = Interlocked.CompareExchange(ref s_atomizedTable, newTable, null);
                if(oldTable != null)
                    newTable = (MTNameTable) oldTable; */

            // Atomize frequently used strings for perf
            // The following ops are not done inside a lock as they are idempotent
            s_operationString = newTable.Add("operation");
            s_emptyString = newTable.Add(String.Empty);
            s_complexTypeString = newTable.Add("complexType");
            s_simpleTypeString = newTable.Add("simpleType");
            s_elementString = newTable.Add("element");
            s_enumerationString = newTable.Add("enumeration");
            s_encodingString = newTable.Add("encoding");
            s_attributeString = newTable.Add("attribute");
            s_allString = newTable.Add("all");
            s_sequenceString = newTable.Add("sequence");
            s_choiceString = newTable.Add("choice");
            s_minOccursString = newTable.Add("minOccurs");
            s_maxOccursString = newTable.Add("maxOccurs");
            s_unboundedString = newTable.Add("unbounded");
            s_oneString = newTable.Add("1");
            s_zeroString = newTable.Add("0");
            s_nameString = newTable.Add("name");
            s_typeString = newTable.Add("type");
            s_baseString = newTable.Add("base");
            s_valueString = newTable.Add("value");
            s_interfaceString = newTable.Add("interface");
            s_serviceString = newTable.Add("service");
            s_extendsString = newTable.Add("extends");
            s_addressesString = newTable.Add("addresses");
            s_addressString = newTable.Add("address");
            s_uriString = newTable.Add("uri");
            s_implementsString = newTable.Add("implements");
            s_requestString = newTable.Add("request");
            s_responseString = newTable.Add("response");
            s_requestResponseString = newTable.Add("requestResponse");
            s_messageString = newTable.Add("message");
            s_locationString = newTable.Add("location");
            s_importString = newTable.Add("import");
            s_onewayString = newTable.Add("oneway");
            s_refString = newTable.Add("ref");
            s_refTypeString = newTable.Add("refType");
            s_referenceString = newTable.Add("Reference");
            s_objectString = newTable.Add("Object");
            s_urTypeString = newTable.Add("ur-type");
            s_arrayString = newTable.Add("Array");
            //s_sudsString = newTable.Add("suds");
            s_sudsString = newTable.Add("soap");
            s_soapString = newTable.Add("soap");
            s_serviceDescString = newTable.Add("serviceDescription");
            s_schemaString = newTable.Add("schema");
            s_targetNamespaceString = newTable.Add("targetNamespace");
            s_namespaceString = newTable.Add("namespace");
            s_idString = newTable.Add("ID");
            s_soapActionString = newTable.Add("soapAction");
            s_schemaNamespaceString = newTable.Add("http://www.w3.org/2000/10/XMLSchema");
            s_instanceNamespaceString = newTable.Add("http://www.w3.org/2000/10/XMLSchema-instance");
            s_soapNamespaceString = newTable.Add("urn:schemas-xmlsoap-org:soap.v1");
            //s_sudsNamespaceString = newTable.Add("urn:schemas-xmlsoap-org:suds.v1");
            s_sudsNamespaceString = newTable.Add("urn:schemas-xmlsoap-org:soap-sdl-2000-01-25");
            //s_URTNamespaceString = newTable.Add("urn:schamas-xmlsoap-org:urt.v1");
            //s_serviceNamespaceString = newTable.Add("urn:schemas-xmlsoap-org:servicedesc.v1");
            s_serviceNamespaceString = newTable.Add("urn:schemas-xmlsoap-org:sdl.2000-01-25");

            return((XmlNameTable) newTable);

                // Enqueue a timer if it has not already been done
                /*Timer timer = new Timer(new TimerCallback(Cleanup), null, 1000, 1000);
                Object existingTimer = Interlocked.CompareExchange(ref s_enqueuedTimer, timer, null);
                if(existingTimer != null)
                    timer.Dispose(); */
            //}

            //return((XmlNameTable) s_atomizedTable);
        }

        // Private fields
        private XmlTextReader _XMLReader;
        private ArrayList _URTNamespaces;
        private ReaderStream _parsingInput;
        private bool _bWrappedProxy;
        private ReaderStream _readerStreams;
        private String _outputDir;
        private ArrayList _outCodeStreamList;
        private WriterStream _writerStreams;
        private SchemaBlockType _blockDefault;

        //static private Object s_atomizedTable = null;
        //static private int s_counter = 0;
        //static private Object s_enqueuedTimer = null;
        static private String s_operationString;
        static private String s_emptyString;
        static private String s_complexTypeString;
        static private String s_simpleTypeString;
        static private String s_elementString;
        static private String s_enumerationString;
        static private String s_encodingString;
        static private String s_attributeString;
        static private String s_allString;
        static private String s_sequenceString;
        static private String s_choiceString;
        static private String s_minOccursString;
        static private String s_maxOccursString;
        static private String s_unboundedString;
        static private String s_oneString;
        static private String s_zeroString;
        static private String s_nameString;
        static private String s_typeString;
        static private String s_baseString;
        static private String s_valueString;
        static private String s_interfaceString;
        static private String s_serviceString;
        static private String s_extendsString;
        static private String s_addressesString;
        static private String s_addressString;
        static private String s_uriString;
        static private String s_implementsString;
        static private String s_requestString;
        static private String s_responseString;
        static private String s_requestResponseString;
        static private String s_messageString;
        static private String s_locationString;
        static private String s_importString;
        static private String s_onewayString;
        static private String s_refString;
        static private String s_refTypeString;
        static private String s_referenceString;
        static private String s_arrayString;
        static private String s_objectString;
        static private String s_urTypeString;
        static private String s_sudsString;
        static private String s_soapString;
        static private String s_serviceDescString;
        static private String s_schemaString;
        static private String s_targetNamespaceString;
        static private String s_namespaceString;
        static private String s_idString;
        static private String s_soapActionString;
        static private String s_instanceNamespaceString;
        static private String s_schemaNamespaceString;
        static private String s_soapNamespaceString;
        static private String s_sudsNamespaceString;
        static private String s_serviceNamespaceString;

        

        /***************************************************************
        **
        ** Private classes used by SUDS Parser
        **
        ***************************************************************/
        // Input streams
        internal class ReaderStream
        {
            internal ReaderStream(String location)
            {
                Util.Log("ReaderStream.ReaderStream "+location);
                _location = location;
                _name = String.Empty;
                _targetNS = String.Empty;
                _uniqueType = null;
                _uniqueNS = null;
                _reader = null;
                _next = null;
            }
            internal String Location
            {
                get { return(_location); }
            }
            internal String Name
            {
                get { return(_name); }
                set { _name = value; }
            }
            internal String TargetNS
            {
                get { return(_targetNS); }
                set { _targetNS = value; }
            }
            internal URTComplexType UniqueType
            {
                get { return(_uniqueType); }
                set { _uniqueType = value; }
            }
            internal URTNamespace UniqueNS
            {
                get { return(_uniqueNS); }
                set { _uniqueNS = value; }
            }
            internal TextReader InputStream
            {
                get { return(_reader); }
                set { _reader = value; }
            }
            internal static ReaderStream GetReaderStream(ReaderStream inputStreams, String location)
            {
                Util.Log("ReaderStream.GetReaderStream "+location);             
                ReaderStream input = inputStreams;
                ReaderStream last;
                do
                {
                    if(input._location == location)
                        return(input);
                    last = input;
                    input = input._next;
                } while(input != null);

                input = new ReaderStream(location);
                last._next = input;

                return(input);
            }
            internal static ReaderStream GetNextReaderStream(ReaderStream input)
            {
                Util.Log("ReaderStream.GetNextReaderStream ");              
                return(input._next);
            }

            private String _location;
            private String _name;
            private String _targetNS;
            private URTComplexType _uniqueType;
            private URTNamespace _uniqueNS;
            private TextReader _reader;
            private ReaderStream _next;
        }

        internal class WriterStream
        {

            private WriterStream(String fileName, TextWriter writer)
            {
                Util.Log("WriterStream.WriterStream "+fileName);                
                _fileName = fileName;
                _writer = writer;
            }
            internal TextWriter OutputStream
            {
                get { return(_writer); }
            }
            internal static void Flush(WriterStream writerStream)
            {
                while(writerStream != null)
                {
                    writerStream._writer.Flush();
                    writerStream = writerStream._next;
                }

                return;
            }
            internal static WriterStream GetWriterStream(ref WriterStream outputStreams,
                                                       String outputDir, String fileName,
                                                       ref String completeFileName)
            {
                Util.Log("WriterStream.GetWriterStream "+fileName);                             
                WriterStream output = outputStreams;
                while(output != null)
                {
                    if(output._fileName == fileName)
                        return(output);
                    output = output._next;
                }

                String diskFileName = fileName;
                if(diskFileName.EndsWith(".exe") || diskFileName.EndsWith(".dll"))
                    diskFileName = diskFileName.Substring(0, diskFileName.Length - 4);
                String _completeFileName = outputDir + diskFileName + ".cs";
                completeFileName = _completeFileName;
                //TextWriter textWriter = new StreamWriter(outputDir + fileName + ".cs", false);
                TextWriter textWriter = new StreamWriter(_completeFileName, false, new UTF8Encoding(false));
                output = new WriterStream(fileName, textWriter);
                output._next = outputStreams;
                outputStreams = output;
                Util.Log("WriterStream.GetWriterStream in fileName "+fileName+" completeFileName "+_completeFileName);                              
                return(output);
            }

            internal static void Close(WriterStream outputStreams)
            {
                WriterStream output = outputStreams;
                while(output != null)
                {
                    output._writer.Close();
                    output = output._next;
                }
            }

            private String _fileName;
            private TextWriter _writer;
            private WriterStream _next;
        }

        // Represents a parameter of a method
        [Serializable]
        internal enum URTParamType { IN, OUT, REF }
        internal class URTParam
        {
            internal URTParam(String name, String typeName, String typeNS, String encodedNS,
                            URTParamType pType, bool bEmbedded)
            {
                Util.Log("URTParam.URTParam name "+name+" typeName "+typeName+" typeNS "+typeNS+" ecodedNS "+encodedNS+" pType "+pType+" bEmbedded "+bEmbedded);
                _name = name;
                _typeName = typeName;
                _typeNS = typeNS;
                _encodedNS = encodedNS;
                _pType = pType;
                _embeddedParam = bEmbedded;
            }
            public override bool Equals(Object obj)
            {
                //Util.Log("URTParam.Equals ");
                URTParam suppliedParam = (URTParam) obj;
                if(_pType == suppliedParam._pType &&
                   SdlParser.MatchingStrings(_typeName, suppliedParam._typeName) &&
                   SdlParser.MatchingStrings(_typeNS, suppliedParam._typeNS))
                    return(true);

                return(false);
            }


            public override int GetHashCode()
            {
                return base.GetHashCode();
            }
            internal bool IsCompatibleType(ParameterInfo pInfo)
            {
                Util.Log("URTParam.IsCompatibleType");              
                if(_pType == URTParamType.OUT)
                {
                    if(pInfo.IsOut == false)
                        return(false);
                }

                Type parameterType = pInfo.ParameterType;
                if(parameterType.Namespace == _typeNS)
                {
                    String typeName = _typeName;
                    if(_pType == URTParamType.REF)
                    {
                        if(parameterType.IsByRef == false)
                            return(false);

                        typeName = typeName + '&';
                    }
                    if(parameterType.Name == typeName)
                        return(true);
                }

                return(false);
            }
            internal URTParamType ParamType
            {
                get { return(_pType); }
                set { _pType = value; }
            }
            internal String Name
            {
                get { return(_name); }
            }
            internal String TypeName
            {
                get { return(_typeName); }
            }
            internal String TypeNS
            {
                get { return(_typeNS); }
            }
            
            internal bool IsInteropType
            {
                get { return((Object) _typeNS != (Object) _encodedNS); }                
            }
            
            internal String GetTypeString(String curNS)
            {
                Util.Log("URTParam.GetTypeString Enter curNS "+curNS);                              
                String type;
                if(SdlParser.Qualify(_typeNS, curNS))
                {
                    StringBuilder sb = new StringBuilder(_encodedNS, 50);
                    sb.Append('.');
                    type = sb.Append(_typeName).ToString();
                }
                else
                    type = _typeName;

                Util.Log("URTParam.GetTypeString Exit type "+type);                                             
                return(type);
            }
            internal void PrintCSC( StringBuilder sb, String curNS)
            {
                Util.Log("URTParam.PrintCSC curNS "+curNS+" name "+_name);                                              
                //if(_embeddedParam)
                //    sb.Append("[Embedded] ");
                sb.Append(PTypeString[(int) _pType]);
                sb.Append(GetTypeString(curNS));
                sb.Append(' ');
                sb.Append(_name);
                return;
            }
            internal void PrintCSC(StringBuilder sb)
            {
                Util.Log("URTParam.PrintCSC name "+_name);                                              
                sb.Append(PTypeString[(int) _pType]);
                sb.Append(_name);
                return;
            }

            static private String[] PTypeString = { "", "out ", "ref " };
            private String _name;
            private String _typeName;
            private String _typeNS;
            private String _encodedNS;
            private URTParamType _pType;
            private bool _embeddedParam;
        }

        // Represents a method
        internal abstract class URTMethod
        {
            internal URTMethod(String name, String soapAction)
            {
                Util.Log("URTMethod.URTMethod name "+name+" soapAction "+soapAction);
                _methodName = name;
                _soapAction = soapAction;
                _methodType = null;
                _methodFlags = 0;
                _params = new ArrayList();
            }
            internal String Name
            {
                get { return(_methodName); }
            }
            internal String SoapAction
            {
                get { return(_soapAction); }
                set { _soapAction = value;}
            }
            internal int MethodFlags
            {
                get { return(_methodFlags); }
                set { _methodFlags = value; }
            }

            internal bool IsInteropType
            {
                get 
                { 
                    if (_methodType != null)
                        return _methodType.IsInteropType;
                    else
                        return false;
                }
            }

            internal String GetTypeString(String curNS)
            {
                Util.Log("URTMethod.GetTypeString curNS "+curNS);
                return((_methodType != null) ? _methodType.GetTypeString(curNS) : "void");
            }
            protected URTParam MethodType
            {
                get { return(_methodType); }
            }
            public override int GetHashCode()
            {
                return base.GetHashCode();
            }           
            public override bool Equals(Object obj)
            {
                URTMethod suppliedMethod = (URTMethod) obj;
                if(SdlParser.MatchingStrings(_methodName, suppliedMethod._methodName) &&
                   _params.Count == suppliedMethod._params.Count)
                {
                    for(int i=0;i<_params.Count;i++)
                    {
                        if(_params[i].Equals(suppliedMethod._params[i]) == false)
                            return(false);
                    }

                    return(true);
                }

                return(false);
            }
            internal int GetMethodFlags(MethodInfo method)
            {
                int methodFlags = 0;
                MethodAttributes attributes = method.Attributes;
                MethodAttributes access = MethodAttributes.Family |
                                          MethodAttributes.FamORAssem |
                                          MethodAttributes.Public;
                if((attributes & access) == MethodAttributes.Family |
                   (attributes & access) == MethodAttributes.FamORAssem |
                   (attributes & access) == MethodAttributes.Public)
                {
                    if(method.Name == _methodName)
                    {
                        ParameterInfo[] parameters = method.GetParameters();
                        if(parameters.Length == _params.Count)
                        {
                            for(int i=0;i<parameters.Length;i++)
                            {
                                if(((URTParam) _params[i]).IsCompatibleType(parameters[i]) == false)
                                    return(methodFlags);
                            }

                            if((attributes & access) == MethodAttributes.Family |
                               (attributes & access) == MethodAttributes.FamORAssem)
                                methodFlags |= 2;
                            if((attributes & MethodAttributes.Virtual) != 0)
                                methodFlags |= 4;
                        }
                    }
                }

                return(methodFlags);
            }
            internal void AddParam(URTParam newParam)
            {
                Util.Log("URTMethod.AddParam "+newParam.Name);
                for(int i=0;i<_params.Count;i++)
                {
                    URTParam extParam = (URTParam) _params[i];
                    if(SdlParser.MatchingStrings(extParam.Name, newParam.Name))
                    {
                        if(extParam.ParamType == URTParamType.IN &&
                           newParam.ParamType == URTParamType.OUT &&
                           SdlParser.MatchingStrings(extParam.TypeName, newParam.TypeName) &&
                           SdlParser.MatchingStrings(extParam.TypeNS, newParam.TypeNS))
                        {
                            extParam.ParamType = URTParamType.REF;
                            return;
                        }

                        throw new SUDSParserException(CoreChannel.GetResourceString("Remoting_Suds_DuplicateParameter"));
                    }
                }

                if((_methodType == null) && (newParam.ParamType == URTParamType.OUT))
                {
                    _methodType = newParam;
                    return;
                }

                _params.Add(newParam);
                return;
            }
            internal void PrintSignature(StringBuilder sb, String curNS)
            {
                Util.Log("URTMethod.PrintSignature curNS "+curNS);              
                for(int i=0;i<_params.Count;i++)
                {
                    if(i != 0)
                        sb.Append(", ");
                    Util.Log("URTMethod.PrintSignature Invoke _params PrintCSC");                               
                    ((URTParam) _params[i]).PrintCSC(sb, curNS);
                }

                return;
            }
            internal abstract void PrintCSC(TextWriter textWriter, String indentation,
                                          String namePrefix, String curNS, bool bPrintBody,
                                          bool bURTType, String bodyPrefix, StringBuilder sb);

            protected void PrintCSC(TextWriter textWriter, String indentation,
                                    String namePrefix, String curNS, bool bPrintBody,
                                    String bodyPrefix, StringBuilder sb)
            {
                Util.Log("URTMethod.PrintCSC name "+_methodName+" namePrefix "+namePrefix+" curNS "+curNS+" bPrintBody "+bPrintBody+" bodyPrefix "+bodyPrefix);                                             
                // Custom Attributes

                /*
                if (!fromSubclass)
                {
                    bool bSoapAction = false;
                    String soapAction = SoapAction;
                    if ((soapAction != null) && (soapAction.Length > 0))
                        bSoapAction = true;
                    if (IsInteropType || bSoapAction)
                    {
                        sb.Length = 0;
                        sb.Append(indentation);
                        sb.Append("[SoapMethod(");
                        if (bSoapAction)
                        {
                            sb.Append("SoapAction=\"");
                            sb.Append(soapAction);
                            sb.Append("\"");
                        }
                        if (IsInteropType)
                        {
                            if (bSoapAction)
                            {
                                sb.Append(",");
                            }
                            sb.Append(", ReturnXmlElementName=\"");
                            sb.Append(MethodType.Name);
                            sb.Append(",XmlNamespace=\"");
                            sb.Append(_methodType.TypeNS);
                            sb.Append("\", ResponseXmlNamespace=\"");
                            sb.Append(_methodType.TypeNS);
                            sb.Append("\"");
                        }
                        sb.Append(")]");
                        textWriter.WriteLine(sb);
                    }
                }
                */

                // Check for class methods
                sb.Length = 0;
                sb.Append(indentation);
                if(_methodFlags != 0)
                {
                    if((_methodFlags & 2) != 0)
                        sb.Append("protected ");
                    else
                        sb.Append("public ");
                    if((_methodFlags & 4) != 0)
                        sb.Append("override ");
                }

                sb.Append(GetTypeString(curNS));
                sb.Append(namePrefix);
                sb.Append(_methodName);
                sb.Append('(');
                if(_params.Count > 0)
                {
                    Util.Log("URTMethod.PrintCSC Invoke _params[0] 1 PrintCSC");
                    ((URTParam) _params[0]).PrintCSC(sb, curNS);
                    for(int i=1;i<_params.Count;i++)
                    {
                        sb.Append(", ");
                        Util.Log("URTMethod.PrintCSC Invoke _params 2 PrintCSC");                       
                        ((URTParam) _params[i]).PrintCSC(sb, curNS);
                    }
                }
                sb.Append(')');
                if(!bPrintBody)
                    sb.Append(';');
                textWriter.WriteLine(sb);

                if(bPrintBody)
                {
                    sb.Length = 0;
                    sb.Append(indentation);
                    sb.Append('{');
                    textWriter.WriteLine(sb);

                    String newIndentation = indentation + "    ";
                    if(bodyPrefix == null)
                    {
                        for(int i=0;i<_params.Count;i++)
                        {
                            URTParam param = (URTParam) _params[i];
                            if(param.ParamType == URTParamType.OUT)
                            {
                                sb.Length = 0;
                                sb.Append(newIndentation);
                                sb.Append(param.Name);
                                sb.Append(" = ");
                                sb.Append(ValueString(param.GetTypeString(curNS)));
                                sb.Append(';');
                                textWriter.WriteLine(sb);
                            }
                        }
                        Util.Log("URTMethod.PrintCSC return print");
                        sb.Length = 0;
                        sb.Append(newIndentation);
                        sb.Append("return");
                        String returnString = ValueString(GetTypeString(curNS));
                        if(returnString != null)
                        {
                            sb.Append('(');
                            sb.Append(returnString);
                            sb.Append(')');
                        }
                        sb.Append(';');
                    }
                    else
                    {
                        sb.Length = 0;
                        sb.Append(newIndentation);
                        if(ValueString(GetTypeString(curNS)) != null)
                            sb.Append("return ");
                        sb.Append(bodyPrefix);
                        sb.Append(_methodName);
                        sb.Append('(');
                        if(_params.Count > 0)
                        {
                            Util.Log("URTMethod.PrintCSC Invoke _params[0] 3 PrintCSC");                                                    
                            ((URTParam) _params[0]).PrintCSC(sb);
                            for(int i=1;i<_params.Count;i++)
                            {
                                sb.Append(", ");
                                Util.Log("URTMethod.PrintCSC Invoke _params 4 PrintCSC");                                                       
                                ((URTParam) _params[i]).PrintCSC(sb);
                            }
                        }
                        sb.Append(");");
                    }
                    textWriter.WriteLine(sb);

                    textWriter.Write(indentation);
                    textWriter.WriteLine('}');
                }
            }

            // Returns string that is appropriate for the return type
            internal static String ValueString(String paramType)
            {
                String valueString;
                if(paramType == "void")
                    valueString = null;
                else if(paramType == "bool")
                    valueString = "false";
                else if(paramType == "string")
                    valueString = "null";
                else if(paramType == "sbyte" ||
                        paramType == "byte" ||
                        paramType == "short" ||
                        paramType == "ushort" ||
                        paramType == "int" ||
                        paramType == "uint" ||
                        paramType == "long" ||
                        paramType == "ulong")
                    valueString = "1";
                else if(paramType == "float" ||
                        paramType == "exfloat")
                    valueString = "(float)1.0";
                else if(paramType == "double" ||
                        paramType == "exdouble")
                    valueString = "1.0";
                else
                {
                    StringBuilder sb = new StringBuilder(50);
                    sb.Append('(');
                    sb.Append(paramType);
                    sb.Append(") (Object) null");
                    valueString = sb.ToString();
                }
                Util.Log("URTMethod.ValueString paramType "+paramType+" valueString "+valueString);                             
                return(valueString);
            }

            // This method is called when the parsing is complete
            // and is useful for derived types
            internal abstract void ResolveTypes(SdlParser parser);

            // Helper method used by Resolve
            protected void ResolveParams(SdlParser parser, String targetNS, String targetName,
                                         bool bRequest)
            {
                Util.Log("URTMethod.ResolveParams targetName "+targetName+"targetNS "+targetNS+" bRequest "+bRequest);                              
                // Lookup the element declaration using target namespace and type name
                URTNamespace elmNS = parser.LookupNamespace(targetNS);
                if(elmNS == null)
                {
                    throw new SUDSParserException(
                        String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
                                      targetNS));
                }
                ElementDecl elm = elmNS.LookupElementDecl(targetName);
                if(elm == null)
                {
                    throw new SUDSParserException(
                        String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveElementInNS"),
                                      targetName, targetNS));
                }

                // Lookup the type from the element declaration
                URTNamespace typeNS = parser.LookupNamespace(elm.TypeNS);
                if(typeNS == null)
                {
                    throw new SUDSParserException(
                        String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
                                      elm.TypeNS));
                }
                URTComplexType type = typeNS.LookupComplexType(elm.TypeName);
                if(type == null)
                {
                    throw new SUDSParserException(
                        String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
                                      elm.TypeName, elm.TypeNS));
                }
                Util.Log("URTMethod.ResolveParams Before RemoveComplexType ");
                typeNS.RemoveComplexType(type);

                // The fields of the type are the params of the method
                ArrayList fields = type.Fields;
                for(int i=0;i<fields.Count;i++)
                {
                    URTField field = (URTField) fields[i];
                    URTParamType pType = bRequest ? URTParamType.IN : URTParamType.OUT;
                    AddParam(new URTParam(field.Name, field.TypeName, field.TypeNS, field.EncodedNS,
                                          pType, field.IsEmbedded));
                }

                return;
            }

            // Fields
            private String _methodName;
            private String _soapAction;
            private URTParam _methodType;
            private int _methodFlags;
            private ArrayList _params;
        }

        // Repesents a request response method
        internal class RRMethod : URTMethod
        {
            // Constructor
            internal RRMethod(String name, String soapAction)
            : base(name, soapAction)
            {
                Util.Log("RRMethod.RRMethod name "+name+" soapAction "+soapAction);
                _requestElementName = null;
                _requestElementNS = null;
                //_requestTypeName = null;
                //_requestTypeNS = null;
                _responseElementName = null;
                _responseElementNS = null;
                //_responseTypeName = null;
                //_responseTypeNS = null;
            }

            // Adds the request element
            internal void AddRequest(String name, String ns)
            {
                Util.Log("RRMethod.AddRequest name "+name+" ns "+ns);               
                _requestElementName = name;
                _requestElementNS = ns;
            }

            // Adds the response element
            internal void AddResponse(String name, String ns)
            {
                Util.Log("RRMethod.AddResponse name "+name+" ns "+ns);                              
                _responseElementName = name;
                _responseElementNS = ns;
            }

            // Resolves the method
            internal override void ResolveTypes(SdlParser parser)
            {
                Util.Log("RRMethod.ResolveTypes "+_requestElementName+" "+_responseElementName);                                
                ResolveParams(parser, _requestElementNS, _requestElementName, true);
                ResolveParams(parser, _responseElementNS, _responseElementName, false);
                return;
            }

            internal override void PrintCSC(TextWriter textWriter, String indentation,
                                          String namePrefix, String curNS, bool bPrintBody,
                                          bool bURTType, String bodyPrefix, StringBuilder sb)
            {
                Util.Log("RRMethod.PrintCSC name "+_requestElementName+" namePrefix "+namePrefix+" curNS "+curNS+" bPrintBody "+bPrintBody+" bURTType "+bURTType+" bodyPrefix "+bodyPrefix);                                
                //if(bURTType == false)

                bool bSoapAction = false;
                if (SoapAction != null)
                    bSoapAction = true;

                if (bSoapAction || !bURTType)
                {
                    sb.Length = 0;
                    sb.Append(indentation);
                    sb.Append("[SoapMethod(");

                    if (bSoapAction)
                    {
                        sb.Append("SoapAction=\"");
                        sb.Append(SoapAction);
                        sb.Append("\"");
                    }
                    if (!bURTType)
                    {
                        if (bSoapAction)
                            sb.Append(",");

                        sb.Append("ResponseXmlElementName=\"");
                        sb.Append(_responseElementName);
                        if(MethodType != null)
                        {
                            sb.Append("\", ReturnXmlElementName=\"");
                            sb.Append(MethodType.Name);
                        }
                        sb.Append("\", XmlNamespace=\"");
                        sb.Append(_requestElementNS);
                        sb.Append("\", ResponseXmlNamespace=\"");
                        sb.Append(_responseElementNS);
                        sb.Append("\"");
                    }
                    sb.Append(")]");
                    textWriter.WriteLine(sb);                   
                }

                Util.Log("RRMethod.PrintCSC Invoke base PrintCSC");                                     
                base.PrintCSC(textWriter, indentation, namePrefix, curNS, bPrintBody,
                              bodyPrefix, sb);
                return;
            }

            // Fields
            private String _requestElementName;
            private String _requestElementNS;
            //private String _requestTypeName;
            //private String _requestTypeNS;
            private String _responseElementName;
            private String _responseElementNS;
            //private String _responseTypeName;
            //private String _responseTypeNS;
        }

        // Reperents a oneway method
        internal class OnewayMethod : URTMethod
        {
            // Constructor
            internal OnewayMethod(String name, String soapAction)
            : base(name, soapAction)
            {
                Util.Log("OnewayMethod.OnewayMethod name "+name+" soapAction "+soapAction);
                _messageElementName = null;
                _messageElementNS = null;
                //_messageTypeName = null;
                //_messageTypeNS = null;
            }

            // Adds the request element
            internal void AddMessage(String name, String ns)
            {
                Util.Log("OnewayMethod.AddMessage name "+name+" ns "+ns);               
                _messageElementName = name;
                _messageElementNS = ns;
            }

            // Resolves the method
            internal override void ResolveTypes(SdlParser parser)
            {
                Util.Log("OnewayMethod.ResolveTypes name "+ _messageElementName);
                ResolveParams(parser, _messageElementNS, _messageElementName, true);
                return;
            }

            // Writes the oneway attribute and delegates to the base implementation
            internal override void PrintCSC(TextWriter textWriter, String indentation,
                                          String namePrefix, String curNS, bool bPrintBody,
                                          bool bURTType, String bodyPrefix, StringBuilder sb)
            {
                Util.Log("OnewayMethod.PrintCSC name "+_messageElementName+" namePrefix "+namePrefix+" curNS "+curNS+" bPrintBody "+bPrintBody+" bURTType "+bURTType+" bodyPrefix "+bodyPrefix);                                                                
                textWriter.Write(indentation);
                textWriter.WriteLine("[OneWay]");

                if (SoapAction != null) //bURTType == false)
                {
                    sb.Length = 0;
                    sb.Append(indentation);
                    sb.Append("[SoapMethod(SoapAction=\"");
                    sb.Append(SoapAction);
                    sb.Append("\", XmlNamespace=\"");
                    sb.Append(_messageElementNS);
                    sb.Append("\")]");
                    textWriter.WriteLine(sb);                   
                }

                Util.Log("OnewayMethod.PrintCSC Invoke base PrintCSC");                                                     
                base.PrintCSC(textWriter, indentation, namePrefix, curNS, bPrintBody,
                              bodyPrefix, sb);

                return;
            }

            // Fields
            private String _messageElementName;
            private String _messageElementNS;
            //private String _messageTypeName;
            //private String _messageTypeNS;
        }

        // Base class for interfaces
        internal abstract class BaseInterface
        {
            internal BaseInterface(String name, String ns, String encodedNS)
            {
                Util.Log("BaseInterface.BaseInterface");
                _name = name;
                _namespace = ns;
                _encodedNS = encodedNS;
            }
            internal String Name
            {
                get { return(_name); }
            }
            internal String Namespace
            {
                get { return(_namespace); }
            }
            internal bool IsURTInterface
            {
                get { return((Object) _namespace == (Object) _encodedNS); }
            }
            internal String GetName(String curNS)
            {
                String name;
                if(SdlParser.Qualify(_namespace, curNS))
                {
                    StringBuilder sb = new StringBuilder(_encodedNS, 50);
                    sb.Append('.');
                    sb.Append(_name);
                    name = sb.ToString();
                }
                else
                    name = _name;

                Util.Log("BaseInterface.GetName curNS "+curNS);
                return(name);
            }
            internal abstract void PrintClassMethods(TextWriter textWriter,
                                                   String indentation,
                                                   String curNS,
                                                   ArrayList printedIFaces,
                                                   bool bProxy, StringBuilder sb);
            private String _name;
            private String _namespace;
            private String _encodedNS;
        }

        // Represents a system interface
        internal class SystemInterface : BaseInterface
        {
            internal SystemInterface(String name, String ns)
            : base(name, ns, ns)
            {
                Util.Log("SystemInterface.SystemInterface");                
                Debug.Assert(ns.StartsWith("System"), "Invalid System type");
                String fullName = ns + '.' + name;
                _type = Type.GetType(fullName, true);
            }
            internal override void PrintClassMethods(TextWriter textWriter,
                                                   String indentation,
                                                   String curNS,
                                                   ArrayList printedIFaces,
                                                   bool bProxy,
                                                   StringBuilder sb)
            {
                Util.Log("SystemInterface.PrintClassMethods "+curNS+" bProxy "+bProxy);                             
                // Return if the interfaces has already been printed
                int i;
                for(i=0;i<printedIFaces.Count;i++)
                {
                    if(printedIFaces[i] is SystemInterface)
                    {
                        SystemInterface iface = (SystemInterface) printedIFaces[i];
                        if(iface._type == _type)
                            return;
                    }
                }
                printedIFaces.Add(this);

                // Count of implemented methods
                BindingFlags bFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance |
                                      BindingFlags.Public;// | BindingFlags.NonPublic;
                ArrayList types = new ArrayList();
                sb.Length = 0;
                types.Add(_type);
                i=0;
                int j=1;
                while(i<j)
                {
                    Type type = (Type) types[i];
                    MethodInfo[] methods = type.GetMethods(bFlags);
                    Type[] iFaces = type.GetInterfaces();
                    for(int k=0;k<iFaces.Length;k++)
                    {
                        for(int l=0;l<j;l++)
                        {
                            if(types[i] == iFaces[k])
                                goto Loopback;
                        }
                        types.Add(iFaces[k]);
                        j++;
                    Loopback:
                        continue;
                    }

                    for(int k=0;k<methods.Length;k++)
                    {
                        MethodInfo method = methods[k];
                        sb.Length = 0;
                        sb.Append(indentation);
                        sb.Append(CSharpTypeString(method.ReturnType.FullName));
                        sb.Append(' ');
                        sb.Append(type.FullName);
                        sb.Append('.');
                        sb.Append(method.Name);
                        sb.Append('(');
                        ParameterInfo[] parameters = method.GetParameters();
                        for(int l=0;l<parameters.Length;l++)
                        {
                            if(l != 0)
                                sb.Append(", ");
                            ParameterInfo param = parameters[l];
                            Type parameterType = param.ParameterType;
                            if(param.IsIn)
                                sb.Append("in ");
                            else if(param.IsOut)
                                sb.Append("out ");
                            else if(parameterType.IsByRef)
                            {
                                sb.Append("ref ");
                                parameterType = parameterType.GetElementType();
                            }
                            sb.Append(CSharpTypeString(parameterType.FullName));
                            sb.Append(' ');
                            sb.Append(param.Name);
                        }
                        sb.Append(')');
                        textWriter.WriteLine(sb);

                        textWriter.Write(indentation);
                        textWriter.WriteLine('{');

                        String newIndentation = indentation + "    ";
                        if(bProxy == false)
                        {
                            for(int l=0;l<parameters.Length;l++)
                            {
                                ParameterInfo param = parameters[l];
                                Type parameterType = param.ParameterType;
                                if(param.IsOut)
                                {
                                    sb.Length = 0;
                                    sb.Append(newIndentation);
                                    sb.Append(param.Name);
                                    sb.Append(URTMethod.ValueString(CSharpTypeString(param.ParameterType.FullName)));
                                    sb.Append(';');
                                    textWriter.WriteLine(sb);
                                }
                            }

                            Util.Log("SystemInterface.PrintClassMethods return 1 print");                           
                            sb.Length = 0;
                            sb.Append(newIndentation);
                            sb.Append("return");
                            String valueString = URTMethod.ValueString(CSharpTypeString(method.ReturnType.FullName));
                            if(valueString != null)
                            {
                                sb.Append('(');
                                sb.Append(valueString);
                                sb.Append(')');
                            }
                            sb.Append(';');
                        }
                        else
                        {
                            Util.Log("SystemInterface.PrintClassMethods return 2 print");                                                       
                            sb.Length = 0;
                            sb.Append(newIndentation);
                            sb.Append("return((");
                            sb.Append(type.FullName);
                            sb.Append(") _tp).");
                            sb.Append(method.Name);
                            sb.Append('(');
                            if(parameters.Length > 0)
                            {
                                int lastParameter = parameters.Length-1;
                                for(int l=0;l<parameters.Length;l++)
                                {
                                    ParameterInfo param = parameters[0];
                                    Type parameterType = param.ParameterType;
                                    if(param.IsIn)
                                        sb.Append("in ");
                                    else if(param.IsOut)
                                        sb.Append("out ");
                                    else if(parameterType.IsByRef)
                                        sb.Append("ref ");
                                    sb.Append(param.Name);
                                    if(l < lastParameter)
                                        sb.Append(", ");
                                }
                            }
                            sb.Append(");");
                        }
                        textWriter.WriteLine(sb);

                        textWriter.Write(indentation);
                        textWriter.WriteLine('}');
                    }

                    ++i;
                }

                return;
            }
            private static String CSharpTypeString(String typeName)
            {
                Util.Log("SystemInterface.CSharpTypeString typeName "+typeName);                                                
                String CSCTypeName = typeName;
                if(typeName == "System.SByte")
                    CSCTypeName = "sbyte";
                else if(typeName == "System.byte")
                    CSCTypeName = "byte";
                else if(typeName == "System.Int16")
                    CSCTypeName = "short";
                else if(typeName == "System.UInt16")
                    CSCTypeName = "ushort";
                else if(typeName == "System.Int32")
                    CSCTypeName = "int";
                else if(typeName == "System.UInt32")
                    CSCTypeName = "uint";
                else if(typeName == "System.Int64")
                    CSCTypeName = "long";
                else if(typeName == "System.UInt64")
                    CSCTypeName = "ulong";
                else if(typeName == "System.Char")
                    CSCTypeName = "char";
                else if(typeName == "System.Single")
                    CSCTypeName = "float";
                else if(typeName == "System.Double")
                    CSCTypeName = "double";
                else if(typeName == "System.Boolean")
                    CSCTypeName = "boolean";
                else if(typeName == "System.Void")
                    CSCTypeName = "void";
                else if(typeName == "System.String")
                    CSCTypeName = "String";

                return(CSCTypeName);
            }

            Type _type;
        }

        // Represents an interface

        internal class URTInterface : BaseInterface
        {
            internal URTInterface(String name, String ns, String encodedNS)
            : base(name, ns, encodedNS)
            {
                Util.Log("URTInterface.URTInterface name "+name+" ns "+ns+" encodedNS "+encodedNS);                                             
                _baseIFaces = new ArrayList();
                _baseIFaceNames = new ArrayList();
                _methods = new ArrayList();
            }
            internal void Extends(String baseName, String baseNS, SdlParser parser)
            {
                Util.Log("URTInterface.Extends baseName "+baseName+" baseNSf "+baseNS);
                _baseIFaceNames.Add(baseName);
                _baseIFaceNames.Add(baseNS);
                // Urt namespace will not have schema, they need to be recorded.
                URTNamespace parsingNamespace = parser.LookupNamespace(baseNS);
                if(parsingNamespace == null)
                {
                    parsingNamespace = new URTNamespace(baseNS, parser);
                    parser._URTNamespaces.Add(parsingNamespace);
                }

                URTInterface parsingInterface = parsingNamespace.LookupInterface(baseName);         
                if(parsingInterface == null)
                {
                    parsingInterface = new URTInterface(baseName, parsingNamespace.Namespace, parsingNamespace.EncodedNS);                  
                    parsingNamespace.AddInterface(parsingInterface);
                }
                
            }
            internal void AddMethod(URTMethod method)
            {
                Util.Log("URTInterface.AddMethod method "+method.Name);
                _methods.Add(method);
            }
            internal void ResolveTypes(SdlParser parser)
            {
                Util.Log("URTInterface.ResolveTypes "+Name);                
                for(int i=0;i<_baseIFaceNames.Count;i=i+2)
                {
                    String baseIFaceName = (String) _baseIFaceNames[i];
                    String baseIFaceXmlNS = (String) _baseIFaceNames[i+1];
                    String baseIFaceNS, baseIFaceAssemName;
                    BaseInterface iFace;
                    UrtType iType = parser.IsURTExportedType(baseIFaceXmlNS, out baseIFaceNS,
                                                         out baseIFaceAssemName);

                    Util.Log("URTInterface.ResolveTypes Is System "+Name+" iType "+((Enum)iType).ToString()+" baseIFaceNS "+baseIFaceNS);                                   
                    if ((iType != UrtType.Interop) && baseIFaceNS.StartsWith("System"))
                    {
                        iFace = new SystemInterface(baseIFaceName, baseIFaceNS);
                    }
                    else
                    {
                        URTNamespace ns = parser.LookupNamespace(baseIFaceXmlNS);
                        if(ns == null)
                        {
                            throw new SUDSParserException(
                                String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
                                              baseIFaceXmlNS));
                        }
                        iFace = ns.LookupInterface(baseIFaceName);
                        if(iFace == null)
                        {
                            throw new SUDSParserException(
                                String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
                                              baseIFaceName, baseIFaceXmlNS));
                        }
                    }
                    _baseIFaces.Add(iFace);
                }
                for(int i=0;i<_methods.Count;i++)
                    ((URTMethod) _methods[i]).ResolveTypes(parser);
            }
            internal void PrintCSC(TextWriter textWriter, String indentation,
                                 String curNS, StringBuilder sb)
            {
                Util.Log("URTInterface.PrintCSC name "+Name+" curNS "+curNS);               
                bool bURTType = IsURTInterface;
                if(bURTType == false)
                {
                    sb.Length = 0;
                    sb.Append(indentation);
                    sb.Append("[SoapType(XmlElementName=\"");
                    sb.Append(Name);
                    sb.Append("\", XmlNamespace=\"");
                    sb.Append(Namespace);
                    sb.Append("\", XmlTypeName=\"");
                    sb.Append(Name);
                    sb.Append("\", XmlTypeNamespace=\"");
                    sb.Append(Namespace);
                    sb.Append("\")]");
                    textWriter.WriteLine(sb);
                }

                sb.Length = 0;
                sb.Append(indentation);
                sb.Append("public interface ");
                sb.Append(Name);
                
                if(_baseIFaces.Count > 0)
                    sb.Append(" : ");

                if(_baseIFaces.Count > 0)
                {
                    sb.Append(((BaseInterface) _baseIFaces[0]).GetName(curNS));
                    for(int i=1;i<_baseIFaces.Count;i++)
                    {
                        sb.Append(((BaseInterface) _baseIFaces[i]).GetName(curNS));
                    }
                }

                textWriter.WriteLine(sb);

                textWriter.Write(indentation);
                textWriter.WriteLine('{');

                String newIndentation = indentation + "    ";
                String namePrefix = " ";
                Util.Log("URTInterface.PrintCSC method count "+_methods.Count);
                for(int i=0;i<_methods.Count;i++)
                {
                    Util.Log("URTInterface.PrintCSC Invoke methods PrintCSC");
                    ((URTMethod) _methods[i]).PrintCSC(textWriter, newIndentation,
                                                       namePrefix, curNS, false, bURTType,
                                                       null, sb);
                }
                textWriter.Write(indentation);
                textWriter.WriteLine('}');
            }
            internal override void PrintClassMethods(TextWriter textWriter,
                                                   String indentation,
                                                   String curNS,
                                                   ArrayList printedIFaces,
                                                   bool bProxy,
                                                   StringBuilder sb)
            {
                Util.Log("URTInterface.PrintClassMethods method "+Name+" curNS "+curNS+" bProxy "+bProxy);              
                // Return if the interface has already been printed
                for(int i=0;i<printedIFaces.Count;i++)
                {
                    if(printedIFaces[i] == this)
                    {
                        Util.Log("URTInterface.PrintClassMethods printedIFaces return "+Name);
                        return;
                    }
                }
                Util.Log("URTInterface.PrintClassMethods method 2 "+Name+" _methods.Count "+_methods.Count);                
                printedIFaces.Add(this);
                sb.Length = 0;
                sb.Append(indentation);
                if(_methods.Count > 0)
                {
                    sb.Append("// ");
                    sb.Append(Name);
                    sb.Append(" interface Methods");
                    textWriter.WriteLine(sb);

                    sb.Length = 0;
                    sb.Append(' ');
                    String ifaceName = GetName(curNS);
                    sb.Append(ifaceName);
                    sb.Append('.');
                    String namePrefix = sb.ToString();

                    String bodyPrefix = null;
                    if(bProxy)
                    {
                        sb.Length = 0;
                        sb.Append("((");
                        sb.Append(ifaceName);
                        sb.Append(") _tp).");
                        bodyPrefix = sb.ToString();
                    }
                    for(int i=0;i<_methods.Count;i++)
                    {
                        Util.Log("URTInterface.PrintClassMethods Invoke methods PrintCSC "+Name);
                        ((URTMethod) _methods[i]).PrintCSC(textWriter, indentation,
                                                           namePrefix, curNS, true,
                                                           true, bodyPrefix, sb);
                    }
                }

                for(int i=0;i<_baseIFaces.Count;i++)
                {
                    ((BaseInterface) _baseIFaces[i]).PrintClassMethods(textWriter,
                                                                       indentation,
                                                                       curNS,
                                                                       printedIFaces,
                                                                       bProxy, sb);
                }
            }

            private ArrayList _baseIFaces;
            private ArrayList _baseIFaceNames;
            private ArrayList _methods;
        }

        // Represents a field of a type
        internal class URTField
        {
            internal URTField(String name, String typeName, String xmlNS, SdlParser parser,
                            bool bPrimitive, bool bEmbedded, bool bAttribute, bool bOptional,
                            bool bArray, String arraySize)
            {
                Util.Log("URTField.URTField "+name+" typeName "+typeName+" xmlNS "+xmlNS+" bPrimitive "+bPrimitive+" bEmbedded "+bEmbedded+" bAttribute "+bAttribute);
                _name = name;
                _typeName = typeName;
                String typeAssemName;
                UrtType urtType = parser.IsURTExportedType(xmlNS, out _typeNS, out typeAssemName);
                if(urtType == UrtType.Interop)
                    _encodedNS = "InteropProxy";
                else
                 _encodedNS = _typeNS;
                _primitiveField = bPrimitive;
                _embeddedField = bEmbedded;
                _attributeField = bAttribute;
                _optionalField = bOptional;
                _arrayField = bArray;
                _arraySize = arraySize;
            }
            internal String Name
            {
                get { return(_name); }
            }
            internal String TypeName
            {
                get
                {
                    if(_arrayField)
                        return(_typeName + "[]");
                    return(_typeName);
                }
            }
            internal String TypeNS
            {
                get { return(_typeNS); }
            }
            internal String EncodedNS
            {
                get { return(_encodedNS); }
            }
            internal bool IsPrimitive
            {
                get { return(_primitiveField); }
            }
            internal bool IsEmbedded
            {
                get { return(_embeddedField); }
            }
            internal bool IsAttribute
            {
                get { return(_attributeField); }
            }
            internal bool IsArray
            {
                get { return(_arrayField); }
            }
            internal bool IsOptional
            {
                get { return(_optionalField); }
            }
            internal String GetTypeString(String curNS)
            {
                String type;
                if(SdlParser.Qualify(_typeNS, curNS))
                {
                    StringBuilder sb = new StringBuilder(_encodedNS, 50);
                    sb.Append('.');
                    sb.Append(TypeName);
                    type = sb.ToString();
                }
                else
                    type = TypeName;

                Util.Log("URTField.GetTypeString curNS "+curNS+" type "+type);              
                return(type);
            }
            internal void PrintCSC(TextWriter textWriter, String indentation,
                                 String curNS, StringBuilder sb)
            {
                Util.Log("URTField.PrintCSC name "+_name+" curNS"+curNS);               
                if(_embeddedField)
                {
                    textWriter.Write(indentation);
                    textWriter.WriteLine("[SoapField(Embedded=true)]");
                }

                sb.Length = 0;
                sb.Append(indentation);
                sb.Append("public ");
                sb.Append(GetTypeString(curNS));
                sb.Append(' ');
                sb.Append(_name);
                sb.Append(';');
                textWriter.WriteLine(sb);
            }

            private String _name;
            private String _typeName;
            private String _typeNS;
            private String _encodedNS;
            private bool _primitiveField;
            private bool _embeddedField;
            private bool _attributeField;
            private bool _optionalField;
            private bool _arrayField;
            private String _arraySize;
        }

        internal abstract class SchemaFacet
        {
            protected SchemaFacet()
            {
            }
            internal virtual void ResolveTypes(SdlParser parser)
            {
            }
            internal abstract void PrintCSC(TextWriter textWriter, String newIndentation,
                                          String curNS, StringBuilder sb);
        }

        internal class EnumFacet : SchemaFacet
        {
            internal EnumFacet(String valueString, int value)
            : base()
            {
                Util.Log("EnumFacet.EnumFacet valueString "+valueString+" value "+value);               
                _valueString = valueString;
                _value = value;
            }
            internal override void PrintCSC(TextWriter textWriter, String newIndentation,
                                          String curNS, StringBuilder sb)
            {
                Util.Log("EnumFacet.PrintCSC _valueString "+_valueString+" value "+_value+" curNS "+curNS);
                sb.Length = 0;
                sb.Append(newIndentation);
                sb.Append(_valueString);
                sb.Append(" = ");
                sb.Append(_value);
                sb.Append(',');
                textWriter.WriteLine(sb);
                return;
            }

            private String _valueString;
            private int _value;
        }

        // Represents a Base type
        internal abstract class BaseType
        {
            internal BaseType(String name, String ns, String encodedNS)
            {
                _name = name;
                _namespace = ns;
                _elementName = _name;
                _elementNS = ns;
                _encodedNS = encodedNS;
            }
            internal String Name
            {
                get { return(_name); }
            }
            internal String Namespace
            {
                get { return(_namespace); }
            }
            internal String ElementName
            {
                get { return(_elementName); }
                set { _elementName = value; }
            }
            internal String ElementNS
            {
                get { return(_elementNS); }
                set { _elementNS = value; }
            }
            internal bool IsURTType
            {
                get {
                    Util.Log("BaseType.IsURTType _namespace "+_namespace+" _encodedNS "+_encodedNS+" "+((Object) _namespace == (Object) _encodedNS));
                    return((Object) _namespace == (Object) _encodedNS); }
            }
            
            internal bool IsInteropType
            {
                get { return((Object) _namespace != (Object) _encodedNS); }
            }

            internal virtual String GetName(String curNS)
            {
                String name;
                if(MatchingStrings(_namespace, curNS))
                    name = _name;
                else
                {
                    StringBuilder sb = new StringBuilder(_encodedNS, 50);
                    sb.Append('.');
                    sb.Append(_name);
                    name = sb.ToString();
                }

                return(name);
            }
            internal abstract int GetMethodFlags(URTMethod method);
            internal abstract bool IsEmittableFieldType
            {
                get;
            }
            internal abstract String FieldName
            {
                get;
            }

            internal abstract String FieldNamespace
            {
                get;
            }

            internal abstract bool PrimitiveField
            {
                get;
            }

            private String _name;
            private String _namespace;
            private String _elementName;
            private String _elementNS;
            private String _encodedNS;
        }

        // Representa a system type
        internal class SystemType : BaseType
        {
            internal SystemType(String name, String ns, String assemName)
            : base(name, ns, ns)
            {
                Util.Log("SystemType.SystemType name "+name+" ns "+ns+" assemName "+assemName);             
                Debug.Assert(ns.StartsWith("System"), "Invalid System type");
                String fullName = ns + '.' + name;
                if(assemName != null)
                    fullName = fullName + ',' + assemName;
                _type = Type.GetType(fullName, true);
            }
            internal override int GetMethodFlags(URTMethod method)
            {
                BindingFlags bFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance |
                                      BindingFlags.Public | BindingFlags.NonPublic;
                Type type = _type;
                while(type != null)
                {
                    MethodInfo[] methods = type.GetMethods(bFlags);
                    for(int i=0;i<methods.Length;i++)
                    {
                        int methodFlags = method.GetMethodFlags(methods[i]);
                        if(methodFlags != 0)
                            return(methodFlags);
                    }
                    type = type.BaseType;
                }

                return(0);
            }
            internal override bool IsEmittableFieldType
            {
                get { return(true); }
            }

            internal override String FieldName
            {
                get { return(null); }
            }
            internal override String FieldNamespace
            {
                get { return(null); }
            }
            internal override bool PrimitiveField
            {
                get { return(false); }
            }

            private Type _type;
        }

        // Represents a simple type
        internal class URTSimpleType : BaseType
        {
            internal URTSimpleType(String name, String ns, String encodedNS, bool bAnonymous)
            : base(name, ns, encodedNS)
            {
                Util.Log("URTSimpleType.URTSimpleType name "+name+" ns "+ns+" encodedNS "+encodedNS+" bAnonymous "+bAnonymous);
                _baseTypeName = null;
                _baseTypeXmlNS = null;
                _baseType = null;
                _fieldString = null;
                _facets = new ArrayList();
                _bEnum = false;
                _bAnonymous = bAnonymous;
                _encoding = null;
            }

            internal void Extends(String baseTypeName, String baseTypeNS)
            {
                Util.Log("URTSimpleType.Extends baseTypeName "+baseTypeName+" baseTypeNS "+baseTypeNS);
                _baseTypeName = baseTypeName;
                _baseTypeXmlNS = baseTypeNS;

            }

            internal bool IsEnum
            {
                get { return(_bEnum); }
                set { _bEnum = value; }
            }

            internal String Encoding
            {
                get { return (_encoding); }
                set { _encoding = value; }
            }

            internal void AddFacet(SchemaFacet facet)
            {
                Util.Log("URTSimpleType.AddFacet");
                _facets.Add(facet);
            }

            internal bool IsAnonymous
            {
                get {return _bAnonymous;}
            }

            internal override bool IsEmittableFieldType
            {
                get
                {
                    if(_fieldString == null)
                    {
                        if((_bAnonymous == true) &&
                   (_facets.Count == 0) &&
                   (_encoding != null) &&
                   (_baseTypeName == "binary") &&
                   (_baseTypeXmlNS == s_schemaNamespaceString))
                            _fieldString = "byte[]";
                else
                            _fieldString = String.Empty;
                    }

                    return(_fieldString != String.Empty);
                }
            }
            internal override String FieldName
            {
                get { return(_fieldString); }
            }

            internal override String FieldNamespace
            {
                get { return(s_schemaNamespaceString); }
            }

            internal override bool PrimitiveField
            {
                get { return(true); }
            }

            internal override String GetName(String curNS)
            {
                if((_fieldString != null) && (_fieldString != String.Empty))
                    return(_fieldString);

                Util.Log("URTSimpleType.GetName curNS "+curNS+" return "+base.GetName(curNS));              
                return(base.GetName(curNS));
            }

            internal void ResolveTypes(SdlParser parser)
            {
                Util.Log("URTSimpleType.ResolveTypes "+Name);               
                if(_baseTypeName != null)
                {
                    if(SdlParser.IsPrimitiveType(_baseTypeXmlNS, _baseTypeName))
                    {
                        if(IsEnum == false)
                            _baseName = SdlParser.MapSchemaTypesToCSharpTypes(_baseTypeName);
                    }
                    else
                    {
                        URTNamespace ns = parser.LookupNamespace(_baseTypeXmlNS);
                        if(ns == null)
                        {
                            throw new SUDSParserException(
                                String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
                                              _baseTypeXmlNS));
                        }
                        _baseType = ns.LookupComplexType(_baseTypeName);
                        if(_baseType == null)
                        {
                            throw new SUDSParserException(
                                String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
                                              _baseTypeName, _baseTypeXmlNS));
                        }
                    }
                }

                for(int i=0;i<_facets.Count;i++)
                    ((SchemaFacet) _facets[i]).ResolveTypes(parser);

                return;
            }
            internal void PrintCSC(TextWriter textWriter, String indentation,
                                 String curNS, StringBuilder sb)
            {
                Util.Log("URTSimpleType.PrintCSC name "+Name+" curNS "+curNS);                              
                // Print only if the type is not an emittable field type
                if (IsEmittableFieldType == true)
                    return;

                // Handle encoding
                if(_encoding != null)
                {
                    // sb.Length = 0;
                    // sb.Append(indentation);
                }

                // Print type
                sb.Length = 0;
                sb.Append(indentation);

                // Handle Enum case
                if(IsEnum)
                    sb.Append("public enum ");
                else
                    sb.Append("public class ");
                sb.Append(Name);
                if(_baseType != null)
                {
                    sb.Append(" : ");
                    sb.Append(_baseType.GetName(curNS));
                }
                else if(_baseName != null)
                {
                    sb.Append(" : ");
                    sb.Append(_baseName);
                }
                textWriter.WriteLine(sb);

                textWriter.Write(indentation);
                textWriter.WriteLine('{');

                String newIndentation = indentation + "    ";
                for(int i=0;i<_facets.Count;i++)
                {
                    Util.Log("URTSimpleType.PrintCSC Invoke _facets PrintCSC ");                                                                                                        
                    ((SchemaFacet) _facets[i]).PrintCSC(textWriter, newIndentation, curNS, sb);
                }

                textWriter.Write(indentation);
                textWriter.WriteLine('}');

                return;
            }
            internal override int GetMethodFlags(URTMethod method)
            {
                Debug.Assert(false, "GetMethodFlags called on a SimpleSchemaType");
                return(0);
            }

            private String _baseTypeName;
            private String _baseTypeXmlNS;
            private BaseType _baseType;
            private String _baseName;
            private String _fieldString;
            private bool  _bEnum;
            private bool _bAnonymous;
            private String _encoding;
            private ArrayList _facets;
        }

        // Represents a complex type
        internal class URTComplexType : BaseType
        {
            internal URTComplexType(String name, String ns, String encodedNS,
                                  SchemaBlockType blockDefault, bool bSUDSType, bool bAnonymous)
            : base(name, ns, encodedNS)
            {
                Util.Log("URTComplexType.URTComplexType name "+name+" ns "+ns+" encodedNS "+encodedNS+" bSUDStype "+bSUDSType+" bAnonymous "+bAnonymous);
                _baseTypeName = null;
                _baseTypeXmlNS = null;
                _baseType = null;
                _connectURLs = null;
                _bStruct = !bSUDSType;
                _blockType = blockDefault;
                _bSUDSType = bSUDSType;
                _bAnonymous = bAnonymous;
                Debug.Assert(bAnonymous == false || _bSUDSType == false);
                _fieldString = null;
                _fields = new ArrayList();
                _methods = new ArrayList();
                _implIFaces = new ArrayList();
                _implIFaceNames = new ArrayList();
                _sudsType = SUDSType.None;              
            }
            internal void Extends(String baseTypeName, String baseTypeNS)
            {
                Util.Log("URTComplexType.Extends baseTypeName "+baseTypeName+" baseTypeNS "+baseTypeNS);
                _baseTypeName = baseTypeName;
                _baseTypeXmlNS = baseTypeNS;
            }
            internal void Implements(String iFaceName, String iFaceNS, SdlParser parser)
            {
                Util.Log("URTComplexType.Implements IFaceName "+iFaceName+" iFaceNS "+iFaceNS);
                _implIFaceNames.Add(iFaceName);
                _implIFaceNames.Add(iFaceNS);
                // Urt namespace will not have schema, they need to be recorded.
                URTNamespace parsingNamespace = parser.LookupNamespace(iFaceNS);
                if(parsingNamespace == null)
                {
                    parsingNamespace = new URTNamespace(iFaceNS, parser);
                    parser._URTNamespaces.Add(parsingNamespace);
                }

                URTInterface parsingInterface = parsingNamespace.LookupInterface(iFaceName);            
                if(parsingInterface == null)
                {
                    parsingInterface = new URTInterface(iFaceName, parsingNamespace.Namespace, parsingNamespace.EncodedNS);                 
                    parsingNamespace.AddInterface(parsingInterface);
                }
            }
            internal ArrayList ConnectURLs
            {
                get { return(_connectURLs); }
                set {
                        _connectURLs = value;
                    }
            }
            internal bool IsStruct
            {
                get { return(_bStruct); }
                set { _bStruct = value; }
            }
            internal bool IsSUDSType
            {
                get { return(_bSUDSType); }
                set { _bSUDSType = value; _bStruct = !value; }
            }
            internal SUDSType SUDSType
            {
                get { return(_sudsType); }
                set { _sudsType = value; }
            }
            internal SchemaBlockType BlockType
            {
                get { return(_blockType); }
                set { _blockType = value; }
            }
            internal bool IsAnonymous
            {
                get {return _bAnonymous;}
            }           
            internal override bool IsEmittableFieldType
            {
                get
                {
                    Util.Log("URTComplexType.IsEmittableFieldType _fieldString "+_fieldString+" _bAnonymous "+_bAnonymous+" _fields.Count "+_fields.Count);
                    if(_fieldString == null)
                    {
                        if((_bAnonymous == true) &&
                           (_fields.Count == 1))
                        {
                            URTField field = (URTField) _fields[0];
                            if(field.IsArray)
                            {
                                _fieldString = field.TypeName;
                                return(true);
                            }
                        }
                        _fieldString = String.Empty;
                    }

                    return(_fieldString != String.Empty);
                }
            }
            internal override String FieldName
            {
                get { return(_fieldString); }
            }
            internal override String FieldNamespace
            {
                get { return(((URTField) _fields[0]).TypeNS); }
            }
            internal override bool PrimitiveField
            {
                get { return((((URTField) _fields[0]).IsPrimitive)); }
            }
            internal override String GetName(String curNS)
            {
                if((_fieldString != null) && (_fieldString != String.Empty))
                    return(_fieldString);

                return(base.GetName(curNS));
            }
            internal ArrayList Fields
            {
                get { return _fields; }
            }
            internal ArrayList Methods
            {
                get { return _methods; }
            }
            internal void AddField(URTField field)
            {
                Util.Log("URTComplexType.AddField");
                _fields.Add(field);
            }
            internal void AddMethod(URTMethod method)
            {
                Util.Log("URTComplexType.AddMethod "+method);               
                _methods.Add(method);
            }
            private URTMethod GetMethod(String name)
            {
                Util.Log("URTComplexType.GetMethod "+name);                             
                for(int i=0;i<_methods.Count;i++)
                {
                    URTMethod method = (URTMethod) _methods[i];
                    if(method.Name == name)
                        return(method);
                }

                return(null);
            }
            internal void ResolveTypes(SdlParser parser)
            {
                Util.Log("URTComplexType.ResolveTypes "+Name+" _baseTypeName "+_baseTypeName+" IsSUDSType "+IsSUDSType);
                String baseTypeNS = null;
                String baseTypeAssemName = null;
                if(_baseTypeName != null)
                {
                    Util.Log("URTComplexType.ResolveTypes 1 ");
                    UrtType urtType = parser.IsURTExportedType(_baseTypeXmlNS, out baseTypeNS, out baseTypeAssemName);
                    if ((urtType == UrtType.Interop) && baseTypeNS.StartsWith("System"))
                    {
                        _baseType = new SystemType(_baseTypeName, baseTypeNS, baseTypeAssemName);
                    }
                    else
                    {
                        URTNamespace ns = parser.LookupNamespace(_baseTypeXmlNS);
                        if(ns == null)
                        {
                            throw new SUDSParserException(
                                String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
                                              _baseTypeXmlNS));
                        }
                        _baseType = ns.LookupComplexType(_baseTypeName);
                        if(_baseType == null)
                        {
                            throw new SUDSParserException(
                                String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
                                              _baseTypeName, _baseTypeXmlNS));
                        }
                    }
                }
                else if(IsSUDSType)
                {
                    Util.Log("URTComplexType.ResolveTypes 2 SUDSType "+ ((Enum)_sudsType).ToString());                  
                    if (_sudsType == SUDSType.ClientProxy)
                    {
                        Util.Log("URTComplexType.ResolveTypes 3 ");                     
                        _baseTypeName = "RemotingClientProxy";
                        //_baseTypeXmlNS = "http://schemas.microsoft.com/urt/NSAssem/System.Runtime.Remoting/System.Runtime.Remoting";
                        _baseTypeXmlNS = SoapServices.CodeXmlNamespaceForClrTypeNamespace("System.Runtime.Remoting","System.Runtime.Remoting");
                        baseTypeNS = "System.Runtime.Remoting.Services";
                        baseTypeAssemName = "System.Runtime.Remoting";
                    }
                    else if (_sudsType == SUDSType.MarshalByRef)
                    {
                        Util.Log("URTComplexType.ResolveTypes 4 ");                                             
                        _baseTypeName = "MarshalByRefObject";
                        //_baseTypeXmlNS = "http://schemas.microsoft.com/urt/NS/System";
                        _baseTypeXmlNS = SoapServices.CodeXmlNamespaceForClrTypeNamespace("System", null);
                        baseTypeNS = "System";
                        baseTypeAssemName = null;
                    }
                    _baseType = new SystemType(_baseTypeName, baseTypeNS, baseTypeAssemName);
                }
                else
                {
                    Util.Log("URTComplexType.ResolveTypes 5 ");                                         
                    _baseType = new SystemType("Object", "System", null);
                }
                for(int i=0;i<_implIFaceNames.Count;i=i+2)
                {
                    String implIFaceName = (String) _implIFaceNames[i];
                    String implIFaceXmlNS = (String) _implIFaceNames[i+1];
                    String implIFaceNS, implIFaceAssemName;
                    BaseInterface iFace;


                    UrtType iType = parser.IsURTExportedType(implIFaceXmlNS, out implIFaceNS,
                                                         out implIFaceAssemName);

                    if ((iType == UrtType.UrtSystem) && implIFaceNS.StartsWith("System"))
                    {
                        iFace = new SystemInterface(implIFaceName, implIFaceNS);
                    }
                    else
                    {
                        URTNamespace ns = parser.LookupNamespace(implIFaceXmlNS);
                        if(ns == null)
                        {
                            throw new SUDSParserException(
                                String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
                                              implIFaceXmlNS));
                        }
                        iFace = ns.LookupInterface(implIFaceName);
                        if(iFace == null)
                        {
                            throw new SUDSParserException(
                                String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
                                              implIFaceName, implIFaceXmlNS));
                        }
                    }
                    _implIFaces.Add(iFace);
                }
                for(int i=0;i<_methods.Count;i++)
                    ((URTMethod) _methods[i]).ResolveTypes(parser);
            }
            internal void ResolveMethods()
            {
                Util.Log("URTComplexType.ResolveMethods "+Name);                
                for(int i=0;i<_methods.Count;i++)
                {
                    URTMethod method = (URTMethod) _methods[i];
                    if(method.MethodFlags == 0)
                        method.MethodFlags = _baseType.GetMethodFlags(method) | 1;
                }

                return;
            }
            internal override int GetMethodFlags(URTMethod method)
            {
                Debug.Assert(method.MethodFlags == 0, "Method has already been considered");

                int methodFlags = _baseType.GetMethodFlags(method) | 1;
                for(int i=0;i<_methods.Count;i++)
                {
                    URTMethod thisMethod = (URTMethod) _methods[i];
                    if(thisMethod.Equals(method))
                        thisMethod.MethodFlags = methodFlags | 1;
                }

                return(methodFlags);
            }
            internal void PrintCSC(TextWriter textWriter, String indentation,
                                 String curNS, StringBuilder sb)
            {
                Util.Log("URTComplexType.PrintCSC name "+Name+" curNS "+curNS);
                // Print only if the type is not an emittable field type
                if (IsEmittableFieldType == true)
                    return;

                // Handle delegate case
                sb.Length = 0;
                sb.Append(indentation);
                if(_baseTypeName != null)
                {
                    String baseName = _baseType.GetName(curNS);
                    if((baseName == "System.Delegate") || (baseName == "System.MulticastDelegate"))
                    {
                        sb.Append("public delegate ");
                        URTMethod invokeMethod = GetMethod("Invoke");
                        if(invokeMethod == null)
                        {
                            throw new SUDSParserException(
                                CoreChannel.GetResourceString("Remoting_Suds_DelegateWithoutInvoke"));
                        }
                        sb.Append(invokeMethod.GetTypeString(curNS));
                        sb.Append(' ');
                        sb.Append(Name);
                        sb.Append('(');
                        invokeMethod.PrintSignature(sb, curNS);
                        sb.Append(");");
                        textWriter.WriteLine(sb);
                        return;
                    }
                }

                bool bURTType = IsURTType;
                if(bURTType == false)
                {
                    sb.Length = 0;
                    sb.Append(indentation);
                    sb.Append("[SoapType(XmlElementName=\"");
                    sb.Append(ElementName);
                    sb.Append("\", XmlNamespace=\"");
                    sb.Append(Namespace);
                    sb.Append("\", XmlTypeName=\"");
                    sb.Append(Name);
                    sb.Append("\", XmlTypeNamespace=\"");
                    sb.Append(Namespace);
                    sb.Append("\")]");
                    textWriter.WriteLine(sb);
                }

                sb.Length = 0;
                sb.Append(indentation);
                if(IsStruct == true)
                    sb.Append("public struct ");
                else
                    sb.Append("public class ");
                sb.Append(Name);
                if(_baseTypeName != null)               
                    sb.Append(" : ");
                bool bBaseIsURTType = true;
                if(_baseTypeName != null)
                {
                    bBaseIsURTType = _baseType.IsURTType;
                    String baseString = _baseType.GetName(curNS);
                    if(baseString == "System.__ComObject")
                    {
                        /*textWriter.Write(indentation);
                        textWriter.WriteLine("[guid(\"cc3bf020-1881-4e44-88d8-39b1052b1b11\")]");
                        textWriter.Write(indentation);
                        textWriter.WriteLine("[comimport]"); */
                        sb.Append("System.MarshalByRefObject");
                    }
                    else
                    {
                        sb.Append(baseString);
                    }
                }
                
                if(_implIFaces.Count > 0)
                {
                    for(int i=0;i<_implIFaces.Count;i++)
                    {
                        sb.Append(", ");
                        sb.Append(((BaseInterface) _implIFaces[i]).GetName(curNS));
                    }
                }
                textWriter.WriteLine(sb);

                textWriter.Write(indentation);
                textWriter.WriteLine('{');

                String newIndentation = indentation + "    ";
                int newIndentationLength = newIndentation.Length;
                //bool fClientProxy = _connectURL != null;

                Util.Log("URTComplexType.PrintCSC _sudsType "+((Enum)_sudsType).ToString());
                bool fClientProxy = (_sudsType == SUDSType.ClientProxy);
                if(fClientProxy)
                {
                    sb.Length = 0;
                    sb.Append(newIndentation);
                    sb.Append("// Constructor");
                    textWriter.WriteLine(sb);

                    sb.Length = newIndentationLength;
                    sb.Append("public ");
                    sb.Append(Name);
                    sb.Append("()");
                    textWriter.WriteLine(sb);

                    sb.Length = newIndentationLength;
                    sb.Append('{');
                    textWriter.WriteLine(sb);

                    if (_connectURLs != null)
                    {
                        for (int i=0; i<_connectURLs.Count; i++)
                        {
                            sb.Length = newIndentationLength;
                            sb.Append("    ");
                            if (i == 0)
                            {
                                sb.Append("base.ConfigureProxy(this.GetType(), \"");
                                sb.Append(_connectURLs[i]);
                                sb.Append("\");");
                            }
                            else
                            {
                                // Only the first location is used, the rest are commented out in the proxy
                                sb.Append("//base.ConfigureProxy(this.GetType(), \"");
                                sb.Append(_connectURLs[i]);
                                sb.Append("\");");
                            }
                            textWriter.WriteLine(sb);
                        }
                    }

                    sb.Length = newIndentationLength;
                    sb.Append('}');
                    textWriter.WriteLine(sb);
                }

                if(_methods.Count > 0)
                {
                    textWriter.Write(newIndentation);
                    textWriter.WriteLine("// Class Methods");
                    String bodyPrefix = null;
                    if(fClientProxy)
                    {
                        sb.Length = 0;
                        sb.Append("((");
                        sb.Append(Name);
                        sb.Append(") _tp).");
                        bodyPrefix = sb.ToString();
                    }
                    for(int i=0;i<_methods.Count;i++)
                    {
                        Util.Log("URTComplexType.PrintCSC Invoke methods PrintCSC ");
                        ((URTMethod) _methods[i]).PrintCSC(textWriter, newIndentation,
                                                           " ", curNS, true, bURTType,
                                                           bodyPrefix, sb);
                    }
                    textWriter.WriteLine();
                }

                if(_implIFaces.Count > 0)
                {
                    ArrayList printedIFaces = new ArrayList(_implIFaces.Count);
                    for(int i=0;i<_implIFaces.Count;i++)
                        ((BaseInterface) _implIFaces[i]).PrintClassMethods(textWriter,
                                                                           newIndentation,
                                                                           curNS,
                                                                           printedIFaces,
                                                                           fClientProxy,
                                                                           sb);
                    textWriter.WriteLine();
                }

                if(_fields.Count > 0)
                {
                    textWriter.Write(newIndentation);
                    textWriter.WriteLine("// Class Fields");
                    for(int i=0;i<_fields.Count;i++)
                    {
                        Util.Log("URTComplexType.PrintCS Invoke _fields PrintCSC");                                                                                                         
                        ((URTField) _fields[i]).PrintCSC(textWriter, newIndentation, curNS, sb);
                    }
                }
                // Close class
                sb.Length = 0;
                sb.Append(indentation);
                sb.Append("}");
                textWriter.WriteLine(sb);
                return;
            }

            private String _baseTypeName;
            private String _baseTypeXmlNS;
            private BaseType _baseType;
            private ArrayList _connectURLs;
            private bool _bStruct;
            private SchemaBlockType _blockType;
            private bool _bSUDSType;
            private bool _bAnonymous;
            private String _fieldString;
            private ArrayList _implIFaceNames;
            private ArrayList _implIFaces;
            private ArrayList _fields;
            private ArrayList _methods;
            private SUDSType _sudsType;
        }

        // Represents an XML element declaration
        internal class ElementDecl
        {
            // Constructor
            public ElementDecl(String elmName, String elmNS, String typeName, String typeNS,
                               bool bPrimitive)
            {
                Util.Log("ElementDecl.ElementDecl elmName "+elmName+" elmNS "+elmNS+" typeName "+typeName+" typeNS "+typeNS+" bPrimitive "+bPrimitive);
                _elmName = elmName;
                _elmNS = elmNS;
                _typeName = typeName;
                _typeNS = typeNS;
                _bPrimitive = bPrimitive;
            }

            // Field accessors
            public String Name
            {
                get { return(_elmName); }
            }
            public String Namespace
            {
                get { return(_elmNS); }
            }
            public String TypeName
            {
                get { return(_typeName); }
            }
            public String TypeNS
            {
                get { return(_typeNS); }
            }

            public void Resolve(SdlParser parser)
            {
                Util.Log("ElementDecl.Resolve "+TypeName+" "+TypeNS);
                // Return immediatly for element declaration of primitive types
                if(_bPrimitive)
                    return;

                // Lookup the type from the element declaration
                URTNamespace typeNS = parser.LookupNamespace(TypeNS);
                if(typeNS == null)
                {
                    throw new SUDSParserException(
                        String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
                                      TypeNS));
                }
                BaseType type = typeNS.LookupType(TypeName);
                if(type == null)
                {
                    throw new SUDSParserException(
                        String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
                                      TypeName, TypeNS));
                }

                type.ElementName = Name;
                type.ElementNS = Namespace;

                return;
            }

            // Fields
            private String _elmName;
            private String _elmNS;
            private String _typeName;
            private String _typeNS;
            private bool _bPrimitive;
        }

        // Represents a namespace
        internal class URTNamespace
        {
            // Constructor
            public URTNamespace(String name, SdlParser parser)
            {
                Util.Log("URTNamespace.URTNamespace name "+name);
                _name = name;
                _nsType = parser.IsURTExportedType(name, out _namespace, out _assemName);
                if(_nsType == UrtType.Interop)
                    _encodedNS = "InteropProxy";
                else
                    _encodedNS = _namespace;
                _elmDecls = new ArrayList();
                _URTComplexTypes = new ArrayList();
                _numURTComplexTypes = 0;
                _URTSimpleTypes = new ArrayList();
                _numURTSimpleTypes = 0;
                _URTInterfaces = new ArrayList();
                _anonymousSeqNum = 0;
            }

            // Get the next anonymous type name
            public String GetNextAnonymousName()
            {
                ++_anonymousSeqNum;
                Util.Log("URTNamespace.GetNextAnonymousName AnonymousType"+_anonymousSeqNum+" ComplexType "+_name);
                return("AnonymousType" + _anonymousSeqNum);
            }

            // Add a new element declaration to the namespace
            public void AddElementDecl(ElementDecl elmDecl)
            {
                Util.Log("URTNamespace.AddElementDecl ");
                _elmDecls.Add(elmDecl);
            }

            // Add a new type into the namespace
            public void AddComplexType(URTComplexType type)
            {
                Util.Log("URTNamespace.AddComplexType "+type.Name);
                // Assert that simple and complex types share the same namespace
                Debug.Assert(LookupSimpleType(type.Name) == null,
                             "Complex type has the same name as a simple type");
                _URTComplexTypes.Add(type);
                ++_numURTComplexTypes;
            }

            // Add a new type into the namespace
            public void AddSimpleType(URTSimpleType type)
            {
                Util.Log("URTNamespace.AddSimpleType "+type.Name);              
                // Assert that simple and complex types share the same namespace
                Debug.Assert(LookupComplexType(type.Name) == null,
                             "Simple type has the same name as a complex type");
                _URTSimpleTypes.Add(type);
                ++_numURTSimpleTypes;
            }

            // Adds a new interface into the namespace
            public void AddInterface(URTInterface iface)
            {
                Util.Log("URTNamespace.AddInterface "+iface.Name);              
                _URTInterfaces.Add(iface);
            }

            // Returns the namespace
            public String Namespace
            {
                get { return(_namespace); }
            }

            // Returns Encoded namespace
            public String EncodedNS
            {
                get { return(_encodedNS); }
            }

            // Returns the full name
            public String Name
            {
                get { return(_name); }
            }

            // Returns Assembly name
            public String AssemName
            {
                get { return(_assemName); }
            }

            public UrtType UrtType
            {
                get { return _nsType;}
            }

            // Returns true if this represents a URTNamespace
            public bool IsURTNamespace
            {
                get { return((Object) _namespace == (Object) _encodedNS); }
            }

            // Returns true if the namespace has no types defined
            public bool IsEmpty
            {
                get{
                    bool isEmpty = true;
                    if ((_numURTComplexTypes == 0) &&
                          (_URTInterfaces.Count == 0) &&
                          (_numURTSimpleTypes == 0))
                        isEmpty = true;
                    else
                        isEmpty = false;

                    /*
                    if (_numURTComplexTypes > 0)
                    {
                        for(int i=0;i<_URTComplexTypes.Count;i++)
                        {
                            URTComplexType type = (URTComplexType) _URTComplexTypes[i];
                            if ((type != null) && (!type.IsAnonymous))
                            {
                                isEmpty = false;
                                break;
                            }
                        }

                        if (isEmpty)
                        {
                            for(int i=0;i<_URTSimpleTypes.Count;i++)
                            {
                                URTSimpleType type = (URTSimpleType) _URTSimpleTypes[i];
                                if ((type != null) && (!type.IsAnonymous))
                                {
                                    isEmpty = false;
                                    break;
                                }
                            }
                        }
                    }
                    */
                    return isEmpty;
                }
            }

            // Looks up a element declaration
            public ElementDecl LookupElementDecl(String name)
            {
                Util.Log("URTNamespace.LookupElementDecl "+name);               
                for(int i=0;i<_elmDecls.Count;i++)
                {
                    ElementDecl elm = (ElementDecl) _elmDecls[i];
                    if(elm.Name == name)
                        return(elm);
                }

                return(null);
            }

            // Looks up a complex type
            public URTComplexType LookupComplexType(String typeName)
            {
                Util.Log("URTNamespace.LookupComplexType "+typeName);               
                for(int i=0;i<_URTComplexTypes.Count;i++)
                {
                    URTComplexType type = (URTComplexType) _URTComplexTypes[i];
                    if((type != null) && SdlParser.MatchingStrings(type.Name, typeName))
                        return(type);
                }

                return(null);
            }

            // Looks up a simple type
            public URTSimpleType LookupSimpleType(String typeName)
            {
                Util.Log("URTNamespace.LookupSimpleType "+typeName);                                
                for(int i=0;i<_URTSimpleTypes.Count;i++)
                {
                    URTSimpleType type = (URTSimpleType) _URTSimpleTypes[i];
                    if((type != null) && SdlParser.MatchingStrings(type.Name, typeName))
                        return(type);
                }

                return(null);
            }

            // Looks up a complex or simple type
            public BaseType LookupType(String typeName)
            {
                BaseType type = LookupComplexType(typeName);
                if(type == null)
                    type = LookupSimpleType(typeName);

                return(type);
            }

            // Removes the given type from the namespace
            public void RemoveComplexType(URTComplexType type)
            {
                Util.Log("URTNamespace.RemoveComplexType "+type.Name+" complex Type "+_name);
                for(int i=0;i<_URTComplexTypes.Count;i++)
                {
                    Util.Log("URTNamespace.RemoveComplexType 1 "+type.Name+" complexTypes "+((_URTComplexTypes[i] != null) ? ((URTComplexType)_URTComplexTypes[i]).Name : "Null"));                 
                    if(_URTComplexTypes[i] == type)
                    {
                        Util.Log("URTNamespace.RemoveComplexType 2 match "+type.Name+" complexTypes "+((_URTComplexTypes[i] != null) ? ((URTComplexType)_URTComplexTypes[i]).Name : "Null"));                                       
                        _URTComplexTypes[i] = null;
                        --_numURTComplexTypes;
                        return;
                    }
                }

                throw new SUDSParserException(
                    CoreChannel.GetResourceString("Remoting_Suds_TriedToRemoveNonexistentType"));
            }

            // Removes the given type from the namespace
            public void RemoveSimpleType(URTSimpleType type)
            {
                Util.Log("URTNamespace.RemoveSimpleType "+type.Name+" SimpleType "+_name);              
                for(int i=0;i<_URTSimpleTypes.Count;i++)
                {
                    if(_URTSimpleTypes[i] == type)
                    {
                        _URTSimpleTypes[i] = null;
                        --_numURTSimpleTypes;
                        return;
                    }
                }

                throw new SUDSParserException(
                    CoreChannel.GetResourceString("Remoting_Suds_TriedToRemoveNonexistentType"));
            }

            // Looks up an interface
            public URTInterface LookupInterface(String iFaceName)
            {
                Util.Log("URTNamespace.LookupInterface "+iFaceName);
                for(int i=0;i<_URTInterfaces.Count;i++)
                {
                    URTInterface iFace = (URTInterface) _URTInterfaces[i];
                    if(SdlParser.MatchingStrings(iFace.Name, iFaceName))
                        return(iFace);
                }

                return(null);
            }

            // Resolve element references
            public void ResolveElements(SdlParser parser)
            {
                Util.Log("URTNamespace.ResolveElements "+Name);
                for(int i=0;i<_elmDecls.Count;i++)
                    ((ElementDecl) _elmDecls[i]).Resolve(parser);
            }

            // Resolves internal references
            public void ResolveTypes(SdlParser parser)
            {
                Util.Log("URTNamespace.ResolveTypes "+Name);
                for(int i=0;i<_URTComplexTypes.Count;i++)
                {
                    if(_URTComplexTypes[i] != null)
                        ((URTComplexType)_URTComplexTypes[i]).ResolveTypes(parser);
                }

                for(int i=0;i<_URTInterfaces.Count;i++)
                    ((URTInterface)_URTInterfaces[i]).ResolveTypes(parser);
            }

            // Resolves method types
            public void ResolveMethods()
            {
                Util.Log("URTNamespace.ResolveMethods "+Name);              
                for(int i=0;i<_URTComplexTypes.Count;i++)
                {
                    if(_URTComplexTypes[i] != null)
                        ((URTComplexType)_URTComplexTypes[i]).ResolveMethods();
                }
            }

            // Prints all the types in the namespace
            public void PrintCSC(TextWriter textWriter)
            {
                Util.Log("URTNamespace.PrintCSC "+Namespace);               
                Debug.Assert(!IsEmpty, "Empty namespace " + Name + " being printed");
                String indentation = String.Empty;
                if ((Namespace != null) &&
                    (Namespace.Length != 0))
                {
                    textWriter.Write("namespace ");
                    textWriter.Write(EncodedNS);
                    textWriter.WriteLine(" {");
                    indentation = "    ";
                }
                textWriter.WriteLine("using System;");
                textWriter.WriteLine("using System.Runtime.Remoting.Messaging;");
                textWriter.WriteLine("using System.Runtime.Remoting.Metadata;");

                StringBuilder sb = new StringBuilder(256);
                if(_numURTComplexTypes > 0)
                {
                    for(int i=0;i<_URTComplexTypes.Count;i++)
                    {
                        URTComplexType type = (URTComplexType) _URTComplexTypes[i];
                        if(type != null)
                        {
                            Util.Log("URTNamespace.PrintCSC Invoke Complex type PrintCSC");                                                                                                             
                            type.PrintCSC(textWriter, indentation, Namespace, sb);
                        }
                    }
                }

                if(_numURTSimpleTypes > 0)
                {
                    for(int i=0;i<_URTSimpleTypes.Count;i++)
                    {
                        URTSimpleType type = (URTSimpleType) _URTSimpleTypes[i];
                        if(type != null)
                        {
                            Util.Log("URTNamespace.PrintCSC Invoke Simple type PrintCSC");                                                                                                                                          
                            type.PrintCSC(textWriter, indentation, Namespace, sb);
                        }
                    }
                }

                for(int i=0;i<_URTInterfaces.Count;i++)
                {
                    Util.Log("URTNamespace.PrintCSC Invoke Interfaces PrintCSC");                                                                                                                                   
                    ((URTInterface)_URTInterfaces[i]).PrintCSC(textWriter, indentation, Namespace, sb);
                }

                if ((Namespace != null) &&
                    (Namespace.Length != 0))
                    textWriter.WriteLine('}');

                return;
            }

            // Fields
            private String _name;
            private UrtType _nsType;
            private String _namespace;
            private String _encodedNS;
            private String _assemName;
            private int _anonymousSeqNum;
            private ArrayList _elmDecls;
            private ArrayList _URTComplexTypes;
            private int _numURTComplexTypes;
            private ArrayList _URTSimpleTypes;
            private int _numURTSimpleTypes;
            private ArrayList _URTInterfaces;
        }

    }
                    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\system\security\cryptography\xml\keyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------
//
// CLASS:    KeyInfo.cs       
// 
// DATE:     21 March 2000
// 
//---------------------------------------------------------------------------

namespace System.Security.Cryptography.Xml 
{
    using System;
    using System.Text;
    using System.Xml;
    using System.Collections;
    using System.Security;
    using System.Security.Cryptography;
    using System.Security.Cryptography.X509Certificates;

    /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfo"]/*' />
    public class KeyInfo : IEnumerable
    {
        internal String m_strId = null;
        internal ArrayList m_KeyInfoClauses;

        //-------------------------- Constructors -------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfo.KeyInfo"]/*' />
        public KeyInfo() 
        {
            m_KeyInfoClauses = new ArrayList();
        }
    
        //--------------------------- Properties --------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfo.Id"]/*' />
        public String Id
        {
            get { return m_strId; }
            set { m_strId = value; }
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfo.GetXml"]/*' />
        public XmlElement GetXml() {
            XmlDocument xmlDocument = new XmlDocument();

            // Create the KeyInfo element itself
            XmlElement keyInfoElement = xmlDocument.CreateElement("KeyInfo",SignedXml.XmlDsigNamespaceUrl);
            if (m_strId != null) {
                keyInfoElement.SetAttribute("Id", m_strId);
            }
                
            // Add all the clauses that go underneath it
            for (int i = 0; i < m_KeyInfoClauses.Count; ++i) {
                XmlElement xmlElement = ((KeyInfoClause) m_KeyInfoClauses[i]).GetXml();
                if (xmlElement != null) {
                    keyInfoElement.AppendChild(xmlDocument.ImportNode(xmlElement,true));
                }
            }

            return keyInfoElement;
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfo.LoadXml"]/*' />
        public void LoadXml(XmlElement value) {
            // Guard against nulls
            if (value == null)
                throw new ArgumentNullException("value");

            // Validate what we are passed against the DTD

            XmlElement keyInfoElement = value;
            if (keyInfoElement.HasAttribute("Id")) {
                m_strId = keyInfoElement.GetAttribute("Id");
            }
                
            XmlNodeList nodeList = keyInfoElement.ChildNodes;
            foreach (XmlNode node in nodeList) {
                XmlElement elem = node as XmlElement;
                // We only care about XmlElement nodes here
                if (elem == null) continue;
                // Create the right type of KeyInfoClause
                // We use a combination of the namespace and tag name (local name)
                String kicString = elem.NamespaceURI+" "+elem.LocalName;
                // Special-case handling for KeyValue -- we have to go one level deeper
                if (kicString == "http://www.w3.org/2000/09/xmldsig# KeyValue") {
                    XmlNodeList nodeList2 = elem.ChildNodes;
                    foreach (XmlNode node2 in nodeList2) {
                        XmlElement elem2 = node2 as XmlElement;
                        if (elem2 != null) {
                            kicString += "/"+elem2.LocalName;
                            break;
                        }
                    }
                }
                KeyInfoClause keyInfoClause = (KeyInfoClause) CryptoConfig.CreateFromName(kicString);
                // if we don't know what kind of KeyInfoClause we're looking at, use a generic KeyInfoNode:
                if (keyInfoClause == null) keyInfoClause = new KeyInfoNode();

                // Ask the create clause to fill itself with the
                // corresponding XML
                keyInfoClause.LoadXml(elem);
                // Add it to our list of KeyInfoClauses
                AddClause(keyInfoClause);
            }
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfo.Count"]/*' />
        public Int32 Count
        {
            get { return m_KeyInfoClauses.Count; }
        }

        //------------------------- Public Methods ------------------------------
    
        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfo.AddClause"]/*' />
        public void AddClause(KeyInfoClause clause)
        {
            m_KeyInfoClauses.Add(clause);
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfo.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator()
        {
            return m_KeyInfoClauses.GetEnumerator();
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfo.GetEnumerator1"]/*' />
        public IEnumerator GetEnumerator(Type requestedObjectType)
        {
            ArrayList requestedList = new ArrayList();

            Object tempObj;
            IEnumerator tempEnum = m_KeyInfoClauses.GetEnumerator();

            while(tempEnum.MoveNext() != false) {
                    tempObj = tempEnum.Current;
                    if (requestedObjectType.Equals(tempObj.GetType()))
                        requestedList.Add(tempObj);
                }

            return requestedList.GetEnumerator();
        }
    }

    /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoClause"]/*' />
    public abstract class KeyInfoClause
    {
        //-------------------------- Constructors -------------------------------
        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoClause.KeyInfoClause"]/*' />
        public KeyInfoClause()
        {
        }
    
        //--------------------------- Properties --------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoClause.GetXml"]/*' />
        public abstract XmlElement GetXml();

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoClause.LoadXml"]/*' />
        public abstract void LoadXml(XmlElement element);

    }

    /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoName"]/*' />
    public class KeyInfoName : KeyInfoClause
    {
        String m_strKeyName;

        //-------------------------- Constructors -------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoName.KeyInfoName"]/*' />
        public KeyInfoName()
        {
        }

        //--------------------------- Properties --------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoName.Value"]/*' />
        public String Value
        {
            get { return m_strKeyName; }
            set { m_strKeyName = value; }
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoName.GetXml"]/*' />
        public override XmlElement GetXml()
        {
            XmlDocument xmlDocument =  new XmlDocument();
            // Create the actual element
            XmlElement nameElement = xmlDocument.CreateElement("KeyName",SignedXml.XmlDsigNamespaceUrl);
            nameElement.AppendChild(xmlDocument.CreateTextNode(m_strKeyName));
            
            return nameElement;

        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoName.LoadXml"]/*' />
        public override void LoadXml(XmlElement value) {
            // Guard against nulls
            if (value == null)
                throw new ArgumentNullException("value");
            XmlElement nameElement = value;
            m_strKeyName = nameElement.InnerText;
        }
    }

    /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="DSAKeyValue"]/*' />
    public class DSAKeyValue : KeyInfoClause
    {
        private DSA m_key;

        //-------------------------- Constructors -------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="DSAKeyValue.DSAKeyValue"]/*' />
        public DSAKeyValue()
        {
            m_key = DSA.Create();
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="DSAKeyValue.DSAKeyValue1"]/*' />
        public DSAKeyValue(DSA key)
        {
            m_key = key;
        }

        //--------------------------- Properties --------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="DSAKeyValue.Key"]/*' />
        public DSA Key
        {
            get { return m_key; }
            set { m_key = value; }
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="DSAKeyValue.GetXml"]/*' />
        public override XmlElement GetXml() {
            XmlDocument xmlDocument = new XmlDocument();
            XmlElement keyValueElement = xmlDocument.CreateElement("KeyValue",SignedXml.XmlDsigNamespaceUrl);
            // Get the *public components of the DSA key*
            String dsaKeyValueXmlString = m_key.ToXmlString(false);
            // Set the content of the KeyValue element to be the xmlString
            String keyValueXmlString = "<KeyValue xmlns=\""+SignedXml.XmlDsigNamespaceUrl+"\">"+dsaKeyValueXmlString+"</KeyValue>";
            xmlDocument.LoadXml(keyValueXmlString);
            return xmlDocument.DocumentElement;
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="DSAKeyValue.LoadXml"]/*' />
        public override void LoadXml(XmlElement value) {
            // Guard against nulls
            if (value == null)
                throw new ArgumentNullException("value");
            
            XmlNamespaceManager nsm = new XmlNamespaceManager(value.OwnerDocument.NameTable);
            nsm.AddNamespace("ds",SignedXml.XmlDsigNamespaceUrl);
            XmlNodeList dsaKeyValueNodes = value.SelectNodes("ds:DSAKeyValue", nsm);
            if (dsaKeyValueNodes.Count == 0) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"),"KeyValue");
            }
            // Get the XML string 
            String dsaKeyValueString = value.OuterXml;
            // import the params
            m_key.FromXmlString(dsaKeyValueString);
        }
    }

    /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="RSAKeyValue"]/*' />
    public class RSAKeyValue : KeyInfoClause
    {
        RSA m_key;

        //-------------------------- Constructors -------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="RSAKeyValue.RSAKeyValue"]/*' />
        public RSAKeyValue()
        {
            m_key = RSA.Create();
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="RSAKeyValue.RSAKeyValue1"]/*' />
        public RSAKeyValue(RSA key)
        {
            m_key = key;
        }

        //--------------------------- Properties --------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="RSAKeyValue.Key"]/*' />
        public RSA Key
        {
            get { return m_key; }
            set { m_key = value; }
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="RSAKeyValue.GetXml"]/*' />
        public override XmlElement GetXml() {
            XmlDocument xmlDocument = new XmlDocument();
            // Get the *public components of the RSA key*
            String rsaKeyValueXmlString = m_key.ToXmlString(false);
            // Set the content of the KeyValue element to be the xmlString
            String keyValueXmlString = "<KeyValue xmlns=\""+SignedXml.XmlDsigNamespaceUrl+"\">"+rsaKeyValueXmlString+"</KeyValue>";
            xmlDocument.LoadXml(keyValueXmlString);
            return xmlDocument.DocumentElement;
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="RSAKeyValue.LoadXml"]/*' />
        public override void LoadXml(XmlElement value) {
            // Guard against nulls
            if (value == null)
                throw new ArgumentNullException("value");
            // Get the inner RSAKeyValue node
            XmlNamespaceManager nsm = new XmlNamespaceManager(value.OwnerDocument.NameTable);
            nsm.AddNamespace("ds",SignedXml.XmlDsigNamespaceUrl);
            XmlNodeList rsaKeyValueNodes = value.SelectNodes("ds:RSAKeyValue", nsm);
            if (rsaKeyValueNodes.Count == 0) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"),"KeyValue");
            }
            XmlElement rsaKeyValueElement = (XmlElement) rsaKeyValueNodes.Item(0);
            // Get the XML string 
            String rsaKeyValueString = rsaKeyValueElement.OuterXml;
            // import the params
            m_key.FromXmlString(rsaKeyValueString);
        }
    }

    /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoRetrievalMethod"]/*' />
    public class KeyInfoRetrievalMethod : KeyInfoClause
    {
        String m_strUri;

        //-------------------------- Constructors -------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoRetrievalMethod.KeyInfoRetrievalMethod"]/*' />
        public KeyInfoRetrievalMethod() {}

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoRetrievalMethod.KeyInfoRetrievalMethod1"]/*' />
        public KeyInfoRetrievalMethod(String strUri)
        {
            m_strUri = strUri;
        }

        //--------------------------- Properties --------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoRetrievalMethod.Uri"]/*' />
        public String Uri
        {
            get { return m_strUri; }
            set { m_strUri = value; }
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoRetrievalMethod.GetXml"]/*' />
        public override XmlElement GetXml() {
            XmlDocument xmlDocument =  new XmlDocument();

            // Create the actual element
            XmlElement retrievalMethodElement = xmlDocument.CreateElement("RetrievalMethod", SignedXml.XmlDsigNamespaceUrl);

            if (m_strUri != null)
                retrievalMethodElement.SetAttribute("URI", m_strUri);

            return retrievalMethodElement;
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoRetrievalMethod.LoadXml"]/*' />
        public override void LoadXml(XmlElement value) {            
            // Guard against nulls
            if (value == null)
                throw new ArgumentNullException("value");

            XmlElement retrievalMethodElement = value;
            m_strUri = value.GetAttribute("URI");
        }
    }

    internal struct X509IssuerSerial {
        public string IssuerName;
        public string SerialNumber;
    }

    /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data"]/*' />
    public class KeyInfoX509Data : KeyInfoClause
    {
        // An array of certificates representing the certificate chain 
        private ArrayList m_certificates = null;
        // An array of issuer serial structs
        private ArrayList m_issuerSerials = null;
        // An array of SKIs
        private ArrayList m_subjectKeyIds = null;
        // An array of subject names
        private ArrayList m_subjectNames = null;
        // A raw byte data representing a certificate revocation list
        byte[] m_CRL = null;

        private string ToXmlString(X509IssuerSerial issuerSerial) {
            StringBuilder sb = new StringBuilder();
            sb.Append("<X509IssuerSerial><X509IssuerName>"+issuerSerial.IssuerName+"</X509IssuerName><X509SerialNumber>"+issuerSerial.SerialNumber+"</X509SerialNumber></X509IssuerSerial>");
            return sb.ToString();
        }

        //-------------------------- Constructors -------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.KeyInfoX509Data"]/*' />
        public KeyInfoX509Data() {
            // Default constructor doesn't do anything
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.KeyInfoX509Data1"]/*' />
        public KeyInfoX509Data(byte[] rgbCert) {
            m_certificates = new ArrayList();
            X509Certificate certificate = new X509Certificate(rgbCert);
            if (certificate != null)
                m_certificates.Add(certificate);
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.KeyInfoX509Data2"]/*' />
        public KeyInfoX509Data(X509Certificate cert) {
            m_certificates = new ArrayList();
            X509Certificate certificate = new X509Certificate(cert);
            if (certificate != null)
                m_certificates.Add(certificate);
        }

        //--------------------------- Properties --------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.Certificates"]/*' />
        public ArrayList Certificates
        {
            get { return m_certificates; }
        }
        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.AddCertificate"]/*' />
        public void AddCertificate(X509Certificate certificate) {
            if (m_certificates == null)
                m_certificates = new ArrayList();
            m_certificates.Add(certificate);            
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.SubjectKeyIds"]/*' />
        public ArrayList SubjectKeyIds
        {
            get { return m_subjectKeyIds; }
        }
        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.AddSubjectKeyId"]/*' />
        public void AddSubjectKeyId(byte[] subjectKeyId) {
            if (m_subjectKeyIds == null)
                m_subjectKeyIds = new ArrayList();
            m_subjectKeyIds.Add(subjectKeyId);          
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.SubjectNames"]/*' />
        public ArrayList SubjectNames
        {
            get { return m_subjectNames; }
        }
        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.AddSubjectName"]/*' />
        public void AddSubjectName(string subjectName) {
            if (m_subjectNames == null)
                m_subjectNames = new ArrayList();
            m_subjectNames.Add(subjectName);            
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.IssuerSerials"]/*' />
        public ArrayList IssuerSerials
        {
            get { return m_issuerSerials; }
        }
        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.AddIssuerSerial"]/*' />
        public void AddIssuerSerial(string issuerName, string serialNumber) {
            X509IssuerSerial serial;
            serial.IssuerName = issuerName;
            serial.SerialNumber = serialNumber;
            if (m_issuerSerials == null)
                m_issuerSerials = new ArrayList();
            m_issuerSerials.Add(serial);            
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.CRL"]/*' />
        public byte[] CRL 
        {
            get { return m_CRL; }
            set { m_CRL = value; }
        }

        //-------------------------- Private Methods ----------------------------
        private void Clear() {
            m_CRL = null;
            if (m_subjectKeyIds != null) m_subjectKeyIds.Clear();
            if (m_subjectNames != null) m_subjectNames.Clear();
            if (m_issuerSerials != null) m_issuerSerials.Clear();
            if (m_certificates != null) m_certificates.Clear();
        }

        //--------------------------- Public Methods ----------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.GetXml"]/*' />
        public override XmlElement GetXml() {
            XmlDocument xmlDocument = new XmlDocument();
            StringBuilder sb = new StringBuilder();
            int iNumNodes = 0;

            sb.Append("<X509Data xmlns=\""+SignedXml.XmlDsigNamespaceUrl+"\">");
            if (m_issuerSerials != null) {
                iNumNodes += m_issuerSerials.Count;
                for (int i=0; i<m_issuerSerials.Count; i++)
                    sb.Append(ToXmlString(((X509IssuerSerial)m_issuerSerials[i])));
            }
            if (m_subjectKeyIds != null) {
                iNumNodes += m_subjectKeyIds.Count;
                for (int i=0; i<m_subjectKeyIds.Count; i++) {
                    string strSKI = Convert.ToBase64String((byte[])m_subjectKeyIds[i]);
                    sb.Append("<X509SKI>"+strSKI+"</X509SKI>");
                }
            }
            if (m_subjectNames != null) {
                iNumNodes += m_subjectNames.Count;
                for (int i=0; i<m_subjectNames.Count; i++)
                    sb.Append("<X509SubjectName>"+(string)m_subjectNames[i]+"</X509SubjectName>");
            }

            if (m_certificates != null) {
                iNumNodes += m_certificates.Count;
                for(int i=0; i < m_certificates.Count; i++) { 
                    X509Certificate certificate = (X509Certificate) m_certificates[i];
                    sb.Append("<X509Certificate>"+Convert.ToBase64String(certificate.GetRawCertData())+"</X509Certificate>");
                }
            }           

            if (m_CRL != null && iNumNodes != 0 || m_CRL == null && iNumNodes == 0) // Bad X509Data entry, or Empty X509Data
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "X509Data");

            if (m_CRL != null) {
                sb.Append("<X509CRL>"+Convert.ToBase64String(m_CRL)+"</X509CRL>");
            }

            // Now, load the XML string
            sb.Append("</X509Data>");
            xmlDocument.LoadXml(sb.ToString());
            return xmlDocument.DocumentElement;
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoX509Data.LoadXml"]/*' />
        public override void LoadXml(XmlElement element) {
            int iNumNodes = 0;
            // Guard against nulls
            if (element == null)
                throw new ArgumentNullException("element");

            XmlNodeList x509IssuerSerialNodes = element.GetElementsByTagName("X509IssuerSerial", SignedXml.XmlDsigNamespaceUrl);
            XmlNodeList x509SKINodes = element.GetElementsByTagName("X509SKI", SignedXml.XmlDsigNamespaceUrl);
            XmlNodeList x509SubjectNameNodes = element.GetElementsByTagName("X509SubjectName", SignedXml.XmlDsigNamespaceUrl);
            XmlNodeList x509CertificateNodes = element.GetElementsByTagName("X509Certificate", SignedXml.XmlDsigNamespaceUrl);
            XmlNodeList x509CRLNodes = element.GetElementsByTagName("X509CRL", SignedXml.XmlDsigNamespaceUrl);

            iNumNodes += x509IssuerSerialNodes.Count;
            iNumNodes += x509SKINodes.Count;
            iNumNodes += x509SubjectNameNodes.Count;
            iNumNodes += x509CertificateNodes.Count;

            if ((x509CRLNodes.Count != 0 && iNumNodes != 0) || (x509CRLNodes.Count == 0  && iNumNodes == 0)) // Bad X509Data tag, or Empty tag
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "X509Data");

            if (x509CRLNodes.Count > 1)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "X509Data");

            // Flush anything in the lists
            Clear();

            if (x509CRLNodes.Count != 0) {
                m_CRL = Convert.FromBase64String(SignedXml.DiscardWhiteSpaces(x509CRLNodes.Item(0).InnerText));
                return;         
            }

            if (x509IssuerSerialNodes != null) {
                foreach (XmlNode node in x509IssuerSerialNodes) {
                    XmlNodeList elem = ((XmlNode)node).ChildNodes;
                    if (elem == null || elem.Count < 2)
                        throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "X509IssuerSerial");
                    string strIssuerName = null;
                    string strSerialNumber = null;
                    foreach (XmlNode node1 in elem) {
                        if (node1.Name.Equals("X509IssuerName")) {
                            strIssuerName = node1.InnerText;
                        }
                        if (node1.Name.Equals("X509SerialNumber")) {
                            strSerialNumber = node1.InnerText;
                        }
                    }
                    AddIssuerSerial(strIssuerName, strSerialNumber);
                }
            }   
            
            if (x509SKINodes != null) {
                foreach (XmlNode node in x509SKINodes) {
                    string strSKI = node.InnerText;
                    AddSubjectKeyId(Convert.FromBase64String(SignedXml.DiscardWhiteSpaces(strSKI)));                
                }
            }
            
            if (x509SubjectNameNodes != null) {            
                foreach (XmlNode node in x509SubjectNameNodes) {
                    AddSubjectName(node.InnerText); 
                }
            }
                        
            if (x509CertificateNodes != null) {
                foreach (XmlNode node in x509CertificateNodes) {
                    AddCertificate(new X509Certificate(Convert.FromBase64String(SignedXml.DiscardWhiteSpaces(node.InnerText))));
                }       
            }
        }
    }

    /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoNode"]/*' />
    // This is for generic, unknown nodes
    public class KeyInfoNode : KeyInfoClause
    {
        XmlElement m_node;

        //-------------------------- Constructors -------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoNode.KeyInfoNode"]/*' />
        public KeyInfoNode() {}

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoNode.KeyInfoNode1"]/*' />
        public KeyInfoNode(XmlElement node)
        {
            m_node = node;
        }

        //--------------------------- Properties --------------------------------

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoNode.Value"]/*' />
        public XmlElement Value
        {
            get { return m_node; }
            set { m_node = value; }
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoNode.GetXml"]/*' />
        public override XmlElement GetXml() {
            return m_node;
        }

        /// <include file='doc\KeyInfo.uex' path='docs/doc[@for="KeyInfoNode.LoadXml"]/*' />
        public override void LoadXml(XmlElement value) {
            m_node = value; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\isoapparser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: ISerParser
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Interface For DeSerialize Parsers
 **
 ** Date:  Sept 14, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Soap {

	using System.Runtime.Serialization.Formatters;
	using System.Runtime.Serialization;
	using System;
    internal interface ISerParser
    {
    	void Run();
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_sign: $(COOL_TARGET)

SoapFormatter.resources: SoapFormatter.txt
    $(TARGETPATH)\InternalResGen.Exe SoapFormatter.txt $(O)\SoapFormatter.resources

System.XML.Errors.resources: System.XML.Errors.txt
    $(TARGETPATH)\InternalResGen.Exe System.XML.Errors.txt $(O)\System.XML.Errors.resources

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\System.Runtime.Serialization.Formatters.Soap.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc

        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\hwstack.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
* 
*/

using System;


namespace System.Runtime.Serialization.Formatters.Soap.Xml {

// This stack is designed to minimize object creation for the
// objects being stored in the stack by allowing them to be
// re-used over time.  It basically pushes the objects creating
// a high water mark then as Pop() is called they are not removed
// so that next time Push() is called it simply returns the last
// object that was already on the stack.

internal class HWStack
{
	public HWStack(int GrowthRate)
	{
	    _GrowthRate = GrowthRate;
		_Used = 0;
		_Stack = new Object[GrowthRate];
		_Size = GrowthRate;
    }

    public Object Push()
	{
	    if (_Used == _Size)
		{
            Object[] newstack = new Object[_Size + _GrowthRate];
            if (_Used > 0) 
            {
                System.Array.Copy(_Stack, 0, newstack, 0, _Used);
			}
			_Stack = newstack;
			_Size += _GrowthRate;
		}
		return _Stack[_Used++];
	}

    public Object Pop()
	{
	    if (0 < _Used)
	    {
			_Used--;
			Object result = _Stack[_Used];
	        return result;
	    }
		return null;
	}

	public Object this[int index] 
	{ 
		get {
			if (index >= 0 && index < _Used) 
			{
				Object result = _Stack[index];
				return result;
			}
			else throw new IndexOutOfRangeException();
		}
		set {
			if (index >= 0 && index < _Used) _Stack[index] = value;
			else throw new IndexOutOfRangeException();
		} 
	}

	public int Length
	{
	    get { return _Used; }
	}
	
    private Object[] _Stack;
	private int _GrowthRate;
	private int _Used;
	private int _Size;
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\system\security\cryptography\xml\transform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------
//
// CLASS:    Transform.cs
//
// AUTHORS:  bal
//
//---------------------------------------------------------------------------


// This file contains the classes necessary to represent the Transform processing model used in 
// XMLDSIG.  The basic idea is as follows.  A Reference object contains within it a TransformChain, which
// is an ordered set of XMLDSIG transforms (represented by <Transform>...</Transform> clauses in the XML).
// A transform in XMLDSIG operates on an input of either an octet stream or a node set and produces
// either an octet stream or a node set.  Conversion between the two types is performed by parsing (octet stream->
// node set) or C14N (node set->octet stream).  We generalize this slightly to allow a transform to define an array of
// input and output types (because I believe in the future there will be perf gains to be had by being smarter about
// what goes in & comes out)
// Each XMLDSIG transform is represented by a subclass of the abstract Transform class.  We need to use CryptoConfig to
// associate Transform classes with URLs for transform extensibility, but that's a future concern for this code.

// Once the Transform chain is constructed, call TransformToOctetStream to convert some sort of input type to an octet
// stream.  (We only bother implementing that much now since every use of transform chains in XmlDsig ultimately yields
// something to hash.

namespace System.Security.Cryptography.Xml
{
    using System;
    using System.Xml;
    using System.Xml.XPath;
    using System.Xml.Xsl;
    using System.Security;
    using System.Security.Policy;
    using System.IO;
    using System.Collections;
    using System.Text;
    using System.Runtime.InteropServices;

    // This class represents an ordered chain of transforms

    /// <include file='doc\Transform.uex' path='docs/doc[@for="TransformChain"]/*' />
    public class TransformChain {
        private ArrayList m_transforms;

        /// <include file='doc\Transform.uex' path='docs/doc[@for="TransformChain.TransformChain"]/*' />
        public TransformChain() {
            m_transforms = new ArrayList();
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="TransformChain.Add"]/*' />
        public void Add(Transform transform) {
            if (transform != null) m_transforms.Add(transform);
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="TransformChain.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return m_transforms.GetEnumerator();
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="TransformChain.Count"]/*' />
        public int Count {
            get { return m_transforms.Count; }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="TransformChain.this"]/*' />
        public Transform this[int index] {
            get {
                if (index >= m_transforms.Count) throw new ArgumentException("index");
                return (Transform) m_transforms[index];
            }
        }

        // The goal behind this method is to pump the input stream through the transforms and get back something that
        // can be hashed
        internal Stream TransformToOctetStream(Object inputObject, Type inputType, XmlResolver resolver, string strBaseUri) {
            Object currentInput = inputObject;
            foreach (Object obj in m_transforms) {
                Transform transform = obj as Transform;
                if (transform.AcceptsType(currentInput.GetType())) {
                    //in this case, no translation necessary, pump it through                    
                    transform.Resolver = resolver;
                    transform.BaseURI = strBaseUri;
                    transform.LoadInput(currentInput);
                    currentInput = transform.GetOutput();
                } else {
                    // We need translation 
                    // For now, we just know about Stream->{XmlNodeList,XmlDocument} and {XmlNodeList,XmlDocument}->Stream
                    if (currentInput is Stream) {
                        if (transform.AcceptsType(typeof(XmlDocument))) {
                            XmlDocument doc = new XmlDocument();
                            doc.PreserveWhitespace = true;
                            XmlValidatingReader valReader = SignedXml.PreProcessStreamInput((Stream) currentInput, resolver, strBaseUri);
                            doc.Load(valReader);
                            transform.LoadInput(doc);
                            currentInput = transform.GetOutput();
                            continue;
                        } else {
                            throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"));
                        }
                    } 
                    if (currentInput is XmlNodeList) {
                        if (transform.AcceptsType(typeof(Stream))) {
                            CanonicalXml c14n = new CanonicalXml((XmlNodeList) currentInput, false);
                            MemoryStream ms = new MemoryStream(c14n.GetBytes());
                            transform.LoadInput((Stream) ms);
                            currentInput = transform.GetOutput();
                            continue;
                        } else {
                            throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"));
                        }
                    }
                    if (currentInput is XmlDocument) {
                        if (transform.AcceptsType(typeof(Stream))) {
                            CanonicalXml c14n = new CanonicalXml((XmlDocument) currentInput);
                            MemoryStream ms = new MemoryStream(c14n.GetBytes());
                            transform.LoadInput((Stream) ms);
                            currentInput = transform.GetOutput();
                            continue;
                        } else {
                            throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"));
                        }
                    }
                    throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"));
                }
            }

            // Final processing, either we already have a stream or have to canonicalize
            if (currentInput is Stream) {
                return currentInput as Stream;
            }
            if (currentInput is XmlNodeList) {
                CanonicalXml c14n = new CanonicalXml((XmlNodeList) currentInput, false);
                MemoryStream ms = new MemoryStream(c14n.GetBytes());
                return ms;
            }
            if (currentInput is XmlDocument) {
                CanonicalXml c14n = new CanonicalXml((XmlDocument) currentInput);
                MemoryStream ms = new MemoryStream(c14n.GetBytes());
                return ms;
            }
            throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_TransformIncorrectInputType"));
        }


        internal Stream TransformToOctetStream(Stream input, XmlResolver resolver, string strBaseUri) {
            return TransformToOctetStream(input, typeof(Stream), resolver, strBaseUri);
        }

        internal Stream TransformToOctetStream(XmlDocument document, XmlResolver resolver, string strBaseUri) {
            return TransformToOctetStream(document, typeof(XmlDocument), resolver, strBaseUri);
        }

        internal Stream TransformToOctetStream(XmlNodeList nodeList, XmlResolver resolver, string strBaseUri) {
            return TransformToOctetStream(nodeList, typeof(XmlNodeList), resolver, strBaseUri);
        }
    }

    /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform"]/*' />
    public abstract class Transform {
        internal String m_strAlgorithm;
        private string m_strBaseUri = null;
        internal XmlResolver m_xmlResolver = null;
        private bool m_bResolverSet = false;

        //-------------------------- Constructors ---------------------------

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.Transform"]/*' />
        public Transform()
        {
        }

        //-------------------------- Properties -----------------------------

        internal string BaseURI {
            get { return m_strBaseUri; }
            set { m_strBaseUri = value; }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.Algorithm"]/*' />
        public String Algorithm
        {
            get { return m_strAlgorithm; }
            set { m_strAlgorithm = value; }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.Resolver"]/*' />
        [ComVisible(false)]
        public XmlResolver Resolver
        {
            // This property only has a setter. The rationale for this is that we don't have a good value
            // to return when it has not been explicitely set, as we are using XmlSecureResolver by default
            set { 
                m_xmlResolver = value; 
                m_bResolverSet = true;
            }
        }

        internal bool ResolverSet {
            get { return m_bResolverSet; }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.InputTypes"]/*' />
        public abstract Type[] InputTypes {
            get;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.OutputTypes"]/*' />
        public abstract Type[] OutputTypes {
            get; 
        }

        internal bool AcceptsType(Type inputType) {
            if (InputTypes != null) {
                for (int i=0; i<InputTypes.Length; i++) {
                    if (inputType == InputTypes[i] || inputType.IsSubclassOf(InputTypes[i]))
                        return true;
                }
            }
            return false;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.GetXml"]/*' />
        public XmlElement GetXml() {
            XmlDocument document = new XmlDocument();
            XmlElement theTransformElement = document.CreateElement("Transform",SignedXml.XmlDsigNamespaceUrl);
            theTransformElement.SetAttribute("Algorithm",this.Algorithm);
            XmlNodeList innerContent = this.GetInnerXml();
            if (innerContent != null) {
                foreach (XmlNode node in innerContent) {
                    theTransformElement.AppendChild(document.ImportNode(node,true));
                }
            }
            return theTransformElement;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.LoadInnerXml"]/*' />
        public abstract void LoadInnerXml(XmlNodeList nodeList);

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.GetInnerXml"]/*' />
        protected abstract XmlNodeList GetInnerXml();

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.LoadInput"]/*' />
        public abstract void LoadInput(Object obj);

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.GetOutput"]/*' />
        public abstract Object GetOutput();

        /// <include file='doc\Transform.uex' path='docs/doc[@for="Transform.GetOutput1"]/*' />
        public abstract Object GetOutput(Type type);

        //------------------------- Public Methods --------------------------

    }

    // A class representing CanonicalXml as a DSIG Transform

    /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransform"]/*' />
    public class XmlDsigC14NTransform : Transform {
        // Inherited from Transform

        private Type[] _inputTypes = { typeof(Stream),
                                       typeof(XmlDocument),
                                       typeof(XmlNodeList) };
        private Type[] _outputTypes = { typeof(Stream) };
        private CanonicalXml _cXml;
        private bool _includeComments = false;

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransform.XmlDsigC14NTransform"]/*' />
        public XmlDsigC14NTransform() {
            Algorithm = SignedXml.XmlDsigC14NTransformUrl;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransform.XmlDsigC14NTransform1"]/*' />
        public XmlDsigC14NTransform(bool includeComments) {
            _includeComments = includeComments;
            Algorithm = (includeComments ? SignedXml.XmlDsigC14NWithCommentsTransformUrl : SignedXml.XmlDsigC14NTransformUrl);
        }
        
        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransform.InputTypes"]/*' />
        public override Type[] InputTypes {
            get {
                return _inputTypes;
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransform.OutputTypes"]/*' />
        public override Type[] OutputTypes {
            get {
                return _outputTypes;
            }
        }

        // null for now
        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransform.LoadXml"]/*' />
        public override void LoadInnerXml(XmlNodeList nodeList) {
        }

        // null for now
        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransform.GetXml"]/*' />
        protected override XmlNodeList GetInnerXml() {
            return null;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransform.LoadInput"]/*' />
        public override void LoadInput(Object obj) {
            if (obj is Stream) {
                XmlResolver resolver = (this.ResolverSet ? this.m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), this.BaseURI));
                _cXml = new CanonicalXml((Stream) obj, _includeComments, resolver, this.BaseURI);
                return;
            }
            if (obj is XmlDocument) {
                _cXml = new CanonicalXml((XmlDocument) obj, _includeComments);
                return;
            }
            if (obj is XmlNodeList) {
                _cXml = new CanonicalXml((XmlNodeList) obj, _includeComments);
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransform.GetOutput"]/*' />
        public override Object GetOutput() {
            return new MemoryStream(_cXml.GetBytes());
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransform.GetOutput1"]/*' />
        public override Object GetOutput(Type type) {
            if (type != typeof(Stream) && !type.IsSubclassOf(typeof(Stream))) {
                throw new ArgumentException("type");
            }
            return new MemoryStream(_cXml.GetBytes());
        }
    }

    /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransformWithComments"]/*' />
    public class XmlDsigC14NWithCommentsTransform : XmlDsigC14NTransform {
        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigC14NTransformWithComments.XmlDsigC14NTransformWithComments"]/*' />
        public XmlDsigC14NWithCommentsTransform() 
            : base(true) {
            Algorithm = SignedXml.XmlDsigC14NWithCommentsTransformUrl;
        }
    }


    // A class representing conversion from Base64 using CryptoStream
    /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigBase64Transform"]/*' />
    public class XmlDsigBase64Transform : Transform {
        private Type[] _inputTypes = { typeof(Stream), typeof(XmlNodeList), typeof(XmlDocument)    };
        private Type[] _outputTypes = { typeof(Stream) };
        private CryptoStream _cs = null;

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigBase64Transform.XmlDsigBase64Transform"]/*' />
        public XmlDsigBase64Transform() {
            Algorithm = SignedXml.XmlDsigBase64TransformUrl;
        }


        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigBase64Transform.InputTypes"]/*' />
        public override Type[] InputTypes {
            get {
                return _inputTypes;
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigBase64Transform.OutputTypes"]/*' />
        public override Type[] OutputTypes {
            get {
                return _outputTypes;
            }
        }

        // null for now
        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigBase64Transform.LoadXml"]/*' />
        public override void LoadInnerXml(XmlNodeList nodeList) {
        }

        // null for now
        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigBase64Transform.GetXml"]/*' />
        protected override XmlNodeList GetInnerXml() {
            return null;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigBase64Transform.LoadInput"]/*' />
        public override void LoadInput(Object obj) {
            if (obj is Stream) {
                LoadStreamInput((Stream) obj);
                return;
            }
            if (obj is XmlNodeList) {
                LoadXmlNodeListInput((XmlNodeList) obj);
                return;
            }
            if (obj is XmlDocument) {
                LoadXmlNodeListInput(((XmlDocument) obj).SelectNodes("//."));
                return;
            }
        }

        private void LoadStreamInput(Stream inputStream) {
            if (inputStream == null) throw new ArgumentException("obj");
            MemoryStream ms = new MemoryStream();
            byte[] buffer = new byte[1024];
            int bytesRead;
            do {
                bytesRead = inputStream.Read(buffer,0,1024);
                if (bytesRead > 0) {
                    int i = 0;
                    int j = 0;
                    while ((j < bytesRead) && (!Char.IsWhiteSpace((char) buffer[j]))) j++;
                    i = j; j++;
                    while (j < bytesRead) {
                        if (!Char.IsWhiteSpace((char) buffer[j])) {
                            buffer[i] = buffer[j];
                            i++;
                        }
                        j++;
                    }
                    ms.Write(buffer,0,i);
                }
            } while (bytesRead > 0);
            ms.Position = 0;
            _cs = new CryptoStream(ms, new System.Security.Cryptography.FromBase64Transform(), CryptoStreamMode.Read);
        }

        private void LoadXmlNodeListInput(XmlNodeList nodeList) {
            StringBuilder sb = new StringBuilder();
            foreach (XmlNode node in nodeList) {
                XmlNode result = node.SelectSingleNode("self::text()");
                if (result != null) {
                    sb.Append(result.OuterXml);
                }
            }
            UTF8Encoding utf8 = new UTF8Encoding(false);
            byte[] buffer = utf8.GetBytes(sb.ToString());
            int i = 0;
            int j = 0;
            while ((j <buffer.Length) && (!Char.IsWhiteSpace((char) buffer[j]))) j++;
            i = j; j++;
            while (j < buffer.Length) {
                if (!Char.IsWhiteSpace((char) buffer[j])) {
                    buffer[i] = buffer[j];
                    i++;
                }
                j++;
            }
            MemoryStream ms = new MemoryStream(buffer, 0, i);
            _cs = new CryptoStream(ms, new System.Security.Cryptography.FromBase64Transform(), CryptoStreamMode.Read);
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigBase64Transform.GetOutput"]/*' />
        public override Object GetOutput() {
            return _cs;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigBase64Transform.GetOutput1"]/*' />
        public override Object GetOutput(Type type) {
            if (type != typeof(Stream) && !type.IsSubclassOf(typeof(Stream))) {
                throw new ArgumentException("type");
            }
            return _cs;
        }
    }

    // A class representing DSIG XPath Transforms

    /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXPathTransform"]/*' />
    public class XmlDsigXPathTransform : Transform {
        // Inherited from Transform

        private Type[] _inputTypes = { typeof(Stream), typeof(XmlNodeList), typeof(XmlDocument) };
        private Type[] _outputTypes = { typeof(XmlNodeList) };
        private String _xpathexpr;
        private XmlNodeList _inputNodeList;
        private XmlNamespaceManager _nsm;

#if _DEBUG
        private static bool debug = false;
#endif

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXPathTransform.XmlDsigXPathTransform"]/*' />
        public XmlDsigXPathTransform() {
            Algorithm = SignedXml.XmlDsigXPathTransformUrl;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXPathTransform.InputTypes"]/*' />
        public override Type[] InputTypes {
            get {
                return _inputTypes;
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXPathTransform.OutputTypes"]/*' />
        public override Type[] OutputTypes {
            get {
                return _outputTypes;
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXPathTransform.LoadXml"]/*' />
        public override void LoadInnerXml(XmlNodeList nodeList) {
            // XPath transform is specified by text child of first XPath child
            if (nodeList == null) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
            }
            bool foundit = false;
            foreach (XmlNode node in nodeList) {
                string strPrefix = null;
                string strNamespaceURI = null;
                XmlElement elem = node as XmlElement;
                if ((elem != null) && (elem.LocalName == "XPath")) {
                    _xpathexpr = elem.InnerXml.Trim(null);
                    foundit = true;
                    XmlNodeReader nr = new XmlNodeReader(elem);
                    XmlNameTable nt = nr.NameTable;
                    _nsm = new XmlNamespaceManager(nt);
                    // Look for a namespace in the attributes
                    foreach (XmlAttribute attrib in elem.Attributes) {
                        if (attrib.Prefix == "xmlns") {
                            strPrefix = attrib.LocalName;
                            strNamespaceURI = attrib.Value;
                            break;                          
                        }
                    }
                    if (strPrefix == null) {
                        strPrefix = elem.Prefix;
                        strNamespaceURI = elem.NamespaceURI;
                    }
#if _DEBUG
                    if (debug) {
                        Console.WriteLine(strPrefix + ":" + strNamespaceURI);
                    }   
#endif
                    _nsm.AddNamespace(strPrefix, strNamespaceURI);
                     break;
                }
            }   
                if (!foundit) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXPathTransform.GetXml"]/*' />
        protected override XmlNodeList GetInnerXml() {
            XmlDocument doc = new XmlDocument();
            XmlElement xpathElement = doc.CreateElement(null,"XPath",SignedXml.XmlDsigNamespaceUrl);
            XmlText xpathText = doc.CreateTextNode(_xpathexpr);
            xpathElement.AppendChild(xpathText);
            doc.AppendChild(xpathElement);
            return doc.ChildNodes;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXPathTransform.LoadInput"]/*' />
        public override void LoadInput(Object obj) {
            if (obj is Stream) {
                LoadStreamInput((Stream) obj);
                return;
            }
            if (obj is XmlNodeList) {
                LoadXmlNodeListInput((XmlNodeList) obj);
                return;
            }
            if (obj is XmlDocument) {
                LoadXmlDocumentInput((XmlDocument) obj);
                return;
            }
        }

        private void LoadStreamInput(Stream stream) {
            XmlDocument doc = new XmlDocument();
            doc.PreserveWhitespace = true;
            doc.Load(stream);
            _inputNodeList = CanonicalXml.AllDescendantNodes(doc,true);
        }

        private void LoadXmlNodeListInput(XmlNodeList nodeList) {
            _inputNodeList = nodeList;
        }

        private void LoadXmlDocumentInput(XmlDocument doc) {
            _inputNodeList = CanonicalXml.AllDescendantNodes(doc,true);
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXPathTransform.GetOutput"]/*' />
        public override Object GetOutput() {
            CanonicalXmlNodeList resultNodeList = new CanonicalXmlNodeList();
            foreach (XmlNode node in _inputNodeList) {
                if (node == null)  continue;
                // keep namespaces
                if (node is XmlAttribute && (node.LocalName == "xmlns" || node.Prefix == "xmlns")) {
                    resultNodeList.Add(node);
                    continue;
                }
                try {
                    XmlNode result = node.SelectSingleNode(_xpathexpr, _nsm);
                    if (result != null) {
                        resultNodeList.Add(node);
                    }
                }
                catch {
#if _DEBUG                
                    if (debug) {
                        Console.WriteLine(node.OuterXml);
                    }   
#endif
                }
            }
            return resultNodeList;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXPathTransform.GetOutput1"]/*' />
        public override Object GetOutput(Type type) {
            if (type != typeof(XmlNodeList) && !type.IsSubclassOf(typeof(XmlNodeList))) {
                throw new ArgumentException("type");
            }
            return (XmlNodeList) GetOutput();
        }
    }

    /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXsltTransform"]/*' />
    public class XmlDsigXsltTransform : Transform {
        // Inherited from Transform

        private Type[] _inputTypes = { typeof(Stream), typeof(XmlDocument), typeof(XmlNodeList) };
        private Type[] _outputTypes = { typeof(Stream) };
        private XmlNodeList _xslNodes;
        private string _xslFragment;
        private Stream _inputStream;
        private bool _includeComments = false;

#if _DEBUG
        private static bool debug = false;
#endif

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXsltTransform.XmlDsigXsltTransform"]/*' />
        public XmlDsigXsltTransform() {
            Algorithm = SignedXml.XmlDsigXsltTransformUrl;
        }
        
        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXsltTransform.XmlDsigXsltTransform1"]/*' />
        public XmlDsigXsltTransform(bool includeComments) {
            _includeComments = includeComments;
            Algorithm = SignedXml.XmlDsigXsltTransformUrl;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXsltTransform.InputTypes"]/*' />
        public override Type[] InputTypes {
            get {
                return _inputTypes;
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXsltTransform.OutputTypes"]/*' />
        public override Type[] OutputTypes {
            get {
                return _outputTypes;
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXsltTransform.LoadXml"]/*' />
        public override void LoadInnerXml(XmlNodeList nodeList) {
            if (nodeList == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
            // check that the XSLT element is well formed
            XmlElement firstDataElement = null;
            int count = 0;
            foreach (XmlNode node in nodeList) {
                // ignore white spaces, but make sure only one child element is present
                if (node is XmlWhitespace) continue;
                if (node is XmlElement) {
                    if (count != 0) 
                        throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
                    firstDataElement = node as XmlElement;
                    count++;
                    continue;
                }
                // Only allow white spaces
                count++;
            }
            if (count != 1 || firstDataElement == null) 
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_UnknownTransform"));
            _xslNodes = nodeList;
            _xslFragment = firstDataElement.OuterXml.Trim(null);
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXsltTransform.GetXml"]/*' />
        protected override XmlNodeList GetInnerXml() {
            return _xslNodes;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXsltTransform.LoadInput"]/*' />
        public override void LoadInput(Object obj) {
            _inputStream = new MemoryStream();
            if (obj is Stream) {
                _inputStream = (Stream) obj;
            }
            else if (obj is XmlNodeList) {
                CanonicalXml xmlDoc = new CanonicalXml((XmlNodeList) obj, _includeComments);
                byte[] buffer = xmlDoc.GetBytes();
                if (buffer == null) return;
                _inputStream.Write(buffer, 0, buffer.Length);
                _inputStream.Flush();
                _inputStream.Position = 0;
            }
            else if (obj is XmlDocument) {
                CanonicalXml xmlDoc = new CanonicalXml((XmlDocument) obj, _includeComments);
                byte[] buffer = xmlDoc.GetBytes();
                if (buffer == null) return;
                _inputStream.Write(buffer, 0, buffer.Length);
                _inputStream.Flush();
                _inputStream.Position = 0;
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXsltTransform.GetOutput"]/*' />
        public override Object GetOutput() {
            //  XSL transforms expose many powerful features by default:
            //  1- we need to pass a null evidence to prevent script execution.
            //  2- XPathDocument will expand entities, we don't want this, so set the resolver to null
            //  3- We really don't want the document function feature of XslTransforms, so set the resolver to null.

            // load the XSL Transform
            XslTransform xslt = new XslTransform();
            XmlTextReader readerXsl = new XmlTextReader(_xslFragment, XmlNodeType.Element, null);
            readerXsl.XmlResolver = this.m_xmlResolver;
            xslt.Load(readerXsl, this.m_xmlResolver, new Evidence());

            // Now load the input stream, XmlDocument can be used but is less efficient
            XmlTextReader readerXml = new XmlTextReader(_inputStream);
            readerXml.XmlResolver = this.m_xmlResolver;
            XmlValidatingReader valReader = new XmlValidatingReader(readerXml);
            valReader.ValidationType = ValidationType.None;
            XPathDocument inputData = new XPathDocument(valReader, XmlSpace.Preserve);
            
            // Create an XmlTextWriter
            MemoryStream ms = new MemoryStream();
            XmlWriter writer = new XmlTextWriter(ms, null);
            
            // Transform the data and send the output to the memory stream
            xslt.Transform(inputData, null, writer, this.m_xmlResolver);
#if _DEBUG
            if (debug) {
                Console.WriteLine(Encoding.UTF8.GetString(ms.ToArray()));
            }   
#endif
            ms.Position = 0;
            return ms;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigXsltTransform.GetOutput1"]/*' />
        public override Object GetOutput(Type type) {
            if (type != typeof(Stream) && !type.IsSubclassOf(typeof(Stream))) {
                throw new ArgumentException("type");
            }
            return (Stream) GetOutput();
        }
    }

    /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform"]/*' />
    public class XmlDsigEnvelopedSignatureTransform : Transform {
        // Inherited from Transform

        private Type[] _inputTypes = { typeof(Stream), typeof(XmlNodeList), typeof(XmlDocument) };
        private Type[] _outputTypes = { typeof(XmlNodeList), typeof(XmlDocument) };
        private XmlNodeList _inputNodeList;
        private bool _includeComments = false;
        private XmlNamespaceManager _nsm = null;
        private XmlDocument _containingDocument = null;
        private int _signaturePosition = 0;

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform.SignatureElement"]/*' />
        internal int SignaturePosition {
            get { return _signaturePosition; }
            set { _signaturePosition = value; }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform.XmlDsigEnvelopedSignatureTransform"]/*' />
        public XmlDsigEnvelopedSignatureTransform() {
            Algorithm = SignedXml.XmlDsigEnvelopedSignatureTransformUrl;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform.XmlDsigEnvelopedSignatureTransform1"]/*' />
        /// <internalonly/>
        public XmlDsigEnvelopedSignatureTransform(bool includeComments) {
            _includeComments = includeComments;
            Algorithm = SignedXml.XmlDsigEnvelopedSignatureTransformUrl;
        }
        
        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform.InputTypes"]/*' />
        public override Type[] InputTypes {
            get {
                return _inputTypes;
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform.OutputTypes"]/*' />
        public override Type[] OutputTypes {
            get {
                return _outputTypes;
            }
        }

        // An enveloped signature has no inner XML elements
        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform.LoadXml"]/*' />
        public override void LoadInnerXml(XmlNodeList nodeList) {
        }

        // An enveloped signature has no inner XML elements
        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform.GetXml"]/*' />
        protected override XmlNodeList GetInnerXml() {
            return null;
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform.LoadInput"]/*' />
        public override void LoadInput(Object obj) {
            if (obj is Stream) {
                LoadStreamInput((Stream) obj);
                return;
            }
            if (obj is XmlNodeList) {
                LoadXmlNodeListInput((XmlNodeList) obj);
                return;
            }
            if (obj is XmlDocument) {
                LoadXmlDocumentInput((XmlDocument) obj);
                return;
            }
        }

        private void LoadStreamInput(Stream stream) {
            XmlDocument doc = new XmlDocument();
            doc.PreserveWhitespace = true;
            doc.Load(stream);
            _containingDocument = doc;
            if (_containingDocument == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_EnvelopedSignatureRequiresContext"));
            _nsm = new XmlNamespaceManager(_containingDocument.NameTable);
            _nsm.AddNamespace("dsig", SignedXml.XmlDsigNamespaceUrl);   
        }

        private void LoadXmlNodeListInput(XmlNodeList nodeList) {
            // Empty node list is not acceptable
            if (nodeList == null) 
                throw new ArgumentNullException("nodeList");
            foreach (XmlNode node in nodeList) {
                if (node == null) continue;
                _containingDocument = node.OwnerDocument;
                if (_containingDocument != null) break;
            }
            if (_containingDocument == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_EnvelopedSignatureRequiresContext"));

            _nsm = new XmlNamespaceManager(_containingDocument.NameTable);
            _nsm.AddNamespace("dsig", SignedXml.XmlDsigNamespaceUrl);   
            _inputNodeList = nodeList;
        }

        private void LoadXmlDocumentInput(XmlDocument doc) {
            if (doc == null)
                throw new ArgumentNullException("doc");
            _containingDocument = doc;
            _nsm = new XmlNamespaceManager(_containingDocument.NameTable);
            _nsm.AddNamespace("dsig", SignedXml.XmlDsigNamespaceUrl);   
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform.GetOutput"]/*' />
        public override Object GetOutput() {
            // If we have received an XmlNodeList as input
            if (_inputNodeList != null) {
                // If the position has not been set, then we don't want to remove any signature tags
                if (_signaturePosition == 0) return _inputNodeList;
                XmlNodeList signatureList = _containingDocument.SelectNodes("//dsig:Signature", _nsm);
                if (signatureList == null) return _inputNodeList;

                CanonicalXmlNodeList resultNodeList = new CanonicalXmlNodeList();
                foreach (XmlNode node in _inputNodeList) {
                    if (node == null)  continue;
                    // keep namespaces
                    if (node is XmlAttribute && (node.LocalName == "xmlns" || node.Prefix == "xmlns")) {
                        resultNodeList.Add(node);
                        continue;
                    }
                    // SelectSingleNode throws an exception for xmldecl PI for example, so we will just ignore those exceptions
                    try {
                        // Find the nearest signature ancestor tag 
                        XmlNode result = node.SelectSingleNode("ancestor-or-self::dsig:Signature[1]", _nsm);
                        int position = 0;
                        foreach (XmlNode node1 in signatureList) {
                            position++;
                            if (node1 == result) break;
                        } 
                        if (result == null || (result != null && position != _signaturePosition)) {
                            resultNodeList.Add(node);
                        }
                    }
                    catch {}
                }
                return resultNodeList;
            }
            // Else we have received either a stream or a document as input
            else {
                XmlNodeList signatureList = _containingDocument.SelectNodes("//dsig:Signature", _nsm);
                if (signatureList == null) return _containingDocument;
                if (signatureList.Count < _signaturePosition || _signaturePosition <= 0) return _containingDocument;

                // Remove the signature node with all its children nodes
                signatureList[_signaturePosition - 1].ParentNode.RemoveChild(signatureList[_signaturePosition - 1]);
                return _containingDocument;
            }
        }

        /// <include file='doc\Transform.uex' path='docs/doc[@for="XmlDsigEnvelopedSignatureTransform.GetOutput1"]/*' />
        public override Object GetOutput(Type type) {
            if (type == typeof(XmlNodeList) || type.IsSubclassOf(typeof(XmlNodeList))) {
                if (_inputNodeList == null) {
                    _inputNodeList = CanonicalXml.AllDescendantNodes(_containingDocument, true);
                }               
                return (XmlNodeList) GetOutput();
            } else if (type == typeof(XmlDocument) || type.IsSubclassOf(typeof(XmlDocument))) {
                if (_inputNodeList != null) throw new ArgumentException("type");
                return (XmlDocument) GetOutput();
            } else {
                throw new ArgumentException("type");
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\system\security\cryptography\xml\signedinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------
//
// CLASS:    SignedInfo.cool
//
// AUTHOR:   Christian Caron (t-ccaron)
//
// PURPOSE:  This object implements the http://www.w3.org/2000/02/xmldsig#SignedInfo
//           element.
// 
// DATE:     21 March 2000
// 
//---------------------------------------------------------------------------

namespace System.Security.Cryptography.Xml
{
    using System;
    using System.Xml;
    using System.Collections;
    using System.Security;

    /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo"]/*' />
    public class SignedInfo : ICollection
    {
        internal String m_strId;
        internal String m_strCanonicalizationMethod;
        internal String m_strSignatureMethod;
		internal String m_strSignatureLength;
        internal ArrayList m_references;
        private XmlElement m_cachedXml = null;

        //-------------------------- Constructors ---------------------------

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.SignedInfo"]/*' />
        public SignedInfo()
        {
            m_references = new ArrayList();
        }

        //-------------------------- ICollection -----------------------------

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator()
        {
            throw new NotSupportedException();
        } 

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.CopyTo"]/*' />
        public void CopyTo(Array array, int index)
        {
            throw new NotSupportedException();
        }

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.Count"]/*' />
        public Int32 Count
        {
            get { throw new NotSupportedException(); }
        }

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.IsReadOnly"]/*' />
        public Boolean IsReadOnly
        {
            get { throw new NotSupportedException(); }
        }

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.IsSynchronized"]/*' />
        public Boolean IsSynchronized
        {
            get { throw new NotSupportedException(); }
        }

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.SyncRoot"]/*' />
        public object SyncRoot
        {
            get { throw new NotSupportedException(); }
        }


        //-------------------------- Properties -----------------------------

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.Id"]/*' />
        public String Id
        {
            get { return m_strId; }
            set { 
                m_strId = value; 
                m_cachedXml = null;
            }
        }

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.CanonicalizationMethod"]/*' />
        public String CanonicalizationMethod
        {
            get { 
                // Default the canonicalization method to C14N
                if (m_strCanonicalizationMethod == null) return SignedXml.XmlDsigC14NTransformUrl;
                return m_strCanonicalizationMethod; 
            }
            set { 
                m_strCanonicalizationMethod = value;
                m_cachedXml = null;
            }
        }

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.SignatureMethod"]/*' />
        public String SignatureMethod
        {
            get { return m_strSignatureMethod; }
            set {
                m_strSignatureMethod = value;
                m_cachedXml = null;
            }
        }

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.SignatureLength"]/*' />
		public String SignatureLength
		{
			get { return m_strSignatureLength; }
			set {
				m_strSignatureLength = value;
				m_cachedXml = null;
			}
		}

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.References"]/*' />
        public ArrayList References
        {
            get { return m_references; }
        }

        internal bool CacheValid {
            get {
                // first check that our own cache exists
                if (m_cachedXml == null) return(false);
                // now check all the References
                foreach (Object refobj in References) {
                    if (!(((Reference) refobj).CacheValid)) return(false);
                }
                return(true);
            }
        }

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.GetXml"]/*' />
        public XmlElement GetXml()  {
                // If I built this from some Xml that's cached, return it
                // We have to check that the cache is still valid, which means recursively checking that
                // everything cached within up is valid
                if (CacheValid) return(m_cachedXml);
                
                XmlDocument document = new XmlDocument();
                // Create the root element
                XmlElement signedInfoElement = document.CreateElement("SignedInfo",SignedXml.XmlDsigNamespaceUrl);

                    // Add the canonicalization method, defaults to 
                    // SignedXml.XmlDsigW3CCanonicalizationUrl
                XmlElement canonicalizationMethodElement = document.CreateElement("CanonicalizationMethod",SignedXml.XmlDsigNamespaceUrl);
                if (m_strCanonicalizationMethod != null) {
                    canonicalizationMethodElement.SetAttribute("Algorithm", m_strCanonicalizationMethod);
                } else {
                    canonicalizationMethodElement.SetAttribute("Algorithm", SignedXml.XmlDsigCanonicalizationUrl);
                }
                signedInfoElement.AppendChild(canonicalizationMethodElement);

                // Add the signature method
                if (m_strSignatureMethod == null)
                    throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureMethodRequired"));
                    
                XmlElement signatureMethodElement = document.CreateElement("SignatureMethod",SignedXml.XmlDsigNamespaceUrl);
                signatureMethodElement.SetAttribute("Algorithm", m_strSignatureMethod);
				// Add HMACOutputLength tag if we have one
				if (m_strSignatureLength != null && m_strSignatureMethod == SignedXml.XmlDsigHMACSHA1Url) {
		            XmlElement hmacLengthElement = document.CreateElement(null,"HMACOutputLength",SignedXml.XmlDsigNamespaceUrl);
			        XmlText outputLength = document.CreateTextNode(m_strSignatureLength);
					hmacLengthElement.AppendChild(outputLength);
					signatureMethodElement.AppendChild(hmacLengthElement);
				}

                signedInfoElement.AppendChild(signatureMethodElement);

                // Add the references
                if (m_references.Count == 0)
                    throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_ReferenceElementRequired"));

                for (int i = 0; i < m_references.Count; ++i)
                    {
                        Reference reference = (Reference)m_references[i];
                        signedInfoElement.AppendChild(document.ImportNode(reference.GetXml(),true));
                    }
                    
                return signedInfoElement;
            }

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.LoadXml"]/*' />
        public void LoadXml(XmlElement value) {
                // Guard against nulls
                if (value == null)
                    throw new ArgumentNullException("value");
                
                // SignedInfo
                XmlElement signedInfoElement = value;
                if (!signedInfoElement.LocalName.Equals("SignedInfo"))
                    throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"), "SignedInfo");

                XmlNamespaceManager nsm = new XmlNamespaceManager(value.OwnerDocument.NameTable);
                nsm.AddNamespace("ds",SignedXml.XmlDsigNamespaceUrl);

                // CanonicalizationMethod -- must be present
                XmlNodeList canonicalizationMethodNodes = signedInfoElement.SelectNodes("ds:CanonicalizationMethod", nsm);
                if (canonicalizationMethodNodes.Count == 0) {
                    throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"),"SignedInfo/CanonicalizationMethod");
                }
                XmlElement canonicalizationMethodElement = (XmlElement) canonicalizationMethodNodes.Item(0);
                m_strCanonicalizationMethod = canonicalizationMethodElement.GetAttribute("Algorithm");

                // SignatureMethod -- must be present
                XmlNodeList signatureMethodNodes = signedInfoElement.SelectNodes("ds:SignatureMethod", nsm);
                if (signatureMethodNodes.Count == 0) {
                    throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidElement"),"SignedInfo/SignatureMethod");
                }
                XmlElement signatureMethodElement = (XmlElement) signatureMethodNodes.Item(0);
                m_strSignatureMethod = signatureMethodElement.GetAttribute("Algorithm");
				// Now get the output length if we are using a MAC algorithm
                XmlNodeList signatureLengthNodes = signatureMethodElement.SelectNodes("ds:HMACOutputLength", nsm);
				if (signatureLengthNodes.Count > 0) {
					m_strSignatureLength = signatureLengthNodes.Item(0).InnerXml;
				}

                // References if any
                
                // Flush the any reference that was there
                m_references.Clear();

                XmlNodeList referenceNodes = signedInfoElement.SelectNodes("ds:Reference", nsm);
                for (int i = 0; i < referenceNodes.Count; ++i)
                {
                    Reference reference = new Reference();
                    reference.LoadXml((XmlElement) referenceNodes.Item(i));
                    m_references.Add(reference);
                }

                // Save away the cached value
                m_cachedXml = signedInfoElement;
            }
    

        //------------------------- Public Methods --------------------------

        /// <include file='doc\SignedInfo.uex' path='docs/doc[@for="SignedInfo.AddReference"]/*' />
        public void AddReference(Reference reference)
        {
            m_references.Add(reference);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\soapcommonclasses.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: SoapCommonClasses
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: utility classes
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Soap
{
	using System;
	using System.Collections;
	using System.Reflection;
	using System.Text;
	using System.Globalization;
	using System.Runtime.Serialization.Formatters;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Metadata;
	using System.Runtime.Remoting.Messaging;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Resources;
	using System.Diagnostics;

	// AttributeList class is used to transmit attributes from XMLObjectWriter to XMLWriter
	internal sealed class AttributeList
	{
		private SerStack nameA = new SerStack("AttributeName");
		private SerStack valueA = new SerStack("AttributeValue");

		internal int Count
		{
			get {return nameA.Count();}
		}

		internal void Clear()
		{
			nameA.Clear();
			valueA.Clear();			
		}

		internal void Put(String name, String value)
		{
			nameA.Push(name);
			valueA.Push(value);
		}

		internal void Get(int index, out String name, out String value)
		{
			name = (String)nameA.Next();
			value = (String)valueA.Next();
		}

		[Conditional("SER_LOGGING")]							
		internal void Dump()
		{
			nameA.Dump();
			valueA.Dump();
		}
	}

	// Implements a stack used for parsing

	internal sealed class SerStack
	{
		//internal ArrayList stack = new ArrayList(10);
		internal Object[] objects = new Object[10];
		internal String stackId;
		internal int top = -1;
		internal int next = 0;

		internal SerStack()
		{
			stackId = "System";
		}

		internal SerStack(String stackId) {
			this.stackId = stackId;
		}

		internal Object GetItem(int index)
		{
			return objects[index];
		}

		internal void Clear()
		{
			top = -1;
			next = 0;
		}

		// Push the object onto the stack
		internal void Push(Object obj) {
			InternalST.Soap(this, "Push ",stackId," ",((obj is ITrace)?((ITrace)obj).Trace():""));									
			if (top == (objects.Length -1)) {
				IncreaseCapacity();
			}
			objects[++top] = obj;		
		}

		// Pop the object from the stack
		internal Object Pop() {
			if (top < 0)
				return null;

			Object obj = objects[top];
			objects[top--] = null;
			InternalST.Soap(this, "Pop ",stackId," ",((obj is ITrace)?((ITrace)obj).Trace():""));			
			return obj;
		}

		internal Object Next()
		{
			if (next > top)
				throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_StackRange"),stackId));				
			return objects[next++];
		}

		internal void IncreaseCapacity() {
			int size = objects.Length * 2;
			Object[] newItems = new Object[size];
			Array.Copy(objects, 0, newItems, 0, objects.Length);
			objects = newItems;
		}

		// Gets the object on the top of the stack
		internal Object Peek() {
			if (top < 0)
				return null;		
			InternalST.Soap(this, "Peek ",stackId," ",((objects[top] is ITrace)?((ITrace)objects[top]).Trace():""));			
			return objects[top];
		}

		// Gets the second entry in the stack.
		internal Object PeekPeek() {
			if (top < 1)
				return null;
			InternalST.Soap(this, "PeekPeek ",stackId," ",((objects[top - 1] is ITrace)?((ITrace)objects[top - 1]).Trace():""));									
			return objects[top - 1];		
		}

		// The number of entries in the stack
		internal int Count() {
			return top + 1; 
		}

		// The number of entries in the stack
		internal bool IsEmpty() {
			if (top > 0) 
				return false;
			else
				return true;
		}

		// Reverse the stack
		internal void Reverse() {
			Array.Reverse(objects, 0, Count());
		}

		[Conditional("SER_LOGGING")]								
		internal void Dump()
		{
			for (int i=0; i<Count(); i++)
			{
				Object obj = objects[i];
				InternalST.Soap(this, "Stack Dump ",stackId," "+((obj is ITrace)?((ITrace)obj).Trace():""));										
			}
		}
	}


    internal sealed class NameCacheEntry
    {
        internal String name;
        internal Object value;
    }


    internal sealed class NameCache
    {
        private const int MAX_CACHE_ENTRIES = 353; // Needs to be a prime number
        static NameCacheEntry[] nameCache = new NameCacheEntry[MAX_CACHE_ENTRIES];

        int probe = 0;
        String name = null;

        internal Object GetCachedValue(String name)
        {
            this.name = name;
            probe = Math.Abs(name.GetHashCode())%MAX_CACHE_ENTRIES;
            NameCacheEntry entry = nameCache[probe];
            if (entry == null)
            {
                entry = new NameCacheEntry();
                entry.name = name;
                return null;
            }
            else if (entry.name == name)
            {
                return entry.value;
            }
            else
                return null;
        }

        internal void SetCachedValue(Object value)
        {
            NameCacheEntry entry = new NameCacheEntry();
            entry.name = name;
            entry.value = value;
            nameCache[probe] = entry;
        }
    }



	internal sealed class SoapUtil
	{
		internal static Type typeofString = typeof(String);
		internal static Type typeofBoolean = typeof(Boolean);
		internal static Type typeofObject = typeof(Object);
		internal static Type typeofSoapFault = typeof(SoapFault);		
		internal static Assembly urtAssembly = Assembly.GetAssembly(typeofString);
		internal static String urtAssemblyString = urtAssembly.FullName;

		[Conditional("SER_LOGGING")]		
		internal static void DumpHash(String tag, Hashtable hashTable)
		{
			IDictionaryEnumerator e = hashTable.GetEnumerator();
			InternalST.Soap("HashTable Dump Begin ", tag);
			while(e.MoveNext())
			{
				InternalST.Soap("HashTable key "+e.Key+", value "+e.Value);
			}
			InternalST.Soap("HashTable Dump end \n");			
		}

		
		internal static ResourceManager SystemResMgr;

		private static ResourceManager InitResourceManager()
		{
			if (SystemResMgr == null)
                SystemResMgr = new ResourceManager("SoapFormatter", typeof(SoapParser).Module.Assembly);
			return SystemResMgr;
		}

        // Looks up the resource string value for key.
        // 
		internal static String GetResourceString(String key)
		{
			if (SystemResMgr == null)
				InitResourceManager();
			String s = SystemResMgr.GetString(key, null);
			InternalST.SoapAssert(s!=null, "Managed resource string lookup failed.  Was your resource name misspelled?  Did you rebuild the SoapFormatter and SoapFormatter.resource after adding a resource to SoapFormatter.txt?  Debug this w/ cordbg and bug whoever owns the code that called SoapUtil.GetResourceString.  Resource name was: \""+key+"\"");
			return s;
		}

        internal static String GetResourceString(String key, params Object[] values) {
            if (SystemResMgr == null)
                InitResourceManager();
            String s = SystemResMgr.GetString(key, null);
            InternalST.SoapAssert(s!=null, "Managed resource string lookup failed.  Was your resource name misspelled?  Did you rebuild mscorlib after adding a resource to resources.txt?  Debug this w/ cordbg and bug whoever owns the code that called Environment.GetResourceString.  Resource name was: \""+key+"\"");
            return String.Format(s, values);
        }
	}

	internal sealed class SoapAssemblyInfo
	{
		internal String assemblyString;
		private Assembly assembly;

		internal SoapAssemblyInfo(String assemblyString)
		{
			this.assemblyString = assemblyString;
		}

		internal SoapAssemblyInfo(String assemblyString, Assembly assembly)
		{
			this.assemblyString = assemblyString;
			this.assembly = assembly;
		}

		internal Assembly GetAssembly(ObjectReader objectReader)
		{
			if (assembly == null)
			{
				assembly = objectReader.LoadAssemblyFromString(assemblyString);
				if (assembly == null)
					throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_AssemblyString"),assemblyString));
			}
			return assembly;
		}
	}

	// The ParseRecord class holds the parsed XML information. There is a
	// ParsedRecord for each XML Element
	internal sealed class ParseRecord : ITrace
	{
		internal static int parseRecordIdCount = 1;


		internal int PRparseRecordId = 0;

		// Enums
		internal InternalParseTypeE PRparseTypeEnum = InternalParseTypeE.Empty;
		internal InternalObjectTypeE PRobjectTypeEnum = InternalObjectTypeE.Empty;
		internal InternalArrayTypeE PRarrayTypeEnum = InternalArrayTypeE.Empty;
		internal InternalMemberTypeE PRmemberTypeEnum = InternalMemberTypeE.Empty;
		internal InternalMemberValueE PRmemberValueEnum = InternalMemberValueE.Empty;
		internal InternalObjectPositionE PRobjectPositionEnum = InternalObjectPositionE.Empty;

		// Object
		internal String PRname;
		internal String PRnameXmlKey;
		internal String PRxmlNameSpace;
		internal bool PRisParsed = false;
		internal bool PRisProcessAttributes = false;

		// Value
		internal String PRvalue;
		internal Object PRvarValue;

		// dt attribute
		internal String PRkeyDt;
		internal String PRtypeXmlKey;
		internal Type PRdtType;
        internal String PRassemblyName;
		internal InternalPrimitiveTypeE PRdtTypeCode;
		internal bool PRisVariant = false; // Used by Binary
		internal bool PRisEnum = false;

		// Object ID
		internal long PRobjectId;

		// Reference ID
		internal long PRidRef;

		// Array

		// Array Element Type
		internal String PRarrayElementTypeString;
		internal Type PRarrayElementType;
		internal bool PRisArrayVariant = false;
		internal InternalPrimitiveTypeE PRarrayElementTypeCode;
		//internal String PRarrayXmlKey;

		// Binary Byte Array
		//internal Byte[] PRbyteA;

		// Array Primitive Element type
		internal String PRprimitiveArrayTypeString;

		// Parsed array information
		internal int PRrank;
		internal int[] PRlengthA;
		internal int[] PRpositionA;
		internal int[] PRlowerBoundA;
		internal int[] PRupperBoundA;

		// Array map for placing array elements in array
		//internal int[][] indexMap;
		internal int[] PRindexMap; 
		internal int PRmemberIndex;
		internal int PRlinearlength;
		internal int[] PRrectangularMap;
		internal bool	PRisLowerBound;

		// SerializedStreamHeader information
		internal long PRtopId;
		internal long PRheaderId;
		internal bool PRisHeaderRoot;
		internal bool PRisAttributesProcessed;

		// Parsed HeaderMember Information
		internal bool PRisMustUnderstand;


		// Parse State
		internal InternalParseStateE PRparseStateEnum = InternalParseStateE.Initial;
		internal bool PRisWaitingForNestedObject = false;

		// MemberInfo accumulated during parsing of members

		internal ReadObjectInfo PRobjectInfo;

		// ValueType Fixup needed
		internal bool PRisValueTypeFixup = false;

		// Created object
		internal Object PRnewObj;
		internal Object[] PRobjectA; //optimization, will contain object[]
		internal PrimitiveArray PRprimitiveArray; // for Primitive Soap arrays, optimization
		internal bool PRisRegistered; // Used when registering nested classes

		internal bool PRisXmlAttribute;


		internal ParseRecord()
		{
			Counter();
		}

		private void Counter()
		{
			// The counter is used to test parseRecord identity
			lock(typeof(ParseRecord))
			{
				PRparseRecordId = parseRecordIdCount++;
			}

		}


		// Get a String describing the ParseRecord

		public String Trace()
		{
			//return "ParseType "+EnumInfo.ToString(InternalParseTypeE.class, parseTypeEnum)+" name "+name+" ParseState "+EnumInfo.ToString(InternalParseStateE.class, parseStateEnum);
			return "ParseRecord"+PRparseRecordId+" ParseType "+ ((Enum)PRparseTypeEnum).ToString() +" name "+PRname+" keyDt "+Util.PString(PRkeyDt);
		}

		// Initialize ParseRecord. Called when reusing.
		internal void Init()
		{
			// Enums
			PRparseTypeEnum = InternalParseTypeE.Empty;
			PRobjectTypeEnum = InternalObjectTypeE.Empty;
			PRarrayTypeEnum = InternalArrayTypeE.Empty;
			PRmemberTypeEnum = InternalMemberTypeE.Empty;
			PRmemberValueEnum = InternalMemberValueE.Empty;
			PRobjectPositionEnum = InternalObjectPositionE.Empty;

			// Object
			PRname = null;
			PRnameXmlKey = null;
			PRxmlNameSpace = null;
			PRisParsed = false;
            PRisProcessAttributes = false;

			// Value
			PRvalue = null;

			// dt attribute
			PRkeyDt = null;
			PRdtType = null;
            PRassemblyName = null;
			PRdtTypeCode = InternalPrimitiveTypeE.Invalid;
			PRisEnum = false;			

			// Object ID
			PRobjectId = 0;

			// Reference ID
			PRidRef = 0;

			// Array

			// Array Element Type
			PRarrayElementTypeString = null;
			PRarrayElementType = null;
			PRisArrayVariant = false;
			PRarrayElementTypeCode = InternalPrimitiveTypeE.Invalid;


			// Array Primitive Element type
			PRprimitiveArrayTypeString = null;

			// Parsed array information
			PRrank = 0;
			PRlengthA = null;
			PRpositionA = null;
			PRlowerBoundA = null;
			PRupperBoundA = null;		

			// Array map for placing array elements in array
			PRindexMap = null;
			PRmemberIndex = 0;
			PRlinearlength = 0;
			PRrectangularMap = null;
			PRisLowerBound = false;

			// SerializedStreamHeader information
			PRtopId = 0;
			PRheaderId = 0;
			PRisHeaderRoot = false;
			PRisAttributesProcessed = false;

			// Parsed HeaderMember Information
			PRisMustUnderstand = false;

			// Parse State
			PRparseStateEnum = InternalParseStateE.Initial;
			PRisWaitingForNestedObject = false;


			// ValueType Fixup needed
			PRisValueTypeFixup = false;

			PRnewObj = null;
			PRobjectA = null;
			PRprimitiveArray = null;			
			PRobjectInfo = null;
			PRisRegistered = false;

			PRisXmlAttribute = false;
		}

		internal ParseRecord Copy()
		{

			ParseRecord newPr = new ParseRecord();
			// Enums
			newPr.PRparseTypeEnum = PRparseTypeEnum;
			newPr.PRobjectTypeEnum = PRobjectTypeEnum;
			newPr.PRarrayTypeEnum = PRarrayTypeEnum;
			newPr.PRmemberTypeEnum = PRmemberTypeEnum;
			newPr.PRmemberValueEnum = PRmemberValueEnum;
			newPr.PRobjectPositionEnum = PRobjectPositionEnum;

			// Object
			newPr.PRname = PRname;
			newPr.PRisParsed = PRisParsed;			
            newPr.PRisProcessAttributes = PRisProcessAttributes;
			newPr.PRnameXmlKey = PRnameXmlKey;
			newPr.PRxmlNameSpace = PRxmlNameSpace;			

			// Value
			newPr.PRvalue = PRvalue;


			// dt attribute
			newPr.PRkeyDt = PRkeyDt;
			newPr.PRdtType = PRdtType;
            newPr.PRassemblyName = PRassemblyName;
			newPr.PRdtTypeCode = PRdtTypeCode;
			newPr.PRisEnum = PRisEnum;			

			// Object ID
			newPr.PRobjectId = PRobjectId;

			// Reference ID
			newPr.PRidRef = PRidRef;

			// Array

			// Array Element Type
			newPr.PRarrayElementTypeString = PRarrayElementTypeString;
			newPr.PRarrayElementType = PRarrayElementType;
			newPr.PRisArrayVariant = PRisArrayVariant;
			newPr.PRarrayElementTypeCode = PRarrayElementTypeCode;


			// Array Primitive Element type
			newPr.PRprimitiveArrayTypeString = PRprimitiveArrayTypeString;

			// Parsed array information
			newPr.PRrank = PRrank;
			newPr.PRlengthA = PRlengthA;
			newPr.PRpositionA = PRpositionA;
			newPr.PRlowerBoundA = PRlowerBoundA;
			newPr.PRupperBoundA = PRupperBoundA;		

			// Array map for placing array elements in array
			newPr.PRindexMap = PRindexMap;
			newPr.PRmemberIndex = PRmemberIndex;
			newPr.PRlinearlength = PRlinearlength;
			newPr.PRrectangularMap = PRrectangularMap;
			newPr.PRisLowerBound = PRisLowerBound;

			// SerializedStreamHeader information
			newPr.PRtopId = PRtopId;
			newPr.PRheaderId = PRheaderId;
			newPr.PRisHeaderRoot = PRisHeaderRoot;
			newPr.PRisAttributesProcessed = PRisAttributesProcessed;

			// Parsed HeaderMember Information
			newPr.PRisMustUnderstand = PRisMustUnderstand;

			// Parse State
			newPr.PRparseStateEnum = PRparseStateEnum;
			newPr.PRisWaitingForNestedObject = PRisWaitingForNestedObject;


			// ValueType Fixup needed
			newPr.PRisValueTypeFixup = PRisValueTypeFixup;

			newPr.PRnewObj = PRnewObj;
			newPr.PRobjectA = PRobjectA;
			newPr.PRprimitiveArray = PRprimitiveArray;
			newPr.PRobjectInfo = PRobjectInfo;
			newPr.PRisRegistered = PRisRegistered;
			newPr.PRisXmlAttribute = PRisXmlAttribute;

			return newPr;
		}		


		// Dump ParseRecord. 
		[Conditional("SER_LOGGING")]								
		internal void Dump()
		{
			InternalST.Soap("ParseRecord Dump ",PRparseRecordId);
			InternalST.Soap("Enums");
			Util.NVTrace("ParseType",((Enum)PRparseTypeEnum).ToString());
			Util.NVTrace("ObjectType",((Enum)PRobjectTypeEnum).ToString());
			Util.NVTrace("ArrayType",((Enum)PRarrayTypeEnum).ToString());
			Util.NVTrace("MemberType",((Enum)PRmemberTypeEnum).ToString());
			Util.NVTrace("MemberValue",((Enum)PRmemberValueEnum).ToString());
			Util.NVTrace("ObjectPosition",((Enum)PRobjectPositionEnum).ToString());
			Util.NVTrace("ParseState",((Enum)PRparseStateEnum).ToString());				
			InternalST.Soap("Basics");		
			Util.NVTrace("Name",PRname);
			Util.NVTrace("PRisParsed", PRisParsed);
			Util.NVTrace("PRisProcessAttributes", PRisParsed);
			Util.NVTrace("PRnameXmlKey",PRnameXmlKey);
			Util.NVTrace("PRxmlNameSpace", PRxmlNameSpace);		
			Util.NVTrace("Value ",PRvalue);
			Util.NVTrace("varValue ",PRvarValue);
			if (PRvarValue != null)
				Util.NVTrace("varValue type",PRvarValue.GetType());				

			Util.NVTrace("keyDt",PRkeyDt);
			Util.NVTrace("dtType",PRdtType);
			Util.NVTrace("assemblyName",PRassemblyName);
			Util.NVTrace("code",((Enum)PRdtTypeCode).ToString());
			Util.NVTrace("objectID",PRobjectId);
			Util.NVTrace("idRef",PRidRef);
			Util.NVTrace("isEnum",PRisEnum);			
			InternalST.Soap("Array ");
			Util.NVTrace("arrayElementTypeString",PRarrayElementTypeString);
			Util.NVTrace("arrayElementType",PRarrayElementType);
			Util.NVTrace("arrayElementTypeCode",((Enum)PRarrayElementTypeCode).ToString());		
			Util.NVTrace("isArrayVariant",PRisArrayVariant);
			Util.NVTrace("primitiveArrayTypeString",PRprimitiveArrayTypeString);
			Util.NVTrace("rank",PRrank);
			Util.NVTrace("dimensions", Util.PArray(PRlengthA));
			Util.NVTrace("position", Util.PArray(PRpositionA));
			Util.NVTrace("lowerBoundA", Util.PArray(PRlowerBoundA));
			Util.NVTrace("upperBoundA", Util.PArray(PRupperBoundA));		
			InternalST.Soap("Header ");		
			Util.NVTrace("isMustUnderstand", PRisMustUnderstand);
			Util.NVTrace("isHeaderRoot", PRisHeaderRoot);
			Util.NVTrace("isAttributesProcessed", PRisAttributesProcessed);
			Util.NVTrace("isXmlAttribute", PRisXmlAttribute);

			InternalST.Soap("New Object");
			if (PRnewObj != null)
				Util.NVTrace("newObj", PRnewObj);
			/*
			if ((objectInfo != null) && (objectInfo.objectType != null))
			Util.NVTrace("objectInfo", objectInfo.objectType.ToString());
			*/
		}
	}

	internal interface ITrace
	{
		String Trace();
	}

	// Utilities
	internal sealed class Util
	{
		
		// Replaces a null string with an empty string
		internal static String PString(String value)
		{
			if (value == null)
				return "";
			else
				return value;
		}

		// Converts an object to a string and checks for nulls
		internal static String PString(Object value)
		{
			if (value == null)
				return "";
			else
				return value.ToString();
		}

		// Converts a single int array to a string

		internal static String PArray(int[] array)
		{
			if (array != null)
			{
				StringBuilder sb = new StringBuilder(10);
				sb.Append("[");		
				for (int i=0; i<array.Length; i++)
				{
					sb.Append(array[i]);
					if (i != array.Length -1)
						sb.Append(",");
				}
				sb.Append("]");
				return sb.ToString();
			}
			else
				return "";
		}


		// Traces an name value pair

		[Conditional("SER_LOGGING")]								
		internal static void NVTrace(String name, String value)
		{
            InternalST.Soap("  "+name+((value == null)?" = null":" = "+value));
		}

		// Traces an name value pair
		[Conditional("SER_LOGGING")]										
		internal static void NVTrace(String name, Object value)
		{
            try {
			InternalST.Soap("  "+name+((value == null)?" = null":" = "+value.ToString()));			
            }catch(Exception)
            {
                InternalST.Soap("  "+name+" = null"); //Empty StringBuilder is giving an exception
            }
		}

		// Traces an name value pair

		[Conditional("_LOGGING")]								
		internal static void NVTraceI(String name, String value)
		{
			InternalST.Soap("  "+name+((value == null)?" = null":" = "+value));			
		}

		// Traces an name value pair
		[Conditional("_LOGGING")]										
		internal static void NVTraceI(String name, Object value)
		{
			InternalST.Soap("  "+name+((value == null)?" = null":" = "+value.ToString()));			
		}

	}


	// Used to fixup value types. Only currently used for valuetypes which are array items.
	internal class ValueFixup : ITrace
	{
		internal ValueFixupEnum valueFixupEnum = ValueFixupEnum.Empty;
		internal Array arrayObj;
		internal int[] indexMap;
		internal Object header;
		internal Object memberObject;
		internal static MemberInfo valueInfo;
		internal ReadObjectInfo objectInfo;
		internal String memberName;

		internal ValueFixup(Array arrayObj, int[] indexMap)
		{
			InternalST.Soap(this, "Array Constructor ",arrayObj);										
			valueFixupEnum = ValueFixupEnum.Array;
			this.arrayObj = arrayObj;
			this.indexMap = indexMap;
		}

		internal ValueFixup(Object header)
		{
			InternalST.Soap(this, "Header Constructor ",header);												
			valueFixupEnum = ValueFixupEnum.Header;
			this.header = header;
		}

		internal ValueFixup(Object memberObject, String memberName, ReadObjectInfo objectInfo)
		{
			InternalST.Soap(this, "Member Constructor ",memberObject);												
			valueFixupEnum = ValueFixupEnum.Member;
			this.memberObject = memberObject;
			this.memberName = memberName;
			this.objectInfo = objectInfo;
		}

		internal virtual void Fixup(ParseRecord record, ParseRecord parent)
		{
            Object obj = record.PRnewObj;
			InternalST.Soap(this, "Fixup ",obj," ",((Enum)valueFixupEnum).ToString());

			switch(valueFixupEnum)
			{
				case ValueFixupEnum.Array:
					arrayObj.SetValue(obj, indexMap);
					break;
				case ValueFixupEnum.Header:
					Type type = typeof(Header);
					if (valueInfo == null)
					{
						MemberInfo[] valueInfos = type.GetMember("Value");
						if (valueInfos.Length != 1)
							throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_HeaderReflection"),valueInfos.Length));																				
						valueInfo = valueInfos[0];
					}
					InternalST.SerializationSetValue((FieldInfo)valueInfo, header, obj);
					break;
				case ValueFixupEnum.Member:

					InternalST.Soap(this, "Fixup Member new object value ",obj," memberObject ",memberObject);

                    if (objectInfo.isSi) {
                        InternalST.Soap(this, "Recording a fixup on member: ", memberName, 
                                     " in object id", parent.PRobjectId, " Required Object ", record.PRobjectId);
                        objectInfo.objectManager.RecordDelayedFixup(parent.PRobjectId, memberName, record.PRobjectId);
                    } else {
                        MemberInfo memberInfo = objectInfo.GetMemberInfo(memberName);
                        InternalST.Soap(this, "Recording a fixup on member:", memberInfo, " in object id ", 
                                     parent.PRobjectId," Required Object", record.PRobjectId);
                        objectInfo.objectManager.RecordFixup(parent.PRobjectId, memberInfo, record.PRobjectId);
                    }
					break;
			}
		}

		public virtual String Trace()
		{
			return "ValueFixup"+((Enum)valueFixupEnum).ToString();
		}

	}

	// Class used to transmit Enums from the XML and Binary Formatter class to the ObjectWriter and ObjectReader class
	internal sealed class InternalFE
	{
		internal FormatterTypeStyle FEtypeFormat;
		internal FormatterAssemblyStyle FEassemblyFormat;
		internal ISoapMessage FEtopObject;
		internal TypeFilterLevel FEsecurityLevel;
		internal InternalSerializerTypeE FEserializerTypeEnum;
	}

	// Class used to Read an XML record which has a fake object as the top object.
	// A fake object is an object which has the methodName as the XML elementName rather
	// then a valid object name.
	// After the information is read a SoapMessage object is created as the top object
	// to return the information as the top object graph
	[Serializable]	
	internal sealed class InternalSoapMessage : ISerializable, IFieldInfo
	{
		internal String methodName = null;
		internal String xmlNameSpace = null;
		internal String[] paramNames = null;
		internal Object[] paramValues = null;
		internal Type[] paramTypes = null;
        internal Hashtable keyToNamespaceTable = null;

		// Read Constructor
		internal InternalSoapMessage()
		{
			InternalST.Soap(this, "Constructor Read  Unitialized ");
		}

		// Write Constructor
		internal InternalSoapMessage(String methodName, String xmlNameSpace, String[] paramNames, Object[] paramValues, Type[] paramTypes)
		{
			InternalST.Soap(this, "Constructor Write ",methodName);
			this.methodName = methodName;
			this.xmlNameSpace = xmlNameSpace;
			this.paramNames = paramNames;
			this.paramValues = paramValues;
			this.paramTypes = paramTypes;
		}

		internal InternalSoapMessage(SerializationInfo info, StreamingContext context)
		{
			InternalST.Soap(this, "Constructor Write  SetObjectData ");			
			SetObjectData(info, context);
		}

		private bool IsNull(Object value)
		{
			if (value == null)
				return true;
			else
				return false;
		}

		// IFieldInfo 
		public String[] FieldNames
		{
			get {return paramNames;}
			set {paramNames = value;}
		}

		// IFieldInfo 		
		public Type[] FieldTypes
		{
			get {return paramTypes;}
			set {paramTypes = value;}
		}

	
		public void GetObjectData(SerializationInfo info, StreamingContext context)
		{

			int numberOfMembers = 0;

			if (paramValues != null)
				numberOfMembers = paramValues.Length;

			InternalST.Soap(this, "GetObjectData ",methodName," "+numberOfMembers);		

			info.FullTypeName = methodName;
			if (xmlNameSpace != null)
				info.AssemblyName = xmlNameSpace;

			String paramName = null;
			if (paramValues != null)
			{
				for (int i=0; i<paramValues.Length; i++)
				{
					InternalST.Soap(this, "GetObjectData AddValue ",paramNames[i]," ",paramValues[i]);

					if ((paramNames != null) && (paramNames[i] == null))
						paramName = "param"+i;
					else
						paramName = paramNames[i];
					info.AddValue(paramName, paramValues[i], typeof(Object));
				}
			}

		}

		internal void SetObjectData(SerializationInfo info, StreamingContext context)
		{
			InternalST.Soap(this, "SetObjectData ");					
			ArrayList paramValuesList = new ArrayList(20); 
            methodName = (string)info.GetString("__methodName");
            keyToNamespaceTable = (Hashtable)info.GetValue("__keyToNamespaceTable", typeof(Hashtable));
            ArrayList paramNamesList = (ArrayList)info.GetValue("__paramNameList", typeof(ArrayList));
			xmlNameSpace = (String)info.GetString("__xmlNameSpace");

            for (int i=0; i<paramNamesList.Count; i++)
				paramValuesList.Add(info.GetValue((string)paramNamesList[i], Converter.typeofObject));

			paramNames = new String[paramNamesList.Count];
			paramValues = new Object[paramValuesList.Count];

			for (int i=0; i<paramNamesList.Count; i++)
			{
				paramNames[i] = (String)paramNamesList[i];
				paramValues[i] = (Object)paramValuesList[i];
				InternalST.Soap(this, "SetObjectData param ",i," ",paramNames[i]," paramValue ",paramValues[i]);																	
			}
		}
	}

	internal sealed class SoapAttributeInfo
	{
		internal SoapAttributeType m_attributeType;
		internal String m_nameSpace;
		internal String m_elementName;
		internal String m_typeName;
		internal String m_typeNamespace;

		internal String AttributeNameSpace
		{
			get {return m_nameSpace;}
		}

		internal String AttributeElementName
		{
			get {return m_elementName;}
		}

		internal String AttributeTypeName
		{
			get {return m_typeName;}
		}

		internal String AttributeTypeNamespace
		{
		    get {return m_typeNamespace;}
		}

		internal bool IsEmbedded()
		{
			if ((m_attributeType & SoapAttributeType.Embedded) > 0)
				return true;
			else
				return false;
		}

		internal bool IsXmlElement()
		{
			if ((m_attributeType & SoapAttributeType.XmlElement) > 0)
				return true;
			else
				return false;
		}

		internal bool IsXmlAttribute()
		{
			if ((m_attributeType & SoapAttributeType.XmlAttribute) > 0)
				return true;
			else
				return false;
		}

		internal bool IsXmlType()
		{
			if ((m_attributeType & SoapAttributeType.XmlType) > 0)
				return true;
			else
				return false;
		}
		
		[Conditional("SER_LOGGING")]
		internal void Dump(String id)
		{
			InternalST.Soap("Dump SoapAttributeInfo ", id);
			if (IsXmlType())
				InternalST.Soap("   SchemaType");
			if (IsEmbedded())
				InternalST.Soap("   Embedded");
			if (IsXmlElement())
				InternalST.Soap("   XmlElement");
			if (IsXmlAttribute())
				InternalST.Soap("   XmlAttribute");			
			Util.NVTrace("_nameSpace", m_nameSpace);
			Util.NVTrace("_elementName", m_elementName);
			Util.NVTrace("_type", m_typeName);			
		}
	}

    internal class ObjectIdentityComparer : IComparer
    {
        //READTHIS READTHIS
       //This cannot be used for sorting objects, but it's useful in a hashtable
        //where we just care about equality.
        public int Compare(Object x, Object y) {
        
            if (x==y) {
                return 0;
            }

            return 1;
        }
    }

    internal class ObjectHashCodeProvider : IHashCodeProvider
    {
        public int GetHashCode(Object obj)
        {
            return obj.GetHashCode();

        }
    }

    	
	

	internal sealed class NameInfo
	{
		internal InternalNameSpaceE NInameSpaceEnum = InternalNameSpaceE.None;
		internal String NIname; // Name from SerObjectInfo.GetType
		//internal String elementName; // Name from SerObjectInfo.GetElementName, will be the same as GetType except for interopTypes
		//internal String interopType; 
		internal long NIobjectId;
		internal long NIassemId;
		internal InternalPrimitiveTypeE NIprimitiveTypeEnum = InternalPrimitiveTypeE.Invalid;
		internal Type NItype;
		internal bool NIisSealed;
		internal bool NIisMustUnderstand;
		internal String NInamespace;
		internal String NIheaderPrefix;
		internal String NIitemName;
		internal bool NIisArray;
		internal bool NIisArrayItem;
		internal bool NIisTopLevelObject;
		internal bool NIisNestedObject;
		internal bool NItransmitTypeOnObject;
		internal bool NItransmitTypeOnMember;
		internal bool NIisParentTypeOnObject;
		internal bool NIisHeader;
        internal bool NIisRemoteRecord;
		internal int NIid;
		internal SoapAttributeInfo NIattributeInfo;

		private static int count;

		internal NameInfo()
		{
			Counter();
		}

		[Conditional("SER_LOGGING")]
		private void Counter()
		{
			lock(typeof(NameInfo))
			{
				NIid = count++;
			}
		}

		internal void Init()
		{
			NInameSpaceEnum = InternalNameSpaceE.None;
			NIname = null;
			NIobjectId = 0;
			NIassemId = 0;
			NIprimitiveTypeEnum = InternalPrimitiveTypeE.Invalid;
			NItype = null;
			NIisSealed = false;
			NItransmitTypeOnObject = false;
			NItransmitTypeOnMember = false;
			NIisParentTypeOnObject = false;
			NIisMustUnderstand = false;
			NInamespace = null;
			NIheaderPrefix = null;
			NIitemName = null;
			NIisArray = false;
			NIisArrayItem = false;
			NIisTopLevelObject = false;
			NIisNestedObject = false;
			NIisHeader = false;
            NIisRemoteRecord = false;
			NIattributeInfo = null;
		}

		[Conditional("SER_LOGGING")]
		internal void Dump(String value)
		{
			InternalST.Soap("Dump NameInfo ",NIid," ",value);
			Util.NVTrace("nameSpaceEnum", ((Enum)NInameSpaceEnum).ToString());
			Util.NVTrace("name", NIname);
			Util.NVTrace("objectId", NIobjectId);
			Util.NVTrace("assemId", NIassemId);
			Util.NVTrace("primitiveTypeEnum", ((Enum)NIprimitiveTypeEnum).ToString());
			Util.NVTrace("type", NItype);
			Util.NVTrace("isSealed", NIisSealed);			
			Util.NVTrace("transmitTypeOnObject", NItransmitTypeOnObject);
			Util.NVTrace("transmitTypeOnMember", NItransmitTypeOnMember);
			Util.NVTrace("isParentTypeOnObject", NIisParentTypeOnObject);				
			Util.NVTrace("isMustUnderstand", NIisMustUnderstand);
			Util.NVTrace("namespace", NInamespace);
			Util.NVTrace("headerPrefix", NIheaderPrefix);
			Util.NVTrace("itemName", NIitemName);				
			Util.NVTrace("isArray", NIisArray);
			Util.NVTrace("isArrayItem", NIisArrayItem);
			Util.NVTrace("isTopLevelObject", NIisTopLevelObject);
			Util.NVTrace("isNestedObject", NIisNestedObject);
			Util.NVTrace("isHeader", NIisHeader);
			Util.NVTrace("isRemoteRecord", NIisRemoteRecord);
			if (NIattributeInfo != null)
				NIattributeInfo.Dump(NIname);
		}

	}

	internal sealed class PrimitiveArray
	{
		InternalPrimitiveTypeE code;
		Boolean[] booleanA = null;
		Char[] charA = null;
		Double[] doubleA = null;
		Int16[] int16A = null;
		Int32[] int32A = null;
		Int64[] int64A = null;
		SByte[] sbyteA = null;
		Single[] singleA = null;
		UInt16[] uint16A = null;
		UInt32[] uint32A = null;
		UInt64[] uint64A = null;


		internal PrimitiveArray(InternalPrimitiveTypeE code, Array array)
		{
			Init(code, array);
		}

		internal void Init(InternalPrimitiveTypeE code, Array array)
		{
			this.code = code;
			switch(code)
			{
				case InternalPrimitiveTypeE.Boolean:
					booleanA = (Boolean[])array;
					break;
				case InternalPrimitiveTypeE.Char:
					charA = (Char[])array;
					break;					
				case InternalPrimitiveTypeE.Double:
					doubleA = (Double[])array;
					break;					
				case InternalPrimitiveTypeE.Int16:
					int16A = (Int16[])array;
					break;					
				case InternalPrimitiveTypeE.Int32:
					int32A = (Int32[])array;
					break;					
				case InternalPrimitiveTypeE.Int64:
					int64A = (Int64[])array;
					break;					
				case InternalPrimitiveTypeE.SByte:
					sbyteA = (SByte[])array;
					break;					
				case InternalPrimitiveTypeE.Single:
					singleA = (Single[])array;
					break;					
				case InternalPrimitiveTypeE.UInt16:
					uint16A = (UInt16[])array;
					break;					
				case InternalPrimitiveTypeE.UInt32:
					uint32A = (UInt32[])array;
					break;					
				case InternalPrimitiveTypeE.UInt64:
					uint64A = (UInt64[])array;
					break;
			}
		}

		internal String GetValue(int index)
		{
			String value = null;
			switch(code)
			{
				case InternalPrimitiveTypeE.Boolean:
					value =  (booleanA[index]).ToString();
					break;
				case InternalPrimitiveTypeE.Char:
					if (charA[index] == Char.MinValue)
						value = "_0x00_";
					else
						value =  Char.ToString(charA[index]);
					break;					
                case InternalPrimitiveTypeE.Double:
                    if (Double.IsPositiveInfinity(doubleA[index]))
                        value = "INF";
                    else if (Double.IsNegativeInfinity(doubleA[index]))
                        value = "-INF";
                    else
                        value =  (doubleA[index]).ToString("R", CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.Int16:
					value =  (int16A[index]).ToString(CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.Int32:
					value =  (int32A[index]).ToString(CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.Int64:
					value =  (int64A[index]).ToString(CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.SByte:
					value =  (sbyteA[index]).ToString(CultureInfo.InvariantCulture);
					break;					
                case InternalPrimitiveTypeE.Single:
                    if (Single.IsPositiveInfinity(singleA[index]))
                        value = "INF";
                    else if (Single.IsNegativeInfinity(singleA[index]))
                        value = "-INF";
                    else
                        value =  (singleA[index]).ToString("R", CultureInfo.InvariantCulture);
					break;
				case InternalPrimitiveTypeE.UInt16:
					value =  (uint16A[index]).ToString(CultureInfo.InvariantCulture);
					break;
				case InternalPrimitiveTypeE.UInt32:
					value =  (uint32A[index]).ToString(CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.UInt64:
					value =  (uint64A[index]).ToString(CultureInfo.InvariantCulture);
					break;					
			}
			return value;
		}

		internal void SetValue(String value, int index)
		{
			InternalST.Soap("PrimitiveArray value ", value," index ", index, " code ",((Enum)code).ToString());
			switch(code)
			{
				case InternalPrimitiveTypeE.Boolean:
					booleanA[index] = Boolean.Parse(value);
					break;
				case InternalPrimitiveTypeE.Char:
					if ((value[0] == '_') && (value.Equals("_0x00_")))
						charA[index] = Char.MinValue;
					else
						charA[index] = Char.Parse(value);
					break;					
                case InternalPrimitiveTypeE.Double:
                    if (value == "INF")
                        doubleA[index] =  Double.PositiveInfinity;
                    else if (value == "-INF")
                        doubleA[index] =  Double.NegativeInfinity;
                    else
                        doubleA[index] = Double.Parse(value, CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.Int16:
					int16A[index] = Int16.Parse(value, CultureInfo.InvariantCulture);															
					break;					
				case InternalPrimitiveTypeE.Int32:
					int32A[index] = Int32.Parse(value, CultureInfo.InvariantCulture);																				
					break;					
				case InternalPrimitiveTypeE.Int64:
					int64A[index] = Int64.Parse(value, CultureInfo.InvariantCulture);																									
					break;					
				case InternalPrimitiveTypeE.SByte:
					sbyteA[index] = SByte.Parse(value, CultureInfo.InvariantCulture);
					break;					
                case InternalPrimitiveTypeE.Single:
                    if (value == "INF")
                        singleA[index] =  Single.PositiveInfinity;
                    else if (value == "-INF")
                        singleA[index] =  Single.NegativeInfinity;
                    else
                        singleA[index] = Single.Parse(value, CultureInfo.InvariantCulture);
					break;
				case InternalPrimitiveTypeE.UInt16:
					uint16A[index] = UInt16.Parse(value, CultureInfo.InvariantCulture);
					break;
				case InternalPrimitiveTypeE.UInt32:
					uint32A[index] = UInt32.Parse(value, CultureInfo.InvariantCulture);					
					break;					
				case InternalPrimitiveTypeE.UInt64:
					uint64A[index] = UInt64.Parse(value, CultureInfo.InvariantCulture);					
					break;					
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\soapenums.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: FormatterEnums
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Soap XML Formatter Enums
 **
 ** Date:  August 23, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Soap {
	using System.Threading;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	using System;

    // Enums are for internal use by the XML and Binary Serializers
    // They will eventually signed to restrict there use

	// Formatter Enums
	[Serializable]
	internal enum InternalSerializerTypeE
	{
		Soap = 1,
		Binary = 2,
	}

	// Writer Enums
	[Serializable]
	internal enum InternalElementTypeE
	{
		ObjectBegin = 0,
		ObjectEnd = 1,
		Member = 2,
	}

	// ParseRecord Enums
	[Serializable]
	internal enum InternalParseTypeE
	{
		Empty = 0,
		SerializedStreamHeader = 1,
		Object = 2,
		Member = 3,
		ObjectEnd = 4,
		MemberEnd = 5,
		Headers = 6,
		HeadersEnd = 7,
		SerializedStreamHeaderEnd = 8,
		Envelope = 9,
		EnvelopeEnd = 10,
		Body = 11,
		BodyEnd = 12,
	}


	[Serializable]
	internal enum InternalObjectTypeE
	{
		Empty = 0,
		Object = 1,
		Array = 2,
	}


	[Serializable]
	internal enum InternalObjectPositionE
	{
		Empty = 0,
		Top = 1,
		Child = 2,
		Headers = 3,
	}

	[Serializable]
	internal enum InternalArrayTypeE
	{
		Empty = 0,
		Single = 1,
		Jagged = 2,
		Rectangular = 3,
		Base64 = 4,
	}

	[Serializable]
	internal enum InternalMemberTypeE
	{
		Empty = 0,
		Header = 1,
		Field = 2,
		Item = 3,
	}

	[Serializable]
	internal enum InternalMemberValueE
	{
		Empty = 0,
		InlineValue = 1,
		Nested = 2,
		Reference = 3,
		Null = 4,
	}

	// XML Parse Enum
	[Serializable]
	internal enum InternalParseStateE
	{
		Initial = 0,
		Object = 1,
		Member = 2,
		MemberChild = 3,
	}

	// Data Type Enums
	[Serializable]
	internal enum InternalPrimitiveTypeE
	{
		Invalid = 0,
		Boolean = 1,
		Byte = 2,
		Char = 3,
		Currency = 4,
		Decimal = 5,
		Double = 6,
		Int16 = 7,
		Int32 = 8,
		Int64 = 9,
		SByte = 10,
		Single = 11,
		TimeSpan = 12,
		DateTime = 13,
		UInt16 = 14,
		UInt32 = 15,
		UInt64 = 16,
        Time = 17,
        Date = 18,
        YearMonth =19,
        Year = 20,
        MonthDay = 21,
        Day = 22,
        Month = 23,
        HexBinary = 24,
        Base64Binary = 25,
        Integer = 26,
        PositiveInteger = 27,
        NonPositiveInteger = 28,
        NonNegativeInteger = 29,
        NegativeInteger = 30,
        AnyUri = 31,
        QName = 32,
        Notation = 33,
        NormalizedString = 34,
        Token = 35,
        Language = 36,
        Name = 37,
        Idrefs = 38,
        Entities = 39,
        Nmtoken = 40,
        Nmtokens = 41,
        NcName = 42,
        Id = 43,
        Idref = 44,
        Entity = 45,
	}

	// ValueType Fixup Enum
	[Serializable]
	enum ValueFixupEnum
	{
		Empty = 0,
		Array = 1,
		Header = 2,
		Member = 3,
	}

	// name space
	[Serializable]
	internal enum InternalNameSpaceE
	{
		None = 0,
		Soap = 1,
		XdrPrimitive = 2,
		XdrString = 3,
		UrtSystem = 4,
		UrtUser = 5,
		UserNameSpace = 6,
		MemberName = 7,
		Interop = 8,
		CallElement = 9
	}

    // These don't represent actual Attribute type's. They represent the intent
    // of various SoapXXXAttribute's that may be applied to a type.
	[Serializable]
	internal enum SoapAttributeType
	{
		None = 0x0,
		Embedded = 0x1,
		XmlElement = 0x2,
		XmlAttribute = 0x4,
        XmlType = 0x8
	}

    [Serializable]
    internal enum XsdVersion
    {
        V1999 = 0,
        V2000 = 1,
        V2001 = 2,
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\security\system\security\cryptography\xml\signedxml.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------
//
// CLASS:    SignedXml.cool
//
// AUTHOR:   Christian Caron (t-ccaron)
//
// PURPOSE:  This object serves the purpose of helping the user use the 
//           XMLDSIG class more easily. To facilitate the usage, some values
//           are defaulted for the user. Also, if the user fails to provide
//           a required piece of information, an exception with a guiding
//           message will be thrown.
// 
// DATE:     21 March 2000
// 
//---------------------------------------------------------------------------

[assembly:System.CLSCompliantAttribute(true)]
[assembly:System.Runtime.InteropServices.ComVisibleAttribute(false)]
namespace System.Security.Cryptography.Xml
{
    using System;
    using System.Text;
    using System.Xml;
    using System.Xml.XPath;
    using System.Collections;
    using System.Security;
    using System.Security.Cryptography;
    using System.Net;
    using System.IO;
    using System.Runtime.InteropServices;

    /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml"]/*' />
    public class SignedXml
    {
        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.m_signature"]/*' />
        /// <internalonly/>
        protected Signature m_signature;
        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.m_strSigningKeyName"]/*' />
        /// <internalonly/>
        protected String m_strSigningKeyName;
        private AsymmetricAlgorithm m_signingKey;
        private XmlDocument m_containingDocument = null;
        private XmlElement m_parentElement = null;
        private CanonicalXmlNodeList m_namespaces = null;
        private IEnumerator m_keyInfoEnum = null;

        private bool[] m_refProcessed = null;
        private int[] m_refLevelCache = null;

        internal XmlResolver m_xmlResolver = null;
        private bool m_bResolverSet = false;

        // Constant URL identifiers used within the Signed XML classes

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.XmlDsigNamespaceUrl"]/*' />
        public const String XmlDsigNamespaceUrl = "http://www.w3.org/2000/09/xmldsig#";

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.XmlDsigMinimalCanonicalizationUrl"]/*' />
        public const String XmlDsigMinimalCanonicalizationUrl = "http://www.w3.org/2000/09/xmldsig#minimal";

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.XmlDsigCanonicalizationUrl"]/*' />
        //public const String XmlDsigCanonicalizationUrl = "http://www.w3.org/TR/2000/CR-xml-c14n-20001026";
        // NEW URL:
        public const String XmlDsigCanonicalizationUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.XmlDsigCanonicalizationWithCommentsUrl"]/*' />
        //public const String XmlDsigCanonicalizationWithCommentsUrl = "http://www.w3.org/TR/2000/CR-xml-c14n-20001026#WithComments";
        public const String XmlDsigCanonicalizationWithCommentsUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";

        internal const String XmlDsigC14NTransformUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315"; 
        internal const String XmlDsigC14NWithCommentsTransformUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments"; 
        internal const String XmlDsigBase64TransformUrl = "http://www.w3.org/2000/09/xmldsig#base64";
        internal const String XmlDsigXPathTransformUrl = "http://www.w3.org/TR/1999/REC-xpath-19991116";
        internal const String XmlDsigXsltTransformUrl = "http://www.w3.org/TR/1999/REC-xslt-19991116";
        internal const String XmlDsigEnvelopedSignatureTransformUrl = "http://www.w3.org/2000/09/xmldsig#enveloped-signature";
        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.XmlDsigSHA1Url"]/*' />
        public const String XmlDsigSHA1Url = "http://www.w3.org/2000/09/xmldsig#sha1";
        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.XmlDsigDSAUrl"]/*' />
        public const String XmlDsigDSAUrl = "http://www.w3.org/2000/09/xmldsig#dsa-sha1";
        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.XmlDsigRSASHA1Url"]/*' />
        public const String XmlDsigRSASHA1Url = "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.XmlDsigHMACSHA1Url"]/*' />
        public const String XmlDsigHMACSHA1Url = "http://www.w3.org/2000/09/xmldsig#hmac-sha1";

        //-------------------------- Constructors ---------------------------

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.SignedXml"]/*' />
        public SignedXml() {
            m_containingDocument = null;
            m_parentElement = null;
            m_namespaces = null;
            m_signature = new Signature();
            m_signature.SignedInfo = new SignedInfo();
            m_signingKey = null;
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.SignedXml1"]/*' />
        public SignedXml(XmlDocument document) {
            if (document == null) {
                throw new ArgumentNullException("document");
            }

            m_containingDocument = document;
            m_parentElement = document.DocumentElement;
            m_namespaces = GetPropagatedAttributes(m_parentElement);
            m_signature = new Signature();
            m_signature.SignedInfo = new SignedInfo();
            m_signingKey = null;
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.SignedXml2"]/*' />
        public SignedXml(XmlElement elem)
        {
            if (elem == null) {
                throw new ArgumentNullException("elem");
            }
            m_containingDocument = elem.OwnerDocument;
            m_parentElement = elem;
            m_namespaces = GetPropagatedAttributes(m_parentElement);
            m_signature = new Signature();
            m_signature.SignedInfo = new SignedInfo();
            m_signingKey = null;
        }

        //-------------------------- Properties -----------------------------

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.SigningKeyName"]/*' />
        /// <internalonly/>
        public String SigningKeyName
        {
            get { return m_strSigningKeyName; }
            set { m_strSigningKeyName = value; }
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.Resolver"]/*' />
        [ComVisible(false)]
        public XmlResolver Resolver
        {
            // This property only has a setter. The rationale for this is that we don't have a good value
            // to return when it has not been explicitely set, as we are using XmlSecureResolver by default
            set { 
                m_xmlResolver = value;
                m_bResolverSet = true;  
            }
        }

        internal bool ResolverSet {
            get { return m_bResolverSet; }
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.SigningKey"]/*' />
        public AsymmetricAlgorithm SigningKey
        {
            get { return m_signingKey; }
            set { m_signingKey = value; }
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.Signature"]/*' />
        public Signature Signature
        {
            get { return m_signature; }
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.SignedInfo"]/*' />
        public SignedInfo SignedInfo
        {
            get { return m_signature.SignedInfo; }
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.SignatureMethod"]/*' />
        public String SignatureMethod
        {
            get { return m_signature.SignedInfo.SignatureMethod; }
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.SignatureLength"]/*' />
        public String SignatureLength
        {
            get { return m_signature.SignedInfo.SignatureLength; }
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.SignatureValue"]/*' />
        public byte[] SignatureValue
        {
            get { return m_signature.SignatureValue; }
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.KeyInfo"]/*' />
        public KeyInfo KeyInfo
        {
            get { return m_signature.KeyInfo; }
            set { m_signature.KeyInfo = value; }
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.GetXml"]/*' />
        public XmlElement GetXml() {
            // If we have a document context, then return a signature element in this context
            if (m_containingDocument != null)
                return m_containingDocument.ImportNode(m_signature.GetXml(), true) as XmlElement;
           else
                return m_signature.GetXml();
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.LoadXml"]/*' />
        public void LoadXml(XmlElement value) {
            // Guard against nulls
            if (value == null)
                throw new ArgumentNullException("value");

            // Validate against DTD -- future hook
            // NOTE -- We might now be able to use this since our imlementation
            // of the KeyValue under KeyInfo is not what the spec exaclty specifies.
            // We can probably provide our own custom DTD in order to do the check
            // but we might reject some signature that the spec considers valid
            //ValidateXml(value);
            m_signature.LoadXml(value);
        }

        //-------------------------- Public Methods -----------------------------

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.AddReference"]/*' />
        public void AddReference(Reference reference)
        {
            m_signature.SignedInfo.AddReference(reference);
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.AddObject"]/*' />
        public void AddObject(DataObject dataObject)
        {
            m_signature.AddObject(dataObject);
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.CheckSignature"]/*' />
        public bool CheckSignature()
        {
            // We are not checking if the signature is valid in regards of it's
            // DTD. We are checking the integrity of the referenced data and the
            // SignatureValue itself
            bool bRet = false;
            AsymmetricAlgorithm key;
            
            if (KeyInfo == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_KeyInfoRequired"));
            
            do
            {
                key = GetPublicKey();
                if (key != null)
                    bRet = CheckSignature(key);
            } while (key != null && bRet == false);

            return(bRet);
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.CheckSignatureReturningKey"]/*' />
        public bool CheckSignatureReturningKey(out AsymmetricAlgorithm signingKey)
        {
            // We are not checking if the signature is valid in regards of it's
            // DTD. We are checking the integrity of the referenced data and the
            // SignatureValue itself

            bool bRet = false;
            AsymmetricAlgorithm key = null;

            if (KeyInfo == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_KeyInfoRequired"));
            
            do
            {
                key = GetPublicKey();
                if (key != null)
                    bRet = CheckSignature(key);
            } while (key != null && bRet == false);

            signingKey = key;
            return(bRet);
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.debug"]/*' />

#if _DEBUG
        private static bool debug = false;
#endif

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.CheckSignature1"]/*' />
        public bool CheckSignature(AsymmetricAlgorithm key) {
            if (key == null)
                throw new ArgumentNullException("key");

            SignatureDescription signatureDescription = (SignatureDescription) CryptoConfig.CreateFromName(m_signature.SignedInfo.SignatureMethod);
            if (signatureDescription == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureDescriptionNotCreated"));

            // Let's see if the key corresponds with the SignatureMethod             
            Type ta = Type.GetType(signatureDescription.KeyAlgorithm);
            Type tb = key.GetType();
            if ((ta != tb) && !ta.IsSubclassOf(tb) && !tb.IsSubclassOf(ta)) {
                // Signature method key mismatch
                return false;
            }

            // set up the canonicalizer & canonicalize SignedInfo
            TransformChain tc = new TransformChain();
            Transform c14nMethodTransform = (Transform) CryptoConfig.CreateFromName(SignedInfo.CanonicalizationMethod);
            if (c14nMethodTransform == null) {
                throw new CryptographicException(String.Format(SecurityResources.GetResourceString("Cryptography_Xml_CreateTransformFailed"), SignedInfo.CanonicalizationMethod));
            }
            tc.Add(c14nMethodTransform);
            XmlElement signedInfo = SignedInfo.GetXml().Clone() as XmlElement;
            // Add non default namespaces in scope
            if (m_namespaces != null) {
                foreach (XmlNode attrib in m_namespaces) {
                    string name = ((attrib.Prefix != String.Empty) ? attrib.Prefix + ":" + attrib.LocalName : attrib.LocalName);
                    // Skip the attribute if one with the same qualified name already exists
                    if (signedInfo.HasAttribute(name) || (name.Equals("xmlns") && signedInfo.NamespaceURI != String.Empty)) continue;
                    XmlAttribute nsattrib = m_containingDocument.CreateAttribute(name);
                    nsattrib.Value = ((XmlNode)attrib).Value;
                    signedInfo.SetAttributeNode(nsattrib);      
                }
            } 
            string strBaseUri = (m_containingDocument == null ? null : m_containingDocument.BaseURI);
            XmlResolver resolver = (m_bResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), strBaseUri));
            Stream canonicalizedSignedXml = tc.TransformToOctetStream(PreProcessElementInput(signedInfo, resolver, strBaseUri), resolver, strBaseUri);
                        
            // calculate the hash
            HashAlgorithm hashAlgorithm = signatureDescription.CreateDigest();
            if (hashAlgorithm == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CreateHashAlgorithmFailed"));
            byte[] hashval = hashAlgorithm.ComputeHash(canonicalizedSignedXml);

            // We can FINALLY generate the SignatureValue
#if _DEBUG
                if (debug) {
                    Console.WriteLine("Computed canonicalized SignedInfo:");
                    Console.WriteLine(signedInfo.OuterXml);
                    Console.WriteLine("Computed Hash:");
                    Console.WriteLine(Convert.ToBase64String(hashval));
                    Console.WriteLine("m_signature.SignatureValue:");
                    Console.WriteLine(Convert.ToBase64String(m_signature.SignatureValue));
                }
#endif              
            AsymmetricSignatureDeformatter asymmetricSignatureDeformatter = signatureDescription.CreateDeformatter(key);
            bool bRet = asymmetricSignatureDeformatter.VerifySignature(hashAlgorithm, m_signature.SignatureValue);

            if (bRet != true) {
#if _DEBUG
                if (debug) {
                    Console.WriteLine("Failed to verify the signature on SignedInfo.");
                }
#endif              
                return false;
            }

            // Now is the time to go through all the references and see if their
            // DigestValue are good
            return (CheckDigestedReferences());
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.CheckSignature2"]/*' />
        public bool CheckSignature(KeyedHashAlgorithm macAlg) {
            // Do some sanity checks
            if (macAlg == null)
                throw new ArgumentNullException("macAlg");

            int iSignatureLength;
            if (m_signature.SignedInfo.SignatureLength == null) {
                iSignatureLength = macAlg.HashSize;
            } else {
                iSignatureLength = Convert.ToInt32(m_signature.SignedInfo.SignatureLength);
            }

            // iSignatureLength should be less than hash size
            if (iSignatureLength < 0 || iSignatureLength > macAlg.HashSize) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidSignatureLength"));
            }
            if (iSignatureLength % 8 != 0) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidSignatureLength2"));
            }
            if (m_signature.SignatureValue == null) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureValueRequired"));       
            }
            if (m_signature.SignatureValue.Length != iSignatureLength / 8) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidSignatureLength"));
            }

            // set up the canonicalizer & canonicalize SignedInfo
            TransformChain tc = new TransformChain();
            Transform c14nMethodTransform = (Transform) CryptoConfig.CreateFromName(SignedInfo.CanonicalizationMethod);
            if (c14nMethodTransform == null) {
                throw new CryptographicException(String.Format(SecurityResources.GetResourceString("Cryptography_Xml_CreateTransformFailed"), SignedInfo.CanonicalizationMethod));
            }
            tc.Add(c14nMethodTransform);
            XmlElement signedInfo = SignedInfo.GetXml().Clone() as XmlElement;
            // Add non default namespaces in scope
            if (m_namespaces != null) {
                foreach (XmlNode attrib in m_namespaces) {
                    string name = ((attrib.Prefix != String.Empty) ? attrib.Prefix + ":" + attrib.LocalName : attrib.LocalName);
                    // Skip the attribute if one with the same qualified name already exists
                    if (signedInfo.HasAttribute(name) || (name.Equals("xmlns") && signedInfo.NamespaceURI != String.Empty)) continue;
                    XmlAttribute nsattrib = m_containingDocument.CreateAttribute(name);
                    nsattrib.Value = ((XmlNode)attrib).Value;
                    signedInfo.SetAttributeNode(nsattrib);      
                }
            } 
            string strBaseUri = (m_containingDocument == null ? null : m_containingDocument.BaseURI);
            XmlResolver resolver = (m_bResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), strBaseUri));
            Stream canonicalizedSignedXml = tc.TransformToOctetStream(PreProcessElementInput(signedInfo, resolver, strBaseUri), resolver, strBaseUri);

            // Calculate the hash
            byte[] hashValue = macAlg.ComputeHash(canonicalizedSignedXml);
#if _DEBUG
                if (debug) {
                    Console.WriteLine("Computed canonicalized SignedInfo:");
                    Console.WriteLine(signedInfo.OuterXml);
                    Console.WriteLine("Computed Hash:");
                    Console.WriteLine(Convert.ToBase64String(hashValue));
                    Console.WriteLine("m_signature.SignatureValue:");
                    Console.WriteLine(Convert.ToBase64String(m_signature.SignatureValue));
                }
#endif              
            for (int i=0; i<m_signature.SignatureValue.Length; i++) {
                if (m_signature.SignatureValue[i] != hashValue[i]) return false;
            }           
            
            return (CheckDigestedReferences());
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.ComputeSignature"]/*' />
        public void ComputeSignature()
        {
            BuildDigestedReferences();
            // Load the key
            AsymmetricAlgorithm key;
            if (SigningKey != null) {
                key = SigningKey;
            } else {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_LoadKeyFailed"));
            }

            if (key == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_LoadKeyFailed"));

            // Check the signature algorithm associated with the key so that we can accordingly set
            // the signature method
            if (key is DSA) {
                SignedInfo.SignatureMethod = XmlDsigDSAUrl;
            } else if (key is RSA) {
                // Default to RSA-SHA1
                if (SignedInfo.SignatureMethod == null) 
                    SignedInfo.SignatureMethod = XmlDsigRSASHA1Url;
            } else {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CreatedKeyFailed"));
            }
            // Compute the hash of the SignedInfo object
            XmlElement signedInfo = SignedInfo.GetXml().Clone() as XmlElement;
            // Add non default namespaces in scope
            if (m_namespaces != null) {
                foreach (XmlNode attrib in m_namespaces) {
                    string name = ((attrib.Prefix != String.Empty) ? attrib.Prefix + ":" + attrib.LocalName : attrib.LocalName);
                    // Skip the attribute if one with the same qualified name already exists
                    if (signedInfo.HasAttribute(name) || (name.Equals("xmlns") && signedInfo.NamespaceURI != String.Empty)) continue;
                    XmlAttribute nsattrib = m_containingDocument.CreateAttribute(name);
                    nsattrib.Value = ((XmlNode)attrib).Value;
                    signedInfo.SetAttributeNode(nsattrib);      
                }
            } 
#if _DEBUG
            if (debug) {
                Console.WriteLine("computed signedInfo: ");
                Console.WriteLine(signedInfo.OuterXml);
            }
#endif
            TransformChain tc = new TransformChain();
            Transform c14nMethodTransform = (Transform) CryptoConfig.CreateFromName(SignedInfo.CanonicalizationMethod);
            if (c14nMethodTransform == null) {
                throw new CryptographicException(String.Format(SecurityResources.GetResourceString("Cryptography_Xml_CreateTransformFailed"), SignedInfo.CanonicalizationMethod));
            }
            tc.Add(c14nMethodTransform);
            string strBaseUri = (m_containingDocument == null ? null : m_containingDocument.BaseURI);
            XmlResolver resolver = (m_bResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), strBaseUri));
            Stream hashInput = tc.TransformToOctetStream(PreProcessElementInput(signedInfo, resolver, strBaseUri), resolver, strBaseUri);

            // See if there is a signature description class defined through the Config file
            SignatureDescription signatureDescription = (SignatureDescription) CryptoConfig.CreateFromName(SignedInfo.SignatureMethod);
            if (signatureDescription == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureDescriptionNotCreated"));
            // calculate the hash
            HashAlgorithm hashAlg = signatureDescription.CreateDigest();
            if (hashAlg == null)
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_CreateHashAlgorithmFailed"));
            byte[] hashValue = hashAlg.ComputeHash(hashInput);
            AsymmetricSignatureFormatter asymmetricSignatureFormatter = signatureDescription.CreateFormatter(key);
            m_signature.SignatureValue = asymmetricSignatureFormatter.CreateSignature(hashAlg);
#if _DEBUG
            if (debug) {
                Console.WriteLine("computed hash value: "+Convert.ToBase64String(hashValue));
            }
#endif
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.ComputeSignature1"]/*' />
        public void ComputeSignature(KeyedHashAlgorithm macAlg) {
            // Do some sanity checks
            if (macAlg == null)
                throw new ArgumentNullException("macAlg");
            if(!(macAlg is HMACSHA1)) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_SignatureMethodKeyMismatch"));
            }           
            int iSignatureLength;
            if (m_signature.SignedInfo.SignatureLength == null) {
                iSignatureLength = macAlg.HashSize;
            } else {
                iSignatureLength = Convert.ToInt32(m_signature.SignedInfo.SignatureLength);
            }
            // iSignatureLength should be less than hash size
            if (iSignatureLength < 0 || iSignatureLength > macAlg.HashSize) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidSignatureLength"));
            }
            if (iSignatureLength % 8 != 0) {
                throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidSignatureLength2"));
            }

            BuildDigestedReferences();
            SignedInfo.SignatureMethod = XmlDsigHMACSHA1Url;
            // Compute the hash of the SignedInfo object
            XmlElement signedInfo = SignedInfo.GetXml().Clone() as XmlElement;
            // Add non default namespaces in scope
            if (m_namespaces != null) {
                foreach (XmlNode attrib in m_namespaces) {
                    string name = ((attrib.Prefix != String.Empty) ? attrib.Prefix + ":" + attrib.LocalName : attrib.LocalName);
                    // Skip the attribute if one with the same qualified name already exists
                    if (signedInfo.HasAttribute(name) || (name.Equals("xmlns") && signedInfo.NamespaceURI != String.Empty)) continue;
                    XmlAttribute nsattrib = m_containingDocument.CreateAttribute(name);
                    nsattrib.Value = ((XmlNode)attrib).Value;
                    signedInfo.SetAttributeNode(nsattrib);      
                }
            } 
#if _DEBUG
            if (debug) {
                Console.WriteLine("computed signedInfo: ");
                Console.WriteLine(signedInfo.OuterXml);
            }
#endif
            TransformChain tc = new TransformChain();
            Transform c14nMethodTransform = (Transform) CryptoConfig.CreateFromName(SignedInfo.CanonicalizationMethod);
            if (c14nMethodTransform == null) {
                throw new CryptographicException(String.Format(SecurityResources.GetResourceString("Cryptography_Xml_CreateTransformFailed"), SignedInfo.CanonicalizationMethod));
            }
            tc.Add(c14nMethodTransform);
            string strBaseUri = (m_containingDocument == null ? null : m_containingDocument.BaseURI);
            XmlResolver resolver = (m_bResolverSet ? m_xmlResolver : new XmlSecureResolver(new XmlUrlResolver(), strBaseUri));
            Stream hashInput = tc.TransformToOctetStream(PreProcessElementInput(signedInfo, resolver, strBaseUri), resolver, strBaseUri);
            byte[] hashValue = macAlg.ComputeHash(hashInput);
            m_signature.SignatureValue = new byte[iSignatureLength / 8];
            Buffer.BlockCopy(hashValue, 0, m_signature.SignatureValue, 0, iSignatureLength / 8);
#if _DEBUG
            if (debug) {
                Console.WriteLine("computed hash value: "+Convert.ToBase64String(hashValue));
            }
#endif
        }   

        //------------------------- Protected Methods ---------------------------

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.GetPublicKey"]/*' />
        protected virtual AsymmetricAlgorithm GetPublicKey()
        {
            // In the current implementation, return the next KeyInfo clause
            // that is an RSAKeyValue or DSAKeyValue. If there isn't one, return null
            if (m_keyInfoEnum == null)
                m_keyInfoEnum = KeyInfo.GetEnumerator();

            RSAKeyValue tempRSA;
            DSAKeyValue tempDSA;
            // In our implementation, we move to the next KeyInfo clause 
            // which is an RSAKeyValue or a DSAKeyValue
            while (m_keyInfoEnum.MoveNext()) {
                tempRSA = m_keyInfoEnum.Current as RSAKeyValue;
                if (tempRSA != null) return(tempRSA.Key);
                tempDSA = m_keyInfoEnum.Current as DSAKeyValue;
                if (tempDSA != null) return(tempDSA.Key);
            }
            return(null);
        }

        /// <include file='doc\SignedXml.uex' path='docs/doc[@for="SignedXml.GetIdElement"]/*' />
        public virtual XmlElement GetIdElement (XmlDocument document, string idValue) {
            if (document == null)
                return null;
            XmlElement elem = null;

            // Get the element with idValue
            elem = document.GetElementById(idValue);
            if (elem != null)
                return elem;
            elem = document.SelectSingleNode("//*[@Id=\"" + idValue + "\"]") as XmlElement;

            return elem;
        }

        //-------------------------- Internal Methods -----------------------------

        internal static String DiscardWhiteSpaces(String inputBuffer) {
            return DiscardWhiteSpaces(inputBuffer, 0, inputBuffer.Length);
        }


        internal static String DiscardWhiteSpaces(String inputBuffer, int inputOffset, int inputCount) {
            int i, iCount = 0;
            for (i=0; i<inputCount; i++)
                if (Char.IsWhiteSpace(inputBuffer[inputOffset + i])) iCount++;
            char[] rgbOut = new char[inputCount - iCount];
            iCount = 0;
            for (i=0; i<inputCount; i++)
                if (!Char.IsWhiteSpace(inputBuffer[inputOffset + i])) {
                    rgbOut[iCount++] = inputBuffer[inputOffset + i];
                }
            return new String(rgbOut);
        }

        internal static XmlValidatingReader PreProcessStreamInput (Stream inputStream, XmlResolver xmlResolver, string strBaseUri) {
            XmlTextReader xtr = new XmlTextReader(strBaseUri, inputStream);
            xtr.Normalization = true;
            xtr.XmlResolver = xmlResolver;
            XmlValidatingReader valReader = new XmlValidatingReader(xtr);
            valReader.ValidationType = ValidationType.None;
            return valReader;
        }

        internal static XmlDocument PreProcessDocumentInput (XmlDocument document, XmlResolver xmlResolver, string strBaseUri) {
            if (document == null)
                throw new ArgumentNullException("document");

            XmlDocument doc = new XmlDocument();
            doc.PreserveWhitespace = document.PreserveWhitespace;

            // Normalize the document
            XmlTextReader xtr = new XmlTextReader(strBaseUri, new StringReader(document.OuterXml));
            xtr.Normalization = true;
            xtr.XmlResolver = xmlResolver;
            XmlValidatingReader valReader = new XmlValidatingReader(xtr);
            valReader.ValidationType = ValidationType.None;
            doc.Load(valReader);

            return doc;
        }

        internal static XmlDocument PreProcessElementInput (XmlElement elem, XmlResolver xmlResolver, string strBaseUri) {
            if (elem == null)
                throw new ArgumentNullException("elem");

            XmlDocument doc = new XmlDocument();
            doc.PreserveWhitespace = true;
            // Normalize the document
            XmlTextReader xtr = new XmlTextReader(strBaseUri, new StringReader(elem.OuterXml));
            xtr.Normalization = true;
            xtr.XmlResolver = xmlResolver;
            XmlValidatingReader valReader = new XmlValidatingReader(xtr);
            valReader.ValidationType = ValidationType.None;
            doc.Load(valReader);

            return doc;

        }

        //-------------------------- private Methods -----------------------------

        // A helper function that determines if a namespace node is a committed attribute
        private static bool IsCommittedNamespace (XmlElement element, string strPrefix, string strValue) {
            if (element == null)
                throw new ArgumentNullException("element");

            string name = ((strPrefix != String.Empty) ? "xmlns:" + strPrefix : "xmlns");
            if (element.HasAttribute(name) && element.GetAttribute(name) == strValue) return true; 
            return false;
        } 

        private static bool HasNamespace (XmlElement element, string strPrefix, string strValue) {
            if (IsCommittedNamespace(element, strPrefix, strValue)) return true;
            if (element.Prefix == strPrefix && element.NamespaceURI == strValue) return true;
            return false;
        }

        private static bool IsRedundantNamespace (XmlElement element, string strPrefix, string strValue) {
            if (element == null)
                throw new ArgumentNullException("element");

            XmlNode ancestorNode = ((XmlNode)element).ParentNode;
            while (ancestorNode != null)
            {
                XmlElement ancestorElement = ancestorNode as XmlElement;
                if (ancestorElement != null) 
                    if (HasNamespace(ancestorElement, strPrefix, strValue)) return true;
                ancestorNode = ancestorNode.ParentNode;
            }

            return false;
        }

        // This method gets the attributes that should be propagated 
        private static CanonicalXmlNodeList GetPropagatedAttributes (XmlElement elem) {
            if (elem == null) 
                throw new ArgumentNullException("elem");
            
            CanonicalXmlNodeList namespaces = new CanonicalXmlNodeList();
            XmlNode ancestorNode = elem;

            if (ancestorNode == null) return null;

            bool bDefNamespaceToAdd = true;

            while (ancestorNode != null) {
                XmlElement ancestorElement = ancestorNode as XmlElement;
                if (ancestorElement == null) {
                    ancestorNode = ancestorNode.ParentNode;
                    continue;
                }
                if (!IsCommittedNamespace(ancestorElement, ancestorElement.Prefix, ancestorElement.NamespaceURI)) {
                    // Add the namespace attribute to the collection if needed
                    if (!IsRedundantNamespace(ancestorElement, ancestorElement.Prefix, ancestorElement.NamespaceURI)) {
                        string name = ((ancestorElement.Prefix != String.Empty) ? "xmlns:" + ancestorElement.Prefix : "xmlns");
                        XmlAttribute nsattrib = elem.OwnerDocument.CreateAttribute(name);
                        nsattrib.Value = ancestorElement.NamespaceURI;
                        namespaces.Add(nsattrib);
                    }
                }
                if (ancestorElement.HasAttributes) {
                    XmlAttributeCollection attribs = ancestorElement.Attributes;
                    foreach (XmlAttribute attrib in attribs) {
                        // Add a default namespace if necessary
                        if (bDefNamespaceToAdd && attrib.LocalName == "xmlns") {
                            XmlAttribute nsattrib = elem.OwnerDocument.CreateAttribute("xmlns");
                            nsattrib.Value = attrib.Value;
                            namespaces.Add(nsattrib);
                            bDefNamespaceToAdd = false;
                            continue;
                        }
                        // retain the declarations of type 'xml:*' as well
                        if (attrib.Prefix == "xmlns" || attrib.Prefix == "xml") {
                            namespaces.Add(attrib);
                            continue;
                        }
                        if (!IsCommittedNamespace(ancestorElement, attrib.Prefix, attrib.NamespaceURI)) {
                            // Add the namespace attribute to the collection if needed
                            if (!IsRedundantNamespace(ancestorElement, attrib.Prefix, attrib.NamespaceURI)) {
                                string name = ((attrib.Prefix != String.Empty) ? "xmlns:" + attrib.Prefix : "xmlns");
                                XmlAttribute nsattrib = elem.OwnerDocument.CreateAttribute(name);
                                nsattrib.Value = attrib.NamespaceURI;
                                namespaces.Add(nsattrib);
                            }
                        }
                    }
                }
                ancestorNode = ancestorNode.ParentNode;
            } 

            return namespaces;
        }

        private int GetReferenceLevel (int index, ArrayList references) {
            if (m_refProcessed[index]) return m_refLevelCache[index];
            m_refProcessed[index] = true;
            Reference reference = (Reference)references[index];
            if (reference.Uri == "" || (reference.Uri.Length > 0 && reference.Uri[0] != '#')) {
                m_refLevelCache[index] = 0;    
                return 0;
            }
            if (reference.Uri.Length > 0 && reference.Uri[0] == '#') {
                String idref = reference.Uri.Substring(1);
                
                if (idref == "xpointer(/)") {
                    m_refLevelCache[index] = 0;    
                    return 0;        
                }
                else if (idref.StartsWith("xpointer(id(")) {
                    int startId = idref.IndexOf("id(");
                    int endId = idref.IndexOf(")");
                    if (endId < 0 || endId < startId + 3) 
                        throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidReference"));
                    idref = idref.Substring(startId + 3, endId - startId - 3);
                    idref = idref.Replace("\'", "");
                    idref = idref.Replace("\"", "");
                }

                // If this is pointing to another refernce
                for (int j=0; j < references.Count; ++j) {
                    if (((Reference)references[j]).Id == idref) {
                        m_refLevelCache[index] = GetReferenceLevel(j, references) + 1;
                        return (m_refLevelCache[index]);
                    }
                }
                // Then the reference points to an object tag
                m_refLevelCache[index] = 0;
                return 0;
            }
            // Malformed reference
            throw new CryptographicException(SecurityResources.GetResourceString("Cryptography_Xml_InvalidReference"));
        }

        private class ReferenceLevelSortOrder : IComparer {
            private ArrayList m_references = null;           
            private SignedXml m_signedXml = null; 
            public ReferenceLevelSortOrder() {
            }

            public ArrayList References {
                get { return m_references; }
                set { m_references = value; }
            }

            public SignedXml SignedXml {
                get { return m_signedXml; }
                set { m_signedXml = value; }
            }

            public int Compare(Object a, Object b) {
                Reference referenceA = a as Reference;
                Reference referenceB = b as Reference;

                // Get the indexes
                int iIndexA = 0;
                int iIndexB = 0;
                int i = 0;
                foreach (Reference reference in References) {
                    if (reference == referenceA) iIndexA = i;
                    if (reference == referenceB) iIndexB = i;
                    i++;
                }

                int iLevelA = SignedXml.GetReferenceLevel(iIndexA, References);
                int iLevelB = SignedXml.GetReferenceLevel(iIndexB, References);
                return iLevelA.CompareTo(iLevelB);
            }
        }

        private void BuildDigestedReferences()
        {
            // Default the DigestMethod and Canonicalization
            ArrayList references = SignedInfo.References;
            // Reset the cache
            m_refProcessed = new bool[references.Count];
            m_refLevelCache = new int[references.Count];
                        
            ReferenceLevelSortOrder sortOrder = new ReferenceLevelSortOrder();
            sortOrder.References = references;
            sortOrder.SignedXml = this;
            // Don't alter the order of the references array list
            ArrayList sortedReferences = new ArrayList();
            foreach (Reference reference in references) {
                sortedReferences.Add(reference);
            }
            sortedReferences.Sort(sortOrder);

            CanonicalXmlNodeList nodeList = new CanonicalXmlNodeList();
            foreach (DataObject obj in m_signature.ObjectList) {
                nodeList.Add(obj.GetXml());
            }
            foreach (Reference reference in sortedReferences) {
                // If no DigestMethod has yet been set, default it to sha1
                if (reference.DigestMethod == null)
                    reference.DigestMethod = XmlDsigSHA1Url;
                // propagate namespaces
                reference.Namespaces = m_namespaces;
                reference.SignedXml = this;
                reference.UpdateHashValue(m_containingDocument, nodeList);
                // If this reference has an Id attribute, add it
                if (reference.Id != null)
                    nodeList.Add(reference.GetXml());
            }            
        }


        private bool CheckDigestedReferences () {
            ArrayList references = m_signature.SignedInfo.References;
            for (int i = 0; i < references.Count; ++i)
            {
                Reference digestedReference = (Reference) references[i];
                // propagate namespaces
                digestedReference.Namespaces = m_namespaces;
                digestedReference.SignedXml = this;
                byte[] calculatedHash = digestedReference.CalculateHashValue(m_containingDocument, m_signature.ReferencedItems);

                // Compare both hashes
                if (calculatedHash.Length != digestedReference.DigestValue.Length) {
#if _DEBUG
                    if (debug) {
                        Console.WriteLine("Failed to verify hash for reference {0} -- hashes didn't match length.",i);
                    }
#endif
                    return false;
                }

                byte[] rgb1 = calculatedHash;
                byte[] rgb2 = digestedReference.DigestValue;
                for (int j = 0; j < rgb1.Length; ++j)
                {
                    if (rgb1[j] != rgb2[j]) {
#if _DEBUG
                        if (debug) {
                            Console.WriteLine("Failed to verify has for reference {0} -- hashes didn't match value.",i);
                            Console.WriteLine("Computed hash: "+Convert.ToBase64String(rgb1));
                            Console.WriteLine("Claimed hash: "+Convert.ToBase64String(rgb2));
                        }
#endif
                        return false;
                    }
                }
            }
            return true;  
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\soapformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: SoapFormatter
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Soap XML Formatter
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/
 
[assembly:System.CLSCompliant(true)]

// These two attributes are for supporting side-by-side of COM-visible
// objects with NDP 1.0 RTM. This needs to be set on all assemblies that
// expose COM-visible types to be made Side by Side with NDP 1.0 RTM.
// This declaration covers System.Runtime.Serialization.Formatters.Soap.dll

[assembly:System.Runtime.InteropServices.ComCompatibleVersion(1,0,3300,0)]
[assembly:System.Runtime.InteropServices.TypeLibVersion(1,10)]

namespace System.Runtime.Serialization.Formatters.Soap
{

	using System;
	using System.Runtime.Serialization.Formatters;
	using System.IO;
	using System.Reflection;
	using System.Globalization;
	using System.Collections;
	using System.Runtime.Serialization;
	using System.Runtime.Remoting;	
	using System.Runtime.Remoting.Messaging;	
	using System.Text;


	/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter"]/*' />

	sealed public class SoapFormatter : IRemotingFormatter
	{
		private SoapParser soapParser = null;
		private ISurrogateSelector m_surrogates;
		private StreamingContext m_context;
		private FormatterTypeStyle m_typeFormat = FormatterTypeStyle.TypesWhenNeeded;
		private ISoapMessage m_topObject = null;
		//private FormatterAssemblyStyle m_assemblyFormat = FormatterAssemblyStyle.Simple;		
        private FormatterAssemblyStyle m_assemblyFormat = FormatterAssemblyStyle.Full;		
        private TypeFilterLevel m_securityLevel = TypeFilterLevel.Full;
        private SerializationBinder m_binder;
		private Stream currentStream = null;


    	// Property which specifies an object of type ISoapMessage into which
		// the SoapTop object is serialized. Should only be used if the Soap 
		// top record is a methodCall or methodResponse element. 
		/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.TopObject"]/*' />
		public ISoapMessage TopObject
		{
			get {return m_topObject;}
			set {m_topObject = value;}
		}

    	// Property which specifies how types are serialized,
    	// FormatterTypeStyle Enum specifies options
		/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.TypeFormat"]/*' />
		public FormatterTypeStyle TypeFormat
		{
			get {return m_typeFormat;}
			set
			{
				// Reset the value if TypesWhenNeeded
				// Or the value for TypesAlways and XsdString
				if (value == FormatterTypeStyle.TypesWhenNeeded)
					m_typeFormat = FormatterTypeStyle.TypesWhenNeeded;
				else
					m_typeFormat |= value;
			}
		}		

    	// Property which specifies how types are serialized,
    	// FormatterAssemblyStyle Enum specifies options
		/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.AssemblyFormat"]/*' />
		public FormatterAssemblyStyle AssemblyFormat
		{
			get {return m_assemblyFormat;}
			set {m_assemblyFormat = value;}
		}	
		
    
    	// Property which specifies the security level of formatter
    	// TypeFilterLevel Enum specifies options
		/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.FilterLevel"]/*' />
        [System.Runtime.InteropServices.ComVisible(false)]
		public TypeFilterLevel FilterLevel
		{
			get {return m_securityLevel;}
			set {m_securityLevel = value;}
		}	
		
    	// Constructor
		/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.SoapFormatter"]/*' />
		public SoapFormatter()
		{
			m_surrogates=null;
			m_context = new StreamingContext(StreamingContextStates.All);
		}

    	// Constructor
		/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.SoapFormatter1"]/*' />
		public SoapFormatter(ISurrogateSelector selector, StreamingContext context)
		{
			m_surrogates = selector;
			m_context = context;
		}

    	// Deserialize the stream into an object graph.
		/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.Deserialize"]/*' />
		public Object Deserialize(Stream serializationStream)
		{
			return Deserialize(serializationStream, null);
		}

    	// Deserialize the stream into an object graph.
		/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.Deserialize1"]/*' />
		public Object Deserialize(Stream serializationStream, HeaderHandler handler) {
			InternalST.InfoSoap("Enter SoapFormatter.Deserialize ");			
            if (serializationStream==null) {
                throw new ArgumentNullException("serializationStream");
            }

			if (serializationStream.CanSeek && (serializationStream.Length == 0))
				throw new SerializationException(SoapUtil.GetResourceString("Serialization_Stream"));								

			InternalST.Soap( this, "Deserialize Entry");
			InternalFE formatterEnums = new InternalFE();
			formatterEnums.FEtypeFormat = m_typeFormat;
			formatterEnums.FEtopObject = m_topObject;
			formatterEnums.FEserializerTypeEnum = InternalSerializerTypeE.Soap;
			formatterEnums.FEassemblyFormat = m_assemblyFormat;
			formatterEnums.FEsecurityLevel = m_securityLevel;    		
			ObjectReader sor = new ObjectReader(serializationStream, m_surrogates, m_context, formatterEnums, m_binder);

			// If this is the first call, or a new stream is being used a new Soap parser is created.
			// If this is a continuing call, then the existing SoapParser is used.
			// One stream can contains multiple Soap XML documents. The XMLParser buffers the XML so
			// that the same XMLParser has to be used to continue a stream.
			if ((soapParser == null) || (serializationStream != currentStream))
			{
				soapParser = new SoapParser(serializationStream);
				currentStream = serializationStream;
			}
			soapParser.Init(sor);
			Object obj = sor.Deserialize(handler, soapParser);
			InternalST.InfoSoap("Leave SoapFormatter.Deserialize ");
			return obj;
		}

		/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.Serialize"]/*' />
		public void Serialize(Stream serializationStream, Object graph)
		{
			Serialize(serializationStream, graph, null);
		}

    	// Commences the process of serializing the entire graph.  All of the data (in the appropriate format
    	// is emitted onto the stream).

		/// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.Serialize1"]/*' />
		public void Serialize(Stream serializationStream, Object graph, Header[] headers)
		{
			InternalST.InfoSoap("Enter SoapFormatter.Serialize ");
            if (serializationStream==null) {
                throw new ArgumentNullException("serializationStream");
            }

			InternalST.Soap( this, "Serialize Entry");
			InternalFE formatterEnums = new InternalFE();
			formatterEnums.FEtypeFormat = m_typeFormat;
			formatterEnums.FEtopObject = m_topObject;
			formatterEnums.FEserializerTypeEnum = InternalSerializerTypeE.Soap;
			formatterEnums.FEassemblyFormat = m_assemblyFormat;
			ObjectWriter sow = new ObjectWriter(serializationStream, m_surrogates, m_context, formatterEnums);
			sow.Serialize(graph, headers, new SoapWriter(serializationStream));
			InternalST.InfoSoap("Leave SoapFormatter.Serialize ");			
		}

        /// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.SurrogateSelector"]/*' />
        public ISurrogateSelector SurrogateSelector {
            get {
                return m_surrogates;
            }

            set {
                m_surrogates = value;
            }
        }

        /// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.Binder"]/*' />
        public SerializationBinder Binder {
            get {
                return m_binder;
            }

            set {
                m_binder=value;
            }
        }

        /// <include file='doc\SoapFormatter.uex' path='docs/doc[@for="SoapFormatter.Context"]/*' />
        public StreamingContext Context {
            get {
                return m_context;
            }

            set {
                m_context = value;
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "System.Runtime.Serialization.Formatters.Soap.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Soap Serialization Library\0"
#define VER_ORIGFILENAME_STR    "System.Runtime.Serialization.Formatters.Soap.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\soapobjectinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: SerObjectInfo
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Holds information about an objects Members
 **
 ** Date:  September 29, 1999
 **
 ===========================================================*/


namespace System.Runtime.Serialization.Formatters.Soap
{
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Metadata;     
    using System.Runtime.Serialization;
    using System;
    using System.Collections;
    using System.Reflection;
    using System.Diagnostics;

    // This class contains information about an object. It is used so that
    // the rest of the Formatter routines can use a common interface for
    // a normal object, an ISerializable object, and a surrogate object
    //
    // The methods in this class are for the internal use of the Formatters.
    // There use will be restricted when signing is supported for assemblies
    internal sealed class WriteObjectInfo
    {
        internal int objectInfoId;

        internal Object obj;
        internal Type objectType;

        internal bool isSi = false;
        internal bool isNamed = false;
        internal bool isTyped = false;

        internal SerializationInfo si = null;

        internal SerObjectInfoCache cache = null;

        internal Object[] memberData = null;
        internal ISerializationSurrogate serializationSurrogate = null;
        internal ISurrogateSelector surrogateSelector;
        internal IFormatterConverter converter;

        internal StreamingContext context;

        internal SerObjectInfoInit serObjectInfoInit = null;

        // Writing and Parsing information
        internal long objectId;
        internal long assemId;

        private int lastPosition = 0;
        private SoapAttributeInfo parentMemberAttributeInfo;
        internal bool isArray = false;
        internal SoapAttributeInfo typeAttributeInfo;
        internal WriteObjectInfo arrayElemObjectInfo;


        internal WriteObjectInfo()
        {
        }

        internal void ObjectEnd()
        {
            InternalST.Soap( this, objectInfoId," objectType ",objectType," ObjectEnd");                                                                           
            PutObjectInfo(serObjectInfoInit, this);
        }

        private void InternalInit()
        {
            InternalST.Soap( this, objectInfoId," InternalInit");                                                                                        
            obj = null;
            objectType = null;
            isSi = false;
            isNamed = false;
            isTyped = false;
            si = null;
            cache = null;
            memberData = null;
            isArray = false;

            // Writing and Parsing information
            objectId = 0;
            assemId = 0;

            // Added for Soap
            lastPosition = 0;
            typeAttributeInfo = null;
            parentMemberAttributeInfo = null;
            arrayElemObjectInfo = null;
        }

        internal static WriteObjectInfo Serialize(Object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SoapAttributeInfo attributeInfo)
        {
            WriteObjectInfo soi = GetObjectInfo(serObjectInfoInit);

            soi.InitSerialize(obj, surrogateSelector, context, serObjectInfoInit, converter, attributeInfo);
            return soi;
        }

        // Write constructor
        internal void InitSerialize(Object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SoapAttributeInfo attributeInfo)
        {
            InternalST.Soap( this, objectInfoId," Constructor 1 ",obj);        
            this.context = context;
            this.obj = obj;
            this.serObjectInfoInit = serObjectInfoInit;
            this.parentMemberAttributeInfo = attributeInfo;
            this.surrogateSelector = surrogateSelector;
            this.converter = converter;
            ISurrogateSelector surrogateSelectorTemp;

            if (RemotingServices.IsTransparentProxy(obj))
                objectType = Converter.typeofMarshalByRefObject;
            else
                objectType = obj.GetType();

            if (objectType.IsArray)
            {
                arrayElemObjectInfo = Serialize(objectType.GetElementType(), surrogateSelector, context, serObjectInfoInit, converter, null);
                typeAttributeInfo = GetTypeAttributeInfo();
                isArray = true;
                InitNoMembers();
                return;
            }

            InternalST.Soap( this, objectInfoId," Constructor 1 trace 2");

            typeAttributeInfo = GetTypeAttributeInfo();

            if (surrogateSelector != null && (serializationSurrogate = surrogateSelector.GetSurrogate(objectType, context, out surrogateSelectorTemp)) != null)
            {
                InternalST.Soap( this, objectInfoId," Constructor 1 trace 3");         
                si = new SerializationInfo(objectType, converter);
                if (!objectType.IsPrimitive)
                    serializationSurrogate.GetObjectData(obj, si, context);
                InitSiWrite();
            }
            else if (obj is ISerializable)
            {
                if (!objectType.IsSerializable)
                {
                    throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_NonSerType"), 
                                                                   objectType.FullName, objectType.Module.Assembly.FullName));
                }
                si = new SerializationInfo(objectType, converter);
                ((ISerializable)obj).GetObjectData(si, context);
                InternalST.Soap( this, objectInfoId," Constructor 1 trace 4 ISerializable "+objectType);                       
                InitSiWrite();
            }
            else
            {
                InternalST.Soap(this, objectInfoId," Constructor 1 trace 5");
                InitMemberInfo();
            }
        }

        [Conditional("SER_LOGGING")]                    
        private void DumpMemberInfo()
        {
            for (int i=0; i<cache.memberInfos.Length; i++)
            {
                InternalST.Soap( this, objectInfoId," Constructor 1 memberInfos data ",cache.memberInfos[i].Name," ",memberData[i]);

            }
        }

        internal static WriteObjectInfo Serialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SoapAttributeInfo attributeInfo)
        {
            WriteObjectInfo soi = GetObjectInfo(serObjectInfoInit);         
            soi.InitSerialize(objectType, surrogateSelector, context, serObjectInfoInit, converter, attributeInfo);
            return soi;         
        }

        // Write Constructor used for array types or null members
        internal void InitSerialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SoapAttributeInfo attributeInfo)
        {

            InternalST.Soap( this, objectInfoId," Constructor 2 ",objectType);     

            this.objectType = objectType;
            this.context = context;
            this.serObjectInfoInit = serObjectInfoInit;
            this.parentMemberAttributeInfo = attributeInfo;         
            this.surrogateSelector = surrogateSelector;
            this.converter = converter;

            if (objectType.IsArray)
            {
                arrayElemObjectInfo = Serialize(objectType.GetElementType(), surrogateSelector, context, serObjectInfoInit, converter, null);
                typeAttributeInfo = GetTypeAttributeInfo();
                InitNoMembers();
                return;         
            }

            typeAttributeInfo = GetTypeAttributeInfo();

            ISurrogateSelector surrogateSelectorTemp = null;

            if (surrogateSelector!=null)
                serializationSurrogate = surrogateSelector.GetSurrogate(objectType, context, out surrogateSelectorTemp);

            if (serializationSurrogate != null)
            {
                isSi = true;
            }
            else if (objectType == Converter.typeofObject)
            {
            }
            else if (Converter.typeofISerializable.IsAssignableFrom(objectType))
                isSi = true;

            if (isSi)
            {
                si = new SerializationInfo(objectType, converter);
                cache = new SerObjectInfoCache();
                cache.fullTypeName = si.FullTypeName;
                cache.assemblyString = si.AssemblyName;
            }
            else
            {
                InitMemberInfo();
            }

            InternalST.Soap( this,objectInfoId," ", objectType," InitSerialize Exit ",isSi);       
        }

        private void InitSiWrite()
        {
            InternalST.Soap( this, objectInfoId," InitSiWrite Entry ");
            // FormatterWrapper instructs the Formatters to use the
            // __WrappedObject has the real object. This is a way
            // to get Surrogates to return a real object.
            if (si.FullTypeName.Equals("FormatterWrapper"))
            {
                obj = si.GetValue("__WrappedObject", Converter.typeofObject);
                InitSerialize(obj, surrogateSelector, context, serObjectInfoInit, converter, null);
            }
            else
            {

                SerializationInfoEnumerator siEnum = null;
                isSi = true;        
                siEnum = si.GetEnumerator();
                int infoLength = 0;

                infoLength = si.MemberCount;

                int count = infoLength;

                // For ISerializable cache cannot be saved because each object instance can have different values
                // BinaryWriter only puts the map on the wire if the ISerializable map cannot be reused.
                cache = new SerObjectInfoCache();
                cache.memberNames = new String[count];
                cache.memberTypes = new Type[count];
                memberData = new Object[count];

                cache.fullTypeName = si.FullTypeName;
                cache.assemblyString = si.AssemblyName;
                siEnum = si.GetEnumerator();
                for (int i=0; siEnum.MoveNext(); i++)
                {
                    cache.memberNames[i] = siEnum.Name;
                    cache.memberTypes[i] = siEnum.ObjectType;
                    memberData[i] = siEnum.Value;
                    InternalST.Soap( this,objectInfoId+" ",objectType," InitSiWrite ",cache.memberNames[i]," Type ",cache.memberTypes[i]," data ",memberData[i]);                          
                }

                isNamed = true;
                isTyped = false;
            }
            InternalST.Soap(this, objectInfoId," InitSiWrite Exit ");      
        }

        private void InitNoMembers()
        {
            cache = (SerObjectInfoCache)serObjectInfoInit.seenBeforeTable[objectType];
            if (cache == null)
            {
                InternalST.Soap( this,objectInfoId," ", objectType," InitMemberInfo new cache");
                cache = new SerObjectInfoCache();
                cache.fullTypeName = objectType.FullName;
                cache.assemblyString = objectType.Module.Assembly.FullName;
                serObjectInfoInit.seenBeforeTable.Add(objectType, cache);
            }
        }

        private void InitMemberInfo()
        {
            InternalST.Soap( this,objectInfoId," ", objectType," InitMemberInfo Entry");

            cache = (SerObjectInfoCache)serObjectInfoInit.seenBeforeTable[objectType];
            if (cache == null)
            {
                InternalST.Soap( this,objectInfoId," ", objectType," InitMemberInfo new cache");
                cache = new SerObjectInfoCache();
                int count = 0;
                if (!objectType.IsByRef) // byref will only occur for MethodSignature
                {
                    cache.memberInfos = FormatterServices.GetSerializableMembers(objectType, context);
                    count = cache.memberInfos.Length;
                }
                cache.memberNames = new String[count];
                cache.memberTypes = new Type[count];
                cache.memberAttributeInfos = new SoapAttributeInfo[count];

                // Calculate new arrays
                for (int i=0; i<count; i++)
                {
                    cache.memberNames[i] = cache.memberInfos[i].Name;
                    cache.memberTypes[i] = GetMemberType(cache.memberInfos[i]);
                    cache.memberAttributeInfos[i] = Attr.GetMemberAttributeInfo(cache.memberInfos[i], cache.memberNames[i], cache.memberTypes[i]);
                    InternalST.Soap( this, objectInfoId," InitMemberInfo name ",cache.memberNames[i],", type ",cache.memberTypes[i],", memberInfoType ",cache.memberInfos[i].GetType());                   
                }
                cache.fullTypeName = objectType.FullName;
                cache.assemblyString = objectType.Module.Assembly.FullName;
                serObjectInfoInit.seenBeforeTable.Add(objectType, cache);
            }

            if (obj != null)
            {
                memberData = FormatterServices.GetObjectData(obj, cache.memberInfos);
                DumpMemberInfo();
            }

            isTyped = true;
            isNamed = true;
            InternalST.Soap( this,objectInfoId," ", objectType," InitMemberInfo Exit");                        
        }


        // Return type name for the object.  

        internal  String GetTypeFullName()
        {
            InternalST.Soap( this,objectInfoId," ", objectType," GetTypeFullName isSi ",isSi, " "+cache.fullTypeName);
            return cache.fullTypeName;
        }

        internal  String GetAssemblyString()
        {
            String assemblyString = null;  
            InternalST.Soap( this,objectInfoId," ", objectType, " GetAssemblyString Entry isSi ",isSi);

            if (arrayElemObjectInfo != null)
                assemblyString = arrayElemObjectInfo.GetAssemblyString();
            else if (IsAttributeNameSpace())
                assemblyString = typeAttributeInfo.m_nameSpace;
            else
                assemblyString = cache.assemblyString;

            InternalST.Soap( this,objectInfoId," ", objectType," GetAssemblyString Exit ",assemblyString);
            return assemblyString;
        }


        // Retrieves the member type from the MemberInfo

        internal  Type GetMemberType(MemberInfo objMember)
        {
            Type objectType = null;

            if (objMember is FieldInfo)
            {
                objectType = ((FieldInfo)objMember).FieldType;
                InternalST.Soap( this, objectInfoId," ", "GetMemberType FieldInfo ",objectType);               
            }
            else if (objMember is PropertyInfo)
            {
                objectType = ((PropertyInfo)objMember).PropertyType;
                InternalST.Soap( this,objectInfoId," ", "GetMemberType PropertyInfo ",objectType);                             
            }
            else
            {
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_SerMemberInfo"),objMember.GetType()));
            }

            return objectType;
        }

        // Return the information about the objects members

        internal  void GetMemberInfo(out String[] outMemberNames, out Type[] outMemberTypes, out Object[] outMemberData, out SoapAttributeInfo[] outAttributeInfo)
        {
            outMemberNames = cache.memberNames;
            outMemberTypes = cache.memberTypes;
            outMemberData = memberData;
            outAttributeInfo = cache.memberAttributeInfos;

            if (isSi)
            {
                if (!isNamed)
                    throw new SerializationException(SoapUtil.GetResourceString("Serialization_ISerializableMemberInfo"));
            }
        }

        private static WriteObjectInfo GetObjectInfo(SerObjectInfoInit serObjectInfoInit)
        {
            WriteObjectInfo objectInfo = null;

            if (!serObjectInfoInit.oiPool.IsEmpty())
            {
                objectInfo = (WriteObjectInfo)serObjectInfoInit.oiPool.Pop();
                objectInfo.InternalInit();
                //InternalST.Soap( "GetObjectInfo",objectInfo.objectInfoId," GetObjectInfo from pool");
            }
            else
            {
                objectInfo = new WriteObjectInfo();
                objectInfo.objectInfoId = serObjectInfoInit.objectInfoIdCount++;                        
                //InternalST.Soap( "GetObjectInfo",objectInfo.objectInfoId," GetObjectInfo new not from pool");				
            }

            return objectInfo;
        }

        private int Position(String name)
        {
            InternalST.Soap( this, objectInfoId," Position ",lastPosition," ",name);
            if (cache.memberNames[lastPosition].Equals(name))
            {
                return lastPosition;
            }
            else if ((++lastPosition < cache.memberNames.Length) && (cache.memberNames[lastPosition].Equals(name)))
            {
                return lastPosition;
            }
            else
            {
                // Search for name
                InternalST.Soap( this, objectInfoId," Position miss search for name "+name);
                for (int i=0; i<cache.memberNames.Length; i++)
                {
                    if (cache.memberNames[i].Equals(name))
                    {
                        lastPosition = i;
                        return lastPosition;
                    }
                }

                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Position"),objectType+" "+name));   
            }
        }

        private static void PutObjectInfo(SerObjectInfoInit serObjectInfoInit, WriteObjectInfo objectInfo)
        {
            serObjectInfoInit.oiPool.Push(objectInfo);
            //InternalST.Soap( "PutObjectInfo",objectInfo.objectInfoId," PutObjectInfo to pool");							
        }

        internal bool IsInteropNameSpace()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsInteropNameSpace();

            if (IsAttributeNameSpace() || IsCallElement())
                return true;
            else
                return false;
        }

        internal bool IsCallElement()
        {
            // This should only return true when this object is being
            //  serialized first.

            if ((objectType != Converter.typeofObject) &&
                (Converter.typeofIMethodCallMessage.IsAssignableFrom(objectType) &&
                 !Converter.typeofIConstructionCallMessage.IsAssignableFrom(objectType)) ||
                (objectType == Converter.typeofReturnMessage) ||
                (objectType == Converter.typeofInternalSoapMessage))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        internal bool IsCustomXmlAttribute()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsCustomXmlAttribute();

            if ((typeAttributeInfo != null) &&
                ((typeAttributeInfo.m_attributeType & SoapAttributeType.XmlAttribute) != 0))
                return true;
            else
                return false;
        }

        internal bool IsCustomXmlElement()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsCustomXmlElement();

            if ((typeAttributeInfo != null) &&
                ((typeAttributeInfo.m_attributeType & SoapAttributeType.XmlElement) != 0))
                return true;
            else
                return false;
        }

        internal bool IsAttributeNameSpace()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsAttributeNameSpace();

            if ((typeAttributeInfo != null) && (typeAttributeInfo.m_nameSpace != null))
                return true;
            else
                return false;
        }

        internal bool IsAttributeElementName()
        {
            if ((typeAttributeInfo != null) && (typeAttributeInfo.m_elementName != null))
                return true;
            else
                return false;
        }

        internal bool IsAttributeTypeName()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsAttributeTypeName();

            if ((typeAttributeInfo != null) && (typeAttributeInfo.m_typeName != null))
                return true;
            else
                return false;
        }


        // Check for Interop type (SchemaType)
        private SoapAttributeInfo GetTypeAttributeInfo()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.GetTypeAttributeInfo();

            SoapAttributeInfo attributeInfo = null;
            if (parentMemberAttributeInfo != null)
                attributeInfo = parentMemberAttributeInfo;
            else
                attributeInfo = new SoapAttributeInfo();

            Attr.ProcessTypeAttribute(objectType, attributeInfo);       

            attributeInfo.Dump("type "+objectType);         
            return attributeInfo;
        }


        // Specifies whether the embedded attribute is set for a member.

        internal  bool IsEmbeddedAttribute(String name)
        {
            InternalST.Soap( this,objectInfoId," ", objectType," IsEmbedded Entry ",name);

            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsEmbeddedAttribute(name);

            bool isEmbedded = false;
            if (cache.memberAttributeInfos != null && cache.memberAttributeInfos.Length > 0)
            {
                SoapAttributeInfo attributeInfo = cache.memberAttributeInfos[Position(name)];
                isEmbedded = attributeInfo.IsEmbedded();
            }
            InternalST.Soap( this,objectInfoId," ", objectType," IsEmbedded Exit ",isEmbedded);                         
            return isEmbedded;
        }
    }


    internal sealed class ReadObjectInfo
    {
        internal int objectInfoId;

        internal Object obj;
        internal Type objectType;


        internal ObjectManager objectManager;

        internal int count;

        internal bool isSi = false;
        internal bool isNamed = false;
        internal bool isTyped = false;

        internal SerializationInfo si = null;

        internal SerObjectInfoCache cache = null;

        internal String[] wireMemberNames = null;   
        internal Type[] wireMemberTypes = null;
        internal Object[] memberData = null;

        private int lastPosition = 0;

        internal ISurrogateSelector surrogateSelector = null;
        internal ISerializationSurrogate serializationSurrogate = null;

        internal StreamingContext context;


        // Si Read
        internal ArrayList memberTypesList;

        internal SerObjectInfoInit serObjectInfoInit = null;

        internal IFormatterConverter formatterConverter;

        // fake object for soap top record when remoting or IRemotingFormatter interface
        internal bool bfake = false;
        internal bool bSoapFault = false;
        internal ArrayList paramNameList; // Contain parameter names in correct order
        private int majorVersion = 0;
        private int minorVersion = 0;
        internal SoapAttributeInfo typeAttributeInfo;
        private ReadObjectInfo arrayElemObjectInfo;
        private int numberMembersSeen = 0;

        internal ReadObjectInfo()
        {
        }

        internal void ObjectEnd()
        {
            InternalST.Soap( this, objectInfoId," objectType ",objectType," ObjectEnd");                                                                           
            PutObjectInfo(serObjectInfoInit, this);
        }

        private void InternalInit()
        {
            InternalST.Soap( this, objectInfoId," objectType ",objectType," InternalInit");                                                                                        
            obj = null;
            objectType = null;
            count = 0;
            isSi = false;
            isNamed = false;
            isTyped = false;
            si = null;
            wireMemberNames = null;
            wireMemberTypes = null;
            cache = null;
            lastPosition = 0;
            numberMembersSeen = 0;

            bfake = false;
            bSoapFault = false;
            majorVersion = 0;
            minorVersion = 0;
            typeAttributeInfo = null;
            arrayElemObjectInfo = null;



            // Si Read
            if (memberTypesList != null)
            {
                memberTypesList.Clear();
            }

        }

        internal static ReadObjectInfo Create(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, String assemblyName)
        {
            ReadObjectInfo soi = GetObjectInfo(serObjectInfoInit);          
            soi.Init(objectType, surrogateSelector, context, objectManager, serObjectInfoInit, converter, assemblyName);
            return soi;
        }


        // Read Constructor
        internal void Init(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, String assemblyName)
        {

            InternalST.Soap( this, objectInfoId," Constructor 3 ",objectType);     

            this.objectType = objectType;
            this.objectManager = objectManager;
            this.context = context;
            this.serObjectInfoInit = serObjectInfoInit;
            this.formatterConverter = converter;

            InitReadConstructor(objectType, surrogateSelector, context, assemblyName);
        }

        internal static ReadObjectInfo Create(Type objectType, String[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, String assemblyName)
        {
            ReadObjectInfo soi = GetObjectInfo(serObjectInfoInit);                      
            soi.Init(objectType, memberNames,memberTypes, surrogateSelector, context, objectManager, serObjectInfoInit, converter, assemblyName);
            return soi;
        }

        // Read Constructor
        internal void Init(Type objectType, String[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, String assemblyName)
        {
            InternalST.Soap( this,objectInfoId, " Constructor 5 ",objectType);                     
            this.objectType = objectType;
            this.objectManager = objectManager;
            this.wireMemberNames = memberNames;
            this.wireMemberTypes = memberTypes;
            this.context = context;
            this.serObjectInfoInit = serObjectInfoInit;     
            this.formatterConverter = converter;
            if (memberNames != null)
                isNamed = true;
            if (memberTypes != null)
                isTyped = true;

            InitReadConstructor(objectType, surrogateSelector, context, assemblyName);                
        }

        private void InitReadConstructor(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, String assemblyName)
        {
            InternalST.Soap( this,objectInfoId," ", objectType," InitReadConstructor Entry ",objectType);

            if (objectType.IsArray)
            {
                arrayElemObjectInfo = Create(objectType.GetElementType(), surrogateSelector, context, objectManager, serObjectInfoInit, formatterConverter, assemblyName);
                typeAttributeInfo = GetTypeAttributeInfo();
                InitNoMembers();
                return;         
            }

            ISurrogateSelector surrogateSelectorTemp = null;

            if (surrogateSelector!=null)
                serializationSurrogate = surrogateSelector.GetSurrogate(objectType, context, out surrogateSelectorTemp);

            if (serializationSurrogate != null)
            {
                isSi = true;
            }
            else if (objectType == Converter.typeofObject)
            {
            }
            else if (Converter.typeofISerializable.IsAssignableFrom(objectType))
                isSi = true;

            if (isSi)
            {
                si = new SerializationInfo(objectType, formatterConverter);
                InitSiRead(assemblyName);
            }
            else
            {
                InitMemberInfo();
            }
            InternalST.Soap( this,objectInfoId," ", objectType," InitReadConstructor Exit ",isSi);     
        }

        private void InitSiRead(String assemblyName)
        {
            InternalST.Soap( this,objectInfoId," ", objectType," InitMemberInfo new cache");
            if (assemblyName != null)
            {
                // Need to set to assembly name from the wire. This assembly name could contain version information
                // not in the default assembly name which was returned from fusion
                si.AssemblyName = assemblyName;
            }
            cache = new SerObjectInfoCache();
            cache.fullTypeName = si.FullTypeName;
            cache.assemblyString = si.AssemblyName;

            // Input from IFieldInfo            
            cache.memberNames = wireMemberNames;
            cache.memberTypes = wireMemberTypes;

            if (memberTypesList != null)
            {
                memberTypesList = new ArrayList(20);
            }


            if (wireMemberNames != null && wireMemberTypes != null)
                isTyped = true;
        }

        private void InitNoMembers()
        {
            cache = (SerObjectInfoCache)serObjectInfoInit.seenBeforeTable[objectType];
            if (cache == null)
            {
                InternalST.Soap( this,objectInfoId," ", objectType," InitMemberInfo new cache");
                cache = new SerObjectInfoCache();
                cache.fullTypeName = objectType.FullName;
                cache.assemblyString = objectType.Module.Assembly.FullName;
                serObjectInfoInit.seenBeforeTable.Add(objectType, cache);
            }
        }

        private void InitMemberInfo()
        {
            InternalST.Soap( this,objectInfoId," ", objectType," InitMemberInfo Entry");

            cache = (SerObjectInfoCache)serObjectInfoInit.seenBeforeTable[objectType];
            if (cache == null)
            {
                InternalST.Soap( this,objectInfoId," ", objectType," InitMemberInfo new cache");
                cache = new SerObjectInfoCache();
                cache.memberInfos = FormatterServices.GetSerializableMembers(objectType, context);
                count = cache.memberInfos.Length;
                cache.memberNames = new String[count];
                cache.memberTypes = new Type[count];
                cache.memberAttributeInfos = new SoapAttributeInfo[count];

                // Calculate new arrays
                for (int i=0; i<count; i++)
                {
                    cache.memberNames[i] = cache.memberInfos[i].Name;
                    cache.memberTypes[i] = GetMemberType(cache.memberInfos[i]);
                    cache.memberAttributeInfos[i] = Attr.GetMemberAttributeInfo(cache.memberInfos[i], cache.memberNames[i], cache.memberTypes[i]);
                    InternalST.Soap( this, objectInfoId," InitMemberInfo name ",cache.memberNames[i],", type ",cache.memberTypes[i],", memberInfoType ",cache.memberInfos[i].GetType());                   
                }
                cache.fullTypeName = objectType.FullName;
                cache.assemblyString = objectType.Module.Assembly.FullName;
                serObjectInfoInit.seenBeforeTable.Add(objectType, cache);
            }
            memberData = new Object[cache.memberNames.Length];

            isTyped = true;
            isNamed = true;
            InternalST.Soap( this,objectInfoId," ", objectType," InitMemberInfo Exit");                        
        }

        internal  String GetAssemblyString()
        {
            String assemblyString = null;  
            InternalST.Soap( this,objectInfoId," ", objectType, " GetAssemblyString Entry isSi ",isSi);

            if (arrayElemObjectInfo != null)
                assemblyString = arrayElemObjectInfo.GetAssemblyString();
            else if (IsAttributeNameSpace())
                assemblyString = typeAttributeInfo.m_nameSpace;
            else
                assemblyString = cache.assemblyString;

            InternalST.Soap( this,objectInfoId," ", objectType," GetAssemblyString Exit ",assemblyString);
            return assemblyString;
        }


        // Get the memberInfo for a memberName
        internal  MemberInfo GetMemberInfo(String name)
        {
            InternalST.Soap( this,objectInfoId," ", objectType," GetMemberInfo Entry ",name);              
            if (isSi)
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_MemberInfo"),objectType+" "+name));
            if (cache.memberInfos == null)
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_NoMemberInfo"),objectType+" "+name));
            return cache.memberInfos[Position(name)];
        }

        internal  Type GetMemberType(MemberInfo objMember)
        {
            Type objectType = null;

            if (objMember is FieldInfo)
            {
                objectType = ((FieldInfo)objMember).FieldType;
                InternalST.Soap( this, objectInfoId," ", "GetMemberType FieldInfo ",objectType);               
            }
            else if (objMember is PropertyInfo)
            {
                objectType = ((PropertyInfo)objMember).PropertyType;
                InternalST.Soap( this,objectInfoId," ", "GetMemberType PropertyInfo ",objectType);                             
            }
            else
            {
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_SerMemberInfo"),objMember.GetType()));
            }

            return objectType;
        }

        // Get the ObjectType for a memberName
        internal  Type GetType(String name)
        {
            InternalST.Soap( this,objectInfoId," ", objectType," GetType Entry ",name);                
            Type type = null;
            if (isTyped)
                type = cache.memberTypes[Position(name)];
            else
                type = (Type)memberTypesList[Position(name)];

            if (type == null)
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_ISerializableTypes"),objectType+" "+name));

            InternalST.Soap( this,objectInfoId," ", objectType," GetType Exit ",type);                     
            return type;
        }

        internal  Type GetType(int position)
        {
            InternalST.Soap( this,objectInfoId," ", objectType," GetType Entry ByPosition ",position);
            Type type = null;           
            if (isTyped)
            {
                if (position >= cache.memberTypes.Length)
                    throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_ISerializableTypes"),objectType+" "+position));
                type = cache.memberTypes[position];

                InternalST.Soap( this,objectInfoId," ", objectType," GetType Exit ByPosition ",type);
            }
            return type;
        }


        internal  void AddParamName(String name)
        {
            if (!bfake)
                return;

            if (name[0] == '_' && name[1] == '_')
            { 
                if (name == "__fault")
                {
                    bSoapFault = true;
                    return;
                }
                else if (name == "__methodName" || name == "__keyToNamespaceTable" || name == "__paramNameList" || name == "__xmlNameSpace")
                {
                    return;
                }
            }
            InternalST.Soap( this,objectInfoId," ", objectType," AddParamName Add "+name);
            paramNameList.Add(name);
        }

        // Adds the value for a memberName
        internal  void AddValue(String name, Object value)
        {
            InternalST.Soap( this,objectInfoId," ", objectType," AddValue ",name," ",value," isSi ",isSi);                     
            if (isSi)
            {
                if (bfake)
                {
                    AddParamName(name);
                }

                si.AddValue(name, value);
            }
            else
            {
                //                Console.WriteLine("Calling add value for " + name + " with value " + value);

                int position = Position(name);
                memberData[position] = value;
            }
        }

        internal void AddMemberSeen()
        {
            InternalST.Soap( this,objectInfoId," ", objectType," AddMemberSeen ");
            numberMembersSeen++;
        }

        //Soap fake object
        internal ArrayList SetFakeObject()
        {
            bfake = true;
            paramNameList = new ArrayList(10);
            return paramNameList;
        }

        internal void SetVersion(int major, int minor)
        {
            majorVersion = major;
            minorVersion = minor;
        }

        // Records an objectId in a member when the actual object for that member is not yet known
        internal  void RecordFixup(long objectId, String name, long idRef)
        {

            if (isSi)
            {
                InternalST.Soap( this,objectInfoId," ", objectType, " RecordFixup  RecordDelayedFixup objectId ",objectId," name ",name," idRef ",idRef," isSi ",isSi);
                objectManager.RecordDelayedFixup(objectId, name, idRef);
            }
            else
            {
                InternalST.Soap( this,objectInfoId," ", objectType," RecordFixup  objectId ",objectId," name ",name," idRef ",idRef," isSi ",isSi);                                            
                objectManager.RecordFixup(objectId, cache.memberInfos[Position(name)], idRef);
            }
        }


        // Fills in the values for an object
        internal  void PopulateObjectMembers()
        {
            InternalST.Soap( this,objectInfoId," ", objectType," PopulateObjectMembers  isSi ",isSi);
            if (!isSi)
            {
                if (numberMembersSeen != cache.memberInfos.Length && 
                    majorVersion >= 1 && minorVersion >= 0 &&
                    !IsInteropNameSpace() && 
                    objectType != Converter.typeofHeader && 
                    !bfake)
                {
                    throw new SerializationException(SoapUtil.GetResourceString("Serialization_WrongNumberOfMembers", 
                                                                                objectType, cache.memberInfos.Length, numberMembersSeen));
                }

                DumpPopulate(cache.memberInfos, memberData);

                FormatterServices.PopulateObjectMembers(obj, cache.memberInfos, memberData);
                numberMembersSeen = 0;
            }
        }

        [Conditional("SER_LOGGING")]                    
        private void DumpPopulate(MemberInfo[] memberInfos, Object[] memberData)
        {
            for (int i=0; i<memberInfos.Length; i++)
            {
                InternalST.Soap( this,objectInfoId," ", objectType," PopulateObjectMembers ",memberInfos[i].Name," ",memberData[i]);

            }
        }

        [Conditional("SER_LOGGING")]                    
        private void DumpPopulateSi()
        {
            InternalST.Soap( this,objectInfoId," ", objectType," PopulateObjectMembers SetObjectData, ISerializable obj ");
            SerializationInfoEnumerator siEnum = si.GetEnumerator();
            for (int i=0; siEnum.MoveNext(); i++)
            {
                InternalST.Soap( this,objectInfoId," ",objectType," Populate Si ",siEnum.Name," ",siEnum.Value);
            }
        }

        // Specifies the position in the memberNames array of this name

        private int Position(String name)
        {
            InternalST.Soap( this, objectInfoId," Position ",lastPosition," ",name);
            if (cache.memberNames[lastPosition].Equals(name))
            {
                return lastPosition;
            }
            else if ((++lastPosition < cache.memberNames.Length) && (cache.memberNames[lastPosition].Equals(name)))
            {
                return lastPosition;
            }
            else
            {
                // Search for name
                InternalST.Soap( this, objectInfoId," Position miss search for name "+name);
                for (int i=0; i<cache.memberNames.Length; i++)
                {
                    if (cache.memberNames[i].Equals(name))
                    {
                        lastPosition = i;
                        return lastPosition;
                    }
                }

                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Position"),objectType+" "+name));   
            }
        }


        private static ReadObjectInfo GetObjectInfo(SerObjectInfoInit serObjectInfoInit)
        {
            ReadObjectInfo objectInfo = null;

            if (!serObjectInfoInit.oiPool.IsEmpty())
            {
                objectInfo = (ReadObjectInfo)serObjectInfoInit.oiPool.Pop();
                objectInfo.InternalInit();
                //InternalST.Soap( "GetObjectInfo",objectInfo.objectInfoId," GetObjectInfo from pool");
            }
            else
            {
                objectInfo = new ReadObjectInfo();
                objectInfo.objectInfoId = serObjectInfoInit.objectInfoIdCount++;                        
                //InternalST.Soap( "GetObjectInfo",objectInfo.objectInfoId," GetObjectInfo new not from pool");				
            }

            return objectInfo;
        }

        private static void PutObjectInfo(SerObjectInfoInit serObjectInfoInit, ReadObjectInfo objectInfo)
        {
            serObjectInfoInit.oiPool.Push(objectInfo);
            //InternalST.Soap( "PutObjectInfo",objectInfo.objectInfoId," PutObjectInfo to pool");							
        }

        internal bool IsInteropNameSpace()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsInteropNameSpace();

            if (IsAttributeNameSpace() || IsCallElement())
                return true;
            else
                return false;
        }

        internal bool IsCallElement()
        {
            //  This should only return true when this object is being
            //  serialized first.

            if ((objectType != Converter.typeofObject) &&
                (Converter.typeofIMethodCallMessage.IsAssignableFrom(objectType) &&
                 !Converter.typeofIConstructionCallMessage.IsAssignableFrom(objectType)) ||
                (objectType == Converter.typeofReturnMessage) ||
                (objectType == Converter.typeofInternalSoapMessage))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        internal bool IsCustomXmlAttribute()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsCustomXmlAttribute();

            if ((typeAttributeInfo != null) &&
                ((typeAttributeInfo.m_attributeType & SoapAttributeType.XmlAttribute) != 0))
                return true;
            else
                return false;
        }

        internal bool IsCustomXmlElement()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsCustomXmlElement();

            if ((typeAttributeInfo != null) &&
                ((typeAttributeInfo.m_attributeType & SoapAttributeType.XmlElement) != 0))
                return true;
            else
                return false;
        }

        internal bool IsAttributeNameSpace()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsAttributeNameSpace();

            if ((typeAttributeInfo != null) && (typeAttributeInfo.m_nameSpace != null))
                return true;
            else
                return false;
        }

        internal bool IsAttributeElementName()
        {
            if ((typeAttributeInfo != null) && (typeAttributeInfo.m_elementName != null))
                return true;
            else
                return false;
        }

        internal bool IsAttributeTypeName()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsAttributeTypeName();

            if ((typeAttributeInfo != null) && (typeAttributeInfo.m_typeName != null))
                return true;
            else
                return false;
        }


        // Check for Interop type (SchemaType)
        private SoapAttributeInfo GetTypeAttributeInfo()
        {
            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.GetTypeAttributeInfo();

            SoapAttributeInfo attributeInfo = null;
            attributeInfo = new SoapAttributeInfo();

            Attr.ProcessTypeAttribute(objectType, attributeInfo);       

            attributeInfo.Dump("type "+objectType);         
            return attributeInfo;
        }


        // Specifies whether the embedded attribute is set for a member.

        internal  bool IsEmbeddedAttribute(String name)
        {
            InternalST.Soap( this,objectInfoId," ", objectType," IsEmbedded Entry ",name);

            if (arrayElemObjectInfo != null)
                return arrayElemObjectInfo.IsEmbeddedAttribute(name);

            bool isEmbedded = false;
            if (cache.memberAttributeInfos != null)
            {
                SoapAttributeInfo attributeInfo = cache.memberAttributeInfos[Position(name)];
                isEmbedded = attributeInfo.IsEmbedded();
            }
            InternalST.Soap( this,objectInfoId," ", objectType," IsEmbedded Exit ",isEmbedded);                         
            return isEmbedded;
        }
    }

    internal sealed class SerObjectInfoCache
    {
        internal String fullTypeName = null;
        internal String assemblyString = null;
        internal MemberInfo[] memberInfos = null;
        internal String[] memberNames = null;   
        internal Type[] memberTypes = null;
        internal SoapAttributeInfo[] memberAttributeInfos = null;
    }

    internal sealed class SerObjectInfoInit
    {
        internal Hashtable seenBeforeTable = new Hashtable();
        internal int objectInfoIdCount = 1;
        internal SerStack oiPool = new SerStack("SerObjectInfo Pool");      
    }

    internal sealed class Attr
    {

        internal static SoapAttributeInfo GetMemberAttributeInfo(MemberInfo memberInfo, String name, Type type)
        {

            SoapAttributeInfo attributeInfo = new SoapAttributeInfo();
            ProcessTypeAttribute(type, attributeInfo);
            ProcessMemberInfoAttribute(memberInfo, attributeInfo);
            attributeInfo.Dump("memberInfo "+name);
            return attributeInfo;
        }


        internal static void ProcessTypeAttribute(Type type, SoapAttributeInfo attributeInfo)
        {
            SoapTypeAttribute attr = (SoapTypeAttribute)
                                     InternalRemotingServices.GetCachedSoapAttribute(type);

            if (attr.Embedded)
                attributeInfo.m_attributeType |= SoapAttributeType.Embedded;

            String xmlName, xmlNamespace;

            if (SoapServices.GetXmlElementForInteropType(type, out xmlName, out xmlNamespace))
            {
                attributeInfo.m_attributeType |= SoapAttributeType.XmlElement;
                attributeInfo.m_elementName = xmlName;
                attributeInfo.m_nameSpace = xmlNamespace;
            }

            if (SoapServices.GetXmlTypeForInteropType(type, out xmlName, out xmlNamespace))
            {
                attributeInfo.m_attributeType |= SoapAttributeType.XmlType;
                attributeInfo.m_typeName = xmlName;
                attributeInfo.m_typeNamespace = xmlNamespace;
            }

        } // ProcessTypeAttribute


        internal static void ProcessMemberInfoAttribute(MemberInfo memberInfo, SoapAttributeInfo attributeInfo)
        {
            SoapAttribute attr = (SoapAttribute)
                                 InternalRemotingServices.GetCachedSoapAttribute(memberInfo);

            if (attr.Embedded)
                attributeInfo.m_attributeType |= SoapAttributeType.Embedded;

            // check for attribute and other junk
            if (attr is SoapFieldAttribute)
            {
                SoapFieldAttribute fieldAttr = (SoapFieldAttribute)attr;
                if (fieldAttr.UseAttribute)
                {
                    attributeInfo.m_attributeType |= SoapAttributeType.XmlAttribute;
                    attributeInfo.m_elementName = fieldAttr.XmlElementName;
                    attributeInfo.m_nameSpace = fieldAttr.XmlNamespace;
                }
                else
                {
                    if (fieldAttr.IsInteropXmlElement())
                    {
                        attributeInfo.m_attributeType |= SoapAttributeType.XmlElement;
                        attributeInfo.m_elementName = fieldAttr.XmlElementName;
                        attributeInfo.m_nameSpace = fieldAttr.XmlNamespace;
                    }
                }
            }
        } // ProcessMemberInfoAttribute

    }

            }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\soapparser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: SoapParser
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: XML Handlers for System.XML parser
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Soap
{
  using System;
  using System.Runtime.Serialization.Formatters;
  using System.Xml;
  using System.IO;
  using System.Globalization;
  using System.Collections;
  using System.Reflection;
  using System.Runtime.Serialization;
  using System.Text;
  using System.Runtime.Remoting;
  using System.Runtime.Remoting.Messaging;
  using System.Runtime.Remoting.Metadata;


  sealed internal class SoapParser : ISerParser
  {
    internal XmlTextReader xmlReader;
    internal SoapHandler soapHandler;
    internal ObjectReader objectReader;
    internal bool bStop = false;
    int depth = 0;
    bool bDebug = false;
    TextReader textReader = null;

    internal SoapParser(Stream stream)
    {
      InternalST.Soap( this, "Constructor");     
      TraceStream(stream);
      if (bDebug)
        xmlReader = new XmlTextReader(textReader);
      else
        xmlReader = new XmlTextReader(stream);                
      xmlReader.XmlResolver= null;
      soapHandler = new SoapHandler(this);
    }


    // Trace when checked builds
    [System.Diagnostics.Conditional("_LOGGING")]
    private void TraceStream(Stream stream)
    {
      bDebug = true;
      TextReader tempReader = new StreamReader(stream);
      String strbuffer = tempReader.ReadToEnd();
      InternalST.InfoSoap("******************** Begin Deserialized Stream Buffer *******************");
      InternalST.InfoSoap(strbuffer);
      InternalST.InfoSoap("******************** End Deserialized Stream Buffer *******************");
      textReader = new StringReader(strbuffer);
    }

    internal void Init(ObjectReader objectReader)

    {
      InternalST.Soap( this, "Init");     
      this.objectReader = objectReader;
      soapHandler.Init(objectReader);
      bStop = false;
      depth = 0;
      xmlReader.ResetState();
    }

    // Start parsing the input
    public void Run()
    {
      InternalST.Soap( this, "Run");     
      try
      {
        soapHandler.Start(xmlReader);
        ParseXml();
        soapHandler.Finish();
      }
      catch (EndOfStreamException)
      {
      }
    }

    internal void Stop()
    {
      InternalST.Soap( this, "Stop");     
      bStop = true;
    }


    private void ParseXml()
    {
      InternalST.Soap( this, "ParseXml");     
      while (!bStop && xmlReader.Read())
      {
        if (depth < xmlReader.Depth)
        {
          soapHandler.StartChildren();
          depth = xmlReader.Depth;
        }
        else if (depth > xmlReader.Depth)
        {
          soapHandler.FinishChildren(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI);
          depth = xmlReader.Depth;
        }

        switch (xmlReader.NodeType)
        {
          case(XmlNodeType.None):
            break;
          case(XmlNodeType.Element):
            Dump("Node Element", xmlReader);                   
            soapHandler.StartElement(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI);
            int attributeCount = xmlReader.AttributeCount;
            while (xmlReader.MoveToNextAttribute())
            {
              soapHandler.Attribute(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI, xmlReader.Value);
            }
            xmlReader.MoveToElement();
            if (xmlReader.IsEmptyElement)
              soapHandler.EndElement(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI);
            break;                  
          case XmlNodeType.EndElement:
            Dump("Node EndElement", xmlReader);                   
            soapHandler.EndElement(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI);
            break;
          case(XmlNodeType.Text):
            Dump("Node Text", xmlReader);                   
            soapHandler.Text(xmlReader.Value);
            break;                  
          case(XmlNodeType.SignificantWhitespace):
            Dump("Node SignificantWhitespace", xmlReader);                   
            soapHandler.Text(xmlReader.Value);
            break;                  
          case(XmlNodeType.Whitespace):
            Dump("Node Whitespace", xmlReader);                   
            soapHandler.Text(xmlReader.Value);
            break;                  
          case(XmlNodeType.Entity):
            Dump("Node Entity", xmlReader);                   
            break;                  
          case(XmlNodeType.CDATA):
            Dump("Node CDATA", xmlReader);                   
            soapHandler.Text(xmlReader.Value);
            break;                  
          case(XmlNodeType.Comment):
            Dump("Node Comment", xmlReader);                   
            soapHandler.Comment(xmlReader.Value);                        
            break;                  
          case(XmlNodeType.EntityReference):
            Dump("Node EntityReference", xmlReader);                    
            break;                  
          case(XmlNodeType.ProcessingInstruction):
            Dump("Node ProcessingInstruction", xmlReader);                  
            break;                  
          case(XmlNodeType.Document):
            Dump("Node Document", xmlReader);                   
            break;                  
          case(XmlNodeType.DocumentType):
            Dump("Node DocumentType", xmlReader);                   
            break;                  
          case(XmlNodeType.DocumentFragment):
            Dump("Node DocumentFragment", xmlReader);                   
            break;                  
          case(XmlNodeType.Notation):
            Dump("Node Notation", xmlReader);                   
            break;                  
          case(XmlNodeType.EndEntity):
            Dump("Node EndEntity", xmlReader);                  
            break;                  
          default:
            Dump("Node Default", xmlReader);                    
            break;                  
        }

      }
    }

    [System.Diagnostics.Conditional("SER_LOGGING")]
    private static void Dump(String name, XmlReader xmlReader)
    {
      InternalST.Soap("========== "+name+" ============");
      InternalST.Soap("Prefix               : " + xmlReader.Prefix);
      InternalST.Soap("Name                 : " + xmlReader.Name);
      InternalST.Soap("LocalName            : " + xmlReader.LocalName);
      InternalST.Soap("Namespace            : " + xmlReader.NamespaceURI);
      InternalST.Soap("Depth                : " + xmlReader.Depth);
      InternalST.Soap("Value                : [" + xmlReader.Value+"]");
      InternalST.Soap("IsDefault            : " + xmlReader.IsDefault);
      InternalST.Soap("XmlSpace             : " + xmlReader.XmlSpace);
      InternalST.Soap("XmlLang              : " + xmlReader.XmlLang);
      InternalST.Soap("QuoteChar            : " + xmlReader.QuoteChar);
      InternalST.Soap("================================\n");            
    }

  }

  // Sets the handler which contains the callbacks for the parser
  sealed internal class SoapHandler
  {
    SerStack stack= new SerStack("SoapParser Stack");

    XmlTextReader xmlTextReader = null;
    SoapParser soapParser = null;


    // Current text
    String textValue = "";

    // XML Formatter
    ObjectReader objectReader;
    internal Hashtable keyToNamespaceTable; //needed for xsd QName type

    // Current state
    InternalParseStateE currentState;
    bool isEnvelope = false;
    bool isBody = false;
    bool isTopFound = false;
    HeaderStateEnum headerState = HeaderStateEnum.None;

    // Attribute holder
    SerStack attributeValues = new SerStack("AttributePrefix");

    SerStack prPool = new SerStack("prPool");

    // XML Key to AssemblyId table
    // Key of SOAP has an AssemblyId of -1
    // Key of urt has an AssemblyId of -2
    Hashtable assemKeyToAssemblyTable = null;
    Hashtable assemKeyToNameSpaceTable = null;
    Hashtable assemKeyToInteropAssemblyTable = null;
    Hashtable nameSpaceToKey = null; // Used to assign a key to default xml namespaces
    String soapKey = "SOAP-ENC"; //xml key for soap, should be SOAP
    String urtKey = "urt"; //xml key for urt, should be urt
    String soapEnvKey = "SOAP-ENV"; //xml key for SOAPRENV, initial value, might change
    String xsiKey = "xsi"; //xml key for xsi, initial value, might change
    String xsdKey = "xsd"; //xml key for xsd, initial value, might change
    int nextPrefix = 0; // Used to generate a prefix if necessary

    internal SoapHandler(SoapParser soapParser)
    {
      this.soapParser = soapParser;
    }

    internal void Init(ObjectReader objectReader)
    {
      this.objectReader = objectReader;
      objectReader.soapHandler = this;
      isEnvelope = false;
      isBody = false;
      isTopFound = false;
      attributeValues.Clear();
      assemKeyToAssemblyTable = new Hashtable(10);
      assemKeyToAssemblyTable[urtKey] = new SoapAssemblyInfo(SoapUtil.urtAssemblyString, SoapUtil.urtAssembly);
      assemKeyToNameSpaceTable = new Hashtable(10);
      assemKeyToInteropAssemblyTable = new Hashtable(10);
      nameSpaceToKey = new Hashtable(5);
      keyToNamespaceTable = new Hashtable(10);

    }

    private String NextPrefix()
    {
      nextPrefix++;
      return "_P"+nextPrefix;

    }

    internal class AttributeValueEntry
    {
      internal String prefix;
      internal String key;
      internal String value;
      internal String urn;

      internal AttributeValueEntry(String prefix, String key, String value, String urn)
      {
        this.prefix = prefix;
        this.key = key;
        this.value = value;
        this.urn = urn;
      }
    }

    private ParseRecord GetPr()
    {
      ParseRecord pr = null;

      if (!prPool.IsEmpty())
      {
        pr = (ParseRecord)prPool.Pop();
        pr.Init();
      }
      else
        pr = new ParseRecord();

      return pr;
    }

    private void PutPr(ParseRecord pr)
    {
      prPool.Push(pr);
    }

    // Creates a trace string
    private static String SerTraceString(String handler, ParseRecord pr, String value, InternalParseStateE currentState, HeaderStateEnum headerState)
    {               
      String valueString = "";
      if (value != null)
        valueString = value;

      String prString = "";
      if (pr != null)
        prString = ((Enum)pr.PRparseStateEnum).ToString();

      return handler+" - "+valueString+", State "+((Enum)currentState).ToString()+", PushState "+prString;        
    }

    private static String SerTraceString(String handler, ParseRecord pr, String value, String prefix, String urn, InternalParseStateE currentState, HeaderStateEnum headerState)
    {
      String valueString = "";
      if (value != null)
        valueString = value;

      String prString = "";
      if (pr != null)
        prString = ((Enum)pr.PRparseStateEnum).ToString();

      return handler+" - name "+valueString+", prefix "+prefix+", urn "+urn+", CuurentState "+((Enum)currentState).ToString()+", HeaderState "+((Enum)headerState).ToString()+", PushState "+prString;        
    }



    // Formats the error message and throws a SerializationException
    private void MarshalError(String handler, ParseRecord pr, String value, InternalParseStateE currentState)
    {
      String traceString = SerTraceString(handler, pr, value, currentState, headerState);

      InternalST.Soap( this,"MarshalError,",traceString);

      throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Syntax"),traceString));                                                    
    }

    // Throws a SerializationException
    private void MarshalError(String message)
    {
      InternalST.Soap( this,"MarshalError, ",message);

      throw new SerializationException(message);
    }


    // Called at the beginning of parsing
    internal void Start(XmlTextReader p)
    {
      InternalST.Soap( this,"Start ");
      currentState = InternalParseStateE.Object;
      xmlTextReader = p;
    }

    // Called at the end of parsing
    internal void Finish()
    {
    }


    // Called when a parse error occurs
    internal void Error(Exception ex)
    {
      if (ex != null)
      {
        InternalST.Soap( this,"Soap Parser Error: ",ex);
        InternalST.Soap( ex.StackTrace);
      }

      if (!(ex is EndOfStreamException))
      {
        if (ex is ServerException || ex is System.Security.SecurityException)
          throw ex;
        else
          throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Parser"),ex));                                                                 
      }
    }

    // Called at the begining of an element
    internal void StartElement(String prefix, String name, String urn)
    {
      InternalST.Soap( this,SerTraceString("StartElement Begin ", (ParseRecord)stack.Peek(), name, prefix, urn, currentState, headerState));
      //InternalST.Soap( this,"prefix ",prefix,", Name ",name,", urn ",urn);

      String actualName = NameFilter(name);
      String actualPrefix = prefix;

      ParseRecord pr = null;

      if (!((urn == null) || (urn.Length == 0)) && ((prefix == null) || (prefix.Length == 0)))
      {
        // Need to assign a prefix to the urn
        if (nameSpaceToKey.ContainsKey(urn))
          actualPrefix = (String)nameSpaceToKey[urn];
        else
        {
          actualPrefix = NextPrefix();
          nameSpaceToKey[urn] = actualPrefix;
        }
        InternalST.Soap( this,"StartElement Begin null urn assigned prefix ", actualPrefix);
      }


      switch (currentState)
      {
        case InternalParseStateE.Object:
          pr = GetPr();
          pr.PRname = actualName;
          pr.PRnameXmlKey = actualPrefix;
          pr.PRxmlNameSpace = urn;
          pr.PRparseStateEnum = InternalParseStateE.Object;

          if ((String.Compare(name, "Array", true, CultureInfo.InvariantCulture) == 0) && actualPrefix.Equals(soapKey))
            pr.PRparseTypeEnum = InternalParseTypeE.Object;
          else if (((String.Compare(name, "anyType", true, CultureInfo.InvariantCulture) == 0) || (String.Compare(name, "ur-type", true, CultureInfo.InvariantCulture) == 0)) && actualPrefix.Equals(xsdKey))
          {
            pr.PRname = "System.Object";
            pr.PRnameXmlKey = urtKey;
            pr.PRxmlNameSpace = urn;                        
            pr.PRparseTypeEnum = InternalParseTypeE.Object;
          }
          else if (String.Compare(urn, "http://schemas.xmlsoap.org/soap/envelope/", true, CultureInfo.InvariantCulture) == 0)
          {
            if (String.Compare(name, "Envelope", true, CultureInfo.InvariantCulture) == 0)
            {
              if (isEnvelope)
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Parser_Envelope"),prefix+":"+name));

              isEnvelope = true;
              pr.PRparseTypeEnum = InternalParseTypeE.Envelope;
            }
            else if (String.Compare(name, "Body", true, CultureInfo.InvariantCulture) == 0)
            {
              if (!isEnvelope)
                throw new SerializationException(SoapUtil.GetResourceString("Serialization_Parser_BodyChild"));

              if (isBody)
                throw new SerializationException(SoapUtil.GetResourceString("Serialization_Parser_BodyOnce"));

              isBody = true;
              headerState = HeaderStateEnum.None;
              isTopFound = false;
              pr.PRparseTypeEnum = InternalParseTypeE.Body;                           
            }
            else if (String.Compare(name, "Header", true, CultureInfo.InvariantCulture) == 0)
            {
              if (!isEnvelope)
                throw new SerializationException(SoapUtil.GetResourceString("Serialization_Parser_Header"));

              pr.PRparseTypeEnum = InternalParseTypeE.Headers;
              headerState = HeaderStateEnum.FirstHeaderRecord;
            }
            else
              pr.PRparseTypeEnum = InternalParseTypeE.Object; //SoapFault has an envelope key         
          }
          else
          {
            pr.PRparseTypeEnum = InternalParseTypeE.Object;
          }

          stack.Push(pr);
          break;

        case InternalParseStateE.Member:
          pr = GetPr();

          // Members of Top object records cannot be reused because of the need to resolving fake element
          ParseRecord objectPr = (ParseRecord)stack.Peek();
          pr.PRname = actualName;
          pr.PRnameXmlKey = actualPrefix;
          pr.PRxmlNameSpace = urn;                    
          pr.PRparseTypeEnum = InternalParseTypeE.Member;
          pr.PRparseStateEnum = InternalParseStateE.Member;
          stack.Push(pr);
          break;

        case InternalParseStateE.MemberChild:
          objectPr = (ParseRecord)stack.PeekPeek();                   
          pr = (ParseRecord)stack.Peek();
          pr.PRmemberValueEnum = InternalMemberValueE.Nested;
          ProcessAttributes(pr, objectPr);
          switch (headerState)
          {
            case HeaderStateEnum.None:
            case HeaderStateEnum.TopLevelObject:
              InternalST.Soap( this,"ObjectReader.Parse 1");
              objectReader.Parse(pr);
              pr.PRisParsed = true;
              break;
            case HeaderStateEnum.HeaderRecord:
            case HeaderStateEnum.NestedObject:                          
              ProcessHeaderMember(pr);
              break;
          }

          ParseRecord nestPr = GetPr();
          nestPr.PRparseTypeEnum = InternalParseTypeE.Member;
          nestPr.PRparseStateEnum = InternalParseStateE.Member;
          nestPr.PRname = actualName;
          nestPr.PRnameXmlKey = actualPrefix;
          pr.PRxmlNameSpace = urn;                    
          currentState = InternalParseStateE.Member;
          stack.Push(nestPr);
          break;

        default:
          MarshalError("StartElement", (ParseRecord)stack.Peek(), actualName, currentState);
          break;
      }

      InternalST.Soap( this,SerTraceString("StartElement End ", (ParseRecord)stack.Peek(), name, currentState, headerState));
    }


    // Called at the end of an element
    internal void  EndElement(String prefix, String name, String urn)
    {
      InternalST.Soap( this,SerTraceString("EndElement Begin ", (ParseRecord)stack.Peek(), name, prefix, urn, currentState, headerState));
      //InternalST.Soap( this,"prefix ",prefix,", Name ",name,", urn ",urn);

      String actualName = NameFilter(name);

      ParseRecord objectPr = null;
      ParseRecord pr = null;

      switch (currentState)
      {
        case InternalParseStateE.Object:
          pr = (ParseRecord)stack.Pop();
          if (pr.PRparseTypeEnum == InternalParseTypeE.Envelope)
            pr.PRparseTypeEnum = InternalParseTypeE.EnvelopeEnd;
          else if (pr.PRparseTypeEnum == InternalParseTypeE.Body)
            pr.PRparseTypeEnum = InternalParseTypeE.BodyEnd;
          else if (pr.PRparseTypeEnum == InternalParseTypeE.Headers)
          {
            pr.PRparseTypeEnum = InternalParseTypeE.HeadersEnd;
            headerState = HeaderStateEnum.HeaderRecord;
          }
          else if (pr.PRarrayTypeEnum != InternalArrayTypeE.Base64)
          {
            // A Base64 array object treated special by ObjectReader. It is completely processed when
            // pr.PRparseTypeEnum == InternalParseTypeE.Object, an ObjectEnd is not needed to complete parsing

            // For an element like <element />, the check was not made for top
            objectPr = (ParseRecord)stack.Peek();
            InternalST.Soap( this,"SoapParser.EndElement TopFound "+isTopFound+" objectPr.parseTypeEnum "+(objectPr == null?"null":((Enum)objectPr.PRparseTypeEnum).ToString()));
            if (!isTopFound && (objectPr != null ) && (objectPr.PRparseTypeEnum == InternalParseTypeE.Body))
            {
              pr.PRobjectPositionEnum = InternalObjectPositionE.Top;
              isTopFound = true;
              InternalST.Soap( this,"SoapParser.EndElement change position to top");
            }

            if (!pr.PRisParsed)
            {
              InternalST.Soap( this,"SoapParser.EndElement Object hasn't been parsed");
              if (!pr.PRisProcessAttributes && !(pr.PRobjectPositionEnum == InternalObjectPositionE.Top && objectReader.IsFakeTopObject))
                ProcessAttributes(pr, objectPr);
              objectReader.Parse(pr);
              pr.PRisParsed = true;                           
            }
            pr.PRparseTypeEnum = InternalParseTypeE.ObjectEnd;                                              
          }

          switch (headerState)
          {
            case HeaderStateEnum.None:
            case HeaderStateEnum.TopLevelObject:
              InternalST.Soap( this,"SoapParser.EndElement Parse EndObject");                 
              objectReader.Parse(pr);
              break;
            case HeaderStateEnum.HeaderRecord:
            case HeaderStateEnum.NestedObject:
              InternalST.Soap( this,"SoapParser.EndElement ProcessHeaderEnd");                                                                            
              ProcessHeaderEnd(pr);
              break;
          }

          if (pr.PRparseTypeEnum == InternalParseTypeE.EnvelopeEnd)
          {
            // End of document
            soapParser.Stop();
          }

          PutPr(pr);
          break;

        case InternalParseStateE.Member:
          pr = (ParseRecord)stack.Peek();
          objectPr = (ParseRecord)stack.PeekPeek();
          ProcessAttributes(pr, objectPr);

          // Check if there are any XmlAttribute records, if there is, process them
          if (xmlAttributeList != null)
            InternalST.Soap( this,"XmlAttribute check count ", xmlAttributeList.Count);
          else
            InternalST.Soap( this,"XmlAttribute null");

          if ((xmlAttributeList != null) && (xmlAttributeList.Count > 0))
          {
            InternalST.Soap( this,"xmlAttribute list count ", xmlAttributeList.Count);
            for (int i=0; i<xmlAttributeList.Count; i++)
            {
              InternalST.Soap( this,"ObjectReader.Parse 7");                                  
              objectReader.Parse((ParseRecord)xmlAttributeList[i]);
            }
            xmlAttributeList.Clear();
          }

          pr = (ParseRecord)stack.Pop();
          if ((headerState == HeaderStateEnum.TopLevelObject) && (pr.PRarrayTypeEnum == InternalArrayTypeE.Base64))
          {
            // A Base64 array object treated special by ObjectReader. It is completely processed when
            // pr.PRparseTypeEnum == InternalParseTypeE.Object, an ObjectEnd is not needed to complete parsing
            InternalST.Soap( this,"ObjectReader.Parse 3");                      
            objectReader.Parse(pr);
            pr.PRisParsed = true;                       
          }
          else if (pr.PRmemberValueEnum != InternalMemberValueE.Nested)
          {
            if ((pr.PRobjectTypeEnum == InternalObjectTypeE.Array) && (pr.PRmemberValueEnum != InternalMemberValueE.Null))
            {
              // Empty array
              pr.PRmemberValueEnum = InternalMemberValueE.Nested;
              InternalST.Soap( this,"ObjectReader.Parse 4");                          
              objectReader.Parse(pr);
              pr.PRisParsed = true;                           

              pr.PRparseTypeEnum = InternalParseTypeE.MemberEnd;
            }
            else if (pr.PRidRef > 0)
              pr.PRmemberValueEnum = InternalMemberValueE.Reference;
            else if (pr.PRmemberValueEnum != InternalMemberValueE.Null)
              pr.PRmemberValueEnum = InternalMemberValueE.InlineValue;

            switch (headerState)
            {
              case HeaderStateEnum.None:
              case HeaderStateEnum.TopLevelObject:
                InternalST.Soap( this,"ObjectReader.Parse 5"); 
                if (pr.PRparseTypeEnum == InternalParseTypeE.Object)
                {
                  // Empty object in header case
                  if (!pr.PRisParsed)
                    objectReader.Parse(pr);
                  pr.PRparseTypeEnum = InternalParseTypeE.ObjectEnd;
                }
                objectReader.Parse(pr);
                pr.PRisParsed = true;                               
                break;
              case HeaderStateEnum.HeaderRecord:
              case HeaderStateEnum.NestedObject:                              
                ProcessHeaderMember(pr);
                break;
            }
          }
          else
          {
            // Nested member already parsed, need end to finish nested object
            pr.PRparseTypeEnum = InternalParseTypeE.MemberEnd;
            switch (headerState)
            {
              case HeaderStateEnum.None:
              case HeaderStateEnum.TopLevelObject:
                InternalST.Soap( this,"ObjectReader.Parse 6");                              
                objectReader.Parse(pr);
                pr.PRisParsed = true;                               
                break;
              case HeaderStateEnum.HeaderRecord:
              case HeaderStateEnum.NestedObject:                              
                ProcessHeaderMemberEnd(pr);
                break;
            }
          }
          PutPr(pr);
          break;

        case InternalParseStateE.MemberChild:
          pr = (ParseRecord)stack.Peek();
          if (pr.PRmemberValueEnum != InternalMemberValueE.Null)
            MarshalError("EndElement", (ParseRecord)stack.Peek(), actualName, currentState);
          break;

        default:
          MarshalError("EndElement", (ParseRecord)stack.Peek(), actualName, currentState);
          break;
      }
      InternalST.Soap( this,SerTraceString("EndElement End ", (ParseRecord)stack.Peek(), name, currentState, headerState));
    }

    // Called at the start of processing child nodes for an element
    internal void StartChildren()
    {
      InternalST.Soap( this,SerTraceString("StartChildren Begin ", (ParseRecord)stack.Peek(), null, currentState, headerState));

      ParseRecord pr = null;

      switch (currentState)
      {
        case InternalParseStateE.Object:
          InternalST.Soap( this,"StartChildren Object");
          pr = (ParseRecord)stack.Peek();
          ParseRecord objectPr = (ParseRecord)stack.PeekPeek();
          ProcessAttributes(pr, objectPr);
          if (pr.PRarrayTypeEnum != InternalArrayTypeE.Base64)
          {
            if (!((pr.PRparseTypeEnum == InternalParseTypeE.Envelope) || (pr.PRparseTypeEnum == InternalParseTypeE.Body)))
            {
              currentState = InternalParseStateE.Member;

            }

            switch (headerState)
            {
              case HeaderStateEnum.None:
              case HeaderStateEnum.TopLevelObject:
                InternalST.Soap( this,"ObjectReader.Parse 8");
                InternalST.Soap( this,"SoapParser.StartChildren TopFound "+isTopFound+" objectPr.parseTypeEnum "+(objectPr == null?"null":((Enum)objectPr.PRparseTypeEnum).ToString()));
                if (!isTopFound && (objectPr != null ) && (objectPr.PRparseTypeEnum == InternalParseTypeE.Body))
                {
                  pr.PRobjectPositionEnum = InternalObjectPositionE.Top;
                  isTopFound = true;
                  InternalST.Soap( this,"SoapParser.StartChildren change position to top");
                }
                objectReader.Parse(pr);
                pr.PRisParsed = true;                               
                break;
              case HeaderStateEnum.HeaderRecord:
              case HeaderStateEnum.NestedObject:
              case HeaderStateEnum.FirstHeaderRecord:
                ProcessHeader(pr);                              
                break;                          
            }
          }
          break;

        case InternalParseStateE.Member:
          InternalST.Soap( this,"StartChildren Member");                  
          pr = (ParseRecord)stack.Peek();             
          currentState = InternalParseStateE.MemberChild;
          break;

        case InternalParseStateE.MemberChild:
        default:
          MarshalError("StartChildren", (ParseRecord)stack.Peek(), null, currentState);
          break;
      }

      InternalST.Soap( this, "StartChildren 10");     
      InternalST.Soap( this,SerTraceString("StartChildren End ", (ParseRecord)stack.Peek(), null, currentState, headerState));
    }

    // Called at the end of process the child nodes for an element
    internal void FinishChildren(String prefix, String name, String urn)
    {
      InternalST.Soap( this,SerTraceString("FinishChildren Begin ", (ParseRecord)stack.Peek(), name, prefix, urn, currentState, headerState));
      //InternalST.Soap( this,"prefix ",prefix,", Name ",name,", urn ",urn);

      ParseRecord pr = null;

      switch (currentState)
      {
        case InternalParseStateE.Member:
          pr = (ParseRecord)stack.Peek();                             
          currentState = pr.PRparseStateEnum;
          // For an object which has a value such as top level System.String
          pr.PRvalue = textValue;
          textValue = "";
          break;

        case InternalParseStateE.MemberChild:
          pr = (ParseRecord)stack.Peek();                             
          currentState = pr.PRparseStateEnum;

          ParseRecord objectPr = (ParseRecord)stack.PeekPeek();
          pr.PRvalue = textValue; // Non-primitive type need to filter
          textValue = "";

          break;

        case InternalParseStateE.Object:
          pr = (ParseRecord)stack.Peek();
          if (pr.PRarrayTypeEnum == InternalArrayTypeE.Base64)
          {
            pr.PRvalue = textValue;
            textValue = "";
          }
          // Only occur for top object, returning to SerializedStreamHeader object
          break;

        default:
          MarshalError("FinishChildren", (ParseRecord)stack.Peek(), name, currentState);
          break;
      }

      InternalST.Soap( this,SerTraceString("FinishChildren End ", (ParseRecord)stack.Peek(), name, currentState, headerState));
    }

    // Called at when an attribute is finished
    internal void Attribute(String prefix, String name, String urn, String value)
    {
      InternalST.Soap( this,SerTraceString("Attribute Begin ", (ParseRecord)stack.Peek(), name, prefix, urn, currentState, headerState));
      InternalST.Soap( this,"Attribute prefix ",prefix,", Name ",name,", urn ",urn, ",value "+value);

      switch (currentState)
      {
        case InternalParseStateE.Object:
        case InternalParseStateE.Member:

          ParseRecord pr = (ParseRecord)stack.Peek();

          String actualName = name;
          if (!((urn == null) || (urn.Length == 0)) && ((prefix == null) || (prefix.Length == 0)))
          {
            // Default namespaces, assign a name to reference urn
            if (nameSpaceToKey.ContainsKey(urn))
              actualName = (String)nameSpaceToKey[urn];
            else
            {
              actualName = NextPrefix();
              nameSpaceToKey[urn] = actualName;
            }
            InternalST.Soap( this,"EndAttribute null urn assigned Name ", actualName);                      
          }

          if (!((prefix == null) || (actualName == null) ||(value == null)|| (urn == null)))
          {
            //  Xml parser returns an end attribute without a begin attribute for xmlns="" (which is a cancellation of a default namespace)
            // In this case want to avoid the push
            attributeValues.Push(new AttributeValueEntry(prefix, actualName, value, urn));
          }
          break;
        case InternalParseStateE.MemberChild:
        default:
          MarshalError("EndAttribute, Unknown State ", (ParseRecord)stack.Peek(), name, currentState);
          break;
      }

      InternalST.Soap( this,SerTraceString("EndAttribute End ", (ParseRecord)stack.Peek(), name, currentState, headerState));
    }


    // Called at when a text element is encountered
    internal void Text(String text)
    {
      InternalST.Soap( this,"Text ",text);
      textValue = text;
    }

    // Called at when a Comment is encourtered (not used)
    internal void Comment(String body)
    {
      InternalST.Soap( this,"Comment ",body);                     
    }


    // Process the attributes placed into the ParseRecord
    StringBuilder sburi = new StringBuilder(50);
    private void ProcessAttributes(ParseRecord pr, ParseRecord objectPr)
    {
      InternalST.Soap( this, "ProcessAttributes Entry ",pr.Trace()," headerState ",((Enum)headerState).ToString());
      String keyPosition = null;
      String keyOffset = null;
      String keyMustUnderstand = null;

      pr.PRisProcessAttributes = true;

      String SoapKeyUrl = "http://schemas.xmlsoap.org/soap/encoding/";
      int SoapKeyUrlLength = SoapKeyUrl.Length;
      String UrtKeyUrl = "http://schemas.microsoft.com/clr/id";
      int UrtKeyUrlLength = UrtKeyUrl.Length;
      String SoapEnvKeyUrl = "http://schemas.xmlsoap.org/soap/envelope/";
      int SoapEnvKeyUrlLength = SoapEnvKeyUrl.Length;
      String XSIKey2001 = "http://www.w3.org/2001/XMLSchema-instance";
      int XSIKey2001Length = XSIKey2001.Length;
      String XSIKey2000 = "http://www.w3.org/2000/10/XMLSchema-instance";
      int XSIKey2000Length = XSIKey2000.Length;
      String XSIKey1999 = "http://www.w3.org/1999/XMLSchema-instance";
      int XSIKey1999Length = XSIKey1999.Length;

      String XSDKey1999 = "http://www.w3.org/1999/XMLSchema";
      int XSDKey1999Length = XSDKey1999.Length;
      String XSDKey2000 = "http://www.w3.org/2000/10/XMLSchema";
      int XSDKey2000Length = XSDKey2000.Length;
      String XSDKey2001 = "http://www.w3.org/2001/XMLSchema";
      int XSDKey2001Length = XSDKey2001.Length;
      String clrNS = "http://schemas.microsoft.com/soap/encoding/clr/1.0";
      int clrNSLength = clrNS.Length;

      for (int i = 0; i<attributeValues.Count(); i++)
      {
        AttributeValueEntry attributeValueEntry = (AttributeValueEntry)attributeValues.GetItem(i);
        String prefix = attributeValueEntry.prefix;
        String key = attributeValueEntry.key;
        if ((key == null) || (key.Length == 0))
          key = pr.PRnameXmlKey; //case where there is a default key
        String value = attributeValueEntry.value;
        bool prefixMatchesXmlns = false;
        String urn = attributeValueEntry.urn;
        InternalST.Soap( this, "ProcessAttributes attribute prefix ",prefix," key ",key," value ",value," urn ", urn);

        int keyLength = key.Length;
        int valueLength = value.Length;
        // table need for QName xsd types
        if (key == null || keyLength == 0)
          keyToNamespaceTable[prefix] = value;
        else
          keyToNamespaceTable[prefix+":"+key] = value;

        if (keyLength == 2 && String.Compare(key, "id", true, CultureInfo.InvariantCulture) == 0)
          pr.PRobjectId = objectReader.GetId(value);
        else if (keyLength == 8 && String.Compare(key, "position", true, CultureInfo.InvariantCulture) == 0)
          keyPosition = value;
        else if (keyLength == 6 && String.Compare(key, "offset", true, CultureInfo.InvariantCulture) == 0)
          keyOffset = value;
        else if (keyLength == 14 && String.Compare(key, "MustUnderstand", true, CultureInfo.InvariantCulture) == 0)
          keyMustUnderstand = value;
        else if (keyLength == 4 && String.Compare(key, "null", true, CultureInfo.InvariantCulture) == 0)
        {
          pr.PRmemberValueEnum = InternalMemberValueE.Null;
          pr.PRvalue = null;
        }
        else if (keyLength == 4 && String.Compare(key, "root", true, CultureInfo.InvariantCulture) == 0)
        {
          if (value.Equals("1"))
            pr.PRisHeaderRoot = true;
        }
        else if (keyLength == 4 && String.Compare(key, "href", true, CultureInfo.InvariantCulture) == 0)
          pr.PRidRef = objectReader.GetId(value);
        else if (keyLength == 4 && String.Compare(key, "type", true, CultureInfo.InvariantCulture) == 0)
        {
          String currentPRtypeXmlKey = pr.PRtypeXmlKey;
          String currentPRkeyDt = pr.PRkeyDt;
          Type currentPRdtType = pr.PRdtType;

          String typeValue = value;
          int index = value.IndexOf(":");
          if (index > 0)
          {
            pr.PRtypeXmlKey = value.Substring(0, index);
            typeValue = value.Substring(++index);
          }
          else
          {
            pr.PRtypeXmlKey = prefix;                       
          }

          if (String.Compare(typeValue, "anyType", true, CultureInfo.InvariantCulture) == 0 || String.Compare(typeValue, "ur-type", true, CultureInfo.InvariantCulture) == 0)
          {
            pr.PRkeyDt = "System.Object";
            pr.PRdtType = SoapUtil.typeofObject;
            pr.PRtypeXmlKey = urtKey;
          }

          if (pr.PRtypeXmlKey == soapKey && typeValue == "Array") //Don't need to process xsi:type="SOAP-ENC:Array"
          {
            // Array values already found,use these value rather then the xsi:type values
            pr.PRtypeXmlKey = currentPRtypeXmlKey;
            pr.PRkeyDt = currentPRkeyDt;
            pr.PRdtType = currentPRdtType;
            InternalST.Soap( this,"ProcessAttributes, xsi:type='SOAP-ENC:Array' pr.PRtypeXmlKey ", pr.PRtypeXmlKey," pr.PRkeyDt "+pr.PRkeyDt);
          }
          else
          {
            pr.PRkeyDt = typeValue;
            InternalST.Soap( this,"ProcessAttributes, not  xsi:type='SOAP-ENC:Array' pr.PRtypeXmlKey ", pr.PRtypeXmlKey," pr.PRkeyDt "+pr.PRkeyDt);
          }
        }
        else if (keyLength == 9 && String.Compare(key, "arraytype", true, CultureInfo.InvariantCulture) == 0)
        {
          String typeValue = value;
          int index = value.IndexOf(":");
          if (index > 0)
          {
            pr.PRtypeXmlKey = value.Substring(0, index);
            pr.PRkeyDt = typeValue = value.Substring(++index);
          }

          if (typeValue.StartsWith("ur_type["))
          {
            pr.PRkeyDt = "System.Object"+typeValue.Substring(6);
            pr.PRtypeXmlKey = urtKey;
          }
        }
        else if (SoapServices.IsClrTypeNamespace(value))
        {
          if (!assemKeyToAssemblyTable.ContainsKey(key))
          {
            String typeNamespace = null;
            String assemblyName = null;
            SoapServices.DecodeXmlNamespaceForClrTypeNamespace(value, out typeNamespace, out assemblyName);
            if (assemblyName == null)
            {
              assemKeyToAssemblyTable[key] = new SoapAssemblyInfo(SoapUtil.urtAssemblyString, SoapUtil.urtAssembly);
              assemKeyToNameSpaceTable[key] = typeNamespace;
            }
            else
            {
              assemKeyToAssemblyTable[key] = new SoapAssemblyInfo(assemblyName);
              if (typeNamespace != null)
                assemKeyToNameSpaceTable[key] = typeNamespace;
            }

          }
        }
        else if ((prefixMatchesXmlns = prefix.Equals("xmlns")) && (valueLength == SoapKeyUrlLength && String.Compare(value, SoapKeyUrl, true, CultureInfo.InvariantCulture) == 0))
        {
          soapKey = key;
        }
        else if (prefixMatchesXmlns && (valueLength == UrtKeyUrlLength && String.Compare(value, UrtKeyUrl, true, CultureInfo.InvariantCulture) == 0))
        {
          urtKey = key;
          assemKeyToAssemblyTable[urtKey] = new SoapAssemblyInfo(SoapUtil.urtAssemblyString, SoapUtil.urtAssembly);
        }
        else if (prefixMatchesXmlns && (valueLength == SoapEnvKeyUrlLength && String.Compare(value, SoapEnvKeyUrl, true, CultureInfo.InvariantCulture) == 0))
        {
          soapEnvKey = key;
        }
        else if (key == "encodingStyle")
        {
          /*
          String[] split = value.Split(' ');
          foreach (String s in split)
          {
          if (s == "http://schemas.microsoft.com/soap/encoding/clr/1.0")
          {
          objectReader.SetVersion(1,0);
          break;
          }
          }
*/
        }
        else if (prefixMatchesXmlns && 
                 ((valueLength == XSIKey2001Length && String.Compare(value, XSIKey2001,true, CultureInfo.InvariantCulture) == 0) ||
                  (valueLength == XSIKey1999Length && String.Compare(value, XSIKey1999,true, CultureInfo.InvariantCulture) == 0) ||
                  (valueLength == XSIKey2000Length && String.Compare(value, XSIKey2000,true, CultureInfo.InvariantCulture) == 0)))
        {
          xsiKey = key;
        }
        else if (prefixMatchesXmlns && 
                 ((valueLength == XSDKey2001Length && String.Compare(value, XSDKey2001 , true, CultureInfo.InvariantCulture) == 0)) ||
                 (valueLength == XSDKey1999Length && String.Compare(value, XSDKey1999, true, CultureInfo.InvariantCulture) == 0) ||
                 (valueLength == XSDKey2000Length && String.Compare(value, XSDKey2000, true, CultureInfo.InvariantCulture) == 0))
        {
          xsdKey = key;
        }
        else if (prefixMatchesXmlns && (valueLength == clrNSLength && String.Compare(value, clrNS, true, CultureInfo.InvariantCulture) == 0))
        {
          objectReader.SetVersion(1,0);
        }
        else
        {
          //String lowerCaseValue = value.ToLower(CultureInfo.InvariantCulture);
          if (prefixMatchesXmlns)
          {
            // Assume it is an interop namespace
            assemKeyToInteropAssemblyTable[key] = value;                        
            InternalST.Soap( this,"ProcessAttributes, InteropType key "+key+" value ",value);
          }
          else if (String.Compare(prefix, soapKey, true, CultureInfo.InvariantCulture) == 0)
          {
            InternalST.Soap( this,"ProcessAttributes, Not processed key ",prefix,":",key," = ",value);                  
          }
          else
          {
            // See if it is a XmlAttribute
            InternalST.Soap( this,"ProcessAttributes, XmlAttribute prefix ",prefix," key ",key," value ",value," urn ",urn, " hashtable ",assemKeyToInteropAssemblyTable[prefix]);

            if ((assemKeyToInteropAssemblyTable.ContainsKey(prefix)) && ((String)assemKeyToInteropAssemblyTable[prefix]).Equals(urn))
            {
              ProcessXmlAttribute(prefix, key, value, objectPr);
            }
            else
            {
              InternalST.Soap( this,"ProcessAttributes, Not processed prefix ",prefix," key ",key," value ",value," urn ",urn);
            }
          }
        }
      }

      attributeValues.Clear();

      // reset the header state
      // If no headers then headerState is None
      //
      // if parent is a header section then these are top level objects
      // within the header section. If the object has a root set
      // then it is a header record, if not then it is a toplevel object
      // in the header section which is not a header record.
      //
      // if the parent is not a header section and is a header root
      // then this is a nested object within a header record. All
      // subsequent object will be nested until another header
      // root is encountered
      //
      // The first header record is considered a root record
      if (headerState != HeaderStateEnum.None)
      {
        if (objectPr.PRparseTypeEnum == InternalParseTypeE.Headers)
        {
          if (pr.PRisHeaderRoot || (headerState == HeaderStateEnum.FirstHeaderRecord))
          {
            headerState = HeaderStateEnum.HeaderRecord;
          }
          else
          {
            headerState = HeaderStateEnum.TopLevelObject;
            currentState = InternalParseStateE.Object;
            pr.PRobjectTypeEnum = InternalObjectTypeE.Object;
            pr.PRparseTypeEnum = InternalParseTypeE.Object;
            pr.PRparseStateEnum = InternalParseStateE.Object;
            pr.PRmemberTypeEnum = InternalMemberTypeE.Empty;
            pr.PRmemberValueEnum = InternalMemberValueE.Empty;
          }
        }
        else if (objectPr.PRisHeaderRoot)
          headerState = HeaderStateEnum.NestedObject;
      }

      InternalST.Soap( this,"ProcessAttributes, headerState ",((Enum)headerState).ToString());


      if (!isTopFound && (objectPr != null ) && (objectPr.PRparseTypeEnum == InternalParseTypeE.Body))
      {
        pr.PRobjectPositionEnum = InternalObjectPositionE.Top;
        isTopFound = true;
      }
      else if (pr.PRobjectPositionEnum != InternalObjectPositionE.Top)
        pr.PRobjectPositionEnum = InternalObjectPositionE.Child;


      // Don't process type for envelop, topSoapElement unless it has a key of soapEnvKey (SOAP-ENV). Fault
      // is the only top record which currently falls into this category.
      if (!((pr.PRparseTypeEnum == InternalParseTypeE.Envelope)||
            (pr.PRparseTypeEnum == InternalParseTypeE.Body) ||
            (pr.PRparseTypeEnum == InternalParseTypeE.Headers) ||
            (pr.PRobjectPositionEnum == InternalObjectPositionE.Top &&
             objectReader.IsFakeTopObject &&
             !pr.PRnameXmlKey.Equals(soapEnvKey))))
      {
        InternalST.Soap( this, "ProcessAttributes  before Process Type ",((Enum)pr.PRparseTypeEnum).ToString());
        ProcessType(pr, objectPr);
      }

      if (keyPosition != null)
      {
        int outRank;
        String outDimSignature;
        InternalArrayTypeE outArrayTypeEnum;
        pr.PRpositionA = ParseArrayDimensions(keyPosition, out outRank, out outDimSignature, out outArrayTypeEnum);
      }

      if (keyOffset != null)
      {
        int outRank;
        String outDimSignature;
        InternalArrayTypeE outArrayTypeEnum;
        pr.PRlowerBoundA = ParseArrayDimensions(keyOffset, out outRank, out outDimSignature, out outArrayTypeEnum);
      }

      if (keyMustUnderstand != null)
        if (keyMustUnderstand.Equals("1"))
          pr.PRisMustUnderstand = true;
        else if (keyMustUnderstand.Equals("0"))
          pr.PRisMustUnderstand = false;
        else
          throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_MustUnderstand"),keyMustUnderstand));

      if (pr.PRparseTypeEnum == InternalParseTypeE.Member)
      {
        //  Process Member      

        InternalST.Soap( this, "ProcessAttributes  Member ");
        stack.Dump();

        if (objectPr.PRparseTypeEnum == InternalParseTypeE.Headers)
          pr.PRmemberTypeEnum = InternalMemberTypeE.Header;
        else if (objectPr.PRobjectTypeEnum == InternalObjectTypeE.Array)
          pr.PRmemberTypeEnum = InternalMemberTypeE.Item;
        else
          pr.PRmemberTypeEnum = InternalMemberTypeE.Field;
      }
    }


    // Create a URT type from the XML dt type
    private void ProcessType(ParseRecord pr, ParseRecord objectPr)
    {
      InternalST.Soap( this, "ProcessType nameXmlKey ",pr.PRnameXmlKey," typeXmlKey ",pr.PRtypeXmlKey);
      pr.Dump();
      if (pr.PRdtType != null)
        return;
      if ((pr.PRnameXmlKey.Equals(soapEnvKey)) && (String.Compare(pr.PRname, "Fault", true, CultureInfo.InvariantCulture) == 0))
      {
        // Fault object
        InternalST.Soap( this, "ProcessType SoapFault");
        pr.PRdtType = SoapUtil.typeofSoapFault;
        pr.PRparseTypeEnum = InternalParseTypeE.Object;
      }
      else if (pr.PRname != null)
      {
        InternalST.Soap( this, "ProcessType Attribute 1");              

        String interopAssemblyNameString = null;

        // determine interop assembly string if there is a namespace
        if ((pr.PRnameXmlKey != null) && (pr.PRnameXmlKey.Length > 0))
        {
          interopAssemblyNameString = (String)assemKeyToInteropAssemblyTable[pr.PRnameXmlKey];
          InternalST.Soap( this, "ProcessType Attribute 2 "+interopAssemblyNameString);               
        }

        // look for interop data
        Type type = null;
        String name = null;

        if (objectPr != null)
        {
          if (pr.PRisXmlAttribute)
          {
            //  These should processed after containing element
            //  is processed.
            SoapServices.GetInteropFieldTypeAndNameFromXmlAttribute(
              objectPr.PRdtType, pr.PRname, interopAssemblyNameString,
              out type, out name);
            InternalST.Soap( this, "ProcessType Attribute 3 type "+type+" name "+name);
          }
          else
          {
            SoapServices.GetInteropFieldTypeAndNameFromXmlElement(
              objectPr.PRdtType, pr.PRname, interopAssemblyNameString,
              out type, out name);
            InternalST.Soap( this, "ProcessType Attribute 4 type objectPr.PRdtType ",objectPr.PRdtType," pr.PRname ",pr.PRname, " interopAssemblyNameString ",interopAssemblyNameString, " type ",type," name ",name);
          }
        }

        if (type != null)
        {
          pr.PRdtType = type;
          pr.PRname = name;
          pr.PRdtTypeCode = Converter.SoapToCode(pr.PRdtType);
          InternalST.Soap(this, "ProcessType Attribute 5 typeCode "+((Enum)pr.PRdtTypeCode));
        }
        else
        {
          if (interopAssemblyNameString != null)
            pr.PRdtType = objectReader.Bind(interopAssemblyNameString, pr.PRname); // try to get type from SerializationBinder
          if (pr.PRdtType == null)
          {
            pr.PRdtType = SoapServices.GetInteropTypeFromXmlElement(pr.PRname, interopAssemblyNameString);
          }

          // Array item where the element name gives the element type
          if (pr.PRkeyDt == null && pr.PRnameXmlKey != null && pr.PRnameXmlKey.Length > 0 && objectPr.PRobjectTypeEnum == InternalObjectTypeE.Array && objectPr.PRarrayElementType == Converter.typeofObject)
          {
            pr.PRdtType = ProcessGetType(pr.PRname, pr.PRnameXmlKey, out pr.PRassemblyName);
            pr.PRdtTypeCode = Converter.SoapToCode(pr.PRdtType);
          }

          InternalST.Soap(this, "ProcessType Attribute 6 type pr.PRname ", pr.PRname, " interopAssemblyNameString ",interopAssemblyNameString, " pr.PRdtType ",pr.PRdtType);
        }

      }

      if (pr.PRdtType != null)
        return;

      if ((pr.PRtypeXmlKey != null) && (pr.PRtypeXmlKey.Length > 0) && 
          (pr.PRkeyDt != null) && (pr.PRkeyDt.Length > 0) && 
          (assemKeyToInteropAssemblyTable.ContainsKey(pr.PRtypeXmlKey)))
      {
        InternalST.Soap(this, "ProcessType Attribute 7 ");
        // Interop type get from dtType
        int index = pr.PRkeyDt.IndexOf("[");
        if (index > 0)
        {
          ProcessArray(pr, index, true);
        }
        else
        {
          String assemblyString = (String)assemKeyToInteropAssemblyTable[pr.PRtypeXmlKey];
          pr.PRdtType = objectReader.Bind(assemblyString, pr.PRkeyDt); // try to get type from SerializationBinder
          if (pr.PRdtType == null)
          {
            pr.PRdtType = SoapServices.GetInteropTypeFromXmlType(pr.PRkeyDt, assemblyString); 
            if (pr.PRdtType == null)
              throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_TypeElement"),pr.PRname+" "+pr.PRkeyDt));
          }
          InternalST.Soap(this, "ProcessType Attribute 8 type pr.PRkeyDt ",pr.PRkeyDt," pr.PRdtType ",pr.PRdtType);
          if (pr.PRdtType == null)
          {
            throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_TypeElement"),pr.PRname+" "+pr.PRkeyDt+", "+assemblyString));   
          }
        }
      }
      else if (pr.PRkeyDt != null)
      {
        if (String.Compare(pr.PRkeyDt, "Base64", true, CultureInfo.InvariantCulture) == 0)
        {
          pr.PRobjectTypeEnum = InternalObjectTypeE.Array;
          pr.PRarrayTypeEnum = InternalArrayTypeE.Base64;
        }
        else if (String.Compare(pr.PRkeyDt, "String", true, CultureInfo.InvariantCulture) == 0)
        {
          pr.PRdtType = SoapUtil.typeofString;
        }
        else if (String.Compare(pr.PRkeyDt, "methodSignature", true, CultureInfo.InvariantCulture) == 0)
        {
          // MethodSignature needs to be expanded to an array of types
          InternalST.Soap( this, "ProcessType methodSignature ",pr.PRvalue);
          try
          {
            pr.PRdtType = typeof(System.Type[]);
            char[] c = {' ', ':'};
            String[] typesStr = null;
            if (pr.PRvalue != null)
              typesStr = pr.PRvalue.Split(c);
            Type[] types = null;
            if ((typesStr == null) ||
                (typesStr.Length == 1 && typesStr[0].Length == 0))
            {
              // Method signature with no parameters
              types = new Type[0];
            }
            else
            {
              types = new Type[typesStr.Length/2];
              //throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_MethodSignature"),pr.PRvalue));          

              for (int i=0; i<typesStr.Length; i+=2)
              {
                String prefix = typesStr[i];
                String typeString = typesStr[i+1];
                types[i/2] = ProcessGetType(typeString, prefix, out pr.PRassemblyName);
                InternalST.Soap( this, "ProcessType methodSignature type string ",i+" "+" prefix "+prefix+" typestring "+typeString+" type "+types[i/2]); //Temp
              }
            }
            pr.PRvarValue = types;
          }
          catch (Exception)
          {
            throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_MethodSignature"),pr.PRvalue));
          }
        }
        else
        {
          pr.PRdtTypeCode = Converter.ToCode(pr.PRkeyDt);
          if (pr.PRdtTypeCode != InternalPrimitiveTypeE.Invalid)
          {
            pr.PRdtType = Converter.SoapToType(pr.PRdtTypeCode);
          }
          else
          {
            // Find out if it is an array
            int index = pr.PRkeyDt.IndexOf("[");
            if (index > 0)
            {
              // Array
              ProcessArray(pr, index, false);
            }
            else
            {
              // Object
              pr.PRobjectTypeEnum = InternalObjectTypeE.Object;
              pr.PRdtType = ProcessGetType(pr.PRkeyDt, pr.PRtypeXmlKey, out pr.PRassemblyName);
              if ((pr.PRdtType == null) && (pr.PRobjectPositionEnum != InternalObjectPositionE.Top))
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_TypeElement"),pr.PRname+" "+pr.PRkeyDt));
            }
          }
          InternalST.Soap(this, "ProcessType Attribute 9 type "+pr.PRdtType);
        }
      }
      else
      {
        if ((pr.PRparseTypeEnum == InternalParseTypeE.Object) && (!(objectReader.IsFakeTopObject && (pr.PRobjectPositionEnum == InternalObjectPositionE.Top))))
        {
          if (String.Compare(pr.PRname, "Array", true, CultureInfo.InvariantCulture) == 0)
            pr.PRdtType = ProcessGetType(pr.PRkeyDt, pr.PRtypeXmlKey, out pr.PRassemblyName);
          else
          {
            pr.PRdtType = ProcessGetType(pr.PRname, pr.PRnameXmlKey, out pr.PRassemblyName);
          }
          InternalST.Soap(this, "ProcessType Attribute 10 type "+pr.PRdtType);
        }

      } 
    }

    private Type ProcessGetType(String value, String xmlKey, out String assemblyString)
    {
      InternalST.Soap( this, "ProcessGetType Entry xmlKey ",xmlKey," value ",value);
      Type type = null;
      String typeValue = null;
      assemblyString = null;

      // If there is an attribute which matches a preloaded type, then return the preloaded type
      String httpstring = (String)keyToNamespaceTable["xmlns:"+xmlKey];
      if (httpstring != null)
      {
        type= GetInteropType(value, httpstring);
        if (type != null)
          return type;
      }


      if ((String.Compare(value, "anyType", true, CultureInfo.InvariantCulture) == 0 || String.Compare(value, "ur-type", true, CultureInfo.InvariantCulture) == 0) && (xmlKey.Equals(xsdKey)))
        type = SoapUtil.typeofObject;
      else if ((xmlKey.Equals(xsdKey)) || (xmlKey.Equals(soapKey)))
      {
        if (String.Compare(value, "string", true, CultureInfo.InvariantCulture) == 0)
        {
          type = SoapUtil.typeofString;
        }
        else
        {
          InternalPrimitiveTypeE code = Converter.ToCode(value);
          if (code == InternalPrimitiveTypeE.Invalid)
            throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Parser_xsd"),value));

          type = Converter.SoapToType(code);
        }
      }
      else
      {
        if ( xmlKey == null)
          throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Parser_xml"),value));

        String nameSpace = (String)assemKeyToNameSpaceTable[xmlKey];
        typeValue = null;
        if (nameSpace == null)
          typeValue = value;
        else
          typeValue = nameSpace+"."+value;

        SoapAssemblyInfo assemblyInfo = (SoapAssemblyInfo)assemKeyToAssemblyTable[xmlKey];
        if (assemblyInfo == null)
          throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Parser_xmlAssembly"),xmlKey+" "+value));

        assemblyString = assemblyInfo.assemblyString;
        if (assemblyString != null)
        {
          // See if a SerializationBinder was defined to resolve this type
          type = objectReader.Bind(assemblyString, typeValue);
          if (type == null)
            type= objectReader.FastBindToType(assemblyString, typeValue);
        }

        if (type == null)
        {
          Assembly assembly = null;
          try
          {
            assembly = assemblyInfo.GetAssembly(objectReader);
          }
          catch (Exception)
          {
          }

          if (assembly == null)
            throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Parser_xmlAssembly"),xmlKey+":"+httpstring+" "+value));
          else
            type = FormatterServices.GetTypeFromAssembly(assembly, typeValue);
        }
      }
      if (type == null)
        throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Parser_xmlType"),xmlKey+" "+typeValue+" "+assemblyString));
      InternalST.Soap( this, "ProcessGetType Exit ",type);
      return type;            
    }

    private Type GetInteropType(String value, String httpstring)
    {
      // For the case where the client dll has a different name from the server dll
      // The assembly name returned in soap won't match the assembly name in the client dll.
      // so the custom attributes are needed to map from the Soap assembly name to the client assembly
      // This map can only work if the client type was preloaded.
      Type type = SoapServices.GetInteropTypeFromXmlType(value, httpstring); 
      if (type == null)
      {
        // try simple assembly name
        int index = httpstring.IndexOf("%2C");
        if (index > 0)
        {
          String simpleAssem = httpstring.Substring(0,index);
          type = SoapServices.GetInteropTypeFromXmlType(value, simpleAssem); 
        }
      }
      return type;
    }


    // Determine the Array  information from the dt attribute
    private void ProcessArray(ParseRecord pr, int firstIndex, bool IsInterop)
    {
      InternalST.Soap( this, "ProcessArray Enter ",firstIndex," ",pr.PRkeyDt);
      String dimString = null;
      String xmlKey = pr.PRtypeXmlKey;
      InternalPrimitiveTypeE primitiveArrayTypeCode = InternalPrimitiveTypeE.Invalid;
      pr.PRobjectTypeEnum = InternalObjectTypeE.Array;
      pr.PRmemberTypeEnum = InternalMemberTypeE.Item; // Need this set in case this it is a nested empty array
      pr.PRprimitiveArrayTypeString = pr.PRkeyDt.Substring(0, firstIndex);
      dimString = pr.PRkeyDt.Substring(firstIndex);
      if (IsInterop)
      {
        String assemblyString = (String)assemKeyToInteropAssemblyTable[pr.PRtypeXmlKey];
        pr.PRarrayElementType = objectReader.Bind(assemblyString, pr.PRprimitiveArrayTypeString); // try to get type from SerializationBinder
        if (pr.PRarrayElementType == null)
          pr.PRarrayElementType = SoapServices.GetInteropTypeFromXmlType(pr.PRprimitiveArrayTypeString, assemblyString);
        if (pr.PRarrayElementType == null)
          throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_TypeElement"),pr.PRname+" "+pr.PRkeyDt));
        pr.PRprimitiveArrayTypeString = pr.PRarrayElementType.FullName;
      }
      else
      {
        primitiveArrayTypeCode = Converter.ToCode(pr.PRprimitiveArrayTypeString);
        if (primitiveArrayTypeCode != InternalPrimitiveTypeE.Invalid)
        {
          pr.PRprimitiveArrayTypeString = Converter.SoapToComType(primitiveArrayTypeCode);
          xmlKey = urtKey;
        }
        else if (String.Compare(pr.PRprimitiveArrayTypeString, "string", true, CultureInfo.InvariantCulture) == 0)
        {
          pr.PRprimitiveArrayTypeString = "System.String";
          xmlKey = urtKey;
        }
        else if (String.Compare(pr.PRprimitiveArrayTypeString, "anyType", true, CultureInfo.InvariantCulture) == 0 || String.Compare(pr.PRprimitiveArrayTypeString, "ur-type", true, CultureInfo.InvariantCulture) == 0)
        {
          pr.PRprimitiveArrayTypeString = "System.Object";
          xmlKey = urtKey;
        }
      }

      int beginIndex = firstIndex;
      int endIndex = pr.PRkeyDt.IndexOf(']', beginIndex+1);
      if (endIndex < 1)
        throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_ArrayDimensions"),pr.PRkeyDt));

      int outRank = 0;
      int[] outDimensions = null;
      String outDimSignature = null;
      InternalArrayTypeE outArrayTypeEnum = InternalArrayTypeE.Empty;
      int numBrackets = 0;

      StringBuilder elementSig = new StringBuilder(10);

      while (true)
      {
        numBrackets++;
        outDimensions = ParseArrayDimensions(pr.PRkeyDt.Substring(beginIndex, endIndex-beginIndex+1), out outRank, out outDimSignature, out outArrayTypeEnum);
        if (endIndex+1 == pr.PRkeyDt.Length)
          break;
        elementSig.Append(outDimSignature); // Don't want last dimension in element sig
        beginIndex = endIndex+1;
        endIndex = pr.PRkeyDt.IndexOf(']', beginIndex);
      }

      pr.PRlengthA = outDimensions;
      pr.PRrank = outRank;


      if (numBrackets == 1)
      {
        pr.PRarrayElementTypeCode = primitiveArrayTypeCode;
        pr.PRarrayTypeEnum = outArrayTypeEnum;
        pr.PRarrayElementTypeString = pr.PRprimitiveArrayTypeString;            
      }
      else
      {
        pr.PRarrayElementTypeCode = InternalPrimitiveTypeE.Invalid;
        pr.PRarrayTypeEnum = InternalArrayTypeE.Rectangular;            
        pr.PRarrayElementTypeString = pr.PRprimitiveArrayTypeString+elementSig.ToString();

      }

      InternalST.Soap( this, "ProcessArray GetType ",pr.PRarrayElementType);
      if (!IsInterop || numBrackets > 1)
      {
        pr.PRarrayElementType = ProcessGetType(pr.PRarrayElementTypeString, xmlKey, out pr.PRassemblyName);
        if (pr.PRarrayElementType == null)
          throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_ArrayType"),pr.PRarrayElementType));

        if ((pr.PRarrayElementType == SoapUtil.typeofObject))
        {
          pr.PRisArrayVariant = true;
          xmlKey = urtKey;
        }
      }

      InternalST.Soap( this, "ProcessArray Exit");
    }

    // Parse an array dimension bracket
    private int[] ParseArrayDimensions(String dimString, out int rank, out String dimSignature, out InternalArrayTypeE arrayTypeEnum)
    {
      InternalST.Soap( this, "ProcessArrayDimensions Enter ",dimString);      
      char[] dimArray = dimString.ToCharArray();

      int paramCount = 0;
      int commaCount = 0;
      int rankCount = 0;
      int[] dim = new int[dimArray.Length];


      StringBuilder sb = new StringBuilder(10);
      StringBuilder sigSb = new StringBuilder(10);

      for (int i=0; i<dimArray.Length; i++)
      {
        if (dimArray[i] == '[')
        {
          paramCount++;
          sigSb.Append(dimArray[i]);
        }
        else if (dimArray[i] == ']')
        {
          if (sb.Length > 0)
          {
            dim[rankCount++] = Int32.Parse(sb.ToString(), CultureInfo.InvariantCulture);
            sb.Length = 0;
          }
          sigSb.Append(dimArray[i]);                  
        }
        else if (dimArray[i] == ',')
        {
          commaCount++;
          if (sb.Length > 0)
          {
            dim[rankCount++] = Int32.Parse(sb.ToString(), CultureInfo.InvariantCulture);
            sb.Length = 0;
          }
          sigSb.Append(dimArray[i]);                      
        }
        else if ((dimArray[i] == '-') || (Char.IsDigit(dimArray[i])))
        {
          sb.Append(dimArray[i]);
        }
        else
          throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_ArrayDimensions"),dimString));
      }

      rank = rankCount;
      dimSignature = sigSb.ToString();
      int[] dimA = new int[rank];
      for (int i=0; i<rank; i++)
      {
        dimA[i] = dim[i];
      }

      InternalArrayTypeE outEnum = InternalArrayTypeE.Empty;

      if (commaCount > 0)
        outEnum = InternalArrayTypeE.Rectangular;
      else
        outEnum = InternalArrayTypeE.Single;

      arrayTypeEnum = outEnum;

      InternalST.Soap( this, "ProcessArrayDimensions length ",PArray(dimA));
      InternalST.Soap( this, "ProcessArrayDimensions Exit rank ",rank," dimSignature ",sigSb.ToString()," arrayTypeEnum ",((Enum)outEnum).ToString());

      return dimA;
    }

    // Converts a single int array to a string

    private String PArray(int[] array)
    {
      if (array != null)
      {
        StringBuilder sb = new StringBuilder(10);
        sb.Append("[");     
        for (int i=0; i<array.Length; i++)
        {
          sb.Append(array[i]);
          if (i != array.Length -1)
            sb.Append(",");
        }
        sb.Append("]");
        return sb.ToString();
      }
      else
        return "";
    }


    StringBuilder stringBuffer = new StringBuilder(120);

    // Filter an element name for $ and leading digit

    NameCache nameCache = new NameCache();
    private String NameFilter(String name)
    {
      String value = (String)nameCache.GetCachedValue(name);
      if (value == null)
      {
        value = System.Xml.XmlConvert.DecodeName(name);
        nameCache.SetCachedValue(value);
      }
      return value;
    }

    ArrayList xmlAttributeList = null;

    private void ProcessXmlAttribute(String prefix, String key, String value, ParseRecord objectPr)
    {
      InternalST.Soap( this,"ProcessXmlAttribute prefix ",prefix, " key ", key, " value ",value);         
      if (xmlAttributeList == null)
        xmlAttributeList = new ArrayList(10);
      ParseRecord pr = GetPr();
      pr.PRparseTypeEnum = InternalParseTypeE.Member;
      pr.PRmemberTypeEnum = InternalMemberTypeE.Field;
      pr.PRmemberValueEnum = InternalMemberValueE.InlineValue;
      pr.PRname = key;
      pr.PRvalue = value;
      pr.PRnameXmlKey = prefix;
      pr.PRisXmlAttribute = true;

      ProcessType(pr, objectPr);

      xmlAttributeList.Add(pr);
    }

    ArrayList headerList = null;
    int headerArrayLength;

    private void ProcessHeader(ParseRecord pr)
    {
      InternalST.Soap( this,"ProcessHeader ");
      pr.Dump();

      if (headerList == null)
        headerList = new ArrayList(10);
      ParseRecord headerPr = GetPr();
      headerPr.PRparseTypeEnum = InternalParseTypeE.Object;
      headerPr.PRobjectTypeEnum = InternalObjectTypeE.Array;
      headerPr.PRobjectPositionEnum = InternalObjectPositionE.Headers;
      headerPr.PRarrayTypeEnum = InternalArrayTypeE.Single;
      headerPr.PRarrayElementType = typeof(System.Runtime.Remoting.Messaging.Header);
      headerPr.PRisArrayVariant = false;
      headerPr.PRarrayElementTypeCode = InternalPrimitiveTypeE.Invalid;
      headerPr.PRrank = 1;
      headerPr.PRlengthA = new int[1];                
      headerList.Add(headerPr);
    }

    private void ProcessHeaderMember(ParseRecord pr)
    {
      ParseRecord headerPr;

      InternalST.Soap( this,"ProcessHeaderMember HeaderState ",((Enum)headerState).ToString());
      pr.Dump(); 

      if (headerState == HeaderStateEnum.NestedObject)
      {
        // Nested object in Header member
        ParseRecord newPr = pr.Copy();
        headerList.Add(newPr);
        return;
      }

      // Item record
      headerPr = GetPr();
      headerPr.PRparseTypeEnum = InternalParseTypeE.Member;
      headerPr.PRmemberTypeEnum = InternalMemberTypeE.Item;
      headerPr.PRmemberValueEnum = InternalMemberValueE.Nested;
      headerPr.PRisHeaderRoot = true;
      headerArrayLength++;
      headerList.Add(headerPr);

      // Name field
      headerPr = GetPr();
      headerPr.PRparseTypeEnum = InternalParseTypeE.Member;
      headerPr.PRmemberTypeEnum = InternalMemberTypeE.Field;
      headerPr.PRmemberValueEnum = InternalMemberValueE.InlineValue;
      headerPr.PRisHeaderRoot = true;
      headerPr.PRname = "Name";
      headerPr.PRvalue = pr.PRname;
      headerPr.PRdtType = SoapUtil.typeofString;
      headerPr.PRdtTypeCode = InternalPrimitiveTypeE.Invalid;
      headerList.Add(headerPr);

      // Namespace field
      headerPr = GetPr();
      headerPr.PRparseTypeEnum = InternalParseTypeE.Member;
      headerPr.PRmemberTypeEnum = InternalMemberTypeE.Field;
      headerPr.PRmemberValueEnum = InternalMemberValueE.InlineValue;
      headerPr.PRisHeaderRoot = true;
      headerPr.PRname = "HeaderNamespace";
      headerPr.PRvalue = pr.PRxmlNameSpace;
      headerPr.PRdtType = SoapUtil.typeofString;
      headerPr.PRdtTypeCode = InternalPrimitiveTypeE.Invalid;
      headerList.Add(headerPr);

      // MustUnderstand Field
      headerPr = GetPr();
      headerPr.PRparseTypeEnum = InternalParseTypeE.Member;
      headerPr.PRmemberTypeEnum = InternalMemberTypeE.Field;
      headerPr.PRmemberValueEnum = InternalMemberValueE.InlineValue;
      headerPr.PRisHeaderRoot = true;         
      headerPr.PRname = "MustUnderstand";
      if (pr.PRisMustUnderstand)
        headerPr.PRvarValue = true;
      else
        headerPr.PRvarValue = false;            
      headerPr.PRdtType = SoapUtil.typeofBoolean;
      headerPr.PRdtTypeCode = InternalPrimitiveTypeE.Boolean;
      headerList.Add(headerPr);       

      // Value field
      headerPr = GetPr();
      headerPr.PRparseTypeEnum = InternalParseTypeE.Member;
      headerPr.PRmemberTypeEnum = InternalMemberTypeE.Field;
      headerPr.PRmemberValueEnum = pr.PRmemberValueEnum;
      headerPr.PRisHeaderRoot = true;         
      headerPr.PRname = "Value";
      switch (pr.PRmemberValueEnum)
      {
        case InternalMemberValueE.Null:
          headerList.Add(headerPr);
          ProcessHeaderMemberEnd(pr);
          break;
        case InternalMemberValueE.Reference:
          headerPr.PRidRef = pr.PRidRef;
          headerList.Add(headerPr);
          ProcessHeaderMemberEnd(pr);             
          break;
        case InternalMemberValueE.Nested:
          headerPr.PRdtType = pr.PRdtType;
          headerPr.PRdtTypeCode = pr.PRdtTypeCode;
          headerPr.PRkeyDt = pr.PRkeyDt;
          headerList.Add(headerPr);
          // ProcessHeaderMemberEnd will be called from the parse loop
          break;

        case InternalMemberValueE.InlineValue:
          headerPr.PRvalue = pr.PRvalue;
          headerPr.PRvarValue = pr.PRvarValue;
          headerPr.PRdtType = pr.PRdtType;
          headerPr.PRdtTypeCode = pr.PRdtTypeCode;
          headerPr.PRkeyDt = pr.PRkeyDt;
          headerList.Add(headerPr);
          ProcessHeaderMemberEnd(pr);             
          break;
      }
    }

    private void ProcessHeaderMemberEnd(ParseRecord pr)
    {
      ParseRecord headerPr = null;

      InternalST.Soap( this,"ProcessHeaderMemberEnd HeaderState ",((Enum)headerState).ToString());
      pr.Dump(); 

      if (headerState == HeaderStateEnum.NestedObject)
      {
        ParseRecord newPr = pr.Copy();
        headerList.Add(newPr);
      }
      else
      {
        // Member End
        headerPr = GetPr();
        headerPr.PRparseTypeEnum = InternalParseTypeE.MemberEnd;
        headerPr.PRmemberTypeEnum = InternalMemberTypeE.Field;
        headerPr.PRmemberValueEnum = pr.PRmemberValueEnum;
        headerPr.PRisHeaderRoot = true;
        headerList.Add(headerPr);

        // Item End
        headerPr = GetPr();
        headerPr.PRparseTypeEnum = InternalParseTypeE.MemberEnd;
        headerPr.PRmemberTypeEnum = InternalMemberTypeE.Item;
        headerPr.PRmemberValueEnum = InternalMemberValueE.Nested;
        headerPr.PRisHeaderRoot = true;             
        headerList.Add(headerPr);
      }
    }


    private void ProcessHeaderEnd(ParseRecord pr)
    {
      InternalST.Soap( this,"ProcessHeaderEnd ");
      pr.Dump();

      if (headerList == null)
        return; // Empty header array


      // Object End
      ParseRecord headerPr = GetPr();
      headerPr.PRparseTypeEnum = InternalParseTypeE.ObjectEnd;
      headerPr.PRobjectTypeEnum = InternalObjectTypeE.Array;
      headerList.Add(headerPr);

      headerPr = (ParseRecord)headerList[0];
      headerPr = (ParseRecord)headerList[0];
      headerPr.PRlengthA[0] = headerArrayLength;
      headerPr.PRobjectPositionEnum = InternalObjectPositionE.Headers;            

      for (int i=0; i<headerList.Count; i++)
      {
        InternalST.Soap( this, "Parse Header Record ",i);
        InternalST.Soap( this,"ObjectReader.Parse 9");              
        objectReader.Parse((ParseRecord)headerList[i]);
      }

      for (int i=0; i<headerList.Count; i++)
        PutPr((ParseRecord)headerList[i]);
    }

    [Serializable]
        enum HeaderStateEnum
    {
      None = 0,
      FirstHeaderRecord = 1,
      HeaderRecord = 2,
      NestedObject = 3,
      TopLevelObject = 4,
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\soapconverter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: Converter
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Hexify and bin.base64 conversions
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/


namespace System.Runtime.Serialization.Formatters.Soap {
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Metadata; 
    using System.Runtime.Remoting.Metadata.W3cXsd2001; 
    using System.Runtime.Serialization;
    using System;
    using System.Reflection;
    using System.Globalization;
    using System.Text;
    using System.Security.Permissions;

    sealed internal class Converter
    {
        private Converter()
        {
        }


        private static int primitiveTypeEnumLength = 46; //Number of PrimitiveTypeEnums

        // The following section are utilities to read and write XML types

        // Translates a runtime type into an enumeration code

        internal static InternalPrimitiveTypeE SoapToCode(Type type)
        {
            return ToCode(type);
        }

        internal static InternalPrimitiveTypeE ToCode(Type type)
        {
            InternalST.Soap("Converter", "ToCode Type Entry ",type," IsEnum "+type.IsEnum);         
            InternalPrimitiveTypeE code = InternalPrimitiveTypeE.Invalid;
            if (type.IsEnum)
                return code = InternalPrimitiveTypeE.Invalid;

            TypeCode typeCode = Type.GetTypeCode(type);

            if (typeCode == TypeCode.Object)
            {
                if (typeofISoapXsd.IsAssignableFrom(type))
                {
                    if (type == typeofSoapTime)
                        code = InternalPrimitiveTypeE.Time;
                    else if (type == typeofSoapDate)
                        code = InternalPrimitiveTypeE.Date;
                    else if (type == typeofSoapYearMonth)
                        code = InternalPrimitiveTypeE.YearMonth;
                    else if (type == typeofSoapYear)
                        code = InternalPrimitiveTypeE.Year;
                    else if (type == typeofSoapMonthDay)
                        code = InternalPrimitiveTypeE.MonthDay;
                    else if (type == typeofSoapDay)
                        code = InternalPrimitiveTypeE.Day;
                    else if (type == typeofSoapMonth)
                        code = InternalPrimitiveTypeE.Month;
                    else if (type == typeofSoapHexBinary)
                        code = InternalPrimitiveTypeE.HexBinary;
                    else if (type == typeofSoapBase64Binary)
                        code = InternalPrimitiveTypeE.Base64Binary;
                    else if (type == typeofSoapInteger)
                        code = InternalPrimitiveTypeE.Integer;
                    else if (type == typeofSoapPositiveInteger)
                        code = InternalPrimitiveTypeE.PositiveInteger;
                    else if (type == typeofSoapNonPositiveInteger)
                        code = InternalPrimitiveTypeE.NonPositiveInteger;
                    else if (type == typeofSoapNonNegativeInteger)
                        code = InternalPrimitiveTypeE.NonNegativeInteger;
                    else if (type == typeofSoapNegativeInteger)
                        code = InternalPrimitiveTypeE.NegativeInteger;
                    else if (type == typeofSoapAnyUri)
                        code = InternalPrimitiveTypeE.AnyUri;
                    else if (type == typeofSoapQName)
                        code = InternalPrimitiveTypeE.QName;
                    else if (type == typeofSoapNotation)
                        code = InternalPrimitiveTypeE.Notation;
                    else if (type == typeofSoapNormalizedString)
                        code = InternalPrimitiveTypeE.NormalizedString;
                    else if (type == typeofSoapToken)
                        code = InternalPrimitiveTypeE.Token;
                    else if (type == typeofSoapLanguage)
                        code = InternalPrimitiveTypeE.Language;
                    else if (type == typeofSoapName)
                        code = InternalPrimitiveTypeE.Name;
                    else if (type == typeofSoapIdrefs)
                        code = InternalPrimitiveTypeE.Idrefs;
                    else if (type == typeofSoapEntities)
                        code = InternalPrimitiveTypeE.Entities;
                    else if (type == typeofSoapNmtoken)
                        code = InternalPrimitiveTypeE.Nmtoken;
                    else if (type == typeofSoapNmtokens)
                        code = InternalPrimitiveTypeE.Nmtokens;
                    else if (type == typeofSoapNcName)
                        code = InternalPrimitiveTypeE.NcName;
                    else if (type == typeofSoapId)
                        code = InternalPrimitiveTypeE.Id;
                    else if (type == typeofSoapIdref)
                        code = InternalPrimitiveTypeE.Idref;
                    else if (type == typeofSoapEntity)
                        code = InternalPrimitiveTypeE.Entity;
                }
                else
                {
                    if (type ==  typeofTimeSpan)
                        code = InternalPrimitiveTypeE.TimeSpan;
                    else
                        code = InternalPrimitiveTypeE.Invalid;
                }
            }
            else
                code = ToPrimitiveTypeEnum(typeCode);

            InternalST.Soap("Converter", "ToCode Exit " , ((Enum)code).ToString());
            return code;
        }


        // Translates a String into a runtime type enumeration code.
        // The types translated are COM+ runtime types and XML Data Types

        internal static InternalPrimitiveTypeE SoapToCode(String value)
        {
            return ToCode(value);
        }

        internal static InternalPrimitiveTypeE ToCode(String value)
        {
            InternalST.Soap("Converter", "ToCode String Entry ",value);
            if (value == null)
                throw new ArgumentNullException("serParser", String.Format(SoapUtil.GetResourceString("ArgumentNull_WithParamName"), value));

            String lxsdType = value.ToLower(CultureInfo.InvariantCulture);
            Char firstChar = lxsdType[0];
            InternalPrimitiveTypeE code = InternalPrimitiveTypeE.Invalid;           

            switch (firstChar)
            {   
                case 'a':
                    if (lxsdType == "anyuri")
                        code = InternalPrimitiveTypeE.AnyUri;

                    break;
                case 'b':
                    if (lxsdType == "boolean")
                        code = InternalPrimitiveTypeE.Boolean;
                    else if (lxsdType == "byte")
                        code = InternalPrimitiveTypeE.SByte;
                    else if (lxsdType == "base64binary")
                        code = InternalPrimitiveTypeE.Base64Binary;
                    else if (lxsdType == "base64")
                        code = InternalPrimitiveTypeE.Base64Binary;
                    break;
                case 'c':
                    if ((lxsdType == "char") || (lxsdType == "character")) // Not xsd types
                        code = InternalPrimitiveTypeE.Char;
                    break;

                case 'd':
                    if (lxsdType == "double")
                        code = InternalPrimitiveTypeE.Double;
                    if (lxsdType == "datetime")
                        code = InternalPrimitiveTypeE.DateTime;
                    else if (lxsdType == "duration")
                        code = InternalPrimitiveTypeE.TimeSpan;
                    else if (lxsdType == "date")
                        code = InternalPrimitiveTypeE.Date;
                    else if (lxsdType == "decimal")  
                        code = InternalPrimitiveTypeE.Decimal; 

                    break;
                case 'e':
                    if (lxsdType == "entities")
                        code = InternalPrimitiveTypeE.Entities;
                    else if (lxsdType == "entity")
                        code = InternalPrimitiveTypeE.Entity;
                    break;
                case 'f':
                    if (lxsdType == "float")
                        code = InternalPrimitiveTypeE.Single;
                    break;
                case 'g':
                    if (lxsdType == "gyearmonth")
                        code = InternalPrimitiveTypeE.YearMonth;
                    else if (lxsdType == "gyear")
                        code = InternalPrimitiveTypeE.Year;
                    else if (lxsdType == "gmonthday")
                        code = InternalPrimitiveTypeE.MonthDay;
                    else if (lxsdType == "gday")
                        code = InternalPrimitiveTypeE.Day;
                    else if (lxsdType == "gmonth")
                        code = InternalPrimitiveTypeE.Month;
                    break;
                case 'h':
                    if (lxsdType == "hexbinary")
                        code = InternalPrimitiveTypeE.HexBinary;
                    break;
                case 'i':
                    if (lxsdType == "int")
                        code = InternalPrimitiveTypeE.Int32;
                    if (lxsdType == "integer")
                        code = InternalPrimitiveTypeE.Integer;
                    else if (lxsdType == "idrefs")
                        code = InternalPrimitiveTypeE.Idrefs;
                    else if (lxsdType == "id")
                        code = InternalPrimitiveTypeE.Id;
                    else if (lxsdType == "idref")
                        code = InternalPrimitiveTypeE.Idref;
                    break;
                case 'l':
                    if (lxsdType == "long")
                        code = InternalPrimitiveTypeE.Int64;
                    else if (lxsdType == "language")
                        code = InternalPrimitiveTypeE.Language;
                    break;
                case 'n':
                    if (lxsdType == "number") //No longer used
                        code = InternalPrimitiveTypeE.Decimal;
                    else if (lxsdType == "normalizedstring")
                        code = InternalPrimitiveTypeE.NormalizedString;
                    else if (lxsdType == "nonpositiveinteger")
                        code = InternalPrimitiveTypeE.NonPositiveInteger;
                    else if (lxsdType == "negativeinteger")
                        code = InternalPrimitiveTypeE.NegativeInteger;
                    else if (lxsdType == "nonnegativeinteger")
                        code = InternalPrimitiveTypeE.NonNegativeInteger;
                    else if (lxsdType == "notation")
                        code = InternalPrimitiveTypeE.Notation;
                    else if (lxsdType == "nmtoken")
                        code = InternalPrimitiveTypeE.Nmtoken;
                    else if (lxsdType == "nmtokens")
                        code = InternalPrimitiveTypeE.Nmtokens;
                    else if (lxsdType == "name")
                        code = InternalPrimitiveTypeE.Name;
                    else if (lxsdType == "ncname")
                        code = InternalPrimitiveTypeE.NcName;
                    break;
                case 'p':
                    if (lxsdType == "positiveinteger")
                        code = InternalPrimitiveTypeE.PositiveInteger;
                    break;
                case 'q':
                    if (lxsdType == "qname")
                        code = InternalPrimitiveTypeE.QName;
                    break;
                case 's':
                    if (lxsdType == "short")
                        code = InternalPrimitiveTypeE.Int16;
                    else if (lxsdType == "system.byte") // used during serialization
                        code = InternalPrimitiveTypeE.Byte;
                    else if (lxsdType == "system.sbyte") // used during serialization
                        code = InternalPrimitiveTypeE.SByte;
                    else if (lxsdType == "system") //used during serialization
                        code = ToCode(value.Substring(7));
                    else if (lxsdType == "system.runtime.remoting.metadata") //used during serialization
                        code = ToCode(value.Substring(33));
                    break;
                case 't':
                    if (lxsdType == "time")
                        code = InternalPrimitiveTypeE.Time;
                    else if (lxsdType == "token")
                        code = InternalPrimitiveTypeE.Token;
                    else if (lxsdType == "timeinstant")
                        code = InternalPrimitiveTypeE.DateTime;
                    else if (lxsdType == "timeduration")
                        code = InternalPrimitiveTypeE.TimeSpan;
                    break;
                case 'u':
                    if (lxsdType == "unsignedlong")
                        code = InternalPrimitiveTypeE.UInt64;
                    else if (lxsdType == "unsignedint")
                        code = InternalPrimitiveTypeE.UInt32;
                    else if (lxsdType == "unsignedshort")
                        code = InternalPrimitiveTypeE.UInt16;
                    else if (lxsdType == "unsignedbyte")
                        code = InternalPrimitiveTypeE.Byte;
                    break;
                default:
                    code = InternalPrimitiveTypeE.Invalid;
                    break;
            }

            InternalST.Soap("Converter", "ToCode Exit ", ((Enum)code).ToString());      
            return code;
        }

        internal static bool IsWriteAsByteArray(InternalPrimitiveTypeE code)
        {
            bool isWrite = false;

            switch (code)
            {
                case InternalPrimitiveTypeE.Boolean:
                case InternalPrimitiveTypeE.Char:
                case InternalPrimitiveTypeE.Byte:
                case InternalPrimitiveTypeE.Double:
                case InternalPrimitiveTypeE.Int16:
                case InternalPrimitiveTypeE.Int32:
                case InternalPrimitiveTypeE.Int64:
                case InternalPrimitiveTypeE.SByte:
                case InternalPrimitiveTypeE.Single:
                case InternalPrimitiveTypeE.UInt16:
                case InternalPrimitiveTypeE.UInt32:
                case InternalPrimitiveTypeE.UInt64:
                    isWrite = true;
                    break;
            }
            return isWrite;
        }

        internal static int TypeLength(InternalPrimitiveTypeE code)
        {
            int length  = 0;

            switch (code)
            {
                case InternalPrimitiveTypeE.Boolean:
                    length = 1;
                    break;
                case InternalPrimitiveTypeE.Char:
                    length = 2;
                    break;                  
                case InternalPrimitiveTypeE.Byte:
                    length = 1;
                    break;                  
                case InternalPrimitiveTypeE.Double:
                    length = 8;
                    break;                  
                case InternalPrimitiveTypeE.Int16:
                    length = 2;
                    break;                  
                case InternalPrimitiveTypeE.Int32:
                    length = 4;
                    break;                  
                case InternalPrimitiveTypeE.Int64:
                    length = 8;
                    break;                  
                case InternalPrimitiveTypeE.SByte:
                    length = 1;
                    break;                  
                case InternalPrimitiveTypeE.Single:
                    length = 4;
                    break;                  
                case InternalPrimitiveTypeE.UInt16:
                    length = 2;
                    break;                  
                case InternalPrimitiveTypeE.UInt32:
                    length = 4;
                    break;                  
                case InternalPrimitiveTypeE.UInt64:
                    length = 8;
                    break;                  
            }
            return length;
        }


        internal static InternalNameSpaceE GetNameSpaceEnum(InternalPrimitiveTypeE code, Type type, WriteObjectInfo objectInfo, out String typeName)
        {
            InternalST.Soap("Converter", "GetNameSpaceEnum Entry ",((Enum)code).ToString()," type ",type);                  
            InternalNameSpaceE nameSpaceEnum = InternalNameSpaceE.None;
            typeName = null;

            if (code != InternalPrimitiveTypeE.Invalid)
            {

                if (code == InternalPrimitiveTypeE.Char)
                {
                    nameSpaceEnum = InternalNameSpaceE.UrtSystem;
                    typeName = "System.Char";
                }
                else
                {
                    nameSpaceEnum = InternalNameSpaceE.XdrPrimitive;
                    typeName = ToXmlDataType(code);
                }
            }

            if ((nameSpaceEnum == InternalNameSpaceE.None) && (type != null))
            {
                if (type == typeofString)
                    nameSpaceEnum = InternalNameSpaceE.XdrString;
                else
                {
                    if (objectInfo == null)
                    {
                        typeName = type.FullName;
                        if (type.Module.Assembly == urtAssembly)
                            nameSpaceEnum = InternalNameSpaceE.UrtSystem;
                        else
                            nameSpaceEnum = InternalNameSpaceE.UrtUser;                     
                    }
                    else
                    {
                        typeName = objectInfo.GetTypeFullName();
                        // If objref is created from a proxy, it will have the proxy namespace
                        // Need to force ObjRef to have system namespace
                        if (objectInfo.GetAssemblyString().Equals(urtAssemblyString))
                            nameSpaceEnum = InternalNameSpaceE.UrtSystem;
                        else
                            nameSpaceEnum = InternalNameSpaceE.UrtUser;
                    }
                }
            }

            // If there is an explicitly specified namespace, then it is used
            if (objectInfo != null)
            {
                if (!objectInfo.isSi &&
                    (objectInfo.IsAttributeNameSpace() ||
                    objectInfo.IsCustomXmlAttribute() ||
                    objectInfo.IsCustomXmlElement()))
                {
                    nameSpaceEnum = InternalNameSpaceE.Interop;
                }
                else if (objectInfo.IsCallElement())
                {
                    nameSpaceEnum = InternalNameSpaceE.CallElement;
                }
            }

            InternalST.Soap("Converter", "GetNameSpaceEnum Exit ", ((Enum)nameSpaceEnum).ToString()," typeName ",typeName);                             
            return nameSpaceEnum;
        }

        // Primitive types for which types need to be transmitted in Soap for ISerialable
        internal static bool IsSiTransmitType(InternalPrimitiveTypeE code)
        {
            switch (code)
            {
                case InternalPrimitiveTypeE.TimeSpan:
                case InternalPrimitiveTypeE.DateTime:
                case InternalPrimitiveTypeE.Time:
                case InternalPrimitiveTypeE.Date:
                case InternalPrimitiveTypeE.YearMonth:
                case InternalPrimitiveTypeE.Year:
                case InternalPrimitiveTypeE.MonthDay:
                case InternalPrimitiveTypeE.Day:
                case InternalPrimitiveTypeE.Month:
                case InternalPrimitiveTypeE.HexBinary:
                case InternalPrimitiveTypeE.Base64Binary:
                case InternalPrimitiveTypeE.Integer:
                case InternalPrimitiveTypeE.PositiveInteger:
                case InternalPrimitiveTypeE. NonPositiveInteger:
                case InternalPrimitiveTypeE.NonNegativeInteger:
                case InternalPrimitiveTypeE.NegativeInteger:
                case InternalPrimitiveTypeE.AnyUri:
                case InternalPrimitiveTypeE.QName:
                case InternalPrimitiveTypeE.Notation:
                case InternalPrimitiveTypeE.NormalizedString:
                case InternalPrimitiveTypeE.Token:
                case InternalPrimitiveTypeE.Language:
                case InternalPrimitiveTypeE.Name:
                case InternalPrimitiveTypeE.Idrefs:
                case InternalPrimitiveTypeE.Entities:
                case InternalPrimitiveTypeE.Nmtoken:
                case InternalPrimitiveTypeE.Nmtokens:
                case InternalPrimitiveTypeE.NcName:
                case InternalPrimitiveTypeE.Id:
                case InternalPrimitiveTypeE.Idref:
                case InternalPrimitiveTypeE.Entity:
                case InternalPrimitiveTypeE.Invalid:                    
                    return true;
                default:
                    return false;
            }
        }


        private static Type[] typeA;

        private static void InitTypeA()
        {
            typeA = new Type[primitiveTypeEnumLength];
            typeA[(int)InternalPrimitiveTypeE.Invalid] = null;
            typeA[(int)InternalPrimitiveTypeE.Boolean] = typeofBoolean;
            typeA[(int)InternalPrimitiveTypeE.Byte] = typeofByte;
            typeA[(int)InternalPrimitiveTypeE.Char] = typeofChar;
            typeA[(int)InternalPrimitiveTypeE.Decimal] = typeofDecimal;
            typeA[(int)InternalPrimitiveTypeE.Double] = typeofDouble;
            typeA[(int)InternalPrimitiveTypeE.Int16] = typeofInt16;
            typeA[(int)InternalPrimitiveTypeE.Int32] = typeofInt32;
            typeA[(int)InternalPrimitiveTypeE.Int64] = typeofInt64;
            typeA[(int)InternalPrimitiveTypeE.SByte] = typeofSByte;
            typeA[(int)InternalPrimitiveTypeE.Single] = typeofSingle;
            typeA[(int)InternalPrimitiveTypeE.TimeSpan] = typeofTimeSpan;
            typeA[(int)InternalPrimitiveTypeE.DateTime] = typeofDateTime;
            typeA[(int)InternalPrimitiveTypeE.UInt16] = typeofUInt16;
            typeA[(int)InternalPrimitiveTypeE.UInt32] = typeofUInt32;
            typeA[(int)InternalPrimitiveTypeE.UInt64] = typeofUInt64;
            typeA[(int)InternalPrimitiveTypeE.Time] = typeofSoapTime;
            typeA[(int)InternalPrimitiveTypeE.Date] = typeofSoapDate;
            typeA[(int)InternalPrimitiveTypeE.YearMonth] = typeofSoapYearMonth;
            typeA[(int)InternalPrimitiveTypeE.Year] = typeofSoapYear;
            typeA[(int)InternalPrimitiveTypeE.MonthDay] = typeofSoapMonthDay;
            typeA[(int)InternalPrimitiveTypeE.Day] = typeofSoapDay;
            typeA[(int)InternalPrimitiveTypeE.Month] = typeofSoapMonth;
            typeA[(int)InternalPrimitiveTypeE.HexBinary] = typeofSoapHexBinary;
            typeA[(int)InternalPrimitiveTypeE.Base64Binary] = typeofSoapBase64Binary;
            typeA[(int)InternalPrimitiveTypeE.Integer] = typeofSoapInteger;
            typeA[(int)InternalPrimitiveTypeE.PositiveInteger] = typeofSoapPositiveInteger;
            typeA[(int)InternalPrimitiveTypeE.NonPositiveInteger] = typeofSoapNonPositiveInteger;
            typeA[(int)InternalPrimitiveTypeE.NonNegativeInteger] = typeofSoapNonNegativeInteger;
            typeA[(int)InternalPrimitiveTypeE.NegativeInteger] = typeofSoapNegativeInteger;
            typeA[(int)InternalPrimitiveTypeE.AnyUri] = typeofSoapAnyUri;
            typeA[(int)InternalPrimitiveTypeE.QName] = typeofSoapQName;
            typeA[(int)InternalPrimitiveTypeE.Notation] = typeofSoapNotation;
            typeA[(int)InternalPrimitiveTypeE.NormalizedString] = typeofSoapNormalizedString;
            typeA[(int)InternalPrimitiveTypeE.Token] = typeofSoapToken;
            typeA[(int)InternalPrimitiveTypeE.Language] = typeofSoapLanguage;
            typeA[(int)InternalPrimitiveTypeE.Name] = typeofSoapName;
            typeA[(int)InternalPrimitiveTypeE.Idrefs] = typeofSoapIdrefs;
            typeA[(int)InternalPrimitiveTypeE.Entities] = typeofSoapEntities;
            typeA[(int)InternalPrimitiveTypeE.Nmtoken] = typeofSoapNmtoken;
            typeA[(int)InternalPrimitiveTypeE.Nmtokens] = typeofSoapNmtokens;
            typeA[(int)InternalPrimitiveTypeE.NcName] = typeofSoapNcName;
            typeA[(int)InternalPrimitiveTypeE.Id] = typeofSoapId;
            typeA[(int)InternalPrimitiveTypeE.Idref] = typeofSoapIdref;
            typeA[(int)InternalPrimitiveTypeE.Entity] = typeofSoapEntity;
        }

        // Returns a COM runtime type associated with the type  code

        internal static Type SoapToType(InternalPrimitiveTypeE code)
        {
            return ToType(code);
        }

        internal static Type ToType(InternalPrimitiveTypeE code)
        {
            InternalST.Soap("Converter", "ToType Entry ", ((Enum)code).ToString());
            lock(typeofConverter)
            {
                if (typeA == null)
                    InitTypeA();
            }
            InternalST.Soap("Converter", "ToType Exit ", ((typeA[(int)code] == null)?"null ":typeA[(int)code].Name));               
            return typeA[(int)code];
        }

        private static String[] valueA;

        private static void InitValueA()
        {
            valueA = new String[primitiveTypeEnumLength];
            valueA[(int)InternalPrimitiveTypeE.Invalid] = null;
            valueA[(int)InternalPrimitiveTypeE.Boolean] = "System.Boolean";
            valueA[(int)InternalPrimitiveTypeE.Byte] = "System.Byte";
            valueA[(int)InternalPrimitiveTypeE.Char] = "System.Char";
            valueA[(int)InternalPrimitiveTypeE.Decimal] = "System.Decimal";
            valueA[(int)InternalPrimitiveTypeE.Double] = "System.Double";
            valueA[(int)InternalPrimitiveTypeE.Int16] = "System.Int16";
            valueA[(int)InternalPrimitiveTypeE.Int32] = "System.Int32";
            valueA[(int)InternalPrimitiveTypeE.Int64] = "System.Int64";
            valueA[(int)InternalPrimitiveTypeE.SByte] = "System.SByte";
            valueA[(int)InternalPrimitiveTypeE.Single] = "System.Single";
            valueA[(int)InternalPrimitiveTypeE.TimeSpan] = "System.TimeSpan";
            valueA[(int)InternalPrimitiveTypeE.DateTime] = "System.DateTime";
            valueA[(int)InternalPrimitiveTypeE.UInt16] = "System.UInt16";
            valueA[(int)InternalPrimitiveTypeE.UInt32] = "System.UInt32";
            valueA[(int)InternalPrimitiveTypeE.UInt64] = "System.UInt64"; 

            valueA[(int)InternalPrimitiveTypeE.Time] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapTime";
            valueA[(int)InternalPrimitiveTypeE.Date] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDate";
            valueA[(int)InternalPrimitiveTypeE.YearMonth] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYearMonth";
            valueA[(int)InternalPrimitiveTypeE.Year] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYear";
            valueA[(int)InternalPrimitiveTypeE.MonthDay] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonthDay";
            valueA[(int)InternalPrimitiveTypeE.Day] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDay";
            valueA[(int)InternalPrimitiveTypeE.Month] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonth";
            valueA[(int)InternalPrimitiveTypeE.HexBinary] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary";
            valueA[(int)InternalPrimitiveTypeE.Base64Binary] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapBase64Binary";
            valueA[(int)InternalPrimitiveTypeE.Integer] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapInteger";
            valueA[(int)InternalPrimitiveTypeE.PositiveInteger] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapPositiveInteger";
            valueA[(int)InternalPrimitiveTypeE.NonPositiveInteger] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonPositiveInteger";
            valueA[(int)InternalPrimitiveTypeE.NonNegativeInteger] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonNegativeInteger";
            valueA[(int)InternalPrimitiveTypeE.NegativeInteger] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNegativeInteger";
            valueA[(int)InternalPrimitiveTypeE.AnyUri] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapAnyUri";
            valueA[(int)InternalPrimitiveTypeE.QName] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapQName";
            valueA[(int)InternalPrimitiveTypeE.Notation] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNotation";
            valueA[(int)InternalPrimitiveTypeE.NormalizedString] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNormalizedString";
            valueA[(int)InternalPrimitiveTypeE.Token] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapToken";
            valueA[(int)InternalPrimitiveTypeE.Language] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapLanguage";
            valueA[(int)InternalPrimitiveTypeE.Name] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapName";
            valueA[(int)InternalPrimitiveTypeE.Idrefs] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdrefs";
            valueA[(int)InternalPrimitiveTypeE.Entities] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntities";
            valueA[(int)InternalPrimitiveTypeE.Nmtoken] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtoken";
            valueA[(int)InternalPrimitiveTypeE.Nmtokens] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtokens";
            valueA[(int)InternalPrimitiveTypeE.NcName] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNcName";
            valueA[(int)InternalPrimitiveTypeE.Id] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapId";
            valueA[(int)InternalPrimitiveTypeE.Idref] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdref";
            valueA[(int)InternalPrimitiveTypeE.Entity] = "System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntity";
        }

        // Returns a String containg a COM+ runtime type associated with the type code
        internal static String SoapToComType(InternalPrimitiveTypeE code)
        {
            return ToComType(code);
        }

        internal static String ToComType(InternalPrimitiveTypeE code)
        {
            InternalST.Soap("Converter", "ToComType Entry ", ((Enum)code).ToString());

            lock(typeofConverter)
            {
                if (valueA == null)
                    InitValueA();
            }

            InternalST.Soap("Converter", "ToComType Exit ",((valueA[(int)code] == null)?"null":valueA[(int)code]));             

            return valueA[(int)code];
        }

        private static String[] valueB;

        private static void InitValueB()
        {
            valueB = new String[primitiveTypeEnumLength];
            valueB[(int)InternalPrimitiveTypeE.Invalid] = null;
            valueB[(int)InternalPrimitiveTypeE.Boolean] = "boolean";
            valueB[(int)InternalPrimitiveTypeE.Byte] = "unsignedByte";
            valueB[(int)InternalPrimitiveTypeE.Char] = "char"; //not an xsi type, but will cause problems with clr if char is not used
            valueB[(int)InternalPrimitiveTypeE.Decimal] = "decimal";
            valueB[(int)InternalPrimitiveTypeE.Double] = "double";
            valueB[(int)InternalPrimitiveTypeE.Int16] = "short";
            valueB[(int)InternalPrimitiveTypeE.Int32] = "int";
            valueB[(int)InternalPrimitiveTypeE.Int64] = "long";
            valueB[(int)InternalPrimitiveTypeE.SByte] = "byte";
            valueB[(int)InternalPrimitiveTypeE.Single] = "float";
            valueB[(int)InternalPrimitiveTypeE.TimeSpan] = "duration";
            valueB[(int)InternalPrimitiveTypeE.DateTime] = "dateTime";
            valueB[(int)InternalPrimitiveTypeE.UInt16] = "unsignedShort";
            valueB[(int)InternalPrimitiveTypeE.UInt32] = "unsignedInt";
            valueB[(int)InternalPrimitiveTypeE.UInt64] = "unsignedLong"; 

            valueB[(int)InternalPrimitiveTypeE.Time] = SoapTime.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Date] = SoapDate.XsdType;
            valueB[(int)InternalPrimitiveTypeE.YearMonth] = SoapYearMonth.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Year] = SoapYear.XsdType;
            valueB[(int)InternalPrimitiveTypeE.MonthDay] = SoapMonthDay.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Day] = SoapDay.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Month] = SoapMonth.XsdType;
            valueB[(int)InternalPrimitiveTypeE.HexBinary] = SoapHexBinary.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Base64Binary] = SoapBase64Binary.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Integer] = SoapInteger.XsdType;
            valueB[(int)InternalPrimitiveTypeE.PositiveInteger] = SoapPositiveInteger.XsdType;
            valueB[(int)InternalPrimitiveTypeE.NonPositiveInteger] = SoapNonPositiveInteger.XsdType;
            valueB[(int)InternalPrimitiveTypeE.NonNegativeInteger] = SoapNonNegativeInteger.XsdType;
            valueB[(int)InternalPrimitiveTypeE.NegativeInteger] = SoapNegativeInteger.XsdType;
            valueB[(int)InternalPrimitiveTypeE.AnyUri] = SoapAnyUri.XsdType;
            valueB[(int)InternalPrimitiveTypeE.QName] = SoapQName.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Notation] = SoapNotation.XsdType;
            valueB[(int)InternalPrimitiveTypeE.NormalizedString] = SoapNormalizedString.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Token] = SoapToken.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Language] = SoapLanguage.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Name] = SoapName.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Idrefs] = SoapIdrefs.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Entities] = SoapEntities.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Nmtoken] = SoapNmtoken.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Nmtokens] = SoapNmtokens.XsdType;
            valueB[(int)InternalPrimitiveTypeE.NcName] = SoapNcName.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Id] = SoapId.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Idref] = SoapIdref.XsdType;
            valueB[(int)InternalPrimitiveTypeE.Entity] = SoapEntity.XsdType;
        }


        // Returns a String containg an XML Data type associated with the type code
        internal static String ToXmlDataType(InternalPrimitiveTypeE code)
        {
            InternalST.Soap( "Converter", "ToXmlDataType Entry ", ((Enum)code).ToString());     

            lock(typeofConverter)
            {
                if (valueB == null)
                    InitValueB();
            }

            InternalST.Soap( "Converter", "ToXmlDataType Exit ",((valueB[(int)code] == null)?"null":valueB[(int)code]));                

            return valueB[(int)code];
        }

        private static TypeCode[] typeCodeA;

        private static void InitTypeCodeA()
        {
            typeCodeA = new TypeCode[primitiveTypeEnumLength];
            typeCodeA[(int)InternalPrimitiveTypeE.Invalid] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Boolean] = TypeCode.Boolean;
            typeCodeA[(int)InternalPrimitiveTypeE.Byte] = TypeCode.Byte;
            typeCodeA[(int)InternalPrimitiveTypeE.Char] = TypeCode.Char;
            typeCodeA[(int)InternalPrimitiveTypeE.Decimal] = TypeCode.Decimal;
            typeCodeA[(int)InternalPrimitiveTypeE.Double] = TypeCode.Double;
            typeCodeA[(int)InternalPrimitiveTypeE.Int16] = TypeCode.Int16;
            typeCodeA[(int)InternalPrimitiveTypeE.Int32] = TypeCode.Int32;
            typeCodeA[(int)InternalPrimitiveTypeE.Int64] = TypeCode.Int64;
            typeCodeA[(int)InternalPrimitiveTypeE.SByte] = TypeCode.SByte;
            typeCodeA[(int)InternalPrimitiveTypeE.Single] = TypeCode.Single;
            typeCodeA[(int)InternalPrimitiveTypeE.TimeSpan] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.DateTime] = TypeCode.DateTime;
            typeCodeA[(int)InternalPrimitiveTypeE.UInt16] = TypeCode.UInt16;
            typeCodeA[(int)InternalPrimitiveTypeE.UInt32] = TypeCode.UInt32;
            typeCodeA[(int)InternalPrimitiveTypeE.UInt64] = TypeCode.UInt64;

            typeCodeA[(int)InternalPrimitiveTypeE.Time] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Date] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.YearMonth] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Year] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.MonthDay] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Day] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Month] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.HexBinary] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Base64Binary] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Integer] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.PositiveInteger] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.NonPositiveInteger] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.NonNegativeInteger] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.NegativeInteger] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.AnyUri] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.QName] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Notation] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.NormalizedString] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Token] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Language] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Name] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Idrefs] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Entities] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Nmtoken] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Nmtokens] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.NcName] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Id] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Idref] = TypeCode.Object;
            typeCodeA[(int)InternalPrimitiveTypeE.Entity] = TypeCode.Object;
        }

        // Returns a System.TypeCode from a InternalPrimitiveTypeE
        internal static TypeCode ToTypeCode(InternalPrimitiveTypeE code)
        {
            lock(typeofConverter)
            {
                if (typeCodeA == null)
                    InitTypeCodeA();
            }
            return typeCodeA[(int)code];
        }


        private static InternalPrimitiveTypeE[] codeA;

        private static void InitCodeA()
        {
            codeA = new InternalPrimitiveTypeE[19];
            codeA[(int)TypeCode.Empty] = InternalPrimitiveTypeE.Invalid;
            codeA[(int)TypeCode.Object] = InternalPrimitiveTypeE.Invalid;
            codeA[(int)TypeCode.DBNull] = InternalPrimitiveTypeE.Invalid;                   
            codeA[(int)TypeCode.Boolean] = InternalPrimitiveTypeE.Boolean;
            codeA[(int)TypeCode.Char] = InternalPrimitiveTypeE.Char;
            codeA[(int)TypeCode.SByte] = InternalPrimitiveTypeE.SByte;
            codeA[(int)TypeCode.Byte] = InternalPrimitiveTypeE.Byte;
            codeA[(int)TypeCode.Int16] = InternalPrimitiveTypeE.Int16;
            codeA[(int)TypeCode.UInt16] = InternalPrimitiveTypeE.UInt16;
            codeA[(int)TypeCode.Int32] = InternalPrimitiveTypeE.Int32;
            codeA[(int)TypeCode.UInt32] = InternalPrimitiveTypeE.UInt32;
            codeA[(int)TypeCode.Int64] = InternalPrimitiveTypeE.Int64;
            codeA[(int)TypeCode.UInt64] = InternalPrimitiveTypeE.UInt64;
            codeA[(int)TypeCode.Single] = InternalPrimitiveTypeE.Single;
            codeA[(int)TypeCode.Double] = InternalPrimitiveTypeE.Double;
            codeA[(int)TypeCode.Decimal] = InternalPrimitiveTypeE.Decimal;
            codeA[(int)TypeCode.DateTime] = InternalPrimitiveTypeE.DateTime;
            codeA[17] = InternalPrimitiveTypeE.Invalid;
            codeA[(int)TypeCode.String] = InternalPrimitiveTypeE.Invalid;                                       
            //codeA[(int)TypeCode.TimeSpan] = InternalPrimitiveTypeE.TimeSpan;
        }

        // Returns a InternalPrimitiveTypeE from a System.TypeCode
        internal static InternalPrimitiveTypeE ToPrimitiveTypeEnum(TypeCode typeCode)
        {
            lock(typeofConverter)
            {
                if (codeA == null)
                    InitCodeA();
            }
            return codeA[(int)typeCode];
        }

        //********************
        private static bool[] escapeA;

        private static void InitEscapeA()
        {
            escapeA = new bool[primitiveTypeEnumLength];
            escapeA[(int)InternalPrimitiveTypeE.Invalid] = true;
            escapeA[(int)InternalPrimitiveTypeE.Boolean] = false;
            escapeA[(int)InternalPrimitiveTypeE.Byte] = false;
            escapeA[(int)InternalPrimitiveTypeE.Char] = true;
            escapeA[(int)InternalPrimitiveTypeE.Decimal] = false;
            escapeA[(int)InternalPrimitiveTypeE.Double] = false;
            escapeA[(int)InternalPrimitiveTypeE.Int16] = false;
            escapeA[(int)InternalPrimitiveTypeE.Int32] = false;
            escapeA[(int)InternalPrimitiveTypeE.Int64] = false;
            escapeA[(int)InternalPrimitiveTypeE.SByte] = false;
            escapeA[(int)InternalPrimitiveTypeE.Single] = false;
            escapeA[(int)InternalPrimitiveTypeE.TimeSpan] = false;
            escapeA[(int)InternalPrimitiveTypeE.DateTime] = false;
            escapeA[(int)InternalPrimitiveTypeE.UInt16] = false;
            escapeA[(int)InternalPrimitiveTypeE.UInt32] = false;
            escapeA[(int)InternalPrimitiveTypeE.UInt64] = false;

            escapeA[(int)InternalPrimitiveTypeE.Time] = false;
            escapeA[(int)InternalPrimitiveTypeE.Date] = false;
            escapeA[(int)InternalPrimitiveTypeE.YearMonth] = false;
            escapeA[(int)InternalPrimitiveTypeE.Year] = false;
            escapeA[(int)InternalPrimitiveTypeE.MonthDay] = false;
            escapeA[(int)InternalPrimitiveTypeE.Day] = false;
            escapeA[(int)InternalPrimitiveTypeE.Month] = false;
            escapeA[(int)InternalPrimitiveTypeE.HexBinary] = false;
            escapeA[(int)InternalPrimitiveTypeE.Base64Binary] = false;
            escapeA[(int)InternalPrimitiveTypeE.Integer] = false;
            escapeA[(int)InternalPrimitiveTypeE.PositiveInteger] = false;
            escapeA[(int)InternalPrimitiveTypeE.NonPositiveInteger] = false;
            escapeA[(int)InternalPrimitiveTypeE.NonNegativeInteger] = false;
            escapeA[(int)InternalPrimitiveTypeE.NegativeInteger] = false;
            escapeA[(int)InternalPrimitiveTypeE.AnyUri] = true;
            escapeA[(int)InternalPrimitiveTypeE.QName] = true;
            escapeA[(int)InternalPrimitiveTypeE.Notation] = true;
            escapeA[(int)InternalPrimitiveTypeE.NormalizedString] = false;
            escapeA[(int)InternalPrimitiveTypeE.Token] = true;
            escapeA[(int)InternalPrimitiveTypeE.Language] = true;
            escapeA[(int)InternalPrimitiveTypeE.Name] = true;
            escapeA[(int)InternalPrimitiveTypeE.Idrefs] = true;
            escapeA[(int)InternalPrimitiveTypeE.Entities] = true;
            escapeA[(int)InternalPrimitiveTypeE.Nmtoken] = true;
            escapeA[(int)InternalPrimitiveTypeE.Nmtokens] = true;
            escapeA[(int)InternalPrimitiveTypeE.NcName] = true;
            escapeA[(int)InternalPrimitiveTypeE.Id] = true;
            escapeA[(int)InternalPrimitiveTypeE.Idref] = true;
            escapeA[(int)InternalPrimitiveTypeE.Entity] = true;
        }

        // Checks if the string is escaped (XML escape characters)
        internal static bool IsEscaped(InternalPrimitiveTypeE code)
        {
            lock(typeofConverter)
            {
                if (escapeA == null)
                    InitEscapeA();
            }
            return escapeA[(int)code];
        }


        // Translates an Object into a string with the COM+ runtime type name
        //@VariantSwitch: Should this use Convert or just cast?
        private static StringBuilder sb = new StringBuilder(30);

        internal static String SoapToString(Object data, InternalPrimitiveTypeE code)
        {
            return ToString(data, code);
        }

        internal static String ToString(Object data, InternalPrimitiveTypeE code)
        {
            // Any changes here need to also be made in System.Runtime.Remoting.Message.cs::SoapCoerceArg

            String value;
            InternalST.Soap( "Converter", "ToString Entry ", ((data==null)?"<null>":data.GetType().ToString())," ",data," " , ((Enum)code).ToString());

            switch (code)
            {
                case InternalPrimitiveTypeE.Boolean:
                    bool b = (bool)data;
                    if (b)
                        value = "true";
                    else
                        value = "false";
                    break;

                case InternalPrimitiveTypeE.TimeSpan:
                    value = SoapDuration.ToString((TimeSpan)data);
                    break;                          
                case InternalPrimitiveTypeE.DateTime:
                    value = SoapDateTime.ToString((DateTime)data);
                    break;
                case InternalPrimitiveTypeE.Invalid:
                    // ToString should not be called if data is an object or string
                    InternalST.SoapAssert(false, "[Converter.ToString]!InternalPrimitiveTypeE.Invalid ");
                    value = data.ToString();
                    break;
                case InternalPrimitiveTypeE.Double:
                    Double doublevalue = (Double)data;
                    if (Double.IsPositiveInfinity(doublevalue))
                        value = "INF";
                    else if (Double.IsNegativeInfinity(doublevalue))
                        value = "-INF";
                    else
                        value = doublevalue.ToString("R", CultureInfo.InvariantCulture);
                    break;
                case InternalPrimitiveTypeE.Single:
                    Single singlevalue = (Single)data;
                    if (Single.IsPositiveInfinity(singlevalue))
                        value = "INF";
                    else if (Single.IsNegativeInfinity(singlevalue))
                        value = "-INF";
                    else
                        value = singlevalue.ToString("R", CultureInfo.InvariantCulture);
                    break; 
                case InternalPrimitiveTypeE.Time:
                case InternalPrimitiveTypeE.Date:
                case InternalPrimitiveTypeE.YearMonth:
                case InternalPrimitiveTypeE.Year:
                case InternalPrimitiveTypeE.MonthDay:
                case InternalPrimitiveTypeE.Day:
                case InternalPrimitiveTypeE.Month:
                case InternalPrimitiveTypeE.HexBinary:
                case InternalPrimitiveTypeE.Base64Binary:
                case InternalPrimitiveTypeE.Integer:
                case InternalPrimitiveTypeE.PositiveInteger:
                case InternalPrimitiveTypeE. NonPositiveInteger:
                case InternalPrimitiveTypeE.NonNegativeInteger:
                case InternalPrimitiveTypeE.NegativeInteger:
                case InternalPrimitiveTypeE.AnyUri:
                case InternalPrimitiveTypeE.QName:
                case InternalPrimitiveTypeE.Notation:
                case InternalPrimitiveTypeE.NormalizedString:
                case InternalPrimitiveTypeE.Token:
                case InternalPrimitiveTypeE.Language:
                case InternalPrimitiveTypeE.Name:
                case InternalPrimitiveTypeE.Idrefs:
                case InternalPrimitiveTypeE.Entities:
                case InternalPrimitiveTypeE.Nmtoken:
                case InternalPrimitiveTypeE.Nmtokens:
                case InternalPrimitiveTypeE.NcName:
                case InternalPrimitiveTypeE.Id:
                case InternalPrimitiveTypeE.Idref:
                case InternalPrimitiveTypeE.Entity:
                        value = data.ToString();
                        break;
                default:
                    value = (String)Convert.ChangeType(data, typeofString, CultureInfo.InvariantCulture);
                    break;
            }

            InternalST.Soap( "Converter", "ToString Exit ",value);          
            return value;
        }

        // Translates a string into an Object
        internal static Object FromString(String value, InternalPrimitiveTypeE code)
        {
            Object var;
            InternalST.Soap( "Converter", "FromString Entry ",value," " , ((Enum)code).ToString());             
            switch (code)
            {
                case InternalPrimitiveTypeE.Boolean:
                    if (value == "1" || value == "true")
                        var = (bool)true;
                    else if (value == "0" || value =="false")
                        var = (bool)false;
                    else
                        throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_typeCoercion"),value, "Boolean"));																				
                    break;
                case InternalPrimitiveTypeE.TimeSpan:
                    var = SoapDuration.Parse(value);
                    break;                          
                case InternalPrimitiveTypeE.DateTime:
                    var = SoapDateTime.Parse(value);
                    break;   
                case InternalPrimitiveTypeE.Double:
                    if (value == "INF")
                        var =  Double.PositiveInfinity;
                    else if (value == "-INF")
                        var =  Double.NegativeInfinity;
                    else
                        var = Double.Parse(value, CultureInfo.InvariantCulture);
                    break;
                case InternalPrimitiveTypeE.Single:
                    if (value == "INF")
                        var =  Single.PositiveInfinity;
                    else if (value == "-INF")
                        var =  Single.NegativeInfinity;
                    else
                        var = Single.Parse(value, CultureInfo.InvariantCulture);
                    break;
                case InternalPrimitiveTypeE.Time:
                    var= SoapTime.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Date:
                    var= SoapDate.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.YearMonth:
                    var= SoapYearMonth.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Year:
                    var= SoapYear.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.MonthDay:
                    var= SoapMonthDay.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Day:
                    var= SoapDay.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Month:
                    var= SoapMonth.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.HexBinary:
                    var= SoapHexBinary.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Base64Binary:
                    var= SoapBase64Binary.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Integer:
                    var= SoapInteger.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.PositiveInteger:
                    var= SoapPositiveInteger.Parse(value);
                    break; 
                case InternalPrimitiveTypeE. NonPositiveInteger:
                    var= SoapNonPositiveInteger.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.NonNegativeInteger:
                    var= SoapNonNegativeInteger.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.NegativeInteger:
                    var= SoapNegativeInteger.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.AnyUri:
                    var= SoapAnyUri.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.QName:
                    var= SoapQName.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Notation:
                    var= SoapNotation.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.NormalizedString:
                    var= SoapNormalizedString.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Token:
                    var= SoapToken.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Language:
                    var= SoapLanguage.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Name:
                    var= SoapName.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Idrefs:
                    var= SoapIdrefs.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Entities:
                    var= SoapEntities.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Nmtoken:
                    var= SoapNmtoken.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Nmtokens:
                    var= SoapNmtokens.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.NcName:
                    var= SoapNcName.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Id:
                    var= SoapId.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Idref:
                    var= SoapIdref.Parse(value);
                    break; 
                case InternalPrimitiveTypeE.Entity:
                    var= SoapEntity.Parse(value);
                    break; 

                default:
                    // InternalPrimitiveTypeE needs to be a primitive type
                    InternalST.SoapAssert((code != InternalPrimitiveTypeE.Invalid), "[Converter.FromString]!InternalPrimitiveTypeE.Invalid ");
                    if (code != InternalPrimitiveTypeE.Invalid)
                        var = Convert.ChangeType(value, ToTypeCode(code), CultureInfo.InvariantCulture);
                    else
                        var = value;
                    break;
            }
            InternalST.Soap( "Converter", "FromString Exit "+((var == null)?"null":var+" var type "+((var==null)?"<null>":var.GetType().ToString())));
            return var;

        }


        internal static Type typeofISerializable = typeof(ISerializable);
        internal static Type typeofString = typeof(String);
        internal static Type typeofConverter = typeof(Converter);
        internal static Type typeofBoolean = typeof(Boolean);
        internal static Type typeofByte = typeof(Byte);
        internal static Type typeofChar = typeof(Char);
        internal static Type typeofDecimal = typeof(Decimal);
        internal static Type typeofDouble = typeof(Double);
        internal static Type typeofInt16 = typeof(Int16);
        internal static Type typeofInt32 = typeof(Int32);
        internal static Type typeofInt64 = typeof(Int64);
        internal static Type typeofSByte = typeof(SByte);
        internal static Type typeofSingle = typeof(Single);
        internal static Type typeofTimeSpan = typeof(TimeSpan);
        internal static Type typeofDateTime = typeof(DateTime);
        internal static Type typeofUInt16 = typeof(UInt16);
        internal static Type typeofUInt32 = typeof(UInt32);
        internal static Type typeofUInt64 = typeof(UInt64);
        internal static Type typeofSoapTime = typeof(SoapTime);
        internal static Type typeofSoapDate = typeof(SoapDate);
        internal static Type typeofSoapYear = typeof(SoapYear);
        internal static Type typeofSoapMonthDay = typeof(SoapMonthDay);
        internal static Type typeofSoapYearMonth = typeof(SoapYearMonth);
        internal static Type typeofSoapDay = typeof(SoapDay);
        internal static Type typeofSoapMonth = typeof(SoapMonth);
        internal static Type typeofSoapHexBinary = typeof(SoapHexBinary);
        internal static Type typeofSoapBase64Binary = typeof(SoapBase64Binary);
        internal static Type typeofSoapInteger = typeof(SoapInteger);
        internal static Type typeofSoapPositiveInteger = typeof(SoapPositiveInteger);
        internal static Type typeofSoapNonPositiveInteger = typeof(SoapNonPositiveInteger);
        internal static Type typeofSoapNonNegativeInteger = typeof(SoapNonNegativeInteger);
        internal static Type typeofSoapNegativeInteger = typeof(SoapNegativeInteger);
        internal static Type typeofSoapAnyUri = typeof(SoapAnyUri);
        internal static Type typeofSoapQName = typeof(SoapQName);
        internal static Type typeofSoapNotation = typeof(SoapNotation);
        internal static Type typeofSoapNormalizedString = typeof(SoapNormalizedString);
        internal static Type typeofSoapToken = typeof(SoapToken);
        internal static Type typeofSoapLanguage = typeof(SoapLanguage);
        internal static Type typeofSoapName = typeof(SoapName);
        internal static Type typeofSoapIdrefs = typeof(SoapIdrefs);
        internal static Type typeofSoapEntities = typeof(SoapEntities);
        internal static Type typeofSoapNmtoken = typeof(SoapNmtoken);
        internal static Type typeofSoapNmtokens = typeof(SoapNmtokens);
        internal static Type typeofSoapNcName = typeof(SoapNcName);
        internal static Type typeofSoapId = typeof(SoapId);
        internal static Type typeofSoapIdref = typeof(SoapIdref);
        internal static Type typeofSoapEntity = typeof(SoapEntity);
        internal static Type typeofISoapXsd = typeof(ISoapXsd);
        internal static Type typeofObject = typeof(Object);
        internal static Type typeofSoapFault = typeof(SoapFault);               
        internal static Type typeofTypeArray = typeof(System.Type[]);
        internal static Type typeofIConstructionCallMessage = typeof(System.Runtime.Remoting.Activation.IConstructionCallMessage);
        internal static Type typeofIMethodCallMessage = typeof(System.Runtime.Remoting.Messaging.IMethodCallMessage);
        internal static Type typeofReturnMessage = typeof(System.Runtime.Remoting.Messaging.ReturnMessage);
        internal static Type typeofSystemVoid = typeof(void);
        internal static Type typeofInternalSoapMessage = typeof(InternalSoapMessage);       
        internal static Type typeofHeader = typeof(System.Runtime.Remoting.Messaging.Header);       
        internal static Type typeofMarshalByRefObject = typeof(System.MarshalByRefObject);       
        internal static Assembly urtAssembly = Assembly.GetAssembly(typeofString);
        internal static String urtAssemblyString = urtAssembly.FullName;
    }

        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\soapobjectreader.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
 /*============================================================
 **
 ** Class: ObjectReader
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: DeSerializes XML in SOAP Format into an an object graph
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Soap {

    using System;
    using System.IO;
    using System.Reflection;
    using System.Collections;
    using System.Text;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Metadata.W3cXsd2001;
    using System.Runtime.Remoting.Messaging;    
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Permissions;
    using System.Diagnostics;
    using System.Globalization;

    internal sealed class ObjectReader
    {

        // System.Serializer information
        internal ObjectIDGenerator m_idGenerator;
        internal Stream m_stream;
        internal ISurrogateSelector m_surrogates;
        internal StreamingContext m_context;
        internal ObjectManager m_objectManager;
        internal InternalFE formatterEnums;
        internal SerializationBinder m_binder;

        internal SoapHandler soapHandler; //Set from SoapHandler

        // Fake Top object and headers
        internal long topId = 0;
        internal SerStack topStack; // Stack for placing ProcessRecords if the top record cannot be serialized on the first pass.
        internal bool isTopObjectSecondPass = false;
        internal bool isTopObjectResolved = true;
        internal bool isHeaderHandlerCalled = false;
        internal Exception deserializationSecurityException = null;
        internal Object handlerObject = null;
        internal Object topObject;
        internal long soapFaultId;
        internal Header[] headers;
        internal Header[] newheaders;
        internal bool IsFakeTopObject = false;
        internal HeaderHandler handler;
        internal SerObjectInfoInit serObjectInfoInit = null;
        internal IFormatterConverter m_formatterConverter = null;

        // Stack of Object ParseRecords
        internal SerStack stack = new SerStack("ObjectReader Object Stack");

        // ValueType Fixup Stack
        internal SerStack valueFixupStack = new SerStack("ValueType Fixup Stack");

        // Generate Object Id's
        internal Hashtable objectIdTable = new Hashtable(25); // holds the keyId value from the XML input and associated internal Id
        internal long objectIds = 0;

        internal int paramPosition = 0; //Position of parameter if soap top fake record.

        internal int majorVersion = 0;
        internal int minorVersion = 0;

        internal String faultString = null;

        // GetType - eliminate redundant Type.GetType()
        //internal Hashtable typeTable = new Hashtable(10);     

        internal static SecurityPermission serializationPermission = new SecurityPermission(SecurityPermissionFlag.SerializationFormatter);
        private static FileIOPermission sfileIOPermission = new FileIOPermission(PermissionState.Unrestricted);

        
        internal ObjectReader(Stream stream, ISurrogateSelector selector, StreamingContext context, InternalFE formatterEnums, SerializationBinder binder)
        {
            InternalST.Soap( this, "Constructor ISurrogateSelector ",((selector == null)?"null selector ":"selector present"));                 

            if (stream==null)
            {
                throw new ArgumentNullException("stream", SoapUtil.GetResourceString("ArgumentNull_Stream"));
            }

            m_stream=stream;
            m_surrogates = selector;
            m_context = context;
            m_binder =  binder;
            this.formatterEnums = formatterEnums;

            InternalST.Soap( this, "Constructor formatterEnums.FEtopObject ",formatterEnums.FEtopObject);
            if (formatterEnums.FEtopObject != null) 
                IsFakeTopObject = true;
            else
                IsFakeTopObject = false;

            m_formatterConverter = new FormatterConverter();
        }


        private ObjectManager GetObjectManager() {
            new SecurityPermission(SecurityPermissionFlag.SerializationFormatter).Assert();
            return new ObjectManager(m_surrogates, m_context);
      }




        // Deserialize the stream into an object graph.
        internal Object Deserialize(HeaderHandler handler, ISerParser serParser)
        {

            InternalST.Soap( this, "Deserialize Entry handler", handler);

            if (serParser == null)
                throw new ArgumentNullException("serParser", String.Format(SoapUtil.GetResourceString("ArgumentNull_WithParamName"), serParser));


            deserializationSecurityException = null;
            try {
                serializationPermission.Demand();
            } catch(Exception e ) {
                deserializationSecurityException = e;
            }

            this.handler = handler;
            isTopObjectSecondPass = false;
            isHeaderHandlerCalled = false;

            if (handler != null)
                IsFakeTopObject = true;

            m_idGenerator = new ObjectIDGenerator();


            m_objectManager = GetObjectManager();

            serObjectInfoInit = new SerObjectInfoInit();
            objectIdTable.Clear();
            objectIds = 0;

            // Will call back to ParseObject, ParseHeader for each object found
            serParser.Run();

            if (handler != null)
            {
                InternalST.Soap( this, "Deserialize Fixup Before Delegate Invoke");         
                m_objectManager.DoFixups(); // Fixup for headers

                // Header handler isn't invoked until method name is known from body fake record
                // Except for SoapFault, in this case it is invoked below
                if (handlerObject == null)
                {
                    InternalST.Soap( this, "Deserialize Before SoapFault Delegate Invoke ");
                    handlerObject = handler(newheaders);
                    InternalST.Soap( this, "Deserialize after SoapFault Delegate Invoke");
                }


                // SoapFault creation Create a fake Pr for the handlerObject to use.
                // Create a member for the fake pr with name __fault;
                if ((soapFaultId > 0) && (handlerObject != null))
                {
                    InternalST.Soap( this, "Deserialize SoapFault ");
                    topStack = new SerStack("Top ParseRecords");                
                    ParseRecord pr = new ParseRecord();
                    pr.PRparseTypeEnum = InternalParseTypeE.Object;
                    pr.PRobjectPositionEnum = InternalObjectPositionE.Top;
                    pr.PRparseStateEnum = InternalParseStateE.Object;
                    pr.PRname = "Response";
                    topStack.Push(pr);
                    pr = new ParseRecord();
                    pr.PRparseTypeEnum = InternalParseTypeE.Member;
                    pr.PRobjectPositionEnum = InternalObjectPositionE.Child;
                    pr.PRmemberTypeEnum = InternalMemberTypeE.Field;
                    pr.PRmemberValueEnum = InternalMemberValueE.Reference;
                    pr.PRparseStateEnum = InternalParseStateE.Member;
                    pr.PRname = "__fault";
                    pr.PRidRef = soapFaultId;
                    topStack.Push(pr);
                    pr = new ParseRecord();
                    pr.PRparseTypeEnum = InternalParseTypeE.ObjectEnd;
                    pr.PRobjectPositionEnum = InternalObjectPositionE.Top;
                    pr.PRparseStateEnum = InternalParseStateE.Object;
                    pr.PRname = "Response";
                    topStack.Push(pr);
                    isTopObjectResolved = false;
                }
            }


            // Resolve fake top object if necessary
            if (!isTopObjectResolved)
            {
                //resolve top object
                InternalST.Soap( this, "Deserialize TopObject Second Pass");                
                isTopObjectSecondPass = true;
                topStack.Reverse();
                // The top of the stack now contains the fake record
                // When it is Parsed, the handler object will be substituted
                // for it in ParseObject.
                int topStackLength = topStack.Count();
                ParseRecord pr = null;
                for (int i=0; i<topStackLength; i++)
                {
                    pr = (ParseRecord)topStack.Pop();
                    Parse(pr);
                }
            }


            InternalST.Soap( this, "Deserialize Finished Parsing DoFixups");

            m_objectManager.DoFixups();

            if (topObject == null)
                throw new SerializationException(SoapUtil.GetResourceString("Serialization_TopObject"));

            //if topObject has a surrogate then the actual object may be changed during special fixup
            //So refresh it using topID.
            if (HasSurrogate(topObject)  && topId != 0)//Not yet resolved
                topObject = m_objectManager.GetObject(topId);

            if (topObject is IObjectReference) {
                topObject = ((IObjectReference)topObject).GetRealObject(m_context);
            }       

            InternalST.Soap( this, "Deserialize Exit ",topObject);

            m_objectManager.RaiseDeserializationEvent();

            if ((formatterEnums.FEtopObject != null) &&
                  (topObject is InternalSoapMessage))


            {
                // Convert InternalSoapMessage to SoapMessage           
                InternalST.Soap( this, "Deserialize SoapMessage Entry ");           

                InternalSoapMessage ismc = (InternalSoapMessage)topObject;
                ISoapMessage smc = (ISoapMessage)formatterEnums.FEtopObject;
                smc.MethodName = ismc.methodName;
                smc.XmlNameSpace = ismc.xmlNameSpace;
                smc.ParamNames = ismc.paramNames;
                smc.ParamValues = ismc.paramValues;
                smc.Headers = headers;
                topObject = smc;
                isTopObjectResolved = true;
                InternalST.Soap( this, "Deserialize SoapMessage Exit topObject ",topObject," method name ",smc.MethodName);                         
            }

            return topObject;
        }

        private bool HasSurrogate(object obj){
            if (m_surrogates == null)
                return false;
            ISurrogateSelector notUsed;
            return m_surrogates.GetSurrogate(obj.GetType(), m_context, out notUsed) != null;
        }

        internal ReadObjectInfo CreateReadObjectInfo(Type objectType, String assemblyName)
        {
            ReadObjectInfo objectInfo = ReadObjectInfo.Create(objectType, m_surrogates, m_context, m_objectManager, serObjectInfoInit, m_formatterConverter, assemblyName);
            objectInfo.SetVersion(majorVersion, minorVersion);
            return objectInfo;
        }

        internal ReadObjectInfo CreateReadObjectInfo(Type objectType, String[] memberNames, String assemblyName)
        {
            ReadObjectInfo objectInfo = ReadObjectInfo.Create(objectType, memberNames, null, m_surrogates, m_context, m_objectManager, serObjectInfoInit, m_formatterConverter, assemblyName);
            objectInfo.SetVersion(majorVersion, minorVersion);
            return objectInfo;
        }

        internal ReadObjectInfo CreateReadObjectInfo(Type objectType, String[] memberNames, Type[] memberTypes, String assemblyName)
        {
            ReadObjectInfo objectInfo = ReadObjectInfo.Create(objectType, memberNames, memberTypes, m_surrogates, m_context, m_objectManager, serObjectInfoInit, m_formatterConverter, assemblyName);
            objectInfo.SetVersion(majorVersion, minorVersion);
            return objectInfo;
        }


        // Main Parse routine, called by the XML Parse Handlers in XMLParser and also called internally to
        // parse the fake top object.
        internal void Parse(ParseRecord pr)
        {
            InternalST.Soap( this, "Parse Entry");
            stack.Dump();
            pr.Dump();

            switch(pr.PRparseTypeEnum)
            {
                case InternalParseTypeE.SerializedStreamHeader:
                    ParseSerializedStreamHeader(pr);
                    break;
                case InternalParseTypeE.SerializedStreamHeaderEnd:
                    ParseSerializedStreamHeaderEnd(pr);
                    break;                  
                case InternalParseTypeE.Object:
                    ParseObject(pr);
                    break;
                case InternalParseTypeE.ObjectEnd:
                    ParseObjectEnd(pr);
                    break;
                case InternalParseTypeE.Member:
                    ParseMember(pr);
                    break;
                case InternalParseTypeE.MemberEnd:
                    ParseMemberEnd(pr);
                    break;
                case InternalParseTypeE.Body:
                case InternalParseTypeE.BodyEnd:
                case InternalParseTypeE.Envelope:
                case InternalParseTypeE.EnvelopeEnd:
                    break;
                case InternalParseTypeE.Empty:
                default:
                    throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_XMLElement"), pr.PRname));                 

            }
        }

        // Styled ParseError output
        private void ParseError(ParseRecord processing, ParseRecord onStack)
        {
            InternalST.Soap( this, " ParseError ",processing," ",onStack);
            throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_ParseError"),onStack.PRname+" "+((Enum)onStack.PRparseTypeEnum).ToString()+" "+processing.PRname+" "+((Enum)processing.PRparseTypeEnum).ToString()));                              
        }

        // Parse the SerializedStreamHeader element. This is the first element in the stream if present
        private void ParseSerializedStreamHeader(ParseRecord pr)
        {
            InternalST.Soap( this, "SerializedHeader ",pr);
            stack.Push(pr);
        }

        // Parse the SerializedStreamHeader end element. This is the last element in the stream if present
        private void ParseSerializedStreamHeaderEnd(ParseRecord pr)
        {
            InternalST.Soap( this, "SerializedHeaderEnd ",pr);
            stack.Pop();
        }



        private bool IsRemoting {
            get {
                //return (m_context.State & (StreamingContextStates.Persistence|StreamingContextStates.File|StreamingContextStates.Clone)) == 0;
                return  IsFakeTopObject;
            }
        }
    
        private void CheckSecurity(ParseRecord pr)
         {
            InternalST.SoapAssert(pr!=null, "[BinaryObjectReader.CheckSecurity]pr!=null");
            Type t = pr.PRdtType;

            if (t != null){
                if(IsRemoting){
                    if (typeof(MarshalByRefObject).IsAssignableFrom(t))
                        throw new ArgumentException(String.Format(SoapUtil.GetResourceString("Serialization_MBRAsMBV"), t.FullName));
                    FormatterServices.CheckTypeSecurity(t, formatterEnums.FEsecurityLevel);
                }
            }

            //If we passed the security check, they can do whatever they'd like,
            //so we'll just short-circuit this.
            if (deserializationSecurityException==null) {
                return;
            }

            // BaseTypes and Array of basetypes allowed

            if (t != null)
            {
                if (t.IsPrimitive || t == Converter.typeofString)
                    return;

                if (typeof(Enum).IsAssignableFrom(t))
                    return;

                if (t.IsArray)
                {
                    Type type = t.GetElementType();
                    if (type.IsPrimitive || type == Converter.typeofString)
                        return;
                }
            }

            throw deserializationSecurityException;
        }

        // New object encountered in stream
        private void ParseObject(ParseRecord pr)
        {
            InternalST.Soap( this, "ParseObject Entry ");

            if (pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
                topId = pr.PRobjectId;

            if (pr.PRparseTypeEnum == InternalParseTypeE.Object)
            {
                InternalST.Soap( this, "ParseObject Push "+pr.PRname);
                stack.Push(pr); // Nested objects member names are already on stack
            }

            if (pr.PRobjectTypeEnum == InternalObjectTypeE.Array)
            {
                ParseArray(pr);
                InternalST.Soap( this, "ParseObject Exit, ParseArray ");
                return;
            }

            if ((pr.PRdtType == null) && !IsFakeTopObject)
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_TopObjectInstantiate"),pr.PRname));


            if (pr.PRobjectPositionEnum == InternalObjectPositionE.Top && IsFakeTopObject && pr.PRdtType != Converter.typeofSoapFault)
            {

                // Soap fake top object
                if (handler != null) 
                {
                    // Handler object will supply real top object
                    InternalST.Soap( this, "ParseObject FakeTopObject with handlerObject ");    

                    // Now know the method name, can call header handler 
                    //Create header for method name
                    if (!isHeaderHandlerCalled)
                    {
                        newheaders = null;
                        isHeaderHandlerCalled = true;
                        if (headers == null)
                        {
                            newheaders = new Header[1];
                        }
                        else
                        {
                            newheaders = new Header[headers.Length+1];
                            Array.Copy(headers, 0, newheaders, 1, headers.Length);
                        }

                        Header methodNameHeader = new Header("__methodName", pr.PRname, false, pr.PRnameXmlKey);
                        newheaders[0] = methodNameHeader;
                        InternalST.Soap( this, "Deserialize Before Delegate Invoke ");
                        handlerObject = handler(newheaders);

                        InternalST.Soap( this, "Deserialize after Delegate Invoke");
                        InternalST.Soap( this, "Deserialize delgate object ",((handlerObject == null)?"null":handlerObject));                   
                    }

                    if (isHeaderHandlerCalled)
                    {
                        // Handler object has supplied the real object for the fake object
                        // which is on top of the stack
                        pr.PRnewObj = handlerObject;
                        pr.PRdtType = handlerObject.GetType();
                        CheckSecurity(pr);
                        if (pr.PRnewObj is IFieldInfo)
                        {
                            IFieldInfo fi = (IFieldInfo)pr.PRnewObj;
                            if ((fi.FieldTypes != null) && (fi.FieldTypes.Length > 0))
                            {
                                pr.PRobjectInfo = CreateReadObjectInfo(pr.PRdtType, fi.FieldNames, fi.FieldTypes, pr.PRassemblyName);
                            }
                        }                       
                    }
                    else
                    {
                        // Handler object has not yet been asked for the real object
                        // Stack the parse record until the second pass
                        isTopObjectResolved = false;
                        topStack = new SerStack("Top ParseRecords");
                        InternalST.Soap( this, "ParseObject Handler Push "+pr.PRname);
                        topStack.Push(pr.Copy());
                        return;
                    }
                }
                else if (formatterEnums.FEtopObject != null)
                {
                    // SoapMessage will be used as the real object
                    InternalST.Soap( this, "ParseObject FakeTopObject with SoapMessage ");                                  
                    if (isTopObjectSecondPass)
                    {
                        // This creates a the SoapMessage object as the real object, at this point it is an unitialized object.
                        pr.PRnewObj = new InternalSoapMessage();
                        pr.PRdtType = typeof(InternalSoapMessage);
                        CheckSecurity(pr);
                        if (formatterEnums.FEtopObject != null)
                        {
                            ISoapMessage soapMessage = (ISoapMessage)formatterEnums.FEtopObject;
                            pr.PRobjectInfo = CreateReadObjectInfo(pr.PRdtType, soapMessage.ParamNames, soapMessage.ParamTypes, pr.PRassemblyName);
                        }
                    }
                    else
                    {
                        // Stack the parse record until the second pass
                        isTopObjectResolved = false;
                        topStack = new SerStack("Top ParseRecords");
                        topStack.Push(pr.Copy());
                        return;
                    }
                }
            }
            else if (pr.PRdtType == Converter.typeofString)
            {
                // String as a top level object
                if (pr.PRvalue != null)
                {
                    pr.PRnewObj = pr.PRvalue;
                    if (pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
                    {
                        InternalST.Soap( this, "ParseObject String as top level, Top Object Resolved");
                        isTopObjectResolved = true;
                        topObject = pr.PRnewObj;
                        //stack.Pop();
                        return;
                    }
                    else
                    {
                        InternalST.Soap( this, "ParseObject  String as an object");
                        stack.Pop();                        
                        RegisterObject(pr.PRnewObj, pr, (ParseRecord)stack.Peek());                         
                        return;
                    }
                }
                else
                {
                    // xml Doesn't have the value until later
                    return;
                }
            }
            else 
            {
                if (pr.PRdtType == null)
                {
                    ParseRecord objectPr = (ParseRecord)stack.Peek();
                    if (objectPr.PRdtType == Converter.typeofSoapFault)
                    {
                        InternalST.Soap( this, "ParseObject unknown SoapFault detail");
                        throw new ServerException(String.Format(SoapUtil.GetResourceString("Serialization_SoapFault"),faultString));                
                    }

                    throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_TypeElement"),pr.PRname));             
                }

                if (IsRemoting && formatterEnums.FEsecurityLevel != TypeFilterLevel.Full)
                    pr.PRnewObj = FormatterServices.GetSafeUninitializedObject(pr.PRdtType);                                 
                else
                    pr.PRnewObj = FormatterServices.GetUninitializedObject(pr.PRdtType);  
                
                CheckSecurity(pr);
            }

            if (pr.PRnewObj == null)
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_TopObjectInstantiate"),pr.PRdtType));              

            long genId = pr.PRobjectId;
            if (genId < 1)
                pr.PRobjectId = GetId("GenId-"+objectIds);


            if (IsFakeTopObject && pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
            {
                InternalST.Soap( this, "ParseObject fake Top object resolved ",pr.PRnewObj);
                isTopObjectResolved = true;
                topObject = pr.PRnewObj;
            }

            if (pr.PRobjectInfo == null)
                pr.PRobjectInfo = CreateReadObjectInfo(pr.PRdtType, pr.PRassemblyName);
            pr.PRobjectInfo.obj = pr.PRnewObj;

            if (IsFakeTopObject && pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
            {
                InternalST.Soap( this, "ParseObject AddValue to fake object ",pr.PRobjectInfo.obj);
                // Add the methodName to top object, either InternalSoapMessage or object returned by handler
                pr.PRobjectInfo.AddValue("__methodName", pr.PRname);
                pr.PRobjectInfo.AddValue("__keyToNamespaceTable", soapHandler.keyToNamespaceTable);
                pr.PRobjectInfo.AddValue("__paramNameList", pr.PRobjectInfo.SetFakeObject());
                if (formatterEnums.FEtopObject != null)
                    pr.PRobjectInfo.AddValue("__xmlNameSpace", pr.PRxmlNameSpace);
            }

            InternalST.Soap( this, "ParseObject Exit ");        
        }


        private bool IsWhiteSpace(String value)
        {
            for (int i=0; i<value.Length; i++)
            {
                if (value[i] == ' ' || value[i] == '\n' || value[i] == '\r')
                    continue;
                else
                    return false;
            }
            return true;
        }

        // End of object encountered in stream
        
        private void ParseObjectEnd(ParseRecord pr)
        {
            InternalST.Soap( this, "ParseObjectEnd Entry ",pr.Trace());
            ParseRecord objectPr = (ParseRecord)stack.Peek();
            if (objectPr == null)
                objectPr = pr;


            //BCLDebug.Assert(objectPr != null, "[System.Runtime.Serialization.Formatters.ParseObjectEnd]objectPr != null");

            InternalST.Soap( this, "ParseObjectEnd objectPr ",objectPr.Trace());

            if (objectPr.PRobjectPositionEnum == InternalObjectPositionE.Top) 
            {
                InternalST.Soap( this, "ParseObjectEnd Top Object dtType ",objectPr.PRdtType);
                if (objectPr.PRdtType == Converter.typeofString)
                {
                    InternalST.Soap( this, "ParseObjectEnd Top String");
                    if (objectPr.PRvalue == null)
                        objectPr.PRvalue = String.Empty; // Not a null object, but an empty string

                    objectPr.PRnewObj = objectPr.PRvalue;
                    CheckSecurity(objectPr);
                    isTopObjectResolved = true;
                    topObject = objectPr.PRnewObj;
                    return;
                }
                else if (objectPr.PRdtType != null  && objectPr.PRvalue != null && !IsWhiteSpace(objectPr.PRvalue) && (objectPr.PRdtType.IsPrimitive || objectPr.PRdtType == Converter.typeofTimeSpan))
                {
                    // When an xsd type is transmitted as a top level string <xsd:int>111</xsd:int>
                    objectPr.PRnewObj = Converter.FromString(objectPr.PRvalue, Converter.ToCode(objectPr.PRdtType));
                    CheckSecurity(objectPr);
                    isTopObjectResolved = true;
                    topObject = objectPr.PRnewObj;
                    return;

                }
                else if ((!isTopObjectResolved) && (objectPr.PRdtType != Converter.typeofSoapFault))
                {
                    InternalST.Soap( this, "ParseObjectEnd Top but not String");                    
                    // Need to keep top record on object stack until finished building top stack
                    topStack.Push(pr.Copy());
                    // Note this is PRparseRecordId and not objectId
                    if (objectPr.PRparseRecordId == pr.PRparseRecordId)
                    {
                        // This handles the case of top stack containing nested objects and
                        // referenced objects. If nested objects the objects are not placed
                        // on stack, only topstack. If referenced objects they are placed on
                        // stack and need to be popped.
                        stack.Pop();
                    }
                    return;
                }
            }

            stack.Pop();

            ParseRecord parentPr = (ParseRecord)stack.Peek();

            if (objectPr.PRobjectTypeEnum == InternalObjectTypeE.Array)
            {
                if (objectPr.PRobjectPositionEnum == InternalObjectPositionE.Top)
                {
                    InternalST.Soap( this, "ParseObjectEnd  Top Object (Array) Resolved");
                    isTopObjectResolved = true;
                    topObject = objectPr.PRnewObj;
                }

                InternalST.Soap( this, "ParseArray  RegisterObject ",objectPr.PRobjectId," ",objectPr.PRnewObj.GetType());
                RegisterObject(objectPr.PRnewObj, objectPr, parentPr);                  

                return;
            }

            if (objectPr.PRobjectInfo != null)
            {
                objectPr.PRobjectInfo.PopulateObjectMembers();
            }

            if (objectPr.PRnewObj == null)
            {
                if (objectPr.PRdtType == Converter.typeofString)
                {
                    InternalST.Soap( this, "ParseObjectEnd String ");
                    if (objectPr.PRvalue == null)
                        objectPr.PRvalue = String.Empty; // Not a null object, but an empty string
                    objectPr.PRnewObj = objectPr.PRvalue;
                    CheckSecurity(objectPr);
                }
                else
                    throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_ObjectMissing"),pr.PRname));               
            }

            // Registration is after object is populated
            if (!objectPr.PRisRegistered && objectPr.PRobjectId > 0)
            {
                InternalST.Soap( this, "ParseObjectEnd Register Object ",objectPr.PRobjectId," ",objectPr.PRnewObj.GetType());
                RegisterObject(objectPr.PRnewObj, objectPr, parentPr);
            }

            if (objectPr.PRisValueTypeFixup)
            {
                InternalST.Soap( this, "ParseObjectEnd  ValueTypeFixup ",objectPr.PRnewObj.GetType());
                ValueFixup fixup = (ValueFixup)valueFixupStack.Pop(); //Value fixup
                fixup.Fixup(objectPr, parentPr);  // Value fixup
            }

            if (objectPr.PRobjectPositionEnum == InternalObjectPositionE.Top)
            {
                InternalST.Soap( this, "ParseObjectEnd  Top Object Resolved ",objectPr.PRnewObj.GetType());
                isTopObjectResolved = true;
                topObject = objectPr.PRnewObj;
            }

            if (objectPr.PRnewObj is SoapFault)
                soapFaultId = objectPr.PRobjectId;

            if (objectPr.PRobjectInfo != null)
            {
                if (objectPr.PRobjectInfo.bfake && !objectPr.PRobjectInfo.bSoapFault)
                    objectPr.PRobjectInfo.AddValue("__fault", null); // need this because SerializationObjectInfo throws an exception if a name being referenced is missing

                objectPr.PRobjectInfo.ObjectEnd();
            }

            InternalST.Soap( this, "ParseObjectEnd  Exit ",objectPr.PRnewObj," id: ",objectPr.PRobjectId);      
        }



        // Array object encountered in stream
        private void ParseArray(ParseRecord pr)
        {
            InternalST.Soap( this, "ParseArray Entry");
            pr.Dump();

            long genId = pr.PRobjectId;
            if (genId < 1)
                pr.PRobjectId = GetId("GenId-"+objectIds);

            if ((pr.PRarrayElementType != null) && (pr.PRarrayElementType.IsEnum))
                pr.PRisEnum = true;

            if (pr.PRarrayTypeEnum == InternalArrayTypeE.Base64)
            {
                if (pr.PRvalue == null)
                {
                    pr.PRnewObj = new Byte[0];
                    CheckSecurity(pr);
                }
                else
                {
                    // Used for arrays of Base64 and also for a parameter of Base64
                    InternalST.Soap( this, "ParseArray bin.base64 ",pr.PRvalue.Length," ",pr.PRvalue);

                    if (pr.PRdtType == Converter.typeofSoapBase64Binary)
                    {
                        // Parameter - Case where the return type is a SoapENC:base64 but the parameter type is xsd:base64Binary
                        pr.PRnewObj = SoapBase64Binary.Parse(pr.PRvalue);
                        CheckSecurity(pr);
                    }
                    else
                    {
                        // ByteArray
                        if (pr.PRvalue.Length > 0)
                        {
                            pr.PRnewObj = Convert.FromBase64String(FilterBin64(pr.PRvalue));
                            CheckSecurity(pr);
                        }
                        else
                        {
                            pr.PRnewObj = new Byte[0];
                            CheckSecurity(pr);
                        }
                    }
                }

                if (stack.Peek() == pr)
                {
                    InternalST.Soap( this, "ParseArray, bin.base64 has been stacked");
                    stack.Pop();
                }
                if (pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
                {
                    InternalST.Soap( this, "ParseArray, bin.base64 Top Object");
                    topObject = pr.PRnewObj;
                    isTopObjectResolved = true;
                }

                ParseRecord parentPr = (ParseRecord)stack.Peek();                                           

                // Base64 can be registered at this point because it is populated
                InternalST.Soap( this, "ParseArray  RegisterObject ",pr.PRobjectId," ",pr.PRnewObj.GetType());
                RegisterObject(pr.PRnewObj, pr, parentPr);

            }
            else if ((pr.PRnewObj != null) && Converter.IsWriteAsByteArray(pr.PRarrayElementTypeCode))
            {
                // Primtive typed Array has already been read
                if (pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
                {
                    topObject = pr.PRnewObj;
                    isTopObjectResolved = true;
                }

                ParseRecord parentPr = (ParseRecord)stack.Peek();                                           

                // Primitive typed array can be registered at this point because it is populated
                InternalST.Soap( this, "ParseArray  RegisterObject ",pr.PRobjectId," ",pr.PRnewObj.GetType());
                RegisterObject(pr.PRnewObj, pr, parentPr);
            }
            else if ((pr.PRarrayTypeEnum == InternalArrayTypeE.Jagged) || (pr.PRarrayTypeEnum == InternalArrayTypeE.Single))
            {
                // Multidimensional jagged array or single array
                InternalST.Soap( this, "ParseArray Before Jagged,Simple create ",pr.PRarrayElementType," ",(pr.PRrank >0?pr.PRlengthA[0].ToString():"0"));
                if ((pr.PRlowerBoundA == null) || (pr.PRlowerBoundA[0] == 0))
                {
                    pr.PRnewObj = Array.CreateInstance(pr.PRarrayElementType, (pr.PRrank>0?pr.PRlengthA[0]:0));
                    pr.PRisLowerBound = false;
                }
                else
                {
                    pr.PRnewObj = Array.CreateInstance(pr.PRarrayElementType, pr.PRlengthA, pr.PRlowerBoundA);
                    pr.PRisLowerBound = true;
                }

                if (pr.PRarrayTypeEnum == InternalArrayTypeE.Single)
                {
                    if (!pr.PRisLowerBound && (Converter.IsWriteAsByteArray(pr.PRarrayElementTypeCode)))
                    {
                        pr.PRprimitiveArray = new PrimitiveArray(pr.PRarrayElementTypeCode, (Array)pr.PRnewObj);
                    }
                    else if (!pr.PRarrayElementType.IsValueType && pr.PRlowerBoundA== null)
		    {
                        pr.PRobjectA = (Object[])pr.PRnewObj;
		    }
                }
                CheckSecurity(pr);
                    
                InternalST.Soap( this, "ParseArray Jagged,Simple Array ",pr.PRnewObj.GetType());

                // For binary, headers comes in as an array of header objects
                if (pr.PRobjectPositionEnum == InternalObjectPositionE.Headers)
                {
                    InternalST.Soap( this, "ParseArray header array");
                    headers = (Header[])pr.PRnewObj;
                }

                pr.PRindexMap = new int[1];


            }
            else if (pr.PRarrayTypeEnum == InternalArrayTypeE.Rectangular)
            {
                // Rectangle array

                pr.PRisLowerBound = false;
                if (pr.PRlowerBoundA != null)
                {
                    for (int i=0; i<pr.PRrank; i++)
                    {
                        if (pr.PRlowerBoundA[i] != 0)
                            pr.PRisLowerBound  = true;
                    }
                }


                if (!pr.PRisLowerBound)
                    pr.PRnewObj = Array.CreateInstance(pr.PRarrayElementType, pr.PRlengthA);
                else
                    pr.PRnewObj = Array.CreateInstance(pr.PRarrayElementType, pr.PRlengthA, pr.PRlowerBoundA);
                CheckSecurity(pr);

                InternalST.Soap( this, "ParseArray Rectangle Array ",pr.PRnewObj.GetType()," lower Bound ",pr.PRisLowerBound);

                // Calculate number of items
                int sum = 1;
                for (int i=0; i<pr.PRrank; i++)
                {
                    sum = sum*pr.PRlengthA[i];
                }
                pr.PRindexMap = new int[pr.PRrank];
                pr.PRrectangularMap = new int[pr.PRrank];
                pr.PRlinearlength = sum;
            }
            else
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_ArrayType"),((Enum)pr.PRarrayTypeEnum).ToString()));                               

            InternalST.Soap( this, "ParseArray Exit");      
        }


        // Builds a map for each item in an incoming rectangle array. The map specifies where the item is placed in the output Array Object

        private void NextRectangleMap(ParseRecord pr)
        {
            // For each invocation, calculate the next rectangular array position
            // example
            // indexMap 0 [0,0,0]
            // indexMap 1 [0,0,1]
            // indexMap 2 [0,0,2]
            // indexMap 3 [0,0,3]
            // indexMap 4 [0,1,0]       
            for (int irank = pr.PRrank-1; irank>-1; irank--)
            {
                // Find the current or lower dimension which can be incremented.
                if (pr.PRrectangularMap[irank] < pr.PRlengthA[irank]-1)
                {
                    // The current dimension is at maximum. Increase the next lower dimension by 1
                    pr.PRrectangularMap[irank]++;
                    if (irank < pr.PRrank-1)
                    {
                        // The current dimension and higher dimensions are zeroed.
                        for (int i = irank+1; i<pr.PRrank; i++)
                            pr.PRrectangularMap[i] = 0;
                    }
                    Array.Copy(pr.PRrectangularMap, pr.PRindexMap, pr.PRrank);              
                    break;                  
                }

            }
        }


        // Array object item encountered in stream
        private void ParseArrayMember(ParseRecord pr)
        {
            InternalST.Soap( this, "ParseArrayMember Entry");
            ParseRecord objectPr = (ParseRecord)stack.Peek();

            // Set up for inserting value into correct array position
	    // cli metadata, offset can appear on the array type to represent lowerbound.
	    // Position can appear only on the member.
	    // If the position appears, it specifies the absolute position of the item in the array. The next array member
	    //    continues after the position.

            if (objectPr.PRarrayTypeEnum == InternalArrayTypeE.Rectangular)
            {
		if (pr.PRpositionA != null)
		{
		    Array.Copy(pr.PRpositionA, objectPr.PRindexMap, objectPr.PRindexMap.Length);
		    if (objectPr.PRlowerBoundA == null)
			Array.Copy(pr.PRpositionA, objectPr.PRrectangularMap, objectPr.PRrectangularMap.Length);
		    else
		    {
			// have to subtract away the offset form the position, since the position includes the offset
			// but the PRrectangularMap is the index position without the offset
			for (int i=0; i<objectPr.PRrectangularMap.Length; i++)
			{
			    objectPr.PRrectangularMap[i] = pr.PRpositionA[i] - objectPr.PRlowerBoundA[i];
			}
		    }
		}
                else 
		{
		    if (objectPr.PRmemberIndex > 0)
			NextRectangleMap(objectPr); // Rectangle array, calculate position in array
			
		    for (int i=0; i<objectPr.PRrank; i++)
		    {
			int objectOffset = 0;
			if (objectPr.PRlowerBoundA != null)
			    objectOffset = objectPr.PRlowerBoundA[i];
			objectPr.PRindexMap[i] = objectPr.PRrectangularMap[i] + objectOffset;
		    }
                }
            }
            else
            {
                if (!objectPr.PRisLowerBound)
                {
                    if (pr.PRpositionA == null)
                        objectPr.PRindexMap[0] = objectPr.PRmemberIndex; // Zero based array
                    else
                        objectPr.PRindexMap[0] = objectPr.PRmemberIndex= pr.PRpositionA[0]; // item position specified in SOAP stream
                }
                else
		{
		    if (pr.PRpositionA == null)
			objectPr.PRindexMap[0] = objectPr.PRmemberIndex + objectPr.PRlowerBoundA[0]; //item position specifed by SoapEnc.Offset
		    else
		    {
                        objectPr.PRindexMap[0] = pr.PRpositionA[0]; // item position specified in SOAP stream
			objectPr.PRmemberIndex = pr.PRpositionA[0] - objectPr.PRlowerBoundA[0]; //memberIndex does not contain offset, but position does.
		    }

		}
            }
            IndexTraceMessage("ParseArrayMember isLowerBound "+objectPr.PRisLowerBound+" indexMap  ", objectPr.PRindexMap);     

            // Set Array element according to type of element

            if (pr.PRmemberValueEnum == InternalMemberValueE.Reference)
            {
                // Object Reference

                // See if object has already been instantiated
                Object refObj = m_objectManager.GetObject(pr.PRidRef);
                if (refObj == null)
                {
                    // Object not instantiated
                    // Array fixup manager
                    IndexTraceMessage("ParseArrayMember Record Fixup  "+objectPr.PRnewObj.GetType(), objectPr.PRindexMap);
                    int[] fixupIndex = new int[objectPr.PRrank];
                    Array.Copy(objectPr.PRindexMap, 0, fixupIndex, 0, objectPr.PRrank);

                    InternalST.Soap( this, "ParseArrayMember RecordArrayElementFixup objectId ",objectPr.PRobjectId," idRef ",pr.PRidRef);                                                          
                    m_objectManager.RecordArrayElementFixup(objectPr.PRobjectId, fixupIndex, pr.PRidRef);
                }
                else
                {
                    IndexTraceMessage("ParseArrayMember SetValue ObjectReference "+objectPr.PRnewObj.GetType()+" "+refObj, objectPr.PRindexMap);
                    if (objectPr.PRobjectA != null)
                        objectPr.PRobjectA[objectPr.PRindexMap[0]] = refObj;
                    else
                        ((Array)objectPr.PRnewObj).SetValue(refObj, objectPr.PRindexMap); // Object has been instantiated
                }
            }
            else if (pr.PRmemberValueEnum == InternalMemberValueE.Nested)
            {
                //Set up dtType for ParseObject
                InternalST.Soap( this, "ParseArrayMember Nested ");
                if (pr.PRdtType == null)
                {
                    pr.PRdtType = objectPr.PRarrayElementType;
                }

                ParseObject(pr);

                InternalST.Soap( "ParseArrayMember Push object "+pr.PRname);
                stack.Push(pr);

                if ((objectPr.PRarrayElementType.IsValueType) && (pr.PRarrayElementTypeCode == InternalPrimitiveTypeE.Invalid))
                {
                    InternalST.Soap( "ParseArrayMember ValueType ObjectPr ",objectPr.PRnewObj," index ",objectPr.PRmemberIndex);
                    pr.PRisValueTypeFixup = true; //Valuefixup
                    valueFixupStack.Push(new ValueFixup((Array)objectPr.PRnewObj, objectPr.PRindexMap)); //valuefixup
                }
                else
                {
                    InternalST.Soap( "ParseArrayMember SetValue Nested, memberIndex ",objectPr.PRmemberIndex);
                    IndexTraceMessage("ParseArrayMember SetValue Nested ContainerObject "+objectPr.PRnewObj.GetType()+" "+objectPr.PRnewObj+" item Object "+pr.PRnewObj+" index ", objectPr.PRindexMap);

                    stack.Dump();               
                    InternalST.Soap( "ParseArrayMember SetValue Nested ContainerObject objectPr ",objectPr.Trace());
                    InternalST.Soap( "ParseArrayMember SetValue Nested ContainerObject pr ",pr.Trace());

                    if (objectPr.PRobjectA != null)
                        objectPr.PRobjectA[objectPr.PRindexMap[0]] = pr.PRnewObj;
                    else
                        ((Array)objectPr.PRnewObj).SetValue(pr.PRnewObj, objectPr.PRindexMap);
                }
            }
            else if (pr.PRmemberValueEnum == InternalMemberValueE.InlineValue)
            {
                if (objectPr.PRarrayElementType == Converter.typeofString)
                {
                    // String
                    ParseString(pr, objectPr);
                    IndexTraceMessage("ParseArrayMember SetValue String "+objectPr.PRnewObj.GetType()+" "+pr.PRvalue, objectPr.PRindexMap);
                    if (objectPr.PRobjectA != null)
                        objectPr.PRobjectA[objectPr.PRindexMap[0]] = (Object)pr.PRvalue;
                    else
                        ((Array)objectPr.PRnewObj).SetValue((Object)pr.PRvalue, objectPr.PRindexMap);
                }
                else if (objectPr.PRisEnum)
                {
                            // Soap sends Enums as strings
                    Object var = Enum.Parse(objectPr.PRarrayElementType, pr.PRvalue);
                    if (objectPr.PRobjectA != null)
                        objectPr.PRobjectA[objectPr.PRindexMap[0]] = (Enum)var;
                    else
                        ((Array)objectPr.PRnewObj).SetValue((Enum)var, objectPr.PRindexMap);                    
                    InternalST.Soap( this, "ParseArrayMember Enum 1");
                }
                else if (objectPr.PRisArrayVariant)
                {
                    // Array of type object
                    if (pr.PRdtType == null && pr.PRkeyDt == null)
                        throw new SerializationException(SoapUtil.GetResourceString("Serialization_ArrayTypeObject"));

                    Object var = null;

                    if (pr.PRdtType == Converter.typeofString)
                    {
                        ParseString(pr, objectPr);
                        var = pr.PRvalue;
                    }
                    else if (pr.PRdtType.IsEnum)
                    {
                            // Soap sends Enums as strings
                        var = Enum.Parse(pr.PRdtType, pr.PRvalue);
                        InternalST.Soap( this, "ParseArrayMember Enum 2");
                    }
                    else if (pr.PRdtTypeCode == InternalPrimitiveTypeE.Invalid)
                    {
                        // Not nested and invalid, so it is an empty object
                        if (IsRemoting && formatterEnums.FEsecurityLevel != TypeFilterLevel.Full)
                            var = FormatterServices.GetSafeUninitializedObject(pr.PRdtType);                                 
                        else
                            var = FormatterServices.GetUninitializedObject(pr.PRdtType);                          
                    }
                    else 
                    {
                        if (pr.PRvarValue != null)
                            var = pr.PRvarValue;
                        else
                            var = Converter.FromString(pr.PRvalue, pr.PRdtTypeCode);
                    }
                    IndexTraceMessage("ParseArrayMember SetValue variant or Object "+objectPr.PRnewObj.GetType()+" var "+var+" indexMap ", objectPr.PRindexMap);
                    if (objectPr.PRobjectA != null)
                        objectPr.PRobjectA[objectPr.PRindexMap[0]] = var;
                    else
                        ((Array)objectPr.PRnewObj).SetValue(var, objectPr.PRindexMap); // Primitive type
                }
                else
                {
                    // Primitive type
                    if (objectPr.PRprimitiveArray != null)
                    {
                        // Fast path for Soap primitive arrays. Binary was handled in the BinaryParser
                        objectPr.PRprimitiveArray.SetValue(pr.PRvalue, objectPr.PRindexMap[0]);
                    }
                    else
                    {

                        Object var = null;
                        if (pr.PRvarValue != null)
                            var = pr.PRvarValue;
                        else
                            var = Converter.FromString(pr.PRvalue, objectPr.PRarrayElementTypeCode);

                        if (objectPr.PRarrayElementTypeCode == InternalPrimitiveTypeE.QName)
                        {
                            InternalST.Soap( this, "ParseArrayMember Primitive QName");
                            SoapQName soapQName = (SoapQName)var;
                            if (soapQName.Key.Length == 0)
                                soapQName.Namespace = (String)soapHandler.keyToNamespaceTable["xmlns"];
                            else
                                soapQName.Namespace = (String)soapHandler.keyToNamespaceTable["xmlns"+":"+soapQName.Key];
                        }

                        InternalST.Soap( this, "ParseArrayMember SetValue Primitive pr.PRvalue "+var," elementTypeCode ",((Enum)objectPr.PRdtTypeCode).ToString());
                        IndexTraceMessage("ParseArrayMember SetValue Primitive "+objectPr.PRnewObj.GetType()+" var: "+var+" varType "+var.GetType(), objectPr.PRindexMap);
                        if (objectPr.PRobjectA != null)
                            objectPr.PRobjectA[objectPr.PRindexMap[0]] = var;
                        else
                            ((Array)objectPr.PRnewObj).SetValue(var, objectPr.PRindexMap); // Primitive type   
                        InternalST.Soap( this, "ParseArrayMember SetValue Primitive after");
                    }
                }
            }
            else if (pr.PRmemberValueEnum == InternalMemberValueE.Null)
            {
                InternalST.Soap( "ParseArrayMember Null item ",pr.PRmemberIndex);
            }
            else
                ParseError(pr, objectPr);

            InternalST.Soap( "ParseArrayMember increment memberIndex ",objectPr.PRmemberIndex," ",objectPr.Trace());                
            objectPr.PRmemberIndex++;
            InternalST.Soap( "ParseArrayMember Exit");      
        }

        private void ParseArrayMemberEnd(ParseRecord pr)
        {
            InternalST.Soap( this, "ParseArrayMemberEnd");
            // If this is a nested array object, then pop the stack
            if (pr.PRmemberValueEnum == InternalMemberValueE.Nested)
            {
                ParseObjectEnd(pr);
            }
        }


        // Object member encountered in stream
        private void ParseMember(ParseRecord pr)
        {
            InternalST.Soap( this, "ParseMember Entry ");


            ParseRecord objectPr = (ParseRecord)stack.Peek();
            String objName = null;
            if (objectPr != null)
                objName = objectPr.PRname;
                
            InternalST.Soap( this, "ParseMember ",objectPr.PRobjectId," ",pr.PRname);
            InternalST.Soap( this, "ParseMember objectPr ",objectPr.Trace());
            InternalST.Soap( this, "ParseMember pr ",pr.Trace());

            if (objectPr.PRdtType == Converter.typeofSoapFault && pr.PRname.ToLower(CultureInfo.InvariantCulture) == "faultstring")
                faultString = pr.PRvalue; // Save fault string in case rest of SoapFault cannot be parsed


            if ((objectPr.PRobjectPositionEnum == InternalObjectPositionE.Top) && !isTopObjectResolved)
            {
                InternalST.Soap( this, "ParseMember Top not resolved");
                if (pr.PRdtType == Converter.typeofString)
                {
                    ParseString(pr, objectPr);
                }
                topStack.Push(pr.Copy());
                return;
            }

            switch(pr.PRmemberTypeEnum)
            {
                case InternalMemberTypeE.Item:
                    ParseArrayMember(pr);
                    return;
                case InternalMemberTypeE.Field:
                    break;
            }
            

            if (objectPr.PRobjectInfo != null)
                objectPr.PRobjectInfo.AddMemberSeen();

            bool bParams = (IsFakeTopObject &&
                    objectPr.PRobjectPositionEnum == InternalObjectPositionE.Top && 
                    objectPr.PRobjectInfo != null && objectPr.PRdtType != Converter.typeofSoapFault);

            if ((pr.PRdtType == null) && objectPr.PRobjectInfo.isTyped)         
            {
                InternalST.Soap( this, "ParseMember pr.PRdtType null and not isSi");

                if (bParams)
                {
                    // Get type of parameters
                    InternalST.Soap( this, "ParseMember pr.PRdtType Get Param Type position "+paramPosition+" name "+pr.PRname);    
                    pr.PRdtType = objectPr.PRobjectInfo.GetType(paramPosition++);
                    InternalST.Soap( this, "ParseMember pr.PRdtType Get Param Type Type "+pr.PRdtType);
                }
                else
                    pr.PRdtType = objectPr.PRobjectInfo.GetType(pr.PRname);

                if (pr.PRdtType == null)
                    throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_TypeResolved"), objectPr.PRnewObj+" "+pr.PRname));

                pr.PRdtTypeCode = Converter.ToCode(pr.PRdtType);
            }
            else
            {
                if (bParams)
                {
                    paramPosition++;
                }
            }


            if (pr.PRmemberValueEnum == InternalMemberValueE.Null)
            {
                // Value is Null
                InternalST.Soap( this, "ParseMember null member: ",pr.PRname);
                InternalST.Soap( this, "AddValue 1");
                objectPr.PRobjectInfo.AddValue(pr.PRname, null);
            }
            else if (pr.PRmemberValueEnum == InternalMemberValueE.Nested)
            {
                InternalST.Soap( this, "ParseMember Nested Type member: ",pr.PRname," objectPr.PRnewObj ",objectPr.PRnewObj);
                ParseObject(pr);
                InternalST.Soap( "ParseMember Push object "+pr.PRname);
                stack.Push(pr);
                InternalST.Soap( this, "AddValue 2 ",pr.PRnewObj," is value type ",pr.PRnewObj.GetType().IsValueType);

                if ((pr.PRobjectInfo != null) && (pr.PRobjectInfo.objectType.IsValueType))
                {
                    InternalST.Soap( "ParseMember ValueType ObjectPr ",objectPr.PRnewObj," memberName  ",pr.PRname," nested object ",pr.PRnewObj);
                    if (IsFakeTopObject)
                        objectPr.PRobjectInfo.AddParamName(pr.PRname);
                    
                    pr.PRisValueTypeFixup = true; //Valuefixup
                    valueFixupStack.Push(new ValueFixup(objectPr.PRnewObj, pr.PRname, objectPr.PRobjectInfo));//valuefixup
                }
                else
                {
                    InternalST.Soap( this, "AddValue 2A ");
                    objectPr.PRobjectInfo.AddValue(pr.PRname, pr.PRnewObj);
                }
            }
            else if (pr.PRmemberValueEnum == InternalMemberValueE.Reference)
            {
                InternalST.Soap( this, "ParseMember Reference Type member: ",pr.PRname);            
                // See if object has already been instantiated
                Object refObj = m_objectManager.GetObject(pr.PRidRef);
                if (refObj == null)
                {
                    InternalST.Soap( this, "ParseMember RecordFixup: ",pr.PRname);
                    InternalST.Soap( this, "AddValue 3");                   
                    objectPr.PRobjectInfo.AddValue(pr.PRname, null);                    
                    objectPr.PRobjectInfo.RecordFixup(objectPr.PRobjectId, pr.PRname, pr.PRidRef); // Object not instantiated
                }
                else
                {
                    InternalST.Soap( this, "ParseMember Referenced Object Known ",pr.PRname," ",refObj);
                    InternalST.Soap( this, "AddValue 5");               
                    objectPr.PRobjectInfo.AddValue(pr.PRname, refObj);
                }
            }

            else if (pr.PRmemberValueEnum == InternalMemberValueE.InlineValue) 
            {
                // Primitive type or String
                InternalST.Soap( this, "ParseMember primitive or String member: ",pr.PRname);

                if (pr.PRdtType == Converter.typeofString)
                {
                    ParseString(pr, objectPr);
                    InternalST.Soap( this, "AddValue 6");               
                    objectPr.PRobjectInfo.AddValue(pr.PRname, pr.PRvalue);  
                }
                else if (pr.PRdtTypeCode == InternalPrimitiveTypeE.Invalid)
                {
                    // The member field was an object put the value is Inline either  bin.Base64 or invalid
                    if (pr.PRarrayTypeEnum == InternalArrayTypeE.Base64)
                    {
                        InternalST.Soap( this, "AddValue 7");                   
                        objectPr.PRobjectInfo.AddValue(pr.PRname, Convert.FromBase64String(FilterBin64(pr.PRvalue)));                                   
                    }
                    else if (pr.PRdtType == Converter.typeofObject && pr.PRvalue != null) 
                    {
                        if (objectPr != null && objectPr.PRdtType == Converter.typeofHeader)
                        {
                            // assume the type is a string for a header
                            pr.PRdtType = Converter.typeofString;
                            ParseString(pr, objectPr);
                            InternalST.Soap( this, "AddValue 6");               
                            objectPr.PRobjectInfo.AddValue(pr.PRname, pr.PRvalue);  
                        }
                        else
                            throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_TypeMissing"), pr.PRname));
                    }
                    else
                    {
                        InternalST.Soap( this, "Object Class with no memberInfo data  Member "+pr.PRname+" type "+pr.PRdtType);

                        if (pr.PRdtType != null && pr.PRdtType.IsEnum)
                        {
                            // Soap sends Enums as strings
                            Object obj = Enum.Parse(pr.PRdtType, pr.PRvalue);
                            InternalST.Soap( this, "AddValue 8");                           
                            objectPr.PRobjectInfo.AddValue(pr.PRname, obj);                         
                        }
                        else if (pr.PRdtType != null && pr.PRdtType == Converter.typeofTypeArray)
                        {
                            // Soap sends MethodSignature as an array of types
                            InternalST.Soap( this, "AddValue 8A");                          
                            objectPr.PRobjectInfo.AddValue(pr.PRname, pr.PRvarValue);                                                       
                        }
                        else
                        {
                            if  ((!pr.PRisRegistered) && (pr.PRobjectId > 0))
                            {
                                if (pr.PRvalue == null)
                                    pr.PRvalue = ""; //can't register null value, this must be a string so set to empty string.

                                InternalST.Soap( this, "ParseMember RegisterObject ",pr.PRvalue," ",pr.PRobjectId);                         
                                RegisterObject(pr.PRvalue, pr, objectPr);
                            }

                            // Object Class with no memberInfo data
                            // is this the only special case where AddValue is needed?
                            if (pr.PRdtType == Converter.typeofSystemVoid)
                            {
                                InternalST.Soap( this, "AddValue 9");
                                objectPr.PRobjectInfo.AddValue(pr.PRname, pr.PRdtType);
                            }
                            else if (objectPr.PRobjectInfo.isSi)
                            {
                                // ISerializable are added as strings, the conversion to type is done by the
                                // ISerializable object
                                InternalST.Soap( this, "AddValue 10");
                                objectPr.PRobjectInfo.AddValue(pr.PRname, pr.PRvalue);                          
                            }
                        }
                    }
                }
                else
                {
                    Object var = null;
                    if (pr.PRvarValue != null)
                        var = pr.PRvarValue;
                    else
                        var = Converter.FromString(pr.PRvalue, pr.PRdtTypeCode);
                    // Not a string, convert the value
                    InternalST.Soap( this, "ParseMember Converting primitive and storing");
                    stack.Dump();
                    InternalST.Soap( this, "ParseMember pr "+pr.Trace());
                    InternalST.Soap( this, "ParseMember objectPr ",objectPr.Trace());

                    InternalST.Soap( this, "AddValue 11");  
                    if (pr.PRdtTypeCode == InternalPrimitiveTypeE.QName && var != null)
                    {
                        SoapQName soapQName = (SoapQName)var;
                        if (soapQName.Key != null)
                        {
                            if (soapQName.Key.Length == 0)
                                soapQName.Namespace = (String)soapHandler.keyToNamespaceTable["xmlns"];
                            else
                                soapQName.Namespace = (String)soapHandler.keyToNamespaceTable["xmlns"+":"+soapQName.Key];
                        }
                    }
                    objectPr.PRobjectInfo.AddValue(pr.PRname, var);             
                }
            }
            else
                ParseError(pr, objectPr);
        }

        // Object member end encountered in stream
        private void ParseMemberEnd(ParseRecord pr)
        {
            InternalST.Soap( this, "ParseMemberEnd");
            switch(pr.PRmemberTypeEnum)
            {
                case InternalMemberTypeE.Item:
                    ParseArrayMemberEnd(pr);
                    return;
                case InternalMemberTypeE.Field:
                    if (pr.PRmemberValueEnum == InternalMemberValueE.Nested)
                        ParseObjectEnd(pr);
                    break;
                default:
                    if (pr.PRmemberValueEnum == InternalMemberValueE.Nested)
                        ParseObjectEnd(pr);
                    else
                        ParseError(pr, (ParseRecord)stack.Peek());
                    break;
            }
        }

        // Processes a string object by getting an internal ID for it and registering it with the objectManager
        private void ParseString(ParseRecord pr, ParseRecord parentPr)
        {
            InternalST.Soap( this, "ParseString Entry ",pr.PRobjectId," ",pr.PRvalue," ",pr.PRisRegistered);

            // If there is a string and it wasn't marked as a null object, then it is an empty string
            if (pr.PRvalue == null)
                pr.PRvalue = ""; 

            // Process String class
            if  ((!pr.PRisRegistered) && (pr.PRobjectId > 0))
            {
                InternalST.Soap( this, "ParseString  RegisterObject ",pr.PRvalue," ",pr.PRobjectId);                            
                // String is treated as an object if it has an id
                //m_objectManager.RegisterObject(pr.PRvalue, pr.PRobjectId);
                RegisterObject(pr.PRvalue, pr, parentPr);
            }
        }


        private void RegisterObject(Object obj, ParseRecord pr, ParseRecord objectPr)
        {
            if (!pr.PRisRegistered)
            {
                pr.PRisRegistered = true;

                SerializationInfo si = null;
                long parentId = 0;
                MemberInfo memberInfo = null;
                int[] indexMap = null;

                if (objectPr != null)
                {
                    indexMap = objectPr.PRindexMap;
                    parentId = objectPr.PRobjectId;                 

                    if (objectPr.PRobjectInfo != null)
                    {
                        if (!objectPr.PRobjectInfo.isSi)
                        {
                            // ParentId is only used if there is a memberInfo
                            InternalST.Soap( this, "RegisterObject GetMemberInfo parent ",objectPr.PRobjectInfo.objectType," name looking for ", pr.PRname," field obj "+obj); 
                            memberInfo = objectPr.PRobjectInfo.GetMemberInfo(pr.PRname);
                        }
                    }
                }
                if (pr.PRobjectInfo != null)
                {
                    // SerializationInfo is always needed for ISerialization                        
                    si = pr.PRobjectInfo.si;
                }

                InternalST.Soap( this, "RegisterObject 0bj ",obj," objectId ",pr.PRobjectId," si ", si," parentId ",parentId," memberInfo ",memberInfo, " indexMap "+indexMap);
                m_objectManager.RegisterObject(obj, pr.PRobjectId, si, parentId, memberInfo, indexMap); 
            }
        }


        internal void SetVersion(int major, int minor)
        {
            // Don't do version checking if property is set to Simple
            if (formatterEnums.FEassemblyFormat != FormatterAssemblyStyle.Simple)
            {
                this.majorVersion = major;
                this.minorVersion = minor;
            }
        }


        // Assigns an internal ID associated with the xml id attribute

        String inKeyId = null;
        long outKeyId = 0;      
        internal long GetId(String keyId)
        {
            if (keyId == null)
                throw new ArgumentNullException("keyId", String.Format(SoapUtil.GetResourceString("ArgumentNull_WithParamName"), "keyId"));

            if (keyId != inKeyId)
            {               
                inKeyId = keyId;
                String idString = null;
                InternalST.Soap( this, "GetId Entry ",keyId);
                if (keyId[0] == '#')
                    idString = keyId.Substring(1);
                else
                    idString = keyId;

                Object idObj = objectIdTable[idString];
                if (idObj == null)
                {
                    outKeyId = ++objectIds;
                    objectIdTable[idString] = outKeyId;
                    InternalST.Soap( this, "GetId Exit new ID ",outKeyId);
                }
                else
                {
                    InternalST.Soap( this, "GetId Exit oldId ",(Int64)idObj);           
                    outKeyId =  (Int64)idObj;
                }
            }
            InternalST.Soap( this, "GetId  in id ",keyId, " out id ", outKeyId);
            return outKeyId;
        }

        // Assigns an internal ID associated with the binary id number

        long inId = 0;
        long outId = 0;
        internal long GetId(long objectId)
        {
            if (inId != objectId)
            {

                inId = objectId;
                Object idObj = null;
                if (objectId > 0)
                    idObj = objectIdTable[objectId];
                if (idObj == null)          
                {
                    outId = ++objectIds;
                    objectIdTable[objectId] = outId;
                    InternalST.Soap( this, "GetId Exit new ID ",outId);
                }
                else
                {
                    InternalST.Soap( this, "GetId Exit oldId ",(Int64)idObj);           
                    outId = (Int64)idObj;
                }
            }
            return outId;
        }


        // Trace which includes a single dimensional int array
        [Conditional("SER_LOGGING")]                        
        private void IndexTraceMessage(String message, int[] index)
        {
            StringBuilder sb = new StringBuilder(10);
            sb.Append("[");     
            for (int i=0; i<index.Length; i++)
            {
                sb.Append(index[i]);
                if (i != index.Length -1)
                    sb.Append(",");
            }
            sb.Append("]");             
            InternalST.Soap( this, message," ",sb.ToString());
        }

        internal Assembly LoadAssemblyFromString(String assemblyString)
        {
            Assembly assm = null;
            if(formatterEnums.FEassemblyFormat == FormatterAssemblyStyle.Simple) {
                try {
                    sfileIOPermission.Assert();
                    try {                    
                        assm  = Assembly.LoadWithPartialName(assemblyString);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
                catch(Exception e){
                    InternalST.Soap( this, "Error loading ",assemblyString, e.ToString());
                }
            }
            else {
                try
                {
                    sfileIOPermission.Assert();
                    try {                    
                        assm = Assembly.Load(assemblyString);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
                catch (Exception e)
                {
                    InternalST.Soap( this, "Error loading ",assemblyString, e.ToString());
                }
            }

            return assm;
        }

        internal Type Bind(String assemblyString, String typeString)
        {
            Type type = null;
            if (m_binder != null && !IsInternalType(assemblyString, typeString))
                type = m_binder.BindToType(assemblyString, typeString);
            return type;
        }

        private bool IsInternalType(string assemblyString, string typeString){
            return (assemblyString == Converter.urtAssemblyString) &&
                   ((typeString == "System.DelegateSerializationHolder") ||
                    (typeString == "System.UnitySerializationHolder") ||
                    (typeString == "System.MemberInfoSerializationHolder"));
        }
        
        internal class TypeNAssembly
        {
            public Type type;
            public String assemblyName;
        }

        NameCache typeCache = new NameCache();
        internal Type FastBindToType(String assemblyName, String typeName)
        {
            Type type = null;

            TypeNAssembly entry = (TypeNAssembly)typeCache.GetCachedValue(typeName);

            if (entry == null || entry.assemblyName != assemblyName)
            {
                Assembly assm = LoadAssemblyFromString(assemblyName);
                if (assm == null)
                    return null;

                type = FormatterServices.GetTypeFromAssembly(assm, typeName);

                if (type == null)
                    return null;

                entry = new TypeNAssembly();
                entry.type = type;
                entry.assemblyName = assemblyName;
                typeCache.SetCachedValue(entry);
            }
           return entry.type;
        }

        /*
        static Hashtable typeNames = new Hashtable();
        static int s_numEntries = 0;
        private const int MAX_CACHE_ENTRIES = 128; // No data gathered to arrive at this number !

        internal Type FastBindToType(String assemblyName, String typeName)
        {
            TypeNAssembly match = (TypeNAssembly)typeNames[typeName];
            if (match == null)
            {
                match = new TypeNAssembly();
                Assembly assm = null;
                try
                {
                    assm = Assembly.Load(assemblyName);
                }
                catch (Exception)
                {
                    return null;
                }

                if (assm == null)
                    return null;

                match.type = FormatterServices.GetTypeFromAssembly(assm, typeName);
                if (match.type == null)
                    return null;

                match.assemblyName = assemblyName;
                lock (typeNames)
                {
                    if (s_numEntries == MAX_CACHE_ENTRIES)
                    {
                        typeNames.Clear();
                        s_numEntries = 0;
                    }
                    typeNames[typeName] = match;
                    s_numEntries ++;
                }

                return match.type;
            }
            if (match.assemblyName.Equals(assemblyName))
                return match.type;

            // So if same type name occurs in 2 assemblies, the second guy is screwed
            return null;
        }
        */

        StringBuilder sbf = new StringBuilder();
        internal String FilterBin64(String value)
        {
            sbf.Length = 0;
            for (int i=0; i<value.Length; i++)
            {
                if (!(value[i] == ' '|| value[i] == '\n' || value[i] == '\r'))
                    sbf.Append(value[i]);
            }
            return sbf.ToString();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\soapwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: SoapWriter
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Emits XML for SOAP Formatter
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/
namespace System.Runtime.Serialization.Formatters.Soap
{
	using System;
	using System.Runtime.Serialization.Formatters;
	using System.Collections;
	using System.Reflection;
	using System.IO;
	using System.Globalization;	
	using System.Text;
	using System.Diagnostics;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Metadata.W3cXsd2001;

	// This class provides persistence of a COM+ object graph to a stream using
	// the SOAP XML-based format.

 	sealed internal class SoapWriter
	{        
	    // the start of a soap message always looks like one of these

        // Encoding style not used because of difficulty in interop   
        // "SOAP-ENV:encodingStyle=\"http://schemas.microsoft.com/soap/encoding/clr/1.0 http://schemas.xmlsoap.org/soap/encoding/\"";

        private static String _soapStartStr =
                "<SOAP-ENV:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" " +
                "xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" " +
                "xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" " +
                "xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" " +
                "xmlns:clr=\"http://schemas.microsoft.com/soap/encoding/clr/1.0\" " +
                "SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"";

        private static String _soapStart1999Str =  
                "<SOAP-ENV:Envelope xmlns:xsi=\"http://www.w3.org/1999/XMLSchema-instance\" " +
                "xmlns:xsd=\"http://www.w3.org/1999/XMLSchema\" " +
                "xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" " +
                "xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" " +
                "SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"";

        private static String _soapStart2000Str = 
            "<SOAP-ENV:Envelope xmlns:xsi=\"http://www.w3.org/2000/10/XMLSchema-instance\" " +
            "xmlns:xsd=\"http://www.w3.org/2000/10/XMLSchema\" " +
            "xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" " +
            "xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" " +
            "SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"";

        private static byte[] _soapStart = Encoding.UTF8.GetBytes(_soapStartStr);
        private static byte[] _soapStart1999 = Encoding.UTF8.GetBytes(_soapStart1999Str);
        private static byte[] _soapStart2000 = Encoding.UTF8.GetBytes(_soapStart2000Str);


		private AttributeList attrList = new AttributeList();
		private AttributeList attrValueList = new AttributeList();

		const int StringBuilderSize = 1024;


		// used for emitting into the text stream	
		private int lineIndent = 4;
		private int instanceIndent = 1;

		// used to escape strings.  cache it as a member variable because its used frequently.
		private StringBuilder stringBuffer = new StringBuilder(120);
		private StringBuilder sb = new StringBuilder(120);

		private int topId;
		private int headerId;

		//Assembly information
		Hashtable assemblyInfos = new Hashtable(10);
		StreamWriter writer;
        Stream stream;

		// Support for combining assembly names with namespaces
		Hashtable typeNameToDottedInfoTable = null;
		Hashtable dottedAssemToAssemIdTable = null;
        Hashtable assemblyInfoUsed = new Hashtable(10); // for each xml element keeps track of unique types used
		int dottedAssemId = 1;

		internal bool isUsedEnc = false;
        XsdVersion xsdVersion = XsdVersion.V2001;

		internal struct DottedInfo
		{
			internal String dottedAssemblyName;
			internal String name;
			internal String nameSpace;
			internal int assemId;
		}


		internal SoapWriter(Stream stream)
		{
			this.stream = stream;
			UTF8Encoding enc = new UTF8Encoding(false, true);
			this.writer = new StreamWriter(stream, enc, StringBuilderSize);
			// Need to combine the type namespace with the assembly name for an element
			typeNameToDottedInfoTable = new Hashtable(20);
			dottedAssemToAssemIdTable = new Hashtable(20);
		}


		// Emit first Soap element
		private void EmitHeader()
		{
			InternalST.Soap( this,"EmitHeader: ");
			writer.Write("<?xml version=\"1.0\" ?>");
			EmitLine();
		}

		// Emit spaces for indentation

		[Conditional("_DEBUG")]
		private void EmitIndent(int count)
		{
			while (--count >= 0) {
				for (int i = 0; i < lineIndent; i++)
				{
					TraceSoap(" ");
					writer.Write(' ');
				}
			}
		}

		// Emit a line
		[Conditional("_DEBUG")]				
		private void EmitLine(int indent, String value) {
			InternalST.Soap( this,"EmitLine: ",value);
			EmitIndent(indent);
			writer.Write(value);
			EmitLine();
		}

		// Emit a blank line
		private void EmitLine()
		{
			WriteTraceSoap();
			writer.Write("\r\n");
		}

		// Add xml escape characters to the string value, if necessary.

		private String Escape(String value)
		{
			stringBuffer.Length = 0;
			int index = value.IndexOf('&');
			if (index > -1)
			{
				stringBuffer.Append(value);
				stringBuffer.Replace("&", "&#38;", index, stringBuffer.Length - index);
			}

			index = value.IndexOf('"');
			if (index > -1)
			{
				if (stringBuffer.Length == 0)
					stringBuffer.Append(value);
				stringBuffer.Replace("\"", "&#34;", index, stringBuffer.Length - index);
			}

			index = value.IndexOf('\'');
			if (index > -1)
			{
				if (stringBuffer.Length == 0)
					stringBuffer.Append(value);
				stringBuffer.Replace("\'", "&#39;", index, stringBuffer.Length - index);
			}

			index = value.IndexOf('<');
			if (index > -1)
			{
				if (stringBuffer.Length == 0)
					stringBuffer.Append(value);
				stringBuffer.Replace("<", "&#60;", index, stringBuffer.Length - index);
			}

			index = value.IndexOf('>');
			if (index > -1)
			{
				if (stringBuffer.Length == 0)
					stringBuffer.Append(value);
				stringBuffer.Replace(">", "&#62;", index, stringBuffer.Length - index);
			}

            index = value.IndexOf(Char.MinValue);
			if (index > -1)
			{
				if (stringBuffer.Length == 0)
					stringBuffer.Append(value);
				stringBuffer.Replace(Char.MinValue.ToString(), "&#0;", index, stringBuffer.Length - index);
            }

            String returnValue = null;

			if (stringBuffer.Length > 0)
				returnValue = stringBuffer.ToString();
			else
				returnValue = value;

            return returnValue;
		}


		// Add escape character for a $ and . in an element name


        NameCache nameCache = new NameCache();
        private String NameEscape(String name)
        {
            String value = (String)nameCache.GetCachedValue(name);
            if (value == null)
            {
                value = System.Xml.XmlConvert.EncodeName(name);
                nameCache.SetCachedValue(value);
            }
           return value;
        }


		// Initial writer
		internal void Reset() {
			writer = null;
			stringBuffer = null;
		}

		internal void InternalWrite(String s)
		{
			TraceSoap(s);
			writer.Write(s);
		}

		StringBuilder traceBuffer = null;
		[Conditional("_LOGGING")]						
		internal void TraceSoap(String s)
		{
			if (traceBuffer == null)
				traceBuffer = new StringBuilder();
			traceBuffer.Append(s);
		}

		[Conditional("_LOGGING")]						
		internal void WriteTraceSoap()
		{
			InternalST.InfoSoap(traceBuffer.ToString());
			traceBuffer.Length = 0;
		}		

		// Write an XML element
		internal void Write(InternalElementTypeE use, String name, AttributeList attrList, String value, bool isNameEscape, bool isValueEscape)
		{
			InternalST.Soap( this,"Write ",((Enum)use).ToString(),", name "+name+", value ",value, " isNameEscape ",isNameEscape," isValueEscape ",isValueEscape);

			String elementName = name;
			if (isNameEscape)
				elementName = NameEscape(name);

			if (use == InternalElementTypeE.ObjectEnd)
				instanceIndent--;
			
			EmitIndent(instanceIndent);			

			InternalWrite("<");
			if (use == InternalElementTypeE.ObjectEnd)
				InternalWrite("/");
			InternalWrite(elementName);

			WriteAttributeList(attrList);
			
			switch(use)
			{
				case InternalElementTypeE.ObjectBegin:
					InternalWrite(">");
					instanceIndent++;
					break;
				case InternalElementTypeE.ObjectEnd:
					InternalWrite(">");
					break;
				case InternalElementTypeE.Member:
					if (value == null)
						InternalWrite("/>");
					else
					{
						InternalWrite(">");
						if (isValueEscape)
							InternalWrite(Escape(value));
						else
							InternalWrite(value);
						InternalWrite("</");
						InternalWrite(elementName);
						InternalWrite(">");					
					}
					break;
				default:
					throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_UseCode"),((Enum)use).ToString()));									
			}
			EmitLine();
		}


        void WriteAttributeList(AttributeList attrList)
        {
            for (int i=0; i<attrList.Count; i++)
            {
                String aName;
                String aValue;
                attrList.Get(i, out aName, out aValue);
                InternalWrite(" ");
                InternalWrite(aName);
                InternalWrite("=");
                InternalWrite("\"");
                //InternalWrite(Escape(aValue));
                InternalWrite(aValue);
                InternalWrite("\"");
            }
        } // WriteAttributeList


		// Begin a new XML stream
		internal void WriteBegin()
		{
			InternalST.InfoSoap("******************** Start Serialized Stream *****************");						
		}

		// Finish an XML stream
		internal void WriteEnd()
		{
			writer.Flush();
			InternalST.InfoSoap("******************** End Serialized Stream  *******************");					
			Reset();
		}

        internal void WriteXsdVersion(XsdVersion xsdVersion)
        {
            this.xsdVersion = xsdVersion;
        }

		// Methods to write XML Serialization Record onto the stream, 
		internal void WriteObjectEnd(NameInfo memberNameInfo, NameInfo typeNameInfo)
		{
			//nameInfo.Dump("WriteObjectEnd nameInfo");

			attrList.Clear();
			Write(InternalElementTypeE.ObjectEnd, MemberElementName(memberNameInfo, typeNameInfo), attrList, null, true, false);						
            assemblyInfoUsed.Clear();
		}

		internal void WriteMemberEnd(NameInfo nameInfo)
		{
		}

		internal void WriteSerializationHeaderEnd()
		{
			attrList.Clear();
			Write(InternalElementTypeE.ObjectEnd, "SOAP-ENV:Body", attrList, null, false, false);				
			Write(InternalElementTypeE.ObjectEnd, "SOAP-ENV:Envelope", attrList,	null, false, false);
			writer.Flush();
		}


		internal void WriteItemEnd()
		{
		}

		internal void WriteHeaderArrayEnd()
		{
			//attrList.Clear();
			//Write(InternalElementTypeE.ObjectEnd, "SOAP:HeaderRoots",attrList, null);						
		}

		internal void WriteHeaderSectionEnd()
		{
			attrList.Clear();			
			Write(InternalElementTypeE.ObjectEnd, "SOAP-ENV:Header", attrList, null, false, false);							
		}


		internal void WriteSerializationHeader(int topId, int headerId, int minorVersion, int majorVersion)
		{
			InternalST.Soap( this,"WriteSerializationHeader");
			this.topId = topId;
			this.headerId = headerId;

		    // write start of header directly to stream
            switch(xsdVersion)
            {
                case XsdVersion.V1999:
                    InternalST.InfoSoap(_soapStart1999Str,">");
                    stream.Write(_soapStart1999, 0, _soapStart1999.Length);
                    break;
                case XsdVersion.V2000:
                    InternalST.InfoSoap(_soapStart2000Str,">");
                    stream.Write(_soapStart1999, 0, _soapStart2000.Length);
                    break;
                case XsdVersion.V2001:
                    InternalST.InfoSoap(_soapStartStr,">");
                    stream.Write(_soapStart, 0, _soapStart.Length);
                    break;
            }
			writer.Write(">\r\n");
        } // InternalWriteSerializationHeader


		internal void WriteObject(NameInfo nameInfo, NameInfo typeNameInfo, int numMembers, String[] memberNames, Type[] memberTypes, WriteObjectInfo[] objectInfos)
		{
			nameInfo.Dump("WriteObject nameInfo");
			typeNameInfo.Dump("WriteObject typeNameInfo");						

			int objectId = (int)nameInfo.NIobjectId;
			attrList.Clear();
			if (objectId == topId)
				Write(InternalElementTypeE.ObjectBegin, "SOAP-ENV:Body", attrList, null, false, false);

			// Only write the objectId in the top record if the header has been written or
			if	(objectId > 0)
				attrList.Put("id", IdToString((int)nameInfo.NIobjectId));
			// Types when Object is embedded member and types needed			
			if (((nameInfo.NItransmitTypeOnObject || nameInfo.NItransmitTypeOnMember) && (nameInfo.NIisNestedObject || nameInfo.NIisArrayItem)))
				attrList.Put("xsi:type", TypeNameTagResolver(typeNameInfo, true)); 
			if (nameInfo.NIisMustUnderstand)
			{
				attrList.Put("SOAP-ENV:mustUnderstand", "1");
				isUsedEnc = true;
			}
			if (nameInfo.NIisHeader)
            {
                attrList.Put("xmlns:"+nameInfo.NIheaderPrefix, nameInfo.NInamespace);
				attrList.Put("SOAP-ENC:root", "1"); 
            }

			if (attrValueList.Count > 0)
			{
				// Combine the values from the XmlAttributes with the object attributes
				for (int i=0; i<attrValueList.Count; i++)
				{
					String aName;
					String aValue;
					attrValueList.Get(i, out aName, out aValue);
					attrList.Put(aName, aValue);
				}
				attrValueList.Clear();
			}

            String memberName =  MemberElementName(nameInfo, typeNameInfo);
            NamespaceAttribute();
			Write(InternalElementTypeE.ObjectBegin, memberName, attrList, null, true, false); 
		}

		internal void WriteAttributeValue(NameInfo memberNameInfo, NameInfo typeNameInfo, Object value)
		{
			// Called when the XmlAttribute is specified on a member
			InternalST.Soap( this,"WriteAttributeValues ",value);
			String stringValue = null;
			if (value is String)
				stringValue = (String)value;
			else
				stringValue = Converter.SoapToString(value, typeNameInfo.NIprimitiveTypeEnum);
			attrValueList.Put(MemberElementName(memberNameInfo, typeNameInfo), stringValue);
		}

		internal void WriteObjectString(NameInfo nameInfo, String value)
		{
			InternalST.Soap( this,"WriteObjectString value ",value);
			nameInfo.Dump("WriteObjectString nameInfo");			
			attrList.Clear();
			if (nameInfo.NIobjectId == topId)
				Write(InternalElementTypeE.ObjectBegin, "SOAP-ENV:Body", attrList, null, false, false);


			if (nameInfo.NIobjectId >0)
			{
				attrList.Put("id", IdToString((int)nameInfo.NIobjectId));
			}

            String stringType = null;
            if (nameInfo.NIobjectId > 0)
            {
                stringType = "SOAP-ENC:string";
                isUsedEnc = true;											
            }
            else
                stringType = "xsd:string";				

			Write(InternalElementTypeE.Member, stringType, attrList, value, false, Converter.IsEscaped(nameInfo.NIprimitiveTypeEnum));
		}

		internal void WriteTopPrimitive(NameInfo nameInfo, Object value)
		{
			nameInfo.Dump("WriteMember memberNameInfo");

			attrList.Clear();

			Write(InternalElementTypeE.ObjectBegin, "SOAP-ENV:Body", attrList, null, false, false);

			if (nameInfo.NIobjectId >0)
			{
				attrList.Put("id", IdToString((int)nameInfo.NIobjectId));
			}

			String stringValue = null;
			if (value is String)
				stringValue = (String)value;
			else
				stringValue = Converter.SoapToString(value, nameInfo.NIprimitiveTypeEnum);

			Write(InternalElementTypeE.Member, "xsd:"+(Converter.ToXmlDataType(nameInfo.NIprimitiveTypeEnum)), attrList, stringValue, true, false);
		}



		internal void WriteObjectByteArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Byte[] byteA)
		{
			memberNameInfo.Dump("WriteObjectByteArray memberNameInfo");
			arrayNameInfo.Dump("WriteObjectByteArray arrayNameInfo");
			arrayElemTypeNameInfo.Dump("WriteObjectByteArray arrayElemTypeNameInfo");

			String byteString = Convert.ToBase64String(byteA);		
			attrList.Clear();
			if (memberNameInfo.NIobjectId == topId)
				Write(InternalElementTypeE.ObjectBegin, "SOAP-ENV:Body", attrList, null, false, false);						
			if (arrayNameInfo.NIobjectId > 1)
				attrList.Put("id", IdToString((int)arrayNameInfo.NIobjectId));
			attrList.Put("xsi:type", "SOAP-ENC:base64");
			isUsedEnc = true;	
            String memberName = MemberElementName(memberNameInfo, null);
            NamespaceAttribute();
			Write(InternalElementTypeE.Member, memberName, attrList, byteString, true, false);
		}


		internal void WriteMember(NameInfo memberNameInfo, NameInfo typeNameInfo, Object value)
		{
			memberNameInfo.Dump("WriteMember memberNameInfo");
			typeNameInfo.Dump("WriteMember typeNameInfo");

			attrList.Clear();
			if ((typeNameInfo.NItype != null) && (memberNameInfo.NItransmitTypeOnMember || (memberNameInfo.NItransmitTypeOnObject && !memberNameInfo.NIisArrayItem)))			
			{
				attrList.Put("xsi:type", TypeNameTagResolver(typeNameInfo, true));
			}

             String stringValue = null;
             if (value != null)
             {
                 if (typeNameInfo.NIprimitiveTypeEnum == InternalPrimitiveTypeE.QName)
                 {
                     SoapQName soapQName = (SoapQName)value;
                     if (soapQName.Key == null || soapQName.Key.Length == 0)
                         attrList.Put("xmlns", "");
                     else
                         attrList.Put("xmlns:"+soapQName.Key, soapQName.Namespace);
                     
                     stringValue = soapQName.ToString();
                 }
                 else
                 {

                     if (value is String)
                         stringValue = (String)value;
                     else
                         stringValue = Converter.SoapToString(value, typeNameInfo.NIprimitiveTypeEnum);
                 }
             }

			NameInfo tempNameInfo = null;

			// If XmlElement attribute was defined on member, then an alternate member name has been specifed
			if (typeNameInfo.NInameSpaceEnum == InternalNameSpaceE.Interop)
				tempNameInfo = typeNameInfo;

            String memberName = MemberElementName(memberNameInfo, tempNameInfo);
            NamespaceAttribute();
			Write(InternalElementTypeE.Member, memberName, attrList, stringValue, true, Converter.IsEscaped(typeNameInfo.NIprimitiveTypeEnum));
		}


		//internal void WriteNullMember(String memberName, Type memberType, Boolean isTyped, Type objType)
		internal void WriteNullMember(NameInfo memberNameInfo, NameInfo typeNameInfo)				
		{
			memberNameInfo.Dump("WriteNullMember memberNameInfo");			
			typeNameInfo.Dump("WriteNullMember typeNameInfo");

			attrList.Clear();
			if ((typeNameInfo.NItype != null) &&
				  (memberNameInfo.NItransmitTypeOnMember ||
				   (memberNameInfo.NItransmitTypeOnObject && !memberNameInfo.NIisArrayItem)))
			{
				attrList.Put("xsi:type", TypeNameTagResolver(typeNameInfo, true));
			}
			attrList.Put("xsi:null", "1");

            /*
			NameInfo tempNameInfo = null;

			// If XmlElement attribute was defined on member, then an alternate member name has been specifed
			if (typeNameInfo.NInameSpaceEnum == InternalNameSpaceE.Interop)
				tempNameInfo = typeNameInfo;
                */

			String memberName = MemberElementName(memberNameInfo, null);
            NamespaceAttribute();
			Write(InternalElementTypeE.Member, memberName, attrList, null, true, false); 
		}


		internal void WriteMemberObjectRef(NameInfo memberNameInfo, int idRef)
		{
			memberNameInfo.Dump("WriteMemberObjectRef memberNameInfo");						
			attrList.Clear();
			attrList.Put("href", RefToString(idRef));
            String memberName = MemberElementName(memberNameInfo, null);
            NamespaceAttribute();
			Write(InternalElementTypeE.Member, memberName, attrList, null, true, false);
		}

		internal void WriteMemberNested(NameInfo memberNameInfo)
		{

		}

		//internal void WriteMemberString(String memberName, int objectId, String value, Boolean isTyped, Type objType)
		internal void WriteMemberString(NameInfo memberNameInfo, NameInfo typeNameInfo, String value)
		{
			memberNameInfo.Dump("WriteMemberString memberNameInfo");						
			typeNameInfo.Dump("WriteMemberString typeNameInfo");

			InternalST.Soap( this, "WriteMemberString memberName ",memberNameInfo.NIname," objectId ",typeNameInfo.NIobjectId," value ",value);
			int objectId = (int)typeNameInfo.NIobjectId;
			attrList.Clear();
			if (objectId > 0)
				attrList.Put("id", IdToString((int)typeNameInfo.NIobjectId));
			if ((typeNameInfo.NItype != null) && (memberNameInfo.NItransmitTypeOnMember || (memberNameInfo.NItransmitTypeOnObject && !memberNameInfo.NIisArrayItem)))						
			{
				if (typeNameInfo.NIobjectId > 0)
				{
					attrList.Put("xsi:type", "SOAP-ENC:string");
					isUsedEnc = true;											
				}
				else
					attrList.Put("xsi:type", "xsd:string");						
			}

			NameInfo tempNameInfo = null;

			// If XmlElement attribute was defined on member, then an alternate member name has been specifed
			if (typeNameInfo.NInameSpaceEnum == InternalNameSpaceE.Interop)
				tempNameInfo = typeNameInfo;

            String memberName = MemberElementName(memberNameInfo, tempNameInfo);
            NamespaceAttribute();
			Write(InternalElementTypeE.Member, memberName, attrList, value, true, Converter.IsEscaped(typeNameInfo.NIprimitiveTypeEnum));
		}

		internal void WriteSingleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Array array)
		{
			memberNameInfo.Dump("WriteSingleArray memberNameInfo");									
			arrayNameInfo.Dump("WriteSingleArray arrayNameInfo");
			arrayElemTypeNameInfo.Dump("WriteSingleArray arrayElemTypeNameInfo");

			attrList.Clear();
			if (memberNameInfo.NIobjectId == topId)
				Write(InternalElementTypeE.ObjectBegin, "SOAP-ENV:Body", attrList, null, false, false);			
			if (arrayNameInfo.NIobjectId > 1)
				attrList.Put("id", IdToString((int)arrayNameInfo.NIobjectId));
			arrayElemTypeNameInfo.NIitemName = NameTagResolver(arrayElemTypeNameInfo, true);
			attrList.Put("SOAP-ENC:arrayType", NameTagResolver(arrayNameInfo, true, memberNameInfo.NIname));
			isUsedEnc = true;			
			if (lowerBound != 0)
				attrList.Put("SOAP-ENC:offset","["+lowerBound+"]");
            String memberName = MemberElementName(memberNameInfo, null);
            NamespaceAttribute();
			Write(InternalElementTypeE.ObjectBegin, memberName, attrList, null, false, false);
		}

		internal void WriteJaggedArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound)				
		{
			memberNameInfo.Dump("WriteJaggedArray memberNameInfo");												
			arrayNameInfo.Dump("WriteJaggedArray arrayNameInfo");
			arrayElemTypeNameInfo.Dump("WriteJaggedArray arrayElemTypeNameInfo");

			attrList.Clear();
			if (memberNameInfo.NIobjectId == topId)
				Write(InternalElementTypeE.ObjectBegin, "SOAP-ENV:Body", attrList, null, false, false);						
			if (arrayNameInfo.NIobjectId > 1)
				attrList.Put("id", IdToString((int)arrayNameInfo.NIobjectId));
			arrayElemTypeNameInfo.NIitemName = "SOAP-ENC:Array";
			isUsedEnc = true;			
			attrList.Put("SOAP-ENC:arrayType", TypeArrayNameTagResolver(memberNameInfo, arrayNameInfo, true));			
			if (lowerBound != 0)
				attrList.Put("SOAP-ENC:offset","["+lowerBound+"]");
            String memberName = MemberElementName(memberNameInfo, null);
            NamespaceAttribute();
			Write(InternalElementTypeE.ObjectBegin, memberName, attrList, null, false, false);
		}


		private StringBuilder sbOffset = new StringBuilder(10);

		internal	void WriteRectangleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int rank, int[] lengthA, int[] lowerBoundA)				
		{
			memberNameInfo.Dump("WriteRectangleArray memberNameInfo");												
			arrayNameInfo.Dump("WriteRectangleArray arrayNameInfo");
			arrayElemTypeNameInfo.Dump("WriteRectangleArray arrayElemTypeNameInfo");

			sbOffset.Length = 0;
			sbOffset.Append("[");
			Boolean isZero = true;
			for (int i = 0; i<rank; i++)
			{
				if (lowerBoundA[i] != 0)
					isZero = false;
				if (i > 0)
					sbOffset.Append(",");
				sbOffset.Append(lowerBoundA[i]);
			}
			sbOffset.Append("]");

			attrList.Clear();
			if (memberNameInfo.NIobjectId == topId)
				Write(InternalElementTypeE.ObjectBegin, "SOAP-ENV:Body", attrList, null, false, false);						
			if (arrayNameInfo.NIobjectId > 1)
				attrList.Put("id", IdToString((int)arrayNameInfo.NIobjectId));
			arrayElemTypeNameInfo.NIitemName = NameTagResolver(arrayElemTypeNameInfo, true);
			attrList.Put("SOAP-ENC:arrayType", TypeArrayNameTagResolver(memberNameInfo, arrayNameInfo, true));
			isUsedEnc = true;			
			if (!isZero)
				attrList.Put("SOAP-ENC:offset", sbOffset.ToString());
            String memberName = MemberElementName(memberNameInfo, null);
            NamespaceAttribute();
			Write(InternalElementTypeE.ObjectBegin, memberName, attrList, null, false, false); 
		}

		//internal void WriteItem(Variant value, InternalPrimitiveTypeE code, Boolean isTyped, Type objType)
		internal void WriteItem(NameInfo itemNameInfo, NameInfo typeNameInfo, Object value)
		{
			itemNameInfo.Dump("WriteItem itemNameInfo");												
			typeNameInfo.Dump("WriteItem typeNameInfo");

			attrList.Clear();
			if (itemNameInfo.NItransmitTypeOnMember)
			{
				attrList.Put("xsi:type", TypeNameTagResolver(typeNameInfo, true));
			}

            String stringValue = null;

            if (typeNameInfo.NIprimitiveTypeEnum == InternalPrimitiveTypeE.QName)
            {
                if (value != null)
                {
                    SoapQName soapQName = (SoapQName)value;
                    if (soapQName.Key == null || soapQName.Key.Length == 0)
                        attrList.Put("xmlns", "");
                    else
                        attrList.Put("xmlns:"+soapQName.Key, soapQName.Namespace);

                    stringValue = soapQName.ToString();
                }
            }
            else
                stringValue = Converter.SoapToString(value, typeNameInfo.NIprimitiveTypeEnum);


            NamespaceAttribute();
			Write(InternalElementTypeE.Member, "item", attrList, stringValue, false, (typeNameInfo.NIprimitiveTypeEnum == InternalPrimitiveTypeE.Invalid));
		}

		internal void WriteNullItem(NameInfo memberNameInfo, NameInfo typeNameInfo)				
		{
			memberNameInfo.Dump("WriteNullItem memberNameInfo");												
			typeNameInfo.Dump("WriteNullItem typeNameInfo");

			String typeName = typeNameInfo.NIname;
			attrList.Clear();
			if (typeNameInfo.NItransmitTypeOnMember &&
				  !((typeName.Equals("System.Object")) ||
					(typeName.Equals("Object")) ||						
					(typeName.Equals("System.Empty") ||
					(typeName.Equals("ur-type")) ||
					(typeName.Equals("anyType"))
                     )))
				attrList.Put("xsi:type", TypeNameTagResolver(typeNameInfo, true));

			attrList.Put("xsi:null", "1");		
            NamespaceAttribute();
			Write(InternalElementTypeE.Member, "item", attrList, null, false, false);
		}


		//internal void WriteItemObjectRef(int idRef)
		internal void WriteItemObjectRef(NameInfo itemNameInfo, int arrayId)
		{
			itemNameInfo.Dump("WriteItemObjectRef itemNameInfo");												
			attrList.Clear();
			attrList.Put("href", RefToString(arrayId));
			Write(InternalElementTypeE.Member, "item", attrList, null, false, false);
		}

		// Type of string or primitive type which has already been converted to string
		internal	void WriteItemString(NameInfo itemNameInfo, NameInfo typeNameInfo, String value)		
		{
			itemNameInfo.Dump("WriteItemString itemNameInfo");												
			typeNameInfo.Dump("WriteItemString typeNameInfo");

			attrList.Clear();

			if (typeNameInfo.NIobjectId > 0)
			{
				attrList.Put("id", IdToString((int)typeNameInfo.NIobjectId));
			}
			if (itemNameInfo.NItransmitTypeOnMember)
			{
				if (typeNameInfo.NItype == SoapUtil.typeofString)
				{
					if (typeNameInfo.NIobjectId > 0)
					{
						attrList.Put("xsi:type", "SOAP-ENC:string");
						isUsedEnc = true;											
					}
					else
						attrList.Put("xsi:type", "xsd:string");						
				}
				else
					attrList.Put("xsi:type", TypeNameTagResolver(typeNameInfo, true));
			}

            NamespaceAttribute();
			Write(InternalElementTypeE.Member, "item", attrList, value, false, Converter.IsEscaped(typeNameInfo.NIprimitiveTypeEnum));
		}

		internal void WriteHeader(int objectId, int numMembers)
		{
			attrList.Clear();
			Write(InternalElementTypeE.ObjectBegin, "SOAP-ENV:Header",attrList, null, false, false);
			//Write(InternalElementTypeE.ObjectBegin, "SOAP:HeaderRoots",attrList, null);			
		}


		//internal void WriteHeaderEntry(String name, Boolean isMustUnderstand, InternalPrimitiveTypeE code, Variant value)
		internal void WriteHeaderEntry(NameInfo nameInfo, NameInfo typeNameInfo, Object value)				
		{
			nameInfo.Dump("WriteHeaderEntry nameInfo");
			if (typeNameInfo != null)
			{
				typeNameInfo.Dump("WriteHeaderEntry typeNameInfo");
			}

			attrList.Clear();
			if (value == null)
				attrList.Put("xsi:null", "1");							
			else
				attrList.Put("xsi:type", TypeNameTagResolver(typeNameInfo, true));
			if (nameInfo.NIisMustUnderstand)
			{
				attrList.Put("SOAP-ENV:mustUnderstand", "1");
				isUsedEnc = true;
			}

            attrList.Put("xmlns:"+nameInfo.NIheaderPrefix, nameInfo.NInamespace);
			attrList.Put("SOAP-ENC:root", "1");
			String stringValue = null;

            if (value != null)
            {
                if (typeNameInfo != null && typeNameInfo.NIprimitiveTypeEnum == InternalPrimitiveTypeE.QName)
                {
                    SoapQName soapQName = (SoapQName)value;
                    if (soapQName.Key == null || soapQName.Key.Length == 0)
                        attrList.Put("xmlns", "");
                    else
                        attrList.Put("xmlns:"+soapQName.Key, soapQName.Namespace);

                    stringValue = soapQName.ToString();
                }
                else
                    stringValue = Converter.SoapToString(value, typeNameInfo.NIprimitiveTypeEnum);
            }

            NamespaceAttribute();
			Write(InternalElementTypeE.Member, nameInfo.NIheaderPrefix+":"+nameInfo.NIname, attrList, stringValue, true, true);
		}

		//internal void WriteHeaderObjectRef(String name, Boolean isMustUnderstand, int idRef)
		internal	void WriteHeaderObjectRef(NameInfo nameInfo)
		{
			nameInfo.Dump("WriteHeaderObjectRef nameInfo");						

			attrList.Clear();
			attrList.Put("href", RefToString((int)nameInfo.NIobjectId));
			if (nameInfo.NIisMustUnderstand)
			{				
				attrList.Put("SOAP-ENV:mustUnderstand", "1");
				isUsedEnc = true;
			}
            attrList.Put("xmlns:"+nameInfo.NIheaderPrefix, nameInfo.NInamespace);
			attrList.Put("SOAP-ENC:root", "1");						
			Write(InternalElementTypeE.Member, nameInfo.NIheaderPrefix+":"+nameInfo.NIname, attrList, null, true, true);
		}

		internal void WriteHeaderNested(NameInfo nameInfo)
		{
		}

		//internal void WriteHeaderString(String name, Boolean isMustUnderstand, int objectId, String value)
		internal	void WriteHeaderString(NameInfo nameInfo, String value)
		{
			nameInfo.Dump("WriteHeaderString nameInfo");

			attrList.Clear();
			attrList.Put("xsi:type", "SOAP-ENC:string");
			isUsedEnc = true;		
			if (nameInfo.NIisMustUnderstand)
				attrList.Put("SOAP-ENV:mustUnderstand", "1");
            attrList.Put("xmlns:"+nameInfo.NIheaderPrefix, nameInfo.NInamespace);
			attrList.Put("SOAP-ENC:root", "1");									
			Write(InternalElementTypeE.Member, nameInfo.NIheaderPrefix+":"+nameInfo.NIname, attrList, value, true, true);
		}

		internal void WriteHeaderMethodSignature(NameInfo nameInfo, NameInfo[] typeNameInfos)
		{
			nameInfo.Dump("WriteHeaderString nameInfo");
			attrList.Clear();
			attrList.Put("xsi:type", "SOAP-ENC:methodSignature");
			isUsedEnc = true;			
			if (nameInfo.NIisMustUnderstand)
				attrList.Put("SOAP-ENV:mustUnderstand", "1");
            attrList.Put("xmlns:"+nameInfo.NIheaderPrefix, nameInfo.NInamespace);
			attrList.Put("SOAP-ENC:root", "1");

			StringBuilder sb = new StringBuilder();
			
			// The signature string is an sequence of prefixed types, where the prefix is the key to the namespace.
			for (int i=0; i<typeNameInfos.Length; i++)
			{	if (i > 0)
					sb.Append(' ');
				sb.Append(NameTagResolver(typeNameInfos[i], true));
			}
			
            NamespaceAttribute();
			Write(InternalElementTypeE.Member, nameInfo.NIheaderPrefix+":"+nameInfo.NIname, attrList, sb.ToString(), true, true);
		}

		internal void WriteAssembly(String typeFullName, Type type, String assemName, int assemId, bool isNew, bool isInteropType)
		{
			InternalST.Soap( this, "WriteAssembly ",typeFullName," ",type," ",assemId," ",assemName," isNew ",isNew, " isInteropType ", isInteropType);
			if (isNew)
			{
				InternalST.Soap( this, "WriteAssembly new Assembly ");
				if (isInteropType)
				{
					// Interop type
					assemblyInfos[InteropAssemIdToString(assemId)] = new AssemblyInfo(assemId, assemName, isInteropType);
				}
			}

			if (!isInteropType)
			{
				// assembly name and dotted namespaces are combined
				ParseAssemblyName(typeFullName, assemName);
			}
		}

		private DottedInfo ParseAssemblyName(String typeFullName, String assemName)
		{
			InternalST.Soap( this, "ParseAssemblyName Entry typeFullName ",typeFullName," assemName ",assemName);
			DottedInfo dottedInfo;
			String nameSpace = null;
			String name = null;
			String dottedAssemblyName = null;
			int assemId;
			if (typeNameToDottedInfoTable.ContainsKey(typeFullName))
			{
				// type name already seen 
				dottedInfo = (DottedInfo)typeNameToDottedInfoTable[typeFullName];
			}
			else
			{
				// type name new, find nameSpace and concatenate the assembly name to it.
				int index = typeFullName.LastIndexOf('.');
				if (index > 0)
					nameSpace = typeFullName.Substring(0, index);
				else
					nameSpace = "";


                dottedAssemblyName = SoapServices.CodeXmlNamespaceForClrTypeNamespace(nameSpace, assemName);

				name = typeFullName.Substring(index+1);				

				if (dottedAssemToAssemIdTable.ContainsKey(dottedAssemblyName))
				{
					// The dotted assembly name has been seen before, get the assembly Id
					assemId = (int)dottedAssemToAssemIdTable[dottedAssemblyName];
				}
				else
				{
					// The dotted assembly name has not been seen before, calculate a new
					// assemId and remember it so that it can be added to the Envelope xml namespaces
					assemId = dottedAssemId++;
					assemblyInfos[AssemIdToString(assemId)] = new AssemblyInfo(assemId, dottedAssemblyName, false);
					dottedAssemToAssemIdTable[dottedAssemblyName] = assemId;
				}

				// Create a new DottedInfo structure and remember it with the type name
				dottedInfo = new DottedInfo();
				dottedInfo.dottedAssemblyName = dottedAssemblyName;
				dottedInfo.name = name;
				dottedInfo.nameSpace = nameSpace;
				dottedInfo.assemId = assemId;
				typeNameToDottedInfoTable[typeFullName] = dottedInfo;			
				InternalST.Soap( this, "ParseAssemblyName new dotted Assembly name ",dottedInfo.name,", dottedAssemblyName ",dottedInfo.dottedAssemblyName,", assemId ",dottedInfo.assemId, " typeFullName ", typeFullName);
			}
			InternalST.Soap( this, "ParseAssemblyName Exit nameSpace ",dottedInfo.nameSpace," name ",dottedInfo.name," assemblyName ",dottedInfo.dottedAssemblyName," assemId ",dottedInfo.assemId);
			return dottedInfo;
		}

        StringBuilder sb1 = new StringBuilder("ref-",15);
		private String IdToString(int objectId)
		{
            sb1.Length=4;
            sb1.Append(objectId);
            return sb1.ToString();
		}

        StringBuilder sb2 = new StringBuilder("a-",15);
		private String AssemIdToString(int assemId)
		{
            sb2.Length=1;
            sb2.Append(assemId);
            return sb2.ToString();
		}

        StringBuilder sb3 = new StringBuilder("i-",15);
		private String InteropAssemIdToString(int assemId)
		{
            sb3.Length=1;
            sb3.Append(assemId);
            return sb3.ToString();
		}		

        StringBuilder sb4 = new StringBuilder("#ref-",16);
		private String RefToString(int objectId)
		{
            sb4.Length=5;
            sb4.Append(objectId);
            return sb4.ToString();
		}

		private String MemberElementName(NameInfo memberNameInfo, NameInfo typeNameInfo)
		{
			String memberName = memberNameInfo.NIname;

            if (memberNameInfo.NIisHeader)
            {
                memberName = memberNameInfo.NIheaderPrefix+":"+memberNameInfo.NIname;
            }
			else if ((typeNameInfo != null) &&(typeNameInfo.NItype == SoapUtil.typeofSoapFault))
			{
				memberName = "SOAP-ENV:Fault";
			}
			else if (memberNameInfo.NIisArray && !memberNameInfo.NIisNestedObject)
			{
				memberName = "SOAP-ENC:Array";
				isUsedEnc = true;
			}
			//else if (memberNameInfo.NItype == SoapUtil.typeofObject)
			//memberName = "SOAP:Object";
			else if (memberNameInfo.NIisArrayItem)
			{
				//memberName = memberNameInfo.NIitemName; // occurs for a nested class in an array
				memberName = "item";
			}
			else if (memberNameInfo.NIisNestedObject)
			{
			}
            else if (memberNameInfo.NIisRemoteRecord && !memberNameInfo.NIisTopLevelObject) // Parameters
            {
            }
			else if (typeNameInfo != null)
			{
				memberName = NameTagResolver(typeNameInfo, true); 
			}
			return memberName;
		}

		private String TypeNameTagResolver(NameInfo typeNameInfo, bool isXsiAppended)
		{
			String name = null;
			if ((typeNameInfo.NIassemId > 0) && (typeNameInfo.NIattributeInfo != null) && (typeNameInfo.NIattributeInfo.AttributeTypeName != null))
			{
				String assemIdString = InteropAssemIdToString((int)typeNameInfo.NIassemId);
				name = assemIdString+":"+typeNameInfo.NIattributeInfo.AttributeTypeName;
				AssemblyInfo assemblyInfo = (AssemblyInfo)assemblyInfos[assemIdString];
                assemblyInfo.isUsed = true;
                assemblyInfo.prefix = assemIdString;
                assemblyInfoUsed[assemblyInfo] = 1;
			}
			else
				name = NameTagResolver(typeNameInfo, isXsiAppended);

			return name;
		}

		private String NameTagResolver(NameInfo typeNameInfo, bool isXsiAppended)
		{
			return NameTagResolver(typeNameInfo, isXsiAppended, null);
		}
		
		private String NameTagResolver(NameInfo typeNameInfo, bool isXsiAppended, String arrayItemName)
		{
			String name = typeNameInfo.NIname;
			switch(typeNameInfo.NInameSpaceEnum)
			{
				case InternalNameSpaceE.Soap:
					name = "SOAP-ENC:"+typeNameInfo.NIname;
					isUsedEnc = true;					
					break;
				case InternalNameSpaceE.XdrPrimitive:
					if (isXsiAppended)
						name = "xsd:"+typeNameInfo.NIname;
					break;
				case InternalNameSpaceE.XdrString:
					if (isXsiAppended)					
						name = "xsd:"+typeNameInfo.NIname;
					break;					
				case InternalNameSpaceE.UrtSystem:
					if (typeNameInfo.NItype == SoapUtil.typeofObject)
						name = "xsd:anyType";					
					else if (arrayItemName == null)
					{
						// need to generate dotted name spaces
						DottedInfo dottedInfo;
						if (typeNameToDottedInfoTable.ContainsKey(typeNameInfo.NIname))
							dottedInfo = (DottedInfo)typeNameToDottedInfoTable[typeNameInfo.NIname];
						else
						{
							dottedInfo = ParseAssemblyName(typeNameInfo.NIname, null);
						}
						String assemIdString = AssemIdToString(dottedInfo.assemId);
						name = assemIdString+":"+dottedInfo.name;
                        AssemblyInfo assemblyInfo = (AssemblyInfo)assemblyInfos[assemIdString];
                        assemblyInfo.isUsed = true;
                        assemblyInfo.prefix = assemIdString;
                        assemblyInfoUsed[assemblyInfo] = 1;
					}
					else
					{
						// need to generate dotted name spaces
						DottedInfo dottedInfo;
						if (typeNameToDottedInfoTable.ContainsKey(arrayItemName))
							dottedInfo = (DottedInfo)typeNameToDottedInfoTable[arrayItemName];
						else
						{
							dottedInfo = ParseAssemblyName(arrayItemName, null);
						}
						String assemIdString = AssemIdToString(dottedInfo.assemId);						
						name = assemIdString+":"+DottedDimensionName(dottedInfo.name, typeNameInfo.NIname);
                        AssemblyInfo assemblyInfo = (AssemblyInfo)assemblyInfos[assemIdString];
                        assemblyInfo.isUsed = true;
                        assemblyInfo.prefix = assemIdString;
                        assemblyInfoUsed[assemblyInfo] = 1;
					}
					break;
				case InternalNameSpaceE.UrtUser:
					if (typeNameInfo.NIassemId > 0)
					{
						if (arrayItemName == null)
						{
							DottedInfo dottedInfo;
							InternalST.Soap( this, "NameTagResolver typeNameInfo.NIname ",typeNameInfo.NIname," table ", typeNameToDottedInfoTable.ContainsKey(typeNameInfo.NIname));
							SoapUtil.DumpHash("typeNameToDottedInfoTable", typeNameToDottedInfoTable);
							if (typeNameToDottedInfoTable.ContainsKey(typeNameInfo.NIname))
								dottedInfo = (DottedInfo)typeNameToDottedInfoTable[typeNameInfo.NIname];								
							else
								throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Assembly"),typeNameInfo.NIname));

							String assemIdString = AssemIdToString(dottedInfo.assemId);
							name = assemIdString+":"+dottedInfo.name;
                            AssemblyInfo assemblyInfo = (AssemblyInfo)assemblyInfos[assemIdString];
                            assemblyInfo.isUsed = true;
                            assemblyInfo.prefix = assemIdString;
                            assemblyInfoUsed[assemblyInfo] = 1;
						}
						else
						{
							DottedInfo dottedInfo;
							if (typeNameToDottedInfoTable.ContainsKey(arrayItemName))
								dottedInfo = (DottedInfo)typeNameToDottedInfoTable[arrayItemName];								
							else
								throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Assembly"),typeNameInfo.NIname));													

							String assemIdString = AssemIdToString(dottedInfo.assemId);							
							name = assemIdString+":"+DottedDimensionName(dottedInfo.name, typeNameInfo.NIname);
                            AssemblyInfo assemblyInfo = (AssemblyInfo)assemblyInfos[assemIdString];
                            assemblyInfo.isUsed = true;
                            assemblyInfo.prefix = assemIdString;
                            assemblyInfoUsed[assemblyInfo] = 1;
						}
					}
					break;
				case InternalNameSpaceE.CallElement:
					if (typeNameInfo.NIassemId > 0)
					{
                            String key = InteropAssemIdToString((int)typeNameInfo.NIassemId);
                            AssemblyInfo assemblyInfo = (AssemblyInfo)assemblyInfos[key];
                            if (assemblyInfo == null)
                                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_NameSpaceEnum"),typeNameInfo.NInameSpaceEnum));																	
                            name = key+":"+typeNameInfo.NIname;
                            assemblyInfo.isUsed = true; //PDJ check this against checked in code
                            assemblyInfo.prefix = key;
                            assemblyInfoUsed[assemblyInfo] = 1;
                    }
					break;
				case InternalNameSpaceE.Interop:
				{
				    if ((typeNameInfo.NIattributeInfo != null) && (typeNameInfo.NIattributeInfo.AttributeElementName != null))
				    {
					    if (typeNameInfo.NIassemId > 0) 
					    {
						    String assemIdString = InteropAssemIdToString((int)typeNameInfo.NIassemId);	 
    						name = assemIdString+":"+typeNameInfo.NIattributeInfo.AttributeElementName;
                            if (arrayItemName != null)
                            {
                                int index = typeNameInfo.NIname.IndexOf("[");
                                name = name+typeNameInfo.NIname.Substring(index);
                            }
                            AssemblyInfo assemblyInfo = (AssemblyInfo)assemblyInfos[assemIdString];
                            assemblyInfo.isUsed = true;
                            assemblyInfo.prefix = assemIdString;
                            assemblyInfoUsed[assemblyInfo] = 1;
		    			}
			    		else
				    	{
				    	    // This is the case of writing out a customized XML element
				    	    //   or attribute with no namespace.
					        name = typeNameInfo.NIattributeInfo.AttributeElementName;
	    				}
	    		    }
					break;
			    }
				case InternalNameSpaceE.None:
				case InternalNameSpaceE.UserNameSpace:
				case InternalNameSpaceE.MemberName:
					break;
				default:
					throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_NameSpaceEnum"),typeNameInfo.NInameSpaceEnum));					

			}
			return name;
		}

		private String TypeArrayNameTagResolver(NameInfo memberNameInfo, NameInfo typeNameInfo, bool isXsiAppended)
		{
			String name = null;
			if ((typeNameInfo.NIassemId > 0) && (typeNameInfo.NIattributeInfo != null) && (typeNameInfo.NIattributeInfo.AttributeTypeName != null))
				name = InteropAssemIdToString((int)typeNameInfo.NIassemId)+":"+typeNameInfo.NIattributeInfo.AttributeTypeName;
			else
				name = NameTagResolver(typeNameInfo, isXsiAppended, memberNameInfo.NIname);
			return name;
		}
		
		private void NamespaceAttribute()
		{
			IDictionaryEnumerator e = assemblyInfoUsed.GetEnumerator();
			while(e.MoveNext())
			{
				AssemblyInfo assemblyInfo = (AssemblyInfo)e.Key;
                attrList.Put("xmlns:"+assemblyInfo.prefix, assemblyInfo.name);
            }
            assemblyInfoUsed.Clear();
        }

		private String DottedDimensionName(String dottedName, String dimensionName)
		{
			String newName = null;
			int dottedIndex = dottedName.IndexOf('[');
			int dimensionIndex = dimensionName.IndexOf('[');
			newName = dottedName.Substring(0,dottedIndex)+dimensionName.Substring(dimensionIndex);
			InternalST.Soap( this, "DottedDimensionName "+newName);
			return newName;

		}

		internal sealed class AssemblyInfo
		{
			internal int id;
			internal String name;
            internal String prefix;
			internal bool isInteropType;
			internal bool isUsed;

			internal AssemblyInfo(int id, String name, bool isInteropType)
			{
				this.id = id;
				this.name = name;
				this.isInteropType = isInteropType;
				isUsed = false;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\ceefilegen\blobfetcher.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Implementation for CBlobFetcher
//
//
//*****************************************************************************
#include "stdafx.h" // for ASSERTE and friends
#include "BlobFetcher.h"

//-----------------------------------------------------------------------------
//  round a pointer back down to something aligned
static inline char* truncateTo(char* val, unsigned align) {
    _ASSERTE((align & (align - 1)) == 0);       // align must be a power of 2

    return((char*) (unsigned(val) & ~(align-1)));
}

//-----------------------------------------------------------------------------
//  round up to a certain alignment
static inline unsigned roundUp(unsigned val, unsigned align) {
    _ASSERTE((align & (align - 1)) == 0);       // align must be a power of 2

    return((val + (align-1)) & ~(align-1));
}

//-----------------------------------------------------------------------------
//  round up to a certain alignment
static inline unsigned padForAlign(unsigned val, unsigned align) {
    _ASSERTE((align & (align - 1)) == 0);       // align must be a power of 2
    return ((-int(val)) & (align-1));
}

//*****************************************************************************
// Pillar implementation
//*****************************************************************************
//-----------------------------------------------------------------------------
CBlobFetcher::CPillar::CPillar() {
    m_dataAlloc = m_dataStart = m_dataCur = m_dataEnd = NULL;

    m_nTargetSize = 0x10000;    
}

//-----------------------------------------------------------------------------
CBlobFetcher::CPillar::~CPillar() {
// Sanity check to make sure nobody messed up the pts
    _ASSERTE((m_dataCur >= m_dataStart) && (m_dataCur <= m_dataEnd));

    delete [] m_dataAlloc;
}


//-----------------------------------------------------------------------------
// Transfer ownership of data, so src will lose data and this will get it.
// Data itself will remain untouched, just ptrs & ownership change
//-----------------------------------------------------------------------------
void CBlobFetcher::CPillar::StealDataFrom(CBlobFetcher::CPillar & src)
{
// We should only be moving into an empty Pillar
    _ASSERTE(m_dataStart == NULL);


    m_dataAlloc     = src.m_dataAlloc;
    m_dataStart     = src.m_dataStart;
    m_dataCur       = src.m_dataCur;
    m_dataEnd       = src.m_dataEnd;

    m_nTargetSize   = src.m_nTargetSize;

// Take away src's claim to data. This prevents multiple ownership and double deleting
    src.m_dataAlloc = src.m_dataStart = src.m_dataCur = src.m_dataEnd = NULL;

}

//-----------------------------------------------------------------------------
// Allocate a block in this particular pillar
//-----------------------------------------------------------------------------
/* make a new block 'len' bytes long'  However, move the pointer 'pad' bytes
   over so that the memory has the correct alignment characteristics */

char * CBlobFetcher::CPillar::MakeNewBlock(unsigned len, unsigned pad) {

    _ASSERTE(pad < maxAlign);

// Make sure we have memory in this block to allocatate
    if (m_dataStart == NULL) {
        // make sure allocate at least as big as length
        m_nTargetSize = max(m_nTargetSize, len);

        //
        // We need to allocate memory with an offset of "pad" from
        // being "maxAlign" aligned. (data % maxAlign == pad).
        // Since "new" doesn't do this, allocate some extra 
        // to handle the worst possible alignment case.
        // 

        m_dataAlloc = new char[m_nTargetSize+(maxAlign-1)];
        if (m_dataAlloc == NULL)
            return NULL;

        m_dataStart = m_dataAlloc + 
          ((pad - unsigned(m_dataAlloc)) & (maxAlign-1));

        _ASSERTE(unsigned(m_dataStart) % maxAlign == pad);
        
        m_dataCur = m_dataStart;
    
        m_dataEnd = &m_dataStart[m_nTargetSize];
    }

    _ASSERTE(m_dataCur >= m_dataStart);
    _ASSERTE((int) len > 0);

// If this block is full, then get out, we'll have to try another block
    if (m_dataCur + len > m_dataEnd)  { 
        return NULL;
    }
    
    char* ret = m_dataCur;
    m_dataCur += len;
    _ASSERTE(m_dataCur <= m_dataEnd);
    return(ret);
}


//*****************************************************************************
// Blob Fetcher Implementation
//*****************************************************************************

//-----------------------------------------------------------------------------
CBlobFetcher::CBlobFetcher()
{
// Setup storage
    m_pIndex = NULL;
    m_nIndexMax = 1; // start off with arbitrary small size  @@@ (minimum is 1) 
    m_nIndexUsed = 0;
    _ASSERTE(m_nIndexUsed < m_nIndexMax); // use <, not <=

    m_nDataLen = 0;

    m_pIndex = new CPillar[m_nIndexMax];
    _ASSERTE(m_pIndex);
    // @FUTURE: what do we do here if we run out of memory??!!
}

//-----------------------------------------------------------------------------
CBlobFetcher::~CBlobFetcher()
{
    delete [] m_pIndex;
}


//-----------------------------------------------------------------------------
// Dynamic mem allocation, but we can't move old blocks (since others
// have pointers to them), so we need a fancy way to grow
//-----------------------------------------------------------------------------
char* CBlobFetcher::MakeNewBlock(unsigned len, unsigned align) {

    _ASSERTE(m_pIndex);
    _ASSERTE(0 < align && align <= maxAlign);

    // deal with alignment 
    unsigned pad = padForAlign(m_nDataLen,align);
    char* pChRet = NULL;
    if (pad != 0) {
        pChRet = m_pIndex[m_nIndexUsed].MakeNewBlock(pad, 0);
        // if don't have space for the pad, then need to allocate a new pillar
        // the allocation will handle the padding for the alignment of m_nDataLen
        if (pChRet) {
            memset(pChRet, 0, pad);
            m_nDataLen += pad;
            pad = 0;
        }
    }
#ifdef _DEBUG
    if (pChRet)
        _ASSERTE(m_nDataLen % align == 0);
#endif

// Quickly compute total data length is tough since we have alignment problems
// We'll do it by get the length of all the completely full pillars so far
// and then adding on the size of the current pillar
    unsigned nPreDataLen = m_nDataLen - m_pIndex[m_nIndexUsed].GetDataLen();

    pChRet = m_pIndex[m_nIndexUsed].MakeNewBlock(len + pad, 0);
    if (pChRet == NULL) {
        m_nIndexUsed ++; // current pillar is full, move to next
        nPreDataLen = m_nDataLen;

        if (m_nIndexUsed == m_nIndexMax) { // entire array of pillars are full, re-org
            const unsigned nNewMax = m_nIndexMax * 2; // arbitrary new size             

            // @FUTURE: great! That signature does not allow us to return error when out of memory.
            // @FUTURE: Clean up in the future.
            CPillar* pNewIndex = new CPillar[nNewMax];
            _ASSERTE(pNewIndex);
            
        // Copy old stuff
            for(unsigned i = 0; i < m_nIndexMax; i++) pNewIndex[i].StealDataFrom(m_pIndex[i]);
            
            delete [] m_pIndex;

            m_nIndexMax = nNewMax;
            m_pIndex = pNewIndex;
        }
    
    // Make sure the new pillar is large enough to hold the data
    // How we do this is *totally arbitrary* and has been optimized for how
    // we intend to use this.       
        if (m_pIndex[m_nIndexUsed].GetAllocateSize() < len) {
            m_pIndex[m_nIndexUsed].SetAllocateSize(roundUp(len, maxAlign));
        }

    // Now that we're on new pillar, try again
        pChRet = m_pIndex[m_nIndexUsed].MakeNewBlock(len + pad, m_nDataLen % maxAlign);
        if (pChRet == NULL)
            return NULL;
        _ASSERTE(pChRet);

    // The current pointer picks up at the same alignment that the last block left off
        _ASSERTE(nPreDataLen % maxAlign == ((unsigned) pChRet) % maxAlign);
    }
    if (pad != 0) {
        memset(pChRet, 0, pad);
        pChRet += pad;
    }

    m_nDataLen = nPreDataLen + m_pIndex[m_nIndexUsed].GetDataLen();

    _ASSERTE(((unsigned) m_nDataLen -len) % align == 0);
    _ASSERTE(((unsigned) pChRet) % align == 0);
    return pChRet;
}

//-----------------------------------------------------------------------------
// Index segment as if this were linear (middle weight function)
//-----------------------------------------------------------------------------
char * CBlobFetcher::ComputePointer(unsigned offset) const
{
    _ASSERTE(m_pIndex);
    unsigned idx = 0;

    if (offset == 0) {
        // if ask for a 0 offset and no data, return NULL
        if (m_pIndex[0].GetDataLen() == 0)
            return NULL;
    } else {
        while (offset >= m_pIndex[idx].GetDataLen()) {
            offset -= m_pIndex[idx].GetDataLen();
            idx ++;
            // Overflow - have asked for an offset greater than what exists
            if (idx > m_nIndexUsed) {
                _ASSERTE(!"CBlobFetcher::ComputePointer() Overflow");
                return NULL;
            }
        }
    }

    char * ptr = (char*) (m_pIndex[idx].GetRawDataStart() + offset);
    return ptr;
}

//-----------------------------------------------------------------------------
// See if a pointer came from this blob fetcher
//-----------------------------------------------------------------------------
BOOL CBlobFetcher::ContainsPointer(char *ptr) const
{
    _ASSERTE(m_pIndex);

    CPillar *p = m_pIndex;
    CPillar *pEnd = p + m_nIndexUsed;

    unsigned offset = 0;

    while (p <= pEnd) {
        if (p->Contains(ptr))
            return TRUE;

        offset += p->GetDataLen();
        p++;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
// Find a pointer as if this were linear (middle weight function)
//-----------------------------------------------------------------------------
unsigned CBlobFetcher::ComputeOffset(char *ptr) const
{
    _ASSERTE(m_pIndex);

    CPillar *p = m_pIndex;
    CPillar *pEnd = p + m_nIndexUsed;

    unsigned offset = 0;

    while (p <= pEnd) {
        if (p->Contains(ptr))
            return offset + p->GetOffset(ptr);

        offset += p->GetDataLen();
        p++;
    }

    _ASSERTE(!"Pointer not found");
    return 0;
}

//-----------------------------------------------------------------------------
// Truncate our complex storage as if it were an array
//-----------------------------------------------------------------------------
HRESULT CBlobFetcher::Truncate(unsigned newLen)
{
// Implementation design: we simply need to move the m_dataCur pointers
    if (newLen == m_nDataLen) return S_OK;

    unsigned idx = 0; // start at end and work up

// Find which pillar (idx) new length will leave us in
    unsigned nLen = 0;
    while(nLen < newLen) {
        nLen += m_pIndex[idx].GetDataLen();
        idx ++;
    }

// Set new pillars data pointer accordingly
    idx --;
    nLen -= m_pIndex[idx].GetDataLen(); // goto start of pillar
    
    unsigned newCur = newLen - nLen;

    m_pIndex[idx].m_dataCur = m_pIndex[idx].m_dataStart + newCur;

// Reset rest of pillars
    for(unsigned i = idx + 1; i < m_nIndexUsed; i ++) m_pIndex[i].m_dataCur = m_pIndex[i].m_dataStart;
    
    m_nIndexUsed = idx;

    return S_OK;
}


//Take the data from our previous blob and copy it into our new blob 
//after whatever was already in that blob.
HRESULT CBlobFetcher::Merge(CBlobFetcher *destination) {
    unsigned dataLen;
    char *dataBlock;
    char *dataCurr;
    unsigned idx;
    _ASSERTE(destination);

    dataLen = GetDataLen();
    _ASSERTE( dataLen >= 0 );

    // Make sure there actually is data in the previous blob before trying to append it.
    if ( 0 == dataLen )
    {
        return S_OK;
    }

    //Get the length of our data and get a new block large enough to hold all of it.
    dataBlock = destination->MakeNewBlock(dataLen,1);
    if (dataBlock==NULL) {
        return E_OUTOFMEMORY;
    }
    
    //Copy all of the bytes using the write algorithm from PEWriter.cpp
    dataCurr=dataBlock;
    for (idx=0; idx<=m_nIndexUsed;  idx++) {
        if (m_pIndex[idx].GetDataLen()>0) {
            _ASSERTE(dataCurr<dataBlock+dataLen);
            memcpy(dataCurr, m_pIndex[idx].GetRawDataStart(), m_pIndex[idx].GetDataLen());
            dataCurr+=m_pIndex[idx].GetDataLen();
        }
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\ceefilegen\cceegen.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"

#include <string.h>
#include <limits.h>
#include <basetsd.h>

#include "CorError.h"


//*****************************************************************************
// Creation for new CCeeGen instances
//
// Both allocate and call virtual Init() (Can't call v-func in a ctor, 
// but we want to create in 1 call);
//*****************************************************************************

HRESULT STDMETHODCALLTYPE CreateICeeGen(REFIID riid, void **pCeeGen)
{
	if (riid != IID_ICeeGen)
		return E_NOTIMPL;
    if (!pCeeGen)
		return E_POINTER;
    CCeeGen *pCeeFileGen;
	HRESULT hr = CCeeGen::CreateNewInstance(pCeeFileGen);
	if (FAILED(hr))
		return hr;
	pCeeFileGen->AddRef();
	*(CCeeGen**)pCeeGen = pCeeFileGen;
	return S_OK;
}

HRESULT CCeeGen::CreateNewInstance(CCeeGen* & pGen) // static, public
{
    pGen = new CCeeGen();
	_ASSERTE(pGen != NULL);
    TESTANDRETURNMEMORY(pGen);
    
    pGen->m_peSectionMan = new PESectionMan;    
    _ASSERTE(pGen->m_peSectionMan != NULL);
    TESTANDRETURNMEMORY(pGen->m_peSectionMan);

    HRESULT hr = pGen->m_peSectionMan->Init();
	TESTANDRETURNHR(hr);

    hr = pGen->Init();
	TESTANDRETURNHR(hr);

    return hr;

}

STDMETHODIMP CCeeGen::QueryInterface(REFIID riid, void** ppv)
{
    if (!ppv)
		return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IUnknown)
        *ppv = (IUnknown*)(ICeeGen*)this;
	else if (riid == IID_ICeeGen)
        *ppv = (ICeeGen*)this;
    if (*ppv == NULL)
        return E_NOINTERFACE;
	AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CCeeGen::AddRef(void)
{
    return InterlockedIncrement(&m_cRefs);
}
 
STDMETHODIMP_(ULONG) CCeeGen::Release(void)
{
	if (InterlockedDecrement(&m_cRefs) == 0) {
		Cleanup();
		delete this;
	}
	return 1;
}

STDMETHODIMP CCeeGen::EmitString (LPWSTR lpString, ULONG *RVA)
{
	if (! RVA)
		return E_POINTER;
    return(getStringSection().getEmittedStringRef(lpString, RVA));
}

STDMETHODIMP CCeeGen::GetString(ULONG RVA, LPWSTR *lpString)
{
	if (! lpString)
		return E_POINTER;
    *lpString = (LPWSTR)getStringSection().computePointer(RVA);
	if (*lpString)
		return S_OK;
	return E_FAIL;
}

STDMETHODIMP CCeeGen::AllocateMethodBuffer(ULONG cchBuffer, UCHAR **lpBuffer, ULONG *RVA)
{
	if (! cchBuffer)
		return E_INVALIDARG;
	if (! lpBuffer || ! RVA)
		return E_POINTER;
    *lpBuffer = (UCHAR*) getIlSection().getBlock(cchBuffer, 4);	// Dword align
	if (!*lpBuffer)
		return E_OUTOFMEMORY;
		// have to compute the method offset after getting the block, not
		// before (since alignment might shift it up 
    ULONG methodOffset = getIlSection().dataLen() - cchBuffer;
	// for in-memory, just return address and will calc later
	*RVA = methodOffset;
	return S_OK;
}

STDMETHODIMP CCeeGen::GetMethodBuffer(ULONG RVA, UCHAR **lpBuffer)
{
	if (! lpBuffer)
		return E_POINTER;
    *lpBuffer = (UCHAR*)getIlSection().computePointer(RVA);
	if (*lpBuffer)
		return S_OK;
	return E_FAIL;
}

STDMETHODIMP CCeeGen::ComputePointer(HCEESECTION section, ULONG RVA, UCHAR **lpBuffer)
{
	if (! lpBuffer)
		return E_POINTER;
    *lpBuffer = (UCHAR*) ((CeeSection *)section)->computePointer(RVA);
	if (*lpBuffer)
		return S_OK;
	return E_FAIL;
}

STDMETHODIMP CCeeGen::GetIMapTokenIface (  
		IUnknown **pIMapToken)
{
	_ASSERTE(!"E_NOTIMPL");
	return E_NOTIMPL;
}

STDMETHODIMP CCeeGen::AddNotificationHandler (  
		IUnknown *pHandler)
{
	_ASSERTE(!"E_NOTIMPL");
	return E_NOTIMPL;
}

STDMETHODIMP CCeeGen::GenerateCeeFile ()
{
	_ASSERTE(!"E_NOTIMPL");
	return E_NOTIMPL;
}

STDMETHODIMP CCeeGen::GenerateCeeMemoryImage (void **)
{
	_ASSERTE(!"E_NOTIMPL");
	return E_NOTIMPL;
}

STDMETHODIMP CCeeGen::GetIlSection ( 
		HCEESECTION *section)
{
    *section = (HCEESECTION)(m_sections[m_ilIdx]);
    return S_OK;
}

STDMETHODIMP CCeeGen::GetStringSection(HCEESECTION *section)
{
	_ASSERTE(!"E_NOTIMPL");
	return E_NOTIMPL;
}

STDMETHODIMP CCeeGen::AddSectionReloc ( 
		HCEESECTION section, 
		ULONG offset, 
		HCEESECTION relativeTo, 
		CeeSectionRelocType relocType)
{
    return m_sections[m_ilIdx]->addSectReloc(offset, *(m_sections[m_ilIdx]), relocType);
}

STDMETHODIMP CCeeGen::GetSectionCreate ( 
		const char *name, 
		DWORD flags, 
		HCEESECTION *section)
{
    short       sectionIdx;
    return getSectionCreate (name, flags, (CeeSection **)section, &sectionIdx);
}

STDMETHODIMP CCeeGen::GetSectionDataLen ( 
		HCEESECTION section, 
		ULONG *dataLen)
{
    CeeSection *pSection = (CeeSection*) section;
    *dataLen = pSection->dataLen();
    return NOERROR;
}

STDMETHODIMP CCeeGen::GetSectionBlock ( 
		HCEESECTION section, 
		ULONG len, 
		ULONG align, 
		void **ppBytes)
{
    CeeSection *pSection = (CeeSection*) section;
    *ppBytes = (BYTE *)pSection->getBlock(len, align);
    if (*ppBytes == 0)
        return E_OUTOFMEMORY;
	return NOERROR;
}

STDMETHODIMP CCeeGen::TruncateSection ( 
		HCEESECTION section, 
		ULONG len)
{
	_ASSERTE(!"E_NOTIMPL");
	return E_NOTIMPL;
}



CCeeGen::CCeeGen() // protected ctor
{
// All other init done in InitCommon()
	m_cRefs = 0;
    m_peSectionMan = NULL;
	m_pTokenMap = NULL;
    m_pRemapHandler = NULL;

}

// Shared init code between derived classes, called by virtual Init()
HRESULT CCeeGen::Init() // not-virtual, protected
{
// Public, Virtual init must create our SectionManager, and 
// Common init does the rest
    _ASSERTE(m_peSectionMan != NULL);



    HRESULT hr = S_OK;
  
    __try { 
        m_corHeader = NULL;

        m_numSections = 0;
        m_allocSections = 10;
		m_sections = new CeeSection * [ m_allocSections ];
        if (m_sections == NULL)
            TESTANDLEAVEHR(E_OUTOFMEMORY);

		m_pTokenMap = NULL;
		m_fTokenMapSupported = FALSE;
		m_pRemapHandler = NULL;

		PESection *section = NULL;

        // These text section needs special support for handling string management now that we have
		// merged the sections together, so create it with an underlying CeeSectionString rather than the
		// more generic CeeSection

        hr = m_peSectionMan->getSectionCreate(".text", sdExecute, &section);
        TESTANDLEAVEHR(hr);
        CeeSection *ceeSection = new CeeSectionString(*this, *section);
        TESTANDLEAVE(ceeSection != NULL, E_OUTOFMEMORY);
        hr = addSection(ceeSection, &m_stringIdx);
		m_textIdx = m_stringIdx;	

        m_metaIdx = m_textIdx;	// meta section is actually in .text
        m_ilIdx = m_textIdx;	// il section is actually in .text
		m_corHdrIdx = -1;
        m_encMode = FALSE;

        TESTANDLEAVEHR(hr);
    } __finally {
        if (! SUCCEEDED(hr))
            Cleanup();
    }
    return hr;
}

// For EnC mode, generate strings into .rdata section rather than .text section
HRESULT CCeeGen::setEnCMode()
{
  	PESection *section = NULL;
    HRESULT hr = m_peSectionMan->getSectionCreate(".rdata", sdExecute, &section);
    TESTANDRETURNHR(hr);
    CeeSection *ceeSection = new CeeSectionString(*this, *section);
    TESTANDRETURN(ceeSection != NULL, E_OUTOFMEMORY);
    hr = addSection(ceeSection, &m_stringIdx);
    if (SUCCEEDED(hr))
        m_encMode = TRUE;
    return hr;
}


HRESULT CCeeGen::cloneInstance(CCeeGen *destination) { //public, virtual
    _ASSERTE(destination);
    
    destination->m_pTokenMap =          m_pTokenMap;
    destination->m_fTokenMapSupported = m_fTokenMapSupported;
    destination->m_pRemapHandler =      m_pRemapHandler;

    //Create a deep copy of the section manager (and each of it's sections);
    return m_peSectionMan->cloneInstance(destination->m_peSectionMan);
}

HRESULT CCeeGen::Cleanup() // virtual 
{
	HRESULT hr;
    for (int i = 0; i < m_numSections; i++) {
        delete m_sections[i];
    }

    delete m_sections;

	CeeGenTokenMapper *pMapper = m_pTokenMap;
	if (pMapper) {
		if (pMapper->m_pIImport) {
			IMetaDataEmit *pIIEmit;
			if (SUCCEEDED( hr = pMapper->m_pIImport->QueryInterface(IID_IMetaDataEmit, (void **) &pIIEmit)))
			{
				pIIEmit->SetHandler(NULL);
				pIIEmit->Release();
			}
			_ASSERTE(SUCCEEDED(hr));
			pMapper->m_pIImport->Release();
		}
		pMapper->Release();
		m_pTokenMap = NULL;
	}

    if (m_pRemapHandler)
    {
        m_pRemapHandler->Release();
        m_pRemapHandler = NULL;
    }

	if (m_peSectionMan) {
		m_peSectionMan->Cleanup();
		delete m_peSectionMan;
	}

    return S_OK;
}

HRESULT CCeeGen::addSection(CeeSection *section, short *sectionIdx)
{
    if (m_numSections >= m_allocSections)
    {
        _ASSERTE(m_allocSections > 0);
        while (m_numSections >= m_allocSections)
            m_allocSections <<= 1;
        CeeSection **newSections = new CeeSection * [m_allocSections];
        if (newSections == NULL)
            return E_OUTOFMEMORY;
        CopyMemory(newSections, m_sections, m_numSections * sizeof(*m_sections));
        if (m_sections != NULL)
            delete [] m_sections;
        m_sections = newSections;
    }

	if (sectionIdx)
		*sectionIdx = m_numSections;

    m_sections[m_numSections++] = section;
    return S_OK;
}

HRESULT CCeeGen::getSectionCreate (const char *name, DWORD flags, CeeSection **section, short *sectionIdx)
{
	if (strcmp(name, ".il") == 0)
		name = ".text";
	else if (strcmp(name, ".meta") == 0)
		name = ".text";
	else if (strcmp(name, ".rdata") == 0 && !m_encMode)
		name = ".text";
    for (int i=0; i<m_numSections; i++) {
        if (strcmp((const char *)m_sections[i]->name(), name) == 0) {
            if (section)
                *section = m_sections[i];
			if (sectionIdx)
				*sectionIdx = i;
            return S_OK;
        }
    }
    PESection *pewSect = NULL;
    HRESULT hr = m_peSectionMan->getSectionCreate(name, flags, &pewSect);
    TESTANDRETURNHR(hr);
    CeeSection *newSect = new CeeSection(*this, *pewSect);
    // if this fails, the PESection will get nuked in the destructor for CCeeGen
    TESTANDRETURN(newSect != NULL, E_OUTOFMEMORY);
    hr = addSection(newSect, sectionIdx);
    TESTANDRETURNHR(hr);
    if (section)
        *section = newSect;
    return S_OK;
}


HRESULT CCeeGen::emitMetaData(IMetaDataEmit *emitter, CeeSection* section, DWORD offset, BYTE* buffer, unsigned buffLen)
{
	HRESULT hr;

	if (! m_fTokenMapSupported) {
		IUnknown *pMapTokenIface;
		hr = getMapTokenIface(&pMapTokenIface, emitter);
		_ASSERTE(SUCCEEDED(hr));

	// Set a callback for token remap and save the tokens which change.
		hr = emitter->SetHandler(pMapTokenIface);
		_ASSERTE(SUCCEEDED(hr));
	}

    // generate the metadata
    IStream *metaStream;
    int rc = CreateStreamOnHGlobal(NULL, TRUE, &metaStream);
    _ASSERTE(rc == S_OK);

    hr = emitter->SaveToStream(metaStream, 0);
    _ASSERTE(SUCCEEDED(hr));

    // get size of stream and get sufficient storage for it

	if (section == 0) {
		section = &getMetaSection();
		STATSTG statStg;
		rc = metaStream->Stat(&statStg, STATFLAG_NONAME);       
		_ASSERTE(rc == S_OK);

		buffLen = statStg.cbSize.LowPart;
		if(m_objSwitch)
		{
			CeeSection* pSect;
			DWORD flags = IMAGE_SCN_LNK_INFO | IMAGE_SCN_LNK_REMOVE | IMAGE_SCN_ALIGN_1BYTES; // 0x00100A00
			hr = getSectionCreate(".cormeta",flags,&pSect,&m_metaIdx);
		}
		buffer = (BYTE *)section->getBlock(buffLen, sizeof(DWORD));
		TESTANDRETURN(buffer, E_OUTOFMEMORY);

		offset = getMetaSection().dataLen() - buffLen;
	}

	// reset seek pointer and read from stream
	LARGE_INTEGER disp = {0, 0};
	rc = metaStream->Seek(disp, STREAM_SEEK_SET, NULL);
	_ASSERTE(rc == S_OK);
	ULONG metaDataLen;
	rc = metaStream->Read(buffer, buffLen+1, &metaDataLen);	// +1 so assert below will fire. 
	_ASSERTE(rc == S_OK);
	_ASSERTE(metaDataLen <= buffLen);
	metaStream->Release();

	if (! m_fTokenMapSupported) {
		// Remove the handler that we set
		hr = emitter->SetHandler(NULL);
		TESTANDRETURNHR(hr);
	}

    // Set meta virtual address to offset of metadata within .meta, and 
    // and add a reloc for this offset, which will get turned 
    // into an rva when the pewriter writes out the file. 

    m_corHeader->MetaData.VirtualAddress = offset;
    getCorHeaderSection().addSectReloc(m_corHeaderOffset + offsetof(IMAGE_COR20_HEADER, MetaData), *section, srRelocAbsolute);
    m_corHeader->MetaData.Size = metaDataLen;
    
    return S_OK;
}

// Create the COM header - it goes at front of .meta section
// Need to do this before the meta data is copied in, but don't do at
// the same time because may not have metadata
HRESULT CCeeGen::allocateCorHeader()
{
	HRESULT hr = S_OK;
	CeeSection *corHeaderSection;
	if (m_corHdrIdx < 0) {
		hr = getSectionCreate(".text0", sdExecute, &corHeaderSection, &m_corHdrIdx);
		TESTANDRETURNHR(hr);

        m_corHeaderOffset = corHeaderSection->dataLen();
        m_corHeader = (IMAGE_COR20_HEADER*)corHeaderSection->getBlock(sizeof(IMAGE_COR20_HEADER));
        if (! m_corHeader)
            return E_OUTOFMEMORY;
        memset(m_corHeader, 0, sizeof(IMAGE_COR20_HEADER));
    }
    return S_OK;
}

HRESULT CCeeGen::getMethodRVA(ULONG codeOffset, ULONG *codeRVA)
{
    _ASSERTE(codeRVA);
    // for runtime conversion, just return the offset and will calculate real address when need the code
    *codeRVA = codeOffset;
    return S_OK;
} 

HRESULT CCeeGen::getMapTokenIface(IUnknown **pIMapToken, IMetaDataEmit *emitter) 
{
	if (! pIMapToken)
		return E_POINTER;
	if (! m_pTokenMap) {
		// Allocate the token mapper. As code is generated, each moved token will be added to
		// the mapper and the client will also add a TokenMap reloc for it so we can update later
		CeeGenTokenMapper *pMapper = new CeeGenTokenMapper;
		TESTANDRETURN(pMapper != NULL, E_OUTOFMEMORY);
		if (emitter) {
		    HRESULT hr = emitter->QueryInterface(IID_IMetaDataImport, (PVOID *) &pMapper->m_pIImport);
		    _ASSERTE(SUCCEEDED(hr));
		}
		m_pTokenMap = pMapper;
		m_fTokenMapSupported = (emitter == 0);

        // If we've been holding onto a token remap handler waiting
        // for the token mapper to get created, add it to the token
        // mapper now and release our hold on it.
        if (m_pRemapHandler && m_pTokenMap)
        {
            m_pTokenMap->AddTokenMapper(m_pRemapHandler);
            m_pRemapHandler->Release();
            m_pRemapHandler = NULL;
        }
	}
	*pIMapToken = getTokenMapper()->GetMapTokenIface();
	return S_OK;
}

HRESULT CCeeGen::addNotificationHandler(IUnknown *pHandler)
{
    // Null is no good...
    if (!pHandler)
        return E_POINTER;

    HRESULT hr = S_OK;
    IMapToken *pIMapToken;

    // Is this an IMapToken? If so, we can put it to good use...
    if (SUCCEEDED(pHandler->QueryInterface(IID_IMapToken,
                                           (void**)&pIMapToken)))
    {
        // You gotta have a token mapper to use an IMapToken, though.
        if (m_pTokenMap)
        {
            hr = m_pTokenMap->AddTokenMapper(pIMapToken);
            pIMapToken->Release();
        }
        else
        {
            // Hold onto it for later, just in case a token mapper
            // gets created. We're holding a reference to it here,
            // too.
            m_pRemapHandler = pIMapToken;
        }
    }

    return hr;
}

// Do an inmemory application of relocs
void CCeeGen::applyRelocs()
{
    m_peSectionMan->applyRelocs(getTokenMapper());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\metadata\wsdlparser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** File:    WsdlParser.cs
 **
 ** Author:  Peter de Jong (pdejong)
 **
 ** Purpose: Defines WsdlParser that parses a given WSDL document
 **          and generates types defined in it.
 **
 ** Date:    November 15, 2000
 **
 ===========================================================*/
namespace System.Runtime.Remoting.MetadataServices
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.Reflection;
	using System.Xml;
	using System.Diagnostics;
	using System.IO;
	using System.Text;
	using System.Net;
	using System.Runtime.Remoting.Channels;	// This is so we can get the resource strings.
	using System.Runtime.Remoting;
	using System.Globalization;

	// This class parses SUDS documents
	internal class WsdlParser
	{

		// XML document validation callback
		private void ValidationCallback(int hr, String reason)
		{
			StringBuilder sb = new StringBuilder("Validation Error:", 256);
			sb.Append(reason);
			sb.Append('(');
			sb.Append(hr);
			sb.Append(')');
			Console.WriteLine(sb);
		}

		// Main parser
		internal WsdlParser(TextReader input, String outputDir, ArrayList outCodeStreamList, String locationURL, bool bWrappedProxy, String proxyNamespace)
		{
			Util.Log("WsdlParser.WsdlParser outputDir "+outputDir+" locationURL "+locationURL+" bWrappedProxy "+bWrappedProxy+" proxyNamespace "+proxyNamespace);
			// Initialize member variables
			_XMLReader = null;
			_readerStreamsWsdl = new ReaderStream(locationURL);
			_readerStreamsWsdl.InputStream = input;
			_writerStreams = null;
			_outputDir = outputDir;
			_outCodeStreamList = outCodeStreamList;
			_bWrappedProxy = bWrappedProxy;
			if (proxyNamespace == null || proxyNamespace.Length == 0)
				_proxyNamespace = "InteropNS";
			else
				_proxyNamespace	= proxyNamespace;
			if (outputDir == null)
				outputDir = ".";

			int length = outputDir.Length;
			if (length > 0)
			{
				char endChar = outputDir[length-1];
				if (endChar != '\\' && endChar != '/')
					_outputDir = _outputDir + '\\';
			}
			//_namespaceStack = null;
			_URTNamespaces = new ArrayList();
			_blockDefault = SchemaBlockType.ALL;
			_primedNametable = CreatePrimedNametable();

		}

		internal String SchemaNamespaceString
		{
			get
			{ 
				String schemaStr = null;
				switch (_xsdVersion)
				{
				case XsdVersion.V1999:
					schemaStr = s_schemaNamespaceString1999;
					break;
				case XsdVersion.V2000:
					schemaStr = s_schemaNamespaceString2000;
					break;
				case XsdVersion.V2001:
					schemaStr = s_schemaNamespaceString;
					break;
				}
				return schemaStr;
			}
		}

		internal String ProxyNamespace
		{
			get {return _proxyNamespace;}
		}

		internal int ProxyNamespaceCount
		{
			get {return _proxyNamespaceCount;}
			set {_proxyNamespaceCount = value;}
		}

		internal XmlTextReader XMLReader
		{
			get {return _XMLReader;}
		}

		// Prints an XML node
		private void PrintNode(TextWriter textWriter)
		{
			Util.Log("WsdlParser.PrintNode");           
			if (textWriter == null)
				textWriter = Console.Out;
			_XMLReader.MoveToElement();
			textWriter.WriteLine("===========================");
			textWriter.WriteLine("LineNum   : " + _XMLReader.LineNumber);
			StringBuilder sb = new StringBuilder("NodeType  : ", 256);
			sb.Append((int) _XMLReader.NodeType);
			textWriter.WriteLine(sb);
			sb.Length = 0;
			sb.Append("Name      : ");
			sb.Append(_XMLReader.LocalName);
			textWriter.WriteLine(sb);
			sb.Length = 0;
			sb.Append("Namespace : ");
			sb.Append(_XMLReader.NamespaceURI);
			textWriter.WriteLine(sb);
			sb.Length = 0;
			sb.Append("Prefix    : ");
			sb.Append(_XMLReader.Prefix);
			textWriter.WriteLine(sb);
			sb.Length = 0;
			sb.Append("Hasvalue  : ");
			sb.Append(_XMLReader.HasValue);
			textWriter.WriteLine(sb);
			if (_XMLReader.HasValue)
			{
				sb.Length = 0;
				sb.Append("Value     : ");
				sb.Append(_XMLReader.Value);
				textWriter.WriteLine(sb);
			}
			sb.Length = 0;
			sb.Append("IsEmpty   : ");
			sb.Append(_XMLReader.IsEmptyElement);
			textWriter.WriteLine(sb);
			sb.Length = 0;
			sb.Append("Depth     : ");
			sb.Append(_XMLReader.Depth);
			textWriter.WriteLine(sb);
			sb.Length = 0;
			sb.Append("AttributeCount: ");
			sb.Append(_XMLReader.AttributeCount);
			textWriter.WriteLine(sb);
			while (_XMLReader.MoveToNextAttribute())
			{
				textWriter.WriteLine("      =========================");
				sb.Length = 0;
				sb.Append("      AttributeName: ");
				sb.Append(_XMLReader.LocalName);
				textWriter.WriteLine(sb);
				sb.Length = 0;
				sb.Append("      Prefix       : ");
				sb.Append(_XMLReader.Prefix);
				textWriter.WriteLine(sb);
				sb.Length = 0;
				sb.Append("      Namespace    : ");
				sb.Append(_XMLReader.NamespaceURI);
				textWriter.WriteLine(sb);
				sb.Length = 0;
				sb.Append("      Value        : ");
				sb.Append(_XMLReader.Value);
				textWriter.WriteLine(sb);
			}
			_XMLReader.MoveToElement();

			return;
		}

		// Skips past endtags and non content tags
		private bool SkipXmlElement()
		{
			Util.Log("WsdlParser.SkipXmlElement");          
			//PrintNode(Console.Out);
			_XMLReader.Skip();
			XmlNodeType nodeType = _XMLReader.MoveToContent();
			while (nodeType == XmlNodeType.EndElement)
			{
				_XMLReader.Read();
				nodeType = _XMLReader.MoveToContent();
				if (nodeType == XmlNodeType.None)
					break;
			}

			return(nodeType != XmlNodeType.None);
		}

		// Reads past endtags and non content tags
		private bool ReadNextXmlElement()
		{
			Util.Log("WsdlParser.ReadNextXmlElement");                      
			_XMLReader.Read();
			XmlNodeType nodeType = _XMLReader.MoveToContent();
			while (nodeType == XmlNodeType.EndElement)
			{
				_XMLReader.Read();
				nodeType = _XMLReader.MoveToContent();
				if (nodeType == XmlNodeType.None)
					break;
			}

			//PrintNode(Console.Out);
			return(nodeType != XmlNodeType.None);
		}

		// Parses complex types
		private URTComplexType ParseComplexType(URTNamespace parsingNamespace, String typeName)
		{
			Util.Log("WsdlParser.ParseComplexType NS "+parsingNamespace.Name+" typeName "+typeName);                                 
			// Lookup the name of the type and the base type from which it derives
			if (typeName == null)
				typeName = LookupAttribute(s_nameString, null, true);

			URTNamespace xns = null;
			String typeNS = ParseQName(ref typeName, parsingNamespace, out xns);            

			Util.Log("WsdlParser.ParseComplexType actualNS 1 "+xns);
			Util.Log("WsdlParser.ParseComplexType actualNS 2 "+xns.Name);
			URTComplexType parsingComplexType = xns.LookupComplexType(typeName);
			if (parsingComplexType == null)
			{
				parsingComplexType = new URTComplexType(typeName, xns.Name, xns.Namespace,
														xns.EncodedNS, _blockDefault,
														false, typeName != null, this, xns);
				xns.AddComplexType(parsingComplexType);
			}

			String baseType = LookupAttribute(s_baseString, null, false);

			if (!MatchingStrings(baseType, s_emptyString))
			{
				String baseNS = ParseQName(ref baseType, parsingNamespace);
				parsingComplexType.Extends(baseType, baseNS);
			}

			if (parsingComplexType.Fields.Count > 0)
			{
				SkipXmlElement();
			}
			else
			{
				int curDepth = _XMLReader.Depth;
				ReadNextXmlElement();

				int fieldNum = 0;
				String elementName;
				while (_XMLReader.Depth > curDepth)
				{
					elementName = _XMLReader.LocalName;
					if (MatchingStrings(elementName, s_elementString))
					{
						ParseElementField(xns, parsingComplexType, fieldNum);
						++fieldNum;
						continue;
					}
					else if (MatchingStrings(elementName, s_attributeString))
					{
						ParseAttributeField(xns, parsingComplexType);
						continue;
					}
					else if (MatchingStrings(elementName, s_allString))
					{
						parsingComplexType.BlockType = SchemaBlockType.ALL;
					}
					else if (MatchingStrings(elementName, s_sequenceString))
					{
						parsingComplexType.BlockType = SchemaBlockType.SEQUENCE;
					}
					else if (MatchingStrings(elementName, s_choiceString))
					{
						parsingComplexType.BlockType = SchemaBlockType.CHOICE;
					}
					else if (MatchingStrings(elementName, s_complexContentString))
					{
						parsingComplexType.BlockType = SchemaBlockType.ComplexContent; 
					}
					else if (MatchingStrings(elementName, s_restrictionString))
					{
						ParseRestrictionField(xns, parsingComplexType);
						//++fieldNum;
						continue;
					}
					else
					{
						// Ignore others elements such as annotations
						SkipXmlElement();
						continue;
					}

					// Read next element
					ReadNextXmlElement();
				}
			}

			return(parsingComplexType);
		}

		// Parses simple types
		private URTSimpleType ParseSimpleType(URTNamespace parsingNamespace, String typeName)
		{
			Util.Log("WsdlParser.ParseSimpleType NS "+parsingNamespace+" typeName "+typeName);                                              
			// Lookup the name of the type and the base type from which it derives
			if (typeName == null)
				typeName = LookupAttribute(s_nameString, null, true);
			String enumType = LookupAttribute(s_enumTypeString, s_wsdlSudsNamespaceString, false);
			URTSimpleType parsingSimpleType = parsingNamespace.LookupSimpleType(typeName);
			if (parsingSimpleType == null)
			{
				parsingSimpleType = new URTSimpleType(typeName, parsingNamespace.Name, parsingNamespace.Namespace,
													  parsingNamespace.EncodedNS, typeName != null, this);
				String baseType = LookupAttribute(s_baseString, null, false);
				if (!MatchingStrings(baseType, s_emptyString))
				{
					String baseNS = ParseQName(ref baseType, parsingNamespace);
					parsingSimpleType.Extends(baseType, baseNS);
				}
				parsingNamespace.AddSimpleType(parsingSimpleType);

				int curDepth = _XMLReader.Depth;
				ReadNextXmlElement();

				//int enumFacetNum = 0;
				string elementName;
				while (_XMLReader.Depth > curDepth)
				{
					elementName = _XMLReader.LocalName;

					if (MatchingStrings(elementName, s_restrictionString))
					{
						ParseRestrictionField(parsingNamespace, parsingSimpleType);
					}
					/*
					else if (MatchingStrings(elementName, s_encodingString))
					{
						ParseEncoding(parsingSimpleType);
					}
					*/
					else
					{
						SkipXmlElement();
					}
				}
			}
			else
			{
				SkipXmlElement();
			}
			if (enumType != null)
				parsingSimpleType.EnumType = enumType;

			return(parsingSimpleType);
		}

		/*
		// Parses encoding
		private void ParseEncoding(URTSimpleType parsingSimpleType)
		{
			Util.Log("WsdlParser.ParseEncoding URTSimpleType "+parsingSimpleType);                                              
			if (_XMLReader.IsEmptyElement == true)
			{
				// Get the encoding value
				String valueString = LookupAttribute(s_valueString, null, true);
				parsingSimpleType.Encoding = valueString;
			}
			else
			{
				throw new SUDSParserException(
											 CoreChannel.GetResourceString("Remoting_Suds_EncodingMustBeEmpty"));
			}

			ReadNextXmlElement();
			return;
		}
		*/

		// Parses enumeration
		private void ParseEnumeration(URTSimpleType parsingSimpleType, int enumFacetNum)
		{
			Util.Log("WsdlParser.ParseEnumeration facitNum "+enumFacetNum);
			if (_XMLReader.IsEmptyElement == true)
			{
				// Get the enum value
				String valueString = LookupAttribute(s_valueString, null, true);
				parsingSimpleType.IsEnum = true;
				parsingSimpleType.AddFacet(new EnumFacet(valueString, enumFacetNum));
			}
			else
			{
				throw new SUDSParserException(
											 CoreChannel.GetResourceString("Remoting_Suds_EnumMustBeEmpty"));
			}
			return;
		}


		// Parses element fields
		private void ParseElementField(URTNamespace parsingNamespace,
									   URTComplexType parsingComplexType,
									   int fieldNum)
		{
			Util.Log("WsdlParser.ParseElementField NS "+parsingNamespace+" fieldNum "+fieldNum);            
			// Determine the field name
			String fieldTypeName, fieldTypeXmlNS;
			String fieldName = LookupAttribute(s_nameString, null, true);

			// Look for array bounds
			String minOccurs = LookupAttribute(s_minOccursString, null, false);
			String maxOccurs = LookupAttribute(s_maxOccursString, null, false);

			// Check if the field is optional
			bool bOptional = false;
			if (MatchingStrings(minOccurs, s_zeroString))
				bOptional = true;

			// Check if the field is an inline array
			bool bArray = false;
			String arraySize = null;
			if (!MatchingStrings(maxOccurs, s_emptyString) &&
				!MatchingStrings(maxOccurs, s_oneString))
			{
				if (MatchingStrings(maxOccurs, s_unboundedString))
					arraySize = String.Empty;
				else
					arraySize = maxOccurs;
				bArray = true;
			}

			// Handle anonymous types
			bool bEmbedded, bPrimitive;
			if (_XMLReader.IsEmptyElement == true)
			{
				// Non-anonymous type case
				fieldTypeName = LookupAttribute(s_typeString, null, false);

				// Handle the absense of type attribute (Object case)
				ResolveTypeAttribute(ref fieldTypeName, out fieldTypeXmlNS,
									 out bEmbedded, out bPrimitive);

				// Read next element
				ReadNextXmlElement();
			}
			else
			{
				// Anonymous type case
				fieldTypeXmlNS = parsingNamespace.Namespace;
				fieldTypeName = parsingNamespace.GetNextAnonymousName();
				bPrimitive = false;
				bEmbedded = true;
				int curDepth = _XMLReader.Depth;
				ReadNextXmlElement();

				// Parse the type
				String elementName;
				while (_XMLReader.Depth > curDepth)
				{
					elementName = _XMLReader.LocalName;
					if (MatchingStrings(elementName, s_complexTypeString))
					{
						URTComplexType complexType = ParseComplexType(parsingNamespace, fieldTypeName);
						if (complexType.IsEmittableFieldType)
						{
							fieldTypeXmlNS = complexType.FieldNamespace;
							fieldTypeName = complexType.FieldName;
							bPrimitive = complexType.PrimitiveField;
							parsingNamespace.RemoveComplexType(complexType);
						}
					}
					else if (MatchingStrings(elementName, s_simpleTypeString))
					{
						URTSimpleType simpleType = ParseSimpleType(parsingNamespace, fieldTypeName);
						if (simpleType.IsEmittableFieldType)
						{
							fieldTypeXmlNS = simpleType.FieldNamespace;
							fieldTypeName = simpleType.FieldName;
							bPrimitive = simpleType.PrimitiveField;
							parsingNamespace.RemoveSimpleType(simpleType);
						}
					}
					else
					{
						// Ignore others elements such as annotations
						SkipXmlElement();
					}
				}
			}

			// Add field to the type being parsed
			parsingComplexType.AddField(new URTField(fieldName, fieldTypeName, fieldTypeXmlNS,
													 this, bPrimitive, bEmbedded, false,
													 bOptional, bArray, arraySize, parsingNamespace));
			return;
		}

		// Parses attribute fields
		private void ParseAttributeField(URTNamespace parsingNamespace,
										 URTComplexType parsingComplexType)
		{
			Util.Log("WsdlParser.ParseAttributeField NS "+parsingNamespace);
			// Lookup field name
			String attrTypeName, attrTypeNS;
			String attrName = LookupAttribute(s_nameString, null, true);

			// Check if the field is optional
			bool bOptional = false;
			String minOccurs = LookupAttribute(s_minOccursString, null, false);
			if (MatchingStrings(minOccurs, s_zeroString))
				bOptional = true;

			// Handle anonymous types
			bool bEmbedded, bPrimitive;
			if (_XMLReader.IsEmptyElement == true)
			{
				// Non-anonymous type case and type has to present
				attrTypeName = LookupAttribute(s_typeString, null, true);
				ResolveTypeAttribute(ref attrTypeName, out attrTypeNS,
									 out bEmbedded, out bPrimitive);

				// Read next element
				ReadNextXmlElement();

				// Check for xsd:ID type
				if (MatchingStrings(attrTypeName, s_idString) &&
					MatchingSchemaStrings(attrTypeNS))
				{
					parsingComplexType.IsStruct = false;
					return;
				}
			}
			else
			{
				// Anonymous type case
				attrTypeNS = parsingNamespace.Namespace;
				attrTypeName = parsingNamespace.GetNextAnonymousName();
				bPrimitive = false;
				bEmbedded = true;
				int curDepth = _XMLReader.Depth;
				ReadNextXmlElement();

				// Parse the type
				String elementName;
				while (_XMLReader.Depth > curDepth)
				{
					elementName = _XMLReader.LocalName;
					if (MatchingStrings(elementName, s_simpleTypeString))
					{
						URTSimpleType simpleType = ParseSimpleType(parsingNamespace, attrTypeName);
						if (simpleType.IsEmittableFieldType)
						{
							attrTypeNS = simpleType.FieldNamespace;
							attrTypeName = simpleType.FieldName;
							bPrimitive = simpleType.PrimitiveField;
							parsingNamespace.RemoveSimpleType(simpleType);
						}
					}
					else
					{
						// Ignore others elements such as annotations
						SkipXmlElement();
					}
				}
			}

			// Add field to the type being parsed
			parsingComplexType.AddField(new URTField(attrName, attrTypeName, attrTypeNS,
													 this, bPrimitive, bEmbedded, true,
													 bOptional, false, null, parsingNamespace));
			return;
		}


		// Parses RestrictionField fields
		// Now only set up to recognize arrays
		private void ParseRestrictionField(URTNamespace parsingNamespace,
										   BaseType parsingType)
		{
			Util.Log("WsdlParser.ParseRestrictionField Enter NS "+parsingNamespace+" type "+parsingType);
			// Lookup field name

			String attrName = LookupAttribute(s_baseString, null, true);
			String baseNS = ParseQName(ref attrName, parsingNamespace);
			//if (MatchingStrings(baseNS, s_soapEncodingString) && MatchingStrings(attrName, s_arrayString))
			{
				int curDepth = _XMLReader.Depth;
				ReadNextXmlElement();

				// Parse the type
				String elementName;
				String arrayNS;
				String arrayType;
				int enumFacetNum = 0;
				while (_XMLReader.Depth > curDepth)
				{
					elementName = _XMLReader.LocalName;
					Util.Log("WsdlParser.ParseRestrictionField elementName "+elementName);
					if (MatchingStrings(elementName, s_attributeString))
					{
						String refValue = LookupAttribute(s_refString, null, true);
						String refNS = ParseQName(ref refValue, parsingNamespace);
						if (MatchingStrings(refNS, s_soapEncodingString) && MatchingStrings(refValue, s_arrayTypeString))
						{
							URTComplexType parsingComplexType = (URTComplexType)parsingType;
							arrayType = LookupAttribute(s_arrayTypeString, s_wsdlNamespaceString, true);
							Util.Log("WsdlParser.ParseRestrictionField arrayType "+arrayType);
							URTNamespace arrayNamespace = null;
							arrayNS = ParseQName(ref arrayType, null, out arrayNamespace);

							parsingComplexType.AddArray(arrayType, arrayNamespace);
							//Add array to the array namespace
							arrayNamespace.AddComplexType(parsingComplexType); 
							parsingComplexType.IsPrint = false;
						}
					}
					else if (MatchingStrings(elementName, s_enumerationString))
					{
						URTSimpleType parsingSimpleType = (URTSimpleType)parsingType;
						ParseEnumeration(parsingSimpleType, enumFacetNum);
						++enumFacetNum;
					}
					else
					{
						// Ignore others elements such as annotations
						SkipXmlElement();
					}
					ReadNextXmlElement();
				}
			}
			// else
			// SkipXmlElement();

			Util.Log("WsdlParser.ParseRestrictionField Exit NS "+parsingNamespace+" type "+parsingType);
			return;
		}


		// Parses a global element declaration
		private void ParseElementDecl(URTNamespace parsingNamespace)
		{
			Util.Log("WsdlParser.ParseElementDecl");            
			// Obtain element name and its type
			String elmName = LookupAttribute(s_nameString, null, true);
			String elmNS = parsingNamespace.Name;
			String typeName = LookupAttribute(s_typeString, null, false);

			// Handle the anonymous types
			String typeNS;
			bool bEmbedded, bPrimitive;
			if (_XMLReader.IsEmptyElement == true)
			{
				// Non-anonymous type case
				// We cannot assert that the type attribute must have been present
				// due to the Object/ur-type case
				ResolveTypeAttribute(ref typeName, out typeNS, out bEmbedded, out bPrimitive);

				// Position to the next element
				ReadNextXmlElement();
			}
			else
			{
				// Anonymous type case
				typeNS = parsingNamespace.Name;
				typeName = parsingNamespace.GetNextAnonymousName();
				bEmbedded = true;
				bPrimitive = false;

				// Parse the type
				int curDepth = _XMLReader.Depth;
				ReadNextXmlElement();
				String elementName;
				while (_XMLReader.Depth > curDepth)
				{
					elementName = _XMLReader.LocalName;
					if (MatchingStrings(elementName, s_complexTypeString))
					{
						ParseComplexType(parsingNamespace, typeName);
					}
					else if (MatchingStrings(elementName, s_simpleTypeString))
					{
						ParseSimpleType(parsingNamespace, typeName);
					}
					else
					{
						// Ignore others elements such as annotations
						SkipXmlElement();
					}
				}
			}

			// Create a new global element under the current namespace
			parsingNamespace.AddElementDecl(new ElementDecl(elmName, elmNS, typeName, typeNS,
															bPrimitive));

			return;
		}

		// Checks for reference and array types and resolves to
		// actual types. It returns true if the type needs [Embedded] attribute
		private void ResolveTypeNames(ref String typeNS, ref String typeName,
									  out bool bEmbedded, out bool bPrimitive)
		{
			Util.Log("WsdlParser.ResolveTypeNames typeNS "+typeNS+" typeName "+typeName);           
			// Check for reference and array types
			bEmbedded = true;
			bool bArrayType = false;
			if (MatchingStrings(typeNS, s_wsdlSoapNamespaceString))
			{
				if (MatchingStrings(typeName, s_referenceString))
					bEmbedded = false;
				else if (MatchingStrings(typeName, s_arrayString))
					bArrayType = true;
			}

			Util.Log("WsdlParser.ResolveTypeNames typeNS 1 bEmbedded "+bEmbedded+" bArrayType "+bArrayType);
			// Resolve to the actual type in the case of reference and array types
			if ((bEmbedded == false) || (bArrayType == true))
			{
				typeName = LookupAttribute(s_refTypeString, s_wsdlSudsNamespaceString, true);
				typeNS = ParseQName(ref typeName);
			}

			// Primitive types do not need the [Embedded] attribute;
			bPrimitive = IsPrimitiveType(typeNS, typeName);
			if (bPrimitive)
			{
				typeName = MapSchemaTypesToCSharpTypes(typeName);
				bEmbedded = false;
			}
			else if (MatchingStrings(typeName, s_urTypeString) &&
					 MatchingSchemaStrings(typeNS))
			{
				typeName = s_objectString;
			}

			return;
		}

		// Parses namespace declaration elements
		private URTNamespace ParseNamespace()
		{
			Util.Log("WsdlParser.ParseNamespace");          
			// Determine the new namespace encountered
			String name = (String) LookupAttribute(s_targetNamespaceString, null, false);
			bool bUnique = false;
			if (MatchingStrings(name, s_emptyString) &&
				MatchingStrings(_XMLReader.LocalName, s_sudsString) &&
				_parsingInput.UniqueNS == null)
			{
				name = _parsingInput.TargetNS;
				bUnique = true;
			}

			// Add the namespace being parsed to the list if neccessary
			URTNamespace parsingNamespace = LookupNamespace(name);
			if (parsingNamespace == null)
			{
				parsingNamespace = new URTNamespace(name, this);
			}
			if (bUnique)
				_parsingInput.UniqueNS = parsingNamespace;
			//_namespaceStack = NamespaceStack.Push(_namespaceStack, _parsingNamespace, _XMLReader.Depth);

			// Parse schema defaults
			//if(MatchingStrings(_XMLReader.LocalName, s_sudsString))
			//{

			//}

			// Read the next record
			ReadNextXmlElement();

			return(parsingNamespace);
		}

		/*
		private void AddToNamespace(String name)
		{
		URTNamespace parsingNamespace = LookupNamespace(name);
		if(parsingNamespace == null)
		{
		parsingNamespace = new URTNamespace(name, this);
		_URTNamespaces.Add(parsingNamespace);
		}
		}
		 */

		private void ParseReaderStreamLocation(ReaderStream reader, ReaderStream currentReaderStream)
		{
			Util.Log("WsdlParser.ParseReaderStreamLocation location "+reader.Location+" current location "+currentReaderStream.Location);           
			String location = reader.Location;
			int index = location.IndexOf(':');
			if (index == -1)
			{
				// relative path
				if (currentReaderStream == null || currentReaderStream.Location == null)
					throw new SUDSParserException(String.Format(CoreChannel.GetResourceString("Remoting_Suds_Import"), reader.Location));

				if (currentReaderStream.Uri == null)
					currentReaderStream.Uri= new Uri(currentReaderStream.Location);	// If relative path, will already be changed to absolute path by next statement in previous invocation.
				Uri uri = new Uri(currentReaderStream.Uri, location);
				reader.Uri= uri;
				location = uri.ToString();
				index = location.IndexOf(':');
				if (index == -1)
					return;
				reader.Location= location;
			}

			String protocol = location.Substring(0, index).ToLower(CultureInfo.InvariantCulture);
			String value = location.Substring(index+1);
			if (protocol == "file")
			{
				//Console.WriteLine("Loading file:" + value);
				reader.InputStream = new StreamReader(value);
			}
			else if (protocol.StartsWith("http"))
			{
				Util.Log("WsdlParser.ParseReaderStreamLocation http "+location);
				WebRequest request = WebRequest.Create(location);
				WebResponse response = request.GetResponse();
				Stream responseStream = response.GetResponseStream();
				reader.InputStream = new StreamReader(responseStream);
			}
		}

		private void ParseImport()
		{
			Util.Log("WsdlParser.ParseImport");         
			String ns = LookupAttribute(s_namespaceString, null, true);
			String location = null;
			location = LookupAttribute(s_locationString, null, false); //wsdl

			Util.Log("WsdlParser.ParseImport "+ns+" location "+location);         
			if (location != null && location.Length > 0)
			{
				ReaderStream reader = new ReaderStream(location);
				ParseReaderStreamLocation(reader, (ReaderStream)_currentReaderStack.Peek());
				ReaderStream.GetReaderStream(_readerStreamsWsdl, reader);
			}
			ReadNextXmlElement();
			return;
		}

		internal void Parse()
		{
			Util.Log("WsdlParser.Parse");                       
			//XmlNameTable primedNametable = CreatePrimedNametable();
			ReaderStream input = _readerStreamsWsdl;
			do
			{
				// Initialize the parser
				_XMLReader = new XmlTextReader(input.InputStream, _primedNametable);
				_XMLReader.WhitespaceHandling = WhitespaceHandling.None;
				_XMLReader.XmlResolver = null;
				ParseInput(input);
				input = ReaderStream.GetNextReaderStream(input);
			} while (input != null);

			StartWsdlResolution();

			if (null != _writerStreams)
			{
				WriterStream.Close(_writerStreams);
			}

			return;
		}

		// Starts the parser
		private void ParseInput(ReaderStream input)
		{
			Util.Log("WsdlParser.ParseInput "+input.Location);                                  
			_parsingInput = input;
			try
			{
				ReadNextXmlElement();
				String elementName = _XMLReader.LocalName;
				if (MatchingNamespace(s_wsdlNamespaceString) && MatchingStrings(elementName, s_definitionsString))
				{
					Util.Log("WsdlParser.ParseInput before ParseWsdl "+input.Location);
					_currentReaderStack.Push(input); // need this to get the base url for relative import elements.
					ParseWsdl();
					_currentReaderStack.Pop(); // need this to get the base url for relative import elements.
				}
				else if (MatchingNamespace(s_wsdlNamespaceString) && MatchingStrings(elementName, s_typesString))
				{
					Util.Log("WsdlParser.ParseInput before ParseWsdlTypes "+input.Location);
					_currentReaderStack.Push(input); // need this to get the base url for relative import elements.
					ParseWsdlTypes();
					_currentReaderStack.Pop(); // need this to get the base url for relative import elements.
				}

				else if (MatchingSchemaNamespace() && MatchingStrings(elementName, s_schemaString))
				{
					Util.Log("WsdlParser.ParseInput before ParseWsdl "+input.Location);
					_currentReaderStack.Push(input); // need this to get the base url for relative import elements.
					ParseSchema();
					_currentReaderStack.Pop(); // need this to get the base url for relative import elements.
				}
				else
					throw new SUDSParserException(String.Format(CoreChannel.GetResourceString("Remoting_Suds_UnknownElementAtRootLevel"), elementName));
			}
			finally
			{
				WriterStream.Flush(_writerStreams);
			}

		}

		private void ParseWsdl()
		{
			Util.Log("WsdlParser.ParseWsdl elementName "+_XMLReader.LocalName+" namespace "+ _XMLReader.NamespaceURI);
			int curDepth = _XMLReader.Depth;            
			_parsingInput.Name = LookupAttribute(s_nameString, null, false);
			_parsingInput.TargetNS = LookupAttribute(s_targetNamespaceString, null, false);

			URTNamespace parsingNamespace = ParseNamespace();           

			//ReadNextXmlElement();
			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;
				Util.Log("WsdlParser.ParseWsdl Loop "+_XMLReader.LocalName);
				if (MatchingNamespace(s_wsdlNamespaceString))
				{
					if (MatchingStrings(elementName,s_typesString))
					{
						ParseWsdlTypes();
						continue;
					}
					else if (MatchingStrings(elementName,s_messageString))
					{
						ParseWsdlMessage();
						continue;
					}
					else if (MatchingStrings(elementName,s_portTypeString))
					{
						ParseWsdlPortType();
						continue;
					}
					else if (MatchingStrings(elementName,s_bindingString))
					{
						ParseWsdlBinding(parsingNamespace);
						continue;
					}
					else if (MatchingStrings(elementName,s_serviceString))
					{
						ParseWsdlService();
						continue;
					}
					else if (MatchingStrings(elementName, s_importString))
					{
						ParseImport();
						continue;
					}
				}
				// Ignore others elements such as annotations
				SkipXmlElement();
			}


		}

		private void StartWsdlResolution()
		{
			Util.Log("WsdlParser.StartWsdlResolution ");                                  
			DumpWsdl();
			ResolveWsdl();
			Resolve();
			PruneNamespaces();
			Util.Log("WsdlParser.ParseWsdl Invoke PrintCSC");                       
			PrintCSC();
		}

		// Since the Wsdl can contains binding sections which are not Rcp,Soap, Encoded. Prune the namespaces from messages etc
		// which are not directly referenced by the Soap binding sections.
		private void PruneNamespaces()
		{
			Util.Log("WsdlParser.PruneNamespaces");       
			ArrayList tempList = new ArrayList(10);
			for (int i=0;i<_URTNamespaces.Count;i++)
			{
				URTNamespace urtNS = (URTNamespace) _URTNamespaces[i];
				if (urtNS.bReferenced)
					tempList.Add(urtNS);
			}

			_URTNamespaces = tempList;
		}

		[System.Diagnostics.Conditional("_LOGGING")]        
		private void DumpWsdl()
		{
			foreach (DictionaryEntry d in wsdlMessages)
			((IDump)d.Value).Dump();
			foreach (DictionaryEntry d in wsdlPortTypes)
			((IDump)d.Value).Dump();                    
			foreach (WsdlBinding item in wsdlBindings)
			item.Dump();
			foreach (WsdlService item in wsdlServices)
			item.Dump();            
		}

		private void ParseWsdlTypes()
		{
			Util.Log("WsdlParser.ParseWsdlTypes");                                              
			int curDepth = _XMLReader.Depth;
			ReadNextXmlElement();               

			// Initialize mechanism to support xsd import statements;
			_currentSchemaReaderStack.Push(_currentReaderStack.Peek());	// put current wsdl location as xsd location

			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;
				if (MatchingSchemaNamespace())
				{
					if (MatchingStrings(elementName, s_schemaString))
					{
						ParseSchema(); 
						if (_readerStreamsXsd != null)
						{
							// import element appeared in schema
							ParseImportedSchemaController();
						}
						continue;
					}
				}

				// Ignore others elements such as annotations
				SkipXmlElement();
			}
			_currentSchemaReaderStack.Pop();
		}


		private void ParseSchemaIncludeElement()
		{
			ParseSchemaImportElement(false);
		}

		private void ParseSchemaImportElement()
		{
			ParseSchemaImportElement(true);
		}


		// Processes an import statement in an xsd schema.
		private void ParseSchemaImportElement(bool bImport)
		{ 
			Util.Log("WsdlParser.ParseSchemaImportElement IsImport "+bImport);         
			String ns = null;
			if (bImport)
				ns = LookupAttribute(s_namespaceString, null, true);
			String location = null;
			location = LookupAttribute(s_schemaLocationString, null, false);

			Util.Log("WsdlParser.ParseSchemaImportElement "+ns+" location "+location);         
			if (location != null && location.Length > 0)
			{
				if (_readerStreamsXsd == null)
				{
					_readerStreamsXsd = new ReaderStream(location);
					ParseReaderStreamLocation(_readerStreamsXsd, (ReaderStream)_currentSchemaReaderStack.Peek()); 
				}
				else
				{
					ReaderStream reader = new ReaderStream(location);
					ParseReaderStreamLocation(reader, (ReaderStream)_currentSchemaReaderStack.Peek());
					ReaderStream.GetReaderStream(_readerStreamsWsdl, reader);
				}
			}
			ReadNextXmlElement();
			return;
		}

		// Controls the processing of the imported xsd schema.
		internal void ParseImportedSchemaController()
		{
			Util.Log("WsdlParser.ParseImportedSchemaController");  
			XmlNameTable primedNametable = CreatePrimedNametable();
			ReaderStream input = _readerStreamsXsd;
			XmlTextReader _XMLReaderWsdl = _XMLReader;
			ReaderStream _parsingInputWsdl = _parsingInput;
			do
			{
				// Initialize the parser
				_XMLReader = new XmlTextReader(input.InputStream, _primedNametable);
				_XMLReader.WhitespaceHandling = WhitespaceHandling.None;
				_XMLReader.XmlResolver = null;
				_parsingInput = input;
				ParseImportedSchema(input);
				input = ReaderStream.GetNextReaderStream(input);
			} while (input != null);
			_readerStreamsXsd = null;
			_XMLReader = _XMLReaderWsdl;
			_parsingInput = _parsingInputWsdl;
			return;
		}

		// Process the xsd schema imported from an xsd import statement
		private void ParseImportedSchema(ReaderStream input)
		{
			Util.Log("WsdlParser.ParseImportedSchema "+input.Location);                                  
			try
			{
				String elementName = _XMLReader.LocalName;
				_currentSchemaReaderStack.Push(input); // need this to get the base url for relative import elements.
				ReadNextXmlElement();               
				ParseSchema();
				_currentSchemaReaderStack.Pop(); // need this to get the base url for relative import elements.
			}
			finally
			{
				WriterStream.Flush(_writerStreams);
			}

		}


		private void ParseWsdlMessage()
		{
			Util.Log("WsdlParser.ParseWsdlMessage");
			WsdlMessage message = new WsdlMessage();
			message.name = LookupAttribute(s_nameString, null, true);
			message.nameNs = _parsingInput.TargetNS;
			int curDepth = _XMLReader.Depth; 
			ReadNextXmlElement();               
			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;

				if (MatchingStrings(elementName, s_partString))
				{
					WsdlMessagePart part = new WsdlMessagePart();
					part.name = LookupAttribute(s_nameString, null, true); 
					part.nameNs = _parsingInput.TargetNS;
					//AddToNamespace(part.nameNs);//temp
					part.element = LookupAttribute(s_elementString, null, false);
					part.typeName = LookupAttribute(s_typeString, null, false);
					if (part.element != null)
					{
						part.elementNs = ParseQName(ref part.element);
					}
					if (part.typeName != null)
					{
						part.typeNameNs = ParseQName(ref part.typeName); 
					}

					message.parts.Add(part);
					ReadNextXmlElement();
					continue;
				}

				// Ignore others elements such as annotations
				SkipXmlElement();
			}
			wsdlMessages[message.name] = message;
		}

		private void ParseWsdlPortType()
		{
			Util.Log("WsdlParser.ParseWsdlPortType");
			WsdlPortType portType = new WsdlPortType();
			portType.name = LookupAttribute(s_nameString, null, true);
			portType.nameNs = ParseQName(ref portType.name);
			int curDepth = _XMLReader.Depth; 
			ReadNextXmlElement();               
			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;

				if (MatchingStrings(elementName, s_operationString))
				{
					WsdlPortTypeOperation portTypeOperation = new WsdlPortTypeOperation();
					portTypeOperation.name = LookupAttribute(s_nameString, null, true);
					portTypeOperation.nameNs = ParseQName(ref portTypeOperation.nameNs);
					portTypeOperation.parameterOrder = LookupAttribute(s_parameterOrderString, null, false);
					ParseWsdlPortTypeOperationContent(portType, portTypeOperation);
					portType.operations.Add(portTypeOperation);
					continue;
				}

				// Ignore others elements such as annotations
				SkipXmlElement();
			}
			wsdlPortTypes[portType.name] = portType;
		}


		private void ParseWsdlPortTypeOperationContent(WsdlPortType portType, WsdlPortTypeOperation portTypeOperation)
		{ 
			Util.Log("WsdlParser.ParseWsdlPortTypeOperationContent type "+portType.name+" operationName "+portTypeOperation.name);
			int curDepth = _XMLReader.Depth; 

			ReadNextXmlElement();               
			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;

				if (MatchingStrings(elementName, s_inputString))
				{
					WsdlPortTypeOperationContent portContent = new WsdlPortTypeOperationContent();
					portContent.element = Atomize("input");
					portContent.name = LookupAttribute(s_nameString, null, false);

					if (MatchingStrings(portContent.name, s_emptyString))
					{
						portContent.name = Atomize(portTypeOperation.name+"Request");
						if (portType.sections.ContainsKey(portContent.name))
							throw new SUDSParserException(String.Format(CoreChannel.GetResourceString("Remoting_Suds_DuplicatePortTypesOperationName"), portTypeOperation.name));

						portType.sections[portContent.name] = portTypeOperation; //for request response
						portType.sections[portTypeOperation.name] = portTypeOperation; // for one way don't know yet if one way or response
					}
					else
					{
						if (portType.sections.ContainsKey(portContent.name))
							throw new SUDSParserException(String.Format(CoreChannel.GetResourceString("Remoting_Suds_DuplicatePortSectionName"), portContent.name));


						portType.sections[portContent.name] = portTypeOperation;
					}

					portContent.message = LookupAttribute(s_messageString, null, true);
					portContent.messageNs = ParseQName(ref portContent.message);
					portTypeOperation.contents.Add(portContent);
					ReadNextXmlElement();
					continue;                   
				}
				else if (MatchingStrings(elementName, s_outputString))
				{
					WsdlPortTypeOperationContent portContent = new WsdlPortTypeOperationContent();                  
					portContent.element = Atomize("output");
					portContent.name = LookupAttribute(s_nameString, null, false);
					portContent.nameNs = ParseQName(ref portContent.name);
					if (MatchingStrings(portContent.name, s_emptyString))
						portContent.name = Atomize(portTypeOperation.name+"Response");
					if (!portType.sections.ContainsKey(portContent.name))
						portType.sections[portContent.name] = portTypeOperation;
					portContent.message = LookupAttribute(s_messageString, null, true);
					portContent.messageNs = ParseQName(ref portContent.message);
					portTypeOperation.contents.Add(portContent);                    
					ReadNextXmlElement();
					continue;                   
				}

				// Ignore others elements such as annotations
				SkipXmlElement();
			}
		}


		private void ParseWsdlBinding(URTNamespace inparsingNamespace)
		{
			Util.Log("WsdlParser.ParseWsdlBinding");
			WsdlBinding binding = new WsdlBinding();
			binding.name = LookupAttribute(s_nameString, null, true);
			binding.nameNs = ParseQName(ref binding.name);
			binding.type = LookupAttribute(s_typeString, null, true);
			binding.typeNs = ParseQName(ref binding.type);
			URTNamespace parsingNamespace = LookupNamespace(binding.typeNs);
			if (parsingNamespace == null)
			{
				parsingNamespace = new URTNamespace(binding.typeNs, this); 
			}
			binding.parsingNamespace = parsingNamespace;
			bool bSoapBinding = false;
			bool bRpcBinding = false;
			bool bSoapEncoded = false;
			bool bSoapSuds = false;
			int curDepth = _XMLReader.Depth; 
			ReadNextXmlElement();               
			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;
				if (MatchingNamespace(s_wsdlSoapNamespaceString) &&
					MatchingStrings(elementName, s_bindingString))
				{
					bSoapBinding = true;
					WsdlBindingSoapBinding sb = new WsdlBindingSoapBinding();
					sb.style = LookupAttribute(s_styleString, null, true);
					if (sb.style == "rpc")
						bRpcBinding = true;

					/*
					if (sb.style == "document")
					{
						throw new SUDSParserException(
							String.Format(CoreChannel.GetResourceString("Remoting_Suds_SoapStyleNotSupported"),
										  sb.style));
					}
					*/

					sb.transport = LookupAttribute(s_transportString, null, true);
					binding.soapBinding = sb;
					ReadNextXmlElement();
					continue;                   
				}
				else if (MatchingNamespace(s_wsdlSudsNamespaceString))
				{
					bSoapSuds = true;
					if (MatchingStrings(elementName, s_classString) || MatchingStrings(elementName, s_structString))
					{
						WsdlBindingSuds suds = new WsdlBindingSuds();
						suds.elementName = elementName;
						suds.typeName = LookupAttribute(s_typeString, null, true);
						suds.ns = ParseQName(ref suds.typeName);
						suds.extendsTypeName = LookupAttribute(s_extendsString, null, false);
						String use = LookupAttribute(s_rootTypeString, null, false);
						suds.sudsUse = ProcessSudsUse(use, elementName);
						if (!MatchingStrings(suds.extendsTypeName, s_emptyString))
							suds.extendsNs = ParseQName(ref suds.extendsTypeName);
						ParseWsdlBindingSuds(suds);
						binding.suds.Add(suds);
						continue;                       
					}
					else if (MatchingStrings(elementName, s_interfaceString))
					{
						WsdlBindingSuds suds = new WsdlBindingSuds();                       
						suds.elementName = elementName;	//Atomize("interface");
						suds.typeName = LookupAttribute(s_typeString, null, true);
						suds.ns = ParseQName(ref suds.typeName);        
						String use = LookupAttribute(s_rootTypeString, null, false);
						suds.sudsUse = ProcessSudsUse(use, elementName);
						ParseWsdlBindingSuds(suds);
						binding.suds.Add(suds);
						continue;                       
					}
				}
				else if (MatchingNamespace(s_wsdlNamespaceString) &&
						 MatchingStrings(elementName, s_operationString))
				{
					WsdlBindingOperation op = new WsdlBindingOperation();
					op.name = LookupAttribute(s_nameString, null, true); 
					op.nameNs = _parsingInput.TargetNS;
					ParseWsdlBindingOperation(op, ref bRpcBinding, ref bSoapEncoded);
					binding.operations.Add(op);
					continue;                   
				}

				// Ignore others elements such as annotations
				SkipXmlElement();
			}
			if (bSoapBinding && bRpcBinding && bSoapEncoded || bSoapSuds)
				wsdlBindings.Add(binding);
		}

		private void ParseWsdlBindingSuds(WsdlBindingSuds suds)
		{
			Util.Log("WsdlParser.ParseWsdlBindingSuds");            
			int curDepth = _XMLReader.Depth; 
			ReadNextXmlElement();               
			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;

				if (MatchingStrings(elementName, s_implementsString) ||
					MatchingStrings(elementName, s_extendsString))
				{
					WsdlBindingSudsImplements impl = new WsdlBindingSudsImplements();
					impl.typeName = LookupAttribute(s_typeString, null, true);
					impl.ns = ParseQName(ref impl.typeName);
					suds.implements.Add(impl);
					ReadNextXmlElement();
					continue;                   
				}
				else if (MatchingStrings(elementName, s_nestedTypeString))
				{
					WsdlBindingSudsNestedType nestedType = new WsdlBindingSudsNestedType();
					nestedType.name = LookupAttribute(s_nameString, null, true);
					nestedType.typeName = LookupAttribute(s_typeString, null, true);
					nestedType.ns = ParseQName(ref nestedType.typeName);
					suds.nestedTypes.Add(nestedType);
					ReadNextXmlElement();
					continue;                   
				}


				// Ignore others elements such as annotations
				SkipXmlElement();
			}
		}

		private SudsUse ProcessSudsUse(String use, String elementName)
		{
			Util.Log("WsdlParser.ProcessSudsUse use enter "+use+" elementName "+elementName);            
			SudsUse sudsUse = SudsUse.Class;

			if (use == null || use.Length == 0)
				use = elementName;

			if (MatchingStrings(use, s_interfaceString))
				sudsUse = SudsUse.Interface;
			else if (MatchingStrings(use, s_classString))
				sudsUse = SudsUse.Class;
			else if (MatchingStrings(use, s_structString))
				sudsUse = SudsUse.Struct;
			else if (MatchingStrings(use, s_ISerializableString))
				sudsUse = SudsUse.ISerializable;
			else if (MatchingStrings(use, s_marshalByRefString))
				sudsUse = SudsUse.MarshalByRef;
			else if (MatchingStrings(use, s_delegateString))
				sudsUse = SudsUse.Delegate;
			else if (MatchingStrings(use, s_servicedComponentString))
				sudsUse = SudsUse.ServicedComponent;

			Util.Log("WsdlParser.ProcessSudsUse use exit "+((Enum)sudsUse).ToString());
			return sudsUse;
		}

		private void ParseWsdlBindingOperation(WsdlBindingOperation op, ref bool bRpcBinding, ref bool bSoapEncoded)
		{
			Util.Log("WsdlParser.ParseWsdlBindingOperation");                                                                                   
			int curDepth = _XMLReader.Depth; 
			bool binput = false;
			bool boutput = false;
			WsdlBindingOperationSection opSec = null;

			ReadNextXmlElement();               

			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;

				if (MatchingNamespace(s_wsdlSudsNamespaceString) && MatchingStrings(elementName, s_methodString))
				{
					op.methodAttributes = LookupAttribute(s_attributesString, null, true);
					ReadNextXmlElement();                                   
					continue;                                       
				}
				else if (MatchingNamespace(s_wsdlSoapNamespaceString) &&
						 MatchingStrings(elementName, s_operationString))
				{
					WsdlBindingSoapOperation soapOp = new WsdlBindingSoapOperation();
					soapOp.soapAction = LookupAttribute(s_soapActionString, null, false);
					soapOp.style = LookupAttribute(s_styleString, null, false);
					if (soapOp.style == "rpc")
						bRpcBinding = true;
					{
					}
					op.soapOperation = soapOp;
					ReadNextXmlElement();                                   
					continue;                   
				}
				else if (MatchingNamespace(s_wsdlNamespaceString))
				{
					if (MatchingStrings(elementName, s_inputString))
					{
						binput = true;
						opSec = ParseWsdlBindingOperationSection(op, elementName, ref bSoapEncoded);
						continue;                       
					}
					else if (MatchingStrings(elementName, s_outputString))
					{
						boutput = true;
						ParseWsdlBindingOperationSection(op, elementName, ref bSoapEncoded);
						continue;                       
					}
					else if (MatchingStrings(elementName, s_faultString))
					{
						ParseWsdlBindingOperationSection(op, elementName, ref bSoapEncoded);
						continue;                       
					}
				}

				// Ignore others elements such as annotations
				SkipXmlElement();
			}

			// if no output section then the default name is just the op name.
			if (opSec != null && binput && !boutput)
				opSec.name = op.name;


		}

		private WsdlBindingOperationSection ParseWsdlBindingOperationSection(WsdlBindingOperation op, String inputElementName, ref bool bSoapEncoded)
		{
			Util.Log("WsdlParser.ParseWsdlBindingOperationSections");
			bool breturn = false;
			WsdlBindingOperationSection opSec = new WsdlBindingOperationSection();
			op.sections.Add(opSec);
			opSec.name = LookupAttribute(s_nameString, null, false);
			if (MatchingStrings(opSec.name, s_emptyString))
			{
				if (MatchingStrings(inputElementName, s_inputString))
				{
					breturn = true;
					opSec.name = Atomize(op.name+"Request");
				}
				else if (MatchingStrings(inputElementName, s_outputString))
					opSec.name = Atomize(op.name+"Response");
			}
			opSec.elementName = inputElementName;
			int curDepth = _XMLReader.Depth; 
			ReadNextXmlElement();               
			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;
				if (MatchingNamespace(s_wsdlSoapNamespaceString))
				{
					if (MatchingStrings(elementName, s_bodyString))
					{
						WsdlBindingSoapBody soapBody = new WsdlBindingSoapBody();
						opSec.extensions.Add(soapBody);
						soapBody.parts = LookupAttribute(s_partsString, null, false);
						soapBody.use = LookupAttribute(s_useString, null, true); 
						if (soapBody.use == "encoded")
							bSoapEncoded = true;
						soapBody.encodingStyle = LookupAttribute(s_encodingStyleString, null, false);
						soapBody.namespaceUri = LookupAttribute(s_namespaceString, null, false);
						ReadNextXmlElement();
						continue;                       
					}
					else if (MatchingStrings(elementName, s_headerString))
					{
						WsdlBindingSoapHeader soapHeader = new WsdlBindingSoapHeader();
						opSec.extensions.Add(soapHeader);
						soapHeader.message = LookupAttribute(s_messageString, null, true);  
						soapHeader.messageNs = ParseQName(ref soapHeader.message);
						soapHeader.part = LookupAttribute(s_partString, null, true);
						soapHeader.use = LookupAttribute(s_useString, null, true);
						soapHeader.encodingStyle = LookupAttribute(s_encodingStyleString, null, false);
						soapHeader.namespaceUri = LookupAttribute(s_namespaceString, null, false);
						ReadNextXmlElement();
						continue;                       
					}
					else if (MatchingStrings(elementName, s_faultString))
					{
						WsdlBindingSoapFault soapFault = new WsdlBindingSoapFault();
						opSec.extensions.Add(soapFault);
						soapFault.name = LookupAttribute(s_nameString, null, true);  
						soapFault.use = LookupAttribute(s_useString, null, true);
						soapFault.encodingStyle = LookupAttribute(s_encodingStyleString, null, false);
						soapFault.namespaceUri = LookupAttribute(s_namespaceString, null, false);
						ReadNextXmlElement();
						continue;                       
					}

				}
				// Ignore others elements such as annotations
				// headerFault currently ignored
				SkipXmlElement();
			}

			// returning opSec only if a fixup might be necessary, this is the case of an input section with an empty input name
			// it will be fixed up later if there is no output section
			if (breturn)
				return opSec;
			else
				return null;
		}

		private void ParseWsdlService()
		{
			Util.Log("WsdlParser.ParseWsdlService");
			WsdlService service = new WsdlService();
			service.name = LookupAttribute(s_nameString, null, true);
			service.nameNs = ParseQName(ref service.name);
			int curDepth = _XMLReader.Depth; 
			ReadNextXmlElement();               
			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;

				if (MatchingNamespace(s_wsdlNamespaceString) &&
					MatchingStrings(elementName, s_portString))
				{
					WsdlServicePort port = new WsdlServicePort();
					port.name = LookupAttribute(s_nameString, null, true);
					port.nameNs = ParseQName(ref port.nameNs);
					port.binding = LookupAttribute(s_bindingString, null, true);
					port.bindingNs = ParseQName(ref port.binding);
					ParseWsdlServicePort(port);
					service.ports[port.binding] = port;
					continue;                   
				}

				// Ignore others elements such as annotations
				SkipXmlElement();
			}
			wsdlServices.Add(service);
		}

		private void ParseWsdlServicePort(WsdlServicePort port)
		{
			Util.Log("WsdlParser.ParseWsdlServicePort");
			int curDepth = _XMLReader.Depth; 
			ReadNextXmlElement();               
			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;
				if (MatchingNamespace(s_wsdlSoapNamespaceString) &&
					MatchingStrings(elementName, s_addressString))
				{
					if (port.locations == null)
						port.locations = new ArrayList(10);
					port.locations.Add(LookupAttribute(s_locationString, null, true));
					ReadNextXmlElement();
					continue;                   
				}

				// Ignore others elements such as annotations
				SkipXmlElement();
			}
		}

		private void RemoveUnreachableNS() 
		{
			Util.Log("WsdlParser.RemovewUnreachableNS");

			if (wsdlBindings.Count == 0)
				throw new SUDSParserException(String.Format(CoreChannel.GetResourceString("Remoting_Suds_RpcBindingsMissing")));

			foreach (WsdlBinding binding in wsdlBindings)
			{
				// Only creating classes for soap
				if (binding.soapBinding != null)
				{
					if (binding.suds != null)
					{
						bool bFirstSuds = true;
						foreach (WsdlBindingSuds suds in binding.suds)
						{
							if (MatchingStrings(suds.elementName, s_classString) || MatchingStrings(suds.elementName, s_structString))
							{
								// First Suds is the one which descibes the class for the Binding. The other subs describe additional classes
								ResolveWsdlClass(binding, suds, bFirstSuds);
								bFirstSuds = false;
							}
							else if (MatchingStrings(suds.elementName, s_interfaceString))
								ResolveWsdlInterface(binding, suds);
							else
							{
								throw new SUDSParserException(
															 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveElementInNS"),
																		   suds.elementName, s_wsdlSudsNamespaceString));
							}
						}
					}
					else
						ResolveWsdlClass(binding, null, true); // No suds, create a default class
				}
			}
		}



		private void ResolveWsdl()
		{
			Util.Log("WsdlParser.ResolveWsdl ");

			if (wsdlBindings.Count == 0)
				throw new SUDSParserException(String.Format(CoreChannel.GetResourceString("Remoting_Suds_RpcBindingsMissing")));

			foreach (WsdlBinding binding in wsdlBindings)
			{
				// Only creating classes for soap
				if (binding.soapBinding != null)
				{
					if (binding.suds != null && binding.suds.Count > 0)
					{
						bool bFirstSuds = true;
						foreach (WsdlBindingSuds suds in binding.suds)
						{
							if (MatchingStrings(suds.elementName, s_classString) || MatchingStrings(suds.elementName, s_structString))
							{
								ResolveWsdlClass(binding, suds, bFirstSuds);
								bFirstSuds = false;
							}
							else if (MatchingStrings(suds.elementName, s_interfaceString))
								ResolveWsdlInterface(binding, suds);
							else
							{
								throw new SUDSParserException(
															 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveElementInNS"),
																		   suds.elementName, s_wsdlSudsNamespaceString));
							}
						}
					}
					else
						ResolveWsdlClass(binding, null, true); // No suds, create a default class
				}
			}
		}

		private void ResolveWsdlClass(WsdlBinding binding, WsdlBindingSuds suds, bool bFirstSuds)
		{
			// bFirstSuds is true then the suds class is the class for the binding. 
			// The other suds are additional class without bindings in the same namespace.
			Util.Log("WsdlParser.ResolveWsdlClass suds "+suds);
			URTComplexType parsingComplexType;
			//URTNamespace parsingNamespace = binding.parsingNamespace;
			URTNamespace parsingNamespace;
			//URTNamespace parsingNamespace = binding.typeNs;

			if (suds != null)
			{
				Util.Log("WsdlParser.ResolveWsdlClass suds not null "+suds.elementName+" "+suds.typeName);
				// Suds
				parsingNamespace = AddNewNamespace(suds.ns);
				parsingComplexType = parsingNamespace.LookupComplexType(suds.typeName);
				if (parsingComplexType == null)
				{
					parsingComplexType = new URTComplexType(suds.typeName, parsingNamespace.Name, parsingNamespace.Namespace, parsingNamespace.EncodedNS, _blockDefault ,false, false, this, parsingNamespace);
					parsingNamespace.AddComplexType(parsingComplexType);
				}

				if (MatchingStrings(suds.elementName, s_structString))
					parsingComplexType.IsValueType = true;

				parsingComplexType.SudsUse = suds.sudsUse;

				if (suds.sudsUse == SudsUse.MarshalByRef || 
					suds.sudsUse == SudsUse.ServicedComponent
				   )
				{
					Util.Log("WsdlParser.ResolveWsdlClass MarshalByRef IsSudsType true 1 "+suds.elementName+" "+suds.typeName);
					parsingComplexType.IsSUDSType = true; 

					if (_bWrappedProxy)
						parsingComplexType.SUDSType = SUDSType.ClientProxy;
					else
						parsingComplexType.SUDSType	= SUDSType.MarshalByRef;


					if ((suds.extendsTypeName != null) && (suds.extendsTypeName.Length > 0))
					{
						URTNamespace extendsNamespace = AddNewNamespace(suds.extendsNs);                    
						/*
						if (extendsNamespace == null)
							extendsNamespace = new URTNamespace(suds.extendsTypeName, this);
							*/

						URTComplexType extendsComplexType = extendsNamespace.LookupComplexType(suds.extendsTypeName);                   
						if (extendsComplexType == null)
						{
							extendsComplexType = new URTComplexType(suds.extendsTypeName, extendsNamespace.Name, extendsNamespace.Namespace, extendsNamespace.EncodedNS, _blockDefault ,true, false, this, extendsNamespace);
							extendsNamespace.AddComplexType(extendsComplexType);
						}
						else
						{
							Util.Log("WsdlParser.ResolveWsdlClass IsSudsType true 2 "+suds.elementName+" "+suds.typeName);
							extendsComplexType.IsSUDSType = true;
						}

						if (_bWrappedProxy)
							extendsComplexType.SUDSType = SUDSType.ClientProxy;
						else
							extendsComplexType.SUDSType	= SUDSType.MarshalByRef;

						extendsComplexType.SudsUse = suds.sudsUse;

						// Only top of inheritance hierarchy is marked
						//parsingComplexType.SUDSType = SUDSType.None; 
					}
				}

				foreach (WsdlBindingSudsNestedType nestedType in suds.nestedTypes)
				{
					ResolveWsdlNestedType(binding, suds, nestedType);
				}
			}
			else
			{
				// No suds
				Util.Log("WsdlParser.ResolveWsdlClass no suds ");
				parsingNamespace = AddNewNamespace(binding.typeNs);
				String name = binding.name;
				int index = binding.name.IndexOf("Binding");
				if (index > 0)
				{
					//name = Atomize(binding.name.Substring(0,index));
					name = binding.name.Substring(0,index);
				}

				parsingComplexType = parsingNamespace.LookupComplexTypeEqual(name);
				if (parsingComplexType == null)
				{
					parsingComplexType = new URTComplexType(name, parsingNamespace.Name, parsingNamespace.Namespace, parsingNamespace.EncodedNS, _blockDefault ,true, false, this, parsingNamespace);
					parsingNamespace.AddComplexType(parsingComplexType);                    
				}
				else
				{
					Util.Log("WsdlParser.ResolveWsdlClass IsSudsType true 3 "+name);
					parsingComplexType.IsSUDSType = true;
				}
				if (_bWrappedProxy)
					parsingComplexType.SUDSType = SUDSType.ClientProxy;
				else
					parsingComplexType.SUDSType	= SUDSType.MarshalByRef;

				parsingComplexType.SudsUse = SudsUse.MarshalByRef;
			}

			// Resolve address
			parsingComplexType.ConnectURLs = ResolveWsdlAddress(binding);

			// Resolve extends and implements
			if (suds != null)
			{
				if (!MatchingStrings(suds.extendsTypeName, s_emptyString))
				{
					parsingComplexType.Extends(suds.extendsTypeName, suds.extendsNs);
				}

				foreach (WsdlBindingSudsImplements impl in suds.implements)
				parsingComplexType.Implements(impl.typeName, impl.ns, this);  
			}




			if (bFirstSuds && 
				(parsingComplexType.SudsUse == SudsUse.MarshalByRef || 
				 parsingComplexType.SudsUse == SudsUse.ServicedComponent || 
				 parsingComplexType.SudsUse == SudsUse.Delegate || 
				 parsingComplexType.SudsUse == SudsUse.Interface))
			{
				// Resolve methods

				ArrayList methodInfos = ResolveWsdlMethodInfo(binding);

				foreach (WsdlMethodInfo methodInfo in methodInfos)
				{
					if ((methodInfo.inputMethodName != null) && (methodInfo.outputMethodName != null))
					{
						RRMethod parsingRRMethod = new RRMethod(methodInfo, parsingComplexType);
						parsingRRMethod.AddRequest(methodInfo.methodName, methodInfo.methodNameNs);
						parsingRRMethod.AddResponse(methodInfo.methodName, methodInfo.methodNameNs);
						parsingComplexType.AddMethod(parsingRRMethod);
					}
					else if (methodInfo.inputMethodName != null)
					{
						OnewayMethod parsingOWMethod = new OnewayMethod(methodInfo, parsingComplexType);
						parsingComplexType.AddMethod(parsingOWMethod);
						parsingOWMethod.AddMessage(methodInfo.methodName, methodInfo.methodNameNs);
					}
					else
					{
						throw new SUDSParserException(
													 String.Format(CoreChannel.GetResourceString("Remoting_Suds_WsdlInvalidMessage"),
																   methodInfo.methodName));
					}
				}
			}
		}

		private void ResolveWsdlInterface(WsdlBinding binding, WsdlBindingSuds suds)
		{
			Util.Log("WsdlParser.ResolveWsdlInterface "+binding.name+" ns "+binding.parsingNamespace.Namespace+" suds "+suds.typeName);

			URTNamespace parsingNamespace = binding.parsingNamespace;

			URTNamespace sudsNamespace = AddNewNamespace(suds.ns);
			/*
			if (sudsNamespace == null)
			{
				sudsNamespace = new URTNamespace(suds.ns, this);
			}
			*/

			URTInterface parsingInterface = sudsNamespace.LookupInterface(suds.typeName);           
			if (parsingInterface == null)
			{
				parsingInterface = new URTInterface(suds.typeName, sudsNamespace.Name, sudsNamespace.Namespace, sudsNamespace.EncodedNS, this);
				sudsNamespace.AddInterface(parsingInterface);
			}

			if (suds.extendsTypeName != null)
			{
				parsingInterface.Extends(suds.extendsTypeName, suds.extendsNs, this);
			}
			foreach (WsdlBindingSudsImplements impl in suds.implements)
			{
				parsingInterface.Extends(impl.typeName, impl.ns, this);             
			}

			ArrayList methodInfos = ResolveWsdlMethodInfo(binding);

			foreach (WsdlMethodInfo methodInfo in methodInfos)          
			{
				if ((methodInfo.inputMethodName != null) && (methodInfo.outputMethodName != null))
				{
					RRMethod parsingRRMethod = new RRMethod(methodInfo, null);
					parsingRRMethod.AddRequest(methodInfo.methodName, methodInfo.methodNameNs);
					parsingRRMethod.AddResponse(methodInfo.methodName, methodInfo.methodNameNs);
					parsingInterface.AddMethod(parsingRRMethod);
				}
				else if (methodInfo.inputMethodName != null)
				{
					OnewayMethod parsingOWMethod = new OnewayMethod(methodInfo.methodName, methodInfo.soapAction, null);
					parsingOWMethod.AddMessage(methodInfo.methodName, methodInfo.methodNameNs);                 
					parsingInterface.AddMethod(parsingOWMethod);
				}
				else
				{
					throw new SUDSParserException(
												 String.Format(CoreChannel.GetResourceString("Remoting_Suds_WsdlInvalidMessage"),
															   methodInfo.methodName));

				}
			}
		}

		private void ResolveWsdlNestedType(WsdlBinding binding, WsdlBindingSuds suds, WsdlBindingSudsNestedType nested)
		{
			Util.Log("WsdlParser.ResolveWsdlNestedType "+binding.name+" ns "+binding.parsingNamespace.Namespace+" suds "+suds.typeName+" nestedName "+nested.name+" nestedTypeName "+nested.typeName);
			String className = suds.typeName;
			String ns = nested.ns;
			String nestedName = nested.name;
			String nestedTypeName = nested.typeName;
			if (suds.ns != ns)
			{
				throw new SUDSParserException(
											 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveNestedTypeNS"),
														   suds.typeName, suds.ns));
			}

			URTNamespace sudsNamespace = AddNewNamespace(suds.ns);

			URTComplexType outerType = sudsNamespace.LookupComplexType(suds.typeName);
			if (outerType == null)
			{
				throw new SUDSParserException(
											 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveNestedType"),
														   suds.typeName, suds.ns));
			}

			BaseType innerType = sudsNamespace.LookupType(nested.typeName);
			if (innerType == null)
			{
				// Can be URTSimpleType for Enum
				Util.Log("WsdlParser.ResolveWsdlNestedType cann't find inner type "+nested.typeName+" className "+className+" ns "+ns);

				innerType = sudsNamespace.LookupComplexType(nested.typeName);
				if (innerType == null)
				{
					innerType = new URTComplexType(nested.typeName, sudsNamespace.Name, sudsNamespace.Namespace, sudsNamespace.EncodedNS, _blockDefault ,false, false, this, sudsNamespace);
					sudsNamespace.AddComplexType((URTComplexType)innerType);
				}
			}


			innerType.bNestedType = true;
			innerType.NestedTypeName = nested.name;
			innerType.FullNestedTypeName = nested.typeName;
			innerType.OuterTypeName = suds.typeName;

			outerType.AddNestedType(innerType);
		}

		private ArrayList ResolveWsdlAddress(WsdlBinding binding)
		{
			Util.Log("WsdlParser.ResolveWsdlAddress "+binding.name);            
			ArrayList serviceEndpoints = null;
			if (_bWrappedProxy)
			{
				foreach (WsdlService service in wsdlServices)
				{
					WsdlServicePort port = (WsdlServicePort)service.ports[binding.name];
					if (port != null)
					{
						serviceEndpoints = port.locations;
						break;
					}
					if (serviceEndpoints != null)
						break;
				}
			}
			return serviceEndpoints;
		}

		private ArrayList ResolveWsdlMethodInfo(WsdlBinding binding)
		{
			Util.Log("WsdlParser.ResolveWsdlMethodInfo "+binding.name);                     
			ArrayList methodInfos = new ArrayList(10);
			Hashtable propertyMethod = new Hashtable(3);
			for (int i=0; i<binding.operations.Count; i++)
			{
				bool bGet = false;
				bool bSet = false;
				WsdlBindingOperation op = (WsdlBindingOperation)binding.operations[i];
				if (op.soapOperation != null)
				{
					WsdlMethodInfo methodInfo = new WsdlMethodInfo();
					methodInfo.methodName = op.name;
					methodInfo.methodNameNs = op.nameNs;
					methodInfo.methodAttributes = op.methodAttributes;
					AddNewNamespace(op.nameNs);
					WsdlBindingSoapOperation opSoap = (WsdlBindingSoapOperation)op.soapOperation;

					if ((methodInfo.methodName.StartsWith("get_") && methodInfo.methodName.Length > 4))
						bGet = true;
					else if ((methodInfo.methodName.StartsWith("set_") && methodInfo.methodName.Length > 4))
						bSet = true;
					if (bGet || bSet)
					{
						bool bNew = false;
						String propertyName = methodInfo.methodName.Substring(4);
						WsdlMethodInfo propertyMethodInfo = (WsdlMethodInfo)propertyMethod[propertyName];
						if (propertyMethodInfo == null)
						{
							propertyMethod[propertyName] = methodInfo;
							methodInfos.Add(methodInfo);
							propertyMethodInfo = methodInfo;
							methodInfo.propertyName = propertyName;
							methodInfo.bProperty = true;
							bNew = true;
						}

						if (bGet)
						{
							propertyMethodInfo.bGet = true;
							propertyMethodInfo.soapActionGet = opSoap.soapAction;
						}
						else
						{
							propertyMethodInfo.bSet = true;
							propertyMethodInfo.soapActionSet = opSoap.soapAction;
							//propertyMethodInfo.Dump();
						}

						if (!bNew)
							continue; //already processed this property
					}
					else
						methodInfos.Add(methodInfo);
					methodInfo.soapAction = opSoap.soapAction;

					WsdlPortType portType = (WsdlPortType)wsdlPortTypes[binding.type];

					if ((portType == null) || (portType.operations.Count != binding.operations.Count))
					{
						throw new SUDSParserException(
													 String.Format(CoreChannel.GetResourceString("Remoting_Suds_WsdlInvalidPortType"),
																   binding.type));
					}

					// PortType operations are obtained by the <binding><operation><input name = porttype operation>

					WsdlPortTypeOperation portTypeOp = null;
					foreach (WsdlBindingOperationSection opSec in op.sections)
					{
						if (MatchingStrings(opSec.elementName, s_inputString))
						{

							portTypeOp = (WsdlPortTypeOperation)portType.sections[opSec.name];

							Util.Log("WsdlParser.ResolveWsdlMethodInfo find portTypeOp 1 "+opSec.name+" portTypeOp "+portTypeOp);

							if (portTypeOp == null)
							{
								//this is for interop testing because other implementations are using the opSec.name wrong.
								// a "Request" is not being added to the end of the name.
								int index  = opSec.name.LastIndexOf("Request");
								if (index > 0)
								{
									String newOpName = opSec.name.Substring(0, index);
									portTypeOp = (WsdlPortTypeOperation)portType.sections[newOpName];
									Util.Log("WsdlParser.ResolveWsdlMethodInfo find portTypeOp 2 "+newOpName+" portTypeOp "+portTypeOp);
								}
							}

							if (portTypeOp != null && portTypeOp.parameterOrder != null && portTypeOp.parameterOrder.Length > 0)
							{
								methodInfo.paramNamesOrder = portTypeOp.parameterOrder.Split(' ');
							}

							foreach (WsdlBindingSoapBody body in opSec.extensions)
							{
								if (body.namespaceUri != null || body.namespaceUri.Length > 0)
									methodInfo.inputMethodNameNs = body.namespaceUri;
							}
						}
						else if (MatchingStrings(opSec.elementName, s_outputString))
						{
							foreach (WsdlBindingSoapBody body in opSec.extensions)
							{
								if (body.namespaceUri != null || body.namespaceUri.Length > 0)
									methodInfo.outputMethodNameNs = body.namespaceUri;
							}
						}
					}

					/*
					if (portTypeOp == null)
					{
					throw new SUDSParserException(
					String.Format(CoreChannel.GetResourceString("Remoting_Suds_WsdlInvalidPortType"),
					binding.type));
					}
*/

					if (portTypeOp != null)
					{

						foreach (WsdlPortTypeOperationContent content in portTypeOp.contents)
						{
							if (MatchingStrings(content.element, s_inputString))
							{
								methodInfo.inputMethodName = content.message;
								if (methodInfo.inputMethodNameNs == null)
									methodInfo.inputMethodNameNs = content.messageNs;
								WsdlMessage message = (WsdlMessage)wsdlMessages[content.message];
								if (message == null)
								{
									throw new SUDSParserException(
																 String.Format(CoreChannel.GetResourceString("Remoting_Suds_WsdlMissingMessage"),
																			   content.message));
								}
								else
								{
									if (message.parts != null)
									{
										methodInfo.inputNames = new String[message.parts.Count];
										methodInfo.inputNamesNs = new String[message.parts.Count];
										methodInfo.inputElements = new String[message.parts.Count];
										methodInfo.inputElementsNs = new String[message.parts.Count];
										methodInfo.inputTypes = new String[message.parts.Count];
										methodInfo.inputTypesNs = new String[message.parts.Count];
										for (int ip=0; ip<message.parts.Count; ip++)
										{
											methodInfo.inputNames[ip] = ((WsdlMessagePart)message.parts[ip]).name;
											methodInfo.inputNamesNs[ip] = ((WsdlMessagePart)message.parts[ip]).nameNs;
											AddNewNamespace(methodInfo.inputNamesNs[ip]);
											methodInfo.inputElements[ip] = ((WsdlMessagePart)message.parts[ip]).element;
											methodInfo.inputElementsNs[ip] = ((WsdlMessagePart)message.parts[ip]).elementNs;
											AddNewNamespace(methodInfo.inputElementsNs[ip]);
											methodInfo.inputTypes[ip] = ((WsdlMessagePart)message.parts[ip]).typeName;
											methodInfo.inputTypesNs[ip] = ((WsdlMessagePart)message.parts[ip]).typeNameNs;
											AddNewNamespace(methodInfo.inputTypesNs[ip]);
											if (methodInfo.bProperty && methodInfo.inputTypes[ip] != null && methodInfo.propertyType == null)
											{
												methodInfo.propertyType = methodInfo.inputTypes[ip];
												methodInfo.propertyNs = methodInfo.inputTypesNs[ip];
												AddNewNamespace(methodInfo.propertyNs);
											}

										}
									}
								}
							}
							else if (MatchingStrings(content.element, s_outputString))
							{
								methodInfo.outputMethodName = content.message;
								if (methodInfo.outputMethodNameNs == null)
									methodInfo.outputMethodNameNs = content.messageNs;
								WsdlMessage message = (WsdlMessage)wsdlMessages[content.message];
								if (message == null)
								{
									throw new SUDSParserException(
																 String.Format(CoreChannel.GetResourceString("Remoting_Suds_WsdlMissingMessage"),
																			   content.message));
								}
								else
								{
									if (message.parts != null)
									{
										methodInfo.outputNames = new String[message.parts.Count];
										methodInfo.outputNamesNs = new String[message.parts.Count];
										methodInfo.outputElements = new String[message.parts.Count];
										methodInfo.outputElementsNs = new String[message.parts.Count];
										methodInfo.outputTypes = new String[message.parts.Count];
										methodInfo.outputTypesNs = new String[message.parts.Count];
										for (int ip=0; ip<message.parts.Count; ip++)
										{
											methodInfo.outputNames[ip] = ((WsdlMessagePart)message.parts[ip]).name;
											methodInfo.outputNamesNs[ip] = ((WsdlMessagePart)message.parts[ip]).nameNs;
											AddNewNamespace(methodInfo.outputNamesNs[ip]);
											methodInfo.outputElements[ip] = ((WsdlMessagePart)message.parts[ip]).element;
											methodInfo.outputElementsNs[ip] = ((WsdlMessagePart)message.parts[ip]).elementNs;
											AddNewNamespace(methodInfo.outputElementsNs[ip]);
											methodInfo.outputTypes[ip] = ((WsdlMessagePart)message.parts[ip]).typeName;
											methodInfo.outputTypesNs[ip] = ((WsdlMessagePart)message.parts[ip]).typeNameNs;
											AddNewNamespace(methodInfo.outputTypesNs[ip]);
											if (methodInfo.bProperty && methodInfo.outputTypes[ip] != null && methodInfo.propertyType == null)
											{
												methodInfo.propertyType = methodInfo.outputTypes[ip];
												methodInfo.propertyNs = methodInfo.outputTypesNs[ip];
												AddNewNamespace(methodInfo.outputTypesNs[ip]);
											}
										}
									}
								}
							}
							else
								throw new SUDSParserException(
															 String.Format(CoreChannel.GetResourceString("Remoting_Suds_WsdlInvalidPortType"),
																		   content.element));
						}
						methodInfo.Dump();
					} //no porttype
				}
			}
			return methodInfos;
		}

		// Parse Schema
		private void ParseSchema()
		{
			Util.Log("WsdlParser.ParseSchema");                                 
			// Remember the current depth
			int curDepth = _XMLReader.Depth;

			// Parse the target namespace first
			URTNamespace parsingNamespace = ParseNamespace();

			// Parse schema elements
			while (_XMLReader.Depth > curDepth)
			{
				String elementName = _XMLReader.LocalName;
				//if (MatchingSchemaNamespace())
				{

					if (MatchingStrings(elementName, s_complexTypeString))
						ParseComplexType(parsingNamespace, null);
					else if (MatchingStrings(elementName, s_simpleTypeString))
						ParseSimpleType(parsingNamespace, null);
					else if (MatchingStrings(elementName, s_schemaString))
						ParseSchema();
					else if (MatchingStrings(elementName, s_elementString))
						ParseElementDecl(parsingNamespace);
					else if (MatchingStrings(elementName, s_importString))
						ParseSchemaImportElement();
					else if (MatchingStrings(elementName, s_includeString))
						ParseSchemaIncludeElement();
					else
						goto SkipXMLNode;

					continue;
				}

				SkipXMLNode:
				// Ignore others elements such as annotations
				SkipXmlElement();
			}

			return;
		}


		// Resolves internal references
		private void Resolve()
		{
			Util.Log("WsdlParser.Resolve");                                 
			for (int i=0;i<_URTNamespaces.Count;i++)
				((URTNamespace)_URTNamespaces[i]).ResolveElements(this);

			for (int i=0;i<_URTNamespaces.Count;i++)
				((URTNamespace)_URTNamespaces[i]).ResolveTypes(this);

			for (int i=0;i<_URTNamespaces.Count;i++)
				((URTNamespace)_URTNamespaces[i]).ResolveMethods();
		}

		// Lookup a given attribute position.
		// Note that the supplied strings must have been atomized
		private String LookupAttribute(String attrName, String attrNS, bool throwExp)
		{
			Util.Log("WsdlParser.LookupAttribute Enter "+attrName+", NS "+attrNS+", Exp "+throwExp);                                    
			String value = s_emptyString;
			bool bPresent;
			if (attrNS != null)
				bPresent = _XMLReader.MoveToAttribute(attrName, attrNS);
			else
				bPresent = _XMLReader.MoveToAttribute(attrName);

			if (bPresent)
				value = Atomize(_XMLReader.Value.Trim());
			_XMLReader.MoveToElement();

			if ((bPresent == false) && (throwExp == true))
			{
				throw new SUDSParserException(
											 String.Format(CoreChannel.GetResourceString("Remoting_Suds_AttributeNotFound"),
														   attrName, XMLReader.LineNumber, XMLReader.LinePosition, XMLReader.Name));
			}
			Util.Log("WsdlParser.LookupAttribute exit "+attrName+"="+value+", NS "+attrNS+", Exp "+throwExp);                                    
			return(value);
		}

		// Resolves type attribute into its constituent parts
		private void ResolveTypeAttribute(ref String typeName, out String typeNS,
										  out bool bEmbedded, out bool bPrimitive)
		{
			Util.Log("WsdlParser.ResolveTypeAttribute typeName "+typeName);                                 
			if (MatchingStrings(typeName, s_emptyString))
			{
				typeName = s_objectString;
				typeNS = SchemaNamespaceString;
				bEmbedded = true;
				bPrimitive = false;
			}
			else
			{
				// The type field is a QName
				typeNS = ParseQName(ref typeName);

				// Check for reference and array types
				ResolveTypeNames(ref typeNS, ref typeName, out bEmbedded, out bPrimitive);
			}

			return;
		}

		// Parses a qname

		private String ParseQName(ref String qname)
		{
			return ParseQName(ref qname, null);
		}
		private String ParseQName(ref String qname, URTNamespace defaultNS)
		{
			URTNamespace returnNS = null;
			return ParseQName( ref qname, defaultNS, out returnNS);
		}

		private String ParseQName(ref String qname, URTNamespace defaultNS, out URTNamespace returnNS)
		{
			Util.Log("WsdlParser.ParseQName Enter qname "+qname+" default xmlns NS "+_XMLReader.LookupNamespace(""));

			String ns = null;
			returnNS = null;
			if ((qname == null) || (qname.Length == 0))
			{
				Util.Log("WsdlParser.ParseQName Exit null");
				return null;
			}

			int colonIndex = qname.IndexOf(":");
			if (colonIndex == -1)
			{
				// The default namespace is the s_empty string (this will need to change)
				//textWriter.WriteLine("DefaultNS: " + _XMLReader.LookupNamespace(s_emptyString) + '\n' +
				//                     "ElementNS: " + _XMLReader.Namespace);
				// Should this be element namespace or default namespace
				// For attributes names, element namespace makes more sense
				// For QName values, default namespace makes more sense
				// I am currently returning default namespace

				returnNS = defaultNS;
				if (defaultNS == null)
				{
					Util.Log("WsdlParser.ParseQName Exit defaultNS qname "+qname);          
					ns = _XMLReader.LookupNamespace("");
				}
				else
				{
					Util.Log("WsdlParser.ParseQName Exit defaultNS qname "+qname+" default "+defaultNS.Name);          
					ns = defaultNS.Name;
				}

			}
			else
			{
				// Get the suffix and atmoize it
				String prefix = qname.Substring(0, colonIndex);
				qname = Atomize(qname.Substring(colonIndex+1));
				ns = _XMLReader.LookupNamespace(prefix);
			}

			if (ns == null)
				PrintNode(Console.Out);
			ns = Atomize(ns);

			URTNamespace xns = LookupNamespace(ns);

			if (xns == null)
			{
				xns = new URTNamespace(ns, this);
			}


			returnNS = xns;

			Util.Log("WsdlParser.ParseQName Exit qname "+qname+" typeString "+ns+" returnNS "+(returnNS == null?"null":returnNS.Name));          
			return(ns);
		}

		// Returns true if the type needs to be qualified with namespace
		private bool Qualify(String typeNS, String curNS)
		{
			Util.Log("WsdlParser.Qualify typeNS "+typeNS+" curNS "+curNS);                                  
			if (MatchingSchemaStrings(typeNS) ||
				MatchingStrings(typeNS, s_soapNamespaceString) ||
				MatchingStrings(typeNS, s_wsdlSoapNamespaceString) ||               
				MatchingStrings(typeNS, "System") ||
				MatchingStrings(typeNS, curNS))
				return(false);

			return(true);
		}

		// Returns true if the current element node namespace has matching namespace
		private bool MatchingNamespace(String elmNS)
		{
			Util.Log("WsdlParser.MatchingNamespace "+elmNS+" ***** "+_XMLReader.NamespaceURI);                                              
			if (MatchingStrings(_XMLReader.NamespaceURI, elmNS))
				// ||
				//   MatchingStrings(_XMLReader.Prefix, s_emptyString))
				return(true);

			return(false);
		}

		private bool MatchingSchemaNamespace()
		{
			Util.Log("WsdlParser.MatchingSchemaNamespace ");
			if (MatchingNamespace(s_schemaNamespaceString))
				return true;
			else if (MatchingNamespace(s_schemaNamespaceString1999))
			{
				_xsdVersion = XsdVersion.V1999;
				return true;
			}
			else if (MatchingNamespace(s_schemaNamespaceString2000))
			{
				_xsdVersion = XsdVersion.V2000;
				return true;
			}
			else if (MatchingNamespace(s_schemaNamespaceString))
			{
				_xsdVersion = XsdVersion.V2001;
				return true;
			}
			else
			{
				return false;
			}
		}

		static StringBuilder vsb = new StringBuilder();
		internal static string IsValidUrl(string value)
		{
			if (value == null)
			{
				return "\"\"";
			}

			vsb.Length= 0;
			vsb.Append("@\"");

			for (int i=0; i<value.Length; i++)
			{
				if (value[i] == '\"')
					vsb.Append("\"\"");
				else
					vsb.Append(value[i]);
			}

			vsb.Append("\"");
			return vsb.ToString();
		}


		static Hashtable cSharpKeywords;
		static bool IsCSharpKeyword(string value) 
		{
			if (cSharpKeywords == null)	InitKeywords();
			return cSharpKeywords.ContainsKey(value);
		}

		static void InitKeywords() 
		{
			// build the cSharpKeywords hashtable
			Hashtable cSharpKeywordstemp = new Hashtable(75); // about 75 cSharpKeywords to be added
			Object obj = new Object();
			cSharpKeywordstemp["abstract"] = obj;
			cSharpKeywordstemp["base"] = obj;
			cSharpKeywordstemp["bool"] = obj;
			cSharpKeywordstemp["break"] = obj;
			cSharpKeywordstemp["byte"] = obj;
			cSharpKeywordstemp["case"] = obj;
			cSharpKeywordstemp["catch"] = obj;
			cSharpKeywordstemp["char"] = obj;
			cSharpKeywordstemp["checked"] = obj;
			cSharpKeywordstemp["class"] = obj;
			cSharpKeywordstemp["const"] = obj;
			cSharpKeywordstemp["continue"] = obj;
			cSharpKeywordstemp["decimal"] = obj;
			cSharpKeywordstemp["default"] = obj;
			cSharpKeywordstemp["delegate"] = obj;
			cSharpKeywordstemp["do"] = obj;
			cSharpKeywordstemp["double"] = obj;
			cSharpKeywordstemp["else"] = obj;
			cSharpKeywordstemp["enum"] = obj;
			cSharpKeywordstemp["event"] = obj;
			cSharpKeywordstemp["exdouble"] = obj;
			cSharpKeywordstemp["exfloat"] = obj;
			cSharpKeywordstemp["explicit"] = obj;
			cSharpKeywordstemp["extern"] = obj;
			cSharpKeywordstemp["false"] = obj;
			cSharpKeywordstemp["finally"] = obj;
			cSharpKeywordstemp["fixed"] = obj;
			cSharpKeywordstemp["float"] = obj;
			cSharpKeywordstemp["for"] = obj;
			cSharpKeywordstemp["foreach"] = obj;
			cSharpKeywordstemp["goto"] = obj;
			cSharpKeywordstemp["if"] = obj;
			cSharpKeywordstemp["implicit"] = obj;
			cSharpKeywordstemp["in"] = obj;
			cSharpKeywordstemp["int"] = obj;
			cSharpKeywordstemp["interface"] = obj;
			cSharpKeywordstemp["internal"] = obj;
			cSharpKeywordstemp["is"] = obj;
			cSharpKeywordstemp["lock"] = obj;
			cSharpKeywordstemp["long"] = obj;
			cSharpKeywordstemp["namespace"] = obj;
			cSharpKeywordstemp["new"] = obj;
			cSharpKeywordstemp["null"] = obj;
			cSharpKeywordstemp["object"] = obj;
			cSharpKeywordstemp["operator"] = obj;
			cSharpKeywordstemp["out"] = obj;
			cSharpKeywordstemp["override"] = obj;
			cSharpKeywordstemp["private"] = obj;
			cSharpKeywordstemp["protected"] = obj;
			cSharpKeywordstemp["public"] = obj;
			cSharpKeywordstemp["readonly"] = obj;
			cSharpKeywordstemp["ref"] = obj;
			cSharpKeywordstemp["return"] = obj;
			cSharpKeywordstemp["sbyte"] = obj;
			cSharpKeywordstemp["sealed"] = obj;
			cSharpKeywordstemp["short"] = obj;
			cSharpKeywordstemp["sizeof"] = obj;
			cSharpKeywordstemp["static"] = obj;
			cSharpKeywordstemp["string"] = obj;
			cSharpKeywordstemp["struct"] = obj;
			cSharpKeywordstemp["switch"] = obj;
			cSharpKeywordstemp["this"] = obj;
			cSharpKeywordstemp["throw"] = obj;
			cSharpKeywordstemp["true"] = obj;
			cSharpKeywordstemp["try"] = obj;
			cSharpKeywordstemp["typeof"] = obj;
			cSharpKeywordstemp["uint"] = obj;
			cSharpKeywordstemp["ulong"] = obj;
			cSharpKeywordstemp["unchecked"] = obj;
			cSharpKeywordstemp["unsafe"] = obj;
			cSharpKeywordstemp["ushort"] = obj;
			cSharpKeywordstemp["using"] = obj;
			cSharpKeywordstemp["virtual"] = obj;
			cSharpKeywordstemp["void"] = obj;
			cSharpKeywordstemp["while"] = obj;
			cSharpKeywords = cSharpKeywordstemp;
		}



		static bool IsValidLanguageIndependentIdentifier(string ident)
		{
			for (int i=0; i<ident.Length; i++)
			{
				char c = ident[i];
				UnicodeCategory uc = Char.GetUnicodeCategory(c);
				// each char must be Lu, Ll, Lt, Lm, Lo, Nd, Mn, Mc, Pc
				// 
				switch (uc)
				{
				case UnicodeCategory.UppercaseLetter:		 // Lu
				case UnicodeCategory.LowercaseLetter:		 // Ll
				case UnicodeCategory.TitlecaseLetter:		 // Lt
				case UnicodeCategory.ModifierLetter:		 // Lm
				case UnicodeCategory.OtherLetter:			 // Lo
				case UnicodeCategory.DecimalDigitNumber:	 // Nd
				case UnicodeCategory.NonSpacingMark:		 // Mn
				case UnicodeCategory.SpacingCombiningMark:	 // Mc
				case UnicodeCategory.ConnectorPunctuation:	 // Pc
					break;
				case UnicodeCategory.LetterNumber:
				case UnicodeCategory.OtherNumber:
				case UnicodeCategory.EnclosingMark:
				case UnicodeCategory.SpaceSeparator:
				case UnicodeCategory.LineSeparator:
				case UnicodeCategory.ParagraphSeparator:
				case UnicodeCategory.Control:
				case UnicodeCategory.Format:
				case UnicodeCategory.Surrogate:
				case UnicodeCategory.PrivateUse:
				case UnicodeCategory.DashPunctuation:
				case UnicodeCategory.OpenPunctuation:
				case UnicodeCategory.ClosePunctuation:
				case UnicodeCategory.InitialQuotePunctuation:
				case UnicodeCategory.FinalQuotePunctuation:
				case UnicodeCategory.OtherPunctuation:
				case UnicodeCategory.MathSymbol:
				case UnicodeCategory.CurrencySymbol:
				case UnicodeCategory.ModifierSymbol:
				case UnicodeCategory.OtherSymbol:
				case UnicodeCategory.OtherNotAssigned:
					return false;
				default:
					return false;
				}
			}
			return true;
		}


		internal static void CheckValidIdentifier(string ident)
		{
			if (!IsValidLanguageIndependentIdentifier(ident))
				throw new SUDSParserException(
											 String.Format(CoreChannel.GetResourceString("Remoting_Suds_WsdlInvalidStringSyntax"),
														   ident));
		}

		// Used when identifier appears in a custom attribute. Need to strip out leading @ for keyword
		internal static string IsValidCSAttr(string identifier)
		{
			string returnstr = IsValidCS(identifier);
			if (returnstr.Length > 0 && returnstr[0] == '@')
				return returnstr.Substring(1);
			else return returnstr;
		}

		internal static string IsValidCS(string identifier) {
			if (identifier == null || identifier.Length == 0 || identifier == " ") return identifier;
			string originalIdentifier = identifier;
			int index = identifier.IndexOf('[');
			string arraybrackets = null;
			if (index > -1)
			{
				arraybrackets = identifier.Substring(index);
				identifier = identifier.Substring(0,index);
				// Check arraybrackets
				for (int i=0; i<arraybrackets.Length; i++)
				{
					switch (arraybrackets[i])
					{
					case '[':
					case ']':
					case ',':
					case ' ':
						break;
					default:
						throw new SUDSParserException(
													 String.Format(CoreChannel.GetResourceString("Remoting_Suds_WsdlInvalidStringSyntax"),
																   identifier));
					}
				}
			}

			string[] names = identifier.Split(new char[]{'.'});
			bool newIdent = false;
			StringBuilder sb = new StringBuilder();

			for (int i = 0; i < names.Length; i++)
			{
				if (i > 0) sb.Append(".");
				if (IsCSharpKeyword(names[i]))
				{
					sb.Append("@");
					newIdent = true;
				}
				CheckValidIdentifier(names[i]);
				sb.Append(names[i]);
			}

			if (newIdent)
			{
				if (arraybrackets != null)
					sb.Append(arraybrackets);
				return sb.ToString();
			}
			return originalIdentifier;
		}


		// Returns true if the atomized strings match
		private static bool MatchingStrings(String left, String right)
		{
			//Util.Log("WsdlParser.MatchingStrings left "+left+" right "+right);
			return((Object) left == (Object) right);
		}

		private bool MatchingSchemaStrings(String left)
		{
			Util.Log("WsdlParser.MatchingSchemaStrings left "+left+" _xsdVersion "+((Enum)_xsdVersion).ToString());

			if (MatchingStrings(left, s_schemaNamespaceString1999))
			{
				_xsdVersion = XsdVersion.V1999;
				return true;
			}
			else if (MatchingStrings(left, s_schemaNamespaceString2000))
			{
				_xsdVersion = XsdVersion.V2000;
				return true;
			}
			else if (MatchingStrings(left, s_schemaNamespaceString))
			{
				_xsdVersion = XsdVersion.V2001;
				return true;
			}
			else
				return false;
		}

		private bool MatchingSchemaInstanceStrings(String left)
		{
			if (MatchingStrings(left, s_instanceNamespaceString1999))
			{
				_xsdVersion = XsdVersion.V1999;
				return true;
			}
			else if (MatchingStrings(left, s_instanceNamespaceString2000))
			{
				_xsdVersion = XsdVersion.V2000;
				return true;
			}
			else if (MatchingStrings(left, s_instanceNamespaceString))
			{
				_xsdVersion = XsdVersion.V2001;
				return true;
			}
			else
				return false;
		}



		// Atmozie the given string
		internal String Atomize(String str)
		{
			// Always atmoize using the table defined on the
			// current XML parser
			return(_XMLReader.NameTable.Add(str));
		}

		// Maps URT types to cool types
		private String MapSchemaTypesToCSharpTypes(String xsdType)
		{
			Util.Log("SudsConverter.MapSchemaTypesToCSharpTypes Enter  "+xsdType);
			String stype = xsdType; 
			int index = xsdType.IndexOf('[');
			if (index != -1)
				stype = xsdType.Substring(0, index);

			String clrType = SudsConverter.MapXsdToClrTypes(stype);

			if (clrType == null)
				throw new SUDSParserException(
											 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
														   xsdType, s_schemaNamespaceString));

			// Handle array types
			if (index != -1)
				clrType = clrType + xsdType.Substring(index);
			Util.Log("SudsConverter.MapSchemaTypesToCSharpTypes Exit Type "+clrType);           

			return clrType;
		}

		// Return true if the given type is a primitive type
		private bool IsPrimitiveType(String typeNS, String typeName)
		{
			Util.Log("WsdlParser.IsPrimitiveType typeNS "+typeNS+" typeName "+typeName);            
			bool fReturn = false;
			if (MatchingSchemaStrings(typeNS))
			{
				if (!MatchingStrings(typeName, s_urTypeString))
					fReturn = true;
			}

			return(fReturn);
		}

		// Looksup a matching namespace
		private URTNamespace LookupNamespace(String name)
		{
			Util.Log("WsdlParser.lookupNamespace name "+name+" number of NS "+_URTNamespaces.Count);            
			for (int i=0;i<_URTNamespaces.Count;i++)
			{
				URTNamespace urtNS = (URTNamespace) _URTNamespaces[i];
				if (WsdlParser.MatchingStrings(urtNS.Name, name))
				//Util.Log("WsdlParser.lookupNamespace search ns "+urtNS.Name+" input "+name);            
				//if (urtNS.Name == name)
				{
					Util.Log("WsdlParser.lookupNamespace search ns found "+urtNS.GetHashCode()+" "+urtNS.Name+" input "+name);            
					return(urtNS);
				}
			}

			Util.Log("WsdlParser.lookupNamespace search ns Not found "+name);            
			return(null);
		}


		// This routine is used when finding and creating namespaces during the resolve phase.
		// These references are from binding section which support encoded rpc. Any namespace
		// not referenced during this phase will be pruned before creating proxy. This will
		// prevent Types not used from being placed in the proxy.

		internal URTNamespace AddNewNamespace(String ns)
		{
			Util.Log("WsdlParser.AddNewNamespace name "+ns); 
			if (ns == null)
				return null;

			URTNamespace xns = LookupNamespace(ns);
			if (xns == null)
			{
				xns = new URTNamespace(ns, this);
				Util.Log("WsdlParser.AddNewNamespace new namespace "+ns);            
			}
			else
			{
				Util.Log("WsdlParser.AddNewNamespace existing namespace "+ns);            
			}
			if (!xns.IsSystem)
				xns.bReferenced= true;
			return xns;
		}

		internal void AddNamespace(URTNamespace xns)
		{
			//Util.Log("WsdlParser.AddNamespace "+xns.GetHashCode()+" "+xns.Namespace);
			_URTNamespaces.Add(xns);
		}

		private void RemoveNamespace(URTNamespace xns)
		{
			//Util.Log("WsdlParser.Remove "+xns.GetHashCode()+" "+xns.Namespace);
			_URTNamespaces.Remove(xns);
		}

		// Prints the parsed entities
		private void PrintCSC()
		{
			Util.Log("WsdlParser.PrintCSC ");
			int interopCount = 0;

			// For interop, recalculate the interop names
			for (int i=0;i<_URTNamespaces.Count;i++)
			{
				URTNamespace urtNS = (URTNamespace) _URTNamespaces[i];
				if (!urtNS.IsEmpty && urtNS.UrtType == UrtType.Interop)
				{
					if (interopCount == 0)
						urtNS.EncodedNS = _proxyNamespace;
					else
						urtNS.EncodedNS	= _proxyNamespace+interopCount;
					interopCount++;
					Util.Log("WsdlParser.PrintCSC Interop "+urtNS.EncodedNS+" "+urtNS.Namespace+" urtType "+((Enum)urtNS.UrtType).ToString());                 
				}
			}

			for (int i=0;i<_URTNamespaces.Count;i++)
			{
				URTNamespace urtNS = (URTNamespace) _URTNamespaces[i];
				if (!urtNS.IsEmpty && !(urtNS.UrtType == UrtType.UrtSystem || urtNS.UrtType == UrtType.Xsd || urtNS.UrtType == UrtType.None))
				{
					Util.Log("WsdlParser.PrintCSC fileName urtNS "+urtNS.Namespace+" urtType "+((Enum)urtNS.UrtType).ToString());                 
					String fileName = urtNS.IsURTNamespace ? urtNS.AssemName : urtNS.EncodedNS;
					int index = fileName.IndexOf(','); // reduce to simple assembly name
					if (index > -1)
					{
						fileName = fileName.Substring(0,index);
					}
					Util.Log("WsdlParser.PrintCSC fileName "+fileName+" "+urtNS.Namespace);                 
					String completeFileName = "";

					WriterStream output = WriterStream.GetWriterStream(ref _writerStreams, _outputDir, fileName, ref completeFileName);
					if (completeFileName.Length > 0)
						_outCodeStreamList.Add(completeFileName);
					urtNS.PrintCSC(output);
				}
			}
			return;
		}

		internal UrtType IsURTExportedType(String name, out String ns, out String assemName)
		{
			Util.Log("WsdlParser.IsURTExportedType Enter "+name);           
			//Console.WriteLine("Parsing " + name);
			UrtType urtType = UrtType.None;
			ns = null;
			assemName = null;

			if (MatchingSchemaStrings(name))
			{
				Util.Log("WsdlParser.IsURTExportedType trace 1 "+name);           
				urtType = UrtType.Xsd;
			}
			else
			{
				Util.Log("WsdlParser.IsURTExportedType trace 2 "+name);           
				if (SoapServices.IsClrTypeNamespace(name))
				{
					SoapServices.DecodeXmlNamespaceForClrTypeNamespace(name, out ns, out assemName);

					if (assemName == null)
					{
						assemName = typeof(String).Module.Assembly.GetName().Name;
						urtType = UrtType.UrtSystem;
					}
					else
						urtType	= UrtType.UrtUser;
				}

				if (urtType == UrtType.None)
				{
					ns = name;
					assemName = ns;
					//if (NeedsEncoding(name))
					urtType = UrtType.Interop;
				}

				ns = Atomize(ns);
				assemName = Atomize(assemName);
			}

			//Console.WriteLine("NS: " + ns + " Assembly: " + assemName);
			Util.Log("WsdlParser.IsURTExportedType Exit "+((Enum)urtType).ToString());
			return(urtType);
		}

		private bool NeedsEncoding(String ns)
		{
			bool bEncode = false;
			if (MatchingSchemaStrings(ns) ||
				MatchingSchemaInstanceStrings(ns) ||
				MatchingStrings(ns, s_soapNamespaceString) ||
				MatchingStrings(ns, s_sudsNamespaceString) ||
				MatchingStrings(ns, s_serviceNamespaceString) ||
				MatchingStrings(ns, s_wsdlNamespaceString) ||
				MatchingStrings(ns, s_wsdlSoapNamespaceString) ||
				MatchingStrings(ns, s_wsdlSudsNamespaceString))
				bEncode = false;
			else
				bEncode	= true;

			Util.Log("WsdlParser.NeedsEncoding ns "+ns+" "+bEncode);    
			return bEncode;
		}


		internal String GetTypeString(String curNS, bool bNS, URTNamespace urtNS, String typeName, String typeNS) 
		{
			Util.Log("WsdlParser.GetTypeString Entry curNS "+curNS+" bNS "+bNS+" URTNamespace "+urtNS.Name+" typeName "+typeName+" typeNS "+typeNS);
			String type;

			URTComplexType ct = urtNS.LookupComplexType(typeName);
			if (ct != null && ct.IsArray())
			{
				if (ct.GetArray() == null)
					ct.ResolveArray();
				String arrayName = ct.GetArray();
				URTNamespace arrayNS = ct.GetArrayNS();
				StringBuilder sb = new StringBuilder(50);
				if (arrayNS.EncodedNS != null && Qualify(urtNS.EncodedNS, arrayNS.EncodedNS))
				{
					sb.Append(WsdlParser.IsValidCSAttr(arrayNS.EncodedNS));
					sb.Append('.');
				}
				sb.Append(WsdlParser.IsValidCSAttr(arrayName));
				type = sb.ToString();
			}
			else
			{
				String encodedNS = null;
				if (urtNS.UrtType == UrtType.Interop)
					encodedNS = urtNS.EncodedNS;
				else
					encodedNS = typeNS;

				if (bNS && Qualify(encodedNS, curNS))
				{
					StringBuilder sb = new StringBuilder(50);
					if (encodedNS != null)
					{
						sb.Append(WsdlParser.IsValidCSAttr(encodedNS));
						sb.Append('.');
					}
					sb.Append(WsdlParser.IsValidCSAttr(typeName));
					type = sb.ToString();
				}
				else
				{
					type = typeName;
				}

			}

			int index = type.IndexOf('+');
			if (index > 0)
			{
				// nested type, replace + with . Should be done earlier when forming names
				if (bNS)
					type = type.Replace('+', '.');
				else
					type = type.Substring(0,index);
			}


			Util.Log("WsdlParser.GetTypeString Exit type "+type);              
			return(type);
		}


		// Creates and initializes the name table if neccessary
		static private XmlNameTable CreatePrimedNametable()
		{
			Util.Log("WsdlParser.CreatePrimedNametable");           

			//Interlocked.Increment(ref s_counter);
			/*if(s_atomizedTable == null)
			{
			// Create a new nametable
			//MTNameTable newTable = new MTNameTable(true);
			}*/
			NameTable newTable = new NameTable();

			// Atomically update static location to point to the current table
			/*Object oldTable = Interlocked.CompareExchange(ref s_atomizedTable, newTable, null);
			if(oldTable != null)
			newTable = (MTNameTable) oldTable; */

			// Atomize frequently used strings for perf
			// The following ops are not done inside a lock as they are idempotent
			s_emptyString = newTable.Add(String.Empty);
			s_complexTypeString = newTable.Add("complexType");
			s_simpleTypeString = newTable.Add("simpleType");
			s_elementString = newTable.Add("element");
			s_enumerationString = newTable.Add("enumeration");
			s_encodingString = newTable.Add("encoding");
			s_attributeString = newTable.Add("attribute");
			s_attributesString = newTable.Add("attributes");
			s_allString = newTable.Add("all");
			s_sequenceString = newTable.Add("sequence");
			s_choiceString = newTable.Add("choice");
			s_minOccursString = newTable.Add("minOccurs");
			s_maxOccursString = newTable.Add("maxOccurs");
			s_unboundedString = newTable.Add("unbounded");
			s_oneString = newTable.Add("1");
			s_zeroString = newTable.Add("0");
			s_nameString = newTable.Add("name");
			s_typeString = newTable.Add("type");
			s_baseString = newTable.Add("base");
			s_valueString = newTable.Add("value");
			s_interfaceString = newTable.Add("interface");
			s_serviceString = newTable.Add("service");
			s_extendsString = newTable.Add("extends");
			s_addressesString = newTable.Add("addresses");
			s_addressString = newTable.Add("address");
			s_uriString = newTable.Add("uri");
			s_implementsString = newTable.Add("implements");
			s_nestedTypeString = newTable.Add("nestedType");
			s_requestString = newTable.Add("request");
			s_responseString = newTable.Add("response");
			s_requestResponseString = newTable.Add("requestResponse");
			s_messageString = newTable.Add("message");
			s_locationString = newTable.Add("location");
			s_schemaLocationString = newTable.Add("schemaLocation");
			s_importString = newTable.Add("import");
			s_includeString = newTable.Add("include");
			s_onewayString = newTable.Add("oneway");
			s_refString = newTable.Add("ref");
			s_refTypeString = newTable.Add("refType");
			s_referenceString = newTable.Add("Reference");
			s_objectString = newTable.Add("Object");
			s_urTypeString = newTable.Add("anyType");
			s_arrayString = newTable.Add("Array");
			s_sudsString = newTable.Add("suds");
			s_methodString = newTable.Add("method");
			s_useString = newTable.Add("use");
			s_rootTypeString = newTable.Add("rootType");
			s_soapString = newTable.Add("soap");
			s_serviceDescString = newTable.Add("serviceDescription");
			s_schemaString = newTable.Add("schema");
			s_targetNamespaceString = newTable.Add("targetNamespace");
			s_namespaceString = newTable.Add("namespace");
			s_idString = newTable.Add("ID");
			s_soapActionString = newTable.Add("soapAction");
			s_schemaNamespaceString1999 = newTable.Add(SudsConverter.Xsd1999);
			s_instanceNamespaceString1999 = newTable.Add(SudsConverter.Xsi1999);
			s_schemaNamespaceString2000 = newTable.Add(SudsConverter.Xsd2000);
			s_instanceNamespaceString2000 = newTable.Add(SudsConverter.Xsi2000);
			s_schemaNamespaceString = newTable.Add(SudsConverter.Xsd2001);
			s_instanceNamespaceString = newTable.Add(SudsConverter.Xsi2001);
			s_soapNamespaceString = newTable.Add("urn:schemas-xmlsoap-org:soap.v1");
			//s_sudsNamespaceString = newTable.Add("urn:schemas-xmlsoap-org:suds.v1");
			s_sudsNamespaceString = newTable.Add("urn:schemas-xmlsoap-org:soap-sdl-2000-01-25");
			//s_URTNamespaceString = newTable.Add("urn:schamas-xmlsoap-org:urt.v1");
			//s_serviceNamespaceString = newTable.Add("urn:schemas-xmlsoap-org:servicedesc.v1");
			s_serviceNamespaceString = newTable.Add("urn:schemas-xmlsoap-org:sdl.2000-01-25");

			// Wsdl strings
			s_definitionsString = newTable.Add("definitions");
			s_wsdlNamespaceString = newTable.Add("http://schemas.xmlsoap.org/wsdl/");
			s_wsdlSoapNamespaceString = newTable.Add("http://schemas.xmlsoap.org/wsdl/soap/");
			s_wsdlSudsNamespaceString = newTable.Add("http://www.w3.org/2000/wsdl/suds");
			s_enumTypeString = newTable.Add("enumType");
			s_typesString = newTable.Add("types");
			s_partString = newTable.Add("part");
			s_portTypeString = newTable.Add("portType");
			s_operationString = newTable.Add("operation");
			s_inputString = newTable.Add("input");
			s_outputString = newTable.Add("output");
			s_bindingString = newTable.Add("binding");
			s_classString = newTable.Add("class");
			s_structString = newTable.Add("struct");
			s_ISerializableString = newTable.Add("ISerializable");
			s_marshalByRefString = newTable.Add("MarshalByRefObject");
			s_delegateString = newTable.Add("Delegate");
			s_servicedComponentString = newTable.Add("ServicedComponent");
			s_comObjectString = newTable.Add("__ComObject");
			s_portString = newTable.Add("port");
			s_styleString = newTable.Add("style");
			s_transportString = newTable.Add("transport");
			s_encodedString = newTable.Add("encoded");
			s_faultString = newTable.Add("fault");
			s_bodyString = newTable.Add("body");
			s_partsString = newTable.Add("parts");
			s_headerString = newTable.Add("header");
			s_encodingStyleString = newTable.Add("encodingStyle");                                  
			s_restrictionString = newTable.Add("restriction");                                  
			s_complexContentString = newTable.Add("complexContent");
			s_soapEncodingString = newTable.Add("http://schemas.xmlsoap.org/soap/encoding/");
			s_arrayTypeString = newTable.Add("arrayType");
			s_parameterOrderString = newTable.Add("parameterOrder");


			return((XmlNameTable) newTable);

			// Enqueue a timer if it has not already been done
			/*Timer timer = new Timer(new TimerCallback(Cleanup), null, 1000, 1000);
			Object existingTimer = Interlocked.CompareExchange(ref s_enqueuedTimer, timer, null);
			if(existingTimer != null)
			timer.Dispose(); */
			//}

			//return((XmlNameTable) s_atomizedTable);
		}

		// Private fields
		private XmlTextReader _XMLReader;
		private ArrayList _URTNamespaces;
		private ReaderStream _parsingInput;
		internal bool _bWrappedProxy;
		private String _proxyNamespace;
		private int _proxyNamespaceCount = 0;
		private ReaderStream _readerStreamsWsdl;
		private ReaderStream _readerStreamsXsd;
		private String _outputDir;
		private ArrayList _outCodeStreamList;
		private WriterStream _writerStreams;
		private SchemaBlockType _blockDefault;
		private XsdVersion _xsdVersion;
		private Hashtable wsdlMessages = new Hashtable(10);
		private Hashtable wsdlPortTypes = new Hashtable(10);
		private ArrayList wsdlBindings = new ArrayList(10);
		private ArrayList wsdlServices = new ArrayList(10);
		private Stack _currentReaderStack = new Stack(5);
		private Stack _currentSchemaReaderStack = new Stack(5);
		private XmlNameTable _primedNametable = null;


		//static private Object s_atomizedTable = null;
		//static private int s_counter = 0;
		//static private Object s_enqueuedTimer = null;
		static private String s_emptyString;
		static private String s_complexTypeString;
		static private String s_simpleTypeString;
		static private String s_elementString;
		static private String s_enumerationString;
		static private String s_encodingString;
		static private String s_attributeString;
		static private String s_attributesString;
		static private String s_allString;
		static private String s_sequenceString;
		static private String s_choiceString;
		static private String s_minOccursString;
		static private String s_maxOccursString;
		static private String s_unboundedString;
		static private String s_oneString;
		static private String s_zeroString;
		static private String s_nameString;
		static private String s_enumTypeString;
		static private String s_typeString;
		static private String s_baseString;
		static private String s_valueString;
		static private String s_interfaceString;
		static private String s_serviceString;
		static private String s_extendsString;
		static private String s_addressesString;
		static private String s_addressString;
		static private String s_uriString;
		static private String s_implementsString;
		static private String s_nestedTypeString;
		static private String s_requestString;
		static private String s_responseString;
		static private String s_requestResponseString;
		static private String s_messageString;
		static private String s_locationString;
		static private String s_schemaLocationString;
		static private String s_importString;
		static private String s_includeString;
		static private String s_onewayString;
		static private String s_refString;
		static private String s_refTypeString;
		static private String s_referenceString;
		static private String s_arrayString;
		static private String s_objectString;
		static private String s_urTypeString;
		static private String s_methodString;
		static private String s_sudsString;
		static private String s_useString;
		static private String s_rootTypeString;
		static private String s_soapString;
		static private String s_serviceDescString;
		static private String s_schemaString;
		static private String s_targetNamespaceString;
		static private String s_namespaceString;
		static private String s_idString;
		static private String s_soapActionString;
		static private String s_instanceNamespaceString;
		static private String s_schemaNamespaceString;
		static private String s_instanceNamespaceString1999;
		static private String s_schemaNamespaceString1999;
		static private String s_instanceNamespaceString2000;
		static private String s_schemaNamespaceString2000;
		static private String s_soapNamespaceString;
		static private String s_sudsNamespaceString;
		static private String s_serviceNamespaceString;

		//Wsdl
		static private String s_definitionsString;
		static private String s_wsdlNamespaceString;
		static private String s_wsdlSoapNamespaceString;
		static private String s_wsdlSudsNamespaceString;
		static private String s_typesString;
		static private String s_partString;
		static private String s_portTypeString;
		static private String s_operationString;
		static private String s_inputString;
		static private String s_outputString;
		static private String s_bindingString;
		static private String s_classString;
		static private String s_structString;
		static private String s_ISerializableString;
		static private String s_marshalByRefString;
		static private String s_delegateString;
		static private String s_servicedComponentString;
		static private String s_comObjectString;
		static private String s_portString;
		static private String s_styleString;
		static private String s_transportString;
		static private String s_encodedString;
		static private String s_faultString;
		static private String s_bodyString;
		static private String s_partsString;
		static private String s_headerString;
		static private String s_encodingStyleString;        
		static private String s_restrictionString;        
		static private String s_complexContentString;        
		static private String s_soapEncodingString;        
		static private String s_arrayTypeString;        
		static private String s_parameterOrderString;



		/***************************************************************
		 **
		 ** Private classes used by SUDS Parser
		 **
		 ***************************************************************/
		// Input streams
		internal class ReaderStream
		{
			internal ReaderStream(String location)
			{
				Util.Log("ReaderStream.ReaderStream "+location);
				_location = location;
				_name = String.Empty;
				_targetNS = String.Empty;
				_uniqueType = null;
				_uniqueNS = null;
				_reader = null;
				_next = null;
			}
			internal String Location
			{
				get { return(_location);}
				set { _location = value;}
			}
			internal String Name
			{
				get { return(_name);}
				set { _name = value;}
			}
			internal String TargetNS
			{
				get { return(_targetNS);}
				set { _targetNS = value;}
			}
			internal URTComplexType UniqueType
			{
				get { return(_uniqueType);}
				set { _uniqueType = value;}
			}
			internal URTNamespace UniqueNS
			{
				get { return(_uniqueNS);}
				set { _uniqueNS = value;}
			}
			internal TextReader InputStream
			{
				get { return(_reader);}
				set { _reader = value;}
			}
			internal Uri Uri
			{
				get { return(_uri);}
				set { _uri = value;}
			}

			internal static void GetReaderStream(ReaderStream inputStreams, ReaderStream newStream)
			{
				Util.Log("ReaderStream.GetReaderStream "+newStream.Location);             
				ReaderStream input = inputStreams;
				ReaderStream last;
				do
				{
					Util.Log("ReaderStream.GetReaderStream location match input.location "+input._location+" location "+newStream.Location);             
					if (input._location == newStream.Location)
						return;
					last = input;
					input = input._next;
				} while (input != null);

				input = newStream;
				last._next = input;

				return;
			}
			internal static ReaderStream GetNextReaderStream(ReaderStream input)
			{
				Util.Log("ReaderStream.GetNextReaderStream "+input._next);
				return input._next;
			}

			private String _location;
			private String _name;
			private String _targetNS;
			private URTComplexType _uniqueType;
			private URTNamespace _uniqueNS;
			private TextReader _reader;
			private ReaderStream _next;
			private Uri _uri;
		}

		internal class WriterStream
		{

			private WriterStream(String fileName, TextWriter writer)
			{
				Util.Log("WriterStream.WriterStream "+fileName);                
				_fileName = fileName;
				_writer = writer;
			}
			internal TextWriter OutputStream
			{
				get { return(_writer);}
			}

			internal bool GetWrittenTo()
			{
				return _bWrittenTo;

			}

			internal void SetWrittenTo()
			{
				_bWrittenTo = true;
			}


			internal static void Flush(WriterStream writerStream)
			{
				while (writerStream != null)
				{
					writerStream._writer.Flush();
					writerStream = writerStream._next;
				}

				return;
			}
			internal static WriterStream GetWriterStream(ref WriterStream outputStreams, String outputDir, String fileName, ref String completeFileName)
			{
				Util.Log("WriterStream.GetWriterStream "+fileName);                             
				WriterStream output = outputStreams;
				while (output != null)
				{
					if (output._fileName == fileName)
						return(output);
					output = output._next;
				}

				String diskFileName = fileName;
				if (diskFileName.EndsWith(".exe") || diskFileName.EndsWith(".dll"))
					diskFileName = diskFileName.Substring(0, diskFileName.Length - 4);
				String _completeFileName = outputDir + diskFileName + ".cs";
				completeFileName = _completeFileName;
				//TextWriter textWriter = new StreamWriter(outputDir + fileName + ".cs", false);
				TextWriter textWriter = new StreamWriter(_completeFileName, false, new UTF8Encoding(false));
				output = new WriterStream(fileName, textWriter);
				output._next = outputStreams;
				outputStreams = output;
				Util.Log("WriterStream.GetWriterStream in fileName "+fileName+" completeFileName "+_completeFileName);                              
				return(output);
			}

			internal static void Close(WriterStream outputStreams)
			{
				WriterStream output = outputStreams;
				while (output != null)
				{
					output._writer.Close();
					output = output._next;
				}
			}

			private String _fileName;
			private TextWriter _writer;
			private WriterStream _next;
			private bool _bWrittenTo = false;
		}

		// Represents a parameter of a method
		[Serializable]
		internal enum URTParamType
		{
			IN, OUT, REF
		}
		internal class URTParam
		{
			internal URTParam(String name, String typeName, String typeNS, String encodedNS,
							  URTParamType pType, bool bEmbedded, WsdlParser parser, URTNamespace urtNamespace)
			{
				Util.Log("URTParam.URTParam name "+name+" typeName "+typeName+" typeNS "+typeNS+" ecodedNS "+encodedNS+" pType "+pType+" bEmbedded "+bEmbedded);
				_name = name;
				_typeName = typeName;
				_typeNS = typeNS;
				_encodedNS = encodedNS;
				_pType = pType;
				_embeddedParam = bEmbedded;
				_parser = parser;
				_urtNamespace = urtNamespace;

			}
			public override bool Equals(Object obj)
			{
				//Util.Log("URTParam.Equals ");
				URTParam suppliedParam = (URTParam) obj;
				if (_pType == suppliedParam._pType &&
					WsdlParser.MatchingStrings(_typeName, suppliedParam._typeName) &&
					WsdlParser.MatchingStrings(_typeNS, suppliedParam._typeNS))
					return(true);

				return(false);
			}


			public override int GetHashCode()
			{
				return base.GetHashCode();
			}
			internal bool IsCompatibleType(ParameterInfo pInfo)
			{
				Util.Log("URTParam.IsCompatibleType");              
				if (_pType == URTParamType.OUT)
				{
					if (pInfo.IsOut == false)
						return(false);
				}

				Type parameterType = pInfo.ParameterType;
				if (parameterType.Namespace == _typeNS)
				{
					String typeName = _typeName;
					if (_pType == URTParamType.REF)
					{
						if (parameterType.IsByRef == false)
							return(false);

						typeName = typeName + '&';
					}
					if (parameterType.Name == typeName)
						return(true);
				}

				return(false);
			}
			internal URTParamType ParamType
			{
				get { return(_pType);}
				set { _pType = value;}
			}
			internal String Name
			{
				get { return(_name);}
			}
			internal String TypeName
			{
				get { return(_typeName);}
			}
			internal String TypeNS
			{
				get { return(_typeNS);}
			}

			internal bool IsInteropType
			{
				get { return((Object) _typeNS != (Object) _encodedNS);}                
			}

			internal String GetTypeString(String curNS, bool bNS)
			{
				return _parser.GetTypeString(curNS, bNS, _urtNamespace, _typeName, _encodedNS);
			}

			internal void PrintCSC( StringBuilder sb, String curNS)
			{
				Util.Log("URTParam.PrintCSC curNS "+curNS+" name "+_name);                                              
				//if(_embeddedParam)
				//    sb.Append("[Embedded] ");
				sb.Append(PTypeString[(int) _pType]);
				sb.Append(GetTypeString(curNS, true));
				sb.Append(' ');
				sb.Append(WsdlParser.IsValidCS(_name));
				return;
			}
			internal void PrintCSC(StringBuilder sb)
			{
				Util.Log("URTParam.PrintCSC name "+_name);                                              
				sb.Append(PTypeString[(int) _pType]);
				sb.Append(WsdlParser.IsValidCS(_name));
				return;
			}

			static private String[] PTypeString = { "", "out ", "ref "};
			private String _name;
			private String _typeName;
			private String _typeNS;
			private String _encodedNS;
			private URTParamType _pType;
			private bool _embeddedParam;
			private URTNamespace _urtNamespace;
			private WsdlParser _parser;
		}

		[Flags]
		internal enum MethodPrintEnum
		{
			PrintBody = 0x1,
			InterfaceMethods = 0x2,
			InterfaceInClass = 0x4,
		}

		[Flags]
		internal enum MethodFlags
		{
			None = 0x0,
			Public = 0x1,
			Protected = 0x2,
			Override = 0x4,
			New = 0x8,
			Virtual = 0x10,
			Internal = 0x20,
		}


		// Represents a method
		internal abstract class URTMethod
		{

			internal static bool FlagTest(MethodPrintEnum flag, MethodPrintEnum target)
			{
				if ((flag & target) == target)
					return true;
				else
					return false;
			}

			internal static bool MethodFlagsTest(MethodFlags flag, MethodFlags target)
			{
				if ((flag & target) == target)
					return true;
				else
					return false;
			}

			internal URTMethod(String name, String soapAction, String methodAttributes, URTComplexType complexType)
			{
				Util.Log("URTMethod.URTMethod name "+name+" soapAction "+soapAction+" attributes "+methodAttributes+" complexType "+complexType);
				_methodName = name;
				_soapAction = soapAction;
				_methodType = null;
				_complexType = complexType;
				int index = name.IndexOf('.');
				_methodFlags = MethodFlags.None;

				// set method flags
				if (methodAttributes != null && methodAttributes.Length > 0)
				{
					String[] attributes = methodAttributes.Split(' ');
					foreach (String attribute in attributes)
					{
						if (attribute == "virtual")
							_methodFlags |= MethodFlags.Virtual;
						if (attribute == "new")
							_methodFlags |= MethodFlags.New;
						if (attribute == "override")
							_methodFlags |= MethodFlags.Override;
						if (attribute == "public")
							_methodFlags |= MethodFlags.Public;
						if (attribute == "protected")
							_methodFlags |= MethodFlags.Protected;
						if (attribute == "internal")
							_methodFlags |= MethodFlags.Internal;
					}
				}

				Util.Log("URTMethod.URTMethod methodFlags "+((Enum)_methodFlags).ToString());
			}


			internal String Name
			{
				get { return(_methodName);}
			}

			internal String SoapAction
			{
				get { return(_soapAction);}
				set { _soapAction = value;}
			}
			internal MethodFlags MethodFlags
			{
				get { return(_methodFlags);}
				set { _methodFlags = value;}
			}

			internal bool IsInteropType
			{
				get 
				{ 
					if (_methodType != null)
						return _methodType.IsInteropType;
					else
						return false;
				}
			}

			internal String GetTypeString(String curNS, bool bNS)
			{
				Util.Log("URTMethod.GetTypeString curNS "+curNS+" bNS "+bNS);
				return((_methodType != null) ? _methodType.GetTypeString(curNS, bNS) : "void");
			}
			protected URTParam MethodType
			{
				get { return(_methodType);}
			}
			public override int GetHashCode()
			{
				return base.GetHashCode();
			}           
			public override bool Equals(Object obj)
			{
				URTMethod suppliedMethod = (URTMethod) obj;
				if (WsdlParser.MatchingStrings(_methodName, suppliedMethod._methodName) &&
					_params.Count == suppliedMethod._params.Count)
				{
					for (int i=0;i<_params.Count;i++)
					{
						if (_params[i].Equals(suppliedMethod._params[i]) == false)
							return(false);
					}

					return(true);
				}

				return(false);
			}
			internal MethodFlags GetMethodFlags(MethodInfo method)
			{
				return(_methodFlags);
			}

			internal void AddParam(URTParam newParam)
			{
				Util.Log("URTMethod.AddParam "+newParam.Name);
				for (int i=0;i<_params.Count;i++)
				{
					URTParam extParam = (URTParam) _params[i];
					if (WsdlParser.MatchingStrings(extParam.Name, newParam.Name))
					{
						if (extParam.ParamType == URTParamType.IN &&
							newParam.ParamType == URTParamType.OUT &&
							WsdlParser.MatchingStrings(extParam.TypeName, newParam.TypeName) &&
							WsdlParser.MatchingStrings(extParam.TypeNS, newParam.TypeNS))
						{
							extParam.ParamType = URTParamType.REF;
							return;
						}

						throw new SUDSParserException(CoreChannel.GetResourceString("Remoting_Suds_DuplicateParameter"));
					}
				}

				// Find parameter position
				int paramPosition = -1;
				if (_paramNamesOrder != null)
				{
					// Parameter order find the parameter position or determine if the parameter is a return value
					for (int i=0; i<_paramNamesOrder.Length; i++)
					{
						if (_paramNamesOrder[i] == newParam.Name)
						{
							paramPosition = i;
							break;
						}
					}

					if (paramPosition == -1)
					{
						// return value
						_methodType = newParam;
					}
					else
					{
						// Parameter, add the correct position
						//_params[paramPosition] = newParam; // _params array list is the size of the parameters.
						_params.Add(newParam);
						_paramPosition.Add(paramPosition);
					}
				}
				else
				{
					// no parameterOrder in wsdl, do the best we can to determine if there is a return value
					if ((_methodType == null) && (newParam.ParamType == URTParamType.OUT))
					{
						// return value
						_methodType = newParam;
					}
					else
					{
						// parameter put as the next parameter
						_params.Add(newParam);
					}
				}
			}

			internal void ResolveMethodAttributes()
			{
				Util.Log("URTMethod.ResolveMethodAttributes "+Name+" MethodFlags "+((Enum)_methodFlags).ToString());
				if (!(MethodFlagsTest(_methodFlags,MethodFlags.Override) || MethodFlagsTest(_methodFlags,MethodFlags.New)))
					FindMethodAttributes();
			}

			private void FindMethodAttributes()
			{
				Util.Log("URTMethod.FindMethodAttributes "+Name+" complexType "+_complexType);
				if (_complexType == null)
					return;

				Util.Log("URTMethod.FindMethodAttributes "+_complexType.Name);

				ArrayList inherit = _complexType.Inherit;
				Type baseType = null;
				if (inherit == null)
				{
					inherit = new ArrayList();
					if (_complexType.SUDSType == SUDSType.ClientProxy)
						baseType = typeof(System.Runtime.Remoting.Services.RemotingClientProxy);
					else if (_complexType.SudsUse == SudsUse.MarshalByRef)
						baseType = typeof(MarshalByRefObject);
					else if (_complexType.SudsUse == SudsUse.ServicedComponent)
						baseType = typeof(MarshalByRefObject);

					if (baseType == null)
						return;

					while (baseType != null)
					{
						Util.Log("URTMethod.FindMethodAttributes baseType Enter "+baseType);
						inherit.Add(baseType);
						baseType = baseType.BaseType;
					}

					_complexType.Inherit = inherit;
				}

				BindingFlags bFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

				bool bVirtual = MethodFlagsTest(_methodFlags, MethodFlags.Virtual);
				Util.Log("URTMethod.FindMethodAttributes "+Name+" bVirtual "+bVirtual);

				// See if method hides inherited methods
				bool bfound = false;
				for (int j=0; j<inherit.Count; j++)
				{
					baseType = (Type)inherit[j];
					MethodInfo[] baseInfos = null;
					try
					{
						MethodInfo methodInfo = baseType.GetMethod(Name, bFlags);
						if (methodInfo != null)
						{
							baseInfos = new MethodInfo[1];
							baseInfos[0] = methodInfo;
						}
					}
					catch (Exception)
					{
						// Ambiguous match, overloaded methos
						baseInfos = baseType.GetMethods(bFlags);
					}

					if (baseInfos != null)
					{
						foreach (MethodBase baseInfo in baseInfos)
						{
							if (baseInfo != null && 
								baseInfo.Name == Name && 
								(baseInfo.IsFamily || baseInfo.IsPublic || baseInfo.IsAssembly) 
								&& IsSignature(baseInfo))
							{
								bfound = true;

								// Change attribute to match new hiearchy
								if (!baseInfo.IsPublic)
								{
									if (baseInfo.IsAssembly)
									{
										_methodFlags &= ~(MethodFlags.Public);
										_methodFlags |= MethodFlags.Internal;
									}
									else if (baseInfo.IsFamily)
									{
										_methodFlags &= ~(MethodFlags.Public);
										_methodFlags |= MethodFlags.Protected;
									}
								}

								// Hides
								if (baseInfo.IsFinal)
									_methodFlags |= MethodFlags.New;
								else if (baseInfo.IsVirtual && bVirtual)
									_methodFlags |= MethodFlags.Override;
								else
									_methodFlags |= MethodFlags.New;
								break;
							}
						}
					}
					if (bfound)
						break;
				}

				Util.Log("URTMethod.FindMethodAttributes Exit "+Name+" "+((Enum)_methodFlags).ToString());
			}

			private bool IsSignature(MethodBase baseInfo)
			{
				ParameterInfo[] paramInfos = baseInfo.GetParameters();
				Util.Log("URTMethod.IsSignature  param length "+paramInfos.Length+" URTParams length "+_params.Count);

				if (_params.Count != paramInfos.Length)
					return false;

				bool bsig = true;

				for (int i=0; i<paramInfos.Length; i++)
				{
					URTParam param = (URTParam)_params[i];
					if (param.GetTypeString(null, true) != paramInfos[i].ParameterType.FullName)
					{
						bsig = false;
						break;

					}
				}

				return bsig;
			}

			internal void PrintSignature(StringBuilder sb, String curNS)
			{
				Util.Log("URTMethod.PrintSignature curNS "+curNS);              
				for (int i=0;i<_params.Count;i++)
				{
					if (i != 0)
						sb.Append(", ");
					Util.Log("URTMethod.PrintSignature Invoke _params PrintCSC");                               
					((URTParam) _params[i]).PrintCSC(sb, curNS);
				}

				return;
			}
			/*
			internal abstract void PrintCSC(TextWriter textWriter, String indentation,
											String namePrefix, String curNS, MethodPrintEnum methodPrintEnum,
											bool bURTType, String bodyPrefix, StringBuilder sb);
											*/

			internal virtual void PrintCSC(TextWriter textWriter, String indentation,
										   String namePrefix, String curNS, MethodPrintEnum methodPrintEnum, bool bURTType,
										   String bodyPrefix, StringBuilder sb)
			{
				Util.Log("URTMethod.PrintCSC name "+_methodName+" namePrefix "+namePrefix+" curNS "+curNS+" MethodPrintEnum "+((Enum)methodPrintEnum).ToString());

				// Check for class methods
				sb.Length= 0;
				sb.Append(indentation);

				if (Name == "Finalize")
					return;

				if (FlagTest(methodPrintEnum, MethodPrintEnum.InterfaceInClass))
					sb.Append("public ");
				else if (MethodFlagsTest(_methodFlags, MethodFlags.Public))
					sb.Append("public ");
				else if (MethodFlagsTest(_methodFlags, MethodFlags.Protected))
					sb.Append("protected ");
				else if (MethodFlagsTest(_methodFlags, MethodFlags.Internal))
					sb.Append("internal ");

				if (MethodFlagsTest(_methodFlags, MethodFlags.Override))
					sb.Append("override ");

				else if (MethodFlagsTest(_methodFlags, MethodFlags.Virtual))
					sb.Append("virtual ");

				if (MethodFlagsTest(_methodFlags, MethodFlags.New))
					sb.Append("new ");

				sb.Append(WsdlParser.IsValidCSAttr(GetTypeString(curNS, true)));

				if (FlagTest(methodPrintEnum, MethodPrintEnum.InterfaceInClass))
					sb.Append(" ");
				else
					sb.Append(WsdlParser.IsValidCSAttr(namePrefix));
				if (_wsdlMethodInfo.bProperty)
					sb.Append(WsdlParser.IsValidCS(_wsdlMethodInfo.propertyName));
				else
				{
					sb.Append(WsdlParser.IsValidCS(_methodName));

					sb.Append('(');
					if (_params.Count > 0)
					{
						Util.Log("URTMethod.PrintCSC Invoke _params[0] 1 PrintCSC");
						((URTParam) _params[0]).PrintCSC(sb, curNS);
						for (int i=1;i<_params.Count;i++)
						{
							sb.Append(", ");
							Util.Log("URTMethod.PrintCSC Invoke _params 2 PrintCSC "+i);                       
							((URTParam) _params[i]).PrintCSC(sb, curNS);
						}
					}
					sb.Append(')');
				}

				if (_wsdlMethodInfo.bProperty && FlagTest(methodPrintEnum, MethodPrintEnum.InterfaceMethods))
				{
					sb.Append("{");
					if (_wsdlMethodInfo.bGet)
						sb.Append(" get; ");
					if (_wsdlMethodInfo.bSet)
						sb.Append(" set; ");
					sb.Append("}");
				}
				else if (!FlagTest(methodPrintEnum, MethodPrintEnum.PrintBody))
					sb.Append(';');

				textWriter.WriteLine(sb); 

				if (_wsdlMethodInfo.bProperty && FlagTest(methodPrintEnum, MethodPrintEnum.PrintBody))
					PrintPropertyBody(textWriter,indentation, sb, bodyPrefix);

				else if (FlagTest(methodPrintEnum, MethodPrintEnum.PrintBody))
				{
					sb.Length = 0;
					sb.Append(indentation);
					sb.Append('{');
					textWriter.WriteLine(sb);

					String newIndentation = indentation + "    ";
					if (bodyPrefix == null)
					{
						for (int i=0;i<_params.Count;i++)
						{
							URTParam param = (URTParam) _params[i];
							if (param.ParamType == URTParamType.OUT)
							{
								sb.Length = 0;
								sb.Append(newIndentation);
								sb.Append(WsdlParser.IsValidCS(param.Name));
								sb.Append(" = ");
								sb.Append(ValueString(param.GetTypeString(curNS, true)));
								sb.Append(';');
								textWriter.WriteLine(sb);
							}
						}
						Util.Log("URTMethod.PrintCSC return print");
						sb.Length = 0;
						sb.Append(newIndentation);
						sb.Append("return");
						String returnString = ValueString(GetTypeString(curNS, true));
						if (returnString != null)
						{
							sb.Append('(');
							sb.Append(returnString);
							sb.Append(')');
						}
						sb.Append(';');
					}
					else
					{
						sb.Length = 0;
						sb.Append(newIndentation);
						if (ValueString(GetTypeString(curNS, true)) != null)
							sb.Append("return ");
						PrintMethodName(sb, bodyPrefix, _methodName);
						//sb.Append(bodyPrefix);
						//sb.Append(_methodName);
						sb.Append('(');
						if (_params.Count > 0)
						{
							Util.Log("URTMethod.PrintCSC Invoke _params[0] 3 PrintCSC");                                                    
							((URTParam) _params[0]).PrintCSC(sb);
							for (int i=1;i<_params.Count;i++)
							{
								sb.Append(", ");
								Util.Log("URTMethod.PrintCSC Invoke _params 4 PrintCSC");                                                       
								((URTParam) _params[i]).PrintCSC(sb);
							}
						}
						sb.Append(");");
					}
					textWriter.WriteLine(sb);

					textWriter.Write(indentation);
					textWriter.WriteLine('}');
				}
			}

			private void PrintSoapAction(String action, StringBuilder sb)
			{
				sb.Append("[SoapMethod(SoapAction=");
				sb.Append(WsdlParser.IsValidUrl(action));
				sb.Append(")]");
			}

			private void PrintPropertyBody(TextWriter textWriter, String indentation, StringBuilder sb, String bodyPrefix)
			{
				/*
				[SoapMethod(SoapAction="http://schemas.microsoft.com/clr/nsassem/Testing.TestSimpleObject/test12#get_Value")]
				get{return ((TestSimpleObject) _tp).Value;}

				[SoapMethod(SoapAction="http://schemas.microsoft.com/clr/nsassem/Testing.TestSimpleObject/test12#set_Value")]
				set{((TestSimpleObject) _tp).Value = value;}
				*/

				sb.Length = 0;
				sb.Append(indentation);
				sb.Append('{');
				textWriter.WriteLine(sb);

				String newIndentation = indentation + "    ";
				sb.Length = 0;
				sb.Append(newIndentation);
				if (_wsdlMethodInfo.bGet)
				{
					sb.Length = 0;
					sb.Append(newIndentation);
					PrintSoapAction(_wsdlMethodInfo.soapActionGet, sb);
					textWriter.WriteLine(sb);

					sb.Length = 0;
					sb.Append(newIndentation);
					sb.Append("get{return ");
					PrintMethodName(sb, bodyPrefix, _wsdlMethodInfo.propertyName);
					//sb.Append(bodyPrefix);
					//sb.Append(_wsdlMethodInfo.propertyName);
					sb.Append(";}");
					textWriter.WriteLine(sb);
				}

				if (_wsdlMethodInfo.bSet)
				{
					if (_wsdlMethodInfo.bGet)
						textWriter.WriteLine();

					sb.Length = 0;
					sb.Append(newIndentation);
					PrintSoapAction(_wsdlMethodInfo.soapActionSet, sb);
					textWriter.WriteLine(sb);

					sb.Length = 0;
					sb.Append(newIndentation);
					sb.Append("set{");
					PrintMethodName(sb, bodyPrefix, _wsdlMethodInfo.propertyName);
					//sb.Append(bodyPrefix);
					//sb.Append(_wsdlMethodInfo.propertyName);
					sb.Append("= value;}");
					textWriter.WriteLine(sb);
				}

				sb.Length = 0;
				sb.Append(indentation);
				sb.Append('}');
				textWriter.WriteLine(sb);
			}

			private void PrintMethodName(StringBuilder sb, String bodyPrefix, String name)
			{
				int index = name.LastIndexOf('.');
				if (index < 0)
				{
					sb.Append(bodyPrefix);
					sb.Append(WsdlParser.IsValidCS(name));
				}
				else
				{
					// interface name, need to reconstruct bodyPrefix and strip name qualifier
					String iface = name.Substring(0,index);
					String methodName = name.Substring(index+1);
					if (bodyPrefix == null)
					{
						// Non-wrapped proxy
						sb.Append("(");
						sb.Append(WsdlParser.IsValidCS(iface));
						sb.Append(")");
						sb.Append(WsdlParser.IsValidCS(methodName));
					}
					else
					{
						// wrapped proxy
						sb.Append("((");
						sb.Append(WsdlParser.IsValidCS(iface));
						sb.Append(") _tp).");
						sb.Append(WsdlParser.IsValidCS(methodName));
					}
				}
			}

			// Returns string that is appropriate for the return type
			internal static String ValueString(String paramType)
			{
				String valueString;
				if (paramType == "void")
					valueString = null;
				else if (paramType == "bool")
					valueString = "false";
				else if (paramType == "string")
					valueString = "null";
				else if (paramType == "sbyte" ||
						 paramType == "byte" ||
						 paramType == "short" ||
						 paramType == "ushort" ||
						 paramType == "int" ||
						 paramType == "uint" ||
						 paramType == "long" ||
						 paramType == "ulong")
					valueString = "1";
				else if (paramType == "float" ||
						 paramType == "exfloat")
					valueString = "(float)1.0";
				else if (paramType == "double" ||
						 paramType == "exdouble")
					valueString = "1.0";
				else
				{
					StringBuilder sb = new StringBuilder(50);
					sb.Append('(');
					sb.Append(WsdlParser.IsValidCS(paramType));
					sb.Append(") (Object) null");
					valueString = sb.ToString();
				}
				Util.Log("URTMethod.ValueString paramType "+paramType+" valueString "+valueString);                             
				return(valueString);
			}

			// This method is called when the parsing is complete
			// and is useful for derived types
			internal abstract void ResolveTypes(WsdlParser parser);


			// Helper method used by Resolve
			protected void ResolveWsdlParams(WsdlParser parser, String targetNS, String targetName,
											 bool bRequest, WsdlMethodInfo wsdlMethodInfo)
			{
				Util.Log("URTMethod.ResolveWsdlParams targetName "+targetName+" targetNS "+targetNS+" bRequest "+bRequest+" wsdlMethodInfo "+wsdlMethodInfo);                               
				_wsdlMethodInfo = wsdlMethodInfo;
				_paramNamesOrder = _wsdlMethodInfo.paramNamesOrder;

				int length;
				if (_wsdlMethodInfo.bProperty)
					length = 1;
				else if (bRequest)
					length = wsdlMethodInfo.inputNames.Length;
				else
					length = wsdlMethodInfo.outputNames.Length;

				for (int i=0; i<length; i++)
				{
					String element = null;
					String elementNs = null;
					String name = null;
					String nameNs = null;
					String typeName = null;;
					String typeNameNs = null;;
					URTParamType pType;
					if (_wsdlMethodInfo.bProperty)
					{
						typeName = wsdlMethodInfo.propertyType;
						typeNameNs = wsdlMethodInfo.propertyNs;
						pType = URTParamType.OUT;
					}
					else if (bRequest && !_wsdlMethodInfo.bProperty)
					{
						element = wsdlMethodInfo.inputElements[i];
						elementNs = wsdlMethodInfo.inputElementsNs[i];
						name = wsdlMethodInfo.inputNames[i];
						nameNs = wsdlMethodInfo.inputNamesNs[i];
						typeName = wsdlMethodInfo.inputTypes[i];
						typeNameNs = wsdlMethodInfo.inputTypesNs[i];

						pType = URTParamType.IN;
					}
					else
					{
						element = wsdlMethodInfo.outputElements[i];
						elementNs = wsdlMethodInfo.outputElementsNs[i];
						name = wsdlMethodInfo.outputNames[i];
						nameNs = wsdlMethodInfo.outputNamesNs[i];
						typeName = wsdlMethodInfo.outputTypes[i];
						typeNameNs = wsdlMethodInfo.outputTypesNs[i];
						pType = URTParamType.OUT;
					}

					String actualType;
					String actualTypeNs;
					if ((element == null) || element.Length == 0)
					{
						actualType = typeName;
						actualTypeNs = typeNameNs;
					}
					else
					{
						actualType = element;
						actualTypeNs = elementNs;
					}

					Util.Log("URTMethod.ResolveWsdlParams actualType "+actualType+" actualTypeNs "+actualTypeNs);
					URTNamespace ns = parser.LookupNamespace(actualTypeNs);
					if (ns == null)
					{
						throw new SUDSParserException(
													 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
																   actualTypeNs, actualType));
					}

					URTComplexType ct = ns.LookupComplexType(actualType);

					if (ct != null && ct.IsArray())
					{
						if (ct.GetArray() == null)
							ct.ResolveArray();
						String arrayName = ct.GetArray();
						URTNamespace arrayNS = ct.GetArrayNS();
						AddParam(new URTParam(name, arrayName, arrayNS.Name, arrayNS.EncodedNS, pType, true, parser, arrayNS));
					}
					else
					{
						Util.Log("URTMethod.ResolveWsdlParams actualType 2 UrtType "+((Enum)ns.UrtType).ToString());
						if (ns.UrtType == UrtType.Xsd)
						{
							String clrtypeName = parser.MapSchemaTypesToCSharpTypes(actualType);
							AddParam(new URTParam(name, clrtypeName, ns.Namespace, ns.EncodedNS, pType, true, parser, ns));
						}
						else
						{
							String foundTypeName = null;
							if (ct != null)
							{
								foundTypeName = ct.Name;
							}
							else
							{
								URTSimpleType stype = ns.LookupSimpleType(actualType);
								if (stype != null)
								{
									foundTypeName = stype.Name;
								}
								else
								{
									foundTypeName = actualType; 

									/*
									throw new SUDSParserException(
										String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
													  actualType, ns.Name));
													  */
								}
							}
							//typeNS.RemoveComplexType(type);
							AddParam(new URTParam(name, foundTypeName, ns.Namespace, ns.EncodedNS, pType, true, parser, ns));
						}
					}
				}
			}


			// Fields
			private String _methodName;
			private String _soapAction;
			private URTParam _methodType;
			internal URTComplexType _complexType;
			protected String[] _paramNamesOrder; // parameterOrder names from wsdl 
			protected ArrayList _params = new ArrayList();
			protected ArrayList _paramPosition = new ArrayList();
			private MethodFlags _methodFlags;
			private WsdlMethodInfo _wsdlMethodInfo;
		}

		// Repesents a request response method
		internal class RRMethod : URTMethod
		{
			// Constructor

			internal RRMethod(WsdlMethodInfo wsdlMethodInfo, URTComplexType complexType) 
			: base (wsdlMethodInfo.methodName, wsdlMethodInfo.soapAction, wsdlMethodInfo.methodAttributes, complexType)
			{
				Util.Log("RRMethod.RRMethod WsdlMethodInfo name "+wsdlMethodInfo.methodName+" soapAction "+wsdlMethodInfo.soapAction);
				_wsdlMethodInfo = wsdlMethodInfo;
				_requestElementName = null;
				_requestElementNS = null;
				_responseElementName = null;
				_responseElementNS = null;
			}

			// Adds the request element
			internal void AddRequest(String name, String ns)
			{
				Util.Log("RRMethod.AddRequest name "+name+" ns "+ns);               
				_requestElementName = name;
				_requestElementNS = ns;
			}

			// Adds the response element
			internal void AddResponse(String name, String ns)
			{
				Util.Log("RRMethod.AddResponse name "+name+" ns "+ns);                              
				_responseElementName = name;
				_responseElementNS = ns;
			}

			// Resolves the method
			internal override void ResolveTypes(WsdlParser parser)
			{
				Util.Log("RRMethod.ResolveTypes "+_requestElementName+" "+_responseElementName);
				ResolveWsdlParams(parser, _requestElementNS, _requestElementName, true, _wsdlMethodInfo);
				ResolveWsdlParams(parser, _responseElementNS, _responseElementName, false, _wsdlMethodInfo);

				if (_paramNamesOrder != null)
				{
					// reorder parameters if there is a parameter order
					Object[] paramsInOrder = new Object[_params.Count];
					for (int i=0; i<_params.Count; i++)
					{
						paramsInOrder[(int)_paramPosition[i]] = _params[i];
					}
					_params =  new ArrayList(paramsInOrder);
				}

				ResolveMethodAttributes(); //Needs to be after param order

				return;
			}

			internal override void PrintCSC(TextWriter textWriter, String indentation,
											String namePrefix, String curNS, MethodPrintEnum methodPrintEnum,
											bool bURTType, String bodyPrefix, StringBuilder sb)
			{
				Util.Log("RRMethod.PrintCSC name "+_requestElementName+" namePrefix "+namePrefix+" curNS "+curNS+" methodPrintEnum "+((Enum)methodPrintEnum).ToString());
				//if(bURTType == false)

				// Don't want to generate a Finalize or destructor method
				if (Name == "Finalize")
					return;

				bool bSoapAction = false;
				if (SoapAction != null)
					bSoapAction = true;

				if ((bSoapAction || !bURTType) && !_wsdlMethodInfo.bProperty)
				{
					sb.Length = 0;
					sb.Append(indentation);
					sb.Append("[SoapMethod(");

					if (bSoapAction)
					{
						sb.Append("SoapAction=");
						sb.Append(WsdlParser.IsValidUrl(SoapAction));
					}
					if (!bURTType)
					{
						if (bSoapAction)
							sb.Append(",");

						sb.Append("ResponseXmlElementName=");
						sb.Append(WsdlParser.IsValidUrl(_responseElementName));
						if (MethodType != null)
						{
							sb.Append(", ReturnXmlElementName=");
							sb.Append(WsdlParser.IsValidUrl(MethodType.Name));
						}
						sb.Append(", XmlNamespace=");
						sb.Append(WsdlParser.IsValidUrl(_wsdlMethodInfo.inputMethodNameNs)); 
						sb.Append(", ResponseXmlNamespace=");
						sb.Append(WsdlParser.IsValidUrl(_wsdlMethodInfo.outputMethodNameNs)); 
					}
					sb.Append(")]");
					textWriter.WriteLine(sb);                   
				}

				Util.Log("RRMethod.PrintCSC Invoke base PrintCSC");                                     
				base.PrintCSC(textWriter, indentation, namePrefix, curNS, methodPrintEnum, bURTType,
							  bodyPrefix, sb);
				return;
			}

			// Fields
			private String _requestElementName;
			private String _requestElementNS;
			//private String _requestTypeName;
			//private String _requestTypeNS;
			private String _responseElementName;
			private String _responseElementNS;
			private WsdlMethodInfo _wsdlMethodInfo;
			//private String _responseTypeName;
			//private String _responseTypeNS;
		}

		// Reperents a oneway method
		internal class OnewayMethod : URTMethod
		{
			// Constructor
			internal OnewayMethod(String name, String soapAction, URTComplexType complexType)
			: base(name, soapAction, null, complexType)
			{
				Util.Log("OnewayMethod.OnewayMethod name "+name+" soapAction "+soapAction);
				_messageElementName = null;
				_messageElementNS = null;
				//_messageTypeName = null;
				//_messageTypeNS = null;
			}

			internal OnewayMethod(WsdlMethodInfo wsdlMethodInfo, URTComplexType complexType) 
			: base (wsdlMethodInfo.methodName, wsdlMethodInfo.soapAction, wsdlMethodInfo.methodAttributes, complexType)
			{
				Util.Log("OnewayMethod.OnewayMethod WsdlMethodInfo name "+wsdlMethodInfo.methodName+" soapAction "+wsdlMethodInfo.soapAction);
				_wsdlMethodInfo = wsdlMethodInfo;
				_messageElementName = null;
				_messageElementNS = null;
			}


			// Adds the request element
			internal void AddMessage(String name, String ns)
			{
				Util.Log("OnewayMethod.AddMessage name "+name+" ns "+ns);               
				_messageElementName = name;
				_messageElementNS = ns;
			}

			// Resolves the method
			internal override void ResolveTypes(WsdlParser parser)
			{
				Util.Log("OnewayMethod.ResolveTypes name "+ _messageElementName);
				ResolveWsdlParams(parser, _messageElementNS, _messageElementName, true, _wsdlMethodInfo);
				if (_paramNamesOrder != null)
				{
					// reorder parameters if there is a parameter order
					Object[] paramsInOrder = new Object[_params.Count];
					for (int i=0; i<_params.Count; i++)
					{
						paramsInOrder[(int)_paramPosition[i]] = _params[i];
					}
					_params =  new ArrayList(paramsInOrder);
				}

				ResolveMethodAttributes(); //Needs to be after param order

				return;
			}



			// Writes the oneway attribute and delegates to the base implementation
			internal override void PrintCSC(TextWriter textWriter, String indentation,
											String namePrefix, String curNS, MethodPrintEnum methodPrintEnum,
											bool bURTType, String bodyPrefix, StringBuilder sb)
			{
				Util.Log("OnewayMethod.PrintCSC name "+_messageElementName+" namePrefix "+namePrefix+" curNS "+curNS+" methodPrintEnum "+((Enum)methodPrintEnum).ToString());

				if (Name == "Finalize")
					return;

				bool bSoapAction = false;
				if (SoapAction != null)
					bSoapAction = true;

				if (!(bSoapAction || !bURTType))
				{
					textWriter.Write(indentation);
					textWriter.WriteLine("[OneWay]");
				}
				else
				{
					sb.Length = 0;
					sb.Append(indentation);
					sb.Append("[OneWay, SoapMethod(");

					if (bSoapAction)
					{
						sb.Append("SoapAction=");
						sb.Append(WsdlParser.IsValidUrl(SoapAction));
					}
					if (!bURTType)
					{
						if (bSoapAction)
							sb.Append(",");

						sb.Append("XmlNamespace=");
						sb.Append(WsdlParser.IsValidUrl(_wsdlMethodInfo.inputMethodNameNs)); 
						//sb.Append(_messageElementNS);
					}
					sb.Append(")]");
					textWriter.WriteLine(sb);                   
				}


				Util.Log("OnewayMethod.PrintCSC Invoke base PrintCSC");                                                     
				base.PrintCSC(textWriter, indentation, namePrefix, curNS, methodPrintEnum, bURTType,
							  bodyPrefix, sb);

				return;
			}

			// Fields
			private String _messageElementName;
			private String _messageElementNS;
			private WsdlMethodInfo _wsdlMethodInfo;
			//private String _messageTypeName;
			//private String _messageTypeNS;
		}

		// Base class for interfaces
		internal abstract class BaseInterface
		{
			internal BaseInterface(String name, String urlNS, String ns, String encodedNS, WsdlParser parser)
			{
				Util.Log("BaseInterface.BaseInterface");
				_name = name;
				_urlNS = urlNS;
				_namespace = ns;
				_encodedNS = encodedNS;
				_parser = parser;
			}
			internal String Name
			{
				get { return(_name);}
			}
			internal String UrlNS
			{
				get { return(_urlNS);}
			}
			internal String Namespace
			{
				get { return(_namespace);}
			}
			internal String EncodedNS
			{
				get { return(_encodedNS);}
			}

			internal bool IsURTInterface
			{
				get { return((Object) _namespace == (Object) _encodedNS);}
			}
			internal String GetName(String curNS)
			{
				String name;
				if (_parser.Qualify(_namespace, curNS))
				{
					StringBuilder sb = new StringBuilder(_encodedNS, 50);
					sb.Append('.');
					sb.Append(WsdlParser.IsValidCS(_name));
					name = sb.ToString();
				}
				else
					name = _name;

				Util.Log("BaseInterface.GetName curNS "+curNS);
				return(name);
			}
			internal abstract void PrintClassMethods(TextWriter textWriter,
													 String indentation,
													 String curNS,
													 ArrayList printedIFaces,
													 bool bProxy, StringBuilder sb);
			private String _name;
			private String _urlNS;
			private String _namespace;
			private String _encodedNS;
			private WsdlParser _parser;
		}

		// Represents a system interface
		internal class SystemInterface : BaseInterface
		{
			internal SystemInterface(String name, String urlNS, String ns, WsdlParser parser, String assemName)
			: base(name, urlNS, ns, ns, parser)
			{
				Util.Log("SystemInterface.SystemInterface");                
				Debug.Assert(ns.StartsWith("System"), "Invalid System type");
				String fullName = ns + '.' + name;

				Assembly assem = null;
				if (assemName == null)
					assem = typeof(string).Assembly;
				else
					assem = Assembly.LoadWithPartialName(assemName);

				if (assem == null)
					throw new SUDSParserException(String.Format(CoreChannel.GetResourceString("Remoting_Suds_AssemblyNotFound"), assemName));

				_type = assem.GetType(fullName, true);
			}
			internal override void PrintClassMethods(TextWriter textWriter,
													 String indentation,
													 String curNS,
													 ArrayList printedIFaces,
													 bool bProxy,
													 StringBuilder sb)
			{
				Util.Log("SystemInterface.PrintClassMethods "+curNS+" bProxy "+bProxy);                             
				// Return if the interfaces has already been printed
				int i;
				for (i=0;i<printedIFaces.Count;i++)
				{
					if (printedIFaces[i] is SystemInterface)
					{
						SystemInterface iface = (SystemInterface) printedIFaces[i];
						if (iface._type == _type)
							return;
					}
				}
				printedIFaces.Add(this);

				// Count of implemented methods
				BindingFlags bFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance |
									  BindingFlags.Public;// | BindingFlags.NonPublic;
				ArrayList types = new ArrayList();
				sb.Length = 0;
				types.Add(_type);
				i=0;
				int j=1;
				while (i<j)
				{
					Type type = (Type) types[i];
					MethodInfo[] methods = type.GetMethods(bFlags);
					Type[] iFaces = type.GetInterfaces();
					for (int k=0;k<iFaces.Length;k++)
					{
						for (int l=0;l<j;l++)
						{
							if (types[i] == iFaces[k])
								goto Loopback;
						}
						types.Add(iFaces[k]);
						j++;
						Loopback:
						continue;
					}

					for (int k=0;k<methods.Length;k++)
					{
						MethodInfo method = methods[k];
						sb.Length = 0;
						sb.Append(indentation);
						sb.Append(CSharpTypeString(method.ReturnType.FullName));
						sb.Append(' ');
						sb.Append(WsdlParser.IsValidCS(type.FullName));
						sb.Append('.');
						sb.Append(WsdlParser.IsValidCS(method.Name));
						sb.Append('(');
						ParameterInfo[] parameters = method.GetParameters();
						for (int l=0;l<parameters.Length;l++)
						{
							if (l != 0)
								sb.Append(", ");
							ParameterInfo param = parameters[l];
							Type parameterType = param.ParameterType;
							if (param.IsIn)
								sb.Append("in ");
							else if (param.IsOut)
								sb.Append("out ");
							else if (parameterType.IsByRef)
							{
								sb.Append("ref ");
								parameterType = parameterType.GetElementType();
							}
							sb.Append(CSharpTypeString(parameterType.FullName));
							sb.Append(' ');
							sb.Append(WsdlParser.IsValidCS(param.Name));
						}
						sb.Append(')');
						textWriter.WriteLine(sb);

						textWriter.Write(indentation);
						textWriter.WriteLine('{');

						String newIndentation = indentation + "    ";
						if (bProxy == false)
						{
							for (int l=0;l<parameters.Length;l++)
							{
								ParameterInfo param = parameters[l];
								Type parameterType = param.ParameterType;
								if (param.IsOut)
								{
									sb.Length = 0;
									sb.Append(newIndentation);
									sb.Append(WsdlParser.IsValidCS(param.Name));
									sb.Append(URTMethod.ValueString(CSharpTypeString(param.ParameterType.FullName)));
									sb.Append(';');
									textWriter.WriteLine(sb);
								}
							}

							Util.Log("SystemInterface.PrintClassMethods return 1 print");                           
							sb.Length = 0;
							sb.Append(newIndentation);
							sb.Append("return");
							String valueString = URTMethod.ValueString(CSharpTypeString(method.ReturnType.FullName));
							if (valueString != null)
							{
								sb.Append('(');
								sb.Append(valueString);
								sb.Append(')');
							}
							sb.Append(';');
						}
						else
						{
							Util.Log("SystemInterface.PrintClassMethods return 2 print");                                                       
							sb.Length = 0;
							sb.Append(newIndentation);
							sb.Append("return((");
							sb.Append(WsdlParser.IsValidCS(type.FullName));
							sb.Append(") _tp).");
							sb.Append(WsdlParser.IsValidCS(method.Name));
							sb.Append('(');
							if (parameters.Length > 0)
							{
								int lastParameter = parameters.Length-1;
								for (int l=0;l<parameters.Length;l++)
								{
									ParameterInfo param = parameters[0];
									Type parameterType = param.ParameterType;
									if (param.IsIn)
										sb.Append("in ");
									else if (param.IsOut)
										sb.Append("out ");
									else if (parameterType.IsByRef)
										sb.Append("ref ");
									sb.Append(WsdlParser.IsValidCS(param.Name));
									if (l < lastParameter)
										sb.Append(", ");
								}
							}
							sb.Append(");");
						}
						textWriter.WriteLine(sb);

						textWriter.Write(indentation);
						textWriter.WriteLine('}');
					}

					++i;
				}

				return;
			}
			private static String CSharpTypeString(String typeName)
			{
				Util.Log("SystemInterface.CSharpTypeString typeName "+typeName);                                                
				String CSCTypeName = typeName;
				if (typeName == "System.SByte")
					CSCTypeName = "sbyte";
				else if (typeName == "System.byte")
					CSCTypeName = "byte";
				else if (typeName == "System.Int16")
					CSCTypeName = "short";
				else if (typeName == "System.UInt16")
					CSCTypeName = "ushort";
				else if (typeName == "System.Int32")
					CSCTypeName = "int";
				else if (typeName == "System.UInt32")
					CSCTypeName = "uint";
				else if (typeName == "System.Int64")
					CSCTypeName = "long";
				else if (typeName == "System.UInt64")
					CSCTypeName = "ulong";
				else if (typeName == "System.Char")
					CSCTypeName = "char";
				else if (typeName == "System.Single")
					CSCTypeName = "float";
				else if (typeName == "System.Double")
					CSCTypeName = "double";
				else if (typeName == "System.Boolean")
					CSCTypeName = "boolean";
				else if (typeName == "System.Void")
					CSCTypeName = "void";
				else if (typeName == "System.String")
					CSCTypeName = "String";

				return(WsdlParser.IsValidCSAttr(CSCTypeName));
			}

			Type _type;
		}

		// Represents an interface

		internal class URTInterface : BaseInterface
		{
			internal URTInterface(String name, String urlNS, String ns, String encodedNS, WsdlParser parser)
			: base(name, urlNS, ns, encodedNS, parser)
			{
				Util.Log("URTInterface.URTInterface name "+name+" ns "+ns+" encodedNS "+encodedNS);                                             
				_baseIFaces = new ArrayList();
				_baseIFaceNames = new ArrayList();
				_extendsInterface = new ArrayList();
				_methods = new ArrayList();
				_parser = parser;
			}
			internal void Extends(String baseName, String baseNS, WsdlParser parser)
			{
				Util.Log("URTInterface.Extends baseName "+baseName+" baseNSf "+baseNS);
				_baseIFaceNames.Add(baseName);
				_baseIFaceNames.Add(baseNS);
				// Urt namespace will not have schema, they need to be recorded.
				URTNamespace parsingNamespace = parser.AddNewNamespace(baseNS);
				/*
				if (parsingNamespace == null)
				{
					parsingNamespace = new URTNamespace(baseNS, parser);
				}
				*/

				URTInterface parsingInterface = parsingNamespace.LookupInterface(baseName);         
				if (parsingInterface == null)
				{
					parsingInterface = new URTInterface(baseName, parsingNamespace.Name, parsingNamespace.Namespace, parsingNamespace.EncodedNS, parser);                  
					parsingNamespace.AddInterface(parsingInterface);
				}
				_extendsInterface.Add(parsingInterface);
			}

			internal void AddMethod(URTMethod method)
			{
				Util.Log("URTInterface.AddMethod method "+method.Name);
				_methods.Add(method);
				method.MethodFlags = MethodFlags.None; // method names don't have public modifiers
			}

			// Check if interface method occurs up the inheritance hierarchy
			internal void NewNeeded(URTMethod method)
			{
				Util.Log("URTInterface.NewNeeded Enter interface "+Name+" method "+method.Name);
				foreach (URTInterface urtInterface in _extendsInterface)
				{
					urtInterface.CheckIfNewNeeded(method);
					if (URTMethod.MethodFlagsTest(method.MethodFlags, MethodFlags.New))
						break;

				}
				Util.Log("URTInterface.NewNeeded Exit interface "+Name+" method "+method.Name+" "+((Enum)method.MethodFlags).ToString());
			}

			// Check this interface for method
			private void CheckIfNewNeeded(URTMethod method)
			{
				foreach (URTMethod urtMethod in _methods)
				{
					if (urtMethod.Name == method.Name)
					{
						method.MethodFlags |= MethodFlags.New;
						break;
					}
				}

				if (URTMethod.MethodFlagsTest(method.MethodFlags, MethodFlags.New))
					NewNeeded(method);
			}

			internal void ResolveTypes(WsdlParser parser)
			{
				Util.Log("URTInterface.ResolveTypes "+Name);                
				for (int i=0;i<_baseIFaceNames.Count;i=i+2)
				{
					String baseIFaceName = (String) _baseIFaceNames[i];
					String baseIFaceXmlNS = (String) _baseIFaceNames[i+1];
					String baseIFaceNS, baseIFaceAssemName;
					BaseInterface iFace;
					UrtType iType = parser.IsURTExportedType(baseIFaceXmlNS, out baseIFaceNS,
															 out baseIFaceAssemName);

					Util.Log("URTInterface.ResolveTypes Is System "+Name+" iType "+((Enum)iType).ToString()+" baseIFaceNS "+baseIFaceNS);                                   
					if ((iType != UrtType.Interop) && baseIFaceNS.StartsWith("System"))
					{
						iFace = new SystemInterface(baseIFaceName, baseIFaceXmlNS, baseIFaceNS, _parser, baseIFaceAssemName);
					}
					else
					{
						URTNamespace ns = parser.LookupNamespace(baseIFaceXmlNS);
						if (ns == null)
						{
							throw new SUDSParserException(
														 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
																	   baseIFaceXmlNS, baseIFaceName));
						}
						iFace = ns.LookupInterface(baseIFaceName);
						if (iFace == null)
						{
							throw new SUDSParserException(
														 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
																	   baseIFaceName, baseIFaceXmlNS));
						}
					}
					_baseIFaces.Add(iFace);
				}
				for (int i=0;i<_methods.Count;i++)
					((URTMethod) _methods[i]).ResolveTypes(parser);
			}
			internal void PrintCSC(TextWriter textWriter, String indentation,
								   String curNS, StringBuilder sb)
			{
				Util.Log("URTInterface.PrintCSC name "+Name+" curNS "+curNS);               
				bool bURTType = IsURTInterface;

				sb.Length = 0;
				sb.Append("\n"); 
				sb.Append(indentation);
				sb.Append("[SoapType(");

				if (_parser._xsdVersion == XsdVersion.V1999)
				{
					sb.Append("SoapOptions=SoapOption.Option1|SoapOption.AlwaysIncludeTypes|SoapOption.XsdString|SoapOption.EmbedAll,");
				}
				else if (_parser._xsdVersion == XsdVersion.V2000)
				{
					sb.Append("SoapOptions=SoapOption.Option2|SoapOption.AlwaysIncludeTypes|SoapOption.XsdString|SoapOption.EmbedAll,");
				}

				if (!bURTType)
				{
					sb.Append("XmlElementName=");
					sb.Append(WsdlParser.IsValidUrl(Name));
					sb.Append(", XmlNamespace=");
					sb.Append(WsdlParser.IsValidUrl(Namespace));
					sb.Append(", XmlTypeName=");
					sb.Append(WsdlParser.IsValidUrl(Name));
					sb.Append(", XmlTypeNamespace=");
					sb.Append(WsdlParser.IsValidUrl(Namespace));
				}
				else
				{
					// Need namespace for clr type because proxy dll might have a different name than server dll
					sb.Append("XmlNamespace=");
					sb.Append(WsdlParser.IsValidUrl(UrlNS));
					sb.Append(", XmlTypeNamespace=");
					sb.Append(WsdlParser.IsValidUrl(UrlNS));
				}

				sb.Append(")]");
				textWriter.WriteLine(sb);

				sb.Length = 0;
				sb.Append(indentation);
				sb.Append("public interface ");
				sb.Append(WsdlParser.IsValidCS(Name));

				if (_baseIFaces.Count > 0)
					sb.Append(" : ");

				if (_baseIFaces.Count > 0)
				{
					sb.Append(WsdlParser.IsValidCSAttr(((BaseInterface) _baseIFaces[0]).GetName(curNS)));
					for (int i=1;i<_baseIFaces.Count;i++)
					{
						sb.Append(", ");
						sb.Append(WsdlParser.IsValidCSAttr(((BaseInterface) _baseIFaces[i]).GetName(curNS)));
					}
				}

				textWriter.WriteLine(sb);

				textWriter.Write(indentation);
				textWriter.WriteLine('{');

				String newIndentation = indentation + "    ";
				String namePrefix = " ";
				Util.Log("URTInterface.PrintCSC method count "+_methods.Count);

				for (int i=0;i<_methods.Count;i++)
				{
					Util.Log("URTInterface.PrintCSC Invoke methods in Interface PrintCSC "+Name+" methodName "+((URTMethod) _methods[i]).Name);
					NewNeeded((URTMethod)_methods[i]);
					((URTMethod) _methods[i]).PrintCSC(textWriter, newIndentation,
													   namePrefix, curNS, MethodPrintEnum.InterfaceMethods, bURTType,
													   null, sb);
				}
				textWriter.Write(indentation);
				textWriter.WriteLine('}');
			}

			// No longer used
			internal override void PrintClassMethods(TextWriter textWriter,
													 String indentation,
													 String curNS,
													 ArrayList printedIFaces,
													 bool bProxy,
													 StringBuilder sb)
			{
				Util.Log("URTInterface.PrintClassMethods method "+Name+" curNS "+curNS+" bProxy "+bProxy);              
				// Return if the interface has already been printed
				for (int i=0;i<printedIFaces.Count;i++)
				{
					if (printedIFaces[i] == this)
					{
						Util.Log("URTInterface.PrintClassMethods printedIFaces return "+Name);
						return;
					}
				}
				Util.Log("URTInterface.PrintClassMethods method 2 "+Name+" _methods.Count "+_methods.Count);                
				printedIFaces.Add(this);
				sb.Length = 0;
				sb.Append(indentation);
				if (_methods.Count > 0)
				{
					sb.Append("// ");
					sb.Append(WsdlParser.IsValidCS(Name));
					sb.Append(" interface Methods");
					textWriter.WriteLine(sb);

					sb.Length = 0;
					sb.Append(' ');
					String ifaceName = GetName(curNS);
					sb.Append(WsdlParser.IsValidCS(ifaceName));
					sb.Append('.');
					String namePrefix = sb.ToString();

					String bodyPrefix = null;
					if (bProxy)
					{
						sb.Length = 0;
						sb.Append("((");
						sb.Append(WsdlParser.IsValidCS(ifaceName));
						sb.Append(") _tp).");
						bodyPrefix = sb.ToString();
					}

					MethodPrintEnum methodPrintEnum = MethodPrintEnum.PrintBody | MethodPrintEnum.InterfaceInClass;
					for (int i=0;i<_methods.Count;i++)
					{
						Util.Log("URTInterface.PrintClassMethods URTMethod invoke interface methods in class PrintCSC "+Name+" methodName "+((URTMethod) _methods[i]));

						((URTMethod) _methods[i]).PrintCSC(textWriter, indentation,
														   namePrefix, curNS, methodPrintEnum,
														   true, bodyPrefix, sb); 
					}
				}

				for (int i=0;i<_baseIFaces.Count;i++)
				{
					Util.Log("URTInterface.PrintClassMethods BaseIFaces "+Name);
					((BaseInterface) _baseIFaces[i]).PrintClassMethods(textWriter,
																	   indentation,
																	   curNS,
																	   printedIFaces,
																	   bProxy, sb);
				}
			}

			private WsdlParser _parser;
			private ArrayList _baseIFaces;
			private ArrayList _baseIFaceNames;
			private ArrayList _methods;
			private ArrayList _extendsInterface;
		}

		// Represents a field of a type
		internal class URTField
		{
			internal URTField(String name, String typeName, String xmlNS, WsdlParser parser,
							  bool bPrimitive, bool bEmbedded, bool bAttribute, bool bOptional,
							  bool bArray, String arraySize, URTNamespace urtNamespace)
			{
				Util.Log("URTField.URTField "+name+" typeName "+typeName+" xmlNS "+xmlNS+" bPrimitive "+bPrimitive+" bEmbedded "+bEmbedded+" bAttribute "+bAttribute);
				_name = name;
				_typeName = typeName;
				_parser = parser;
				String typeAssemName;

				UrtType urtType = parser.IsURTExportedType(xmlNS, out _typeNS, out typeAssemName);
				if (urtType == UrtType.Interop)
					_encodedNS = urtNamespace.EncodedNS;
				else
					_encodedNS = _typeNS;
				_primitiveField = bPrimitive;
				_embeddedField = bEmbedded;
				_attributeField = bAttribute;
				_optionalField = bOptional;
				_arrayField = bArray;
				_arraySize = arraySize;
				_urtNamespace = urtNamespace;
			}
			internal String Name
			{
				get { return(_name);}
			}
			internal String TypeName
			{
				get
				{
					if (_arrayField)
						return(_typeName + "[]");
					return(_typeName);
				}
			}
			internal String TypeNS
			{
				get { return(_typeNS);}
			}
			internal String EncodedNS
			{
				get { return(_encodedNS);}
			}
			internal bool IsPrimitive
			{
				get { return(_primitiveField);}
			}
			internal bool IsEmbedded
			{
				get { return(_embeddedField);}
			}
			internal bool IsAttribute
			{
				get { return(_attributeField);}
			}
			internal bool IsArray
			{
				get { return(_arrayField);}
			}
			internal bool IsOptional
			{
				get { return(_optionalField);}
			}
			internal String GetTypeString(String curNS, bool bNS)
			{
				return _parser.GetTypeString (curNS, bNS, _urtNamespace, TypeName, _typeNS);
			}

			internal void PrintCSC(TextWriter textWriter, String indentation,
								   String curNS, StringBuilder sb)
			{
				Util.Log("URTField.PrintCSC name "+_name+" curNS"+curNS);               
				if (_embeddedField)
				{
					textWriter.Write(indentation);
					textWriter.WriteLine("[SoapField(Embedded=true)]");
				}

				sb.Length = 0;
				sb.Append(indentation);
				sb.Append("public ");
				sb.Append(WsdlParser.IsValidCSAttr(GetTypeString(curNS, true))); 
				sb.Append(' ');
				sb.Append(WsdlParser.IsValidCS(_name));
				sb.Append(';');
				textWriter.WriteLine(sb);
			}

			private String _name;
			private String _typeName;
			private String _typeNS;
			private String _encodedNS;
			private bool _primitiveField;
			private bool _embeddedField;
			private bool _attributeField;
			private bool _optionalField;
			private bool _arrayField;
			private String _arraySize;
			private WsdlParser _parser;
			private URTNamespace _urtNamespace;
		}

		internal abstract class SchemaFacet
		{
			protected SchemaFacet()
			{
			}
			internal virtual void ResolveTypes(WsdlParser parser)
			{
			}
			internal abstract void PrintCSC(TextWriter textWriter, String newIndentation,
											String curNS, StringBuilder sb);
		}

		internal class EnumFacet : SchemaFacet
		{
			internal EnumFacet(String valueString, int value)
			: base()
			{
				Util.Log("EnumFacet.EnumFacet valueString "+valueString+" value "+value);               
				_valueString = valueString;
				_value = value;
			}
			internal override void PrintCSC(TextWriter textWriter, String newIndentation,
											String curNS, StringBuilder sb)
			{
				Util.Log("EnumFacet.PrintCSC _valueString "+_valueString+" value "+_value+" curNS "+curNS);
				sb.Length = 0;
				sb.Append(newIndentation);
				sb.Append(WsdlParser.IsValidCS(_valueString));
				sb.Append(" = ");
				sb.Append(_value);
				sb.Append(',');
				textWriter.WriteLine(sb);
				return;
			}

			private String _valueString;
			private int _value;
		}

		// Represents a Base type
		internal abstract class BaseType
		{
			internal BaseType(String name, String urlNS, String ns, String encodedNS)
			{
				_searchName = name;
				_name = name;
				_urlNS = urlNS;
				_namespace = ns;
				_elementName = _name;
				_elementNS = ns;
				_encodedNS = encodedNS;
				Util.Log("BaseType.BaseType in name "+name+" storedname "+_name+" nested "+_bNestedType);
			}
			internal String Name
			{
				get { return(_name);}
				set { _name = value;}
			}

			internal String SearchName
			{
				get { return(_searchName);}
				set { _searchName = value;}
			}

			internal String OuterTypeName
			{
				get { return(_outerTypeName);}
				set { _outerTypeName = value;}


			}

			internal String NestedTypeName
			{
				get { return(_nestedTypeName);}
				set { _nestedTypeName = value;}
			}

			internal String FullNestedTypeName
			{
				get { return(_fullNestedTypeName);}
				set { _fullNestedTypeName = value;}
			}

			internal bool bNestedType
			{
				get { return(_bNestedType);}
				set { _bNestedType = value;}
			}

			internal bool bNestedTypePrint
			{
				get { return(_bNestedTypePrint);}
				set { _bNestedTypePrint = value;}
			}

			internal String UrlNS
			{
				get { return(_urlNS);}
			}

			internal String Namespace
			{
				get { return(_namespace);}
			}
			internal String EncodedNS
			{
				get { return(_encodedNS);}
			}

			internal String ElementName
			{
				get { return(_elementName);}
				set { _elementName = value;}
			}
			internal String ElementNS
			{
				get { return(_elementNS);}
				set { _elementNS = value;}
			}

			internal bool IsURTType
			{
				get {
					Util.Log("BaseType.IsURTType _namespace "+_namespace+" _encodedNS "+_encodedNS+" "+((Object) _namespace == (Object) _encodedNS));
					return((Object) _namespace == (Object) _encodedNS);}
			}

			internal bool IsInteropType
			{
				get { return((Object) _namespace != (Object) _encodedNS);}
			}

			internal virtual String GetName(String curNS)
			{
				String name;
				if (MatchingStrings(_namespace, curNS))
					name = _name;
				else
				{
					StringBuilder sb = new StringBuilder(_encodedNS, 50);
					sb.Append('.');
					sb.Append(WsdlParser.IsValidCS(_name));
					name = sb.ToString();
				}

				return(name);
			}
			internal abstract MethodFlags GetMethodFlags(URTMethod method);
			internal abstract bool IsEmittableFieldType
			{
				get;
			}
			internal abstract String FieldName
			{
				get;
			}

			internal abstract String FieldNamespace
			{
				get;
			}

			internal abstract bool PrimitiveField
			{
				get;
			}

			private String _name;
			private String _searchName;
			private String _urlNS;
			private String _namespace;
			private String _elementName;
			private String _elementNS;
			private String _encodedNS;
			internal ArrayList _nestedTypes; // nested types within this type
			internal String _nestedTypeName;  //If this type is nested, name of nested type (without + mangle)
			internal String _fullNestedTypeName; //If this type is nested, name of nested type (without + mangle) with outer class qualifier
			internal String _outerTypeName;
			internal bool _bNestedType = false;	//Contains nested types
			internal bool _bNestedTypePrint = false;
		}

		// Representa a system type
		internal class SystemType : BaseType
		{
			internal SystemType(String name, String urlNS, String ns, String assemName)
			: base(name, urlNS, ns, ns)
			{
				Util.Log("SystemType.SystemType name "+name+" ns "+ns+" assemName "+assemName);             
				Debug.Assert(ns.StartsWith("System"), "Invalid System type");

				String fullName = ns + '.' + name;

				Assembly assem = null;
				if (assemName == null)
					assem = typeof(string).Assembly;
				else
					assem = Assembly.LoadWithPartialName(assemName);

				if (assem == null)
					throw new SUDSParserException(String.Format(CoreChannel.GetResourceString("Remoting_Suds_AssemblyNotFound"), assemName));

				_type = assem.GetType(fullName, true);
			}
			internal override MethodFlags GetMethodFlags(URTMethod method)
			{
				BindingFlags bFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance |
									  BindingFlags.Public | BindingFlags.NonPublic;
				Type type = _type;
				while (type != null)
				{
					MethodInfo[] methods = type.GetMethods(bFlags);
					for (int i=0;i<methods.Length;i++)
					{
						MethodFlags methodFlags = method.GetMethodFlags(methods[i]);
						if (methodFlags != 0)
							return(methodFlags);
					}
					type = type.BaseType;
				}

				return(0);
			}
			internal override bool IsEmittableFieldType
			{
				get { return(true);}
			}

			internal override String FieldName
			{
				get { return(null);}
			}
			internal override String FieldNamespace
			{
				get { return(null);}
			}
			internal override bool PrimitiveField
			{
				get { return(false);}
			}

			private Type _type;
		}

		// Represents a simple type
		internal class URTSimpleType : BaseType
		{
			internal URTSimpleType(String name, String urlNS, String ns, String encodedNS, bool bAnonymous, WsdlParser parser)
			: base(name, urlNS, ns, encodedNS)
			{
				Util.Log("URTSimpleType.URTSimpleType name "+name+" ns "+ns+" encodedNS "+encodedNS+" bAnonymous "+bAnonymous);
				_baseTypeName = null;
				_baseTypeXmlNS = null;
				_baseType = null;
				_fieldString = null;
				_facets = new ArrayList();
				_bEnum = false;
				_bAnonymous = bAnonymous;
				_encoding = null;
				_parser = parser;
			}

			internal void Extends(String baseTypeName, String baseTypeNS)
			{
				Util.Log("URTSimpleType.Extends baseTypeName "+baseTypeName+" baseTypeNS "+baseTypeNS);
				_baseTypeName = baseTypeName;
				_baseTypeXmlNS = baseTypeNS;

			}

			internal bool IsEnum
			{
				get { return(_bEnum);}
				set { _bEnum = value;}
			}

			internal String Encoding
			{
				get { return(_encoding);}
				set { _encoding = value;}
			}

			internal String EnumType
			{
				get { return(_enumType);}
				set {
					String typeName = value;
					String typeNS = _parser.ParseQName(ref typeName);
					if (typeName != null && typeName.Length > 0)
						_enumType = MapToEnumType(_parser.MapSchemaTypesToCSharpTypes(typeName));

				}
			}

			private String MapToEnumType(String type)
			{
				String etype = null;
				if (type == "Byte")
					etype = "byte";
				else if (type == "SByte")
					etype = "sbyte";
				else if (type == "Int16")
					etype = "short";
				else if (type == "UInt16")
					etype = "ushort";
				else if (type == "Int32")
					etype = "int";
				else if (type == "UInt32")
					etype = "uint";
				else if (type == "Int64")
					etype = "long";
				else if (type == "UInt64")
					etype = "ulong";
				else
					throw new SUDSParserException(
												 String.Format(CoreChannel.GetResourceString("Remoting_Suds_InvalidEnumType"), type));

				return etype;
			}

			internal void AddFacet(SchemaFacet facet)
			{
				Util.Log("URTSimpleType.AddFacet");
				_facets.Add(facet);
			}

			internal bool IsAnonymous
			{
				get {return _bAnonymous;}
			}

			internal override bool IsEmittableFieldType
			{
				get
				{
					if (_fieldString == null)
					{
						if ((_bAnonymous == true) &&
							(_facets.Count == 0) &&
							(_encoding != null) &&
							(_baseTypeName == "binary") &&
							(_parser.MatchingSchemaStrings(_baseTypeXmlNS)))
							_fieldString = "byte[]";
						else
							_fieldString = String.Empty;
					}

					return(_fieldString != String.Empty);
				}
			}
			internal override String FieldName
			{
				get { return(_fieldString);}
			}

			internal override String FieldNamespace
			{
				get { 
					String schemaStr = null;
					if (_parser._xsdVersion == XsdVersion.V1999)
						schemaStr = s_schemaNamespaceString1999;
					else if (_parser._xsdVersion == XsdVersion.V2000)
						schemaStr = s_schemaNamespaceString2000;
					else if (_parser._xsdVersion == XsdVersion.V2001)
						schemaStr = s_schemaNamespaceString;
					return schemaStr;
				}
			}

			internal override bool PrimitiveField
			{
				get { return(true);}
			}

			internal override String GetName(String curNS)
			{
				if ((_fieldString != null) && (_fieldString != String.Empty))
					return(_fieldString);

				Util.Log("URTSimpleType.GetName curNS "+curNS+" return "+base.GetName(curNS));              
				return(base.GetName(curNS));
			}

			internal void ResolveTypes(WsdlParser parser)
			{
				Util.Log("URTSimpleType.ResolveTypes "+Name);               
				if (_baseTypeName != null)
				{
					if (_parser.IsPrimitiveType(_baseTypeXmlNS, _baseTypeName))
					{
						if (IsEnum == false)
							_baseName = _parser.MapSchemaTypesToCSharpTypes(_baseTypeName);
					}
					else
					{
						URTNamespace ns = parser.LookupNamespace(_baseTypeXmlNS);
						if (ns == null)
						{
							throw new SUDSParserException(
														 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
																	   _baseTypeXmlNS, _baseTypeName));
						}
						_baseType = ns.LookupComplexType(_baseTypeName);
						if (_baseType == null)
						{
							throw new SUDSParserException(
														 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
																	   _baseTypeName, _baseTypeXmlNS));
						}
					}
				}

				for (int i=0;i<_facets.Count;i++)
					((SchemaFacet) _facets[i]).ResolveTypes(parser);

				return;
			}
			internal void PrintCSC(TextWriter textWriter, String indentation,
								   String curNS, StringBuilder sb)
			{
				Util.Log("URTSimpleType.PrintCSC name "+Name+" curNS "+curNS);                              

				// Print only if the type is not an emittable field type
				if (IsEmittableFieldType == true)
					return;

				if (bNestedType && !bNestedTypePrint)
					return;

				// Handle encoding
				if (_encoding != null)
				{
					// sb.Length = 0;
					// sb.Append(indentation);
				}

				sb.Length = 0;
				sb.Append("\n"); 
				sb.Append(indentation);
				sb.Append("[");
				sb.Append("Serializable, ");
				sb.Append("SoapType(");

				if (_parser._xsdVersion == XsdVersion.V1999)
				{
					sb.Append("SoapOptions=SoapOption.Option1|SoapOption.AlwaysIncludeTypes|SoapOption.XsdString|SoapOption.EmbedAll,");
				}
				else if (_parser._xsdVersion == XsdVersion.V2000)
				{
					sb.Append("SoapOptions=SoapOption.Option2|SoapOption.AlwaysIncludeTypes|SoapOption.XsdString|SoapOption.EmbedAll,");
				}

				// Need namespace for clr type because proxy dll might have a different name than server dll
				sb.Append("XmlNamespace=");
				sb.Append(WsdlParser.IsValidUrl(UrlNS));
				sb.Append(", XmlTypeNamespace=");
				sb.Append(WsdlParser.IsValidUrl(UrlNS)); 

				sb.Append(")]");
				textWriter.WriteLine(sb);


				// Print type
				sb.Length = 0;
				sb.Append(indentation);

				// Handle Enum case
				if (IsEnum)
					sb.Append("public enum ");
				else
					sb.Append("public class ");

				if (_bNestedType)
					sb.Append(WsdlParser.IsValidCS(NestedTypeName));
				else
					sb.Append(WsdlParser.IsValidCS(Name));
				if (_baseType != null)
				{
					sb.Append(" : ");
					sb.Append(WsdlParser.IsValidCSAttr(_baseType.GetName(curNS)));
				}
				else if (_baseName != null)
				{
					sb.Append(" : ");
					sb.Append(WsdlParser.IsValidCSAttr(_baseName));
				}
				else if (IsEnum && _enumType != null && _enumType.Length > 0)
				{
					sb.Append(" : ");
					sb.Append(WsdlParser.IsValidCSAttr(_enumType));
				}

				textWriter.WriteLine(sb);

				textWriter.Write(indentation);
				textWriter.WriteLine('{');

				String newIndentation = indentation + "    ";
				for (int i=0;i<_facets.Count;i++)
				{
					Util.Log("URTSimpleType.PrintCSC Invoke _facets PrintCSC ");                                                                                                        
					((SchemaFacet) _facets[i]).PrintCSC(textWriter, newIndentation, curNS, sb);
				}

				textWriter.Write(indentation);
				textWriter.WriteLine('}');
				return;
			}

			internal override MethodFlags GetMethodFlags(URTMethod method)
			{
				Debug.Assert(false, "GetMethodFlags called on a SimpleSchemaType");
				return(0);
			}

			private String _baseTypeName;
			private String _baseTypeXmlNS;
			private BaseType _baseType;
			private String _baseName;
			private String _fieldString;
			private bool  _bEnum;
			private bool _bAnonymous;
			private String _encoding;
			private ArrayList _facets;
			private String _enumType;
			private WsdlParser _parser;
		}

		// Represents a complex type
		internal class URTComplexType : BaseType
		{
			internal URTComplexType(String name, String urlNS, String ns, String encodedNS,
									SchemaBlockType blockDefault, bool bSUDSType, bool bAnonymous, WsdlParser parser, URTNamespace xns)
			: base(name, urlNS, ns, encodedNS)
			{
				Util.Log("URTComplexType.URTComplexType name "+this.GetHashCode()+" "+name+" urlNS "+urlNS+" ns "+ns+" encodedNS "+encodedNS+" bSUDStype "+bSUDSType+" bAnonymous "+bAnonymous);
				_baseTypeName = null;
				_baseTypeXmlNS = null;
				_baseType = null;
				_connectURLs = null;
				_bStruct = !bSUDSType;
				_blockType = blockDefault;
				_bSUDSType = bSUDSType;
				_bAnonymous = bAnonymous;
				Debug.Assert(bAnonymous == false || _bSUDSType == false);
				_fieldString = null;
				_fields = new ArrayList();
				_methods = new ArrayList();
				_implIFaces = new ArrayList();
				_implIFaceNames = new ArrayList();
				_sudsType = SUDSType.None;              
				_parser = parser;

				int index = name.IndexOf('+');
				if (index > 0)
				{
					// Nested type see if outer type has been added to namespace
					String outerType = parser.Atomize(name.Substring(0,index));
					URTComplexType cs = xns.LookupComplexType(outerType);
					if (cs == null)
					{
						URTComplexType newCs = new URTComplexType(outerType, urlNS, ns, encodedNS, blockDefault, bSUDSType, bAnonymous, parser, xns);
						Util.Log("URTComplexType.URTComplexType add outerType to namespace "+outerType+" nestedname "+name);
						xns.AddComplexType(newCs);
					}
				}


				if (xns.UrtType == UrtType.Interop)
				{
					// Interop class names can have '.', replace these with '_', and set wire name to original type name.
					index = name.LastIndexOf('.');
					if (index > -1)
					{
						// class names can't have '.' so replace with '$'. Use xmlType attribute to send original name on wire.
						_wireType = name;
						Name = name.Replace(".", "_");
						SearchName = name;
					}
				}

			}

			internal void AddNestedType(BaseType ct)
			{
				if (_nestedTypes == null)
					_nestedTypes = new ArrayList(10);

				_nestedTypes.Add(ct);
			}

			internal void Extends(String baseTypeName, String baseTypeNS)
			{
				Util.Log("URTComplexType.Extends baseTypeName "+baseTypeName+" baseTypeNS "+baseTypeNS);
				_baseTypeName = baseTypeName;
				_baseTypeXmlNS = baseTypeNS;
			}
			internal void Implements(String iFaceName, String iFaceNS, WsdlParser parser)
			{
				Util.Log("URTComplexType.Implements IFaceName "+iFaceName+" iFaceNS "+iFaceNS);
				_implIFaceNames.Add(iFaceName);
				_implIFaceNames.Add(iFaceNS);
				// Urt namespace will not have schema, they need to be recorded.
				URTNamespace parsingNamespace = parser.AddNewNamespace(iFaceNS);
				/*
				if (parsingNamespace == null)
				{
					parsingNamespace = new URTNamespace(iFaceNS, parser);
				}
				*/

				URTInterface parsingInterface = parsingNamespace.LookupInterface(iFaceName);            
				if (parsingInterface == null)
				{
					parsingInterface = new URTInterface(iFaceName, parsingNamespace.Name, parsingNamespace.Namespace, parsingNamespace.EncodedNS, _parser);                    
					parsingNamespace.AddInterface(parsingInterface);
				}
			}

			internal ArrayList ConnectURLs
			{
				get { return(_connectURLs);}
				set {
					_connectURLs = value;
				}
			}
			internal bool IsStruct
			{
				get { return(_bStruct);}
				set { _bStruct = value;}
			}
			internal bool IsSUDSType
			{
				get { return(_bSUDSType);}
				set {_bSUDSType = value; _bStruct = !value;}
			}
			internal SUDSType SUDSType
			{
				get { return(_sudsType);}
				set { _sudsType = value;}
			}
			internal SudsUse SudsUse
			{
				get { return(_sudsUse);}
				set { _sudsUse = value;}
			}

			internal bool IsValueType
			{
				get {return _bValueType;}
				set {_bValueType = value;}
			}

			internal SchemaBlockType BlockType
			{
				get { return(_blockType);}
				set { _blockType = value;}
			}
			internal bool IsAnonymous
			{
				get {return _bAnonymous;}
			}           

			internal String WireType
			{
				get { return(_wireType);}
				set { _wireType = value;}
			}

			internal ArrayList Inherit
			{
				get { return(_inherit);}
				set { _inherit = value;}
			}

			internal bool IsArray()
			{
				Util.Log("URTComplexType.IsArray "+this.GetHashCode()+" "+Name+" IsArray "+_arrayType);
				if (_arrayType != null)
					return true;
				else
					return false;
			}
			internal String GetArray()
			{
				return _clrarray;
			}
			internal URTNamespace GetArrayNS()
			{
				return _arrayNS;
			}

			internal String GetClassName()
			{
				String cname = null;
				if (_bNameMethodConflict)
					cname = "C"+Name; // Class name generated from a non-Suds wsdl and a method name and portType conflicted.
				else
					cname = Name;
				return cname;
			}

			internal bool IsPrint
			{
				get {return _bprint;}
				set {_bprint = value;}
			}

			internal override bool IsEmittableFieldType
			{
				get
				{
					Util.Log("URTComplexType.IsEmittableFieldType _fieldString "+_fieldString+" _bAnonymous "+_bAnonymous+" _fields.Count "+_fields.Count);
					if (_fieldString == null)
					{
						if ((_bAnonymous == true) &&
							(_fields.Count == 1))
						{
							URTField field = (URTField) _fields[0];
							if (field.IsArray)
							{
								_fieldString = field.TypeName;
								return(true);
							}
						}
						_fieldString = String.Empty;
					}

					return(_fieldString != String.Empty);
				}
			}
			internal override String FieldName
			{
				get { return(_fieldString);}
			}
			internal override String FieldNamespace
			{
				get { return(((URTField) _fields[0]).TypeNS);}
			}
			internal override bool PrimitiveField
			{
				get { return((((URTField) _fields[0]).IsPrimitive));}
			}
			internal override String GetName(String curNS)
			{
				if ((_fieldString != null) && (_fieldString != String.Empty))
					return(_fieldString);

				return(base.GetName(curNS));
			}
			internal ArrayList Fields
			{
				get { return _fields;}
			}
			internal ArrayList Methods
			{
				get { return _methods;}
			}
			internal void AddField(URTField field)
			{
				Util.Log("URTComplexType.AddField");
				_fields.Add(field);
			}
			internal void AddMethod(URTMethod method)
			{
				Util.Log("URTComplexType.AddMethod "+method);               
				if (method.Name == Name)
				{
					// Type generated from an non-suds wsdl. Append the class name with a C when printing.
					_bNameMethodConflict = true;
				}
				_methods.Add(method);
				int index = method.Name.IndexOf('.');
				if (index > 0)
					method.MethodFlags = MethodFlags.None; //interface qualfied method names have no method modifier
				else
					method.MethodFlags = method.MethodFlags |= MethodFlags.Public; // method names are public for this version of wsdl

			}
			private URTMethod GetMethod(String name)
			{
				Util.Log("URTComplexType.GetMethod "+name+" count "+_methods.Count+" Name "+Name+" base ns "+_baseTypeXmlNS+" base name "+_baseTypeName);                             
				for (int i=0;i<_methods.Count;i++)
				{
					URTMethod method = (URTMethod) _methods[i];
					Util.Log("URTComplexType.GetMethod interate "+method.Name);                             
					if (method.Name == name)
						return(method);
				}

				return(null);
			}
			internal void ResolveTypes(WsdlParser parser)
			{
				Util.Log("URTComplexType.ResolveTypes "+Name+" _baseTypeName "+_baseTypeName+" IsSUDSType "+IsSUDSType);
				String baseTypeNS = null;
				String baseTypeAssemName = null;
				if (IsArray())
				{
					ResolveArray();
					return;
				}

				if (IsSUDSType)
				{
					// BaseType == null;
					if (_sudsType == SUDSType.None)
					{
						if (_parser._bWrappedProxy)
							_sudsType = SUDSType.ClientProxy;
						else
							_sudsType = SUDSType.MarshalByRef;
					}
				}


				if (_baseTypeName != null)
				{
					Util.Log("URTComplexType.ResolveTypes 1 ");
					UrtType urtType = parser.IsURTExportedType(_baseTypeXmlNS, out baseTypeNS, out baseTypeAssemName);
					if (urtType == UrtType.UrtSystem || baseTypeNS.StartsWith("System"))
					{
						_baseType = new SystemType(_baseTypeName, _baseTypeXmlNS, baseTypeNS, baseTypeAssemName);
					}
					else
					{
						URTNamespace ns = parser.LookupNamespace(_baseTypeXmlNS);
						if (ns == null)
						{
							throw new SUDSParserException(
														 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
																	   _baseTypeXmlNS, _baseTypeName));
						}
						_baseType = ns.LookupComplexType(_baseTypeName);
						if (_baseType == null)
						{
							_baseType = new SystemType(_baseTypeName, _baseTypeXmlNS, baseTypeNS, baseTypeAssemName);

							/*
							throw new SUDSParserException(
														 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
																	   _baseTypeName, _baseTypeXmlNS));
																	   */
						}
					}

				}

				// Top of inheritance hiearchy for a Wrapped proxy is RemotingClientProxy
				if (IsSUDSType)
				{
					if (_parser._bWrappedProxy)
					{

						if (_baseTypeName == null || _baseType is SystemType)
						{
							_baseTypeName = "RemotingClientProxy";
							//_baseTypeXmlNS = "http://schemas.microsoft.com/urt/NSAssem/System.Runtime.Remoting/System.Runtime.Remoting";
							_baseTypeXmlNS = SoapServices.CodeXmlNamespaceForClrTypeNamespace("System.Runtime.Remoting","System.Runtime.Remoting");
							baseTypeNS = "System.Runtime.Remoting.Services";
							baseTypeAssemName = "System.Runtime.Remoting";
							_baseType = new SystemType(_baseTypeName, _baseTypeXmlNS, baseTypeNS, baseTypeAssemName);
						}
					}
					else if (_baseTypeName == null)
					{
						_baseTypeName = "MarshalByRefObject";
						//_baseTypeXmlNS = "http://schemas.microsoft.com/urt/NS/System";
						_baseTypeXmlNS = SoapServices.CodeXmlNamespaceForClrTypeNamespace("System", null);
						baseTypeNS = "System";
						baseTypeAssemName = null;
						_baseType = new SystemType(_baseTypeName, _baseTypeXmlNS, baseTypeNS, baseTypeAssemName);
					}

				}
				else if (_baseType == null)
				{
					Util.Log("URTComplexType.ResolveTypes 5 ");                                         
					_baseType = new SystemType("Object", SoapServices.CodeXmlNamespaceForClrTypeNamespace("System", null), "System", null);
				}

				for (int i=0;i<_implIFaceNames.Count;i=i+2)
				{
					String implIFaceName = (String) _implIFaceNames[i];
					String implIFaceXmlNS = (String) _implIFaceNames[i+1];
					String implIFaceNS, implIFaceAssemName;
					BaseInterface iFace;


					UrtType iType = parser.IsURTExportedType(implIFaceXmlNS, out implIFaceNS,
															 out implIFaceAssemName);

					if (iType == UrtType.UrtSystem)// && implIFaceNS.StartsWith("System"))
					{
						iFace = new SystemInterface(implIFaceName, implIFaceXmlNS, implIFaceNS, parser, implIFaceAssemName);
					}
					else
					{
						URTNamespace ns = parser.LookupNamespace(implIFaceXmlNS);
						if (ns == null)
						{
							throw new SUDSParserException(
														 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
																	   implIFaceXmlNS, implIFaceName));
						}
						iFace = ns.LookupInterface(implIFaceName);
						if (iFace == null)
						{
							throw new SUDSParserException(
														 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
																	   implIFaceName, implIFaceXmlNS));
						}
					}
					_implIFaces.Add(iFace);
				}
				for (int i=0;i<_methods.Count;i++)
					((URTMethod) _methods[i]).ResolveTypes(parser);
			}

			internal void ResolveMethods()
			{
				Util.Log("URTComplexType.ResolveMethods "+Name);                
				for (int i=0;i<_methods.Count;i++)
				{
					URTMethod method = (URTMethod) _methods[i];
					/*
					if (method.MethodFlags == 0)
						method.MethodFlags = _baseType.GetMethodFlags(method);
						*/
				}

				return;
			}
			internal override MethodFlags GetMethodFlags(URTMethod method)
			{
				/*
				Debug.Assert(method.MethodFlags == 0, "Method has already been considered");

				MethodFlags methodFlags = _baseType.GetMethodFlags(method);
				for (int i=0;i<_methods.Count;i++)
				{
					URTMethod thisMethod = (URTMethod) _methods[i];
					if (thisMethod.Equals(method))
						thisMethod.MethodFlags = method.MethodFlags;
				}
				*/

				return(method.MethodFlags);
			}

			internal void PrintCSC(TextWriter textWriter, String indentation, String curNS, StringBuilder sb)
			{
				Util.Log("URTComplexType.PrintCSC enter name "+Name+" curNS "+curNS+" sudsUse "+((Enum)_sudsUse).ToString()+" bNestedType "+bNestedType+" bNestedTypePrint "+bNestedTypePrint);
				// Print only if the type is not an emittable field type
				if (IsEmittableFieldType == true)
					return;

				if (bNestedType && !bNestedTypePrint)
					return;


				// Handle delegate case
				sb.Length = 0;
				sb.Append(indentation);
				if (_baseTypeName != null)
				{
					String baseName = _baseType.GetName(curNS);
					if ((baseName == "System.Delegate") || (baseName == "System.MulticastDelegate"))
					{
						sb.Append("public delegate ");
						URTMethod invokeMethod = GetMethod("Invoke");
						if (invokeMethod == null)
						{
							throw new SUDSParserException(
														 CoreChannel.GetResourceString("Remoting_Suds_DelegateWithoutInvoke"));
						}
						String typeString = invokeMethod.GetTypeString(curNS, true);
						sb.Append(WsdlParser.IsValidCSAttr(typeString));
						sb.Append(' ');

						String printName = Name;
						int index = printName.IndexOf('.');
						if (index > 0)
						{
							printName = printName.Substring(index+1);
						}
						sb.Append(WsdlParser.IsValidCS(printName));
						sb.Append('(');
						invokeMethod.PrintSignature(sb, curNS);
						sb.Append(");");
						textWriter.WriteLine(sb);
						return;
					}
				}

				bool bURTType = IsURTType;


				sb.Length = 0;
				sb.Append("\n"); 
				sb.Append(indentation);
				sb.Append("[");
				if (_sudsType != SUDSType.ClientProxy)
					sb.Append("Serializable, ");
				sb.Append("SoapType(");

				if (_parser._xsdVersion == XsdVersion.V1999)
				{
					sb.Append("SoapOptions=SoapOption.Option1|SoapOption.AlwaysIncludeTypes|SoapOption.XsdString|SoapOption.EmbedAll,");
				}
				else if (_parser._xsdVersion == XsdVersion.V2000)
				{
					sb.Append("SoapOptions=SoapOption.Option2|SoapOption.AlwaysIncludeTypes|SoapOption.XsdString|SoapOption.EmbedAll,");
				}

				if (!bURTType)
				{
					sb.Append("XmlElementName=");
					sb.Append(WsdlParser.IsValidUrl(GetClassName()));
					sb.Append(", XmlNamespace=");
					sb.Append(WsdlParser.IsValidUrl(Namespace));
					sb.Append(", XmlTypeName=");
					if (WireType != null)
						sb.Append(WsdlParser.IsValidUrl(WireType));
					else
						sb.Append(WsdlParser.IsValidUrl(GetClassName()));
					sb.Append(", XmlTypeNamespace=");
					sb.Append(WsdlParser.IsValidUrl(Namespace));
				}
				else
				{
					// Need namespace for clr type because proxy dll might have a different name than server dll
					sb.Append("XmlNamespace=");
					sb.Append(WsdlParser.IsValidUrl(UrlNS));
					sb.Append(", XmlTypeNamespace=");
					sb.Append(WsdlParser.IsValidUrl(UrlNS)); 
					if (WireType != null)
					{
						sb.Append(", XmlTypeName=");
						sb.Append(WsdlParser.IsValidUrl(WireType));
					}
				}

				sb.Append(")]");
				textWriter.WriteLine(sb);

				sb.Length = 0;
				sb.Append(indentation);

				if (_sudsUse == SudsUse.Struct)
					sb.Append("public struct ");
				else
					sb.Append("public class ");
				if (_bNestedType)
					sb.Append(WsdlParser.IsValidCS(NestedTypeName));
				else
					sb.Append(WsdlParser.IsValidCS(GetClassName()));

				if (_baseTypeName != null || _sudsUse == SudsUse.ISerializable || _implIFaces.Count > 0)
					sb.Append(" : ");
				bool bBaseIsURTType = true;
				String baseString = null;

				bool binherit = false;

				bool fClientProxy;
				if (_baseTypeName == "RemotingClientProxy")
					fClientProxy = true;
				else
					fClientProxy = false;

				if (fClientProxy)
				{
					sb.Append("System.Runtime.Remoting.Services.RemotingClientProxy");
					binherit = true;
				}
				else if (_baseTypeName != null)
				{
					bBaseIsURTType = _baseType.IsURTType;
					baseString = _baseType.GetName(curNS);
					if (baseString == "System.__ComObject")
					{
						/*textWriter.Write(indentation);
						textWriter.WriteLine("[guid(\"cc3bf020-1881-4e44-88d8-39b1052b1b11\")]");
						textWriter.Write(indentation);
						textWriter.WriteLine("[comimport]"); */
						sb.Append("System.MarshalByRefObject");
						binherit = true;
					}
					else
					{
						sb.Append(WsdlParser.IsValidCSAttr(baseString));
						binherit = true;
					}
				}
				else
				{
					// no base name
					if (_sudsUse == SudsUse.ISerializable)
					{
						sb.Append("System.Runtime.Serialization.ISerializable");
						binherit = true;
					}
				}

				if (_implIFaces.Count > 0)
				{
					for (int i=0;i<_implIFaces.Count;i++)
					{
						if (binherit)
							sb.Append(", ");
						sb.Append(WsdlParser.IsValidCS(((BaseInterface) _implIFaces[i]).GetName(curNS)));
						binherit = true;
					}
				}


				textWriter.WriteLine(sb);

				textWriter.Write(indentation);
				textWriter.WriteLine('{');

				String newIndentation = indentation + "    ";
				int newIndentationLength = newIndentation.Length;
				//bool fClientProxy = _connectURL != null;

				Util.Log("URTComplexType.PrintCSC _sudsType "+((Enum)_sudsType).ToString());

				if (fClientProxy)
				{
					PrintClientProxy(textWriter, indentation, curNS, sb);
				}

				if (_methods.Count > 0)
				{
					//textWriter.Write(newIndentation);
					//textWriter.WriteLine("// Class Methods");
					String bodyPrefix = null;

					if (_parser._bWrappedProxy)
					{
						sb.Length = 0;
						sb.Append("((");
						sb.Append(WsdlParser.IsValidCS(GetClassName()));
						sb.Append(") _tp).");
						bodyPrefix = sb.ToString();
					}

					for (int i=0;i<_methods.Count;i++)
					{
						Util.Log("URTComplexType.PrintCSC Invoke methods class methods PrintCSC class "+Name+" methodName "+((URTMethod) _methods[i]).Name);
						((URTMethod) _methods[i]).PrintCSC(textWriter, newIndentation,
														   " ", curNS, MethodPrintEnum.PrintBody, bURTType,
														   bodyPrefix, sb); 
					}
					textWriter.WriteLine();
				}


				/*
				if (_implIFaces.Count > 0)
				{
					ArrayList printedIFaces = new ArrayList(_implIFaces.Count);
					for (int i=0;i<_implIFaces.Count;i++)
						((BaseInterface) _implIFaces[i]).PrintClassMethods(textWriter, newIndentation, curNS, printedIFaces, fClientProxy, sb);
					textWriter.WriteLine();
				}
				*/

				// Standard class
				if (_fields.Count > 0)
				{
					textWriter.Write(newIndentation);
					textWriter.WriteLine("// Class Fields");
					for (int i=0;i<_fields.Count;i++)
					{
						Util.Log("URTComplexType.PrintCS Invoke _fields PrintCSC");                                                                                                         
						((URTField) _fields[i]).PrintCSC(textWriter, newIndentation, curNS, sb);
					}
				}

				// print nested types
				if (_nestedTypes != null && _nestedTypes.Count > 0)
				{
					foreach (BaseType ctype in _nestedTypes)
					{
						ctype.bNestedTypePrint = true;
						if (ctype is URTSimpleType)
							((URTSimpleType)ctype).PrintCSC(textWriter, newIndentation, curNS, sb);
						else
							((URTComplexType)ctype).PrintCSC(textWriter, newIndentation, curNS, sb);

						ctype.bNestedTypePrint = false;
					}
				}

				if (_sudsUse == SudsUse.ISerializable)
					PrintISerializable(textWriter, indentation, curNS, sb, baseString);

				// Close class
				sb.Length = 0;
				sb.Append(indentation);
				sb.Append("}");
				textWriter.WriteLine(sb);
				Util.Log("URTComplexType.PrintCSC Exit name "+Name+" curNS "+curNS);
				return;
			}

			private void PrintClientProxy(TextWriter textWriter, String indentation, String curNS, StringBuilder sb)
			{
				Util.Log("URTComplexType.PrintCSC PrintClientProxy ");
				String indent1 = indentation + "    ";
				String indent2 = indent1 + "    ";
				sb.Length = 0;
				sb.Append(indent1);
				sb.Append("// Constructor");
				textWriter.WriteLine(sb);

				sb.Length = 0;
				sb.Append(indent1);
				sb.Append("public ");
				sb.Append(WsdlParser.IsValidCS(GetClassName()));
				sb.Append("()");
				textWriter.WriteLine(sb);

				sb.Length = 0;
				sb.Append(indent1);
				sb.Append('{');
				textWriter.WriteLine(sb);

				if (_connectURLs != null)
				{
					for (int i=0; i<_connectURLs.Count; i++)
					{
						sb.Length = 0;
						sb.Append(indent2);
						if (i == 0)
						{
							sb.Append("base.ConfigureProxy(this.GetType(), ");
							sb.Append(WsdlParser.IsValidUrl((string)_connectURLs[i]));
							sb.Append(");");
						}
						else
						{
							// Only the first location is used, the rest are commented out in the proxy
							sb.Append("//base.ConfigureProxy(this.GetType(), ");
							sb.Append(WsdlParser.IsValidUrl((string)_connectURLs[i]));
							sb.Append(");");
						}
						textWriter.WriteLine(sb);
					}
				}



				//Preload classes
				foreach (URTNamespace ns in _parser._URTNamespaces)
				{
					foreach (URTComplexType cs in ns._URTComplexTypes)
					{
						if ((cs._sudsType != SUDSType.ClientProxy) && !cs.IsArray())
						{
							sb.Length = 0;
							sb.Append(indent2);
							sb.Append("System.Runtime.Remoting.SoapServices.PreLoad(typeof(");
							sb.Append(WsdlParser.IsValidCS(ns.EncodedNS));
							if (ns.EncodedNS != null && ns.EncodedNS.Length > 0)
								sb.Append(".");
							sb.Append(WsdlParser.IsValidCS(cs.Name));
							sb.Append("));");
							textWriter.WriteLine(sb);
						}
					}
				}

				foreach (URTNamespace ns in _parser._URTNamespaces)
				{
					foreach (URTSimpleType ss in ns._URTSimpleTypes)
					{
						if (ss.IsEnum)
						{
							sb.Length = 0;
							sb.Append(indent2);
							sb.Append("System.Runtime.Remoting.SoapServices.PreLoad(typeof(");
							sb.Append(WsdlParser.IsValidCS(ns.EncodedNS));
							if (ns.EncodedNS != null && ns.EncodedNS.Length > 0)
								sb.Append(".");
							sb.Append(WsdlParser.IsValidCS(ss.Name));
							sb.Append("));");
							textWriter.WriteLine(sb);
						}
					}
				}

				sb.Length = 0;
				sb.Append(indent1);
				sb.Append('}');
				textWriter.WriteLine(sb);

				// Base class for Client Proxy
				// Write Property to retrieve Transparent Proxy
				textWriter.WriteLine();

				sb.Length = 0;
				sb.Append(indent1);
				sb.Append("public Object RemotingReference");
				textWriter.WriteLine(sb);
				
				sb.Length = 0;
				sb.Append(indent1);
				sb.Append("{");
				textWriter.WriteLine(sb);

				sb.Length = 0;
				sb.Append(indent2);
				sb.Append("get{return(_tp);}");
				textWriter.WriteLine(sb);

				sb.Length = 0;
				sb.Append(indent1);
				sb.Append("}");
				textWriter.WriteLine(sb);

				textWriter.WriteLine();
			}

			private void PrintISerializable(TextWriter textWriter, String indentation, String curNS, StringBuilder sb, String baseString)
			{
				Util.Log("URTComplexType.PrintCSC PrintISerializable ");
				String indent1 = indentation + "    ";
				String indent2 = indent1 + "    ";

				if (baseString == null || baseString.StartsWith("System."))
				{
					// Don't generate if base class already contains field
					sb.Length = 0;
					sb.Append(indent1);
					sb.Append("public System.Runtime.Serialization.SerializationInfo info;");
					textWriter.WriteLine(sb);

					sb.Length = 0;
					sb.Append(indent1);
					sb.Append("public System.Runtime.Serialization.StreamingContext context; \n");
					textWriter.WriteLine(sb);
				}

				sb.Length = 0;
				sb.Append(indent1);

				if (_baseTypeName == null)
					sb.Append("public ");
				else
					sb.Append("protected ");

				if (_bNestedType)
					sb.Append(WsdlParser.IsValidCS(NestedTypeName));
				else
					sb.Append(WsdlParser.IsValidCS(GetClassName()));

				sb.Append("(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)");

				if (_baseTypeName != null)
					sb.Append(" : base(info, context)");
				textWriter.WriteLine(sb);

				sb.Length = 0;
				sb.Append(indent1);
				sb.Append("{");
				textWriter.WriteLine(sb);

				if (baseString == null || baseString.StartsWith("System."))
				{
					// Don't generate if base class already contains field
					sb.Length = 0;
					sb.Append(indent2);
					sb.Append("this.info = info;");
					textWriter.WriteLine(sb);

					sb.Length = 0;
					sb.Append(indent2);
					sb.Append("this.context = context;");
					textWriter.WriteLine(sb);
				}


				sb.Length = 0;
				sb.Append(indent1);
				sb.Append("}");
				textWriter.WriteLine(sb);

				if (_baseTypeName == null)
				{
					sb.Length = 0;
					sb.Append(indent1);
					sb.Append("public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)");
					textWriter.WriteLine(sb);

					sb.Length = 0;
					sb.Append(indent1);
					sb.Append("{");
					textWriter.WriteLine(sb);

					sb.Length = 0;
					sb.Append(indent1);
					sb.Append("}");
					textWriter.WriteLine(sb);
				}


			}

			internal void AddArray(String arrayType, URTNamespace arrayNS)
			{
				Util.Log("URTComplexType.ResolveArray Entry "+this.GetHashCode()+" "+_arrayType+" ns "+_arrayNS);
				_arrayType = arrayType;

				/*
				int index = arrayType.IndexOf('+');
				if (index > 0)
				{
					// Nested Type
					String outerTypeName = arrayType.Substring(0, index);
					String nestedTypeName = arrayType.Substring(index+1);
					_arrayType = outerTypeName+"."+nestedTypeName;
				}
				*/
				_arrayNS = arrayNS;
				Util.Log("URTComplexType.AddArray "+arrayType+" ns "+(arrayNS == null?"null":arrayNS.Namespace)+" finalName "+_arrayType);
			}

			internal void ResolveArray()
			{
				Util.Log("URTComplexType.ResolveArray Entry "+this.GetHashCode()+" "+_arrayType+" ns "+_arrayNS);

				if (_clrarray != null)
					return;

				String actualElementType = null;
				String wireElementType = _arrayType;
				int index = _arrayType.IndexOf("[");
				if (index < 0)
				{
					throw new SUDSParserException(
												 String.Format(CoreChannel.GetResourceString("Remoting_Suds_WsdlInvalidArraySyntax"),
															   _arrayType));
				}

				wireElementType = _arrayType.Substring(0, index);

				switch (_arrayNS.UrtType)
				{
				case UrtType.Xsd:
					actualElementType = _parser.MapSchemaTypesToCSharpTypes(wireElementType);
					break;
				case UrtType.UrtSystem:
				case UrtType.UrtUser:
					actualElementType = wireElementType;
					break;
				case UrtType.Interop:
					actualElementType = wireElementType;
					break;
				default:
					Debug.Assert(false, "!UrtType.None");
					break;
				}

				_clrarray = actualElementType+FilterDimensions(_arrayType.Substring(index));
				Util.Log("URTComplexType.ResolveArray Exit "+_clrarray+" "+_arrayNS+" elementname "+actualElementType);
			}

			// Need to remove dimensions in an array (some wsdl's generate fixed arrays with dimensions)
			private String FilterDimensions(String value)
			{
				Char[] outChar = new Char[value.Length];
				for (int i=0; i<value.Length; i++)
				{
					if (Char.IsDigit(value[i]))
						outChar[i] = ' ';
					else
						outChar[i] = value[i];
				}
				return new String(outChar);
			}


			private String _baseTypeName;
			private String _baseTypeXmlNS;
			private BaseType _baseType;
			private ArrayList _connectURLs;
			private bool _bStruct;
			private SchemaBlockType _blockType;
			private bool _bSUDSType;
			private bool _bAnonymous;
			private String _wireType;
			private ArrayList _inherit;	// proxy hierarchy 
			private String _fieldString;
			private ArrayList _implIFaceNames;
			private ArrayList _implIFaces;
			private ArrayList _fields;
			private ArrayList _methods;
			private SUDSType _sudsType;
			private SudsUse _sudsUse;
			private bool _bValueType;
			private WsdlParser _parser;
			private String _arrayType;
			private URTNamespace _arrayNS;
			private String _clrarray;
			private bool _bprint = true;
			private bool _bNameMethodConflict = false;

		}

		// Represents an XML element declaration
		internal class ElementDecl
		{
			// Constructor
			internal ElementDecl(String elmName, String elmNS, String typeName, String typeNS,
								 bool bPrimitive){
				Util.Log("ElementDecl.ElementDecl elmName "+elmName+" elmNS "+elmNS+" typeName "+typeName+" typeNS "+typeNS+" bPrimitive "+bPrimitive);
				_elmName = elmName;
				_elmNS = elmNS;
				_typeName = typeName;
				_typeNS = typeNS;
				_bPrimitive = bPrimitive;
			}

			// Field accessors
			internal String Name{
				get{ return(_elmName);}
			}
			internal String Namespace{
				get{ return(_elmNS);}
			}
			internal String TypeName{
				get{ return(_typeName);}
			}
			internal String TypeNS{
				get{ return(_typeNS);}
			}

			internal bool Resolve(WsdlParser parser){
				Util.Log("ElementDecl.Resolve "+TypeName+" "+TypeNS);
				// Return immediatly for element declaration of primitive types
				if (_bPrimitive)
					return true;

				// Lookup the type from the element declaration
				URTNamespace typeNS = parser.LookupNamespace(TypeNS);
				if (typeNS == null)
				{
					throw new SUDSParserException(
												 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveSchemaNS"),
															   TypeNS, TypeName));
				}
				BaseType type = typeNS.LookupType(TypeName);
				if (type == null)
				{
					// Because there might be multiple bindings and some not soap, there can be failures in the non soap bindings.
					return false; 
					/*
					throw new SUDSParserException(
												 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveTypeInNS"),
															   TypeName, TypeNS));
															   */
				}

				type.ElementName = Name;
				type.ElementNS = Namespace;

				return true;
			}

			// Fields
			private String _elmName;
			private String _elmNS;
			private String _typeName;
			private String _typeNS;
			private bool _bPrimitive;
		}

		// Represents a namespace
		internal class URTNamespace
		{
			// Constructor
			internal URTNamespace(String name, WsdlParser parser)
			{
				Util.Log("URTNamespace.URTNamespace Enter name "+name);
				_name = name;
				_parser = parser;
				_nsType = parser.IsURTExportedType(name, out _namespace, out _assemName);
				if (_nsType == UrtType.Interop)
				{
					_encodedNS = EncodeInterop(_namespace, parser);
				}
				else
					_encodedNS = _namespace;
				_elmDecls = new ArrayList();
				_URTComplexTypes = new ArrayList();
				_numURTComplexTypes = 0;
				_URTSimpleTypes = new ArrayList();
				_numURTSimpleTypes = 0;
				_URTInterfaces = new ArrayList();
				_anonymousSeqNum = 0;
				parser.AddNamespace(this);
				Util.Log("URTNamespace.URTNamespace Exit name "+this.GetHashCode()+" "+name+" _namespace "+_namespace+" _assemName "+_assemName+" _encodedNS "+_encodedNS);
			}

			internal static String EncodeInterop(String name, WsdlParser parser)
			{
				String _encodedNS = name;
				if ((parser.ProxyNamespace != null) && parser.ProxyNamespace.Length > 0)
				{
					String countStr = "";
					if (parser.ProxyNamespaceCount > 0)
						countStr = (parser.ProxyNamespaceCount).ToString();
					parser.ProxyNamespaceCount++;
					_encodedNS = parser.ProxyNamespace+countStr;
				}
				else
				{
					int index = name.IndexOf(":");
					if (index > 0)
						_encodedNS = _encodedNS.Substring(index+1);
					if (_encodedNS.StartsWith("//"))
						_encodedNS = _encodedNS.Substring(2);
					_encodedNS = _encodedNS.Replace('/', '_');
				}
				Util.Log("URTNamespace.EncodeInterop  encoded "+_encodedNS);
				return _encodedNS;
			}


			// Get the next anonymous type name
			internal String GetNextAnonymousName(){
				++_anonymousSeqNum;
				Util.Log("URTNamespace.GetNextAnonymousName AnonymousType"+_anonymousSeqNum+" ComplexType "+_name);
				return("AnonymousType" + _anonymousSeqNum);
			}

			// Add a new element declaration to the namespace
			internal void AddElementDecl(ElementDecl elmDecl){
				Util.Log("URTNamespace.AddElementDecl ");
				_elmDecls.Add(elmDecl);
			}

			// Add a new type into the namespace
			internal void AddComplexType(URTComplexType type){
				Util.Log("URTNamespace.AddComplexType "+this.GetHashCode()+" "+type.Name+" "+type.GetHashCode()+" ns "+_name);
				// Assert that simple and complex types share the same namespace
				Debug.Assert(LookupSimpleType(type.Name) == null,
							 "Complex type has the same name as a simple type");
				_URTComplexTypes.Add(type);
				++_numURTComplexTypes;
			}

			// Add a new type into the namespace
			internal void AddSimpleType(URTSimpleType type){
				Util.Log("URTNamespace.AddSimpleType "+type.Name);              
				// Assert that simple and complex types share the same namespace
				Debug.Assert(LookupComplexType(type.Name) == null,
							 "Simple type has the same name as a complex type");
				_URTSimpleTypes.Add(type);
				++_numURTSimpleTypes;
			}

			// Adds a new interface into the namespace
			internal void AddInterface(URTInterface iface){
				Util.Log("URTNamespace.AddInterface "+iface.Name);              
				_URTInterfaces.Add(iface);
			}

			// Returns the namespace
			internal String Namespace{
				get{ return(_namespace);}
			}

			internal bool IsSystem
			{
				get
				{ 
					if (_namespace != null && _namespace.StartsWith("System"))
						return true;
					else
						return false;
				}
			}

			// Returns Encoded namespace
			internal String EncodedNS{
				get{ return(_encodedNS);}
				set{ _encodedNS = value;}
			}

			internal bool bReferenced{
				get{ return(_bReferenced);}
				set{ _bReferenced = value;}
			}

			// Returns the full name
			internal String Name{
				get{ return(_name);}
			}

			// Returns Assembly name
			internal String AssemName{
				get{ return(_assemName);}
			}

			internal UrtType UrtType{
				get{ return _nsType;}
			}

			// Returns true if this represents a URTNamespace
			internal bool IsURTNamespace{
				get{ return((Object) _namespace == (Object) _encodedNS);}
			}

			// Returns true if the namespace has no types defined
			internal bool IsEmpty{
				get{
					bool isEmpty = true;
					if (ComplexTypeOnlyArrayorEmpty() &&
						(_URTInterfaces.Count == 0) &&
						(_numURTSimpleTypes == 0))
						isEmpty = true;
					else
						isEmpty	= false;
					return isEmpty;
				}
			}

			// Looks up a element declaration
			internal ElementDecl LookupElementDecl(String name){
				Util.Log("URTNamespace.LookupElementDecl "+name);               
				for (int i=0;i<_elmDecls.Count;i++)
				{
					ElementDecl elm = (ElementDecl) _elmDecls[i];
					if (elm.Name == name)
						return(elm);
				}

				return(null);
			}

			internal bool ComplexTypeOnlyArrayorEmpty()
			{
				bool bempty = true;
				for (int i=0;i<_URTComplexTypes.Count;i++)
				{
					URTComplexType type = (URTComplexType) _URTComplexTypes[i];
					if (type != null && !type.IsArray())
					{
						bempty = false;
						break;
					}
				}
				return bempty;
			}

			// Looks up a complex type
			internal URTComplexType LookupComplexType(String typeName){
				URTComplexType ctype = null;
				for (int i=0;i<_URTComplexTypes.Count;i++)
				{
					URTComplexType type = (URTComplexType) _URTComplexTypes[i];
					//if (type != null && type.SearchName == typeName)
					//Util.Log("URTNamespace.LookupComplexType "+this.GetHashCode()+" "+typeName+" "+type.SearchName);
					if ((type != null) && WsdlParser.MatchingStrings(type.SearchName, typeName))
					{
						//Util.Log("URTNamespace.LookupComplexType found");
						ctype = type;
						break;
					}
				}

				Util.Log("URTNamespace.LookupComplexType "+typeName+" ns "+this.GetHashCode()+" "+_name+" return "+((ctype != null) ? ctype.Name:"null"));               
				return(ctype);
			}

			// Looks up a complex type
			internal URTComplexType LookupComplexTypeEqual(String typeName){
				URTComplexType ctype = null;
				for (int i=0;i<_URTComplexTypes.Count;i++)
				{
					URTComplexType type = (URTComplexType) _URTComplexTypes[i];
					if (type != null && type.SearchName == typeName)
					{
						ctype = type;
						break;
					}
				}

				Util.Log("URTNamespace.LookupComplexTypeEqual "+typeName+" ns "+this.GetHashCode()+" "+_name+" return "+((ctype != null) ? ctype.Name:"null"));               
				return(ctype);
			}


			// Looks up a simple type
			internal URTSimpleType LookupSimpleType(String typeName){
				Util.Log("URTNamespace.LookupSimpleType "+typeName+" ns "+_name);                                
				for (int i=0;i<_URTSimpleTypes.Count;i++)
				{
					URTSimpleType type = (URTSimpleType) _URTSimpleTypes[i];
					if ((type != null) && WsdlParser.MatchingStrings(type.Name, typeName))
						return(type);
				}

				return(null);
			}

			// Looks up a complex or simple type
			internal BaseType LookupType(String typeName){
				BaseType type = LookupComplexType(typeName);
				if (type == null)
					type = LookupSimpleType(typeName);

				return(type);
			}

			// Removes the given type from the namespace
			internal void RemoveComplexType(URTComplexType type){
				Util.Log("URTNamespace.RemoveComplexType "+type.Name+" complex Type "+_name);
				for (int i=0;i<_URTComplexTypes.Count;i++)
				{
					Util.Log("URTNamespace.RemoveComplexType 1 "+type.Name+" complexTypes "+((_URTComplexTypes[i] != null) ? ((URTComplexType)_URTComplexTypes[i]).Name : "Null"));                 
					if (_URTComplexTypes[i] == type)
					{
						Util.Log("URTNamespace.RemoveComplexType 2 match "+type.Name+" complexTypes "+((_URTComplexTypes[i] != null) ? ((URTComplexType)_URTComplexTypes[i]).Name : "Null"));                                       
						_URTComplexTypes[i] = null;
						--_numURTComplexTypes;
						return;
					}
				}

				throw new SUDSParserException(
											 CoreChannel.GetResourceString("Remoting_Suds_TriedToRemoveNonexistentType"));
			}

			// Removes the given type from the namespace
			internal void RemoveSimpleType(URTSimpleType type){
				Util.Log("URTNamespace.RemoveSimpleType "+type.Name+" SimpleType "+_name);              
				for (int i=0;i<_URTSimpleTypes.Count;i++)
				{
					if (_URTSimpleTypes[i] == type)
					{
						_URTSimpleTypes[i] = null;
						--_numURTSimpleTypes;
						return;
					}
				}

				throw new SUDSParserException(
											 CoreChannel.GetResourceString("Remoting_Suds_TriedToRemoveNonexistentType"));
			}

			// Looks up an interface
			internal URTInterface LookupInterface(String iFaceName){
				Util.Log("URTNamespace.LookupInterface "+iFaceName);
				for (int i=0;i<_URTInterfaces.Count;i++)
				{
					URTInterface iFace = (URTInterface) _URTInterfaces[i];
					if (WsdlParser.MatchingStrings(iFace.Name, iFaceName))
						return(iFace);
				}

				return(null);
			}

			// Resolve element references
			internal void ResolveElements(WsdlParser parser){
				Util.Log("URTNamespace.ResolveElements "+Name);

				for (int i=0;i<_elmDecls.Count;i++)
				{
					((ElementDecl) _elmDecls[i]).Resolve(parser);
				}
			}

			// Resolves internal references
			internal void ResolveTypes(WsdlParser parser){
				Util.Log("URTNamespace.ResolveTypes "+Name); 

				/*
				// Process nested types 
				Hashtable typeTable = new Hashtable(10);
				for (int i=0;i<_URTComplexTypes.Count;i++)
				{
					// fill up hashtable with types
					URTComplexType ctype = (URTComplexType)_URTComplexTypes[i];

					if (ctype.bNestedType)
					{
						Util.Log("URTNamespace.ResolveTypes nested type outer type "+ctype.OuterTypeName+" nested type "+ctype.NestedTypeName+" fullNestedTypeName "+ctype.Name);
						// type is a nested class 
						URTComplexType outerType = (URTComplexType)typeTable[ctype.OuterTypeName];
						if (outerType == null)
						{
							// place all the URTComplex types in the table, the nested type appears before the outer type in Wsdl
							for (int j=0;j<_URTComplexTypes.Count;j++)
							{
								URTComplexType ctype2 = (URTComplexType)_URTComplexTypes[j];
								Util.Log("URTNamespace.ResolveTypes miss find all types "+ctype2.Name);
								typeTable[ctype2.Name] = ctype2;
							}
						}
						outerType = (URTComplexType)typeTable[ctype.OuterTypeName];
						if (outerType == null)
						{
							throw new SUDSParserException(
												 String.Format(CoreChannel.GetResourceString("Remoting_Suds_CantResolveNestedType"),
															   ctype.Name, ctype.UrlNS));
						}
						outerType._nestedTypes.Add(ctype);

					}
					else
					{

						Util.Log("URTNamespace.ResolveTypes nested place in table "+ctype.Name);
						typeTable[ctype.Name] = ctype;
					}
				}
				*/


				for (int i=0;i<_URTComplexTypes.Count;i++)
				{
					if (_URTComplexTypes[i] != null)
						((URTComplexType)_URTComplexTypes[i]).ResolveTypes(parser);
				}

				for (int i=0;i<_URTInterfaces.Count;i++)
					((URTInterface)_URTInterfaces[i]).ResolveTypes(parser);
			}

			// Resolves method types
			internal void ResolveMethods(){
				Util.Log("URTNamespace.ResolveMethods "+Name);              
				for (int i=0;i<_URTComplexTypes.Count;i++)
				{
					if (_URTComplexTypes[i] != null)
						((URTComplexType)_URTComplexTypes[i]).ResolveMethods();
				}
			}

			// Prints all the types in the namespace
			internal void PrintCSC(WriterStream writerStream)
			{
				Util.Log("URTNamespace.PrintCSC Entry "+Name);               
				Debug.Assert(!IsEmpty, "Empty namespace " + Name + " being printed");
				TextWriter textWriter = writerStream.OutputStream;
				// Check to see if there is anything to print for this namespace
				bool bprint = false;
				if (_numURTComplexTypes > 0)
				{
					for (int i=0;i<_URTComplexTypes.Count;i++)
					{
						URTComplexType type = (URTComplexType) _URTComplexTypes[i];
						if (type != null && type.IsPrint)
							bprint = true;
					}
				}

				if (_numURTSimpleTypes > 0)
				{
					for (int i=0;i<_URTSimpleTypes.Count;i++)
					{
						URTSimpleType type = (URTSimpleType) _URTSimpleTypes[i];
						if (type != null)
							bprint = true;
					}
				}

				if (_URTInterfaces.Count > 0)
					bprint = true;


				if (!bprint)
					return;
				// End of check to see if there is anything to print


				String indentation = String.Empty;

				Stream stream = ((StreamWriter)textWriter).BaseStream;

				if (!writerStream.GetWrittenTo())
				{
					// Only print when new output file is used
					textWriter.WriteLine("using System;");
					textWriter.WriteLine("using System.Runtime.Remoting.Messaging;");
					textWriter.WriteLine("using System.Runtime.Remoting.Metadata;");
					textWriter.WriteLine("using System.Runtime.Remoting.Metadata.W3cXsd2001;");
					writerStream.SetWrittenTo();
				}

				if ((Namespace != null) &&
					(Namespace.Length != 0))
				{
					textWriter.Write("namespace ");
					textWriter.Write(WsdlParser.IsValidCS(EncodedNS));
					textWriter.WriteLine(" {");
					indentation = "    ";
				}


				StringBuilder sb = new StringBuilder(256);
				if (_numURTComplexTypes > 0)
				{
					for (int i=0;i<_URTComplexTypes.Count;i++)
					{
						URTComplexType type = (URTComplexType) _URTComplexTypes[i];
						if (type != null && type.IsPrint)
						{
							Util.Log("URTNamespace.PrintCSC Invoke Complex type PrintCSC");                                                                                                             
							type.PrintCSC(textWriter, indentation, _encodedNS, sb);
						}
					}
				}

				if (_numURTSimpleTypes > 0)
				{
					for (int i=0;i<_URTSimpleTypes.Count;i++)
					{
						URTSimpleType type = (URTSimpleType) _URTSimpleTypes[i];
						if (type != null)
						{
							Util.Log("URTNamespace.PrintCSC Invoke Simple type PrintCSC");                                                                                                                                          
							type.PrintCSC(textWriter, indentation, _encodedNS, sb);
						}
					}
				}

				for (int i=0;i<_URTInterfaces.Count;i++)
				{
					Util.Log("URTNamespace.PrintCSC Invoke Interfaces PrintCSC");                                                                                                                                   
					((URTInterface)_URTInterfaces[i]).PrintCSC(textWriter, indentation, _encodedNS, sb);
				}

				if ((Namespace != null) &&
					(Namespace.Length != 0))
					textWriter.WriteLine('}');

				return;
			}

			// Fields
			private String _name;
			private UrtType _nsType;
			private WsdlParser _parser;
			private String _namespace;
			private String _encodedNS;
			private String _assemName;
			private int _anonymousSeqNum;
			private ArrayList _elmDecls;
			internal ArrayList _URTComplexTypes;
			private int _numURTComplexTypes;
			internal ArrayList _URTSimpleTypes;
			private int _numURTSimpleTypes;
			private ArrayList _URTInterfaces;
			private bool _bReferenced = false;
		}

		internal interface IDump{
			void Dump();
		}

		internal interface INamespaces
		{
			void UsedNamespace(Hashtable namespaces);
		}

		internal class WsdlMessage : IDump, INamespaces
		{
			internal String name;
			internal String nameNs;
			internal ArrayList parts = new ArrayList(10);

			public void UsedNamespace(Hashtable namespaces)
			{
				Util.Log("WsdlMessage.UsedNamespace "+name+" "+nameNs);
				/*
				if (nameNs != null)
					namespaces[nameNs] = 1;
					*/
				for (int i=0; i<parts.Count; i++)
					((INamespaces)parts[i]).UsedNamespace(namespaces);
			}

			public void Dump(){
				Util.Log("WsdlMessage.Dump");
				Util.Log("   name "+name);
				Util.Log("   ns "+nameNs);
				for (int i=0; i<parts.Count; i++)
					((IDump)parts[i]).Dump();
			}


		}

		internal class WsdlMessagePart : IDump, INamespaces
		{
			internal String name;
			internal String nameNs;
			internal String element;
			internal String elementNs;
			internal String typeName;
			internal String typeNameNs;


			public void UsedNamespace(Hashtable namespaces)
			{
				Util.Log("WsdlMessagePart.UsedNamespace "+name+" "+nameNs);
				if (nameNs != null)
					namespaces[nameNs] = 1;
				if (elementNs != null)
					namespaces[elementNs] = 1;

			}

			public void Dump(){
				Util.Log("WsdlMessagePart.Dump");
				Util.Log("   name "+name);
				Util.Log("   element "+element);
				Util.Log("   elementNs "+elementNs);
				Util.Log("   typeName "+typeName);
				Util.Log("   typeNameNs "+typeNameNs);                              
			}
		}

		internal class WsdlPortType : IDump, INamespaces
		{
			internal String name;
			internal String nameNs;
			internal ArrayList operations = new ArrayList(10);
			internal Hashtable sections = new Hashtable(10);

			public void UsedNamespace(Hashtable namespaces)
			{
				Util.Log("WsdlPortType.UsedNamespace "+name+" "+nameNs);
				/*
				if (nameNs != null)
					namespaces[nameNs] = 1;
					*/
				foreach (INamespaces item in operations)
				item.UsedNamespace(namespaces);

			}
			public void Dump()          {
				Util.Log("WsdlPortType.Dump");
				Util.Log("   name "+name);
				foreach (DictionaryEntry d in sections)
				Util.Log("   sections key "+d.Key+" value "+((WsdlPortTypeOperation)d.Value).name);
				foreach (IDump item in operations)
				item.Dump();
			}
		}

		internal class WsdlPortTypeOperation : IDump, INamespaces
		{
			internal String name;
			internal String nameNs;
			internal String parameterOrder;
			internal ArrayList contents = new ArrayList(3);

			public void UsedNamespace(Hashtable namespaces) 
			{
				/*
				if (nameNs != null)
					namespaces[nameNs] = 1;
					*/

				foreach (INamespaces item in contents)
				item.UsedNamespace(namespaces);
			}

			public void Dump()          {
				Util.Log("WsdlPortTypeOperation.Dump");
				Util.Log("   name "+name+" parameterOrder "+parameterOrder);
				foreach (IDump item in contents)
				item.Dump();
			}
		}


		internal class WsdlPortTypeOperationContent : IDump, INamespaces
		{
			internal String element;
			internal String name;
			internal String nameNs;
			internal String message;
			internal String messageNs;
			public void UsedNamespace(Hashtable namespaces)
			{
				Util.Log("WsdlPortTypeOperationContent.UsedNamespace "+name+" "+nameNs);
				/*
				if (nameNs != null)
					namespaces[nameNs] = 1;
				if (messageNs != null)
					namespaces[messageNs] = 1;
					*/
			}

			public void Dump()          {
				Util.Log("WsdlPortTypeOperationContent.Dump");
				Util.Log("   element "+element);                
				Util.Log("   name "+name);
				Util.Log("   message "+message);                
				Util.Log("   messageNs "+messageNs);                
			}
		}

		internal class WsdlBinding : IDump, INamespaces
		{
			internal URTNamespace parsingNamespace;
			internal String name;
			internal String nameNs;
			internal String type;
			internal String typeNs;
			internal ArrayList suds = new ArrayList(10);
			internal WsdlBindingSoapBinding soapBinding;
			internal ArrayList operations = new ArrayList(10);

			public void UsedNamespace(Hashtable namespaces)
			{
				Util.Log("WsdlBinding.UsedNamespace "+name+" "+nameNs);
				/*
				if (nameNs != null)
					namespaces[nameNs] = 1;
				if (typeNs != null)
					namespaces[typeNs] = 1;
					*/

				if (soapBinding != null)
					soapBinding.UsedNamespace(namespaces);

				foreach (INamespaces item in suds)
				item.UsedNamespace(namespaces);

				foreach (INamespaces item in operations)
				item.UsedNamespace(namespaces);
			}

			public void Dump(){
				Util.Log("WsdlBinding.Dump");
				Util.Log("   name "+name);
				Util.Log("   type "+type);
				Util.Log("   typeNs "+typeNs);
				Util.Log("   parsingNamespace.ns "+parsingNamespace.Namespace);
				Util.Log("   parsingNamespace.EncodedNS "+parsingNamespace.EncodedNS);              

				if (soapBinding != null)
					soapBinding.Dump();

				foreach(IDump item in suds)
				item.Dump();

				foreach (IDump item in operations)
				item.Dump();
			}
		}

		internal class WsdlBindingOperation : IDump, INamespaces
		{
			internal String name;
			internal String nameNs;
			internal String methodAttributes;
			internal WsdlBindingSoapOperation soapOperation;
			internal ArrayList sections = new ArrayList(10);

			public void UsedNamespace(Hashtable namespaces)          
			{
				Util.Log("WsdlBIndingOperation.UsedNamespace "+name+" "+nameNs);

				/*
				if (nameNs != null)
					namespaces[nameNs] = 1;
					*/

				soapOperation.UsedNamespace(namespaces);
				foreach (INamespaces item in sections)
				item.UsedNamespace(namespaces);
			}

			public void Dump()          {
				Util.Log("WsdlBindingOperation.Dump");
				Util.Log("   name "+name);
				Util.Log("   methodAttributes "+methodAttributes);
				soapOperation.Dump();
				foreach (IDump item in sections)
				item.Dump();
			}
		}

		internal class WsdlBindingOperationSection : IDump, INamespaces
		{
			internal String name;
			internal String elementName;
			internal ArrayList extensions = new ArrayList(10);

			public void UsedNamespace(Hashtable namespaces)          
			{
				Util.Log("WsdlBIndingOperationSection.UsedNamespace "+name);
				foreach (INamespaces item in extensions)
				item.UsedNamespace(namespaces);
			}

			public void Dump()          {
				Util.Log("WsdlBindingOperationSection.Dump");
				Util.Log("   name "+name);
				Util.Log("   elementName "+elementName);                
				foreach (IDump item in extensions)
				item.Dump();
			}
		}


		internal class WsdlBindingSoapBinding : IDump, INamespaces
		{
			internal String style;
			internal String transport;

			public void UsedNamespace(Hashtable namespaces)          
			{
				Util.Log("WsdlBindingSoapBinding.UsedNamespace ");
			}

			public void Dump()          {
				Util.Log("WsdlBindingSoapBinding.Dump");
				Util.Log("   style "+style);
				Util.Log("   transport "+transport);
			}


		}

		internal class WsdlBindingSoapBody : IDump, INamespaces
		{
			internal String parts;
			internal String use;
			internal String encodingStyle;
			internal String namespaceUri;

			public void UsedNamespace(Hashtable namespaces)          
			{
				Util.Log("WsdlBIndingSoapBody.UsedNamespace "+parts);
			}

			public void Dump()          {
				Util.Log("WsdlBindingSoapBody.Dump");
				Util.Log("   parts "+parts);
				Util.Log("   use "+use);
				Util.Log("   encodingStyle "+encodingStyle);
				Util.Log("   namespaceUri "+namespaceUri);              
			}
		}

		internal class WsdlBindingSoapHeader : IDump, INamespaces
		{
			internal String message;
			internal String messageNs;
			internal String part;
			internal String use;
			internal String encodingStyle;
			internal String namespaceUri;

			public void UsedNamespace(Hashtable namespaces)          
			{
				Util.Log("WsdlBindingSoapHeader.UsedNamespace "+message+" "+messageNs);
				/*
				if (nameNs != null)
					namespaces[nameNs] = 1; 
					*/
			}

			public void Dump()          {
				Util.Log("WsdlBindingSoapHeader.Dump");
				Util.Log("   message "+message);
				Util.Log("   part "+part);
				Util.Log("   use "+use);
				Util.Log("   encodingStyle "+encodingStyle);
				Util.Log("   namespaceUri "+namespaceUri);              
			}
		}

		internal class WsdlBindingSoapOperation : IDump, INamespaces
		{
			internal String soapAction;
			internal String style;

			public void UsedNamespace(Hashtable namespaces)          
			{
				Util.Log("WsdlBindingSoapOperation.UsedNamespace ");
			}

			public void Dump(){
				Util.Log("WsdlBindingSoapOperation.Dump");
				Util.Log("   soapAction "+soapAction);
				Util.Log("   style "+style);
			}
		}

		internal class WsdlBindingSoapFault : IDump, INamespaces
		{
			internal String name;
			internal String use;
			internal String encodingStyle;
			internal String namespaceUri;

			public void UsedNamespace(Hashtable namespaces)          
			{
				Util.Log("WsdlBindingSoapFault.UsedNamespace "+name+" "+namespaceUri);
				/*
				if (nameNs != null)
					namespaces[nameNs] = 1; 
					*/
			}

			public void Dump()          {
				Util.Log("WsdlBindingSoapFault.Dump");
				Util.Log("   name "+name);
				Util.Log("   use "+use);
				Util.Log("   encodingStyle "+encodingStyle);
				Util.Log("   namespaceUri "+namespaceUri);              
			}
		}

		internal enum SudsUse
		{
			Class = 0,
			ISerializable = 1,
			Struct = 2,
			Interface = 3,
			MarshalByRef = 4,
			Delegate = 5,
			ServicedComponent = 6,
		}

		internal class WsdlBindingSuds : IDump, INamespaces
		{
			internal String elementName;
			internal String typeName;
			internal String ns;
			internal String extendsTypeName;
			internal String extendsNs;          
			internal SudsUse sudsUse;
			internal ArrayList implements = new ArrayList(10);
			internal ArrayList nestedTypes = new ArrayList(10);

			public void UsedNamespace(Hashtable namespaces)          
			{
				Util.Log("WsdlBindingSuds.UsedNamespace elementName "+elementName+" typeName "+typeName+" ns "+ns+" extendsTypeName "+extendsTypeName+" extendsNs "+extendsNs+" sudsUse "+((Enum)sudsUse).ToString());
				if (ns != null)
					namespaces[ns] = 1;

				if (extendsNs != null)
					namespaces[extendsNs] = 1;

				foreach (INamespaces item in implements)
				item.UsedNamespace(namespaces);                    
			}


			public void Dump()          {
				Util.Log("WsdlBindingSuds.Dump");
				Util.Log("   elementName "+elementName);
				Util.Log("   typeName "+typeName);
				Util.Log("   ns "+ns);
				Util.Log("   extendsTypeName "+extendsTypeName);
				Util.Log("   extendsNs "+extendsNs);                
				Util.Log("   sudsUse "+((Enum)sudsUse).ToString());
				foreach (IDump item in implements)
				item.Dump();                    
				foreach (IDump item in nestedTypes)
				item.Dump();                    
			}
		}

		internal class WsdlBindingSudsImplements : IDump, INamespaces
		{
			internal String typeName;
			internal String ns;

			public void UsedNamespace(Hashtable namespaces)          
			{
				Util.Log("WsdlBindingSudsImplements.UsedNamespace typeName "+typeName+" ns "+ns);
				if (ns != null)
					namespaces[ns] = 1;
			}

			public void Dump()  
			{
				Util.Log("WsdlBindingSudsImplements.Dump");             
				Util.Log("   typeName "+typeName);
				Util.Log("   ns "+ns);
			}
		}

		internal class WsdlBindingSudsNestedType : IDump
		{
			internal String name;
			internal String typeName;
			internal String ns;

			public void Dump()   
			{
				Util.Log("WsdlBindingSudsNestedType.Dump");             
				Util.Log("   name "+name);
				Util.Log("   typeName "+typeName);
				Util.Log("   ns "+ns);
			}
		}

		internal class WsdlService : IDump, INamespaces
		{
			internal String name;
			internal String nameNs;
			internal Hashtable ports = new Hashtable(10);

			public void UsedNamespace(Hashtable namespaces)          
			{
				Util.Log("WsdlService.UsedNamespace "+name+" "+nameNs);
				/*
				if (nameNs != null)
					namespaces[nameNs] = 1; 
					*/
				foreach (DictionaryEntry  d in ports)
				((INamespaces)d.Value).UsedNamespace(namespaces);
			}

			public void Dump()          {
				Util.Log("WsdlService.Dump");
				Util.Log("   name "+name);
				foreach (DictionaryEntry  d in ports)
				((IDump)d.Value).Dump();
			}
		}

		internal class WsdlServicePort : IDump, INamespaces
		{
			internal String name;
			internal String nameNs;
			internal String binding;
			internal String bindingNs;
			internal ArrayList locations;

			public void UsedNamespace(Hashtable namespaces)          
			{
				/*
				if (nameNs != null)
					namespaces[nameNs] = 1; 

				if (bindingNs != null)
					namespaces[bindingNs] = 1; 
					*/
			}

			public void Dump()          {
				Util.Log("WsdlServicePort.Dump");
				Util.Log("   name "+name);
				Util.Log("   nameNs "+nameNs);
				Util.Log("   binding "+binding);
				Util.Log("   bindingNs"+bindingNs);
				if (locations != null)
				{
					foreach (String item in locations)
					Util.Log("   location "+item);
				}
			}
		}



		internal class WsdlMethodInfo : IDump
		{
			internal String soapAction;
			internal String methodName;
			internal String methodNameNs;
			internal String methodAttributes;
			internal String[] paramNamesOrder;
			internal String inputMethodName;
			internal String inputMethodNameNs;
			internal String outputMethodName;
			internal String outputMethodNameNs;
			internal String[] inputNames;
			internal String[] inputNamesNs;
			internal String[] inputElements;
			internal String[] inputElementsNs;
			internal String[] inputTypes;
			internal String[] inputTypesNs;
			internal String[] outputNames;
			internal String[] outputNamesNs;
			internal String[] outputElements;
			internal String[] outputElementsNs;
			internal String[] outputTypes;
			internal String[] outputTypesNs;
			internal String propertyName;
			internal bool bProperty = false;
			internal bool bGet = false;
			internal bool bSet = false;
			internal String propertyType;
			internal String propertyNs;
			internal String soapActionGet;
			internal String soapActionSet;

			public void Dump(){
				Util.Log("WsdlMethodInfo.Dump");
				Util.Log("   soapAction "+soapAction);
				Util.Log("   methodName "+methodName);
				Util.Log("   ns "+methodNameNs);

				if (paramNamesOrder != null)
				{
					foreach(String pname in paramNamesOrder)
					Util.Log("   paramNamesOrder   name "+pname);

				}
				if (inputNames != null)
				{
					for (int i=0; i<inputNames.Length; i++)
						Util.Log("   inputparams   name "+inputNames[i]+" element "+inputElements[i]+" elementNs "+inputElementsNs[i]+" type "+inputTypes[i]+" typeNs "+inputTypesNs[i]);
				}

				if (outputNames != null)
				{
					for (int i=0; i<outputNames.Length; i++)
						Util.Log("   outputparams   name "+outputNames[i]+" element "+outputElements[i]+" elementNs "+outputElementsNs[i]+" type "+outputTypes[i]+" typeNs "+outputTypesNs[i]);
				}

				if (bProperty)
				{
					Util.Log("   Property   name "+propertyName+" bGet "+bGet+" bSet "+bSet+" type "+propertyType+" ns "+propertyNs);
					Util.Log("   action get "+soapActionGet+" set "+soapActionSet);

				}
			}
		}
				}
				}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\ceefilegen\ceegentokenmapper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CeeGenTokenMapper.cpp
//
// This helper class tracks mapped tokens from their old value to the new value
// which can happen when the data is optimized on save.
//
//*****************************************************************************
#include "stdafx.h"
#include "CeeGenTokenMapper.h"


#define INDEX_FROM_TYPE(type) case INDEX_OF_TYPE(mdt ## type): return (tkix ## type)

//*****************************************************************************
// At this point, only a select set of token values are stored for remap.
// If others should become required, this needs to get updated.
//*****************************************************************************
int CeeGenTokenMapper::IndexForType(mdToken tk)
{
    int iType = INDEX_OF_TYPE(TypeFromToken(tk));
    // if (iType <= tkixMethodImpl)
    //    return (iType);
    // else
    {
        switch(iType)
        {
            INDEX_FROM_TYPE(TypeDef);
            INDEX_FROM_TYPE(InterfaceImpl);
            INDEX_FROM_TYPE(MethodDef);
            INDEX_FROM_TYPE(TypeRef);
            INDEX_FROM_TYPE(MemberRef);
            INDEX_FROM_TYPE(CustomAttribute);
            INDEX_FROM_TYPE(FieldDef);
            INDEX_FROM_TYPE(ParamDef);
            INDEX_FROM_TYPE(File);
        }
    }
    
    return (-1);
}


//*****************************************************************************
// Called by the meta data engine when a token is remapped to a new location.
// This value is recorded in the m_rgMap array based on type and rid of the
// from token value.
//*****************************************************************************
HRESULT __stdcall CeeGenTokenMapper::Map(
    mdToken     tkFrom, 
    mdToken     tkTo)
{
    if ( IndexForType(tkFrom) == -1 )
    {
        // It is a type that we are not tracking, such as mdtProperty or mdtEvent,
        // just return S_OK.
        return S_OK;
    }

    _ASSERTE(IndexForType(tkFrom) < GetMaxMapSize());
    _ASSERTE(IndexForType(tkTo) != -1 && IndexForType(tkTo) < GetMaxMapSize());

    // If there is another token mapper that the user wants called, go
    // ahead and call it now.
    if (m_pIMapToken)
        m_pIMapToken->Map(tkFrom, tkTo);
    
    mdToken *pToken;
    ULONG ridFrom = RidFromToken(tkFrom);
    TOKENMAP *pMap = &m_rgMap[IndexForType(tkFrom)];

    // If there isn't enough entries, fill out array up to the count
    // and mark the token to nil so we know there is no valid data yet.
    if ((ULONG) pMap->Count() <= ridFrom)
    {
        for (int i=ridFrom - pMap->Count() + 1;  i;  i--) 
        {
            pToken = pMap->Append();
            if (!pToken)
                break;
            *pToken = mdTokenNil;
        }
        _ASSERTE(pMap->Get(ridFrom) == pToken);
    }
    else
        pToken = pMap->Get(ridFrom);
    if (!pToken)
        return (OutOfMemory());
    
    *pToken = tkTo;
    return (S_OK);
}


//*****************************************************************************
// Check the given token to see if it has moved to a new location.  If so,
// return true and give back the new token.
//*****************************************************************************
int CeeGenTokenMapper::HasTokenMoved(
    mdToken     tkFrom,
    mdToken     &tkTo)
{
    mdToken     tk;

    int i = IndexForType(tkFrom);
    if(i == -1) return false;

    _ASSERTE(i < GetMaxMapSize());
    TOKENMAP *pMap = &m_rgMap[i];

    // Assume nothing moves.
    tkTo = tkFrom;

    // If the array is smaller than the index, can't have moved.
    if ((ULONG) pMap->Count() <= RidFromToken(tkFrom))
        return (false);

    // If the entry is set to 0, then nothing there.
    tk = *pMap->Get(RidFromToken(tkFrom));
    if (tk == mdTokenNil)
        return (false);
    
    // Had to move to a new location, return that new location.
    tkTo = tk;
    return (true);
}


//*****************************************************************************
// Hand out a copy of the meta data information.
//*****************************************************************************

HRESULT CeeGenTokenMapper::GetMetaData(
    IMetaDataImport **ppIImport)
{
    if (m_pIImport)
        return (m_pIImport->QueryInterface(IID_IMetaDataImport, (PVOID *) ppIImport));
    *ppIImport = 0;
    return E_FAIL;
}


HRESULT __stdcall CeeGenTokenMapper::QueryInterface(REFIID iid, PVOID *ppIUnk)
{
    if (iid == IID_IUnknown || iid == IID_IMapToken)
        *ppIUnk = static_cast<IMapToken*>(this);
    else
    {
        *ppIUnk = 0;
        return (E_NOINTERFACE);
    }
    AddRef();
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\ceefilegen\ceesectionstring.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CeeSectionString.cpp
// 
// ===========================================================================
#include "stdafx.h"

struct StringTableEntry {
    ULONG m_hashId;
    int m_offset;
    StringTableEntry *m_next;
};

CeeSectionString::CeeSectionString(CCeeGen &ceeFile, CeeSectionImpl &impl)
    : CeeSection(ceeFile, impl)
{
    memset(stringTable, 0, sizeof(stringTable));
}

void CeeSectionString::deleteEntries(StringTableEntry *e)
{
    if (!e)
        return;
    deleteEntries(e->m_next);
    delete e;
}

#ifdef RDATA_STATS
int CeeSectionString::dumpEntries(StringTableEntry *e)
{
    if (!e)
        return 0;
    else {
        printf("    HashId: %d, value: %S\n", e->m_hashId, computOffset(e->m_offset));
        return dumpEntries(e->m_next) + 1;
    }
}

void CeeSectionString::dumpTable()
{
    int sum = 0, count = 0;
    for (int i=0; i < MaxRealEntries; i++) {
        if (stringTable[i]) {
            printf("Bucket %d\n", i);
            printf("Total size: %d\n\n", 
                    count = dumpEntries(stringTable[i]));
            sum += count;
        }
    }
    printf("Total number strings: %d\n\n", sum);
}
#endif

CeeSectionString::~CeeSectionString()
{
#ifdef RDATA_STATS
    dumpTable();
#endif
    for (int i=0; i < MaxRealEntries; i++)
        deleteEntries(stringTable[i]);
}

StringTableEntry* CeeSectionString::createEntry(LPWSTR target, ULONG hashId) 
{
    StringTableEntry *entry = new StringTableEntry;
    if (!entry)
        return NULL;
    entry->m_next = NULL;
    entry->m_hashId = hashId;
    entry->m_offset = dataLen();
    ULONG len = (lstrlenW(target)+1) * sizeof(wchar_t);
    void *buf = getBlock(len);
    if (!buf) {
        delete entry;
        return NULL;
    }
    memcpy(buf, target, len);
    return entry;
}

// Searches through the linked list looking for a match on hashID. If
// multiple elements hash to the same value, a strcmp must be done to
// check for match. The goal is to have very large hashId space so that
// string compares are minimized
StringTableEntry *CeeSectionString::findStringInsert(
                        StringTableEntry *&head, LPWSTR target, ULONG hashId)
{
    StringTableEntry *cur, *prev;
    cur = prev = head;
    while (cur && cur->m_hashId < hashId) {
        prev = cur;
        cur = cur->m_next;
    }
    char *rdataBase = NULL;
    while (cur && cur->m_hashId == hashId) {
        if (wcscmp(target, (LPWSTR)(computePointer(cur->m_offset))) == 0)
            return cur;
        prev = cur;
        cur = cur->m_next;
    }
    // didn't find in chain so insert at prev
    StringTableEntry *entry = createEntry(target, hashId);
    if (cur == head) {
        head = entry;
        entry->m_next = prev;
    } else {
        prev->m_next = entry;
        entry->m_next = cur;
    }
    return entry;
}

HRESULT CeeSectionString::getEmittedStringRef(LPWSTR target, StringRef *ref)
{
    TESTANDRETURN(ref!=NULL, E_POINTER);
    ULONG hashId = HashString(target) % MaxVirtualEntries;
    ULONG bucketIndex = hashId / MaxRealEntries;

    StringTableEntry *entry;
    entry = findStringInsert(stringTable[bucketIndex], target, hashId);

    if (! entry)
        return E_OUTOFMEMORY;
    *ref = entry->m_offset;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\ceefilegen\pesectionman.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// PESectionMan implementation

#include "stdafx.h"

/*****************************************************************/
HRESULT PESectionMan::Init()
{	
	const int initNumSections = 16;	
    sectStart = new PESection*[initNumSections];	
	if (!sectStart)
		return E_OUTOFMEMORY;
    sectCur = sectStart;
    sectEnd = &sectStart[initNumSections];

	return S_OK;
}

/*****************************************************************/
HRESULT PESectionMan::Cleanup()
{
	for (PESection** ptr = sectStart; ptr < sectCur; ptr++)
		delete *ptr;
    delete sectStart;

	return S_OK;
}

/*****************************************************************/
// this class is located in it's own DLL (MsCorXvt.dll)
// Since DLL allocates, The DLL must delete; we can't simply delete from 
// the client (This is a bug in VC, see knowledge base Q122675)
void PESectionMan::sectionDestroy(PESection **section)
{
	// check if this section is referenced in other sections' relocs
	for(PESection** ptr = sectStart; ptr < sectCur; ptr++)
	{
		if(ptr != section)
		{
		    for(PESectionReloc* cur = (*ptr)->m_relocStart; cur < (*ptr)->m_relocCur; cur++) 
			{
				if(cur->section == *section) //here it is! Delete the reference
				{
					for(PESectionReloc* tmp = cur; tmp < (*ptr)->m_relocCur; tmp++)
					{
						memcpy(tmp,(tmp+1),sizeof(PESectionReloc));
					}
					(*ptr)->m_relocCur--;
					cur--; // no position shift this time
				}
			}
		}
	}
	delete *section;
	*section = NULL;
}
/*****************************************************************/

/******************************************************************/
// Apply the relocs for all the sections
// Called by: ClassConverter after loading up during an in-memory conversion, 

void PESectionMan::applyRelocs(CeeGenTokenMapper *pTokenMapper)
{	
	// Cycle through each of the sections
	for(PESection ** ppCurSection = sectStart; ppCurSection < sectCur; ppCurSection++) {
		(*ppCurSection)->applyRelocs(pTokenMapper);
	} // End sections
}


/*****************************************************************/
PESection* PESectionMan::getSection(const char* name)
{
    int     len = (int)strlen(name);

    // the section name can be at most 8 characters including the null. 
    if (len < 8)
        len++;
    else 
        len = 8;

    // dbPrintf(("looking for section %s\n", name));
    for(PESection** cur = sectStart; cur < sectCur; cur++) {
		// dbPrintf(("searching seciton %s\n", (*cur)->m_ame));
		if (strncmp((*cur)->m_name, name, len) == 0) {
			// dbPrintf(("found section %s\n", (*cur)->m_name));
			return(*cur);
		}
	}
    return(0);
}

/******************************************************************/
HRESULT PESectionMan::getSectionCreate(const char* name, unsigned flags, 
													PESection **section)
{	
    PESection* ret = getSection(name);
	if (ret == NULL) 
		return(newSection(name, section, flags));
	*section = ret;
	return(S_OK);
}

/******************************************************************/
HRESULT PESectionMan::newSection(const char* name, PESection **section, 
						unsigned flags, unsigned estSize, unsigned estRelocs)
{
    if (sectCur >= sectEnd) {
		unsigned curLen = (unsigned)(sectCur-sectStart);
		unsigned newLen = curLen * 2 + 1;
		PESection** sectNew = new PESection*[newLen];
		TESTANDRETURN(sectNew, E_OUTOFMEMORY);
		memcpy(sectNew, sectStart, sizeof(PESection*)*curLen);
		delete sectStart;
		sectStart = sectNew;
		sectCur = &sectStart[curLen];
		sectEnd = &sectStart[newLen];
	}

    PESection* ret = new PESection(name, flags, estSize, estRelocs);
    TESTANDRETURN(ret, E_OUTOFMEMORY);
	// dbPrintf(("MAKING NEW %s SECTION data starts at 0x%x\n", name, ret->dataStart));
    *sectCur++ = ret;
	_ASSERTE(sectCur <= sectEnd);
	*section = ret;
    return(S_OK);
}


//Clone each of our sections.  This will cause a deep-copy of the sections
HRESULT PESectionMan::cloneInstance(PESectionMan *destination) {
    _ASSERTE(destination);
    PESection       *pSection;
    PESection       **destPtr;
    HRESULT         hr = NOERROR;

    //Copy each of the sections
    for (PESection** ptr = sectStart; ptr < sectCur; ptr++) {
        destPtr = destination->sectStart;
        pSection = NULL;

        // try to find the matching section by name
        for (; destPtr < destination->sectCur; destPtr++)
        {
            if (strcmp((*destPtr)->m_name, (*ptr)->m_name) == 0)
            {
                pSection = *destPtr;
                break;
            }
        }
        if (destPtr >= destination->sectCur)
        {
            // cannot find a section in the destination with matching name
            // so create one!
            IfFailRet( destination->getSectionCreate((*ptr)->m_name,
		                                        (*ptr)->flags(), 
		                                        &pSection) );
        }
        if (pSection)
            IfFailRet( (*ptr)->cloneInstance(pSection) );
    }
    
    //destination->sectEnd=destination->sectStart + (sectEnd-sectStart);
    return S_OK;
}


//*****************************************************************************
// Implementation for PESection
//*****************************************************************************
/******************************************************************/
PESection::PESection(const char *name, unsigned flags, 
								 unsigned estSize, unsigned estRelocs) {


	dirEntry = -1;

    // No init needed for CBlobFectcher m_pIndex

    // @FUTURE: How do we fail out if allocation fails??
    m_relocStart = new PESectionReloc[estRelocs];
	_ASSERTE(m_relocStart != NULL);

    m_relocCur =  m_relocStart;
    m_relocEnd = &m_relocStart[estRelocs];
    m_header = NULL;
	m_baseRVA = 0;
	m_filePos = 0;
	m_filePad = 0;
	m_flags = flags;

	_ASSERTE(strlen(name)<sizeof(m_name));
	strncpy(m_name, name, sizeof(m_name));
}


/******************************************************************/
PESection::~PESection() {
    delete m_relocStart;
}


/******************************************************************/
void PESection::writeSectReloc(unsigned val, CeeSection& relativeTo, CeeSectionRelocType reloc, CeeSectionRelocExtra *extra) {

	addSectReloc(dataLen(), relativeTo, reloc, extra);
	unsigned* ptr = (unsigned*) getBlock(4);
	*ptr = val;
}

/******************************************************************/
HRESULT PESection::addSectReloc(unsigned offset, CeeSection& relativeToIn, CeeSectionRelocType reloc, CeeSectionRelocExtra *extra) 
{
	return addSectReloc(
		offset, (PESection *)&relativeToIn.getImpl(), reloc, extra); 
}

/******************************************************************/
HRESULT PESection::addSectReloc(unsigned offset, PESection *relativeTo, CeeSectionRelocType reloc, CeeSectionRelocExtra *extra) {

	/* dbPrintf(("******** GOT a section reloc for section %s offset 0x%x to section %x offset 0x%x\n",
		   header->m_name, offset, relativeTo->m_name, *((unsigned*) dataStart + offset))); */
	_ASSERTE(offset < dataLen());

    if (m_relocCur >= m_relocEnd)  {
		unsigned curLen = (unsigned)(m_relocCur-m_relocStart);
		unsigned newLen = curLen * 2 + 1;
		PESectionReloc* relocNew = new PESectionReloc[newLen];
        TESTANDRETURNMEMORY(relocNew);

		memcpy(relocNew, m_relocStart, sizeof(PESectionReloc)*curLen);
		delete m_relocStart;
		m_relocStart = relocNew;
		m_relocCur = &m_relocStart[curLen];
		m_relocEnd = &m_relocStart[newLen];
	}
	
    m_relocCur->type = reloc;
    m_relocCur->offset = offset;
    m_relocCur->section = relativeTo;
	if (extra)
		m_relocCur->extra = *extra;
	m_relocCur++;
	assert(m_relocCur <= m_relocEnd);
	return S_OK;
}

/******************************************************************/
// Compute a pointer (wrap blobfetcher)
char * PESection::computePointer(unsigned offset) const // virtual
{
	return m_blobFetcher.ComputePointer(offset);
}

/******************************************************************/
BOOL PESection::containsPointer(char *ptr) const // virtual
{
	return m_blobFetcher.ContainsPointer(ptr);
}

/******************************************************************/
// Compute an offset (wrap blobfetcher)
unsigned PESection::computeOffset(char *ptr) const // virtual
{
	return m_blobFetcher.ComputeOffset(ptr);
}


/******************************************************************/
HRESULT PESection::addBaseReloc(unsigned offset, CeeSectionRelocType reloc, CeeSectionRelocExtra *extra)
{
	// peSectionBase is a dummy section that causes any offsets to	
	// be relative to the PE base
	static PESection peSectionBase("BASE", 0, 0, 0);
	return addSectReloc(offset, &peSectionBase, reloc, extra);
}

/******************************************************************/
// Dynamic mem allocation, but we can't move old blocks (since others
// have pointers to them), so we need a fancy way to grow
char* PESection::getBlock(unsigned len, unsigned align) {

	return m_blobFetcher.MakeNewBlock(len, align);

}

unsigned PESection::dataLen()  
{
	return m_blobFetcher.GetDataLen();
}

// Apply all the relocs for in memory conversion

// @FUTURE: Currently, our VM is rather inefficient in dealing with in-memory RVA. 
// @FUTURE: VM is given an index to memory pool and a helper will return the memory pointer given the index.
// @FUTURE: We will consider having the coverter resolve RVAs into addresses.

void PESection::applyRelocs(CeeGenTokenMapper *pTokenMapper)
{
	// For each section, go through each of it's relocs
	for(PESectionReloc* pCurReloc = m_relocStart; pCurReloc < m_relocCur; pCurReloc++) {

		if (pCurReloc->type == srRelocMapToken) {
			unsigned * pos = (unsigned*) 
			  m_blobFetcher.ComputePointer(pCurReloc->offset);
			mdToken newToken;
			if (pTokenMapper->HasTokenMoved(*pos, newToken)) {
				// we have a mapped token
				*pos = newToken;
			}
		}

#if 0
		_ASSERTE(pCurReloc->offset + 4 <= CurSection.m_blobFetcher.GetDataLen());
		unsigned * pAddr = (unsigned *) 
		  CurSection.m_blobFetcher.ComputePointer(pCurReloc->offset);
		_ASSERTE(pCurReloc->type == srRelocAbsolute);
			
		// Current contents contain an offset into pCurReloc->section
		// computePointer() is like pCurReloc-section + *pAddr, but for non-linear section
		// This will resolve *pAddr to be a complete address			
		*pAddr = (unsigned) pCurReloc->section->computePointer(*pAddr);
#endif

	} // End relocs
}		

HRESULT PESection::cloneInstance(PESection *destination) {
    PESectionReloc *cur;
    INT32 newSize;
    HRESULT hr = NOERROR;

    _ASSERTE(destination);

    destination->dirEntry = dirEntry;

    //Merge the information currently in the BlobFetcher into 
    //out current blob fetcher
    m_blobFetcher.Merge(&(destination->m_blobFetcher));

    //Copy the name.
	strncpy(destination->m_name, m_name, sizeof(m_name));

    //Clone the relocs
    //If the arrays aren't the same size, reallocate as necessary.
    //@FUTURE:  Make this a ref-counted structure and don't copy it.
    
    newSize = (INT32)(m_relocCur-m_relocStart);

    if (newSize>(destination->m_relocEnd - destination->m_relocStart)) {
        delete destination->m_relocStart;

        destination->m_relocStart = new PESectionReloc[newSize];
        _ASSERTE(destination->m_relocStart != NULL);
        if (destination->m_relocStart == NULL)
            IfFailGo( E_OUTOFMEMORY );
        destination->m_relocEnd = destination->m_relocStart+(newSize);
    }

    //copy the correct data over into our new array.
    memcpy(destination->m_relocStart, m_relocStart, sizeof(PESectionReloc)*(newSize));
    destination->m_relocCur = destination->m_relocStart + (newSize);
    for (cur=destination->m_relocStart; cur<destination->m_relocCur; cur++) {
        cur->section=destination;
    }
ErrExit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\ceefilegen\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//	stdafx.cpp
//
//	Host for precompiled header.
//
//*****************************************************************************
#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\ceefilegen\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#define _CRT_DEPENDENCY_  //this code depends on the crt file functions
#include <CrtWrap.h>
#include <string.h>
#include <limits.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>		// for qsort
#include <windows.h>
#include <time.h>

#include <CorError.h>
#include <UtilCode.h>

#include <corpriv.h>

#include <winreg.h>


#include <sighelper.h>

#include "PESectionMan.h"

#include "ceegen.h"
#include "CeeSectionString.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\cacheload.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CacheLoad.h
//
// Class for returning the memory image where the image lives
//
//*****************************************************************************
#ifndef __CACHELOAD__H__
#define __CACHELOAD__H__


#undef  INTERFACE   
#define INTERFACE ICacheLoad
DECLARE_INTERFACE_(ICacheLoad, IUnknown)
{
    STDMETHOD(GetCachedImaged)(
       LPVOID* pImage);

    STDMETHOD(SetCachedImaged)(
       LPVOID pImage);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\assemblymd.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// AssemblyMD.cpp
//
// Implementation for the assembly meta data emit and import code.
//
//*****************************************************************************
#include "stdafx.h"
#include "RegMeta.h"
#include "MDUtil.h"
#include "RWUtil.h"
#include "MDLog.h"
#include "ImportHelper.h"

#pragma warning(disable: 4102)

extern HRESULT STDMETHODCALLTYPE
    GetAssembliesByName(LPCWSTR  szAppBase,
                        LPCWSTR  szPrivateBin,
                        LPCWSTR  szAssemblyName,
                        IUnknown *ppIUnk[],
                        ULONG    cMax,
                        ULONG    *pcAssemblies);

//*******************************************************************************
// Define an Assembly and set the attributes.
//*******************************************************************************
STDAPI RegMeta::DefineAssembly(         // S_OK or error.
    const void  *pbPublicKey,           // [IN] Public key of the assembly.
    ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
    ULONG       ulHashAlgId,            // [IN] Hash Algorithm.
    LPCWSTR     szName,                 // [IN] Name of the assembly.
    const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
    DWORD       dwAssemblyFlags,        // [IN] Flags.
    mdAssembly  *pma)                   // [OUT] Returned Assembly token.
{
    AssemblyRec *pRecord = 0;           // The assembly record.
    ULONG       iRecord;                // RID of the assembly record.
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::DefineAssembly(0x%08x, 0x%08x, 0x%08x, %S, 0x%08x, 0x%08x, 0x%08x)\n",
        pbPublicKey, cbPublicKey, ulHashAlgId, MDSTR(szName), pMetaData, 
        dwAssemblyFlags, pma));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(szName && pMetaData && pma);

    m_pStgdb->m_MiniMd.PreUpdate();

    // Assembly defs always contain a full public key (assuming they're strong
    // named) rather than the tokenized version. Force the flag on to indicate
    // this, and this way blindly copying public key & flags from a def to a ref
    // will work (though the ref will be bulkier than strictly necessary).
    if (cbPublicKey)
        dwAssemblyFlags |= afPublicKey;

    if (CheckDups(MDDupAssembly))
    {   // Should be no more than one -- just check count of records.
        if (m_pStgdb->m_MiniMd.getCountAssemblys() > 0)
        {   // S/b only one, so we know the rid.
            iRecord = 1;
            // If ENC, let them update the existing record.
            if (IsENCOn())
                pRecord = m_pStgdb->m_MiniMd.getAssembly(iRecord);
            else
            {   // Not ENC, so it is a duplicate.
                *pma = TokenFromRid(iRecord, mdtAssembly);
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
    }
    else
    {   // Not ENC, not duplicate checking, so shouldn't already have one.
        _ASSERTE(m_pStgdb->m_MiniMd.getCountAssemblys() == 0);
    }

    // Create a new record, if needed.
    if (pRecord == 0)
        IfNullGo(pRecord = m_pStgdb->m_MiniMd.AddAssemblyRecord(&iRecord));

    // Set the output parameter.
    *pma = TokenFromRid(iRecord, mdtAssembly);

    IfFailGo(_SetAssemblyProps(*pma, pbPublicKey, cbPublicKey, ulHashAlgId, szName, pMetaData, dwAssemblyFlags));

ErrExit:

    STOP_MD_PERF(DefineAssembly);
    return hr;
}   // RegMeta::DefineAssembly

//*******************************************************************************
// Define an AssemblyRef and set the attributes.
//*******************************************************************************
STDAPI RegMeta::DefineAssemblyRef(      // S_OK or error.
    const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
    ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
    LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
    const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
    const void  *pbHashValue,           // [IN] Hash Blob.
    ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
    DWORD       dwAssemblyRefFlags,     // [IN] Flags.
    mdAssemblyRef *pmar)                // [OUT] Returned AssemblyRef token.
{
    AssemblyRefRec  *pRecord = 0;
    ULONG       iRecord;
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::DefineAssemblyRef(0x%08x, 0x%08x, %S, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
        pbPublicKeyOrToken, cbPublicKeyOrToken, MDSTR(szName), pMetaData, pbHashValue,
        cbHashValue, dwAssemblyRefFlags, pmar));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(szName && pmar);

    if (CheckDups(MDDupAssemblyRef))
    {
        hr = ImportHelper::FindAssemblyRef(&m_pStgdb->m_MiniMd,
                                           UTF8STR(szName),
                                           UTF8STR(pMetaData->szLocale),
                                           pbPublicKeyOrToken,
                                           cbPublicKeyOrToken,
                                           pMetaData->usMajorVersion,
                                           pMetaData->usMinorVersion,
                                           pMetaData->usBuildNumber,
                                           pMetaData->usRevisionNumber,
                                           dwAssemblyRefFlags,
                                           pmar);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pRecord = m_pStgdb->m_MiniMd.getAssemblyRef(RidFromToken(*pmar));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create a new record if needed.
    if (!pRecord)
    {
        // Create a new record.
        IfNullGo(pRecord = m_pStgdb->m_MiniMd.AddAssemblyRefRecord(&iRecord));

        // Set the output parameter.
        *pmar = TokenFromRid(iRecord, mdtAssemblyRef);
    }

    // Set rest of the attributes.
    SetCallerDefine();
    IfFailGo(_SetAssemblyRefProps(*pmar, pbPublicKeyOrToken, cbPublicKeyOrToken, szName, pMetaData,
                                 pbHashValue, cbHashValue, 
                                 dwAssemblyRefFlags));
ErrExit:
    SetCallerExternal();
    
    STOP_MD_PERF(DefineAssemblyRef);
    return hr;
}   // RegMeta::DefineAssemblyRef

//*******************************************************************************
// Define a File and set the attributes.
//*******************************************************************************
STDAPI RegMeta::DefineFile(             // S_OK or error.
    LPCWSTR     szName,                 // [IN] Name of the file.
    const void  *pbHashValue,           // [IN] Hash Blob.
    ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
    DWORD       dwFileFlags,            // [IN] Flags.
    mdFile      *pmf)                   // [OUT] Returned File token.
{
    FileRec     *pRecord = 0;
    ULONG       iRecord;
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::DefineFile(%S, %#08x, %#08x, %#08x, %#08x)\n",
        MDSTR(szName), pbHashValue, cbHashValue, dwFileFlags, pmf));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(szName && pmf);

    if (CheckDups(MDDupFile))
    {
        hr = ImportHelper::FindFile(&m_pStgdb->m_MiniMd, UTF8STR(szName), pmf);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pRecord = m_pStgdb->m_MiniMd.getFile(RidFromToken(*pmf));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create a new record if needed.
    if (!pRecord)
    {
        // Create a new record.
        IfNullGo(pRecord = m_pStgdb->m_MiniMd.AddFileRecord(&iRecord));

        // Set the output parameter.
        *pmf = TokenFromRid(iRecord, mdtFile);

        // Set the name.
        IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_File, FileRec::COL_Name, pRecord, szName));
    }

    // Set rest of the attributes.
    IfFailGo(_SetFileProps(*pmf, pbHashValue, cbHashValue, dwFileFlags));
ErrExit:
    
    STOP_MD_PERF(DefineFile);
    return hr;
}   // RegMeta::DefineFile

//*******************************************************************************
// Define a ExportedType and set the attributes.
//*******************************************************************************
STDAPI RegMeta::DefineExportedType(     // S_OK or error.
    LPCWSTR     szName,                 // [IN] Name of the Com Type.
    mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the ExportedType.
    mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
    DWORD       dwExportedTypeFlags,    // [IN] Flags.
    mdExportedType   *pmct)             // [OUT] Returned ExportedType token.
{
    ExportedTypeRec  *pRecord = 0;
    ULONG       iRecord;
    LPSTR       szNameUTF8;
    LPCSTR      szTypeNameUTF8;
    LPCSTR      szTypeNamespaceUTF8;
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::DefineExportedType(%S, %#08x, %08x, %#08x, %#08x)\n",
        MDSTR(szName), tkImplementation, tkTypeDef, 
         dwExportedTypeFlags, pmct));
    START_MD_PERF();
    LOCKWRITE();

    // Validate name for prefix.
    if (!szName)
        IfFailGo(E_INVALIDARG);

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(ns::IsValidName(szName));
    //SLASHES2DOTS_NAMESPACE_BUFFER_UNICODE(szName, szName);

    szNameUTF8 = UTF8STR(szName);
    // Split the name into name/namespace pair.
    ns::SplitInline(szNameUTF8, szTypeNamespaceUTF8, szTypeNameUTF8);

    _ASSERTE(szName && dwExportedTypeFlags != ULONG_MAX && pmct);
    _ASSERTE(TypeFromToken(tkImplementation) == mdtFile ||
              TypeFromToken(tkImplementation) == mdtAssemblyRef ||
              TypeFromToken(tkImplementation) == mdtExportedType ||
              tkImplementation == mdTokenNil);

    if (CheckDups(MDDupExportedType))
    {
        hr = ImportHelper::FindExportedType(&m_pStgdb->m_MiniMd,
                                       szTypeNamespaceUTF8,
                                       szTypeNameUTF8,
                                       tkImplementation,
                                       pmct);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pRecord = m_pStgdb->m_MiniMd.getExportedType(RidFromToken(*pmct));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create a new record if needed.
    if (!pRecord)
    {
        // Create a new record.
        IfNullGo(pRecord = m_pStgdb->m_MiniMd.AddExportedTypeRecord(&iRecord));

        // Set the output parameter.
        *pmct = TokenFromRid(iRecord, mdtExportedType);

        // Set the TypeName and TypeNamespace.
        IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_ExportedType,
                ExportedTypeRec::COL_TypeName, pRecord, szTypeNameUTF8));
        if (szTypeNamespaceUTF8)
        {
            IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_ExportedType,
                    ExportedTypeRec::COL_TypeNamespace, pRecord, szTypeNamespaceUTF8));
        }
    }

    // Set rest of the attributes.
    IfFailGo(_SetExportedTypeProps(*pmct, tkImplementation, tkTypeDef,
                             dwExportedTypeFlags));
ErrExit:
    
    STOP_MD_PERF(DefineExportedType);
    return hr;
}   // RegMeta::DefineExportedType

//*******************************************************************************
// Define a Resource and set the attributes.
//*******************************************************************************
STDAPI RegMeta::DefineManifestResource( // S_OK or error.
    LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
    mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
    DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
    DWORD       dwResourceFlags,        // [IN] Flags.
    mdManifestResource  *pmmr)          // [OUT] Returned ManifestResource token.
{
    ManifestResourceRec *pRecord = 0;
    ULONG       iRecord;
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::DefineManifestResource(%S, %#08x, %#08x, %#08x, %#08x)\n",
        MDSTR(szName), tkImplementation, dwOffset, dwResourceFlags, pmmr));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(szName && dwResourceFlags != ULONG_MAX && pmmr);
    _ASSERTE(TypeFromToken(tkImplementation) == mdtFile ||
              TypeFromToken(tkImplementation) == mdtAssemblyRef ||
              tkImplementation == mdTokenNil);

    if (CheckDups(MDDupManifestResource))
    {
        hr = ImportHelper::FindManifestResource(&m_pStgdb->m_MiniMd, UTF8STR(szName), pmmr);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pRecord = m_pStgdb->m_MiniMd.getManifestResource(RidFromToken(*pmmr));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create a new record if needed.
    if (!pRecord)
    {
        // Create a new record.
        IfNullGo(pRecord = m_pStgdb->m_MiniMd.AddManifestResourceRecord(&iRecord));

        // Set the output parameter.
        *pmmr = TokenFromRid(iRecord, mdtManifestResource);

        // Set the name.
        IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_ManifestResource,
                                    ManifestResourceRec::COL_Name, pRecord, szName));
    }

    // Set the rest of the attributes.
    IfFailGo(_SetManifestResourceProps(*pmmr, tkImplementation, 
                                dwOffset, dwResourceFlags));

ErrExit:
    
    STOP_MD_PERF(DefineManifestResource);
    return hr;
}   // RegMeta::DefineManifestResource

//*******************************************************************************
// Set the specified attributes on the given Assembly token.
//*******************************************************************************
STDAPI RegMeta::SetAssemblyProps(       // S_OK or error.
    mdAssembly  ma,                     // [IN] Assembly token.
    const void  *pbPublicKey,           // [IN] Public key of the assembly.
    ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
    ULONG       ulHashAlgId,            // [IN] Hash Algorithm.
    LPCWSTR     szName,                 // [IN] Name of the assembly.
    const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
    DWORD       dwAssemblyFlags)        // [IN] Flags.
{
    AssemblyRec *pRecord = 0;           // The assembly record.
    HRESULT     hr = S_OK;

    _ASSERTE(TypeFromToken(ma) == mdtAssembly && RidFromToken(ma));

    LOG((LOGMD, "RegMeta::SetAssemblyProps(%#08x, %#08x, %#08x, %#08x %S, %#08x, %#08x)\n",
        ma, pbPublicKey, cbPublicKey, ulHashAlgId, MDSTR(szName), pMetaData, dwAssemblyFlags));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    IfFailGo(_SetAssemblyProps(ma, pbPublicKey, cbPublicKey, ulHashAlgId, szName, pMetaData, dwAssemblyFlags));
    
ErrExit:
    
    STOP_MD_PERF(SetAssemblyProps);
    return hr;
} // STDAPI SetAssemblyProps()
    
//*******************************************************************************
// Set the specified attributes on the given AssemblyRef token.
//*******************************************************************************
STDAPI RegMeta::SetAssemblyRefProps(    // S_OK or error.
    mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
    const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
    ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
    LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
    const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
    const void  *pbHashValue,           // [IN] Hash Blob.
    ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
    DWORD       dwAssemblyRefFlags)     // [IN] Flags.
{
    ULONG       i = 0;
    HRESULT     hr = S_OK;

    _ASSERTE(TypeFromToken(ar) == mdtAssemblyRef && RidFromToken(ar));

    LOG((LOGMD, "RegMeta::SetAssemblyRefProps(0x%08x, 0x%08x, 0x%08x, %S, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
        ar, pbPublicKeyOrToken, cbPublicKeyOrToken, MDSTR(szName), pMetaData, pbHashValue, cbHashValue,
        dwAssemblyRefFlags));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    IfFailGo( _SetAssemblyRefProps(
        ar,
        pbPublicKeyOrToken,
        cbPublicKeyOrToken,
        szName,
        pMetaData,
        pbHashValue,
        cbHashValue,
        dwAssemblyRefFlags) );

ErrExit:
    
    STOP_MD_PERF(SetAssemblyRefProps);
    return hr;
}   // RegMeta::SetAssemblyRefProps

//*******************************************************************************
// Set the specified attributes on the given File token.
//*******************************************************************************
STDAPI RegMeta::SetFileProps(           // S_OK or error.
    mdFile      file,                   // [IN] File token.
    const void  *pbHashValue,           // [IN] Hash Blob.
    ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
    DWORD       dwFileFlags)            // [IN] Flags.
{
    HRESULT     hr = S_OK;
    
    _ASSERTE(TypeFromToken(file) == mdtFile && RidFromToken(file));

    LOG((LOGMD, "RegMeta::SetFileProps(%#08x, %#08x, %#08x, %#08x)\n",
        file, pbHashValue, cbHashValue, dwFileFlags));
    START_MD_PERF();
    LOCKWRITE();

    IfFailGo( _SetFileProps(file, pbHashValue, cbHashValue, dwFileFlags) );

ErrExit:
    
    STOP_MD_PERF(SetFileProps);
    return hr;
}   // RegMeta::SetFileProps

//*******************************************************************************
// Set the specified attributes on the given ExportedType token.
//*******************************************************************************
STDAPI RegMeta::SetExportedTypeProps(        // S_OK or error.
    mdExportedType   ct,                     // [IN] ExportedType token.
    mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the ExportedType.
    mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
    DWORD       dwExportedTypeFlags)         // [IN] Flags.
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::SetExportedTypeProps(%#08x, %#08x, %#08x, %#08x)\n",
        ct, tkImplementation, tkTypeDef, dwExportedTypeFlags));
    START_MD_PERF();
    LOCKWRITE();
    
    IfFailGo( _SetExportedTypeProps( ct, tkImplementation, tkTypeDef, dwExportedTypeFlags) );

ErrExit:
    
    STOP_MD_PERF(SetExportedTypeProps);
    return hr;
}   // RegMeta::SetExportedTypeProps

//*******************************************************************************
// Set the specified attributes on the given ManifestResource token.
//*******************************************************************************
STDAPI RegMeta::SetManifestResourceProps(// S_OK or error.
    mdManifestResource  mr,             // [IN] ManifestResource token.
    mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
    DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
    DWORD       dwResourceFlags)        // [IN] Flags.
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::SetManifestResourceProps(%#08x, %#08x, %#08x, %#08x)\n",
        mr, tkImplementation, dwOffset,  
        dwResourceFlags));
         
    _ASSERTE(TypeFromToken(tkImplementation) == mdtFile ||
              TypeFromToken(tkImplementation) == mdtAssemblyRef ||
              tkImplementation == mdTokenNil);

    START_MD_PERF();
    LOCKWRITE();
    
    IfFailGo( _SetManifestResourceProps( mr, tkImplementation, dwOffset, dwResourceFlags) );

ErrExit:
    
    STOP_MD_PERF(SetManifestResourceProps);
    return hr;
} // STDAPI RegMeta::SetManifestResourceProps()

//*******************************************************************************
// Helper: Set the specified attributes on the given Assembly token.
//*******************************************************************************
HRESULT RegMeta::_SetAssemblyProps(     // S_OK or error.
    mdAssembly  ma,                     // [IN] Assembly token.
    const void  *pbPublicKey,          // [IN] Originator of the assembly.
    ULONG       cbPublicKey,           // [IN] Count of bytes in the Originator blob.
    ULONG       ulHashAlgId,            // [IN] Hash Algorithm.
    LPCWSTR     szName,                 // [IN] Name of the assembly.
    const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
    DWORD       dwAssemblyFlags)        // [IN] Flags.
{
    AssemblyRec *pRecord = 0;           // The assembly record.
    HRESULT     hr = S_OK;

    pRecord = m_pStgdb->m_MiniMd.getAssembly(RidFromToken(ma));
    
    // Set the data.
    if (pbPublicKey)
        IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_Assembly, AssemblyRec::COL_PublicKey,
                                pRecord, pbPublicKey, cbPublicKey));
    if (ulHashAlgId != ULONG_MAX)
        pRecord->m_HashAlgId = ulHashAlgId;
    IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_Assembly, AssemblyRec::COL_Name, pRecord, szName));
    if (pMetaData->usMajorVersion != USHRT_MAX)
        pRecord->m_MajorVersion = pMetaData->usMajorVersion;
    if (pMetaData->usMinorVersion != USHRT_MAX)
        pRecord->m_MinorVersion = pMetaData->usMinorVersion;
    if (pMetaData->usBuildNumber != USHRT_MAX)
        pRecord->m_BuildNumber = pMetaData->usBuildNumber;
    if (pMetaData->usRevisionNumber != USHRT_MAX)
        pRecord->m_RevisionNumber = pMetaData->usRevisionNumber;
    if (pMetaData->szLocale)
        IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_Assembly, AssemblyRec::COL_Locale,
                                pRecord, pMetaData->szLocale));
    pRecord->m_Flags = dwAssemblyFlags;
    IfFailGo(UpdateENCLog(ma));

ErrExit:
    
    return hr;
} // HRESULT RegMeta::_SetAssemblyProps()
    
//*******************************************************************************
// Helper: Set the specified attributes on the given AssemblyRef token.
//*******************************************************************************
HRESULT RegMeta::_SetAssemblyRefProps(  // S_OK or error.
    mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
    const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
    ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
    LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
    const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
    const void  *pbHashValue,           // [IN] Hash Blob.
    ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
    DWORD       dwAssemblyRefFlags)     // [IN] Flags.
{
    AssemblyRefRec *pRecord;
    ULONG       i = 0;
    HRESULT     hr = S_OK;

    pRecord = m_pStgdb->m_MiniMd.getAssemblyRef(RidFromToken(ar));

    if (pbPublicKeyOrToken)
        IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_AssemblyRef, AssemblyRefRec::COL_PublicKeyOrToken,
                                pRecord, pbPublicKeyOrToken, cbPublicKeyOrToken));
    if (szName)
        IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_AssemblyRef, AssemblyRefRec::COL_Name,
                                pRecord, szName));
    if (pMetaData)
    {
        if (pMetaData->usMajorVersion != USHRT_MAX)
            pRecord->m_MajorVersion = pMetaData->usMajorVersion;
        if (pMetaData->usMinorVersion != USHRT_MAX)
            pRecord->m_MinorVersion = pMetaData->usMinorVersion;
        if (pMetaData->usBuildNumber != USHRT_MAX)
            pRecord->m_BuildNumber = pMetaData->usBuildNumber;
        if (pMetaData->usRevisionNumber != USHRT_MAX)
            pRecord->m_RevisionNumber = pMetaData->usRevisionNumber;
        if (pMetaData->szLocale)
            IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_AssemblyRef,
                    AssemblyRefRec::COL_Locale, pRecord, pMetaData->szLocale));
    }
    if (pbHashValue)
        IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_AssemblyRef, AssemblyRefRec::COL_HashValue,
                                    pRecord, pbHashValue, cbHashValue));
    if (dwAssemblyRefFlags != ULONG_MAX)
        pRecord->m_Flags = dwAssemblyRefFlags;

    IfFailGo(UpdateENCLog(ar));

ErrExit:
    return hr;
}   // RegMeta::_SetAssemblyRefProps

//*******************************************************************************
// Helper: Set the specified attributes on the given File token.
//*******************************************************************************
HRESULT RegMeta::_SetFileProps(         // S_OK or error.
    mdFile      file,                   // [IN] File token.
    const void  *pbHashValue,           // [IN] Hash Blob.
    ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
    DWORD       dwFileFlags)            // [IN] Flags.
{
    FileRec     *pRecord;
    HRESULT     hr = S_OK;

    pRecord = m_pStgdb->m_MiniMd.getFile(RidFromToken(file));

    if (pbHashValue)
        IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_File, FileRec::COL_HashValue, pRecord,
                                    pbHashValue, cbHashValue));
    if (dwFileFlags != ULONG_MAX)
        pRecord->m_Flags = dwFileFlags;

    IfFailGo(UpdateENCLog(file));
ErrExit:
    return hr;
}   // RegMeta::_SetFileProps

//*******************************************************************************
// Helper: Set the specified attributes on the given ExportedType token.
//*******************************************************************************
HRESULT RegMeta::_SetExportedTypeProps( // S_OK or error.
    mdExportedType   ct,                // [IN] ExportedType token.
    mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the ExportedType.
    mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
    DWORD       dwExportedTypeFlags)    // [IN] Flags.
{
    ExportedTypeRec  *pRecord;
    HRESULT     hr = S_OK;

    pRecord = m_pStgdb->m_MiniMd.getExportedType(RidFromToken(ct));

    if(! IsNilToken(tkImplementation))
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_ExportedType, ExportedTypeRec::COL_Implementation,
                                        pRecord, tkImplementation));
    if (! IsNilToken(tkTypeDef))
    {
        _ASSERTE(TypeFromToken(tkTypeDef) == mdtTypeDef);
        pRecord->m_TypeDefId = tkTypeDef;
    }
    if (dwExportedTypeFlags != ULONG_MAX)
        pRecord->m_Flags = dwExportedTypeFlags;

    IfFailGo(UpdateENCLog(ct));
ErrExit:
    return hr;
}   // RegMeta::_SetExportedTypeProps

//*******************************************************************************
// Helper: Set the specified attributes on the given ManifestResource token.
//*******************************************************************************
HRESULT RegMeta::_SetManifestResourceProps(// S_OK or error.
    mdManifestResource  mr,             // [IN] ManifestResource token.
    mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
    DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
    DWORD       dwResourceFlags)        // [IN] Flags.
{
    ManifestResourceRec *pRecord = 0;
    HRESULT     hr = S_OK;

    pRecord = m_pStgdb->m_MiniMd.getManifestResource(RidFromToken(mr));
    
    // Set the attributes.
    if (tkImplementation != mdTokenNil)
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_ManifestResource,
                    ManifestResourceRec::COL_Implementation, pRecord, tkImplementation));
    if (dwOffset != ULONG_MAX)
        pRecord->m_Offset = dwOffset;
    if (dwResourceFlags != ULONG_MAX)
        pRecord->m_Flags = dwResourceFlags;

    IfFailGo(UpdateENCLog(mr));
    
ErrExit:
    return hr;
} // HRESULT RegMeta::_SetManifestResourceProps()



//*******************************************************************************
// Get the properties for the given Assembly token.
//*******************************************************************************
STDAPI RegMeta::GetAssemblyProps(       // S_OK or error.
    mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
    const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
    ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
    ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
    LPWSTR      szName,                 // [OUT] Buffer to fill with name.
    ULONG       cchName,                // [IN] Size of buffer in wide chars.
    ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
    ASSEMBLYMETADATA *pMetaData,         // [OUT] Assembly MetaData.
    DWORD       *pdwAssemblyFlags)      // [OUT] Flags.
{
    AssemblyRec *pRecord;
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::GetAssemblyProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
        mda, ppbPublicKey, pcbPublicKey, pulHashAlgId, szName, cchName, pchName, pMetaData,
        pdwAssemblyFlags));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(TypeFromToken(mda) == mdtAssembly && RidFromToken(mda));
    pRecord = pMiniMd->getAssembly(RidFromToken(mda));

    if (ppbPublicKey)
        *ppbPublicKey = pMiniMd->getPublicKeyOfAssembly(pRecord, pcbPublicKey);
    if (pulHashAlgId)
        *pulHashAlgId = pMiniMd->getHashAlgIdOfAssembly(pRecord);
    if (szName || pchName)
        IfFailGo(pMiniMd->getNameOfAssembly(pRecord, szName, cchName, pchName));
    if (pMetaData)
    {
        pMetaData->usMajorVersion = pMiniMd->getMajorVersionOfAssembly(pRecord);
        pMetaData->usMinorVersion = pMiniMd->getMinorVersionOfAssembly(pRecord);
        pMetaData->usBuildNumber = pMiniMd->getBuildNumberOfAssembly(pRecord);
        pMetaData->usRevisionNumber = pMiniMd->getRevisionNumberOfAssembly(pRecord);
        IfFailGo(pMiniMd->getLocaleOfAssembly(pRecord, pMetaData->szLocale,
                                              pMetaData->cbLocale, &pMetaData->cbLocale));
        pMetaData->ulProcessor = 0;
        pMetaData->ulOS = 0;
    }
    if (pdwAssemblyFlags)
    {
        *pdwAssemblyFlags = pMiniMd->getFlagsOfAssembly(pRecord);
        
		// Turn on the afPublicKey if PublicKey blob is not empty
        DWORD cbPublicKey;
        pMiniMd->getPublicKeyOfAssembly(pRecord, &cbPublicKey);
        if (cbPublicKey)
            *pdwAssemblyFlags |= afPublicKey;
    }
ErrExit:
    
    STOP_MD_PERF(GetAssemblyProps);
    return hr;
}   // RegMeta::GetAssemblyProps

//*******************************************************************************
// Get the properties for the given AssemblyRef token.
//*******************************************************************************
STDAPI RegMeta::GetAssemblyRefProps(    // S_OK or error.
    mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
    const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
    ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
    LPWSTR      szName,                 // [OUT] Buffer to fill with name.
    ULONG       cchName,                // [IN] Size of buffer in wide chars.
    ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
    ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
    const void  **ppbHashValue,         // [OUT] Hash blob.
    ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
    DWORD       *pdwAssemblyRefFlags)   // [OUT] Flags.
{
    AssemblyRefRec  *pRecord;
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::GetAssemblyRefProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
        mdar, ppbPublicKeyOrToken, pcbPublicKeyOrToken, szName, cchName,
        pchName, pMetaData, ppbHashValue, pdwAssemblyRefFlags));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(TypeFromToken(mdar) == mdtAssemblyRef && RidFromToken(mdar));
    pRecord = pMiniMd->getAssemblyRef(RidFromToken(mdar));

    if (ppbPublicKeyOrToken)
        *ppbPublicKeyOrToken = pMiniMd->getPublicKeyOrTokenOfAssemblyRef(pRecord, pcbPublicKeyOrToken);
    if (szName || pchName)
        IfFailGo(pMiniMd->getNameOfAssemblyRef(pRecord, szName, cchName, pchName));
    if (pMetaData)
    {
        pMetaData->usMajorVersion = pMiniMd->getMajorVersionOfAssemblyRef(pRecord);
        pMetaData->usMinorVersion = pMiniMd->getMinorVersionOfAssemblyRef(pRecord);
        pMetaData->usBuildNumber = pMiniMd->getBuildNumberOfAssemblyRef(pRecord);
        pMetaData->usRevisionNumber = pMiniMd->getRevisionNumberOfAssemblyRef(pRecord);
        IfFailGo(pMiniMd->getLocaleOfAssemblyRef(pRecord, pMetaData->szLocale,
                                    pMetaData->cbLocale, &pMetaData->cbLocale));
        pMetaData->ulProcessor = 0;
        pMetaData->ulOS = 0;
    }
    if (ppbHashValue)
        *ppbHashValue = pMiniMd->getHashValueOfAssemblyRef(pRecord, pcbHashValue);
    if (pdwAssemblyRefFlags)
        *pdwAssemblyRefFlags = pMiniMd->getFlagsOfAssemblyRef(pRecord);
ErrExit:
    
    STOP_MD_PERF(GetAssemblyRefProps);
    return hr;
}   // RegMeta::GetAssemblyRefProps

//*******************************************************************************
// Get the properties for the given File token.
//*******************************************************************************
STDAPI RegMeta::GetFileProps(               // S_OK or error.
    mdFile      mdf,                    // [IN] The File for which to get the properties.
    LPWSTR      szName,                 // [OUT] Buffer to fill with name.
    ULONG       cchName,                // [IN] Size of buffer in wide chars.
    ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
    const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
    ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
    DWORD       *pdwFileFlags)          // [OUT] Flags.
{
    FileRec     *pRecord;
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::GetFileProps(%#08x, %#08x, %#08x, %#08x, %#08x, %#08x, %#08x)\n",
        mdf, szName, cchName, pchName, ppbHashValue, pcbHashValue, pdwFileFlags));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(TypeFromToken(mdf) == mdtFile && RidFromToken(mdf));
    pRecord = pMiniMd->getFile(RidFromToken(mdf));

    if (szName || pchName)
        IfFailGo(pMiniMd->getNameOfFile(pRecord, szName, cchName, pchName));
    if (ppbHashValue)
        *ppbHashValue = pMiniMd->getHashValueOfFile(pRecord, pcbHashValue);
    if (pdwFileFlags)
        *pdwFileFlags = pMiniMd->getFlagsOfFile(pRecord);
ErrExit:
    
    STOP_MD_PERF(GetFileProps);
    return hr;
}   // RegMeta::GetFileProps

//*******************************************************************************
// Get the properties for the given ExportedType token.
//*******************************************************************************
STDAPI RegMeta::GetExportedTypeProps(   // S_OK or error.
    mdExportedType   mdct,              // [IN] The ExportedType for which to get the properties.
    LPWSTR      szName,                 // [OUT] Buffer to fill with name.
    ULONG       cchName,                // [IN] Size of buffer in wide chars.
    ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
    mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
    mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
    DWORD       *pdwExportedTypeFlags)  // [OUT] Flags.
{
    ExportedTypeRec  *pRecord;          // The exported type.
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    int         bTruncation=0;          // Was there name truncation?
    HRESULT     hr = S_OK;              // A result.

    LOG((LOGMD, "RegMeta::GetExportedTypeProps(%#08x, %#08x, %#08x, %#08x, %#08x, %#08x, %#08x)\n",
        mdct, szName, cchName, pchName, 
        ptkImplementation, ptkTypeDef, pdwExportedTypeFlags));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(TypeFromToken(mdct) == mdtExportedType && RidFromToken(mdct));
    pRecord = pMiniMd->getExportedType(RidFromToken(mdct));

    if (szName || pchName)
    {
        LPCSTR  szTypeNamespace;
        LPCSTR  szTypeName;

        szTypeNamespace = pMiniMd->getTypeNamespaceOfExportedType(pRecord);
        MAKE_WIDEPTR_FROMUTF8(wzTypeNamespace, szTypeNamespace);

        szTypeName = pMiniMd->getTypeNameOfExportedType(pRecord);
        _ASSERTE(*szTypeName);
        MAKE_WIDEPTR_FROMUTF8(wzTypeName, szTypeName);

        if (szName)
            bTruncation = ! (ns::MakePath(szName, cchName, wzTypeNamespace, wzTypeName));
        if (pchName)
        {
            if (bTruncation || !szName)
                *pchName = ns::GetFullLength(wzTypeNamespace, wzTypeName);
            else
                *pchName = (ULONG)(wcslen(szName) + 1);
        }
    }
    if (ptkImplementation)
        *ptkImplementation = pMiniMd->getImplementationOfExportedType(pRecord);
    if (ptkTypeDef)
        *ptkTypeDef = pMiniMd->getTypeDefIdOfExportedType(pRecord);
    if (pdwExportedTypeFlags)
        *pdwExportedTypeFlags = pMiniMd->getFlagsOfExportedType(pRecord);

    if (bTruncation && hr == S_OK)
        hr = CLDB_S_TRUNCATION;
ErrExit:
    
    STOP_MD_PERF(GetExportedTypeProps);
    return hr;
}   // RegMeta::GetExportedTypeProps

//*******************************************************************************
// Get the properties for the given Resource token.
//*******************************************************************************
STDAPI RegMeta::GetManifestResourceProps(   // S_OK or error.
    mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
    LPWSTR      szName,                 // [OUT] Buffer to fill with name.
    ULONG       cchName,                // [IN] Size of buffer in wide chars.
    ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
    mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
    DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
    DWORD       *pdwResourceFlags)      // [OUT] Flags.
{
    ManifestResourceRec *pRecord;
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    HRESULT     hr = S_OK;

    LOG((LOGMD, "RegMeta::GetManifestResourceProps("
        "%#08x, %#08x, %#08x, %#08x, %#08x, %#08x, %#08x)\n",
        mdmr, szName, cchName, pchName, 
        ptkImplementation, pdwOffset, 
        pdwResourceFlags));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(TypeFromToken(mdmr) == mdtManifestResource && RidFromToken(mdmr));
    pRecord = pMiniMd->getManifestResource(RidFromToken(mdmr));

    if (szName || pchName)
        IfFailGo(pMiniMd->getNameOfManifestResource(pRecord, szName, cchName, pchName));
    if (ptkImplementation)
        *ptkImplementation = pMiniMd->getImplementationOfManifestResource(pRecord);
    if (pdwOffset)
        *pdwOffset = pMiniMd->getOffsetOfManifestResource(pRecord);
    if (pdwResourceFlags)
        *pdwResourceFlags = pMiniMd->getFlagsOfManifestResource(pRecord);
ErrExit:
    
    STOP_MD_PERF(GetManifestResourceProps);
    return hr;
}   // RegMeta::GetManifestResourceProps


//*******************************************************************************
// Enumerating through all of the AssemblyRefs.
//*******************************************************************************   
STDAPI RegMeta::EnumAssemblyRefs(       // S_OK or error
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
    ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    HENUMInternal       *pEnum;

    LOG((LOGMD, "MD RegMeta::EnumAssemblyRefs(%#08x, %#08x, %#08x, %#08x)\n", 
        phEnum, rAssemblyRefs, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();

    if (*ppmdEnum == 0)
    {
        // instantiate a new ENUM.
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        // create the enumerator.
        IfFailGo(HENUMInternal::CreateSimpleEnum(
            mdtAssemblyRef,
            1,
            pMiniMd->getCountAssemblyRefs() + 1,
            &pEnum) );

        // set the output parameter.
        *ppmdEnum = pEnum;
    }
    else
        pEnum = *ppmdEnum;

    // we can only fill the minimum of what the caller asked for or what we have left.
    IfFailGo(HENUMInternal::EnumWithCount(pEnum, cMax, rAssemblyRefs, pcTokens));
ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumAssemblyRefs);
    return hr;
}   // RegMeta::EnumAssemblyRefs

//*******************************************************************************
// Enumerating through all of the Files.
//*******************************************************************************   
STDAPI RegMeta::EnumFiles(              // S_OK or error
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdFile      rFiles[],               // [OUT] Put Files here.
    ULONG       cMax,                   // [IN] Max Files to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    HENUMInternal       *pEnum;

    LOG((LOGMD, "MD RegMeta::EnumFiles(%#08x, %#08x, %#08x, %#08x)\n", 
        phEnum, rFiles, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();

    if (*ppmdEnum == 0)
    {
        // instantiate a new ENUM.
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        // create the enumerator.
        IfFailGo(HENUMInternal::CreateSimpleEnum(
            mdtFile,
            1,
            pMiniMd->getCountFiles() + 1,
            &pEnum) );

        // set the output parameter.
        *ppmdEnum = pEnum;
    }
    else
        pEnum = *ppmdEnum;

    // we can only fill the minimum of what the caller asked for or what we have left.
    IfFailGo(HENUMInternal::EnumWithCount(pEnum, cMax, rFiles, pcTokens));
ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumFiles);
    return hr;
}   // RegMeta::EnumFiles

//*******************************************************************************
// Enumerating through all of the ExportedTypes.
//*******************************************************************************   
STDAPI RegMeta::EnumExportedTypes(           // S_OK or error
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdExportedType   rExportedTypes[],            // [OUT] Put ExportedTypes here.
    ULONG       cMax,                   // [IN] Max ExportedTypes to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    HENUMInternal       *pEnum;

    LOG((LOGMD, "MD RegMeta::EnumExportedTypes(%#08x, %#08x, %#08x, %#08x)\n", 
        phEnum, rExportedTypes, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();
    
    if (*ppmdEnum == 0)
    {
        // instantiate a new ENUM.
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        if (pMiniMd->HasDelete() && 
            ((m_OptionValue.m_ImportOption & MDImportOptionAllExportedTypes) == 0))
        {
            IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtExportedType, &pEnum) );

            // add all Types to the dynamic array if name is not _Delete
            for (ULONG index = 1; index <= pMiniMd->getCountExportedTypes(); index ++ )
            {
                ExportedTypeRec       *pRec = pMiniMd->getExportedType(index);
                if (IsDeletedName(pMiniMd->getTypeNameOfExportedType(pRec)) )
                {   
                    continue;
                }
                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(index, mdtExportedType) ) );
            }
        }
        else
        {
            // create the enumerator.
            IfFailGo(HENUMInternal::CreateSimpleEnum(
                mdtExportedType,
                1,
                pMiniMd->getCountExportedTypes() + 1,
                &pEnum) );
        }

        // set the output parameter.
        *ppmdEnum = pEnum;
    }
    else
        pEnum = *ppmdEnum;

    // we can only fill the minimum of what the caller asked for or what we have left.
    IfFailGo(HENUMInternal::EnumWithCount(pEnum, cMax, rExportedTypes, pcTokens));
ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumExportedTypes);
    return hr;
}   // RegMeta::EnumExportedTypes

//*******************************************************************************
// Enumerating through all of the Resources.
//*******************************************************************************   
STDAPI RegMeta::EnumManifestResources(  // S_OK or error
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
    ULONG       cMax,                   // [IN] Max Resources to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    HENUMInternal       *pEnum;

    LOG((LOGMD, "MD RegMeta::EnumManifestResources(%#08x, %#08x, %#08x, %#08x)\n", 
        phEnum, rManifestResources, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();

    if (*ppmdEnum == 0)
    {
        // instantiate a new ENUM.
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        // create the enumerator.
        IfFailGo(HENUMInternal::CreateSimpleEnum(
            mdtManifestResource,
            1,
            pMiniMd->getCountManifestResources() + 1,
            &pEnum) );

        // set the output parameter.
        *ppmdEnum = pEnum;
    }
    else
        pEnum = *ppmdEnum;

    // we can only fill the minimum of what the caller asked for or what we have left.
    IfFailGo(HENUMInternal::EnumWithCount(pEnum, cMax, rManifestResources, pcTokens));
ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumManifestResources);
    return hr;
}   // RegMeta::EnumManifestResources

//*******************************************************************************
// Get the Assembly token for the given scope..
//*******************************************************************************
STDAPI RegMeta::GetAssemblyFromScope(   // S_OK or error
    mdAssembly  *ptkAssembly)           // [OUT] Put token here.
{
    HRESULT     hr = NOERROR;
    LOG((LOGMD, "MD RegMeta::GetAssemblyFromScope(%#08x)\n", ptkAssembly));
    START_MD_PERF();

    _ASSERTE(ptkAssembly);

    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    if (pMiniMd->getCountAssemblys())
    {
        *ptkAssembly = TokenFromRid(1, mdtAssembly);
    }
    else
    {
        IfFailGo( CLDB_E_RECORD_NOTFOUND );
    }
ErrExit:
    STOP_MD_PERF(GetAssemblyFromScope);
    return hr;
}   // RegMeta::GetAssemblyFromScope

//*******************************************************************************
// Find the ExportedType given the name.
//*******************************************************************************
STDAPI RegMeta::FindExportedTypeByName( // S_OK or error
    LPCWSTR     szName,                 // [IN] Name of the ExportedType.
    mdExportedType   tkEnclosingType,   // [IN] Enclosing ExportedType.
    mdExportedType   *ptkExportedType)  // [OUT] Put the ExportedType token here.
{
    HRESULT     hr = S_OK;              // A result.
    LOG((LOGMD, "MD RegMeta::FindExportedTypeByName(%S, %#08x, %#08x)\n",
        MDSTR(szName), tkEnclosingType, ptkExportedType));
    START_MD_PERF();
    LOCKREAD();

    // Validate name for prefix.
    if (!szName)
        IfFailGo(E_INVALIDARG);

    _ASSERTE(szName && ptkExportedType);
    _ASSERTE(ns::IsValidName(szName));

    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    LPSTR       szNameUTF8 = UTF8STR(szName);
    LPCSTR      szTypeName;
    LPCSTR      szTypeNamespace;

    ns::SplitInline(szNameUTF8, szTypeNamespace, szTypeName);

    IfFailGo(ImportHelper::FindExportedType(pMiniMd,
                                       szTypeNamespace,
                                       szTypeName,
                                       tkEnclosingType,
                                       ptkExportedType));
ErrExit:
    STOP_MD_PERF(FindExportedTypeByName);
    return hr;
}   // RegMeta::FindExportedTypeByName

//*******************************************************************************
// Find the ManifestResource given the name.
//*******************************************************************************
STDAPI RegMeta::FindManifestResourceByName( // S_OK or error
    LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
    mdManifestResource *ptkManifestResource)    // [OUT] Put the ManifestResource token here.
{
    HRESULT     hr = S_OK;
    LOG((LOGMD, "MD RegMeta::FindManifestResourceByName(%S, %#08x)\n",
        MDSTR(szName), ptkManifestResource));
    START_MD_PERF();
    LOCKREAD();

    // Validate name for prefix.
    if (!szName)
        IfFailGo(E_INVALIDARG);

    _ASSERTE(szName && ptkManifestResource);

    ManifestResourceRec *pRecord;
    ULONG       cRecords;               // Count of records.
    LPCUTF8     szNameTmp = 0;          // Name obtained from the database.
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    LPCUTF8     szUTF8Name;             // UTF8 version of the name passed in.
    ULONG       i;

    *ptkManifestResource = mdManifestResourceNil;
    cRecords = pMiniMd->getCountManifestResources();
    szUTF8Name = UTF8STR(szName);

    // Search for the TypeRef.
    for (i = 1; i <= cRecords; i++)
    {
        pRecord = pMiniMd->getManifestResource(i);
        szNameTmp = pMiniMd->getNameOfManifestResource(pRecord);
        if (! strcmp(szUTF8Name, szNameTmp))
        {
            *ptkManifestResource = TokenFromRid(i, mdtManifestResource);
            goto ErrExit;
        }
    }
    IfFailGo( CLDB_E_RECORD_NOTFOUND );
ErrExit:
    
    STOP_MD_PERF(FindManifestResourceByName);
    return hr;
}   // RegMeta::FindManifestResourceByName


//*******************************************************************************
// Used to find assemblies either in Fusion cache or on disk at build time.
//*******************************************************************************
STDAPI RegMeta::FindAssembliesByName( // S_OK or error
        LPCWSTR  szAppBase,           // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,        // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,      // [IN] required - this is the assembly you are requesting
        IUnknown *ppIUnk[],           // [OUT] put IMetaDataAssemblyImport pointers here
        ULONG    cMax,                // [IN] The max number to put
        ULONG    *pcAssemblies)       // [OUT] The number of assemblies returned.
{
    LOG((LOGMD, "RegMeta::FindAssembliesByName(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
        szAppBase, szPrivateBin, szAssemblyName, ppIUnk, cMax, pcAssemblies));
    START_MD_PERF();
    
    // No need to lock this function. It is going through fushion to find the matching Assemblies by name

    HRESULT hr = GetAssembliesByName(szAppBase, szPrivateBin,
                                     szAssemblyName, ppIUnk, cMax, pcAssemblies);

ErrExit:
    STOP_MD_PERF(FindAssembliesByName);
    return hr;
} // RegMeta::FindAssembliesByName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\classfactory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ClassFactory.cpp
//
// Dll* routines for entry points, and support for COM framework.  The class
// factory and other routines live in this module.
//
//*****************************************************************************
#include "stdafx.h"
#include "ClassFactory.h"
#include "Disp.h"
#include "RegMeta.h"
#include "mscoree.h"
#include "CorHost.h"
#include "sxstypes.h"
#include <__file__.ver>

//********** Locals. **********************************************************
STDAPI MetaDataDllUnregisterServer(void);
HINSTANCE GetModuleInst();
static long _GetMasterVersion();
static void _SetMasterVersion(long iVersion);
static void _RestoreOldDispenser();

static void _SetSBSVersion(REFCLSID id, WCHAR *lpwszVersion);
static void _RemoveSBSVersion(const COCLASS_REGISTER* id, WCHAR *lpwszVersion);

#define MASTER_VERSION          L"MasterVersion"
#define THIS_VERSION 2


//********** Globals. *********************************************************
static const LPCWSTR g_szCoclassDesc    = L"Microsoft Common Language Runtime Meta Data";
static const LPCWSTR g_szProgIDPrefix   = L"CLRMetaData";
static const LPCWSTR g_szThreadingModel = L"Both";
const int       g_iVersion = THIS_VERSION;// Version of coclasses.
HINSTANCE       g_hInst;                // Instance handle to this piece of code.

// This map contains the list of coclasses which are exported from this module.
// NOTE:  CLSID_CorMetaDataDispenser must be the first entry in this table!
const COCLASS_REGISTER g_CoClasses[] =
{
//  pClsid                              szProgID                        pfnCreateObject
    &CLSID_CorMetaDataDispenser,        L"CorMetaDataDispenser",        Disp::CreateObject,
    &CLSID_CorMetaDataDispenserRuntime, L"CorMetaDataDispenserRuntime", Disp::CreateObject,     
//    &CLSID_CorMetaDataRuntime,          L"CorMetaDataRuntime",          RegMeta::CreateObject,      
    &CLSID_CorRuntimeHost,              L"CorRuntimeHost",              CorHost::CreateObject,
    NULL,                               NULL,                           NULL
};


//********** Code. ************************************************************


//*****************************************************************************
// Register the class factories for the main debug objects in the API.
//*****************************************************************************
STDAPI MetaDataDllRegisterServerEx(HINSTANCE hMod)
{
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    WCHAR       rcModule[_MAX_PATH];    // This server's module name.
    int         bRegisterMaster=true;   // true to register master dispenser.
    int         iVersion;               // Version installed for dispenser.
    HRESULT     hr = S_OK;

    // Get the version of the runtime
    WCHAR       rcVersion[_MAX_PATH];
    DWORD       lgth;
    IfFailGo(GetCORSystemDirectory(rcVersion, NumItems(rcVersion), &lgth));

    // Get the filename for this module.
    VERIFY(WszGetModuleFileName(hMod, rcModule, NumItems(rcModule)));

    // For each item in the coclass list, register it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        // Don't process master by default.
        if (*pCoClass->pClsid == CLSID_CorMetaDataDispenser)
            continue;
        
        // Register the class with default values.
        if (FAILED(hr = REGUTIL::RegisterCOMClass(
                *pCoClass->pClsid, 
                g_szCoclassDesc, 
                g_szProgIDPrefix,
                g_iVersion, 
                pCoClass->szProgID, 
                g_szThreadingModel, 
                rcModule,
                hMod,
                NULL,
                rcVersion,
                false,
                false)))
            goto ErrExit;

        _SetSBSVersion(*pCoClass->pClsid, VER_SBSFILEVERSION_WSTR);
            
    }

    // If there is alreayd a master dispenser installed, and it is older than
    // this version, then we overwrite it.  For version 2, this means we overwrite
    // ourselves and version 1.
    iVersion = _GetMasterVersion();
    if (iVersion != 0 && iVersion > THIS_VERSION)
        bRegisterMaster = false;

    // If we decide we need to, register the this dispenser as the master
    // for this machine.  Never overwrite a newer dispenser; it needs to 
    // understand n-1.
    if (bRegisterMaster)
    {
        pCoClass = &g_CoClasses[0];
        hr = REGUTIL::RegisterCOMClass(
                *pCoClass->pClsid, 
                g_szCoclassDesc, 
                g_szProgIDPrefix,
                g_iVersion, 
                pCoClass->szProgID, 
                g_szThreadingModel, 
                rcModule,
                hMod,
                NULL,
                rcVersion,
                false,
                false);
        _SetMasterVersion(THIS_VERSION);
        _SetSBSVersion(*pCoClass->pClsid, VER_SBSFILEVERSION_WSTR);
    }


ErrExit:
    if (FAILED(hr))
        MetaDataDllUnregisterServer();
    return (hr);
}

STDAPI MetaDataDllRegisterServer()
{
    return MetaDataDllRegisterServerEx(GetModuleInst());
}

//*****************************************************************************
// Remove registration data from the registry.
//*****************************************************************************
STDAPI MetaDataDllUnregisterServer(void)
{
    const COCLASS_REGISTER *pCoClass;   // Loop control.

    // For each item in the coclass list, unregister it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        // Don't process master by default.
        if (*pCoClass->pClsid == CLSID_CorMetaDataDispenser)
            continue;


        _RemoveSBSVersion(pCoClass, VER_SBSFILEVERSION_WSTR);
    }

    // If we are the master dispenser on this machine, then take us out.
    if (_GetMasterVersion() == THIS_VERSION)
    {
        pCoClass = &g_CoClasses[0];

        _RemoveSBSVersion(pCoClass, VER_SBSFILEVERSION_WSTR);
        
        // If there is an old dispenser on the machine, re-register it as the
        // master so that we don't break the machine for uninstall.

        // This call shouldn't be needed anymore, and the code for _RestoreOldDispenser has
        // been commented out
        
        // _RestoreOldDispenser();
    }
    return (S_OK);
}


//*****************************************************************************
// Called by COM to get a class factory for a given CLSID.  If it is one we
// support, instantiate a class factory object and prepare for create instance.
//*****************************************************************************
STDAPI MetaDataDllGetClassObject(       // Return code.
    REFCLSID    rclsid,                 // The class to desired.
    REFIID      riid,                   // Interface wanted on class factory.
    LPVOID FAR  *ppv)                   // Return interface pointer here.
{
    MDClassFactory *pClassFactory;      // To create class factory object.
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    HRESULT     hr = CLASS_E_CLASSNOTAVAILABLE;

    // Scan for the right one.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        if (*pCoClass->pClsid == rclsid)
        {
            // Allocate the new factory object.
            pClassFactory = new MDClassFactory(pCoClass);
            if (!pClassFactory)
                return (E_OUTOFMEMORY);

            // Pick the v-table based on the caller's request.
            hr = pClassFactory->QueryInterface(riid, ppv);

            // Always release the local reference, if QI failed it will be
            // the only one and the object gets freed.
            pClassFactory->Release();
            break;
        }
    }
    return (hr);
}



//*****************************************************************************
//
//********** Class factory code.
//
//*****************************************************************************


//*****************************************************************************
// QueryInterface is called to pick a v-table on the co-class.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE MDClassFactory::QueryInterface( 
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;

    // Avoid confusion.
    *ppvObject = NULL;

    // Pick the right v-table based on the IID passed in.
    if (riid == IID_IUnknown)
        *ppvObject = (IUnknown *) this;
    else if (riid == IID_IClassFactory)
        *ppvObject = (IClassFactory *) this;

    // If successful, add a reference for out pointer and return.
    if (*ppvObject)
    {
        hr = S_OK;
        AddRef();
    }
    else
        hr = E_NOINTERFACE;
    return (hr);
}


//*****************************************************************************
// CreateInstance is called to create a new instance of the coclass for which
// this class was created in the first place.  The returned pointer is the
// v-table matching the IID if there.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE MDClassFactory::CreateInstance( 
    IUnknown    *pUnkOuter,
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;

    // Avoid confusion.
    *ppvObject = NULL;
    _ASSERTE(m_pCoClass);

    // Aggregation is not supported by these objects.
    if (pUnkOuter)
        return (CLASS_E_NOAGGREGATION);

    // Ask the object to create an instance of itself, and check the iid.
    hr = (*m_pCoClass->pfnCreateObject)(riid, ppvObject);
    return (hr);
}


HRESULT STDMETHODCALLTYPE MDClassFactory::LockServer( 
    BOOL        fLock)
{
    // @FUTURE: Should we return E_NOTIMPL instead of S_OK?
    return (S_OK);
}




//*****************************************************************************
// Look for the master dispenser clsid, find the version of this that is
// installed.
//*****************************************************************************
long _GetMasterVersion()                // Version number installed, 0 if not.
{
    WCHAR       rcKey[512];             // Path to key.
    WCHAR       rcID[64];               // {clsid}

    // Format the guid name path.
    GuidToLPWSTR(CLSID_CorMetaDataDispenser, rcID, NumItems(rcID));
    _tcscpy(rcKey, L"CLSID\\");
    _tcscat(rcKey, rcID);
    return (REGUTIL::GetLong(MASTER_VERSION, 0, rcKey, HKEY_CLASSES_ROOT));
}


//*****************************************************************************
// Update the version number for subsequent clients.
//*****************************************************************************
void _SetMasterVersion(
    long        iVersion)               // Version number to set.
{
    WCHAR       rcKey[512];             // Path to key.
    WCHAR       rcID[64];               // {clsid}

    // Format the guid name path.
    GuidToLPWSTR(CLSID_CorMetaDataDispenser, rcID, NumItems(rcID));
    _tcscpy(rcKey, L"CLSID\\");
    _tcscat(rcKey, rcID);
    REGUTIL::SetLong(MASTER_VERSION, iVersion, rcKey, HKEY_CLASSES_ROOT);
}

//*****************************************************************************
// Creates the string used for a SBS version registry key
//
// Returns true is success, false otherwise
//*****************************************************************************
bool _CreateSBSVersionRegKey(
    REFCLSID id,                        // GUID of the class to register
    WCHAR *lpwszVersion,        // Version Number to set
    WCHAR *lpwszOutBuffer ,    // [out] Buffer to store the registry key
    DWORD   dwNumCharacters) // number of characters in the buffer including null
{
    WCHAR rcID[64];       // {clsid}

    // Format the guid name path.
    if (0 == GuidToLPWSTR(id, rcID, NumItems(rcID)))
        return false;

    // Make sure out buffer is big enough
    DWORD nVersionLen = (lpwszVersion == NULL)?0:(wcslen(lpwszVersion) + wcslen(L"\\"));

    // +1 for the null character
    if ((wcslen(L"CLSID\\") + wcslen(rcID) + wcslen(L"\\InProcServer32") + nVersionLen + 1) > dwNumCharacters)
    {
        _ASSERTE(!"Buffer isn't big enough");
        return false;
    }

    wcscpy(lpwszOutBuffer, L"CLSID\\");
    wcscat(lpwszOutBuffer, rcID);
    wcscat(lpwszOutBuffer, L"\\InProcServer32");
    if (lpwszVersion != NULL)
    {
        wcscat(lpwszOutBuffer, L"\\");
        wcscat(lpwszOutBuffer, lpwszVersion);
    }    
    return true;
}// _CreateSBSVersionRegKey

//*****************************************************************************
// Adds this runtime's version number to the list of SBS runtime versions.
//*****************************************************************************
void _SetSBSVersion(
    REFCLSID id,                      // GUID of the class to register
    WCHAR *lpwszVersion)     // Version Number to set
{
    WCHAR rcKey[512];       // Path to key

    // Ignore failures 
    
    if (_CreateSBSVersionRegKey(id, lpwszVersion, rcKey, NumItems(rcKey)))
        REGUTIL::SetRegValue(rcKey, SBSVERSIONVALUE, L"");
} // _SetSBSVersion

//*****************************************************************************
// Removes this runtime's version number from the list of SBS runtime versions.
//
// If this is the last version number in the registry, then we completely remove the key
//*****************************************************************************
void _RemoveSBSVersion(
    const COCLASS_REGISTER* id,                      // GUID of the class to unregister
    WCHAR *lpwszVersion)                          // Version Number to set
{
    WCHAR rcKey[512];       // Path to key

     // Ignore failures 
    if (_CreateSBSVersionRegKey(*id->pClsid, lpwszVersion, rcKey, NumItems(rcKey)))
        REGUTIL::DeleteKey(rcKey, NULL);


    // if this was the last sbs version string, then remove the entire key
    HKEY hKeyCLSID;

    if (_CreateSBSVersionRegKey(*id->pClsid, NULL, rcKey, NumItems(rcKey)))
    {
        if (ERROR_SUCCESS == WszRegOpenKeyEx( HKEY_CLASSES_ROOT,
                                                                             rcKey,
                                                                              0, 
                                                                             KEY_ENUMERATE_SUB_KEYS | KEY_READ,
                                                                             &hKeyCLSID))
        {
            DWORD dwNumSubKeys = 0;
            
            if (ERROR_SUCCESS == WszRegQueryInfoKey(hKeyCLSID, NULL, NULL, NULL,
                                                                                     &dwNumSubKeys, NULL, NULL, NULL, 
                                                                                     NULL, NULL, NULL, NULL))
            {
                // If we have 0 subkeys under InProcServer32, then wipe out the entire object
                if (dwNumSubKeys == 0)
                {
                    // Unregister the class.
                    REGUTIL::UnregisterCOMClass(*id->pClsid, 
                                                                  g_szProgIDPrefix,
                                                                  g_iVersion, 
                                                                  id->szProgID, 
                                                                  false);
                }
            }

            VERIFY(ERROR_SUCCESS == RegCloseKey(hKeyCLSID));
        }
    }

}// _RemoveSBSVersion



//*****************************************************************************
// Now for the tricky part: if there is a version 1 dispenser on the
// machine, we need to put it back as the master.  This is to support
// (a) install v1, (b) install v2, (c) uninstall v2.  If we don't do
// this then the apps that worked after (a) wouldn't work after (c).
//*****************************************************************************
void _RestoreOldDispenser()
{
#if 0
// This code is now disabled because we are no longer supporting the com+ 1.0
// through the dispenser code after VC 6.1 was canceled.  I'm leaving it here
// as a comment so we can add it as required for v3.  It was tested and should
// be ready to dust off when needed.
    WCHAR       rcPath[_MAX_PATH];      // Path to old dispenser.
    WCHAR       rcKey[512];             // Path to key.
    WCHAR       rcID[64];               // {clsid}
    int         bFound;                 // true if old id is there.

    // Look at the version 1 dispenser.
    GuidToLPWSTR(CLSID_CorMetaDataDispenserReg, rcID, NumItems(rcID));
    _tcscpy(rcKey, L"CLSID\\");
    _tcscat(rcKey, rcID);
    _tcscat(rcKey, L"\\InprocServer32");

    *rcPath = 0;
    REGUTIL::GetString(L"", L"", rcPath, sizeof(rcPath), rcKey, &bFound, HKEY_CLASSES_ROOT);
    if (*rcPath && bFound && WszGetFileAttributes(rcPath) != (DWORD) -1)
    {
        typedef HRESULT (__stdcall *PFN_REGSERVER)();
        HINSTANCE hLib;
        PFN_REGSERVER pfn;

        // Turn on quiet failures, don't get in user's face.
        ULONG OldMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

        // Load the version 1 library based on path.
        hLib = WszLoadLibrary(rcPath);
        if (hLib != NULL)
        {
            // Get the register entry point and call it.
            pfn = (PFN_REGSERVER) GetProcAddress(hLib, "DllRegisterServer");
            if (pfn)
                (*pfn)();
            FreeLibrary(hLib);
        }
        
        // Restore error mode.
        SetErrorMode(OldMode);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\classfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ClassFactory.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************
#ifndef __ClassFactory__h__
#define __ClassFactory__h__

#include "Disp.h"


// This typedef is for a function which will create a new instance of an object.
typedef HRESULT (* PFN_CREATE_OBJ)(REFIID riid, void **ppvObject);

//*****************************************************************************
// This structure is used to declare a global list of coclasses.  The class
// factory object is created with a pointer to the correct one of these, so
// that when create instance is called, it can be created.
//*****************************************************************************
struct COCLASS_REGISTER
{
	const GUID *pClsid;					// Class ID of the coclass.
	LPCWSTR		szProgID;				// Prog ID of the class.
	PFN_CREATE_OBJ pfnCreateObject;		// Creation function for an instance.
};



//*****************************************************************************
// One class factory object satifies all of our clsid's, to reduce overall 
// code bloat.
//*****************************************************************************
class MDClassFactory :
	public IClassFactory
{
	MDClassFactory() { }						// Can't use without data.
	
public:
	MDClassFactory(const COCLASS_REGISTER *pCoClass)
		: m_cRef(1), m_pCoClass(pCoClass)
	{ }

	
	//
	// IUnknown methods.
	//

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        REFIID		riid,
        void		**ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return (InterlockedIncrement((long *) &m_cRef));
	}
    
    virtual ULONG STDMETHODCALLTYPE Release()
	{
		long		cRef = InterlockedDecrement((long *) &m_cRef);
		if (cRef <= 0)
			delete this;
		return (cRef);
	}


	//
	// IClassFactory methods.
	//

    virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
        IUnknown	*pUnkOuter,
        REFIID		riid,
        void		**ppvObject);
    
    virtual HRESULT STDMETHODCALLTYPE LockServer( 
        BOOL		fLock);


private:
	DWORD		m_cRef;						// Reference count.
	const COCLASS_REGISTER *m_pCoClass;		// The class we belong to.
};



#endif // __ClassFactory__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\soapserializer\soapobjectwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: ObjectWriter
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Serializes an object graph into XML in SOAP format
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Soap 
{    
    using System;
    using System.IO;
    using System.Reflection;
    using System.Collections;
    using System.Text;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;    
    using System.Runtime.Remoting.Metadata;
    using System.Runtime.Remoting.Metadata.W3cXsd2001;
    using System.Runtime.Serialization;
    using System.Security.Permissions;
    using System.Diagnostics;

    internal sealed  class ObjectWriter
    {
        private Queue m_objectQueue;
        private ObjectIDGenerator m_idGenerator;
        private Stream m_stream;
        private ISurrogateSelector m_surrogates;
        private StreamingContext m_context;
        private SoapWriter serWriter;

        //Keeps track of types written
        // Null members are only written the first time for XML.
        private System.Collections.Hashtable m_serializedTypeTable;

        private long topId;
        private String topName = null;
        private Header[] headers;

        private InternalFE formatterEnums;

        private SerObjectInfoInit serObjectInfoInit = null;

        private IFormatterConverter m_formatterConverter;

        // Default header name space
        private String headerNamespace = "http://schemas.microsoft.com/clr/soap";

        private bool bRemoting = false;

        internal static SecurityPermission serializationPermission = new SecurityPermission(SecurityPermissionFlag.SerializationFormatter);

        PrimitiveArray primitiveArray = null;

        // XMLObjectWriter Constructor
        internal ObjectWriter(Stream stream, ISurrogateSelector selector, StreamingContext context,InternalFE formatterEnums)
        {
            if (stream==null)
            {
                throw new ArgumentNullException("stream", SoapUtil.GetResourceString("ArgumentNull_Stream"));               
            }

            m_stream=stream;
            m_surrogates = selector;
            m_context = context;
            this.formatterEnums = formatterEnums;
            InternalST.InfoSoap(
                               formatterEnums.FEtypeFormat +" "+
                               ((Enum)formatterEnums.FEserializerTypeEnum));

            m_formatterConverter = new FormatterConverter();

        }

        // Commences the process of serializing the entire graph.
        // initialize the graph walker.
        internal void Serialize(Object graph, Header[] inHeaders, SoapWriter serWriter)
        {
            InternalST.Soap( this, "Serialize Entry 2 ",graph,((headers == null)?" no headers ": "headers"));

            serializationPermission.Demand();

            if (graph == null)
                throw new ArgumentNullException("graph",SoapUtil.GetResourceString("ArgumentNull_Graph"));

            if (serWriter == null)
                throw new ArgumentNullException("serWriter",String.Format(SoapUtil.GetResourceString("ArgumentNull_WithParamName"), "serWriter"));

            serObjectInfoInit = new SerObjectInfoInit();        
            this.serWriter = serWriter;
            this.headers = inHeaders;

            if (graph is IMethodMessage)
            {
                bRemoting = true;
                MethodBase methodBase = ((IMethodMessage)graph).MethodBase;
                if (methodBase != null)
                    serWriter.WriteXsdVersion(ProcessTypeAttributes(methodBase.ReflectedType));
                else
                    serWriter.WriteXsdVersion(XsdVersion.V2001);
            }
            else
                serWriter.WriteXsdVersion(XsdVersion.V2001);

            m_idGenerator = new ObjectIDGenerator();
            m_objectQueue = new Queue();

            if (graph is ISoapMessage)
            {
                // Fake method call is to be written
                bRemoting = true;
                ISoapMessage ismc = (ISoapMessage)graph;
                graph = new InternalSoapMessage(ismc.MethodName, ismc.XmlNameSpace, ismc.ParamNames, ismc.ParamValues, ismc.ParamTypes);
                headers = ismc.Headers;
            }


            InternalST.Soap( this, "Serialize New SerializedTypeTable");
            m_serializedTypeTable = new Hashtable();

            serWriter.WriteBegin();

            long headerId = 0;
            Object obj;
            long objectId;
            bool isNew;

            topId = m_idGenerator.GetId(graph, out isNew);

            if (headers != null)
                headerId = m_idGenerator.GetId(headers, out isNew);
            else
                headerId = -1;

            WriteSerializedStreamHeader(topId, headerId);

            InternalST.Soap( this, "Serialize Schedule 0");

            // Write out SerializedStream header
            if (!((headers == null) || (headers.Length == 0)))
            {
                ProcessHeaders(headerId);
            }

            m_objectQueue.Enqueue(graph);

            while ((obj = GetNext(out objectId))!=null)
            {
                InternalST.Soap( this, "Serialize GetNext ",obj);
                WriteObjectInfo objectInfo = null;

                // GetNext will return either an object or a WriteObjectInfo. 
                // A WriteObjectInfo is returned if this object was member of another object
                if (obj is WriteObjectInfo)
                {
                    InternalST.Soap( this, "Serialize GetNext recognizes WriteObjectInfo");
                    objectInfo = (WriteObjectInfo)obj;
                }
                else
                {
                    objectInfo = WriteObjectInfo.Serialize(obj, m_surrogates, m_context, serObjectInfoInit, m_formatterConverter, null);
                    objectInfo.assemId = GetAssemblyId(objectInfo);
                }

                objectInfo.objectId = objectId;
                NameInfo typeNameInfo = TypeToNameInfo(objectInfo);
                typeNameInfo.NIisTopLevelObject = true;
                if (bRemoting && obj  == graph)
                    typeNameInfo.NIisRemoteRecord = true;
                Write(objectInfo, typeNameInfo, typeNameInfo);
                PutNameInfo(typeNameInfo);
                objectInfo.ObjectEnd();
            }

            serWriter.WriteSerializationHeaderEnd();
            serWriter.WriteEnd();

            m_idGenerator = new ObjectIDGenerator();
            InternalST.Soap( this, "*************Serialize New SerializedTypeTable 2");
            m_serializedTypeTable = new System.Collections.Hashtable();

            InternalST.Soap( this, "Serialize Exit ");
        }

        private XsdVersion ProcessTypeAttributes(Type type)
        {
            // Check to see if the xsd and xsi schema types should be 1999 instead of 2000. This is a temporary fix for an interop problem
            SoapTypeAttribute att = InternalRemotingServices.GetCachedSoapAttribute(type) as SoapTypeAttribute;
            XsdVersion xsdVersion = XsdVersion.V2001;
            if (att != null)
            {
                SoapOption soapOption = att.SoapOptions;
                if ((soapOption &= SoapOption.Option1) == SoapOption.Option1)
                    xsdVersion = XsdVersion.V1999;
                else if ((soapOption &= SoapOption.Option1) == SoapOption.Option2)
                    xsdVersion = XsdVersion.V2000;
            }
            return xsdVersion;
        }

        private void ProcessHeaders(long headerId)
        {
            long objectId;
            Object obj;

            // XML Serializer

            serWriter.WriteHeader((int)headerId, headers.Length);

            for (int i=0; i<headers.Length; i++)
            {
                Type headerValueType = null;
                if (headers[i].Value != null)
                    headerValueType = GetType(headers[i].Value);
                if ((headerValueType != null) && (headerValueType == Converter.typeofString))
                {
                    NameInfo nameInfo = GetNameInfo();
                    nameInfo.NInameSpaceEnum = InternalNameSpaceE.UserNameSpace;
                    nameInfo.NIname = headers[i].Name;
                    nameInfo.NIisMustUnderstand = headers[i].MustUnderstand;
                    nameInfo.NIobjectId = -1;

                    // Header will need to add a name space field which will if it doesn't the following
                    // is the default name space
                    HeaderNamespace(headers[i], nameInfo);

                    serWriter.WriteHeaderString(nameInfo, headers[i].Value.ToString());

                    PutNameInfo(nameInfo);
                }
                else if (headers[i].Name.Equals("__MethodSignature"))
                {
                    InternalST.Soap( this, "Serialize Write Header __MethodSignature ");                        
                    // Process message signature
                    if (!(headers[i].Value is Type[]))
                        throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_MethodSignature"), headerValueType));
                    // Replace type array with an array of TypeToNameInfo's
                    Type[] types = (Type[])headers[i].Value;
                    NameInfo[] typeToNameInfos = new NameInfo[types.Length];
                    WriteObjectInfo[] objectInfos = new WriteObjectInfo[types.Length];
                    for (int j=0; j< types.Length; j++)
                    {
                        objectInfos[j] = WriteObjectInfo.Serialize(types[j], m_surrogates, m_context, serObjectInfoInit, m_formatterConverter, null);
                        objectInfos[j].objectId = -1;
                        objectInfos[j].assemId = GetAssemblyId(objectInfos[j]);                             
                        typeToNameInfos[j] = TypeToNameInfo(objectInfos[j]);
                    }

                    // Create MemberNameInfo 
                    NameInfo memberNameInfo = MemberToNameInfo(headers[i].Name);
                    memberNameInfo.NIisMustUnderstand = headers[i].MustUnderstand;
                    memberNameInfo.NItransmitTypeOnMember = true;
                    memberNameInfo.NIisNestedObject = true;
                    memberNameInfo.NIisHeader = true;
                    HeaderNamespace(headers[i], memberNameInfo);

                    serWriter.WriteHeaderMethodSignature(memberNameInfo, typeToNameInfos);

                    for (int j=0; j<types.Length; j++)
                    {
                        PutNameInfo(typeToNameInfos[j]);
                        objectInfos[j].ObjectEnd();
                    }
                    PutNameInfo(memberNameInfo);
                }
                else
                {
                    InternalPrimitiveTypeE code = InternalPrimitiveTypeE.Invalid;
                    long valueId;
                    if (headerValueType != null)
                        code = Converter.ToCode(headerValueType);

                    if ((headerValueType != null) && (code == InternalPrimitiveTypeE.Invalid))
                    {
                        // Object reference
                        InternalST.Soap( this, "Serialize Schedule 2");
                        valueId = Schedule(headers[i].Value, headerValueType);
                        if (valueId == -1)
                        {
                            WriteObjectInfo objectInfo = WriteObjectInfo.Serialize(headers[i].Value, m_surrogates, m_context, serObjectInfoInit, m_formatterConverter, null);
                            objectInfo.objectId = -1;
                            objectInfo.assemId = GetAssemblyId(objectInfo);                             
                            NameInfo typeNameInfo = TypeToNameInfo(objectInfo);
                            NameInfo memberNameInfo = MemberToNameInfo(headers[i].Name);
                            memberNameInfo.NIisMustUnderstand = headers[i].MustUnderstand;
                            memberNameInfo.NItransmitTypeOnMember = true;
                            memberNameInfo.NIisNestedObject = true;
                            memberNameInfo.NIisHeader = true;

                            HeaderNamespace(headers[i], memberNameInfo);

                            Write(objectInfo, memberNameInfo, typeNameInfo);
                            PutNameInfo(typeNameInfo);
                            PutNameInfo(memberNameInfo);
                            objectInfo.ObjectEnd();
                        }
                        else
                        {
                            InternalST.Soap( this, "Serialize Write Header Object Reference ");
                            NameInfo refNameInfo = MemberToNameInfo(headers[i].Name);
                            refNameInfo.NIisMustUnderstand = headers[i].MustUnderstand;
                            refNameInfo.NIobjectId = valueId;
                            refNameInfo.NItransmitTypeOnMember = true;
                            refNameInfo.NIisNestedObject = true;                                                                                    
                            HeaderNamespace(headers[i], refNameInfo);
                            serWriter.WriteHeaderObjectRef(refNameInfo);
                            PutNameInfo(refNameInfo);
                        }
                    }
                    else
                    {
                        // Primitive type or null					
                        InternalST.Soap( this, "Serialize Write Header primitive type ");
                        NameInfo nameInfo = GetNameInfo();
                        nameInfo.NInameSpaceEnum = InternalNameSpaceE.UserNameSpace;
                        nameInfo.NIname = headers[i].Name;
                        nameInfo.NIisMustUnderstand = headers[i].MustUnderstand;
                        nameInfo.NIprimitiveTypeEnum = code;

                        // Header will need to add a name space field which will if it doesn't the following
                        // is the default name space
                        HeaderNamespace(headers[i], nameInfo);

                        NameInfo typeNameInfo = null;
                        if (headerValueType != null)
                        {
                            typeNameInfo = TypeToNameInfo(headerValueType);
                            typeNameInfo.NItransmitTypeOnMember = true;
                        }
                        serWriter.WriteHeaderEntry(nameInfo, typeNameInfo, headers[i].Value);
                        PutNameInfo(nameInfo);
                        if (headerValueType != null)
                            PutNameInfo(typeNameInfo);
                    }
                }
            }

            serWriter.WriteHeaderArrayEnd();

            // Serialize headers ahead of top graph
            while ((obj = GetNext(out objectId))!=null)
            {
                WriteObjectInfo objectInfo = null;

                // GetNext will return either an object or a WriteObjectInfo. 
                // A WriteObjectInfo is returned if this object was member of another object
                if (obj is WriteObjectInfo)
                {
                    InternalST.Soap( this, "Serialize GetNext recognizes WriteObjectInfo");
                    objectInfo = (WriteObjectInfo)obj;
                }
                else
                {
                    objectInfo = WriteObjectInfo.Serialize(obj, m_surrogates, m_context, serObjectInfoInit, m_formatterConverter, null);
                    objectInfo.assemId = GetAssemblyId(objectInfo);
                }


                objectInfo.objectId = objectId;
                NameInfo typeNameInfo = TypeToNameInfo(objectInfo);
                Write(objectInfo, typeNameInfo, typeNameInfo);
                PutNameInfo(typeNameInfo);
                objectInfo.ObjectEnd();
            }

            serWriter.WriteHeaderSectionEnd();
        }

        private void HeaderNamespace(Header header, NameInfo nameInfo)
        {
            if (header.HeaderNamespace == null)
                nameInfo.NInamespace = headerNamespace;
            else
                nameInfo.NInamespace = header.HeaderNamespace;
            bool isNew = false;
            nameInfo.NIheaderPrefix = "h"+InternalGetId(nameInfo.NInamespace, Converter.typeofString, out isNew);
        }


        // Writes a given object to the stream.
        private void Write(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo)
        {       
            InternalST.Soap( this, "Write 1 Entry objectInfo ",objectInfo,", memberNameInfo ",memberNameInfo,", typeNameInfo ",typeNameInfo);
            memberNameInfo.Dump("Write memberNameInfo");
            typeNameInfo.Dump("Write typeNameInfo");
            Object obj = objectInfo.obj;
            if (obj==null)
                throw new ArgumentNullException("objectInfo.obj", String.Format(SoapUtil.GetResourceString("Serialization_ArgumentNull_Obj"), objectInfo.objectType));

            Type objType = objectInfo.objectType;
            long objectId = objectInfo.objectId;


            InternalST.Soap( this, "Write 1 ",obj," ObjectId ",objectId);

            if (objType == Converter.typeofString)
            {
                // Top level String
                memberNameInfo.NIobjectId = objectId;
                serWriter.WriteObjectString(memberNameInfo, obj.ToString());
            }
            else if (objType == Converter.typeofTimeSpan)
            {
                // Top level TimeSpan
                serWriter.WriteTopPrimitive(memberNameInfo, obj);
            }
            else
            {

                if (objType.IsArray)
                {
                    WriteArray(objectInfo, null, null); 
                }
                else
                {
                    String[] memberNames;
                    Type[] memberTypes;
                    Object[] memberData;
                    SoapAttributeInfo[] memberAttributeInfo;

                    objectInfo.GetMemberInfo(out memberNames, out memberTypes, out memberData, out memberAttributeInfo);

                    // Only Binary needs to transmit types for ISerializable because the binary formatter transmits the types in URT format.
                    // Soap transmits all types as strings, so it is up to the ISerializable object to convert the string back to its URT type
                    if (CheckTypeFormat(formatterEnums.FEtypeFormat, FormatterTypeStyle.TypesAlways))
                    {
                        InternalST.Soap( this, "Write 1 TransmitOnObject ");
                        memberNameInfo.NItransmitTypeOnObject = true;
                        memberNameInfo.NIisParentTypeOnObject = true;
                        typeNameInfo.NItransmitTypeOnObject = true;
                        typeNameInfo.NIisParentTypeOnObject = true;                                             
                    }

                    WriteObjectInfo[] memberObjectInfos = new WriteObjectInfo[memberNames.Length];

                    // Get assembly information
                    // Binary Serializer, assembly names need to be
                    // written before objects are referenced.
                    // GetAssemId here will write out the
                    // assemblyStrings at the right Binary
                    // Serialization object boundary.
                    for (int i=0; i<memberTypes.Length; i++)
                    {
                        Type type = null;
                        if (memberData[i] != null)                        
                            type = GetType(memberData[i]);
                        else
                            type = typeof(Object);

                        InternalPrimitiveTypeE code = Converter.ToCode(type);
                        if ((code == InternalPrimitiveTypeE.Invalid && type != Converter.typeofString) ||
                            ((objectInfo.cache.memberAttributeInfos != null) &&
                             (objectInfo.cache.memberAttributeInfos[i] != null) &&
                             ((objectInfo.cache.memberAttributeInfos[i].IsXmlAttribute()) ||
                              (objectInfo.cache.memberAttributeInfos[i].IsXmlElement()))))
                        {
                            if (memberData[i] != null)
                            {
                                memberObjectInfos[i] =
                                WriteObjectInfo.Serialize
                                (
                                memberData[i],
                                m_surrogates,
                                m_context,
                                serObjectInfoInit,
                                m_formatterConverter,
                                (memberAttributeInfo == null)? null : memberAttributeInfo[i]
                                );                                    
                                memberObjectInfos[i].assemId = GetAssemblyId(memberObjectInfos[i]);
                            }
                            else
                            {
                                memberObjectInfos[i] =
                                WriteObjectInfo.Serialize
                                (
                                memberTypes[i],
                                m_surrogates,
                                m_context,
                                serObjectInfoInit,
                                m_formatterConverter,
                                ((memberAttributeInfo == null) ? null : memberAttributeInfo[i])
                                );
                                memberObjectInfos[i].assemId = GetAssemblyId(memberObjectInfos[i]);
                            }
                        }
                    }

                    Write(objectInfo, memberNameInfo, typeNameInfo, memberNames, memberTypes, memberData, memberObjectInfos);
                }

                InternalST.Soap( this, "Write 1 ",obj," type ",GetType(obj));

                // After first time null members do not have to be written		
                if (!(m_serializedTypeTable.ContainsKey(objType)))
                {
                    InternalST.Soap( this, "Serialize SerializedTypeTable Add ",objType," obj ",obj);           
                    m_serializedTypeTable.Add(objType, objType);
                }
            }

            InternalST.Soap( this, "Write 1 Exit ",obj);        
        }

        // Writes a given object to the stream.
        private void Write(WriteObjectInfo objectInfo,         
                           NameInfo memberNameInfo,          
                           NameInfo typeNameInfo,            
                           String[] memberNames,             
                           Type[] memberTypes,               
                           Object[] memberData,              
                           WriteObjectInfo[] memberObjectInfos)
        {
            InternalST.Soap( this, "Write 2 Entry obj ",objectInfo.obj,". objectId ",objectInfo.objectId,", objType ",typeNameInfo.NIname,", memberName ",memberNameInfo.NIname,", memberType ",typeNameInfo.NIname,", isMustUnderstand ",memberNameInfo.NIisMustUnderstand);

            int numItems = memberNames.Length;
            NameInfo topNameInfo = null;

            // Process members which will be written out as Soap attributes first
            if (objectInfo.cache.memberAttributeInfos != null)
            {
                InternalST.Soap( this, "Write Attribute Members");
                for (int i=0; i<objectInfo.cache.memberAttributeInfos.Length; i++)
                {
                    InternalST.Soap( this, "Write Attribute Members name ", memberNames[i]);                    
                    if ((objectInfo.cache.memberAttributeInfos[i] != null) &&
                        (objectInfo.cache.memberAttributeInfos[i].IsXmlAttribute()))
                        WriteMemberSetup(objectInfo, memberNameInfo, typeNameInfo, memberNames[i], memberTypes[i], memberData[i], memberObjectInfos[i], true);
                }
            }


            if (memberNameInfo != null)
            {
                InternalST.Soap( this, "Write 2 ObjectBegin, memberName ",memberNameInfo.NIname);
                memberNameInfo.NIobjectId = objectInfo.objectId;
                serWriter.WriteObject(memberNameInfo, typeNameInfo, numItems, memberNames, memberTypes, memberObjectInfos);
            }
            else if ((objectInfo.objectId == topId) && (topName != null))
            {
                InternalST.Soap( this, "Write 2 ObjectBegin, topId method name ",topName);
                topNameInfo = MemberToNameInfo(topName);
                topNameInfo.NIobjectId = objectInfo.objectId;
                serWriter.WriteObject(topNameInfo, typeNameInfo, numItems, memberNames, memberTypes, memberObjectInfos);
            }
            else
            {
                if (objectInfo.objectType != Converter.typeofString)
                {
                    InternalST.Soap( this, "Write 2 ObjectBegin, default ", typeNameInfo.NIname);
                    typeNameInfo.NIobjectId = objectInfo.objectId;
                    serWriter.WriteObject(typeNameInfo, null, numItems, memberNames, memberTypes, memberObjectInfos);
                }
            }

            if (memberNameInfo.NIisParentTypeOnObject)
            {
                memberNameInfo.NItransmitTypeOnObject = true;
                memberNameInfo.NIisParentTypeOnObject = false;
            }
            else
                memberNameInfo.NItransmitTypeOnObject = false;


            // Write members
            for (int i=0; i<numItems; i++)
            {
                if ((objectInfo.cache.memberAttributeInfos == null) ||
                    (objectInfo.cache.memberAttributeInfos[i] == null) ||
                    (!(objectInfo.cache.memberAttributeInfos[i].IsXmlAttribute())))
                    WriteMemberSetup(objectInfo, memberNameInfo, typeNameInfo, memberNames[i], memberTypes[i], memberData[i], memberObjectInfos[i], false);
            }

            if (memberNameInfo != null)
            {
                memberNameInfo.NIobjectId = objectInfo.objectId;
                serWriter.WriteObjectEnd(memberNameInfo, typeNameInfo);
            }
            else if ((objectInfo.objectId == topId) && (topName != null))
            {
                serWriter.WriteObjectEnd(topNameInfo, typeNameInfo);
                PutNameInfo(topNameInfo);
            }
            else
            {
                if (objectInfo.objectType != Converter.typeofString)
                {
                    String objectName = objectInfo.GetTypeFullName();
                    serWriter.WriteObjectEnd(typeNameInfo, typeNameInfo);                       
                }
            }

            InternalST.Soap( this, "Write 2 Exit");
        }

        private void WriteMemberSetup(WriteObjectInfo objectInfo,      
                                      NameInfo memberNameInfo,           
                                      NameInfo typeNameInfo,             
                                      String memberName,             
                                      Type memberType,               
                                      Object memberData,                 
                                      WriteObjectInfo memberObjectInfo,
                                      bool isAttribute
                                     )
        {
            NameInfo newMemberNameInfo = MemberToNameInfo(memberName); 
            // newMemberNameInfo contains the member type

            if (memberObjectInfo != null)
                newMemberNameInfo.NIassemId = memberObjectInfo.assemId;
            newMemberNameInfo.NItype = memberType;

            // newTypeNameInfo contains the data type
            NameInfo newTypeNameInfo = null;
            if (memberObjectInfo == null)
            {
                newTypeNameInfo = TypeToNameInfo(memberType);
            }
            else
            {
                newTypeNameInfo = TypeToNameInfo(memberObjectInfo);
            }

            newMemberNameInfo.NIisRemoteRecord = typeNameInfo.NIisRemoteRecord;

            newMemberNameInfo.NItransmitTypeOnObject = memberNameInfo.NItransmitTypeOnObject;
            newMemberNameInfo.NIisParentTypeOnObject = memberNameInfo.NIisParentTypeOnObject;               
            WriteMembers(newMemberNameInfo, newTypeNameInfo, memberData, objectInfo, typeNameInfo, memberObjectInfo, isAttribute);
            PutNameInfo(newMemberNameInfo);
            PutNameInfo(newTypeNameInfo);
        }


        // Writes the members of an object
        private void WriteMembers(NameInfo memberNameInfo,
                                  NameInfo memberTypeNameInfo,
                                  Object   memberData,
                                  WriteObjectInfo objectInfo,
                                  NameInfo typeNameInfo,
                                  WriteObjectInfo memberObjectInfo,
                                  bool isAttribute)
        {
            InternalST.Soap( this, "WriteMembers Entry memberType: ",memberTypeNameInfo.NIname," memberName: ",memberNameInfo.NIname," data: ",memberData," objectId: ",objectInfo.objectId, " Container object ",objectInfo.obj, " isAttribute ", isAttribute);
            Type memberType = memberNameInfo.NItype;

            // Types are transmitted for a member as follows:
            // The member is of type object
            // The member object of type is ISerializable and
            //		Soap -  the member is a non-primitive value type, or it is a primitive value type which needs types (TimeSpan, DateTime)
            //				TimeSpan and DateTime are transmitted as UInt64 to keep their precision.
            //      Binary - Types always transmitted.

            if ((memberType == Converter.typeofObject) ||
                (memberType.IsValueType && objectInfo.isSi &&
                 Converter.IsSiTransmitType(memberTypeNameInfo.NIprimitiveTypeEnum)))
            {
                memberTypeNameInfo.NItransmitTypeOnMember  = true;
                memberNameInfo.NItransmitTypeOnMember  = true;              
            }

            if (CheckTypeFormat(formatterEnums.FEtypeFormat, FormatterTypeStyle.TypesAlways))
            {
                memberTypeNameInfo.NItransmitTypeOnObject  = true;
                memberNameInfo.NItransmitTypeOnObject  = true;
                memberNameInfo.NIisParentTypeOnObject = true;
            }

            if (CheckForNull(objectInfo, memberNameInfo, memberTypeNameInfo, memberData))
            {
                return;
            }

            Object outObj = memberData;
            Type outType = null;

            // If member type does not equal data type, transmit type on object.
            if (memberTypeNameInfo.NIprimitiveTypeEnum == InternalPrimitiveTypeE.Invalid)
            {
                if (RemotingServices.IsTransparentProxy(outObj))
                    outType = Converter.typeofMarshalByRefObject;
                else
                {
                    outType = GetType(outObj);
                    if (memberType != outType)
                    {
                        memberTypeNameInfo.NItransmitTypeOnMember  = true;
                        memberNameInfo.NItransmitTypeOnMember  = true;                              
                    }
                }
            }

            if (memberType == Converter.typeofObject)
            {
                memberType = GetType(memberData);
                if (memberObjectInfo == null)
                    TypeToNameInfo(memberType, memberTypeNameInfo);
                else
                    TypeToNameInfo(memberObjectInfo, memberTypeNameInfo);                   
                InternalST.Soap( this, "WriteMembers memberType Object, actual memberType ",memberType);                                                                                
            }

            if (memberObjectInfo != null && memberObjectInfo.isArray)
            {
                // Array
                InternalST.Soap( this, "WriteMembers IsArray");

                long arrayId = 0;
                if (!(objectInfo.IsEmbeddedAttribute(memberNameInfo.NIname)|| IsEmbeddedAttribute(memberType)))
                {
                    arrayId = Schedule(outObj, outType, memberObjectInfo);
                }
                if (arrayId > 0)
                {
                    // Array as object
                    InternalST.Soap( this, "WriteMembers Schedule 3");
                    memberNameInfo.NIobjectId = arrayId;
                    WriteObjectRef(memberNameInfo, arrayId); 
                }
                else
                {
                    // Nested Array
                    serWriter.WriteMemberNested(memberNameInfo);

                    memberObjectInfo.objectId = arrayId;
                    memberNameInfo.NIobjectId = arrayId;
                    memberNameInfo.NIisNestedObject = true;
                    WriteArray(memberObjectInfo, memberNameInfo, memberObjectInfo);
                }
                InternalST.Soap( this, "WriteMembers Array Exit ");
                return;
            }

            if (!WriteKnownValueClass(memberNameInfo, memberTypeNameInfo, memberData, isAttribute))
            {
                InternalST.Soap( this, "WriteMembers Object ",memberData);

                // In soap an enum is written out as a string
                if (memberTypeNameInfo.NItype.IsEnum)
                    WriteEnum(memberNameInfo, memberTypeNameInfo, memberData, isAttribute);
                else
                {

                    if (isAttribute)
                    {
                        // XmlAttribute must be a primitive type or string
                        throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_NonPrimitive_XmlAttribute"), memberNameInfo.NIname));                                  
                    }

                    // Value or NO_ID, need to explicitly check for IsValue because a top level
                    // value class has an objectId of 1
                    if ((memberType.IsValueType) || objectInfo.IsEmbeddedAttribute(memberNameInfo.NIname) || IsEmbeddedAttribute(outType))
                    {
                        InternalST.Soap( this, "WriteMembers Value Type or NO_ID parameter");
                        serWriter.WriteMemberNested(memberNameInfo);

                        memberObjectInfo.objectId = -1;
                        NameInfo newTypeNameInfo = TypeToNameInfo(memberObjectInfo);
                        newTypeNameInfo.NIobjectId = -1;
                        memberNameInfo.NIisNestedObject = true;
                        if (objectInfo.isSi)
                        {
                            memberTypeNameInfo.NItransmitTypeOnMember  = true;
                            memberNameInfo.NItransmitTypeOnMember  = true;                              
                        }
                        Write( memberObjectInfo, memberNameInfo, newTypeNameInfo);
                        PutNameInfo(newTypeNameInfo);
                        memberObjectInfo.ObjectEnd();
                    }
                    else
                    {
                        InternalST.Soap( this, "WriteMembers Schedule 4");
                        long memberObjectId = 0;
                        memberObjectId = Schedule(outObj, outType, memberObjectInfo);

                        if (memberObjectId < 0)
                        {
                            // Nested object
                            InternalST.Soap( this, "WriteMembers Nesting");
                            serWriter.WriteMemberNested(memberNameInfo);

                            memberObjectInfo.objectId = -1;
                            NameInfo newTypeNameInfo = TypeToNameInfo(memberObjectInfo);
                            newTypeNameInfo.NIobjectId = -1;
                            memberNameInfo.NIisNestedObject = true;     
                            Write(memberObjectInfo, memberNameInfo, newTypeNameInfo);
                            PutNameInfo(newTypeNameInfo);
                            memberObjectInfo.ObjectEnd();
                        }
                        else
                        {
                            // Object reference
                            memberNameInfo.NIobjectId = memberObjectId;
                            WriteObjectRef(memberNameInfo, memberObjectId); 
                        }
                    }
                }
            }

            InternalST.Soap( this, "WriteMembers Exit ");
        }

        // Writes out an array
        private void WriteArray(WriteObjectInfo objectInfo, NameInfo memberNameInfo, WriteObjectInfo memberObjectInfo)          
        {
            InternalST.Soap( this, "WriteArray Entry ",objectInfo.obj," ",objectInfo.objectId);

            bool isAllocatedMemberNameInfo = false;
            if (memberNameInfo == null)
            {
                memberNameInfo = TypeToNameInfo(objectInfo);
                memberNameInfo.NIisTopLevelObject = true;
                isAllocatedMemberNameInfo = true;
            }

            memberNameInfo.NIisArray = true;

            long objectId = objectInfo.objectId;
            memberNameInfo.NIobjectId = objectInfo.objectId;

            // Get array type
            System.Array array = (System.Array)objectInfo.obj;
            //Type arrayType = array.GetType();
            Type arrayType = objectInfo.objectType;         

            // Get type of array element 
            Type arrayElemType = arrayType.GetElementType();
            WriteObjectInfo arrayElemObjectInfo = WriteObjectInfo.Serialize(arrayElemType, m_surrogates, m_context, serObjectInfoInit, m_formatterConverter, (memberObjectInfo == null) ? null : memberObjectInfo.typeAttributeInfo);
            arrayElemObjectInfo.assemId = GetAssemblyId(arrayElemObjectInfo);


            NameInfo arrayElemTypeNameInfo = null;
            NameInfo arrayNameInfo = ArrayTypeToNameInfo(objectInfo, out arrayElemTypeNameInfo);
            arrayNameInfo.NIobjectId = objectId;
            arrayNameInfo.NIisArray = true;
            arrayElemTypeNameInfo.NIobjectId = objectId;
            arrayElemTypeNameInfo.NItransmitTypeOnMember = memberNameInfo.NItransmitTypeOnMember;
            arrayElemTypeNameInfo.NItransmitTypeOnObject = memberNameInfo.NItransmitTypeOnObject;
            arrayElemTypeNameInfo.NIisParentTypeOnObject = memberNameInfo.NIisParentTypeOnObject;

            // Get rank and length information
            int rank = array.Rank;
            int[] lengthA = new int[rank];
            int[] lowerBoundA = new int[rank];
            int[] upperBoundA = new int[rank];                  
            for (int i=0; i<rank; i++)
            {
                lengthA[i] = array.GetLength(i);
                lowerBoundA[i] = array.GetLowerBound(i);
                upperBoundA[i] = array.GetUpperBound(i);                            
            }

            InternalArrayTypeE arrayEnum;

            if (arrayElemType.IsArray)
            {
                if (rank == 1)
                    arrayEnum = InternalArrayTypeE.Jagged;
                else
                    arrayEnum = InternalArrayTypeE.Rectangular;
            }
            else if (rank == 1)
                arrayEnum = InternalArrayTypeE.Single;
            else
                arrayEnum = InternalArrayTypeE.Rectangular;

            InternalST.Soap( this, "WriteArray ArrayInfo type ",arrayType," rank ",rank);


            // Byte array
            if ((arrayElemType == Converter.typeofByte) && (rank == 1) && (lowerBoundA[0] == 0))
            {
                serWriter.WriteObjectByteArray(memberNameInfo, arrayNameInfo, arrayElemObjectInfo, arrayElemTypeNameInfo, lengthA[0], lowerBoundA[0], (byte[])array);
                return;
            }

            if (arrayElemType == Converter.typeofObject)
            {
                memberNameInfo.NItransmitTypeOnMember = true;
                arrayElemTypeNameInfo.NItransmitTypeOnMember = true;
            }

            if (CheckTypeFormat(formatterEnums.FEtypeFormat, FormatterTypeStyle.TypesAlways))
            {
                memberNameInfo.NItransmitTypeOnObject = true;
                arrayElemTypeNameInfo.NItransmitTypeOnObject = true;                
            }

            if (arrayEnum == InternalArrayTypeE.Single)
            {
                // Single Dimensional array
                InternalST.Soap( this, "WriteArray ARRAY_SINGLE ");

                arrayNameInfo.NIname = arrayElemTypeNameInfo.NIname+"["+lengthA[0]+"]";

                // BinaryFormatter array of primitive types is written out in the WriteSingleArray statement
                // as a byte buffer
                serWriter.WriteSingleArray(memberNameInfo, arrayNameInfo, arrayElemObjectInfo, arrayElemTypeNameInfo, lengthA[0], lowerBoundA[0], array);

                if (Converter.IsWriteAsByteArray(arrayElemTypeNameInfo.NIprimitiveTypeEnum) && (lowerBoundA[0] == 0))
                {
                    // If binaryformatter and array is of appopriate primitive type the array is
                    // written out as a buffer of bytes. The array was transmitted in WriteSingleArray
                    // If soap the index directly by array
                    arrayElemTypeNameInfo.NIobjectId = 0;
                    if (primitiveArray == null)
                        primitiveArray = new PrimitiveArray(arrayElemTypeNameInfo.NIprimitiveTypeEnum, array);
                    else
                        primitiveArray.Init(arrayElemTypeNameInfo.NIprimitiveTypeEnum, array);

                    int upperBound = upperBoundA[0]+1;                      
                    for (int i = lowerBoundA[0]; i < upperBound; i++)
                    {
                        serWriter.WriteItemString(arrayElemTypeNameInfo, arrayElemTypeNameInfo, primitiveArray.GetValue(i));
                    }
                }
                else
                {
                    // Non-primitive type array
                    Object[] objectA = null;
                    if (!arrayElemType.IsValueType)
                        objectA = (Object[])array;

                    int upperBound = upperBoundA[0]+1;
                    // Soap does not write out trailing nulls. lastValue is set to the last null value. This becomes the array's upperbound
                    // Note: value classes can't be null
                    if (objectA != null)
                    {
                        int lastValue = lowerBoundA[0]-1;
                        for (int i = lowerBoundA[0]; i< upperBound; i++)
                        {
                            if (objectA[i] != null)
                                lastValue = i;
                        }
                        upperBound = lastValue+1;
                    }

                    for (int i = lowerBoundA[0]; i < upperBound; i++)
                    {
                        if (objectA == null)
                            WriteArrayMember(objectInfo, arrayElemTypeNameInfo, array.GetValue(i));
                        else
                            WriteArrayMember(objectInfo, arrayElemTypeNameInfo, objectA[i]);
                    }
                }
            }
            else if (arrayEnum == InternalArrayTypeE.Jagged)
            {
                // Jagged Array
                InternalST.Soap( this, "WriteArray ARRAY_JAGGED");

                int index;
                String arrayElemTypeDimension = null;

                index = arrayNameInfo.NIname.IndexOf('[');
                if (index < 0)
                    throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_Dimensions"),arrayElemTypeNameInfo.NIname));
                arrayElemTypeDimension = arrayNameInfo.NIname.Substring(index);

                InternalST.Soap( this, "WriteArray arrayNameInfo.NIname ",arrayNameInfo.NIname," arrayElemTypeNameInfo.NIname ",arrayElemTypeNameInfo.NIname," arrayElemTypeDimension ",arrayElemTypeDimension);
                arrayNameInfo.NIname = arrayElemTypeNameInfo.NIname+"["+lengthA[0]+"]";

                arrayNameInfo.NIobjectId = objectId;

                serWriter.WriteJaggedArray(memberNameInfo, arrayNameInfo, arrayElemObjectInfo, arrayElemTypeNameInfo, lengthA[0], lowerBoundA[0]);

                Object[] objectA = (Object[])array;
                for (int i = lowerBoundA[0]; i < upperBoundA[0]+1; i++)
                {
                    WriteArrayMember(objectInfo, arrayElemTypeNameInfo, objectA[i]);
                }
            }
            else
            {
                // Rectangle Array
                // Get the length for all the ranks
                InternalST.Soap( this, "WriteArray ARRAY_RECTANGLE");                       

                // Express array Type using XmlData Name
                int index;
                index = arrayNameInfo.NIname.IndexOf('[');

                // Create length dimension string in form [3,4,2]
                StringBuilder sb = new StringBuilder(10);
                sb.Append(arrayElemTypeNameInfo.NIname);
                sb.Append('[');

                for (int i=0; i<rank; i++)
                {
                    sb.Append(lengthA[i]);
                    if (i < rank-1)
                        sb.Append(',');
                }
                sb.Append(']');
                arrayNameInfo.NIname = sb.ToString();

                arrayNameInfo.NIobjectId = objectId;
                serWriter.WriteRectangleArray(memberNameInfo, arrayNameInfo, arrayElemObjectInfo, arrayElemTypeNameInfo, rank, lengthA, lowerBoundA);


                IndexTraceMessage("WriteArray Rectangle  ", lengthA);

                bool bzero = false;
                for (int i=0; i<rank; i++)
                {
                    if (lengthA[i] == 0)
                    {
                        bzero = true;
                        break;
                    }
                }

                if (!bzero)
                    WriteRectangle(objectInfo, rank, lengthA, array, arrayElemTypeNameInfo, lowerBoundA);
            }

            serWriter.WriteObjectEnd(memberNameInfo, arrayNameInfo); 


            PutNameInfo(arrayElemTypeNameInfo);
            PutNameInfo(arrayNameInfo);
            if (isAllocatedMemberNameInfo)
                PutNameInfo(memberNameInfo);

            InternalST.Soap( this, "WriteArray Exit ");
        }

        // Writes out an array element
        private void WriteArrayMember(WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, Object data)
        {
            InternalST.Soap( this, "WriteArrayMember ",data," baseArrayName ",arrayElemTypeNameInfo.NIname);

            arrayElemTypeNameInfo.NIisArrayItem = true;

            if (CheckForNull(objectInfo, arrayElemTypeNameInfo, arrayElemTypeNameInfo, data))
                return;

            NameInfo actualTypeInfo = null;

            Type dataType = null;

            bool isObjectOnMember = false;

            if (arrayElemTypeNameInfo.NItransmitTypeOnMember)
                isObjectOnMember = true;

            if (!isObjectOnMember && !arrayElemTypeNameInfo.NIisSealed)
            {
                dataType = GetType(data);
                if (arrayElemTypeNameInfo.NItype != dataType)
                    isObjectOnMember = true;
            }

            if (isObjectOnMember)
            {
                // Object array, need type of member
                if (dataType == null)
                    dataType = GetType(data);
                actualTypeInfo = TypeToNameInfo(dataType);
                actualTypeInfo.NItransmitTypeOnMember = true;
                actualTypeInfo.NIobjectId = arrayElemTypeNameInfo.NIobjectId;
                actualTypeInfo.NIassemId = arrayElemTypeNameInfo.NIassemId;
                actualTypeInfo.NIisArrayItem = true;
                actualTypeInfo.NIitemName = arrayElemTypeNameInfo.NIitemName;
            }
            else
            {
                actualTypeInfo = arrayElemTypeNameInfo;
                actualTypeInfo.NIisArrayItem = true;
            }

            if (!WriteKnownValueClass(arrayElemTypeNameInfo, actualTypeInfo, data, false))
            {
                Object obj = data;

                if (actualTypeInfo.NItype.IsEnum)
                {
                    WriteObjectInfo newObjectInfo = WriteObjectInfo.Serialize(obj, m_surrogates, m_context, serObjectInfoInit, m_formatterConverter, null);
                    actualTypeInfo.NIassemId = GetAssemblyId(newObjectInfo);
                    WriteEnum(arrayElemTypeNameInfo, actualTypeInfo, data, false);
                }
                else
                {
                    long arrayId = Schedule(obj, actualTypeInfo.NItype);
                    arrayElemTypeNameInfo.NIobjectId = arrayId;
                    actualTypeInfo.NIobjectId = arrayId;
                    if (arrayId < 1)
                    {
                        WriteObjectInfo newObjectInfo = WriteObjectInfo.Serialize(obj, m_surrogates, m_context, serObjectInfoInit, m_formatterConverter, null);
                        newObjectInfo.objectId = arrayId;
                        newObjectInfo.assemId = GetAssemblyId(newObjectInfo);

                        InternalST.Soap( this, "WriteArrayMembers nested");
                        if (dataType == null)
                            dataType = GetType(data);
                        if (data!=null && dataType.IsArray)
                        {
                            WriteArray(newObjectInfo, actualTypeInfo, null);
                        }
                        else
                        {
                            actualTypeInfo.NIisNestedObject = true;
                            NameInfo typeNameInfo = TypeToNameInfo(newObjectInfo);
                            typeNameInfo.NIobjectId = arrayId;
                            newObjectInfo.objectId = arrayId;
                            Write(newObjectInfo, actualTypeInfo, typeNameInfo);
                        }

                        newObjectInfo.ObjectEnd();
                    }
                    else
                        serWriter.WriteItemObjectRef(arrayElemTypeNameInfo, (int)arrayId);
                }
            }
            if (arrayElemTypeNameInfo.NItransmitTypeOnMember)
                PutNameInfo(actualTypeInfo);
        }


        // Iterates over a Rectangle array, for each element of the array invokes WriteArrayMember

        private void WriteRectangle(WriteObjectInfo objectInfo, int rank, int[] maxA, System.Array array, NameInfo arrayElemNameTypeInfo, int[] lowerBoundA)
        {
            IndexTraceMessage("WriteRectangle  Entry "+rank, maxA);
            int[] currentA = new int[rank];
            int[] indexMap = null;
            bool isLowerBound = false;
            if (lowerBoundA != null)
            {
                for (int i=0; i<rank; i++)
                {
                    if (lowerBoundA[i] != 0)
                        isLowerBound = true;
                }
            }
            if (isLowerBound)
                indexMap = new int[rank];

            bool isLoop = true;
            while (isLoop)
            {
                isLoop = false;
                if (isLowerBound)
                {
                    for (int i=0; i<rank; i++)
                        indexMap[i] = currentA[i]+lowerBoundA[i];
                    WriteArrayMember(objectInfo, arrayElemNameTypeInfo, array.GetValue(indexMap));
                }
                else
                    WriteArrayMember(objectInfo, arrayElemNameTypeInfo, array.GetValue(currentA));          
                for (int irank = rank-1; irank>-1; irank--)
                {
                    // Find the current or lower dimension which can be incremented.
                    if (currentA[irank] < maxA[irank]-1)
                    {
                        // The current dimension is at maximum. Increase the next lower dimension by 1
                        currentA[irank]++;
                        if (irank < rank-1)
                        {
                            // The current dimension and higher dimensions are zeroed.
                            for (int i = irank+1; i<rank; i++)
                                currentA[i] = 0;
                        }
                        isLoop = true;
                        break;                  
                    }

                }
            }
            InternalST.Soap( this, "WriteRectangle  Exit ");
        }

        // Traces a message with an array of int
        [Conditional("SER_LOGGING")]                            
        private void IndexTraceMessage(String message, int[] index)
        {
            StringBuilder sb = new StringBuilder(10);
            sb.Append("[");     
            for (int i=0; i<index.Length; i++)
            {
                sb.Append(index[i]);
                if (i != index.Length -1)
                    sb.Append(",");
            }
            sb.Append("]");             
            InternalST.Soap( this, message+" ",sb.ToString());
        }


        // This gives back the next object to be serialized.  Objects
        // are returned in a FIFO order based on how they were passed
        // to Schedule.  The id of the object is put into the objID parameter
        // and the Object itself is returned from the function.
        private Object GetNext(out long objID)
        {
            InternalST.Soap( this, "GetNext Entry ");       
            bool isNew;

            //The Queue is empty here.  We'll throw if we try to dequeue the empty queue.
            if (m_objectQueue.Count==0)
            {
                objID=0;
                InternalST.Soap( this, "GetNext Exit null");
                return null;
            }

            Object obj = m_objectQueue.Dequeue();
            Object realObj = null;

            // A WriteObjectInfo is queued if this object was a member of another object
            InternalST.Soap( this, "GetNext ",obj);
            if (obj is WriteObjectInfo)
            {
                InternalST.Soap( this, "GetNext recognizes WriteObjectInfo");
                realObj = ((WriteObjectInfo)obj).obj;
            }
            else
                realObj = obj;
            objID = m_idGenerator.HasId(realObj, out isNew);
            if (isNew)
            {
                InternalST.Soap( this, "Object " , obj , " has never been assigned an id.");
                throw new SerializationException(String.Format(SoapUtil.GetResourceString("Serialization_ObjNoID"),obj));                                                   
            }

            InternalST.Soap( this, "GetNext Exit "+objID," ",obj);              

            return obj;
        }

        Object previousObj = null;
        long previousId = 0;

        private long InternalGetId(Object obj, Type type, out bool isNew)
        {
            if (obj == previousObj)
            {
                isNew = false;
                return previousId;
            }

            if (type.IsValueType)
            {
                isNew = false;
                previousObj = obj;
                previousId = -1;
                return -1;
            }
            else
            {
                long objectId = m_idGenerator.GetId(obj, out isNew);
                previousObj = obj;
                previousId = objectId;              
                return objectId;
            }
        }


        // Schedules an object for later serialization if it hasn't already been scheduled.
        // We get an ID for obj and put it on the queue for later serialization
        // if this is a new object id.

        private long Schedule(Object obj, Type type)
        {
            return Schedule(obj, type, null);
        }

        private long Schedule(Object obj, Type type, WriteObjectInfo objectInfo)
        {
            InternalST.Soap( this, "Schedule Entry ",((obj == null)?"null":obj));

            bool isNew;
            long id;

            if (obj==null)
            {
                InternalST.Soap(this, "Schedule Obj Null, id = 0 ");
                return 0;
            }

            id = InternalGetId(obj, type, out isNew);           

            if (isNew)
            {
                if (objectInfo == null)
                    m_objectQueue.Enqueue(obj);
                else
                    m_objectQueue.Enqueue(objectInfo);
            }

            InternalST.Soap( this, "Schedule Exit, id: ",id," isNew: ",isNew);      
            return id;
        }


        // Determines if a type is a primitive type, if it is it is written

        private bool WriteKnownValueClass(NameInfo memberNameInfo, NameInfo typeNameInfo, Object data, bool isAttribute) 
        {
            InternalST.Soap( this, "WriteKnownValueClass Entry ",typeNameInfo.NIname," ",data," ",memberNameInfo.NIname);
            memberNameInfo.Dump("WriteKnownValueClass memberNameInfo");         
            typeNameInfo.Dump("WriteKnownValueClass typeNameInfo");

            if (typeNameInfo.NItype == Converter.typeofString)
            {
                if (isAttribute)
                    serWriter.WriteAttributeValue(memberNameInfo, typeNameInfo, (String)data);
                else
                    WriteString(memberNameInfo, typeNameInfo, data);
            }
            else
            {
                if (typeNameInfo.NIprimitiveTypeEnum == InternalPrimitiveTypeE.Invalid)
                {
                    InternalST.Soap( this, "WriteKnownValueClass Exit false");                      
                    return false;
                }
                else
                {
                    if (typeNameInfo.NIisArray) // null if an array
                        serWriter.WriteItem(memberNameInfo, typeNameInfo, data);
                    else
                    {
                        if (isAttribute)
                            serWriter.WriteAttributeValue(memberNameInfo, typeNameInfo, data);
                        else
                            serWriter.WriteMember(memberNameInfo, typeNameInfo, data);
                    }
                }
            }

            InternalST.Soap( this, "WriteKnownValueClass Exit true");
            return true;
        }


        // Writes an object reference to the stream.
        private void WriteObjectRef(NameInfo nameInfo, long objectId)
        {
            InternalST.Soap( this, "WriteObjectRef Entry ",nameInfo.NIname," ",objectId);
            serWriter.WriteMemberObjectRef(nameInfo, (int)objectId);

            InternalST.Soap( this, "WriteObjectRef Exit ");
        }



        // Writes a string into the XML stream
        private void WriteString(NameInfo memberNameInfo, NameInfo typeNameInfo, Object stringObject)
        {
            InternalST.Soap( this, "WriteString stringObject ",stringObject," memberName ",memberNameInfo.NIname);
            bool isFirstTime = true;

            long stringId = -1;

            if (!CheckTypeFormat(formatterEnums.FEtypeFormat, FormatterTypeStyle.XsdString))
                stringId= InternalGetId(stringObject, typeNameInfo.NItype, out isFirstTime);

            typeNameInfo.NIobjectId = stringId;
            InternalST.Soap( this, "WriteString stringId ",stringId," isFirstTime ",isFirstTime);

            if ((isFirstTime) || (stringId < 0))
            {
                if (typeNameInfo.NIisArray) // null if array
                    serWriter.WriteItemString(memberNameInfo, typeNameInfo, (String)stringObject);
                else
                    serWriter.WriteMemberString(memberNameInfo, typeNameInfo, (String)stringObject);
            }
            else
            {
                WriteObjectRef(memberNameInfo, stringId);
            }
        }

        // Writes a null member into the stream
        private bool CheckForNull(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, Object data)
        {
            InternalST.Soap( this, "CheckForNull Entry data ",Util.PString(data),", memberType ",Util.PString(typeNameInfo.NItype));

            bool isNull = false;

            if (data == null) // || Convert.IsDBNull(data)
                isNull = true;

            // Optimization, Null members are only written for Binary
            if (isNull)
            {
                InternalST.Soap( this, "CheckForNull Write");

                if (typeNameInfo.NItype.IsArray)
                {
                    // Call can occur before typeNameInfo.NIisArray is set
                    ArrayNameToDisplayName(objectInfo, typeNameInfo);
                }

                if (typeNameInfo.NIisArrayItem)
                    serWriter.WriteNullItem(memberNameInfo, typeNameInfo);
                else
                    serWriter.WriteNullMember(memberNameInfo, typeNameInfo);
            }
            InternalST.Soap( this, "CheckForNull Exit ",isNull);
            return isNull;
        }


        // Writes the SerializedStreamHeader
        private void WriteSerializedStreamHeader(long topId, long headerId)
        {
            serWriter.WriteSerializationHeader((int)topId, (int)headerId, 1, 0);
        }


        // Transforms a type to the serialized string form. URT Primitive types are converted to XMLData Types
        private NameInfo TypeToNameInfo(Type type, WriteObjectInfo objectInfo, InternalPrimitiveTypeE code, NameInfo nameInfo)
        {
            InternalST.Soap( this, "TypeToNameInfo Entry type ",type,", objectInfo ",objectInfo,", code ", ((Enum)code).ToString());
            if (nameInfo == null)
                nameInfo = GetNameInfo();
            else
                nameInfo.Init();

            nameInfo.NIisSealed = type.IsSealed;

            String typeName = null;
            nameInfo.NInameSpaceEnum = Converter.GetNameSpaceEnum(code, type, objectInfo, out typeName);
            nameInfo.NIprimitiveTypeEnum = code;
            nameInfo.NItype = type;
            nameInfo.NIname = typeName;
            if (objectInfo != null)
            {
                nameInfo.NIattributeInfo = objectInfo.typeAttributeInfo;                    
                nameInfo.NIassemId = objectInfo.assemId;
            }

            switch (nameInfo.NInameSpaceEnum)
            {
                case InternalNameSpaceE.XdrPrimitive:
                    break;
                case InternalNameSpaceE.XdrString:
                    nameInfo.NIname = "string";
                    break;
                case InternalNameSpaceE.UrtSystem:
                    break;
                case InternalNameSpaceE.UrtUser:
                    //if (type.FullName.StartsWith("System."))
                    if (type.Module.Assembly == Converter.urtAssembly)
                    {
                        // The type name could be an ISerializable
                        // But the type returned (typeName) could be a fake
                        // type
                    }
                    else
                    {
                        if (objectInfo == null)
                        {
                            InternalST.Soap( this, "TypeToNameInfo ObjectInfo is null 2 ",type);
                        }
                    }
                    break;
            }

            InternalST.Soap( this, "TypeToNameInfo Exit ",type, " typeName "+nameInfo.NIname);
            return nameInfo;            
        }

        private NameInfo TypeToNameInfo(Type type)
        {
            return TypeToNameInfo(type, null, Converter.ToCode(type), null);
        }

        private NameInfo TypeToNameInfo(Type type, InternalPrimitiveTypeE code)
        {
            return TypeToNameInfo(type, null, code, null);
        }


        private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo)
        {
            return TypeToNameInfo(objectInfo.objectType, objectInfo, Converter.ToCode(objectInfo.objectType), null);
        }

        private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo, NameInfo nameInfo)
        {
            return TypeToNameInfo(objectInfo.objectType, objectInfo, Converter.ToCode(objectInfo.objectType), nameInfo);
        }


        private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo, InternalPrimitiveTypeE code)
        {
            return TypeToNameInfo(objectInfo.objectType, objectInfo, code, null);
        }

        private void TypeToNameInfo(Type type, NameInfo nameInfo)
        {
            TypeToNameInfo(type, null, Converter.ToCode(type), nameInfo);
        }




        // Transforms an Array to the serialized string form.

        private NameInfo ArrayTypeToNameInfo(WriteObjectInfo objectInfo, out NameInfo arrayElemTypeNameInfo)
        {
            InternalST.Soap( this, "ArrayTypeToNameInfo Entry ",objectInfo.objectType);

            NameInfo arrayNameInfo = TypeToNameInfo(objectInfo);
            //arrayElemTypeNameInfo = TypeToNameInfo(objectInfo.objectType.GetElementType());
            arrayElemTypeNameInfo = TypeToNameInfo(objectInfo.arrayElemObjectInfo);
            // Need to substitute XDR type for URT type in array.
            // E.g. Int32[] becomes I4[]
            ArrayNameToDisplayName(objectInfo, arrayElemTypeNameInfo);
            arrayNameInfo.NInameSpaceEnum = arrayElemTypeNameInfo.NInameSpaceEnum;
            arrayElemTypeNameInfo.NIisArray = arrayElemTypeNameInfo.NItype.IsArray;

            InternalST.Soap( this, "ArrayTypeToNameInfo Exit array ",arrayNameInfo.NIname," element ",arrayElemTypeNameInfo.NIname);            
            return arrayNameInfo;
        }

        private NameInfo MemberToNameInfo(String name)
        {
            NameInfo memberNameInfo = GetNameInfo();
            memberNameInfo.NInameSpaceEnum = InternalNameSpaceE.MemberName;
            memberNameInfo.NIname = name;
            return memberNameInfo;
        }

        private void ArrayNameToDisplayName(WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo)
        {

            InternalST.Soap( this, "ArrayNameToDisplayName Entry ",arrayElemTypeNameInfo.NIname);           

            String arrayElemTypeName = arrayElemTypeNameInfo.NIname;
            //String arrayElemTypeName = objectInfo.GetTypeFullName();;    
            InternalST.Soap( this, "ArrayNameToDisplayName Entry ",arrayElemTypeNameInfo.NIname, " Type full name ", arrayElemTypeName);            
            int arrayIndex = arrayElemTypeName.IndexOf('[');
            if (arrayIndex > 0)
            {
                String elemBaseTypeString = arrayElemTypeName.Substring(0, arrayIndex);
                InternalPrimitiveTypeE code = Converter.ToCode(elemBaseTypeString);
                String convertedType = null;
                bool isConverted = false;
                if (code != InternalPrimitiveTypeE.Invalid)
                {
                    if (code == InternalPrimitiveTypeE.Char)
                    {
                        convertedType = elemBaseTypeString;
                        arrayElemTypeNameInfo.NInameSpaceEnum = InternalNameSpaceE.UrtSystem;
                    }
                    else
                    {
                        isConverted = true;
                        convertedType = Converter.ToXmlDataType(code);
                        String typeName = null;                 
                        arrayElemTypeNameInfo.NInameSpaceEnum = Converter.GetNameSpaceEnum(code, null, objectInfo, out typeName); 
                    }
                }
                else
                {
                    InternalST.Soap( this, "ArrayNameToDisplayName elemBaseTypeString ",elemBaseTypeString);                                
                    if ((elemBaseTypeString.Equals("String")) || (elemBaseTypeString.Equals("System.String")))
                    {
                        isConverted = true;
                        convertedType = "string";
                        arrayElemTypeNameInfo.NInameSpaceEnum = InternalNameSpaceE.XdrString;
                    }
                    else if (elemBaseTypeString.Equals("System.Object"))
                    {
                        isConverted = true;
                        convertedType = "anyType";
                        arrayElemTypeNameInfo.NInameSpaceEnum = InternalNameSpaceE.XdrPrimitive;
                    }
                    else
                    {
                        convertedType = elemBaseTypeString;
                    }
                }

                if (isConverted)
                {
                    arrayElemTypeNameInfo.NIname = convertedType+arrayElemTypeName.Substring(arrayIndex);
                }
            }
            else if (arrayElemTypeName.Equals("System.Object"))
            {
                arrayElemTypeNameInfo.NIname = "anyType";
                arrayElemTypeNameInfo.NInameSpaceEnum = InternalNameSpaceE.XdrPrimitive;
            }

            InternalST.Soap( this, "ArrayNameToDisplayName Exit ",arrayElemTypeNameInfo.NIname);                        
        }

        private Hashtable assemblyToIdTable = new Hashtable(20);
        private StringBuilder sburi = new StringBuilder(50);
        private long GetAssemblyId(WriteObjectInfo objectInfo)
        {
            //use objectInfo to get assembly string with new criteria
            InternalST.Soap( this, "GetAssemblyId Entry ",objectInfo.objectType," isSi ",objectInfo.isSi);
            long assemId = 0;
            bool isNew = false;
            String assemblyString = objectInfo.GetAssemblyString();
            String serializedAssemblyString = assemblyString;
            if (assemblyString.Length == 0)
            {
                // Fake type could returns an empty string
                assemId = 0;
            }
            else if (assemblyString.Equals(Converter.urtAssemblyString))
            {
                // Urt type is an assemId of 0. No assemblyString needs
                // to be sent but for soap, dotted names need to be placed in header
                InternalST.Soap( this, "GetAssemblyId urt Assembly String ");
                assemId = 0;
                isNew = false;
                serWriter.WriteAssembly(objectInfo.GetTypeFullName(), objectInfo.objectType, null, (int)assemId, isNew, objectInfo.IsAttributeNameSpace());
            }
            else
            {
                // Assembly needs to be sent
                // Need to prefix assembly string to separate the string names from the
                // assemblyName string names. That is a string can have the same value
                // as an assemblyNameString, but it is serialized differently

                if (assemblyToIdTable.ContainsKey(assemblyString))
                {
                    assemId = (long)assemblyToIdTable[assemblyString];
                    isNew = false;
                }
                else
                {
                    assemId = m_idGenerator.GetId("___AssemblyString___"+assemblyString, out isNew);
                    assemblyToIdTable[assemblyString] = assemId;
                }

                if (assemblyString != null && !objectInfo.IsInteropNameSpace())
                {
                    if (formatterEnums.FEassemblyFormat == FormatterAssemblyStyle.Simple)
                    {
                        // Use only the simple assembly name (not version or strong name)
                        int index = assemblyString.IndexOf(',');
                        if (index > 0)
                            serializedAssemblyString = assemblyString.Substring(0, index);
                    }
                }
                serWriter.WriteAssembly(objectInfo.GetTypeFullName(), objectInfo.objectType, serializedAssemblyString, (int)assemId, isNew, objectInfo.IsInteropNameSpace());
            }
            InternalST.Soap( this, "GetAssemblyId Exit id ",assemId," isNew ",isNew," assemblyString ",serializedAssemblyString);
            return assemId;
        }

        private bool IsEmbeddedAttribute(Type type)
        {
            InternalST.Soap( this," IsEmbedded Entry ",type);
            bool isEmbedded = false;
            if (type.IsValueType)
                isEmbedded = true;
            else
            {
                SoapTypeAttribute attr = (SoapTypeAttribute)
                                         InternalRemotingServices.GetCachedSoapAttribute(type);
                isEmbedded = attr.Embedded;             
            }
            InternalST.Soap( this," IsEmbedded Exit ",isEmbedded);          
            return isEmbedded;
        }

        private void WriteEnum(NameInfo memberNameInfo, NameInfo typeNameInfo, Object data, bool isAttribute)
        {
            InternalST.Soap( this, "WriteEnum ", memberNameInfo.NIname," type ", typeNameInfo.NItype," data ",((Enum)data).ToString());
            // An enum is written out as a string
            if (isAttribute)
                serWriter.WriteAttributeValue(memberNameInfo, typeNameInfo, ((Enum)data).ToString());
            else
                serWriter.WriteMember(memberNameInfo, typeNameInfo, ((Enum)data).ToString());
        }           

        private Type GetType(Object obj)
        {
            Type type = null;
            if (RemotingServices.IsTransparentProxy(obj))
                type = Converter.typeofMarshalByRefObject;
            else
                type = obj.GetType();
            return type;
        }

        private SerStack niPool = new SerStack("NameInfo Pool");

        private NameInfo GetNameInfo()
        {
            NameInfo nameInfo = null;

            if (!niPool.IsEmpty())
            {
                nameInfo = (NameInfo)niPool.Pop();
                nameInfo.Init();
            }
            else
                nameInfo = new NameInfo();

            return nameInfo;
        }

        private bool CheckTypeFormat(FormatterTypeStyle test, FormatterTypeStyle want)
        {
            return(test & want) == want;
        }

        private void PutNameInfo(NameInfo nameInfo)
        {
            niPool.Push(nameInfo);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\custattr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CustAttr.cpp
//
// Implementation for the meta data custom attribute code.
//
//*****************************************************************************
#include "stdafx.h"
#include "RegMeta.h"
#include "MetaData.h"
#include "CorError.h"
#include "MDUtil.h"
#include "RWUtil.h"
#include "MDLog.h"
#include "ImportHelper.h"
#include "MDPerf.h"
#include "CorPermE.h"
#include "PostError.h"
#include "CaHlpr.h"

#include <MetaModelRW.h>

//*****************************************************************************
//*****************************************************************************
// Support for "Pseudo Custom Attributes"


//*****************************************************************************
// Enumeration of known custom attributes.
//*****************************************************************************
#define KnownCaList()                   \
    KnownCa(UNKNOWN)                    \
    KnownCa(DllImportAttribute)         \
    KnownCa(GuidAttribute)              \
    KnownCa(ComImportAttribute)         \
    KnownCa(InterfaceTypeAttribute)     \
    KnownCa(ClassInterfaceAttribute)    \
    KnownCa(SerializableAttribute)      \
    KnownCa(NonSerializedAttribute)     \
    KnownCa(MethodImplAttribute1)       \
    KnownCa(MethodImplAttribute2)       \
    KnownCa(MethodImplAttribute3)       \
    KnownCa(MarshalAsAttribute)         \
    KnownCa(PreserveSigAttribute)       \
    KnownCa(InAttribute)                \
    KnownCa(OutAttribute)               \
    KnownCa(OptionalAttribute)          \
    KnownCa(StructLayoutAttribute1)     \
    KnownCa(StructLayoutAttribute2)     \
    KnownCa(FieldOffsetAttribute)       \
    KnownCa(DebuggableAttribute)        \


// Ids for the CA's.  CA_DllImportAttribute, etc.
#define KnownCa(x) CA_##x,
enum {
    KnownCaList()
    CA_COUNT
};

//*****************************************************************************
// Argument parsing.  The custom attributes may have ctor arguments, and may
//  have named arguments.  The arguments are defined by the following tables.
//
//  These tables also include a member to contain the value of the argument,
//  which is used at runtime.  When parsing a given custom attribute, a copy
//  of the argument descriptors is filled in with the values for the instance
//  of the custom attribute.
//                          
//  For each ctor arg, there is a CaArg struct, with the type.  At runtime,
//   a value is filled in for each ctor argument.
//
//  For each named arg, there is a CaNamedArg struct, with the name of the 
//   argument, the expected type of the argument, if the type is an enum,
//   the name of the enum.  Also, at runtime, a value is filled in for 
//   each named argument found.
//
//  Note that arrays and variants are not supported.
//
//  At runtime, afte the args have been parsed, the tag field of CaValue
//   can be used to determine if a particular arg was given.
//*****************************************************************************
struct CaArg
{
    CorSerializationType    type;       // Type of the argument.
    CaValue                 val;        // Value of the argument.
};

struct CaNamedArg
{
    LPCSTR                  szName;     // Name of the argument.
    CorSerializationType    type;       // Expected type of the argument.
    LPCSTR                  szEnumName; // Name of enum type, if enum type.
    size_t                  cEnumNameCount;
    CaValue                 val;        // Value of the argument.
};

//*****************************************************************************
// Properties of the known custom attributes.  
//
// These tables describe the known custom attributes.  For each custom 
//  attribute, we know the namespace and name of the custom attribute,
//  the types to which the CA applies, the ctor args, and possible named
//  args.  There is a flag which specifies whether the custom attribute 
//  should be kept, in addition to any processing done with the data.
//*****************************************************************************
const bKEEPCA = TRUE;
const bDONTKEEPCA = FALSE;
const bMATCHBYSIG = TRUE;
const bMATCHBYNAME = FALSE;
struct KnownCaProp
{   
    LPCUTF8     szNamespace;            // Namespace of the custom attribute.
    LPCUTF8     szName;                 // Name of the custom attribute.
    mdToken     *rTypes;                // Types that the CA applies to.
    BOOL        bKeepCa;                // Keep the CA after processing?
    CaArg       *pArgs;                 // List of ctor argument descriptors.
    ULONG       cArgs;                  // Count of ctor argument descriptors.
    CaNamedArg  *pNamedArgs;            // List of named arg descriptors.
    ULONG       cNamedArgs;             // Count of named arg descriptors.
    BOOL        bMatchBySig;            // For overloads; match by sig, not just name.  
                                        // WARNING:  All overloads need the flag!
};

// Recognized targets for known custom attributes.
mdToken DllImportTargets[]          = {mdtMethodDef, -1};
mdToken GuidTargets[]               = {mdtTypeDef, mdtTypeRef, mdtModule, mdtAssembly, -1};
mdToken ComImportTargets[]          = {mdtTypeDef, -1};
mdToken InterfaceTypeTargets[]      = {mdtTypeDef, -1};
mdToken ClassInterfaceTargets[]     = {mdtTypeDef, mdtAssembly, mdtTypeRef, -1};
mdToken SerializableTargets[]       = {mdtTypeDef, -1};
mdToken NotInGCHeapTargets[]        = {mdtTypeDef, -1};
mdToken NonSerializedTargets[]      = {mdtFieldDef, -1};
mdToken MethodImplTargets[]         = {mdtMethodDef, -1};
mdToken MarshalTargets[]            = {mdtFieldDef, mdtParamDef, mdtProperty, -1};
mdToken PreserveSigTargets[]        = {mdtMethodDef, -1};
mdToken InOutTargets[]              = {mdtParamDef, -1};
mdToken StructLayoutTargets[]       = {mdtTypeDef, -1};
mdToken FieldOffsetTargets[]        = {mdtFieldDef, -1};
mdToken DebuggableTargets[]         = {mdtAssembly, mdtTypeRef, -1};

//#ifndef CEE_CALLCONV
// # define CEE_CALLCONV (IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS)
//#endif

//-----------------------------------------------------------------------------
// index 0 is used as a placeholder.
KnownCaProp UNKNOWNProps                   = {0};
    
//-----------------------------------------------------------------------------
// DllImport args, named args, and known attribute properties.
CaArg rDllImportAttributeArgs[] = 
{
    {SERIALIZATION_TYPE_STRING}
};
// NOTE:  Keep this enum in sync with the array of named arguments.
enum DllImportNamedArgs
{
    DI_CallingConvention,
    DI_CharSet,
    DI_EntryPoint,
    DI_ExactSpelling,
    DI_SetLastError,
    DI_PreserveSig,
    DI_BestFitMapping,
    DI_ThrowOnUnmappableChar,
    DI_COUNT
};

#define CALLING_CONVENTION      "System.Runtime.InteropServices.CallingConvention"
#define CHAR_SET                "System.Runtime.InteropServices.CharSet"

CaNamedArg rDllImportAttributeNamedArgs[] = 
{
    {"CallingConvention",   SERIALIZATION_TYPE_ENUM,    CALLING_CONVENTION, sizeof(CALLING_CONVENTION) - 1},
    {"CharSet",             SERIALIZATION_TYPE_ENUM,    CHAR_SET,           sizeof(CHAR_SET) - 1},
    {"EntryPoint",          SERIALIZATION_TYPE_STRING},
    {"ExactSpelling",       SERIALIZATION_TYPE_BOOLEAN},
    {"SetLastError",        SERIALIZATION_TYPE_BOOLEAN},
    {"PreserveSig",         SERIALIZATION_TYPE_BOOLEAN},
    {"BestFitMapping",      SERIALIZATION_TYPE_BOOLEAN},
    {"ThrowOnUnmappableChar", SERIALIZATION_TYPE_BOOLEAN},
};
KnownCaProp DllImportAttributeProps         = {"System.Runtime.InteropServices", "DllImportAttribute", DllImportTargets, bDONTKEEPCA,
                                                rDllImportAttributeArgs, lengthof(rDllImportAttributeArgs),
                                                rDllImportAttributeNamedArgs, lengthof(rDllImportAttributeNamedArgs)};

//-----------------------------------------------------------------------------
// GUID args, named args (none), and known attribute properties.
CaArg rGuidAttributeArgs[] = 
{
    {SERIALIZATION_TYPE_STRING}
};
KnownCaProp GuidAttributeProps              = {"System.Runtime.InteropServices", "GuidAttribute", GuidTargets, bKEEPCA,
                                                rGuidAttributeArgs, lengthof(rGuidAttributeArgs)};    

//-----------------------------------------------------------------------------
// ComImport args (none), named args (none), and known attribute properties.
KnownCaProp ComImportAttributeProps         = {"System.Runtime.InteropServices", "ComImportAttribute", ComImportTargets};    

//-----------------------------------------------------------------------------
// Interface type args, named args (none), and known attribute properties.
CaArg rInterfaceTypeAttributeArgs[] = 
{
    {SERIALIZATION_TYPE_U2}
};
KnownCaProp InterfaceTypeAttributeProps     = {"System.Runtime.InteropServices", "InterfaceTypeAttribute", InterfaceTypeTargets, bKEEPCA,
                                                rInterfaceTypeAttributeArgs, lengthof(rInterfaceTypeAttributeArgs)};    

//-----------------------------------------------------------------------------
// Class interface type args, named args (none), and known attribute properties.
CaArg rClassInterfaceAttributeArgs[] = 
{
    {SERIALIZATION_TYPE_U2}
};
KnownCaProp ClassInterfaceAttributeProps     = {"System.Runtime.InteropServices", "ClassInterfaceAttribute", ClassInterfaceTargets, bKEEPCA,
                                                rClassInterfaceAttributeArgs, lengthof(rClassInterfaceAttributeArgs)};    

//-----------------------------------------------------------------------------
// Serializable args (none), named args (none), and known attribute properties.
KnownCaProp SerializableAttributeProps      = {"System", "SerializableAttribute", SerializableTargets};    

//-----------------------------------------------------------------------------
// NonSerialized args (none), named args (none), and known attribute properties.
KnownCaProp NonSerializedAttributeProps     = {"System", "NonSerializedAttribute", NonSerializedTargets};    

//-----------------------------------------------------------------------------
// MethodImpl #1 args (none), named args, and known attribute properties.
// MethodImpl #2 args (short), named args, and known attribute properties.
// MethodImpl #3 args (enum), named args, and known attribute properties.
// Note: first two match by signature; third by name only, because signature matching code is not 
//  strong enough for enums.
CaArg rMethodImplAttribute2Args[] = 
{
    {SERIALIZATION_TYPE_I2}
};
CaArg rMethodImplAttribute3Args[] = 
{
    {SERIALIZATION_TYPE_U4}
};
enum MethodImplAttributeNamedArgs
{
    MI_CodeType,
    MI_COUNT
};

#define METHOD_CODE_TYPE    "System.Runtime.CompilerServices.MethodCodeType"

CaNamedArg rMethodImplAttributeNamedArgs[] = 
{
    {"MethodCodeType",      SERIALIZATION_TYPE_ENUM,    METHOD_CODE_TYPE,   sizeof(METHOD_CODE_TYPE) - 1}
};
KnownCaProp MethodImplAttribute1Props        = {"System.Runtime.CompilerServices", "MethodImplAttribute", MethodImplTargets, bDONTKEEPCA,
                                                0, 0,
                                                rMethodImplAttributeNamedArgs, lengthof(rMethodImplAttributeNamedArgs),    
                                                bMATCHBYSIG};    
KnownCaProp MethodImplAttribute2Props        = {"System.Runtime.CompilerServices", "MethodImplAttribute", MethodImplTargets, bDONTKEEPCA,
                                                rMethodImplAttribute2Args, lengthof(rMethodImplAttribute2Args),
                                                rMethodImplAttributeNamedArgs, lengthof(rMethodImplAttributeNamedArgs),    
                                                bMATCHBYSIG};    
KnownCaProp MethodImplAttribute3Props        = {"System.Runtime.CompilerServices", "MethodImplAttribute", MethodImplTargets, bDONTKEEPCA,
                                                rMethodImplAttribute3Args, lengthof(rMethodImplAttribute3Args),
                                                rMethodImplAttributeNamedArgs, lengthof(rMethodImplAttributeNamedArgs),    
                                                bMATCHBYNAME};    

//-----------------------------------------------------------------------------
// Marshal args, named args, and known attribute properties.
CaArg rMarshalAsAttributeArgs[] = 
{
    {SERIALIZATION_TYPE_U4}
};
// NOTE:  Keep this enum in sync with the array of named arguments.
enum MarshalNamedArgs
{
    M_ArraySubType,
    M_SafeArraySubType,    
    M_SafeArrayUserDefinedSubType,
    M_SizeParamIndex,
    M_SizeConst,
    M_MarshalType,
    M_MarshalTypeRef,
    M_MarshalCookie,
    M_COUNT
};

#define UNMANAGED_TYPE      "System.Runtime.InteropServices.UnmanagedType"
#define VAR_ENUM            "System.Runtime.InteropServices.VarEnum"

CaNamedArg rMarshalAsAttributeNamedArgs[] = 
{
    {"ArraySubType",            SERIALIZATION_TYPE_ENUM,        UNMANAGED_TYPE,     sizeof(UNMANAGED_TYPE) - 1},
    {"SafeArraySubType",        SERIALIZATION_TYPE_ENUM,        VAR_ENUM,           sizeof(VAR_ENUM) - 1},
    {"SafeArrayUserDefinedSubType", SERIALIZATION_TYPE_TYPE},
    {"SizeParamIndex",          SERIALIZATION_TYPE_I2},
    {"SizeConst",               SERIALIZATION_TYPE_I4},
    {"MarshalType",             SERIALIZATION_TYPE_STRING},
    {"MarshalTypeRef",          SERIALIZATION_TYPE_TYPE},
    {"MarshalCookie",           SERIALIZATION_TYPE_STRING},
};
KnownCaProp MarshalAsAttributeProps         = {"System.Runtime.InteropServices", "MarshalAsAttribute", MarshalTargets, bDONTKEEPCA,
                                              rMarshalAsAttributeArgs, lengthof(rMarshalAsAttributeArgs),
                                              rMarshalAsAttributeNamedArgs, lengthof(rMarshalAsAttributeNamedArgs)};    

//-----------------------------------------------------------------------------
// PreserveSignature args, named args (none), and known attribute properties.
KnownCaProp PreserveSigAttributeProps        = {"System.Runtime.InteropServices", "PreserveSigAttribute", PreserveSigTargets, bDONTKEEPCA};    

//-----------------------------------------------------------------------------
// In args (none), named args (none), and known attribute properties.
KnownCaProp InAttributeProps     = {"System.Runtime.InteropServices", "InAttribute", InOutTargets};    

//-----------------------------------------------------------------------------
// Out args (none), named args (none), and known attribute properties.
KnownCaProp OutAttributeProps     = {"System.Runtime.InteropServices", "OutAttribute", InOutTargets};    

//-----------------------------------------------------------------------------
// Optional args (none), named args (none), and known attribute properties.
KnownCaProp OptionalAttributeProps     = {"System.Runtime.InteropServices", "OptionalAttribute", InOutTargets};    

//-----------------------------------------------------------------------------
// StructLayout args, named args, and known attribute properties.
CaArg rStructLayoutAttribute2Args[] = 
{
    {SERIALIZATION_TYPE_I4}
};
CaArg rStructLayoutAttribute1Args[] = 
{
    {SERIALIZATION_TYPE_I2}
};
// NOTE:  Keep this enum in sync with the array of named arguments.
enum StructLayoutNamedArgs
{
    SL_Pack,
    SL_Size,
    SL_CharSet,
    SL_COUNT
};
CaNamedArg rStructLayoutAttributeNamedArgs[] = 
{
    {"Pack",                SERIALIZATION_TYPE_I4},
    {"Size",                SERIALIZATION_TYPE_I4},
    {"CharSet",             SERIALIZATION_TYPE_ENUM,    CHAR_SET,   sizeof(CHAR_SET) - 1},
};
KnownCaProp StructLayoutAttribute1Props       = {"System.Runtime.InteropServices", "StructLayoutAttribute", StructLayoutTargets, bDONTKEEPCA,
                                                rStructLayoutAttribute1Args, lengthof(rStructLayoutAttribute1Args),
                                                rStructLayoutAttributeNamedArgs, lengthof(rStructLayoutAttributeNamedArgs),    
                                                bMATCHBYSIG};    
KnownCaProp StructLayoutAttribute2Props       = {"System.Runtime.InteropServices", "StructLayoutAttribute", StructLayoutTargets, bDONTKEEPCA,
                                                rStructLayoutAttribute2Args, lengthof(rStructLayoutAttribute2Args),
                                                rStructLayoutAttributeNamedArgs, lengthof(rStructLayoutAttributeNamedArgs),
                                                bMATCHBYNAME};    

//-----------------------------------------------------------------------------
// FieldOffset args, named args (none), and known attribute properties.
CaArg rFieldOffsetAttributeArgs[] = 
{
    {SERIALIZATION_TYPE_U4}
};
KnownCaProp FieldOffsetAttributeProps        = {"System.Runtime.InteropServices", "FieldOffsetAttribute", FieldOffsetTargets, bDONTKEEPCA,
                                                rFieldOffsetAttributeArgs, lengthof(rFieldOffsetAttributeArgs)};    

//-----------------------------------------------------------------------------
// Debuggable args, named args (none), and known attribute properties.
CaArg rDebuggableAttributeArgs[] = 
{
    {SERIALIZATION_TYPE_BOOLEAN,
     SERIALIZATION_TYPE_BOOLEAN}
};
KnownCaProp DebuggableAttributeProps     = {"XXXXSystem.Diagnostics", "DebuggableAttribute", DebuggableTargets, bKEEPCA,
                                            rDebuggableAttributeArgs, lengthof(rDebuggableAttributeArgs)};    


//-----------------------------------------------------------------------------
// Array of known custom attribute properties
#undef KnownCa
#define KnownCa(x) &x##Props,
const KnownCaProp *(rKnownCaProps[CA_COUNT]) =
{
    KnownCaList()
};
    
//*****************************************************************************
// Helper to turn on or off a single bit in a bitmask.
//*****************************************************************************
template<class T> FORCEINLINE void SetBitValue(T &bitmask, T bit, int bVal)
{
    if (bVal)
        bitmask |= bit;
    else
        bitmask &= ~bit;
} // template<class T> FORCEINLINE void SetBitValue()

//*****************************************************************************
// Helper to parse a named argument list.
//*****************************************************************************
static HRESULT ParseKnownCaNamedArgs(
    CustomAttributeParser &ca,          // The Custom Attribute blob.
    CaNamedArg  *pNamedArgs,            // Array of argument descriptors.
    ULONG       cNamedArgs)             // Count of argument descriptors.
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       ix;                     // Loop control.
    int         ixActual;               // Loop control over actual arguments.
    __int16     cActualArgs;            // Count of actual named arguments.
    signed __int8 ArgTag;               // Is argument a field or property?
    signed __int8 ArgType;              // Type of argument.
    ULONG       cbArgName;              // Size of an argument name.
    LPCUTF8     pArgName;               // Argument's name.
    ULONG       cbEnumName;             // Size of an enum name.
    LPCUTF8     pEnumName;              // Enum's name.
    
    // Get actual count of named arguments.
    IfFailGo(ca.GetI2(&cActualArgs));
    
    // For each named argument...
    for (ixActual=0; ixActual<cActualArgs; ++ixActual)
    {   
        // Field or property? Only handle fields.
        IfFailGo(ca.GetI1(&ArgTag));
        if (ArgTag != SERIALIZATION_TYPE_FIELD)
            IfFailGo(PostError(META_E_CA_INVALID_ARGTYPE));
        
        // Type of Arg.
        IfFailGo(ca.GetI1(&ArgType));
        if (ArgType == SERIALIZATION_TYPE_ENUM)
        {
            pEnumName = ca.GetString(&cbEnumName);
            if (cbEnumName == 0 || cbEnumName == -1)
               IfFailGo(PostError(META_E_CA_INVALID_BLOB));
        }
        
        //Name of Arg.
        pArgName = ca.GetString(&cbArgName);
        if (cbArgName == 0 || cbArgName == -1)
            IfFailGo(PostError(META_E_CA_INVALID_BLOB));
        
        // Match arg by name and type.
        for (ix=0; ix<cNamedArgs; ++ix)
        {
            // Match type.
            if (ArgType != pNamedArgs[ix].type)
                continue;
            // Match name.
            if (strncmp(pNamedArgs[ix].szName, pArgName, cbArgName) != 0 ||
                pNamedArgs[ix].szName[cbArgName] != '\0')
                continue;
            // If enum, match enum name.
            if (ArgType == SERIALIZATION_TYPE_ENUM) 
            {
                if (pNamedArgs[ix].cEnumNameCount > cbEnumName)
                    continue; // name cannot possibly match
                if (strncmp(pNamedArgs[ix].szEnumName, pEnumName, pNamedArgs[ix].cEnumNameCount) != 0 ||
                    (pNamedArgs[ix].cEnumNameCount < cbEnumName && pEnumName[pNamedArgs[ix].cEnumNameCount] != ','))
                    continue;
            }
            // Found a match.
            break;
        }
        // Better have found an argument.
        if (ix == cNamedArgs)
            IfFailGo(PostError(META_E_CA_UNKNOWN_ARGUMENT, cbArgName, pArgName));
        // Argument had better not have been seen already.
        if (pNamedArgs[ix].val.tag != 0)
            IfFailGo(PostError(META_E_CA_REPEATED_ARG, cbArgName, pArgName));
        
        // Grab the value.
        pNamedArgs[ix].val.tag = ArgType;
        switch (ArgType)
        {
        case SERIALIZATION_TYPE_BOOLEAN:
        case SERIALIZATION_TYPE_I1:
        case SERIALIZATION_TYPE_U1:
            IfFailGo(ca.GetU1(&pNamedArgs[ix].val.u1));
            break;
        
        case SERIALIZATION_TYPE_CHAR:
        case SERIALIZATION_TYPE_I2:
        case SERIALIZATION_TYPE_U2:
            IfFailGo(ca.GetU2(&pNamedArgs[ix].val.u2));
            break;
            
        case SERIALIZATION_TYPE_I4:
        case SERIALIZATION_TYPE_U4:
            IfFailGo(ca.GetU4(&pNamedArgs[ix].val.u4));
            break;
            
        case SERIALIZATION_TYPE_I8:
        case SERIALIZATION_TYPE_U8:
            IfFailGo(ca.GetU8(&pNamedArgs[ix].val.u8));
            break;
            
        case SERIALIZATION_TYPE_R4:
            IfFailGo(ca.GetR4(&pNamedArgs[ix].val.r4));
            break;
            
        case SERIALIZATION_TYPE_R8:
            IfFailGo(ca.GetR8(&pNamedArgs[ix].val.r8));
            break;
            
        case SERIALIZATION_TYPE_STRING:
        case SERIALIZATION_TYPE_TYPE:
            pNamedArgs[ix].val.pStr = ca.GetString(&pNamedArgs[ix].val.cbStr);
            break;
            
        case SERIALIZATION_TYPE_ENUM:
            // Hope it is a 4-byte enum.
            IfFailGo(ca.GetU4(&pNamedArgs[ix].val.u4));
            break;
            
        case SERIALIZATION_TYPE_TAGGED_OBJECT:
            _ASSERTE(!"Variant for NamedArgument NYI");
            IfFailGo(PostError(META_E_CA_VARIANT_NYI));
            break;
            
        case SERIALIZATION_TYPE_SZARRAY:
            _ASSERTE(!"Array for NamedArgument NYI");
            IfFailGo(PostError(META_E_CA_ARRAY_NYI));
            break;
            
        case SERIALIZATION_TYPE_FIELD:
        case SERIALIZATION_TYPE_PROPERTY:
        default:
            IfFailGo(PostError(META_E_CA_UNEXPECTED_TYPE));
            break;
        } // End switch
    }
  
ErrExit:    
    return hr;
} // static HRESULT ParseKnownCaNamedArgs()

//*****************************************************************************
// Helper to parse argument list.
//*****************************************************************************
static HRESULT ParseKnownCaArgs(
    CustomAttributeParser &ca,          // The Custom Attribute blob.
    CaArg       *pArgs,                 // Array of argument descriptors.
    ULONG       cArgs)                  // Count of argument descriptors.
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       ix;                     // Loop control.
    
    // If there is a blob, check the prolog.
    if (ca.BytesLeft() < 2)
        IfFailGo(PostError(META_E_CA_INVALID_BLOB));
    if (ca.GetProlog() != 0x0001)
        IfFailGo(PostError(META_E_CA_INVALID_BLOB));
    
    // For each expected arg...
    for (ix=0; ix<cArgs; ++ix)
    {   
        // Grab the value.
        switch (pArgs[ix].type)
        {
        case SERIALIZATION_TYPE_BOOLEAN:
        case SERIALIZATION_TYPE_I1:
        case SERIALIZATION_TYPE_U1:
            IfFailGo(ca.GetU1(&pArgs[ix].val.u1));
            break;
        
        case SERIALIZATION_TYPE_CHAR:
        case SERIALIZATION_TYPE_I2:
        case SERIALIZATION_TYPE_U2:
            IfFailGo(ca.GetU2(&pArgs[ix].val.u2));
            break;
            
        case SERIALIZATION_TYPE_I4:
        case SERIALIZATION_TYPE_U4:
            IfFailGo(ca.GetU4(&pArgs[ix].val.u4));
            break;
            
        case SERIALIZATION_TYPE_I8:
        case SERIALIZATION_TYPE_U8:
            IfFailGo(ca.GetU8(&pArgs[ix].val.u8));
            break;
            
        case SERIALIZATION_TYPE_R4:
            IfFailGo(ca.GetR4(&pArgs[ix].val.r4));
            break;
            
        case SERIALIZATION_TYPE_R8:
            IfFailGo(ca.GetR8(&pArgs[ix].val.r8));
            break;
            
        case SERIALIZATION_TYPE_STRING:
        case SERIALIZATION_TYPE_TYPE:
            pArgs[ix].val.pStr = ca.GetString(&pArgs[ix].val.cbStr);
            break;
            
        default:
            _ASSERTE(!"Unexpected internal error");
            IfFailGo(PostError(E_FAIL));
            break;
        } // End switch
    }
    
ErrExit:    
    return hr;
} // static HRESULT ParseKnownCaArgs()

//*****************************************************************************
// Implementation of hash for custom attribute types.
//*****************************************************************************
unsigned long CCustAttrHash::Hash(const CCustAttrHashKey *pData)
{
    return static_cast<unsigned long>(pData->tkType);
} // unsigned long CCustAttrHash::Hash()
unsigned long CCustAttrHash::Compare(const CCustAttrHashKey *p1, CCustAttrHashKey *p2)
{
    if (p1->tkType == p2->tkType)
        return 0;
    return 1;
} // unsigned long CCustAttrHash::Compare()
CCustAttrHash::ELEMENTSTATUS CCustAttrHash::Status(CCustAttrHashKey *p)
{
    if (p->tkType == FREE)
        return (FREE);
    if (p->tkType == DELETED)
        return (DELETED);
    return (USED);
} // CCustAttrHash::ELEMENTSTATUS CCustAttrHash::Status()
void CCustAttrHash::SetStatus(CCustAttrHashKey *p, CCustAttrHash::ELEMENTSTATUS s)
{
    p->tkType = s;
} // void CCustAttrHash::SetStatus()
void* CCustAttrHash::GetKey(CCustAttrHashKey *p)
{
    return &p->tkType;
} // void* CCustAttrHash::GetKey()

//*****************************************************************************
// Create a CustomAttribute record from a blob with the specified parent.
//*****************************************************************************
STDMETHODIMP RegMeta::DefineCustomAttribute(// S_OK or error.
    mdToken     tkObj,                  // [IN] The object to be Attribute.
    mdToken     tkType,                 // [IN] Type of the custom Attribute (TypeRef/TypeDef).
    void const  *pCustomAttribute,      // [IN] Custom Attribute data.
    ULONG       cbCustomAttribute,      // [IN] Size of custom Attribute data.
    mdCustomAttribute *pcv)             // [OUT, OPTIONAL] Put custom Attribute token here.
{
    HRESULT     hr = S_OK;              // A result.
    CustomAttributeRec  *pRecord = NULL; // New custom Attribute record.
    RID         iRecord;                // New custom Attribute RID.
    CMiniMdRW   *pMiniMd = &m_pStgdb->m_MiniMd;
    int         ixKnown;                // Index of known custom attribute.

    LOG((LOGMD, "RegMeta::DefineCustomAttribute(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", tkObj, tkType, 
            pCustomAttribute, cbCustomAttribute, pcv));
    START_MD_PERF();
    LOCKWRITE();

    //workaround for temporary compiler glitch
//    if (tkType == 0 && pCustomAttribute == 0 && pcv == 0)
//    {
//        OutputDebugStringA("Skipping custom attribute of type '0'.\n");
//        goto ErrExit;
//    }
    _ASSERTE(TypeFromToken(tkType) == mdtMethodDef || TypeFromToken(tkType) == mdtMemberRef);
    
    if (TypeFromToken(tkObj) == mdtCustomAttribute)
        IfFailGo(E_INVALIDARG);

    m_pStgdb->m_MiniMd.PreUpdate();

    if (IsNilToken(tkObj) || 
        IsNilToken(tkType) ||
        (TypeFromToken(tkType) != mdtMethodDef &&
        TypeFromToken(tkType) != mdtMemberRef) )
    {
        IfFailGo( E_INVALIDARG );
    }

    // See if this is a known custom attribute.
    IfFailGo(_IsKnownCustomAttribute(tkType, &ixKnown));
    if (ixKnown)
    {
        int bKeep = false;
        hr = _HandleKnownCustomAttribute(tkObj, tkType, pCustomAttribute, cbCustomAttribute, ixKnown, &bKeep);
        if (pcv)
            *pcv = mdCustomAttributeNil;
        IfFailGo(hr);
        if (!bKeep)
            goto ErrExit;
    }
    

    if (((TypeFromToken(tkObj) == mdtTypeDef) || (TypeFromToken(tkObj) == mdtMethodDef)) &&
        (TypeFromToken(tkType) == mdtMethodDef || TypeFromToken(tkType) == mdtMemberRef))
    {
        CHAR        szBuffer[MAX_CLASS_NAME + 1];
        LPSTR       szName = szBuffer;
        LPCSTR      szNamespace;
        LPCSTR      szClass;
        TypeRefRec  *pTypeRefRec = NULL;
        TypeDefRec  *pTypeDefRec = NULL;
        mdToken     tkParent;

        if (TypeFromToken(tkType) == mdtMemberRef)
        {
            tkParent = pMiniMd->getClassOfMemberRef(pMiniMd->getMemberRef(RidFromToken(tkType)));
            if (TypeFromToken(tkParent) == mdtTypeRef)
            {
                pTypeRefRec = pMiniMd->getTypeRef(RidFromToken(tkParent));
                szNamespace = pMiniMd->getNamespaceOfTypeRef(pTypeRefRec);
                szClass = pMiniMd->getNameOfTypeRef(pTypeRefRec);
                ns::MakePath(szName, sizeof(szBuffer) - 1, szNamespace, szClass);
            }
            else if (TypeFromToken(tkParent) == mdtTypeDef)
                pTypeDefRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
        }
        else
        {
            IfFailGo(pMiniMd->FindParentOfMethodHelper(tkType, &tkParent));
            pTypeDefRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
        }

        if (pTypeDefRec)
        {
            szNamespace = pMiniMd->getNamespaceOfTypeDef(pTypeDefRec);
            szClass = pMiniMd->getNameOfTypeDef(pTypeDefRec);
            ns::MakePath(szName, sizeof(szBuffer) - 1, szNamespace, szClass);
        }

        if ((TypeFromToken(tkObj) == mdtMethodDef) && strcmp(szName, COR_REQUIRES_SECOBJ_ATTRIBUTE_ANSI) == 0)
        {
            // Turn REQ_SO attribute into flag bit on the methoddef. 
            MethodRec   *pMethod = m_pStgdb->m_MiniMd.getMethod(RidFromToken(tkObj));
            pMethod->m_Flags |= mdRequireSecObject;
            IfFailGo(UpdateENCLog(tkObj));
            goto ErrExit;
        }
        else if (strcmp(szName, COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI) == 0)
        {
            // If we spot an unmanged code check suppression attribute, turn on
            // the bit that says there's declarative security on the
            // class/method, but still write the attribute itself.
            if (TypeFromToken(tkObj) == mdtTypeDef)
                IfFailGo(_TurnInternalFlagsOn(tkObj, tdHasSecurity));
            else if (TypeFromToken(tkObj) == mdtMethodDef)
                IfFailGo(_TurnInternalFlagsOn(tkObj, mdHasSecurity));
            IfFailGo(UpdateENCLog(tkObj));
        }
    }
    
    IfNullGo(pRecord = m_pStgdb->m_MiniMd.AddCustomAttributeRecord(&iRecord));
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_CustomAttribute, CustomAttributeRec::COL_Type, pRecord, tkType));
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_CustomAttribute, CustomAttributeRec::COL_Parent, pRecord, tkObj));

    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_CustomAttribute, CustomAttributeRec::COL_Value, pRecord, pCustomAttribute, cbCustomAttribute));

    // Give token back to caller.
    if (pcv)
        *pcv = TokenFromRid(iRecord, mdtCustomAttribute);

    IfFailGo(m_pStgdb->m_MiniMd.AddCustomAttributesToHash(TokenFromRid(iRecord, mdtCustomAttribute)) );

    IfFailGo(UpdateENCLog(TokenFromRid(iRecord, mdtCustomAttribute)));
ErrExit:
    
    STOP_MD_PERF(DefineCustomAttribute);
    return (hr);
} // STDMETHODIMP RegMeta::DefineCustomAttribute()

//*****************************************************************************
// Replace the blob of an existing custom attribute.
//*****************************************************************************
STDMETHODIMP RegMeta::SetCustomAttributeValue(  // Return code.
    mdCustomAttribute tkAttr,               // [IN] The object to be Attributed.
    void const  *pCustomAttribute,          // [IN] Custom Attribute data.
    ULONG       cbCustomAttribute)          // [IN] Size of custom Attribute data.
{
    HRESULT     hr;
    LOCKWRITE();
    CustomAttributeRec  *pRecord = NULL;// Existing custom Attribute record.

    START_MD_PERF();
    _ASSERTE(TypeFromToken(tkAttr) == mdtCustomAttribute && !InvalidRid(tkAttr));

    // Retrieve and update the custom value.
    pRecord = m_pStgdb->m_MiniMd.getCustomAttribute(RidFromToken(tkAttr));
    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_CustomAttribute, CustomAttributeRec::COL_Value, pRecord, pCustomAttribute, cbCustomAttribute));

    IfFailGo(UpdateENCLog(tkAttr));
ErrExit:
    
    STOP_MD_PERF(SetCustomAttributeValue);
    return (hr);
} // STDMETHODIMP RegMeta::SetCustomAttributeValue()

//*****************************************************************************
// Get the value of a CustomAttribute, using only TypeName for lookup.
//*****************************************************************************
STDMETHODIMP RegMeta::GetCustomAttributeByName( // S_OK or error.
    mdToken     tkObj,                  // [IN] Object with Custom Attribute.
    LPCWSTR     wzName,                 // [IN] Name of desired Custom Attribute.
    const void  **ppData,               // [OUT] Put pointer to data here.
    ULONG       *pcbData)               // [OUT] Put size of data here.
{
    START_MD_PERF();
    LOCKREAD();

    HRESULT     hr;                     // A result.
    LPUTF8      szName;                 // Name in UFT8.
    int         iLen;                   // A length.
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);

    szName = (LPUTF8)_alloca(iLen=(int)(wcslen(wzName)*2 + 1));
    VERIFY(WszWideCharToMultiByte(CP_UTF8,0, wzName,-1, szName,iLen, 0,0));

    hr = ImportHelper::GetCustomAttributeByName(pMiniMd, tkObj, szName, ppData, pcbData);
     
//ErrExit:
    
    STOP_MD_PERF(GetCustomAttributeByName);
    return hr;
} // STDMETHODIMP RegMeta::GetCustomAttributeByName()

//*****************************************************************************
// Enumerate the CustomAttributes for a given token.
//*****************************************************************************
STDMETHODIMP RegMeta::EnumCustomAttributes(
    HCORENUM        *phEnum,            // Pointer to the enum.
    mdToken         tk,                 // Token to scope the enumeration.
    mdToken         tkType,             // Type to limit the enumeration.
    mdCustomAttribute   rCustomAttributes[],    // Put CustomAttributes here.
    ULONG           cMax,               // Max CustomAttributes to put.
    ULONG           *pcCustomAttributes)    // Put # tokens returned here.
{
    HENUMInternal   **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT         hr = S_OK;
    ULONG           cTokens = 0;
    ULONG           ridStart;
    ULONG           ridEnd;
    HENUMInternal   *pEnum = *ppmdEnum;
    CustomAttributeRec  *pRec;
    ULONG           index;
    
    LOG((LOGMD, "RegMeta::EnumCustomAttributes(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
            phEnum, tk, tkType, rCustomAttributes, cMax, pcCustomAttributes));
    START_MD_PERF();
    LOCKREAD();

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
        CLookUpHash     *pHashTable = pMiniMd->m_pLookUpHashs[TBL_CustomAttribute];

        // Does caller want all custom Values?
        if (IsNilToken(tk))
        {
            IfFailGo( HENUMInternal::CreateSimpleEnum(mdtCustomAttribute, 1, pMiniMd->getCountCustomAttributes()+1, &pEnum) );
        }
        else
        {   // Scope by some object.
            if ( pMiniMd->IsSorted( TBL_CustomAttribute ) )
            {
                // Get CustomAttributes for the object.
                ridStart = pMiniMd->getCustomAttributeForToken(tk, &ridEnd);

                if (IsNilToken(tkType))
                {
                    // Simple enumerator for object's entire list.
                    IfFailGo( HENUMInternal::CreateSimpleEnum( mdtCustomAttribute, ridStart, ridEnd, &pEnum) );
                }
                else
                {
                    // Dynamic enumerator for subsetted list.
                
                    IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtCustomAttribute, &pEnum) );               
                    
                    for (index = ridStart; index < ridEnd; index ++ )
                    {
                        pRec = pMiniMd->getCustomAttribute(index);
                        if (tkType == pMiniMd->getTypeOfCustomAttribute(pRec))
                        {
                            IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(index, mdtCustomAttribute) ) );
                        }
                    }
                }
            }
            else
            {

                if (pHashTable)
                {
                    // table is not sorted but hash is built
                    // We want to create dynmaic array to hold the dynamic enumerator.
                    TOKENHASHENTRY *p;
                    ULONG       iHash;
                    int         pos;
                    mdToken     tkParentTmp;
                    mdToken     tkTypeTmp;

                    // Hash the data.
                    iHash = pMiniMd->HashCustomAttribute(tk);

                    IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtCustomAttribute, &pEnum) );               

                    // Go through every entry in the hash chain looking for ours.
                    for (p = pHashTable->FindFirst(iHash, pos);
                         p;
                         p = pHashTable->FindNext(pos))
                    {
            
                        CustomAttributeRec *pCustomAttribute = pMiniMd->getCustomAttribute(RidFromToken(p->tok));
                        tkParentTmp = pMiniMd->getParentOfCustomAttribute(pCustomAttribute);
                        tkTypeTmp = pMiniMd->getTypeOfCustomAttribute(pCustomAttribute);
                        if (tkParentTmp == tk)
                        {
                            if (IsNilToken(tkType) || tkType == tkTypeTmp)
                            {
                                // compare the blob value
                                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(p->tok, mdtCustomAttribute )) );
                            }
                        }
                    }
                }
                else
                {

                    // table is not sorted and hash is not built so we have to create dynmaic array 
                    // create the dynamic enumerator and loop through CA table linearly
                    //
                    ridStart = 1;
                    ridEnd = pMiniMd->getCountCustomAttributes() + 1;
                
                    IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtCustomAttribute, &pEnum) );               
                
                    for (index = ridStart; index < ridEnd; index ++ )
                    {
                        pRec = pMiniMd->getCustomAttribute(index);
                        if ( tk == pMiniMd->getParentOfCustomAttribute(pRec) &&
                            (tkType == pMiniMd->getTypeOfCustomAttribute(pRec) || IsNilToken(tkType)))
                        {
                            IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(index, mdtCustomAttribute) ) );
                        }
                    }
                }
            }
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rCustomAttributes, pcCustomAttributes);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumCustomAttributes);
    return hr;
} // STDMETHODIMP RegMeta::EnumCustomAttributes()

//*****************************************************************************
// Get information about a CustomAttribute.   
//*****************************************************************************
STDMETHODIMP RegMeta::GetCustomAttributeProps(
    mdCustomAttribute   cv,                 // The attribute token
    mdToken     *ptkObj,                // [OUT, OPTIONAL] Put object token here.
    mdToken     *ptkType,               // [OUT, OPTIONAL] Put TypeDef/TypeRef token here.
    void const  **ppBlob,               // [OUT, OPTIONAL] Put pointer to data here.
    ULONG       *pcbSize)               // [OUT, OPTIONAL] Put size of data here.
{
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(TypeFromToken(cv) == mdtCustomAttribute);

    HRESULT     hr = S_OK;              // A result.
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    CustomAttributeRec  *pCustomAttributeRec;   // The custom value record.

    pCustomAttributeRec = pMiniMd->getCustomAttribute(RidFromToken(cv));

    if (ptkObj)
        *ptkObj = pMiniMd->getParentOfCustomAttribute(pCustomAttributeRec);

    if (ptkType)
        *ptkType = pMiniMd->getTypeOfCustomAttribute(pCustomAttributeRec);

    if (ppBlob)
        *ppBlob = pMiniMd->getValueOfCustomAttribute(pCustomAttributeRec, pcbSize);

//ErrExit:
    
    STOP_MD_PERF(GetCustomAttributeProps);
    return hr;
} // STDMETHODIMP RegMeta::GetCustomAttributeProps()

//*****************************************************************************
//*****************************************************************************
HRESULT RegMeta::_IsKnownCustomAttribute(        // S_OK, S_FALSE, or error.
    mdToken     tkType,                 // [IN] Token of custom attribute's type.
    int         *pca)                   // [OUT] Put value from KnownCustAttr enum here.
{
    HRESULT     hr = S_OK;              // A result.
    CCustAttrHashKey sLookup;           // For looking up a custom attribute.
    CCustAttrHashKey *pFound;           // Result of a lookup.
    LPCSTR      szNamespace = "";       // Namespace of custom attribute type.
    LPCSTR      szName = "";            // Name of custom attribute type.
    TypeDefRec  *pTypeDefRec = NULL;    // Parent record, when a TypeDef.
    TypeRefRec  *pTypeRefRec = NULL;    // Parent record, when a TypeRef.
    CMiniMdRW   *pMiniMd = &m_pStgdb->m_MiniMd;
    int         ixCa;                   // Index of Known CustomAttribute, or 0.
    int         i;                      // Loop control.
    mdToken     tkParent;
    
    *pca = 0;
    
    // Only for Custom Attributes.
    _ASSERTE(TypeFromToken(tkType) != mdtTypeRef && TypeFromToken(tkType) != mdtTypeDef);
    
    sLookup.tkType = tkType;
    
    // See if this custom attribute type has been seen before.
    if (pFound = m_caHash.Find(&sLookup))
    {   // Yes, already seen.
        *pca = pFound->ca;
        hr = (pFound->ca == CA_UNKNOWN) ? S_FALSE : S_OK;
        goto ErrExit;
    }
    
    // Hasn't been seen before.  See if it is well known.
    
    // Get the CA name.
    if (TypeFromToken(tkType) == mdtMemberRef)
    {
        MemberRefRec *pMember = pMiniMd->getMemberRef(RidFromToken(tkType));
        tkParent = pMiniMd->getClassOfMemberRef(pMember);
        if (TypeFromToken(tkParent) == mdtTypeRef)
        {
            pTypeRefRec = pMiniMd->getTypeRef(RidFromToken(tkParent));
            szNamespace = pMiniMd->getNamespaceOfTypeRef(pTypeRefRec);
            szName = pMiniMd->getNameOfTypeRef(pTypeRefRec);
        }
        else if (TypeFromToken(tkParent) == mdtTypeDef)
            pTypeDefRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
    }
    else
    {
        MethodRec *pMethod = pMiniMd->getMethod(RidFromToken(tkType));
        IfFailGo(pMiniMd->FindParentOfMethodHelper(tkType, &tkParent));
        pTypeDefRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
    }

    if (pTypeDefRec)
    {
        szNamespace = pMiniMd->getNamespaceOfTypeDef(pTypeDefRec);
        szName = pMiniMd->getNameOfTypeDef(pTypeDefRec);
    }

    // Search in list of Known CAs.
    for (ixCa=0, i=1; i<CA_COUNT; ++i)
    {
        if (strcmp(szName, rKnownCaProps[i]->szName) != 0)
            continue;
        if (strcmp(szNamespace, rKnownCaProps[i]->szNamespace) == 0)
        {
            // Some custom attributes have overloaded ctors.  For those, 
            //  see if this is the matching overload.
            if (rKnownCaProps[i]->bMatchBySig)
            {
                // Name matches.  Does the signature?
                PCCOR_SIGNATURE pSig = NULL;            // Signature of a method.
                ULONG       cbSig = 0;                  // Size of the signature.
                ULONG       cParams;                    // Count of signature parameters.
                ULONG       cb;                         // Size of an element
                ULONG       elem;                       // Signature element.
                ULONG       j;                          // Loop control.
                
                // Get the signature.
                if (TypeFromToken(tkType) == mdtMemberRef)
                {
                    MemberRefRec *pMember = pMiniMd->getMemberRef(RidFromToken(tkType));
                    pSig = pMiniMd->getSignatureOfMemberRef(pMember, &cbSig);
                }
                else
                {
                    MethodRec *pMethod = pMiniMd->getMethod(RidFromToken(tkType));
                    pSig = pMiniMd->getSignatureOfMethod(pMethod, &cbSig);
                }
                
                // Skip calling convention.
                cb = CorSigUncompressData(pSig, &elem);
                pSig += cb;
                cbSig -= cb;
                // Count of params.
                cb = CorSigUncompressData(pSig, &cParams);
                pSig += cb;
                cbSig -= cb;
    
                // If param count mismatch, not the right CA.
                if (cParams != rKnownCaProps[i]->cArgs)
                    continue;
    
                // Count is fine, check each param.  Skip return type (better be void).
                cb = CorSigUncompressData(pSig, &elem);
    			_ASSERTE(elem == ELEMENT_TYPE_VOID);
                pSig += cb;
                cbSig -= cb;
                for (j=0; j<cParams; ++j)
                {
                    // Get next element from method signature.
                    cb = CorSigUncompressData(pSig, &elem);
                    pSig += cb;
                    cbSig -= cb;
                    if (rKnownCaProps[i]->pArgs[j].type != elem)
                        break;
                }
    
                // All matched?
                if (j != cParams)
                    continue;
            }
            // All matched.
            ixCa = i;
            break;
        }
    }
    
    // Add to hash.
    sLookup.ca = ixCa;
    pFound = m_caHash.Add(&sLookup);
    IfNullGo(pFound);
    *pFound = sLookup;
    *pca = ixCa;
    
ErrExit:    
    return hr;
} // HRESULT RegMeta::_IsKnownCustomAttribute()

//*****************************************************************************
//*****************************************************************************
HRESULT RegMeta::_HandleKnownCustomAttribute(    // S_OK or error.
    mdToken     tkObj,                  // [IN] Object being attributed.
    mdToken     tkType,                 // [IN] Type of the custom attribute.
    const void  *pData,                 // [IN] Custom Attribute data blob.
    ULONG       cbData,                 // [IN] Count of bytes in the data.
    int         ixCa,                   // [IN] Value from KnownCustAttr enum.
    int         *bKeep)                 // [OUT] If true, keep the CA after processing.
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       ixTbl;                  // Index of table with object.
    void        *pRow;                  // Whatever sort of record it is.
    CMiniMdRW   *pMiniMd = &m_pStgdb->m_MiniMd;
    mdToken     tkObjType;              // Type of the object.
    ULONG       ix;                     // Loop control.
    KnownCaProp const *props=rKnownCaProps[ixCa]; // For convenience.
    CustomAttributeParser ca(pData, cbData);
    CQuickArray<CaArg>      qArgs;      // Un-named arguments.
    CQuickArray<CaNamedArg> qNamedArgs; // Named arguments.
    CQuickArray<BYTE>       qNativeType;// Native type string.
    
    _ASSERTE(ixCa > 0 && ixCa < CA_COUNT);
    *bKeep = props->bKeepCa || m_bKeepKnownCa;
    
    // Validate that target is valid for attribute.
    tkObjType = TypeFromToken(tkObj);
    for (ix=0; props->rTypes[ix]!=-1; ++ix)
    {
        if (props->rTypes[ix] == tkObjType)
            break;
    }
    // Was the type found in list of valid targets?
    if (props->rTypes[ix] == -1)
    {   // No, error.
        IfFailGo(PostError(META_E_CA_INVALID_TARGET));
    }
    // Get the row.
    ixTbl = pMiniMd->GetTblForToken(tkObj);
    _ASSERTE(ixTbl >= 0 && ixTbl <= TBL_COUNT);
    pRow = pMiniMd->getRow(ixTbl, RidFromToken(tkObj));
    
    // If this custom attribute expects any args...
    if (props->cArgs || props->cNamedArgs)
    {   // Initialize array ctor arg descriptors.
        IfFailGo(qArgs.ReSize(props->cArgs));
        for (ix=0; ix<props->cArgs; ++ix)
            qArgs[ix] = props->pArgs[ix];
        // Parse any ctor args (un-named, fixed args).
        IfFailGo(ParseKnownCaArgs(ca, qArgs.Ptr(), props->cArgs));
        
        // If this custom attribute accepts named args, parse them, or if there
        //  are un-used bytes, parse them.
        if (props->cNamedArgs || ca.BytesLeft() > 0)
        {   // Initialize array of named arg descriptors.
            IfFailGo(qNamedArgs.ReSize(props->cNamedArgs));
            for (ix=0; ix<props->cNamedArgs; ++ix)
                qNamedArgs[ix] = props->pNamedArgs[ix];
            // Parse named args.
            IfFailGo(ParseKnownCaNamedArgs(ca, qNamedArgs.Ptr(), props->cNamedArgs));
        }
    }
   
    switch (ixCa)
    {
    case CA_DllImportAttribute: 
        {
        // Validate parameters.
		if (qArgs[0].val.cbStr == 0 || qArgs[0].val.pStr == NULL)
		{
			// no name for DllImport. 
            IfFailGo(PostError(META_E_CA_INVALID_VALUE));
		}

        // Retrieve / create a ModuleRef on the dll name.
        mdModuleRef mrModule;
        CQuickArray<char> qDllName;
        IfFailGo(qDllName.ReSize(qArgs[0].val.cbStr+1));
        memcpy(qDllName.Ptr(),  qArgs[0].val.pStr, qArgs[0].val.cbStr);
        qDllName[qArgs[0].val.cbStr] = '\0';
        hr = ImportHelper::FindModuleRef(pMiniMd, qDllName.Ptr(), &mrModule);
        if (hr != S_OK)
        {
            MAKE_WIDEPTR_FROMUTF8(wzDllName, qDllName.Ptr());
            IfFailGo(_DefineModuleRef(wzDllName, &mrModule));
        }
        
        // Create a pinvoke map entry.
        ULONG dwFlags; dwFlags=0;
        // Was a calling convention set?
        if (qNamedArgs[DI_CallingConvention].val.tag)
        {   // Calling convention makes no sense on a field.
            if (TypeFromToken(tkObj) == mdtFieldDef)
                IfFailGo(PostError(META_E_CA_INVALID_ARG_FOR_TYPE, qNamedArgs[DI_CallingConvention].szName));
            // Turn off all callconv bits, then turn on specified value.
            dwFlags &= ~pmCallConvMask;
            switch (qNamedArgs[DI_CallingConvention].val.u4)
            { //@future: sigh.  keep in sync with System.Runtime.InteropServices.CallingConvention
            case 1: dwFlags |= pmCallConvWinapi;   break;
            case 2: dwFlags |= pmCallConvCdecl;    break;
            case 3: dwFlags |= pmCallConvStdcall;  break;
            case 4: dwFlags |= pmCallConvThiscall; break;
            case 5: dwFlags |= pmCallConvFastcall; break;
            default: 
				_ASSERTE(!"Flags are out of sync! ");
				break;
            }
        }
        else
        if (TypeFromToken(tkObj) == mdtMethodDef)
        {   // No calling convention specified for a method.  Default to pmCallConvWinApi.
            dwFlags = (dwFlags & ~pmCallConvMask) | pmCallConvWinapi;
        }
        
        // Charset
        if (qNamedArgs[DI_CharSet].val.tag)
        {   // Turn of all charset bits, then turn on specified bits.
            dwFlags &= ~pmCharSetMask;
            switch (qNamedArgs[DI_CharSet].val.u4)
            { //@future: keep in sync with System.Runtime.InteropServices.CharSet
            case 1: dwFlags |= pmCharSetNotSpec; break;
            case 2: dwFlags |= pmCharSetAnsi;    break;
            case 3: dwFlags |= pmCharSetUnicode; break;
            case 4: dwFlags |= pmCharSetAuto;    break;
            default: 
				_ASSERTE(!"Flags are out of sync! ");
				break;
            }
        }
        if (qNamedArgs[DI_ExactSpelling].val.u1)
            dwFlags |= pmNoMangle;
        if (qNamedArgs[DI_SetLastError].val.tag)
        {   // SetLastError makes no sense on a field.
            if (TypeFromToken(tkObj) == mdtFieldDef)
                IfFailGo(PostError(META_E_CA_INVALID_ARG_FOR_TYPE, qNamedArgs[DI_SetLastError].szName));
            if (qNamedArgs[DI_SetLastError].val.u1)
                dwFlags |= pmSupportsLastError;
        }
            
        // If an entrypoint name was specified, use it, otherrwise grab the name from the member.
        LPCWSTR wzEntry;
        if (qNamedArgs[DI_EntryPoint].val.tag)
        {
            MAKE_WIDEPTR_FROMUTF8N(wzEntryName, qNamedArgs[DI_EntryPoint].val.pStr, qNamedArgs[DI_EntryPoint].val.cbStr);
            wzEntry = wzEntryName;
        }
        else
        {
            LPCUTF8 szMember;
            if (TypeFromToken(tkObj) == mdtMethodDef)
            szMember = pMiniMd->getNameOfMethod(reinterpret_cast<MethodRec*>(pRow));
            MAKE_WIDEPTR_FROMUTF8(wzMemberName, szMember);
            wzEntry = wzMemberName;
        }

        // Set the miPreserveSig bit based on the value of the preserve sig flag.
        if (qNamedArgs[DI_PreserveSig].val.tag && !qNamedArgs[DI_PreserveSig].val.u1)
            reinterpret_cast<MethodRec*>(pRow)->m_ImplFlags &= ~miPreserveSig;
        else
            reinterpret_cast<MethodRec*>(pRow)->m_ImplFlags |= miPreserveSig;

        if (qNamedArgs[DI_BestFitMapping].val.tag)
        {
            if (qNamedArgs[DI_BestFitMapping].val.u1)
                dwFlags |= pmBestFitEnabled;
            else
                dwFlags |= pmBestFitDisabled;
        }

        if (qNamedArgs[DI_ThrowOnUnmappableChar].val.tag)
        {
            if (qNamedArgs[DI_ThrowOnUnmappableChar].val.u1)
                dwFlags |= pmThrowOnUnmappableCharEnabled;
            else
                dwFlags |= pmThrowOnUnmappableCharDisabled;          
        }
  
        // Finally, create the PInvokeMap entry.,
        IfFailGo(_DefinePinvokeMap(tkObj, dwFlags, wzEntry, mrModule));
        goto ErrExit;
        }
        break;
    
    case CA_GuidAttribute:
        { // Just verify the attribute.  It still gets stored as a real custom attribute.
        // format is "{01234567-0123-0123-0123-001122334455}"
        GUID guid;
        WCHAR wzGuid[40];
        int cch = qArgs[0].val.cbStr;
        
        // Guid should be 36 characters; need to add curlies.
        if (cch == 36)
        {
            WszMultiByteToWideChar(CP_UTF8, 0, qArgs[0].val.pStr,cch, wzGuid+1,39);
            wzGuid[0] = '{';
            wzGuid[37] = '}';
            wzGuid[38] = 0;
            hr = IIDFromString(wzGuid, &guid);
        }
        else 
            hr = META_E_CA_INVALID_UUID;
        if (hr != S_OK)
            IfFailGo(PostError(META_E_CA_INVALID_UUID));
        goto ErrExit;
        }
        break;
    
    case CA_ComImportAttribute:
        reinterpret_cast<TypeDefRec*>(pRow)->m_Flags |= tdImport;
        break;

    case CA_InterfaceTypeAttribute:
        {
            // Verify the attribute.
            if (qArgs[0].val.u4 > ifDispatch)
                IfFailGo(PostError(META_E_CA_INVALID_VALUE));
        }
        break;
        
    case CA_ClassInterfaceAttribute:
        {
            // Verify the attribute.
            if (qArgs[0].val.u4 > clsIfAutoDual)
                IfFailGo(PostError(META_E_CA_INVALID_VALUE));
        }
        break;

    case CA_SerializableAttribute:
        reinterpret_cast<TypeDefRec*>(pRow)->m_Flags |= tdSerializable;
        break;
    
    case CA_NonSerializedAttribute:
        reinterpret_cast<FieldRec*>(pRow)->m_Flags |= fdNotSerialized;
        break;
    
    case CA_InAttribute:
        reinterpret_cast<ParamRec*>(pRow)->m_Flags |= pdIn;
        break;
    
    case CA_OutAttribute:
        reinterpret_cast<ParamRec*>(pRow)->m_Flags |= pdOut;
        break;
    
    case CA_OptionalAttribute:
        reinterpret_cast<ParamRec*>(pRow)->m_Flags |= pdOptional;
        break;
    
    case CA_MethodImplAttribute2:
        // Force to wider value.
        qArgs[0].val.u4 = (unsigned)qArgs[0].val.i2;
        // Fall through to validation.
    case CA_MethodImplAttribute3:
        // Validate bits.
        if (qArgs[0].val.u4 & ~(miManagedMask | miForwardRef | miPreserveSig | miInternalCall | miSynchronized | miNoInlining))
            IfFailGo(PostError(META_E_CA_INVALID_VALUE));
        reinterpret_cast<MethodRec*>(pRow)->m_ImplFlags |= qArgs[0].val.u4;
        if (!qNamedArgs[MI_CodeType].val.tag)
            break;
        // fall through to set the code type.
    case CA_MethodImplAttribute1:
        {
        USHORT usFlags = reinterpret_cast<MethodRec*>(pRow)->m_ImplFlags;
        _ASSERTE(sizeof(usFlags) == sizeof(((MethodRec*)(0))->m_ImplFlags));
        if (qNamedArgs[MI_CodeType].val.i4 & ~(miCodeTypeMask))
            IfFailGo(PostError(META_E_CA_INVALID_VALUE));
        // Mask out old value, put in new one.
        usFlags = (usFlags & ~miCodeTypeMask) | qNamedArgs[MI_CodeType].val.i4;
        reinterpret_cast<MethodRec*>(pRow)->m_ImplFlags = usFlags;
        }
        break;
    
    case CA_MarshalAsAttribute:
        IfFailGo(_HandleNativeTypeCustomAttribute(tkObj, qArgs.Ptr(), qNamedArgs.Ptr(), qNativeType));
        break;
    
    case CA_PreserveSigAttribute:
        reinterpret_cast<MethodRec*>(pRow)->m_ImplFlags |= miPreserveSig;
        break;
    
    case CA_DebuggableAttribute:
        {
        // Get a copy of the flags to work with.
        ULONG dwFlags;
        dwFlags = reinterpret_cast<AssemblyRec*>(pRow)->m_Flags;
        _ASSERTE(sizeof(dwFlags) == sizeof(((AssemblyRec*)(0))->m_Flags));
        // First arg, fEnableJitCompileTracking.
 //       SetBitValue<ULONG>(dwFlags, afEnableJITcompileTracking, qArgs[0].val.i1);
        // Second arg, fDisableJITcompileOptimizer
 //       SetBitValue<ULONG>(dwFlags, afDisableJITcompileOptimizer, qArgs[1].val.i1);
        // Put the flags back.
        reinterpret_cast<AssemblyRec*>(pRow)->m_Flags = dwFlags;
        }
        break;
    
    case CA_StructLayoutAttribute1:
        {
        // Convert the I2 to a U2, then wide to an I4, then fall through.
        qArgs[0].val.i4 = static_cast<long>(static_cast<USHORT>(qArgs[0].val.i2));
        }
    case CA_StructLayoutAttribute2:
        {
        // Get a copy of the flags to work with.
        ULONG dwFlags;
        dwFlags = reinterpret_cast<TypeDefRec*>(pRow)->m_Flags;
        // Class layout.  Keep in sync with LayoutKind.
        switch (qArgs[0].val.i4)
        {
        case 0: // tdSequentialLayout:
            dwFlags = (dwFlags & ~tdLayoutMask) | tdSequentialLayout;
            break;
        case 2: // tdExplicitLayout:
            dwFlags = (dwFlags & ~tdLayoutMask) | tdExplicitLayout;
            break;
        case 3: // tdAutoLayout:
            dwFlags = (dwFlags & ~tdLayoutMask) | tdAutoLayout;
            break;
        default: 
            IfFailGo(PostError(META_E_CA_INVALID_VALUE)); 
            break;
        }

        // Class packing and size.
        ULONG ulSize, ulPack;
        ulPack = ulSize = ULONG_MAX;
        if (qNamedArgs[SL_Pack].val.tag)
        {    // Only 1,2,4,8,16,32,64,128 are legal values.
             ulPack = qNamedArgs[SL_Pack].val.u4;
             if ((ulPack > 128) || 
                 (ulPack & (ulPack-1)))
                 IfFailGo(PostError(META_E_CA_INVALID_VALUE)); 
        }
        if (qNamedArgs[SL_Size].val.tag)
        {
            if (qNamedArgs[SL_Size].val.u4 > INT_MAX)
                IfFailGo(PostError(META_E_CA_INVALID_VALUE));
            ulSize = qNamedArgs[SL_Size].val.u4;
        }
        if (ulPack!=ULONG_MAX || ulSize!=ULONG_MAX)
            IfFailGo(_SetClassLayout(tkObj, ulPack, ulSize));

        // Class character set.
        if (qNamedArgs[SL_CharSet].val.tag)
        {
            switch (qNamedArgs[SL_CharSet].val.u4)
            {
            //case 1: // Not specified.
            //    IfFailGo(PostError(META_E_CA_INVALID_VALUE)); 
            //    break;
            case 2: // ANSI
                dwFlags = (dwFlags & ~tdStringFormatMask) | tdAnsiClass;    
                break;
            case 3: // Unicode
                dwFlags = (dwFlags & ~tdStringFormatMask) | tdUnicodeClass; 
                break;
            case 4: // Auto
                dwFlags = (dwFlags & ~tdStringFormatMask) | tdAutoClass;    
                break;
            default: 
                IfFailGo(PostError(META_E_CA_INVALID_VALUE)); 
                break;
            }
        }
        
        // Persist possibly-changed value of flags.
        reinterpret_cast<TypeDefRec*>(pRow)->m_Flags = dwFlags;
        }
        break;
    
    case CA_FieldOffsetAttribute:
        if (qArgs[0].val.u4 > INT_MAX)
            IfFailGo(PostError(META_E_CA_INVALID_VALUE));
        IfFailGo(_SetFieldOffset(tkObj, qArgs[0].val.u4));
        break;
        
    default:
        _ASSERTE(!"Unexpected custom attribute type");
        // Turn into ordinary custom attribute.
        *bKeep = true;
        hr = S_OK;
        goto ErrExit;
        break;
    }
    
    IfFailGo(UpdateENCLog(tkObj));
    
ErrExit:    
    return hr;
} // HRESULT RegMeta::_HandleKnownCustomAttribute()


//*****************************************************************************
//*****************************************************************************
HRESULT RegMeta::_HandleNativeTypeCustomAttribute(// S_OK or error.
    mdToken     tkObj,                  // The token this CA is applied on.
    CaArg       *pArgs,                 // Pointer to args.
    CaNamedArg  *pNamedArgs,            // Pointer to named args.
    CQuickArray<BYTE> &qNativeType)     // Native type is built here.
{ 
    HRESULT     hr = S_OK;              // A result.
    int         cch;                    // Size of a string argument.
    ULONG       cb;                     // Count of some character operation.
    ULONG       cbNative;               // Size of native type string.
    ULONG       cbMax;                  // Max size of native type string.
    BYTE        *pbNative;              // Pointer into native type buffer.
    mdToken     tkObjType;              // The type of the token.
    mdToken     tkSetter;               // Token for Property setter.
    mdToken     tkGetter;               // Token for property getter.
    mdParamDef  tkParam;                // Parameter of getter/setter.
    ULONG       cParams;                // Count of params for getter/setter.
    HCORENUM    phEnum = 0;             // Enumerator for params.
    ULONG       ulSeq;                  // Sequence of a param.

    // Retrieve the type of the token.
    tkObjType = TypeFromToken(tkObj);
    
    // Compute maximum size of the native type.
    if (pArgs[0].val.i4 == NATIVE_TYPE_CUSTOMMARSHALER)
    {   // N_T_* + 3 string lengths
        cbMax = sizeof(ULONG) * 4;
        // Marshal type - name of the type
        cbMax += pNamedArgs[M_MarshalType].val.cbStr;
        // Marshal type - type of the custom marshaler
        cbMax += pNamedArgs[M_MarshalTypeRef].val.cbStr;
        // String cookie.
        cbMax += pNamedArgs[M_MarshalCookie].val.cbStr;
    }
    else if (pArgs[0].val.i4 == NATIVE_TYPE_SAFEARRAY)
    {   // N_T_* + safe array sub-type + string length. 
        cbMax = sizeof(ULONG) * 3;
        // Safe array record sub type.
        cbMax += pNamedArgs[M_SafeArrayUserDefinedSubType].val.cbStr;
    }
    else
    {   // N_T_* + sub-type + size + additive
        cbMax = sizeof(ULONG) * 4;
    }
    // Extra space to prevent buffer overrun.
    cbMax += 8;

    // Size the array.
    IfFailGo(qNativeType.ReSize(cbMax));
    pbNative = qNativeType.Ptr();
    cbNative = 0;

    //@FUTURE: check for valid combinations of args.
    
    // Put in the NativeType.
    cb = CorSigCompressData(pArgs[0].val.i4, pbNative);
    if (cb == ((ULONG)(-1)))
    {
        IfFailGo(PostError(META_E_CA_INVALID_BLOB));
    }

    cbNative += cb;
    pbNative += cb;
    if (cbNative > cbMax)
        IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

    // Put in additional information, depending on native type.
    switch (pArgs[0].val.i4)
    {
    case NATIVE_TYPE_FIXEDARRAY:
        // Validate that only fields valid for NATIVE_TYPE_FIXEDARRAY are set.
        if (pNamedArgs[M_SafeArraySubType].val.tag)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
        if (pNamedArgs[M_SizeParamIndex].val.tag)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

        // This native type is only applicable on fields.
        if (tkObjType != mdtFieldDef)
            IfFailGo(PostError(META_E_CA_NT_FIELDONLY));

        if (pNamedArgs[M_SizeConst].val.tag)
        {
            // Make sure the size is not negative.
            if (pNamedArgs[M_SizeConst].val.i4 < 0)
                IfFailGo(PostError(META_E_CA_NEGATIVE_CONSTSIZE));

            cb = CorSigCompressData(pNamedArgs[M_SizeConst].val.i4, pbNative);
            if (cb == ((ULONG)(-1)))
            {
                IfFailGo(PostError(META_E_CA_NEGATIVE_CONSTSIZE));
            }

        }
        else
        {
            cb = CorSigCompressData(1, pbNative);
            if (cb == ((ULONG)(-1)))
            {
                IfFailGo(PostError(META_E_CA_INVALID_BLOB));
            }
        }
        cbNative += cb;
        pbNative += cb;
        if (cbNative > cbMax)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

        // Is there a sub type?
        if (pNamedArgs[M_ArraySubType].val.tag)
        {
            // Put in the sub type.
            cb = CorSigCompressData(pNamedArgs[M_ArraySubType].val.i4, pbNative);
            if (cb == ((ULONG)(-1)))
            {
                IfFailGo(PostError(META_E_CA_INVALID_BLOB));
            }
            cbNative += cb;
            pbNative += cb;
            if (cbNative > cbMax)
                IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
        }
        break;

    case NATIVE_TYPE_FIXEDSYSSTRING:
        // Validate that the required fields are set.
        if (!pNamedArgs[M_SizeConst].val.tag)
            IfFailGo(PostError(META_E_CA_FIXEDSTR_SIZE_REQUIRED));

        // Validate that other array fields are not set.
        if (pNamedArgs[M_ArraySubType].val.tag)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
        if (pNamedArgs[M_SizeParamIndex].val.tag)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
        if (pNamedArgs[M_SafeArraySubType].val.tag)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

        // This native type is only applicable on fields.
        if (tkObjType != mdtFieldDef)
            IfFailGo(PostError(META_E_CA_NT_FIELDONLY));
            
        // Put in the constant value.
        cb = CorSigCompressData(pNamedArgs[M_SizeConst].val.i4, pbNative);
        if (cb == ((ULONG)(-1)))
        {
            IfFailGo(PostError(META_E_CA_INVALID_BLOB));
        }
        cbNative += cb;
        pbNative += cb;
        if (cbNative > cbMax)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
        break;
        
    case NATIVE_TYPE_BYVALSTR:
        // This native type is only applicable on parameters.
        if (tkObjType != mdtParamDef)
            IfFailGo(PostError(META_E_CA_INVALID_TARGET));
        break;

    case NATIVE_TYPE_SAFEARRAY:
        // Validate that other array fields are not set.
        if (pNamedArgs[M_ArraySubType].val.tag)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
        if (pNamedArgs[M_SizeParamIndex].val.tag)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
        if (pNamedArgs[M_SizeConst].val.tag)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

        // Is there a safe array sub type?
        if (pNamedArgs[M_SafeArraySubType].val.tag)
        {
            // Do some validation on the safe array sub type.
            if (pNamedArgs[M_SafeArraySubType].val.i4 == NATIVE_TYPE_CUSTOMMARSHALER)
                IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

            // Put in the safe array sub type.
            cb = CorSigCompressData(pNamedArgs[M_SafeArraySubType].val.i4, pbNative);
            if (cb == ((ULONG)(-1)))
            {
                IfFailGo(PostError(META_E_CA_INVALID_BLOB));
            }
            cbNative += cb;
            pbNative += cb;
            if (cbNative > cbMax)
                IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

            // When the SAFEARRAY contains user defined types, the type of the
            // UDT can be specified in the SafeArrayUserDefinedSubType field.
            if (pNamedArgs[M_SafeArrayUserDefinedSubType].val.tag)
            {
                // Validate that this is only set for valid VT's.
                if (pNamedArgs[M_SafeArraySubType].val.i4 != VT_RECORD && 
                    pNamedArgs[M_SafeArraySubType].val.i4 != VT_DISPATCH && 
                    pNamedArgs[M_SafeArraySubType].val.i4 != VT_UNKNOWN)
                {
                    IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
                }

                // Encode the size of the string.
                cch = pNamedArgs[M_SafeArrayUserDefinedSubType].val.cbStr;
                cb = CorSigCompressData(cch, pbNative);
                if (cb == ((ULONG)(-1)))
                    IfFailGo(PostError(META_E_CA_INVALID_BLOB));
                cbNative += cb;
                pbNative += cb;

                // Check that memcpy will fit and then encode the type name itself.
                if ((cbNative+cch) > cbMax)
                    IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
                memcpy(pbNative, pNamedArgs[M_SafeArrayUserDefinedSubType].val.pStr, cch);
                cbNative += cch;
                pbNative += cch;
                _ASSERTE(cbNative <= cbMax);
            }
        }
        break;
        
    case NATIVE_TYPE_ARRAY:
        // Validate that the array sub type is not set.
        if (pNamedArgs[M_SafeArraySubType].val.tag)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

        // Is there a sub type?
        if (pNamedArgs[M_ArraySubType].val.tag)
        {
			// Do some validation on the array sub type.
			if (pNamedArgs[M_ArraySubType].val.i4 == NATIVE_TYPE_CUSTOMMARSHALER)
	            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

            // Put in the sub type.
            cb = CorSigCompressData(pNamedArgs[M_ArraySubType].val.i4, pbNative);
            if (cb == ((ULONG)(-1)))
            {
                IfFailGo(PostError(META_E_CA_INVALID_BLOB));
            }
            cbNative += cb;
            pbNative += cb;
        }
        else
        {
            // Put in the sub type.
            cb = CorSigCompressData(NATIVE_TYPE_MAX, pbNative);
            if (cb == ((ULONG)(-1)))
            {
                IfFailGo(PostError(META_E_CA_INVALID_BLOB));
            }
            cbNative += cb;
            pbNative += cb;
        }
        if (cbNative > cbMax)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

        // Is there a parameter index?
        if (pNamedArgs[M_SizeParamIndex].val.tag)
        {   
            // Make sure the parameter index is not negative.
            if (pNamedArgs[M_SizeParamIndex].val.i4 < 0)
                IfFailGo(PostError(META_E_CA_NEGATIVE_PARAMINDEX));
            
            // Yes, put it in.
            cb = CorSigCompressData(pNamedArgs[M_SizeParamIndex].val.i4, pbNative);
            if (cb == ((ULONG)(-1)))
            {
                IfFailGo(PostError(META_E_CA_INVALID_BLOB));
            }
            cbNative += cb;
            pbNative += cb;
            if (cbNative > cbMax)
                IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
        
            // Is there a const?
            if (pNamedArgs[M_SizeConst].val.tag)
            {   
                // Make sure the size is not negative.
                if (pNamedArgs[M_SizeConst].val.i4 < 0)
                    IfFailGo(PostError(META_E_CA_NEGATIVE_CONSTSIZE));

                // Yes, put it in.
                cb = CorSigCompressData(pNamedArgs[M_SizeConst].val.i4, pbNative);
                if (cb == ((ULONG)(-1)))
                {
                    IfFailGo(PostError(META_E_CA_INVALID_BLOB));
                }
                cbNative += cb;
                pbNative += cb;
                if (cbNative > cbMax)
                    IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
            }
        }
        else
        {
            // Is there a const?
            if (pNamedArgs[M_SizeConst].val.tag)
            {   
                // Put in a param index of 0.
                cb = CorSigCompressData(0, pbNative);
                if (cb == ((ULONG)(-1)))
                {
                    IfFailGo(PostError(META_E_CA_INVALID_BLOB));
                }
                cbNative += cb;
                pbNative += cb;
                if (cbNative > cbMax)
                    IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
    
                // Put in the constant value.
                cb = CorSigCompressData(pNamedArgs[M_SizeConst].val.i4, pbNative);
                if (cb == ((ULONG)(-1)))
                {
                    IfFailGo(PostError(META_E_CA_INVALID_BLOB));
                }
                cbNative += cb;
                pbNative += cb;
                if (cbNative > cbMax)
                    IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
            }
        }
        break;
        
    case NATIVE_TYPE_CUSTOMMARSHALER:
        // Validate that the marshaler type field is set.
        if (!pNamedArgs[M_MarshalType].val.tag && !pNamedArgs[M_MarshalTypeRef].val.tag)
            IfFailGo(PostError(META_E_CA_CUSTMARSH_TYPE_REQUIRED));

        // Put in the place holder for the unmanaged typelib guid.
        cb = CorSigCompressData(0, pbNative);
        if (cb == ((ULONG)(-1)))
        {
            IfFailGo(PostError(META_E_CA_INVALID_BLOB));
        }
        cbNative += cb;
        pbNative += cb;
        if (cbNative > cbMax)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));

        // Put in the place holder for the unmanaged type name.
        cb = CorSigCompressData(0, pbNative);
        if (cb == ((ULONG)(-1)))
        {
            IfFailGo(PostError(META_E_CA_INVALID_BLOB));
        }
        cbNative += cb;
        pbNative += cb;
        if (cbNative > cbMax)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
        
        // Put in the marshaler type name.
        if (pNamedArgs[M_MarshalType].val.tag)
        {
            cch = pNamedArgs[M_MarshalType].val.cbStr;
            cb = CorSigCompressData(cch, pbNative);
            if (cb == ((ULONG)(-1)))
                IfFailGo(PostError(META_E_CA_INVALID_BLOB));
            cbNative += cb;
            pbNative += cb;
            // Check that memcpy will fit.
            if ((cbNative+cch) > cbMax)
                IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
            memcpy(pbNative, pNamedArgs[M_MarshalType].val.pStr, cch);
            cbNative += cch;
            pbNative += cch;
            _ASSERTE(cbNative <= cbMax);
        }
        else
        {
            cch = pNamedArgs[M_MarshalTypeRef].val.cbStr;
            cb = CorSigCompressData(cch, pbNative);
            if (cb == ((ULONG)(-1)))
                IfFailGo(PostError(META_E_CA_INVALID_BLOB));
            cbNative += cb;
            pbNative += cb;
            // Check that memcpy will fit.
            if ((cbNative+cch) > cbMax)
                IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
            memcpy(pbNative, pNamedArgs[M_MarshalTypeRef].val.pStr, cch);
            cbNative += cch;
            pbNative += cch;
            _ASSERTE(cbNative <= cbMax);
        }
        
        // Put in the cookie.
        cch = pNamedArgs[M_MarshalCookie].val.cbStr;
        cb = CorSigCompressData(cch, pbNative);
        if (cb == ((ULONG)(-1)))
        {
            IfFailGo(PostError(META_E_CA_INVALID_BLOB));
        }
        cbNative += cb;
        pbNative += cb;
        // Check that memcpy will fit.
        if ((cbNative+cch) > cbMax)
            IfFailGo(PostError(META_E_CA_INVALID_MARSHALAS_FIELDS));
        memcpy(pbNative, pNamedArgs[M_MarshalCookie].val.pStr, cch);
        cbNative += cch;
        pbNative += cch;
        break;
    }
    _ASSERTE(cbNative <= cbMax);
    
    // Resize to actual size.
    IfFailGo(qNativeType.ReSize(cbNative));
    
    // Now apply the native type to actual token.  If it is a property token,
    //  apply to the methods.
    switch (TypeFromToken(tkObj))
    {
    case mdtParamDef:
    case mdtFieldDef:
        IfFailGo(SetFieldMarshal(tkObj, (PCCOR_SIGNATURE)qNativeType.Ptr(), (DWORD)qNativeType.Size()));
        break;
    
    case mdtProperty:
        // Get any setter/getter methods.
        IfFailGo(GetPropertyProps(tkObj, 0,0,0,0,0,0,0,0,0,0, &tkSetter, &tkGetter, 0,0,0));
        // For getter, put the field marshal on the return value.
        if (!IsNilToken(tkGetter))
        {
            // Search for first param.
            mdToken tk;
            tkParam = mdParamDefNil;
            do {
                IfFailGo(EnumParams(&phEnum, tkGetter, &tk, 1, &cParams));
                if (cParams > 0)
                {
                    IfFailGo(GetParamProps(tk, 0, &ulSeq, 0,0,0,0,0,0,0));
                    if (ulSeq == 0)
                    {
                          tkParam = tk;
                          break;
                    }
                }
            
            } while (hr == S_OK);
            if (!IsNilToken(tkParam))
                IfFailGo(SetFieldMarshal(tkParam, (PCCOR_SIGNATURE)qNativeType.Ptr(), (DWORD)qNativeType.Size()));
            CloseEnum(phEnum);
            phEnum = 0;
        }
        if (!IsNilToken(tkSetter))
        {
            // Determine the last param.
            PCCOR_SIGNATURE pSig;
            ULONG cbSig;
            mdToken tk;
            ULONG iSeq;
            IfFailGo(GetMethodProps(tkSetter, 0,0,0,0,0, &pSig,&cbSig, 0,0));
            tkParam = mdParamDefNil;
            CorSigUncompressData(pSig+1, &iSeq);
            // Search for last param.
            if (iSeq != 0)
            {
                do {
                    IfFailGo(EnumParams(&phEnum, tkSetter, &tk, 1, &cParams));
                    if (cParams > 0)
                    {
                        IfFailGo(GetParamProps(tk, 0, &ulSeq, 0,0,0,0,0,0,0));
                        if (ulSeq == iSeq)
                        {
                            tkParam = tk;
                            break;
                        }
                    }
                } while (hr == S_OK);
            }
            // If found one that is not return value
            if (!IsNilToken(tkParam))
                IfFailGo(SetFieldMarshal(tkParam, (PCCOR_SIGNATURE)qNativeType.Ptr(), (DWORD)qNativeType.Size()));
            CloseEnum(phEnum);
            phEnum = 0;
        }
        break;
        
    default:
        _ASSERTE(!"Should not have this token type in _HandleNativeTypeCustomAttribute()");
        break;
    }
    
ErrExit:
    if (phEnum)
        CloseEnum(phEnum);
    return hr;    
} // HRESULT RegMeta::_HandleNativeTypeCustomAttribute()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\enc_peparse.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "..\enc\peparse.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\disp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Disp.cpp
//
// Implementation for the meta data dispenser code.
//
//*****************************************************************************
#include "stdafx.h"
#include "Disp.h"
#include "RegMeta.h"
#include "MdUtil.h"
#include <CorError.h>
#include <MDLog.h>
#include <ImpTlb.h>
#include <MdCommon.h>

//*****************************************************************************
// Ctor.
//*****************************************************************************
Disp::Disp() : m_cRef(0), m_Namespace(0)
{
#if defined(LOGGING)
    // InitializeLogging() calls scattered around the code.
    // @future: make this make some sense.
    InitializeLogging();
#endif

    m_OptionValue.m_DupCheck = MDDupDefault;
    m_OptionValue.m_RefToDefCheck = MDRefToDefDefault;
    m_OptionValue.m_NotifyRemap = MDNotifyDefault;
    m_OptionValue.m_UpdateMode = MDUpdateFull;
    m_OptionValue.m_ErrorIfEmitOutOfOrder = MDErrorOutOfOrderDefault;
    m_OptionValue.m_ThreadSafetyOptions = MDThreadSafetyDefault;
    m_OptionValue.m_GenerateTCEAdapters = FALSE;
    m_OptionValue.m_ImportOption = MDImportOptionDefault;
    m_OptionValue.m_LinkerOption = MDAssembly;
    m_OptionValue.m_RuntimeVersion = NULL;

} // Disp::Disp()

Disp::~Disp()
{
    if (m_OptionValue.m_RuntimeVersion)
        free(m_OptionValue.m_RuntimeVersion);
    if (m_Namespace)
        free(m_Namespace);
} // Disp::~Disp()

//*****************************************************************************
// Create a brand new scope.  This is based on the CLSID that was used to get
// the dispenser.
//*****************************************************************************
HRESULT Disp::DefineScope(              // Return code.
    REFCLSID    rclsid,                 // [in] What version to create.
    DWORD       dwCreateFlags,          // [in] Flags on the create.
    REFIID      riid,                   // [in] The interface desired.
    IUnknown    **ppIUnk)               // [out] Return interface on success.
{
    RegMeta     *pMeta = 0;
    HRESULT     hr = NOERROR;

    LOG((LF_METADATA, LL_INFO10, "Disp::DefineScope(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", rclsid, dwCreateFlags, riid, ppIUnk));

    // If it is a version we don't understand, then we cannot continue.
    if (rclsid != CLSID_CorMetaDataRuntime)
        return (CLDB_E_FILE_OLDVER);
        
    if (dwCreateFlags)
        return E_INVALIDARG;

// Testers need this flag for their tests.
#if 0
    const int prefixLen = 5;
    WCHAR szFileName[256 + prefixLen] = L"file:";
    DWORD len = WszGetEnvironmentVariable(L"COMP_ENCPE", szFileName+prefixLen, sizeof(szFileName)/sizeof(WCHAR));
    _ASSERTE(len < (sizeof(szFileName)/sizeof(WCHAR))-prefixLen);
    if (len > 0) 
    {
        //_ASSERTE(!"ENC override on DefineScope");
        m_OptionValue.m_UpdateMode = MDUpdateENC;
        m_OptionValue.m_ErrorIfEmitOutOfOrder = MDErrorOutOfOrderDefault;
        hr = OpenScope(szFileName, ofWrite, riid, ppIUnk);
        // print out a message so people know what's happening
        printf("Defining scope for EnC using %S %s\n", 
                            szFileName+prefixLen, SUCCEEDED(hr) ? "succeeded" : "failed");
        return hr;
    }
#endif

    // Create a new coclass for this guy.
    pMeta = new RegMeta(&m_OptionValue);
    IfNullGo( pMeta );

    // Remember the open type.
    pMeta->SetScopeType(DefineForWrite);

    IfFailGo(pMeta->Init());

    // Get the requested interface.
    IfFailGo(pMeta->QueryInterface(riid, (void **) ppIUnk));
    
    // Create the MiniMd-style scope.
    IfFailGo(pMeta->PostInitForWrite());

    // Add the new RegMeta to the cache.
    IfFailGo(pMeta->AddToCache());
    
    LOG((LOGMD, "{%08x} Created new emit scope\n", pMeta));

ErrExit:
    if (FAILED(hr))
    {
        if (pMeta) delete pMeta;
    }
    return (hr);
} // HRESULT Disp::DefineScope()


//*****************************************************************************
// Open an existing scope.
//*****************************************************************************
HRESULT Disp::OpenScope(                // Return code.
    LPCWSTR     szFileName,             // [in] The scope to open.
    DWORD       dwOpenFlags,            // [in] Open mode flags.
    REFIID      riid,                   // [in] The interface desired.
    IUnknown    **ppIUnk)               // [out] Return interface on success.
{
    RegMeta     *pMeta = 0;
    HRESULT     hr;
    bool        bCompressed = false;    // If true, opened a MiniMd.
    bool        bWriteable;             // If true, open for write.
    HRESULT     hrOld = NOERROR;        // Saved failure code from attempted open.

    LOG((LF_METADATA, LL_INFO10, "Disp::OpenScope(%S, 0x%08x, 0x%08x, 0x%08x)\n", MDSTR(szFileName), dwOpenFlags, riid, ppIUnk));

    // Validate that there is some sort of file name.
    if (!szFileName || !szFileName[0] || !ppIUnk)
        return E_INVALIDARG;

    // Create a new coclass for this guy.
    pMeta = new RegMeta(&m_OptionValue);
    IfNullGo( pMeta );

    bWriteable = (dwOpenFlags & ofWrite) != 0;
    pMeta->SetScopeType(bWriteable ? OpenForWrite : OpenForRead);

    // Always initialize the RegMeta's stgdb. 
    // @FUTURE: there are some cleanup for the open code!!
    if (memcmp(szFileName, L"file:", 10) == 0)
	{
		// _ASSERTE(!"Meichint - Should not depends on file: anymore");
        szFileName = &szFileName[5];
	}

    // Try to open the MiniMd-style scope.
    hr = pMeta->PostInitForRead(szFileName, 0,0,0, false);

    bCompressed = (hr == S_OK);

#if defined(_DEBUG)
    // If we failed to open it, but it is a type library, try to import it.
    if (FAILED(hr) && (dwOpenFlags & ofNoTypeLib) == 0)
    {
        HRESULT     hrImport;               // Result from typelib import.
        if (REGUTIL::GetConfigDWORD(L"MD_AutoTlb", 0))
        {
            // This call spins up the runtime as a side-effect.
            pMeta->DefineSecurityAttributeSet(0,0,0,0);

            // Don't need this import meta any more.
            delete pMeta;
            pMeta = 0;
                
            // remember the old failure
            hrOld = hr;
                
            // Make sure it really is a typelib.
            ITypeLib *pITypeLib = 0;
            // Don't register; registering WFC messes up the system.
            IfFailGo(LoadTypeLibEx(szFileName, REGKIND_NONE/*REGKIND_REGISTER*/, &pITypeLib));
                
            // Create and initialize a TypeLib importer.
            CImportTlb importer(szFileName, pITypeLib, m_OptionValue.m_GenerateTCEAdapters, FALSE, FALSE, FALSE);
            pITypeLib->Release();
    
            // If a namespace is specified, use it.
            if (m_Namespace)
                importer.SetNamespace(m_Namespace);
			else
				importer.SetNamespace(L"TlbImp");
    
            // Attempt the conversion.
            IfFailGo(importer.Import());
            hrImport = hr;
    
            // Grab the appropriate interface.
            IfFailGo(importer.GetInterface(riid, reinterpret_cast<void**>(ppIUnk)));
    
            // Restore the possibly non-zero success code.
            hr = hrImport;
    
            goto ErrExit;
        }
    }
#endif
    // Check the return code from most recent operation.
    IfFailGo( hr );

    // Let the RegMeta cache the scope.
    pMeta->Init();

    // call PostOpen
    IfFailGo( pMeta->PostOpen() );

    // Return the requested interface.
    IfFailGo( pMeta->QueryInterface(riid, (void **) ppIUnk) );

    // Add the new RegMeta to the cache.
    IfFailGo(pMeta->AddToCache());
    
    LOG((LOGMD, "{%08x} Successfully opened '%S'\n", pMeta, MDSTR(szFileName)));

ErrExit:
    if (FAILED(hr))
    {
        if (pMeta) delete pMeta;
    }
    if (FAILED(hr) && FAILED(hrOld))
        return hrOld;
    return (hr);
} // HRESULT Disp::OpenScope()


//*****************************************************************************
// Open an existing scope.
//*****************************************************************************
HRESULT Disp::OpenScopeOnMemory(        // Return code.
    LPCVOID     pData,                  // [in] Location of scope data.
    ULONG       cbData,                 // [in] Size of the data pointed to by pData.
    DWORD       dwOpenFlags,            // [in] Open mode flags.
    REFIID      riid,                   // [in] The interface desired.
    IUnknown    **ppIUnk)               // [out] Return interface on success.
{
    RegMeta     *pMeta = 0;
    HRESULT     hr;
    bool        bCompressed = false;    // If true, opened a MiniMd.
    bool        bWriteable;             // If true, open for write.
    bool        fFreeMemory = false;    // set to true if we make a copy of the memory that host passes in.
    void        *pbData = const_cast<void*>(pData);

    LOG((LF_METADATA, LL_INFO10, "Disp::OpenScopeOnMemory(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", pData, cbData, dwOpenFlags, riid, ppIUnk));

    // Create a new coclass for this guy.
    pMeta = new RegMeta(&m_OptionValue);
    if (!pMeta)
        return (OutOfMemory());

    bWriteable = (dwOpenFlags & ofWrite) != 0;
    pMeta->SetScopeType(bWriteable ? OpenForWrite : OpenForRead);

    // Always initialize the RegMeta's stgdb. 
    if (dwOpenFlags &  ofCopyMemory)
    {
        fFreeMemory = true;
        pbData = malloc(cbData);
        IfNullGo(pbData);
        memcpy(pbData, pData, cbData);
    }
    hr = pMeta->PostInitForRead(0, pbData, cbData, 0, fFreeMemory);
    bCompressed = (hr == S_OK);
    IfFailGo( hr );

    // Let the RegMeta cache the scope.
    pMeta->Init();

    // call PostOpen to cache the global typedef.
    IfFailGo( pMeta->PostOpen() );

    // Return the requested interface.
    IfFailGo( pMeta->QueryInterface(riid, (void **) ppIUnk) );

    // Add the new RegMeta to the cache.
    IfFailGo(pMeta->AddToCache());
    
    LOG((LOGMD, "{%08x} Opened new scope on memory, pData: %08x    cbData: %08x\n", pMeta, pData, cbData));

ErrExit:
    if (FAILED(hr))
    {
        if (pMeta) delete pMeta;
    }
    return (hr);
} // HRESULT Disp::OpenScopeOnMemory()


//*****************************************************************************
// Get the directory where the CLR system resides.
//*****************************************************************************
HRESULT Disp::GetCORSystemDirectory(    // Return code.
     LPWSTR     szBuffer,               // [out] Buffer for the directory name
     DWORD      cchBuffer,              // [in] Size of the buffer
     DWORD      *pchBuffer)             // [OUT] Number of characters returned
{
     HRESULT    hr;                     // A result.
     if (!pchBuffer)
         return E_INVALIDARG;
    
     IfFailRet(SetInternalSystemDirectory());

     DWORD lgth = cchBuffer;
     hr = ::GetInternalSystemDirectory(szBuffer, &lgth);
     *pchBuffer = lgth;
     return hr;
} // HRESULT Disp::GetCORSystemDirectory()


HRESULT Disp::FindAssembly(             // S_OK or error
    LPCWSTR     szAppBase,              // [IN] optional - can be NULL
    LPCWSTR     szPrivateBin,           // [IN] optional - can be NULL
    LPCWSTR     szGlobalBin,            // [IN] optional - can be NULL
    LPCWSTR     szAssemblyName,         // [IN] required - this is the assembly you are requesting
    LPCWSTR     szName,                 // [OUT] buffer - to hold name 
    ULONG       cchName,                // [IN] the name buffer's size
    ULONG       *pcName)                // [OUT] the number of characters returend in the buffer
{
    return E_NOTIMPL;
} // HRESULT Disp::FindAssembly()

HRESULT Disp::FindAssemblyModule(       // S_OK or error
    LPCWSTR     szAppBase,              // [IN] optional - can be NULL
    LPCWSTR     szPrivateBin,           // [IN] optional - can be NULL
    LPCWSTR     szGlobalBin,            // [IN] optional - can be NULL
    LPCWSTR     szAssemblyName,         // [IN] The assembly name or code base of the assembly
    LPCWSTR     szModuleName,           // [IN] required - the name of the module
    LPWSTR      szName,                 // [OUT] buffer - to hold name 
    ULONG       cchName,                // [IN]  the name buffer's size
    ULONG       *pcName)                // [OUT] the number of characters returend in the buffer
{
    return E_NOTIMPL;
} // HRESULT Disp::FindAssemblyModule()

//*****************************************************************************
// Open a scope on an ITypeInfo
//*****************************************************************************
HRESULT Disp::OpenScopeOnITypeInfo(     // Return code.
    ITypeInfo   *pITI,                  // [in] ITypeInfo to open.
    DWORD       dwOpenFlags,            // [in] Open mode flags.
    REFIID      riid,                   // [in] The interface desired.
    IUnknown    **ppIUnk)               // [out] Return interface on success.
{
    RegMeta     *pMeta = 0;
    HRESULT     hr;
    mdTypeDef   cl;

    LOG((LF_METADATA, LL_INFO10, "Disp::OpenScopeOnITypeInfo(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", pITI, dwOpenFlags, riid, ppIUnk));

    // Validate that there is some sort of file name.
    if (!pITI || !ppIUnk)
        return E_INVALIDARG;

    // Create and initialize a TypeLib importer.
    CImportTlb importer;

    // If a namespace is specified, use it.
    if (m_Namespace)
        importer.SetNamespace(m_Namespace);

    // Attempt the conversion.
    IfFailGo(importer.ImportTypeInfo(pITI, &cl));

    // Grab the appropriate interface.
    IfFailGo(importer.GetInterface(riid, reinterpret_cast<void**>(ppIUnk)));

    LOG((LOGMD, "{%08x} Opened scope on typeinfo %08x\n", this, pITI));

ErrExit:
    return (hr);
} // HRESULT Disp::OpenScopeOnITypeInfo()


//*****************************************************************************
// IUnknown
//*****************************************************************************

ULONG Disp::AddRef()
{
    return (InterlockedIncrement((long *) &m_cRef));
} // ULONG Disp::AddRef()

ULONG Disp::Release()
{
    ULONG   cRef = InterlockedDecrement((long *) &m_cRef);
    if (!cRef)
        delete this;
    return (cRef);
} // ULONG Disp::Release()

HRESULT Disp::QueryInterface(REFIID riid, void **ppUnk)
{
    *ppUnk = 0;

    if (riid == IID_IUnknown)
        *ppUnk = (IUnknown *) (IMetaDataDispenser *) this;
    else if (riid == IID_IMetaDataDispenser)
        *ppUnk = (IMetaDataDispenser *) this;
    else if (riid == IID_IMetaDataDispenserEx)
        *ppUnk = (IMetaDataDispenserEx *) this;
    else
        return (E_NOINTERFACE);
    AddRef();
    return (S_OK);
} // HRESULT Disp::QueryInterface()


//*****************************************************************************
// Called by the class factory template to create a new instance of this object.
//*****************************************************************************
HRESULT Disp::CreateObject(REFIID riid, void **ppUnk)
{ 
    HRESULT     hr;
    Disp *pDisp = new Disp();

    if (pDisp == 0)
        return (E_OUTOFMEMORY);

    hr = pDisp->QueryInterface(riid, ppUnk);
    if (FAILED(hr))
        delete pDisp;
    return (hr);
} // HRESULT Disp::CreateObject()

//*****************************************************************************
// This routine provides the user a way to set certain properties on the
// Dispenser.
//*****************************************************************************
HRESULT Disp::SetOption(                // Return code.
    REFGUID     optionid,               // [in] GUID for the option to be set.
    const VARIANT *pvalue)              // [in] Value to which the option is to be set.
{
    LOG((LF_METADATA, LL_INFO10, "Disp::SetOption(0x%08x, 0x%08x)\n", optionid, pvalue));

    if (optionid == MetaDataCheckDuplicatesFor)
    {
        if (V_VT(pvalue) != VT_UI4)
        {
            _ASSERTE(!"Invalid Variant Type value!");
            return E_INVALIDARG;
        }
        m_OptionValue.m_DupCheck = (CorCheckDuplicatesFor) V_UI4(pvalue);
    }
    else if (optionid == MetaDataRefToDefCheck)
    {
        if (V_VT(pvalue) != VT_UI4)
        {
            _ASSERTE(!"Invalid Variant Type value!");
            return E_INVALIDARG;
        }
        m_OptionValue.m_RefToDefCheck = (CorRefToDefCheck) V_UI4(pvalue);
    }
    else if (optionid == MetaDataNotificationForTokenMovement)
    {
        if (V_VT(pvalue) != VT_UI4)
        {
            _ASSERTE(!"Invalid Variant Type value!");
            return E_INVALIDARG;
        }
        m_OptionValue.m_NotifyRemap = (CorNotificationForTokenMovement)V_UI4(pvalue);
    }
    else if (optionid == MetaDataSetENC)
    {
        if (V_VT(pvalue) != VT_UI4)
        {
            _ASSERTE(!"Invalid Variant Type value!");
            return E_INVALIDARG;
        }
        m_OptionValue.m_UpdateMode = V_UI4(pvalue);
    }
    else if (optionid == MetaDataErrorIfEmitOutOfOrder)
    {
        if (V_VT(pvalue) != VT_UI4)
        {
            _ASSERTE(!"Invalid Variant Type value!");
            return E_INVALIDARG;
        }
        m_OptionValue.m_ErrorIfEmitOutOfOrder = (CorErrorIfEmitOutOfOrder) V_UI4(pvalue);
    }
    else if (optionid == MetaDataImportOption)
    {
        if (V_VT(pvalue) != VT_UI4)
        {
            _ASSERTE(!"Invalid Variant Type value!");
            return E_INVALIDARG;
        }
        m_OptionValue.m_ImportOption = (CorImportOptions) V_UI4(pvalue);
    }
    else if (optionid == MetaDataThreadSafetyOptions)
    {
        if (V_VT(pvalue) != VT_UI4)
        {
            _ASSERTE(!"Invalid Variant Type value!");
            return E_INVALIDARG;
        }
        m_OptionValue.m_ThreadSafetyOptions = (CorThreadSafetyOptions) V_UI4(pvalue);
    }
    else if (optionid == MetaDataGenerateTCEAdapters)
    {
        if (V_VT(pvalue) != VT_BOOL)
        {
            _ASSERTE(!"Invalid Variant Type value!");
            return E_INVALIDARG;
        }
        m_OptionValue.m_GenerateTCEAdapters = V_BOOL(pvalue);
    }
    else if (optionid == MetaDataTypeLibImportNamespace)
    {
        if (V_VT(pvalue) != VT_BSTR && V_VT(pvalue) != VT_EMPTY && V_VT(pvalue) != VT_NULL)
        {
            _ASSERTE(!"Invalid Variant Type value for namespace.");
            return E_INVALIDARG;
        }
        if (m_Namespace)
            free(m_Namespace);
        if (V_VT(pvalue) == VT_EMPTY || V_VT(pvalue) == VT_NULL || V_BSTR(pvalue) == 0 || *V_BSTR(pvalue) == 0)
            m_Namespace = 0;
        else
        {
            m_Namespace = reinterpret_cast<WCHAR*>(malloc( sizeof(WCHAR) * (1 + wcslen(V_BSTR(pvalue))) ) );
            if (m_Namespace == 0)
                return E_OUTOFMEMORY;
            wcscpy(m_Namespace, V_BSTR(pvalue));
        }
    }
    else if (optionid == MetaDataLinkerOptions)
    {
        if (V_VT(pvalue) != VT_UI4)
        {
            _ASSERTE(!"Invalid Variant Type value!");
            return E_INVALIDARG;
        }
        m_OptionValue.m_LinkerOption = (CorLinkerOptions) V_UI4(pvalue);
    }
    else if (optionid == MetaDataRuntimeVersion)
    {
        if (V_VT(pvalue) != VT_BSTR && V_VT(pvalue) != VT_EMPTY && V_VT(pvalue) != VT_NULL)
        {
            _ASSERTE(!"Invalid Variant Type value for version.");
            return E_INVALIDARG;
        }
        if (m_OptionValue.m_RuntimeVersion)
            free(m_OptionValue.m_RuntimeVersion);

        if (V_VT(pvalue) == VT_EMPTY || V_VT(pvalue) == VT_NULL || V_BSTR(pvalue) == 0 || *V_BSTR(pvalue) == 0)
            m_RuntimeVersion = 0;
        else {
            INT32 len = WszWideCharToMultiByte(CP_UTF8, 0, V_BSTR(pvalue), -1, NULL, 0, NULL, NULL);
            m_OptionValue.m_RuntimeVersion = (LPSTR) malloc(len);
            if (m_OptionValue.m_RuntimeVersion == NULL)
                return E_OUTOFMEMORY;
            WszWideCharToMultiByte(CP_UTF8, 0, V_BSTR(pvalue), -1, m_OptionValue.m_RuntimeVersion, len, NULL, NULL);
        }
    }
    else
    {
        _ASSERTE(!"Invalid GUID");
        return E_INVALIDARG;
    }
    return S_OK;
} // HRESULT Disp::SetOption()

//*****************************************************************************
// This routine provides the user a way to set certain properties on the
// Dispenser.
//*****************************************************************************
HRESULT Disp::GetOption(                // Return code.
    REFGUID     optionid,               // [in] GUID for the option to be set.
    VARIANT *pvalue)                    // [out] Value to which the option is currently set.
{
    LOG((LF_METADATA, LL_INFO10, "Disp::GetOption(0x%08x, 0x%08x)\n", optionid, pvalue));

    _ASSERTE(pvalue);
    if (optionid == MetaDataCheckDuplicatesFor)
    {
        V_VT(pvalue) = VT_UI4;
        V_UI4(pvalue) = m_OptionValue.m_DupCheck;
    }
    else if (optionid == MetaDataRefToDefCheck)
    {
        V_VT(pvalue) = VT_UI4;
        V_UI4(pvalue) = m_OptionValue.m_RefToDefCheck;
    }
    else if (optionid == MetaDataNotificationForTokenMovement)
    {
        V_VT(pvalue) = VT_UI4;
        V_UI4(pvalue) = m_OptionValue.m_NotifyRemap;
    }
    else if (optionid == MetaDataSetENC)
    {
        V_VT(pvalue) = VT_UI4;
        V_UI4(pvalue) = m_OptionValue.m_UpdateMode;
    }
    else if (optionid == MetaDataErrorIfEmitOutOfOrder)
    {
        V_VT(pvalue) = VT_UI4;
        V_UI4(pvalue) = m_OptionValue.m_ErrorIfEmitOutOfOrder;
    }
    else if (optionid == MetaDataGenerateTCEAdapters)
    {
        V_VT(pvalue) = VT_BOOL;
        V_BOOL(pvalue) = m_OptionValue.m_GenerateTCEAdapters;
    }
    else if (optionid == MetaDataLinkerOptions)
    {
        V_VT(pvalue) = VT_BOOL;
        V_UI4(pvalue) = m_OptionValue.m_LinkerOption;
    }
    else
    {
        _ASSERTE(!"Invalid GUID");
        return E_INVALIDARG;
    }
    return S_OK;
} // HRESULT Disp::GetOption()


//*****************************************************************************
// Process attach initialization.
//*****************************************************************************
static DWORD LoadedModulesReadWriteLock[sizeof(UTSemReadWrite)/sizeof(DWORD) + sizeof(DWORD)];
void InitMd()
{
    LOADEDMODULES::m_pSemReadWrite = new((void*)LoadedModulesReadWriteLock) UTSemReadWrite;
} // void InitMd()

//*****************************************************************************
// Process attach cleanup.
//*****************************************************************************
void UninitMd()
{
    if (LOADEDMODULES::m_pSemReadWrite)
    {
        LOADEDMODULES::m_pSemReadWrite->~UTSemReadWrite();
        LOADEDMODULES::m_pSemReadWrite = 0;
    }
} // void UninitMd()


// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\emit.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Emit.cpp
//
// Implementation for the meta data emit code.
//
//*****************************************************************************
#include "stdafx.h"
#include "RegMeta.h"
#include "MDUtil.h"
#include "RWUtil.h"
#include "MDLog.h"
#include "ImportHelper.h"

#pragma warning(disable: 4102)

//*****************************************************************************
// Saves a copy of the scope into the memory buffer provided.  The buffer size
// must be at least as large as the GetSaveSize value.
//*****************************************************************************
STDAPI RegMeta::SaveToMemory(           // S_OK or error.
    void        *pbData,                // [OUT] Location to write data.
    ULONG       cbData)                 // [IN] Max size of data buffer.
{
    IStream     *pStream = 0;           // Working pointer for save.
    HRESULT     hr;

    LOG((LOGMD, "MD RegMeta::SaveToMemory(0x%08x, 0x%08x)\n", 
        pbData, cbData));
    START_MD_PERF();

#ifdef _DEBUG
    ULONG       cbActual;               // Size of the real data.
    IfFailGo(GetSaveSize(cssAccurate, &cbActual));
    _ASSERTE(cbData >= cbActual);
    _ASSERTE(IsBadWritePtr(pbData, cbData) == false);
#endif

    { // cannot lock before the debug statement. Because GetSaveSize is also a public API which will take the Write lock.
        LOCKWRITE();
        m_pStgdb->m_MiniMd.PreUpdate();
        // Create a stream interface on top of the user's data buffer, then simply
        // call the save to stream method.
        IfFailGo(CInMemoryStream::CreateStreamOnMemory(pbData, cbData, &pStream));
        IfFailGo(_SaveToStream(pStream, 0));
        
    }
ErrExit:
    if (pStream)
        pStream->Release();
    STOP_MD_PERF(SaveToMemory);
    return (hr);
} // STDAPI RegMeta::SaveToMemory()



//*****************************************************************************
// Create and set a new MethodDef record.
//*****************************************************************************
STDAPI RegMeta::DefineMethod(           // S_OK or error.
    mdTypeDef   td,                     // Parent TypeDef
    LPCWSTR     szName,                 // Name of member
    DWORD       dwMethodFlags,          // Member attributes
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
    ULONG       ulCodeRVA,
    DWORD       dwImplFlags,
    mdMethodDef *pmd)                   // Put member token here
{
    HRESULT     hr = S_OK;              // A result.
    MethodRec   *pRecord = NULL;        // The new record.
    RID         iRecord;                // The new record's RID.
    LPUTF8      szNameUtf8 = UTF8STR(szName);   

    LOG((LOGMD, "MD: RegMeta::DefineMethod(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        td, MDSTR(szName), dwMethodFlags, pvSigBlob, cbSigBlob, ulCodeRVA, dwImplFlags, pmd));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(pmd);

    // Make sure no one sets the reserved bits on the way in.
    _ASSERTE((dwMethodFlags & (mdReservedMask&~mdRTSpecialName)) == 0);
    dwMethodFlags &= (~mdReservedMask);

    m_pStgdb->m_MiniMd.PreUpdate();
    IsGlobalMethodParent(&td);

    // See if this method has already been defined.
    if (CheckDups(MDDupMethodDef))
    {
        hr = ImportHelper::FindMethod(
            &(m_pStgdb->m_MiniMd), 
            td, 
            szNameUtf8, 
            pvSigBlob, 
            cbSigBlob, 
            pmd);

        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pRecord = m_pStgdb->m_MiniMd.getMethod(RidFromToken(*pmd));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create the new record.
    if (!pRecord)
    {
        IfNullGo(pRecord=m_pStgdb->m_MiniMd.AddMethodRecord(&iRecord));

        // Give token back to caller.
        *pmd = TokenFromRid(iRecord, mdtMethodDef);

        // Add to parent's list of child records.
        IfFailGo(m_pStgdb->m_MiniMd.AddMethodToTypeDef(RidFromToken(td), iRecord));

        IfFailGo(UpdateENCLog(td, CMiniMdRW::eDeltaMethodCreate));

        // record the more defs are introduced.
        SetMemberDefDirty(true);
    }

    // Set the method properties.
    IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_Method, MethodRec::COL_Name, pRecord, szNameUtf8));
    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_Method, MethodRec::COL_Signature, pRecord, pvSigBlob, cbSigBlob));

    // @FUTURE: possible performance improvement here to check _ first of all.
    if (!wcscmp(szName, COR_CTOR_METHOD_NAME_W) || 
        !wcscmp(szName, COR_CCTOR_METHOD_NAME_W) || 
        !wcsncmp(szName, L"_VtblGap", 8) )
    {
        _ASSERTE(IsMdSpecialName(dwMethodFlags) && "Must set mdSpecialName bit on constructors.");
        dwMethodFlags |= mdRTSpecialName | mdSpecialName;
    }
    SetCallerDefine();
    IfFailGo(_SetMethodProps(*pmd, dwMethodFlags, ulCodeRVA, dwImplFlags));

    IfFailGo(m_pStgdb->m_MiniMd.AddMemberDefToHash(*pmd, td) );

ErrExit:
    SetCallerExternal();
    
    STOP_MD_PERF(DefineMethod);
    return hr;
} // STDAPI RegMeta::DefineMethod()

//*****************************************************************************
// Create and set a MethodImpl Record.
//*****************************************************************************
STDAPI RegMeta::DefineMethodImpl(       // S_OK or error.
    mdTypeDef   td,                     // [IN] The class implementing the method   
    mdToken     tkBody,                 // [IN] Method body, MethodDef or MethodRef
    mdToken     tkDecl)                 // [IN] Method declaration, MethodDef or MethodRef
{
    HRESULT     hr = S_OK;
    MethodImplRec   *pMethodImplRec = NULL;
    RID             iMethodImplRec;

    LOG((LOGMD, "MD RegMeta::DefineMethodImpl(0x%08x, 0x%08x, 0x%08x)\n", 
        td, tkBody, tkDecl));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(TypeFromToken(td) == mdtTypeDef);
    _ASSERTE(TypeFromToken(tkBody) == mdtMemberRef || TypeFromToken(tkBody) == mdtMethodDef);
    _ASSERTE(TypeFromToken(tkDecl) == mdtMemberRef || TypeFromToken(tkDecl) == mdtMethodDef);
    _ASSERTE(!IsNilToken(td) && !IsNilToken(tkBody) && !IsNilToken(tkDecl));

    // Check for duplicates.
    if (CheckDups(MDDupMethodDef))
    {
        hr = ImportHelper::FindMethodImpl(&m_pStgdb->m_MiniMd, td, tkBody, tkDecl, NULL);
        if (SUCCEEDED(hr))
        {
            hr = META_S_DUPLICATE;
            goto ErrExit;
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create the MethodImpl record.
    IfNullGo(pMethodImplRec=m_pStgdb->m_MiniMd.AddMethodImplRecord(&iMethodImplRec));

    // Set the values.
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_MethodImpl, MethodImplRec::COL_Class,
                                         pMethodImplRec, td));
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_MethodImpl, MethodImplRec::COL_MethodBody,
                                         pMethodImplRec, tkBody));
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_MethodImpl, MethodImplRec::COL_MethodDeclaration,
                                         pMethodImplRec, tkDecl));
    
    IfFailGo( m_pStgdb->m_MiniMd.AddMethodImplToHash(iMethodImplRec) );

    IfFailGo(UpdateENCLog2(TBL_MethodImpl, iMethodImplRec));
ErrExit:
    
    STOP_MD_PERF(DefineMethodImpl);
    return hr;
} // STDAPI RegMeta::DefineMethodImpl()


//*****************************************************************************
// Set or update RVA and ImplFlags for the given MethodDef or FieldDef record.
//*****************************************************************************
STDAPI RegMeta::SetMethodImplFlags(     // [IN] S_OK or error.  
    mdMethodDef md,                     // [IN] Method for which to set impl flags  
    DWORD       dwImplFlags)
{
    HRESULT     hr = S_OK;
    MethodRec   *pMethodRec;

    LOG((LOGMD, "MD RegMeta::SetMethodImplFlags(0x%08x, 0x%08x)\n", 
        md, dwImplFlags));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(TypeFromToken(md) == mdtMethodDef && dwImplFlags != ULONG_MAX);

    // Get the record.
    pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(md));
    pMethodRec->m_ImplFlags = static_cast<USHORT>(dwImplFlags);

    IfFailGo(UpdateENCLog(md));

ErrExit:
    STOP_MD_PERF(SetMethodImplFlags);    
    return hr;
} // STDAPI RegMeta::SetMethodImplFlags()


//*****************************************************************************
// Set or update RVA and ImplFlags for the given MethodDef or FieldDef record.
//*****************************************************************************
STDAPI RegMeta::SetFieldRVA(            // [IN] S_OK or error.  
    mdFieldDef  fd,                     // [IN] Field for which to set offset  
    ULONG       ulRVA)                  // [IN] The offset  
{
    HRESULT     hr = S_OK;
    FieldRVARec     *pFieldRVARec;
    RID             iFieldRVA;
    FieldRec        *pFieldRec;

    LOG((LOGMD, "MD RegMeta::SetFieldRVA(0x%08x, 0x%08x)\n", 
        fd, ulRVA));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(TypeFromToken(fd) == mdtFieldDef);


    iFieldRVA = m_pStgdb->m_MiniMd.FindFieldRVAHelper(fd);

    if (InvalidRid(iFieldRVA))
    {
        // turn on the has field RVA bit
        pFieldRec = m_pStgdb->m_MiniMd.getField(RidFromToken(fd));
        pFieldRec->m_Flags |= fdHasFieldRVA;

        // Create a new record.
        IfNullGo(pFieldRVARec = m_pStgdb->m_MiniMd.AddFieldRVARecord(&iFieldRVA));

        // Set the data.
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_FieldRVA, FieldRVARec::COL_Field,
                                            pFieldRVARec, fd));
        IfFailGo( m_pStgdb->m_MiniMd.AddFieldRVAToHash(iFieldRVA) );
    }
    else
    {
        // Get the record.
        pFieldRVARec = m_pStgdb->m_MiniMd.getFieldRVA(iFieldRVA);
    }

    // Set the data.
    pFieldRVARec->m_RVA = ulRVA;

    IfFailGo(UpdateENCLog2(TBL_FieldRVA, iFieldRVA));

ErrExit:
    STOP_MD_PERF(SetFieldRVA);    
    return hr;
} // STDAPI RegMeta::SetFieldRVA()


//*****************************************************************************
// Helper: Set or update RVA and ImplFlags for the given MethodDef or MethodImpl record.
//*****************************************************************************
HRESULT RegMeta::_SetRVA(               // [IN] S_OK or error.
    mdToken     tk,                     // [IN] Member for which to set offset
    ULONG       ulCodeRVA,              // [IN] The offset
    DWORD       dwImplFlags) 
{
    HRESULT     hr = S_OK;

    _ASSERTE(TypeFromToken(tk) == mdtMethodDef || TypeFromToken(tk) == mdtFieldDef);
    _ASSERTE(!IsNilToken(tk));

    if (TypeFromToken(tk) == mdtMethodDef)
    {
        MethodRec   *pMethodRec;

        // Get the record.
        pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(tk));

        // Set the data.
        pMethodRec->m_RVA = ulCodeRVA;

        // Do not set the flag value unless its valid.
        if (dwImplFlags != ULONG_MAX)
            pMethodRec->m_ImplFlags = static_cast<USHORT>(dwImplFlags);

        IfFailGo(UpdateENCLog(tk));
    }
    else            // TypeFromToken(tk) == mdtFieldDef
    {
        _ASSERTE(dwImplFlags==0 || dwImplFlags==ULONG_MAX);

        FieldRVARec     *pFieldRVARec;
        RID             iFieldRVA;
        FieldRec        *pFieldRec;

        iFieldRVA = m_pStgdb->m_MiniMd.FindFieldRVAHelper(tk);

        if (InvalidRid(iFieldRVA))
        {
            // turn on the has field RVA bit
            pFieldRec = m_pStgdb->m_MiniMd.getField(RidFromToken(tk));
            pFieldRec->m_Flags |= fdHasFieldRVA;

            // Create a new record.
            IfNullGo(pFieldRVARec = m_pStgdb->m_MiniMd.AddFieldRVARecord(&iFieldRVA));

            // Set the data.
            IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_FieldRVA, FieldRVARec::COL_Field,
                                                pFieldRVARec, tk));

            IfFailGo( m_pStgdb->m_MiniMd.AddFieldRVAToHash(iFieldRVA) );

        }
        else
        {
            // Get the record.
            pFieldRVARec = m_pStgdb->m_MiniMd.getFieldRVA(iFieldRVA);
        }

        // Set the data.
        pFieldRVARec->m_RVA = ulCodeRVA;

        IfFailGo(UpdateENCLog2(TBL_FieldRVA, iFieldRVA));
    }

ErrExit:
    return hr;
} // STDAPI RegMeta::SetRVA()

//*****************************************************************************
// Given a name, create a TypeRef.
//*****************************************************************************
STDAPI RegMeta::DefineTypeRefByName(    // S_OK or error.
    mdToken     tkResolutionScope,      // [IN] ModuleRef or AssemblyRef.
    LPCWSTR     szName,                 // [IN] Name of the TypeRef.
    mdTypeRef   *ptr)                   // [OUT] Put TypeRef token here.
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::DefineTypeRefByName(0x%08x, %S, 0x%08x)\n", 
        tkResolutionScope, MDSTR(szName), ptr));
    START_MD_PERF();
    LOCKWRITE();
    
    m_pStgdb->m_MiniMd.PreUpdate();

    // Common helper function does all of the work.
    IfFailGo(_DefineTypeRef(tkResolutionScope, szName, TRUE, ptr));

ErrExit:
    
    STOP_MD_PERF(DefineTypeRefByName);
    return hr;
} // STDAPI RegMeta::DefineTypeRefByName()

//*****************************************************************************
// Create a reference, in an emit scope, to a TypeDef in another scope.
//*****************************************************************************
STDAPI RegMeta::DefineImportType(       // S_OK or error.
    IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the TypeDef.
    const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
    ULONG    cbHashValue,           // [IN] Count of bytes.
    IMetaDataImport *pImport,           // [IN] Scope containing the TypeDef.
    mdTypeDef   tdImport,               // [IN] The imported TypeDef.
    IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the TypeDef is imported.
    mdTypeRef   *ptr)                   // [OUT] Put TypeRef token here.
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::DefineImportType(0x%08x, 0x%08x, 0x%08x, 0x%08x, "
                "0x%08x, 0x%08x, 0x%08x)\n", 
                pAssemImport, pbHashValue, cbHashValue, 
                pImport, tdImport, pAssemEmit, ptr));

    START_MD_PERF();

    LOCKWRITE();

    RegMeta     *pAssemImportRM = static_cast<RegMeta*>(pAssemImport);
    IMetaModelCommon *pAssemImportCommon = 
        pAssemImportRM ? static_cast<IMetaModelCommon*>(&pAssemImportRM->m_pStgdb->m_MiniMd) : 0;
    RegMeta     *pImportRM = static_cast<RegMeta*>(pImport);
    IMetaModelCommon *pImportCommon = static_cast<IMetaModelCommon*>(&pImportRM->m_pStgdb->m_MiniMd);

    RegMeta     *pAssemEmitRM = static_cast<RegMeta*>(pAssemEmit);
    CMiniMdRW   *pMiniMdAssemEmit =  pAssemEmitRM ? static_cast<CMiniMdRW*>(&pAssemEmitRM->m_pStgdb->m_MiniMd) : 0;
    CMiniMdRW   *pMiniMdEmit = &m_pStgdb->m_MiniMd;
    
    IfFailGo(ImportHelper::ImportTypeDef(
                        pMiniMdAssemEmit,
                        pMiniMdEmit,
                        pAssemImportCommon,
                        pbHashValue, cbHashValue, 
                        pImportCommon,
                        tdImport,
                        false,  // Do not optimize to TypeDef if import and emit scopes are identical.
                        ptr));
ErrExit:
    STOP_MD_PERF(DefineImportType);
    return hr;
} // STDAPI RegMeta::DefineImportType()

//*****************************************************************************
// Create and set a MemberRef record.
//*****************************************************************************
STDAPI RegMeta::DefineMemberRef(        // S_OK or error
    mdToken     tkImport,               // [IN] ClassRef or ClassDef importing a member.
    LPCWSTR     szName,                 // [IN] member's name
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
    mdMemberRef *pmr)                   // [OUT] memberref token
{
    HRESULT         hr = S_OK;
    MemberRefRec    *pRecord = 0;       // The MemberRef record.
    RID             iRecord;            // RID of new MemberRef record.
    LPUTF8          szNameUtf8 = UTF8STR(szName);   

    LOG((LOGMD, "MD RegMeta::DefineMemberRef(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x)\n", 
        tkImport, MDSTR(szName), pvSigBlob, cbSigBlob, pmr));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(TypeFromToken(tkImport) == mdtTypeRef ||
             TypeFromToken(tkImport) == mdtModuleRef ||
             TypeFromToken(tkImport) == mdtMethodDef ||
             TypeFromToken(tkImport) == mdtTypeSpec ||
             IsNilToken(tkImport));

    _ASSERTE(szName && pvSigBlob && cbSigBlob && pmr);

    // _ASSERTE(_IsValidToken(tkImport));

    // Set token to m_tdModule if referring to a global function.
    if (IsNilToken(tkImport))
        tkImport = m_tdModule;

    // If the MemberRef already exists, just return the token, else
    // create a new record.
    if (CheckDups(MDDupMemberRef))
    {
        hr = ImportHelper::FindMemberRef(&(m_pStgdb->m_MiniMd), tkImport, szNameUtf8, pvSigBlob, cbSigBlob, pmr);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pRecord = m_pStgdb->m_MiniMd.getMemberRef(RidFromToken(*pmr));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)      // MemberRef exists
            IfFailGo(hr);
    }

    if (!pRecord)
    {   // Create the record.
        IfNullGo(pRecord=m_pStgdb->m_MiniMd.AddMemberRefRecord(&iRecord));

        // record the more defs are introduced.
        SetMemberDefDirty(true);
        
        // Give token to caller.
        *pmr = TokenFromRid(iRecord, mdtMemberRef);
    }

    // Save row data.
    IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_MemberRef, MemberRefRec::COL_Name, pRecord, szNameUtf8));
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_MemberRef, MemberRefRec::COL_Class, pRecord, tkImport));
    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_MemberRef, MemberRefRec::COL_Signature, pRecord,
                                pvSigBlob, cbSigBlob));

    IfFailGo(m_pStgdb->m_MiniMd.AddMemberRefToHash(*pmr) );

    IfFailGo(UpdateENCLog(*pmr));

ErrExit:
    
    STOP_MD_PERF(DefineMemberRef);
    return hr;
} // STDAPI RegMeta::DefineMemberRef()

//*****************************************************************************
// Create a MemberRef record based on a member in an import scope.
//*****************************************************************************
STDAPI RegMeta::DefineImportMember(     // S_OK or error.
    IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the Member.
    const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
    ULONG        cbHashValue,           // [IN] Count of bytes.
    IMetaDataImport *pImport,           // [IN] Import scope, with member.
    mdToken     mbMember,               // [IN] Member in import scope.
    IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the Member is imported.
    mdToken     tkImport,               // [IN] Classref or classdef in emit scope.
    mdMemberRef *pmr)                   // [OUT] Put member ref here.
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::DefineImportMember("
        "0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x,"
        " 0x%08x, 0x%08x, 0x%08x)\n", 
        pAssemImport, pbHashValue, cbHashValue, pImport, mbMember,
        pAssemEmit, tkImport, pmr));
    START_MD_PERF();

    // No need to lock this function. All the functions that it calls are public APIs.

    _ASSERTE(pImport && pmr);
    _ASSERTE(TypeFromToken(tkImport) == mdtTypeRef || TypeFromToken(tkImport) == mdtModuleRef ||
                IsNilToken(tkImport));
    _ASSERTE((TypeFromToken(mbMember) == mdtMethodDef && mbMember != mdMethodDefNil) ||
             (TypeFromToken(mbMember) == mdtFieldDef && mbMember != mdFieldDefNil));

    CQuickArray<WCHAR> qbMemberName;    // Name of the imported member.
    CQuickArray<WCHAR> qbScopeName;     // Name of the imported member's scope.
    GUID        mvidImport;             // MVID of the import module.
    GUID        mvidEmit;               // MVID of the emit module.
    ULONG       cchName;                // Length of a name, in wide chars.
    PCCOR_SIGNATURE pvSig;              // Member's signature.
    ULONG       cbSig;                  // Length of member's signature.
    CQuickBytes cqbTranslatedSig;       // Buffer for signature translation.
    ULONG       cbTranslatedSig;        // Length of translated signature.

    if (TypeFromToken(mbMember) == mdtMethodDef)
    {
        do {
            hr = pImport->GetMethodProps(mbMember, 0, qbMemberName.Ptr(),(DWORD)qbMemberName.MaxSize(),&cchName, 
                0, &pvSig,&cbSig, 0,0);
            if (hr == CLDB_S_TRUNCATION)
            {
                IfFailGo(qbMemberName.ReSize(cchName));
                continue;
            }
            break;
        } while (1);
    }
    else    // TypeFromToken(mbMember) == mdtFieldDef
    {
        do {
            hr = pImport->GetFieldProps(mbMember, 0, qbMemberName.Ptr(),(DWORD)qbMemberName.MaxSize(),&cchName, 
                0, &pvSig,&cbSig, 0,0, 0);
            if (hr == CLDB_S_TRUNCATION)
            {
                IfFailGo(qbMemberName.ReSize(cchName));
                continue;
            }
            break;
        } while (1);
    }
    IfFailGo(hr);

    IfFailGo(cqbTranslatedSig.ReSize(cbSig * 3));       // Set size conservatively.

    IfFailGo(TranslateSigWithScope(
        pAssemImport,
        pbHashValue,
        cbHashValue,
        pImport, 
        pvSig, 
        cbSig, 
        pAssemEmit,
        static_cast<IMetaDataEmit*>(this),
        (COR_SIGNATURE *)cqbTranslatedSig.Ptr(),
        cbSig * 3, 
        &cbTranslatedSig));

    // Define ModuleRef for imported Member functions

    // Check if the Member being imported is a global function.
    IfFailGo(GetScopeProps(0, 0, 0, &mvidEmit));
    IfFailGo(pImport->GetScopeProps(0, 0,&cchName, &mvidImport));
    if (mvidEmit != mvidImport && IsNilToken(tkImport))
    {
        IfFailGo(qbScopeName.ReSize(cchName));
        IfFailGo(pImport->GetScopeProps(qbScopeName.Ptr(),(DWORD)qbScopeName.MaxSize(),
                                        0, 0));
        IfFailGo(DefineModuleRef(qbScopeName.Ptr(), &tkImport));
    }

    // Define MemberRef base on the name, sig, and parent
    IfFailGo(DefineMemberRef(
        tkImport, 
        qbMemberName.Ptr(),
        reinterpret_cast<PCCOR_SIGNATURE>(cqbTranslatedSig.Ptr()),
        cbTranslatedSig, 
        pmr));

ErrExit:
    STOP_MD_PERF(DefineImportMember);
    return hr;
} // STDAPI RegMeta::DefineImportMember()

//*****************************************************************************
// Define and set a Event record.
//*****************************************************************************
STDAPI RegMeta::DefineEvent(
    mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined
    LPCWSTR     szEvent,                // [IN] Name of the event
    DWORD       dwEventFlags,           // [IN] CorEventAttr
    mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef(to the Event class
    mdMethodDef mdAddOn,                // [IN] required add method
    mdMethodDef mdRemoveOn,             // [IN] required remove method
    mdMethodDef mdFire,                 // [IN] optional fire method
    mdMethodDef rmdOtherMethods[],      // [IN] optional array of other methods associate with the event
    mdEvent     *pmdEvent)              // [OUT] output event token
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::DefineEvent(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        td, szEvent, dwEventFlags, tkEventType, mdAddOn, mdRemoveOn, mdFire, rmdOtherMethods, pmdEvent));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(TypeFromToken(td) == mdtTypeDef && td != mdTypeDefNil);
    _ASSERTE(IsNilToken(tkEventType) || TypeFromToken(tkEventType) == mdtTypeDef ||
                TypeFromToken(tkEventType) == mdtTypeRef);
    _ASSERTE(TypeFromToken(mdAddOn) == mdtMethodDef && mdAddOn != mdMethodDefNil);
    _ASSERTE(TypeFromToken(mdRemoveOn) == mdtMethodDef && mdRemoveOn != mdMethodDefNil);
    _ASSERTE(IsNilToken(mdFire) || TypeFromToken(mdFire) == mdtMethodDef);
    _ASSERTE(szEvent && pmdEvent);

    hr = _DefineEvent(td, szEvent, dwEventFlags, tkEventType, pmdEvent);
    if (hr != S_OK)
        goto ErrExit;

    IfFailGo(_SetEventProps2(*pmdEvent, mdAddOn, mdRemoveOn, mdFire, rmdOtherMethods, IsENCOn()));
    IfFailGo(UpdateENCLog(*pmdEvent));
ErrExit:
    
    STOP_MD_PERF(DefineEvent);
    return hr;
} // STDAPI RegMeta::DefineEvent()

//*****************************************************************************
// Set the ClassLayout information.
//
// If a row already exists for this class in the layout table, the layout
// information is overwritten.
//*****************************************************************************
STDAPI RegMeta::SetClassLayout(
    mdTypeDef   td,                     // [IN] typedef
    DWORD       dwPackSize,             // [IN] packing size specified as 1, 2, 4, 8, or 16
    COR_FIELD_OFFSET rFieldOffsets[],   // [IN] array of layout specification
    ULONG       ulClassSize)            // [IN] size of the class
{
    HRESULT     hr = S_OK;              // A result.
    int         index = 0;              // Loop control.

    LOG((LOGMD, "MD RegMeta::SetClassLayout(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        td, dwPackSize, rFieldOffsets, ulClassSize));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(TypeFromToken(td) == mdtTypeDef);


    // Create entries in the FieldLayout table.
    if (rFieldOffsets)
    {
        mdFieldDef tkfd;
        // Iterate the list of fields...
        for (index = 0; rFieldOffsets[index].ridOfField != mdFieldDefNil; index++)
        {
            if (rFieldOffsets[index].ulOffset != ULONG_MAX)
            {
                tkfd = TokenFromRid(rFieldOffsets[index].ridOfField, mdtFieldDef);
                
                IfFailGo(_SetFieldOffset(tkfd, rFieldOffsets[index].ulOffset));
            }
        }
    }

    IfFailGo(_SetClassLayout(td, dwPackSize, ulClassSize));
    
ErrExit:
    
    STOP_MD_PERF(SetClassLayout);
    return hr;
} // STDAPI RegMeta::SetClassLayout()

//*****************************************************************************
// Helper function to set a class layout for a given class.
//*****************************************************************************
HRESULT RegMeta::_SetClassLayout(       // S_OK or error.
    mdTypeDef   td,                     // [IN] The class.
    ULONG       dwPackSize,             // [IN] The packing size.
    ULONG       ulClassSize)            // [IN, OPTIONAL] The class size.
{
    HRESULT     hr = S_OK;              // A result.
    ClassLayoutRec  *pClassLayout;      // A classlayout record.
    RID         iClassLayout = 0;       // RID of classlayout record.

    // See if a ClassLayout record already exists for the given TypeDef.
    iClassLayout = m_pStgdb->m_MiniMd.FindClassLayoutHelper(td);

    if (InvalidRid(iClassLayout))
    {
        IfNullGo(pClassLayout = m_pStgdb->m_MiniMd.AddClassLayoutRecord(&iClassLayout));
        // Set the Parent entry.
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_ClassLayout, ClassLayoutRec::COL_Parent,
                                            pClassLayout, td));
        IfFailGo( m_pStgdb->m_MiniMd.AddClassLayoutToHash(iClassLayout) );
    }
    else
    {
        pClassLayout = m_pStgdb->m_MiniMd.getClassLayout(iClassLayout);
    }

    // Set the data.
    if (dwPackSize != ULONG_MAX)
        pClassLayout->m_PackingSize = static_cast<USHORT>(dwPackSize);
    if (ulClassSize != ULONG_MAX)
        pClassLayout->m_ClassSize = ulClassSize;

    // Create the log record for the non-token record.
    IfFailGo(UpdateENCLog2(TBL_ClassLayout, iClassLayout));

ErrExit:
    
    return hr;
} // HRESULT RegMeta::_SetClassLayout()

//*****************************************************************************
// Helper function to set a field offset for a given field def.
//*****************************************************************************
HRESULT RegMeta::_SetFieldOffset(       // S_OK or error.
    mdFieldDef  fd,                     // [IN] The field.
    ULONG       ulOffset)               // [IN] The offset of the field.
{
    HRESULT     hr;                     // A result.
    FieldLayoutRec *pFieldLayoutRec=0;  // A FieldLayout record.
    RID         iFieldLayoutRec=0;      // RID of a FieldLayout record.

    // See if an entry already exists for the Field in the FieldLayout table.
    iFieldLayoutRec = m_pStgdb->m_MiniMd.FindFieldLayoutHelper(fd);
    if (InvalidRid(iFieldLayoutRec))
    {
        IfNullGo(pFieldLayoutRec = m_pStgdb->m_MiniMd.AddFieldLayoutRecord(&iFieldLayoutRec));
        // Set the Field entry.
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_FieldLayout, FieldLayoutRec::COL_Field,
                    pFieldLayoutRec, fd));
        IfFailGo( m_pStgdb->m_MiniMd.AddFieldLayoutToHash(iFieldLayoutRec) );
    }
    else
    {
        pFieldLayoutRec = m_pStgdb->m_MiniMd.getFieldLayout(iFieldLayoutRec);
    }

    // Set the offset.
    pFieldLayoutRec->m_OffSet = ulOffset;

    // Create the log record for the non-token record.
    IfFailGo(UpdateENCLog2(TBL_FieldLayout, iFieldLayoutRec));

ErrExit:
    return hr;        
} // STDAPI RegMeta::_SetFieldOffset()
    
//*****************************************************************************
// Delete the ClassLayout information.
//*****************************************************************************
STDAPI RegMeta::DeleteClassLayout(
    mdTypeDef   td)                     // [IN] typdef token
{
    HRESULT     hr = S_OK;
    ClassLayoutRec  *pClassLayoutRec;
    TypeDefRec  *pTypeDefRec;
    FieldLayoutRec *pFieldLayoutRec;
    RID         iClassLayoutRec;
    RID         iFieldLayoutRec;
    RID         ridStart;
    RID         ridEnd;
    RID         ridCur;
    ULONG       index;

    LOG((LOGMD, "MD RegMeta::DeleteClassLayout(0x%08x)\n", td)); 
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(!m_bSaveOptimized && "Cannot change records after PreSave() and before Save().");
    _ASSERTE(TypeFromToken(td) == mdtTypeDef && !IsNilToken(td));

    // Get the ClassLayout record.
    iClassLayoutRec = m_pStgdb->m_MiniMd.FindClassLayoutHelper(td);
    if (InvalidRid(iClassLayoutRec))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    pClassLayoutRec = m_pStgdb->m_MiniMd.getClassLayout(iClassLayoutRec);

    // Clear the parent.
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_ClassLayout,
                                         ClassLayoutRec::COL_Parent,
                                         pClassLayoutRec, mdTypeDefNil));

    // Create the log record for the non-token record.
    IfFailGo(UpdateENCLog2(TBL_ClassLayout, iClassLayoutRec));

    // Delete all the corresponding FieldLayout records if there are any.
    pTypeDefRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(td));
    ridStart = m_pStgdb->m_MiniMd.getFieldListOfTypeDef(pTypeDefRec);
    ridEnd = m_pStgdb->m_MiniMd.getEndFieldListOfTypeDef(pTypeDefRec);

    for (index = ridStart; index < ridEnd; index++)
    {
        ridCur = m_pStgdb->m_MiniMd.GetFieldRid(index);
        iFieldLayoutRec = m_pStgdb->m_MiniMd.FindFieldLayoutHelper(TokenFromRid(ridCur, mdtFieldDef));
        if (InvalidRid(iFieldLayoutRec))
            continue;
        else
        {
            pFieldLayoutRec = m_pStgdb->m_MiniMd.getFieldLayout(iFieldLayoutRec);
            // Set the Field entry.
            IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_FieldLayout, FieldLayoutRec::COL_Field,
                            pFieldLayoutRec, mdFieldDefNil));
            // Create the log record for the non-token record.
            IfFailGo(UpdateENCLog2(TBL_FieldLayout, iFieldLayoutRec));
        }
    }
ErrExit:
    STOP_MD_PERF(DeleteClassLayout);
    return hr;
}   // RegMeta::DeleteClassLayout()

//*****************************************************************************
// Set the field's native type.
//*****************************************************************************
STDAPI RegMeta::SetFieldMarshal(
    mdToken     tk,                     // [IN] given a fieldDef or paramDef token
    PCCOR_SIGNATURE pvNativeType,       // [IN] native type specification
    ULONG       cbNativeType)           // [IN] count of bytes of pvNativeType
{
    HRESULT     hr = S_OK;
    FieldMarshalRec *pFieldMarshRec;
    RID         iFieldMarshRec = 0;     // initialize to invalid rid

    LOG((LOGMD, "MD RegMeta::SetFieldMarshal(0x%08x, 0x%08x, 0x%08x)\n", 
        tk, pvNativeType, cbNativeType));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(TypeFromToken(tk) == mdtFieldDef || TypeFromToken(tk) == mdtParamDef);
    _ASSERTE(!IsNilToken(tk));

    // turn on the HasFieldMarshal
    if (TypeFromToken(tk) == mdtFieldDef)
    {
        FieldRec    *pFieldRec;

        pFieldRec = m_pStgdb->m_MiniMd.getField(RidFromToken(tk));
        pFieldRec->m_Flags |= fdHasFieldMarshal;
    }
    else // TypeFromToken(tk) == mdtParamDef
    {
        ParamRec    *pParamRec;

        IfNullGo(pParamRec = m_pStgdb->m_MiniMd.getParam(RidFromToken(tk)));
        pParamRec->m_Flags |= pdHasFieldMarshal;
    }
    IfFailGo(UpdateENCLog(tk));

    if (TypeFromToken(tk) == mdtFieldDef)
    {
        iFieldMarshRec = m_pStgdb->m_MiniMd.FindFieldMarshalHelper(tk);
    }
    else
    {
        iFieldMarshRec = m_pStgdb->m_MiniMd.FindFieldMarshalHelper(tk);
    }
    if (InvalidRid(iFieldMarshRec))
    {
        IfNullGo(pFieldMarshRec = m_pStgdb->m_MiniMd.AddFieldMarshalRecord(&iFieldMarshRec));
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_FieldMarshal, FieldMarshalRec::COL_Parent, pFieldMarshRec, tk));
        IfFailGo( m_pStgdb->m_MiniMd.AddFieldMarshalToHash(iFieldMarshRec) );
    }
    else
    {
        pFieldMarshRec = m_pStgdb->m_MiniMd.getFieldMarshal(iFieldMarshRec);
    }

    // Set data.
    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_FieldMarshal, FieldMarshalRec::COL_NativeType, pFieldMarshRec,
                                pvNativeType, cbNativeType));

    // Create the log record for the non-token record.
    IfFailGo(UpdateENCLog2(TBL_FieldMarshal, iFieldMarshRec));

ErrExit:
    
    STOP_MD_PERF(SetFieldMarshal);
    return hr;
} // STDAPI RegMeta::SetFieldMarshal()


//*****************************************************************************
// Delete the FieldMarshal record for the given token.
//*****************************************************************************
STDAPI RegMeta::DeleteFieldMarshal(
    mdToken     tk)                     // [IN] fieldDef or paramDef token to be deleted.
{
    HRESULT     hr = S_OK;
    FieldMarshalRec *pFieldMarshRec;
    RID         iFieldMarshRec;

    LOG((LOGMD, "MD RegMeta::DeleteFieldMarshal(0x%08x)\n", tk));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(TypeFromToken(tk) == mdtFieldDef || TypeFromToken(tk) == mdtParamDef);
    _ASSERTE(!IsNilToken(tk));
    _ASSERTE(!m_bSaveOptimized && "Cannot delete records after PreSave() and before Save().");

    // Get the FieldMarshal record.
    iFieldMarshRec = m_pStgdb->m_MiniMd.FindFieldMarshalHelper(tk);
    if (InvalidRid(iFieldMarshRec))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    pFieldMarshRec = m_pStgdb->m_MiniMd.getFieldMarshal(iFieldMarshRec);
    // Clear the parent token from the FieldMarshal record.
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_FieldMarshal,
                FieldMarshalRec::COL_Parent, pFieldMarshRec, mdFieldDefNil));

    // turn off the HasFieldMarshal
    if (TypeFromToken(tk) == mdtFieldDef)
    {
        FieldRec    *pFieldRec;

        pFieldRec = m_pStgdb->m_MiniMd.getField(RidFromToken(tk));
        pFieldRec->m_Flags &= ~fdHasFieldMarshal;
    }
    else // TypeFromToken(tk) == mdtParamDef
    {
        ParamRec    *pParamRec;

        pParamRec = m_pStgdb->m_MiniMd.getParam(RidFromToken(tk));
        pParamRec->m_Flags &= ~pdHasFieldMarshal;
    }

    // Update the ENC log for the parent token.
    IfFailGo(UpdateENCLog(tk));
    // Create the log record for the non-token record.
    IfFailGo(UpdateENCLog2(TBL_FieldMarshal, iFieldMarshRec));

ErrExit:
    STOP_MD_PERF(DeleteFieldMarshal);
    return hr;
} // STDAPI RegMeta::DeleteFieldMarshal()

//*****************************************************************************
// Define a new permission set for an object.
//*****************************************************************************
STDAPI RegMeta::DefinePermissionSet(
    mdToken     tk,                     // [IN] the object to be decorated.
    DWORD       dwAction,               // [IN] CorDeclSecurity.
    void const  *pvPermission,          // [IN] permission blob.
    ULONG       cbPermission,           // [IN] count of bytes of pvPermission.
    mdPermission *ppm)                  // [OUT] returned permission token.
{
    HRESULT     hr  = S_OK;
    LOG((LOGMD, "MD RegMeta::DefinePermissionSet(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        tk, dwAction, pvPermission, cbPermission, ppm));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    IfFailGo( _DefinePermissionSet(tk, dwAction, pvPermission, cbPermission, ppm) );
ErrExit:
    
    STOP_MD_PERF(DefinePermissionSet);
    return hr;

}   // STDAPI RegMeta::DefinePermissionSet()


//*****************************************************************************
// Define a new permission set for an object.
//*****************************************************************************
HRESULT RegMeta::_DefinePermissionSet(
    mdToken     tk,                     // [IN] the object to be decorated.
    DWORD       dwAction,               // [IN] CorDeclSecurity.
    void const  *pvPermission,          // [IN] permission blob.
    ULONG       cbPermission,           // [IN] count of bytes of pvPermission.
    mdPermission *ppm)                  // [OUT] returned permission token.
{

    HRESULT     hr  = S_OK;
    DeclSecurityRec *pDeclSec = NULL;
    RID         iDeclSec;
    short       sAction = static_cast<short>(dwAction); // To match with the type in DeclSecurityRec.
    mdPermission tkPerm;                // New permission token.

    _ASSERTE(TypeFromToken(tk) == mdtTypeDef || TypeFromToken(tk) == mdtMethodDef ||
             TypeFromToken(tk) == mdtAssembly);

    // Check for valid Action.
    if (sAction == 0 || sAction > dclMaximumValue)
        IfFailGo(E_INVALIDARG);

    if (CheckDups(MDDupPermission))
    {
        hr = ImportHelper::FindPermission(&(m_pStgdb->m_MiniMd), tk, sAction, &tkPerm);

        if (SUCCEEDED(hr))
        {
            // Set output parameter.
            if (ppm)
                *ppm = tkPerm;
            if (IsENCOn())
                pDeclSec = m_pStgdb->m_MiniMd.getDeclSecurity(RidFromToken(tkPerm));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create a new record.
    if (!pDeclSec)
    {
        IfNullGo(pDeclSec = m_pStgdb->m_MiniMd.AddDeclSecurityRecord(&iDeclSec));
        tkPerm = TokenFromRid(iDeclSec, mdtPermission);

        // Set output parameter.
        if (ppm)
            *ppm = tkPerm;

        // Save parent and action information.
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_DeclSecurity, DeclSecurityRec::COL_Parent, pDeclSec, tk));
        pDeclSec->m_Action =  sAction;

        // Turn on the internal security flag on the parent.
        if (TypeFromToken(tk) == mdtTypeDef)
            IfFailGo(_TurnInternalFlagsOn(tk, tdHasSecurity));
        else if (TypeFromToken(tk) == mdtMethodDef)
            IfFailGo(_TurnInternalFlagsOn(tk, mdHasSecurity));
        IfFailGo(UpdateENCLog(tk));
    }

    IfFailGo(_SetPermissionSetProps(tkPerm, sAction, pvPermission, cbPermission));
    IfFailGo(UpdateENCLog(tkPerm));
ErrExit:
    
    STOP_MD_PERF(DefinePermissionSet);
    return hr;
}   //HRESULT RegMeta::_DefinePermissionSet()



//*****************************************************************************
// Set the RVA of a methoddef 
//*****************************************************************************
STDAPI RegMeta::SetRVA(                 // [IN] S_OK or error.
    mdToken     md,                     // [IN] Member for which to set offset
    ULONG       ulRVA)                  // [IN] The offset#endif
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::SetRVA(0x%08x, 0x%08x)\n", 
        md, ulRVA));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();
    IfFailGo( _SetRVA(md, ulRVA, ULONG_MAX) );    // 0xbaad

ErrExit:
    
    STOP_MD_PERF(SetRVA);
    return hr;
} // SetRVA

//*****************************************************************************
// Given a signature, return a token to the user.  If there isn't an existing
// token, create a new record.  This should more appropriately be called
// DefineSignature.
//*****************************************************************************
STDAPI RegMeta::GetTokenFromSig(        // [IN] S_OK or error.
    PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.
    ULONG       cbSig,                  // [IN] Size of signature data.
    mdSignature *pmsig)                 // [OUT] returned signature token.
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::GetTokenFromSig(0x%08x, 0x%08x, 0x%08x)\n", 
        pvSig, cbSig, pmsig));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(pmsig);

    m_pStgdb->m_MiniMd.PreUpdate();
    IfFailGo( _GetTokenFromSig(pvSig, cbSig, pmsig) );

ErrExit:
    
    STOP_MD_PERF(GetTokenFromSig);
    return hr;
} // STDAPI RegMeta::GetTokenFromSig()

//*****************************************************************************
// Define and set a ModuleRef record.
//*****************************************************************************
STDAPI RegMeta::DefineModuleRef(        // S_OK or error.
    LPCWSTR     szName,                 // [IN] DLL name
    mdModuleRef *pmur)                  // [OUT] returned module ref token
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::DefineModuleRef(%S, 0x%08x)\n", MDSTR(szName), pmur));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    hr = _DefineModuleRef(szName, pmur);

ErrExit:
    
    STOP_MD_PERF(DefineModuleRef);
    return hr;
} // STDAPI RegMeta::DefineModuleRef()

HRESULT RegMeta::_DefineModuleRef(        // S_OK or error.
    LPCWSTR     szName,                 // [IN] DLL name
    mdModuleRef *pmur)                  // [OUT] returned module ref token
{
    HRESULT     hr = S_OK;
    ModuleRefRec *pModuleRef = 0;       // The ModuleRef record.
    RID         iModuleRef;             // Rid of new ModuleRef record.
    LPCUTF8     szUTF8Name = UTF8STR((LPCWSTR)szName);

    _ASSERTE(szName && pmur);

    // See if the given ModuleRef already exists.  If it exists just return.
    // Else create a new record.
    if (CheckDups(MDDupModuleRef))
    {
        hr = ImportHelper::FindModuleRef(&(m_pStgdb->m_MiniMd), szUTF8Name, pmur);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pModuleRef = m_pStgdb->m_MiniMd.getModuleRef(RidFromToken(*pmur));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    if (!pModuleRef)
    {
        // Create new record and set the values.
        IfNullGo(pModuleRef = m_pStgdb->m_MiniMd.AddModuleRefRecord(&iModuleRef));

        // Set the output parameter.
        *pmur = TokenFromRid(iModuleRef, mdtModuleRef);
    }

    // Save the data.
    IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_ModuleRef, ModuleRefRec::COL_Name,
                                            pModuleRef, szUTF8Name));
    IfFailGo(UpdateENCLog(*pmur));

ErrExit:
    
    return hr;
} // STDAPI RegMeta::_DefineModuleRef()

//*****************************************************************************
// Set the parent for the specified MemberRef.
//*****************************************************************************
STDAPI RegMeta::SetParent(                      // S_OK or error.
    mdMemberRef mr,                     // [IN] Token for the ref to be fixed up.
    mdToken     tk)                     // [IN] The ref parent.
{
    HRESULT     hr = S_OK;
    MemberRefRec *pMemberRef;

    LOG((LOGMD, "MD RegMeta::SetParent(0x%08x, 0x%08x)\n", 
        mr, tk));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(TypeFromToken(mr) == mdtMemberRef);
    _ASSERTE(IsNilToken(tk) || TypeFromToken(tk) == mdtTypeRef || TypeFromToken(tk) == mdtTypeDef ||
                TypeFromToken(tk) == mdtModuleRef || TypeFromToken(tk) == mdtMethodDef);

    pMemberRef = m_pStgdb->m_MiniMd.getMemberRef(RidFromToken(mr));

    // If the token is nil set it to to m_tdModule.
    tk = IsNilToken(tk) ? m_tdModule : tk;

    // Set the parent.
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_MemberRef, MemberRefRec::COL_Class, pMemberRef, tk));

    // Add the updated MemberRef to the hash.
    IfFailGo(m_pStgdb->m_MiniMd.AddMemberRefToHash(mr) );

    IfFailGo(UpdateENCLog(mr));

ErrExit:
    
    STOP_MD_PERF(SetParent);
    return hr;
} // STDAPI RegMeta::SetParent()

//*****************************************************************************
// Define an TypeSpec token given a type description.
//*****************************************************************************
STDAPI RegMeta::GetTokenFromTypeSpec(   // [IN] S_OK or error.
    PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.
    ULONG       cbSig,                  // [IN] Size of signature data.
    mdTypeSpec *ptypespec)              // [OUT] returned signature token.
{
    HRESULT     hr = S_OK;
    TypeSpecRec *pTypeSpecRec;
    RID         iRec;

    LOG((LOGMD, "MD RegMeta::GetTokenFromTypeSpec(0x%08x, 0x%08x, 0x%08x)\n", 
        pvSig, cbSig, ptypespec));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(ptypespec);

    m_pStgdb->m_MiniMd.PreUpdate();

    if (CheckDups(MDDupTypeSpec))
    {
    
        hr = ImportHelper::FindTypeSpec(&(m_pStgdb->m_MiniMd), pvSig, cbSig, ptypespec);
        if (SUCCEEDED(hr))
        {
            goto ErrExit;
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create a new record.
    IfNullGo(pTypeSpecRec = m_pStgdb->m_MiniMd.AddTypeSpecRecord(&iRec));

    // Set output parameter.
    *ptypespec = TokenFromRid(iRec, mdtTypeSpec);

    // Set the signature field
    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(
        TBL_TypeSpec, 
        TypeSpecRec::COL_Signature,
        pTypeSpecRec, 
        pvSig, 
        cbSig));
    IfFailGo(UpdateENCLog(*ptypespec));

ErrExit:
    
    STOP_MD_PERF(GetTokenFromTypeSpec);
    return hr;
} // STDAPI RegMeta::GetTokenFromTypeSpec()

//*****************************************************************************
// Hangs the GUID for the format and the url for the actual data off of the
// module using the CORDBG_SYMBOL_URL struct.
//*****************************************************************************
STDAPI RegMeta::SetSymbolBindingPath(   // S_OK or error.
    REFGUID     FormatID,               // [IN] Symbol data format ID.
    LPCWSTR     szSymbolDataPath)       // [IN] URL for the symbols of this module.
{
    CORDBG_SYMBOL_URL *pSymbol;         // Working pointer.
    mdTypeRef   tr;                     // TypeRef for custom attribute.
    mdCustomAttribute cv;               // Throw away token.
    mdToken     tokModule;              // Token for the module.
    HRESULT     hr;

    LOG((LOGMD, "MD RegMeta::SetSymbolBindingPath\n"));
    START_MD_PERF();

    _ASSERTE(szSymbolDataPath && *szSymbolDataPath);

    // No need to lock this function. This function is calling all public APIs. Keep it that way!

    // Allocate room for the blob on the stack and fill it out.
    int ilen = (int)(wcslen(szSymbolDataPath) + 1);
    pSymbol = (CORDBG_SYMBOL_URL *) _alloca((ilen * 2) + sizeof(CORDBG_SYMBOL_URL));
    pSymbol->FormatID = FormatID;
    wcscpy(pSymbol->rcName, szSymbolDataPath);

    // Set the data as a custom value for the item.
    IfFailGo(GetModuleFromScope(&tokModule));
    IfFailGo(DefineTypeRefByName(mdTokenNil, SZ_CORDBG_SYMBOL_URL, &tr));
    hr = DefineCustomAttribute(tokModule, tr, pSymbol, pSymbol->Size(), &cv);

ErrExit:
    STOP_MD_PERF(SetSymbolBindingPath);
    return (hr);
} // RegMeta::SetSymbolBindingPath


//*****************************************************************************
// This API defines a user literal string to be stored in the MetaData section.
// The token for this string has embedded in it the offset into the BLOB pool
// where the string is stored in UNICODE format.  An additional byte is padded
// at the end to indicate whether the string has any characters that are >= 0x80.
//*****************************************************************************
STDAPI RegMeta::DefineUserString(       // S_OK or error.
    LPCWSTR     szString,               // [IN] User literal string.
    ULONG       cchString,              // [IN] Length of string.
    mdString    *pstk)                  // [OUT] String token.
{
    ULONG       ulOffset;               // Offset into the BLOB pool.
    CQuickBytes qb;                     // For storing the string with the byte prefix.
    ULONG       i;                      // Loop counter.
    BOOL        bIs80Plus = false;      // Is there an 80+ WCHAR.
    ULONG       ulMemSize;              // Size of memory taken by the string passed in.
    PBYTE       pb;                     // Pointer into memory allocated by qb.
    HRESULT     hr = S_OK;              // Result.
    WCHAR       c;                      // Temporary used during comparison;

    LOG((LOGMD, "MD RegMeta::DefineUserString(0x%08x, 0x%08x, 0x%08x)\n", 
        szString, cchString, pstk));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(pstk && szString && cchString != ULONG_MAX);

    //
    // Walk the entire string looking for characters that would block us from doing
    // a fast comparison of the string.  These characters include anything greater than
    // 0x80 or an apostrophe or a hyphen.  Apostrophe and hyphen are excluded because
    // they would prevent words like coop and co-op from sorting together in a culture-aware
    // comparison.  We also need to exclude some set of the control characters.  This check
    // is more restrictive 
    //
    for (i=0; i<cchString; i++) {
        c = szString[i];
        if (c>=0x80 || HighCharTable[(int)c]) {
            bIs80Plus = true;
            break;
        }
    }

    // Copy over the string to memory.
    ulMemSize = cchString * sizeof(WCHAR);
    IfFailGo(qb.ReSize(ulMemSize + 1));
    pb = reinterpret_cast<PBYTE>(qb.Ptr());
    memcpy(pb, szString, ulMemSize);
    // Set the last byte of memory to indicate whether there is a 80+ character.
    *(pb + ulMemSize) = bIs80Plus ? 1 : 0;

    IfFailGo(m_pStgdb->m_MiniMd.PutUserString(pb, ulMemSize + 1, &ulOffset));

    // Fail if the offset requires the high byte which is reserved for the token ID.
    if (ulOffset & 0xff000000)
        IfFailGo(META_E_STRINGSPACE_FULL);
    else
        *pstk = TokenFromRid(ulOffset, mdtString);
ErrExit:
    
    STOP_MD_PERF(DefineUserString);
    return hr;
} // RegMeta::DefineUserString

//*****************************************************************************
// Delete a token.
// We only allow deleting a subset of tokens at this moment. These are TypeDef,
//  MethodDef, FieldDef, Event, Property, and CustomAttribute. Except 
//  CustomAttribute, all the other tokens are named. We reserved a special 
//  name COR_DELETED_NAME_A to indicating a named record is deleted when 
//  xxRTSpecialName is set. 
//*****************************************************************************
STDAPI RegMeta::DeleteToken(            // Return code.
        mdToken     tkObj)              // [IN] The token to be deleted
{
    LOG((LOGMD, "MD RegMeta::DeleteToken(0x%08x)\n", tkObj));
    START_MD_PERF();
    LOCKWRITE();

    HRESULT     hr = NOERROR;

    if (!_IsValidToken(tkObj))
        IfFailGo( E_INVALIDARG );

    // make sure that MetaData scope is opened for incremental compilation
    if (!m_pStgdb->m_MiniMd.HasDelete())
    {
        _ASSERTE( !"You cannot call delete token when you did not open the scope with proper Update flags in the SetOption!");
        IfFailGo( E_INVALIDARG );
    }

    _ASSERTE(!m_bSaveOptimized && "Cannot delete records after PreSave() and before Save().");

    switch ( TypeFromToken(tkObj) )
    {
    case mdtTypeDef: 
        {
            TypeDefRec      *pRecord;
            pRecord = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(tkObj));
            IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_TypeDef, TypeDefRec::COL_Name, pRecord, COR_DELETED_NAME_A));        
            pRecord->m_Flags |= (tdSpecialName | tdRTSpecialName);
            break;
        }
    case mdtMethodDef:
        {
            MethodRec      *pRecord;
            pRecord = m_pStgdb->m_MiniMd.getMethod(RidFromToken(tkObj));
            IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_Method, MethodRec::COL_Name, pRecord, COR_DELETED_NAME_A));        
            pRecord->m_Flags |= (mdSpecialName | mdRTSpecialName);
            break;
        }
    case mdtFieldDef:
        {
            FieldRec      *pRecord;
            pRecord = m_pStgdb->m_MiniMd.getField(RidFromToken(tkObj));
            IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_Field, FieldRec::COL_Name, pRecord, COR_DELETED_NAME_A));        
            pRecord->m_Flags |= (fdSpecialName | fdRTSpecialName);
            break;
        }
    case mdtEvent:
        {
            EventRec      *pRecord;
            pRecord = m_pStgdb->m_MiniMd.getEvent(RidFromToken(tkObj));
            IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_Event, EventRec::COL_Name, pRecord, COR_DELETED_NAME_A));        
            pRecord->m_EventFlags |= (evSpecialName | evRTSpecialName);
            break;
        }
    case mdtProperty:
        {
            PropertyRec      *pRecord;
            pRecord = m_pStgdb->m_MiniMd.getProperty(RidFromToken(tkObj));
            IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_Property, PropertyRec::COL_Name, pRecord, COR_DELETED_NAME_A));        
            pRecord->m_PropFlags |= (evSpecialName | evRTSpecialName);
            break;
        }
    case mdtExportedType:
        {
            ExportedTypeRec      *pRecord;
            pRecord = m_pStgdb->m_MiniMd.getExportedType(RidFromToken(tkObj));
            IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_ExportedType, ExportedTypeRec::COL_TypeName, pRecord, COR_DELETED_NAME_A));        
            break;
        }
    case mdtCustomAttribute:
        {
            mdToken         tkParent;
            CustomAttributeRec  *pRecord;
            pRecord = m_pStgdb->m_MiniMd.getCustomAttribute(RidFromToken(tkObj));

            // replace the parent column of the custom value record to a nil token.
            tkParent = m_pStgdb->m_MiniMd.getParentOfCustomAttribute(pRecord);
            tkParent = TokenFromRid( mdTokenNil, TypeFromToken(tkParent) );
            IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_CustomAttribute, CustomAttributeRec::COL_Parent, pRecord, tkParent));

            // now the customvalue table is no longer sorted
            m_pStgdb->m_MiniMd.SetSorted(TBL_CustomAttribute, false);
            break;
        }
    case mdtPermission:
        {
            mdToken         tkParent;
            mdToken         tkNil;
            DeclSecurityRec *pRecord;
            pRecord = m_pStgdb->m_MiniMd.getDeclSecurity(RidFromToken(tkObj));

            // Replace the parent column of the permission record with a nil tokne.
            tkParent = m_pStgdb->m_MiniMd.getParentOfDeclSecurity(pRecord);
            tkNil = TokenFromRid( mdTokenNil, TypeFromToken(tkParent) );
            IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_DeclSecurity, DeclSecurityRec::COL_Parent, pRecord, tkNil ));

            // The table is no longer sorted.
            m_pStgdb->m_MiniMd.SetSorted(TBL_DeclSecurity, false);

            // If the parent has no more security attributes, turn off the "has security" bit.
            HCORENUM        hEnum = 0;
            mdPermission    rPerms[1];
            ULONG           cPerms = 0;
            EnumPermissionSets(&hEnum, tkParent, 0 /* all actions */, rPerms, 1, &cPerms);
            CloseEnum(hEnum);
            if (cPerms == 0)
            {
                void    *pRow;
                ULONG   ixTbl;
                // Get the row for the parent object.
                ixTbl = m_pStgdb->m_MiniMd.GetTblForToken(tkParent);
                _ASSERTE(ixTbl >= 0 && ixTbl <= TBL_COUNT);
                pRow = m_pStgdb->m_MiniMd.getRow(ixTbl, RidFromToken(tkParent));

                switch (TypeFromToken(tkParent))
                {
                case mdtTypeDef:
                    reinterpret_cast<TypeDefRec*>(pRow)->m_Flags &= ~tdHasSecurity;
                    break;
                case mdtMethodDef:
                    reinterpret_cast<MethodRec*>(pRow)->m_Flags &= ~mdHasSecurity;
                    break;
                case mdtAssembly:
                    // No security bit.
                    break;
                }
            }
            break;
        }
    default:
        _ASSERTE(!"Bad token type!");
        IfFailGo( E_INVALIDARG );
        break;
    }

    ErrExit:

    STOP_MD_PERF(DeleteToken);
    return hr;
} // STDAPI RegMeta::DeleteToken

//*****************************************************************************
// Set the properties on the given TypeDef token.
//*****************************************************************************
STDAPI RegMeta::SetTypeDefProps(        // S_OK or error.
    mdTypeDef   td,                     // [IN] The TypeDef.
    DWORD       dwTypeDefFlags,         // [IN] TypeDef flags.
    mdToken     tkExtends,              // [IN] Base TypeDef or TypeRef.
    mdToken     rtkImplements[])        // [IN] Implemented interfaces.
{
    HRESULT     hr = S_OK;              // A result.

    LOG((LOGMD, "RegMeta::SetTypeDefProps(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
            td, dwTypeDefFlags, tkExtends, rtkImplements));
    START_MD_PERF();
    LOCKWRITE();

    hr = _SetTypeDefProps(td, dwTypeDefFlags, tkExtends, rtkImplements);

ErrExit:
    
    STOP_MD_PERF(SetTypeDefProps);
    return hr;
} // RegMeta::SetTypeDefProps


//*****************************************************************************
// Define a Nested Type.
//*****************************************************************************
STDAPI RegMeta::DefineNestedType(       // S_OK or error.
    LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
    DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
    mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
    mdToken     rtkImplements[],        // [IN] Implements interfaces
    mdTypeDef   tdEncloser,             // [IN] TypeDef token of the enclosing type.
    mdTypeDef   *ptd)                   // [OUT] Put TypeDef token here
{
    HRESULT     hr = S_OK;              // A result.

    LOG((LOGMD, "RegMeta::DefineNestedType(%S, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
            MDSTR(szTypeDef), dwTypeDefFlags, tkExtends,
            rtkImplements, tdEncloser, ptd));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(TypeFromToken(tdEncloser) == mdtTypeDef && !IsNilToken(tdEncloser));
    _ASSERTE(IsTdNested(dwTypeDefFlags));

    IfFailGo(_DefineTypeDef(szTypeDef, dwTypeDefFlags,
                tkExtends, rtkImplements, tdEncloser, ptd));
ErrExit:
    STOP_MD_PERF(DefineNestedType);
    return hr;
} // RegMeta::DefineNestedType()

//*****************************************************************************
// Set the properties on the given Method token.
//*****************************************************************************
STDAPI RegMeta::SetMethodProps(         // S_OK or error.
    mdMethodDef md,                     // [IN] The MethodDef.
    DWORD       dwMethodFlags,          // [IN] Method attributes.
    ULONG       ulCodeRVA,              // [IN] Code RVA.
    DWORD       dwImplFlags)            // [IN] MethodImpl flags.
{
    HRESULT     hr = S_OK;
    
    LOG((LOGMD, "RegMeta::SetMethodProps(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
            md, dwMethodFlags, ulCodeRVA, dwImplFlags));
    START_MD_PERF();
    LOCKWRITE();

    if (dwMethodFlags != ULONG_MAX)
    {
        // Make sure no one sets the reserved bits on the way in.
        _ASSERTE((dwMethodFlags & (mdReservedMask&~mdRTSpecialName)) == 0);
        dwMethodFlags &= (~mdReservedMask);
    }

    hr = _SetMethodProps(md, dwMethodFlags, ulCodeRVA, dwImplFlags);

    
    STOP_MD_PERF(SetMethodProps);
    return hr;
} // RegMeta::SetMethodProps

//*****************************************************************************
// Set the properties on the given Event token.
//*****************************************************************************
STDAPI RegMeta::SetEventProps(          // S_OK or error.
    mdEvent     ev,                     // [IN] The event token.
    DWORD       dwEventFlags,           // [IN] CorEventAttr.
    mdToken     tkEventType,            // [IN] A reference (mdTypeRef or mdTypeRef) to the Event class.
    mdMethodDef mdAddOn,                // [IN] Add method.
    mdMethodDef mdRemoveOn,             // [IN] Remove method.
    mdMethodDef mdFire,                 // [IN] Fire method.
    mdMethodDef rmdOtherMethods[])      // [IN] Array of other methods associate with the event.
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::SetEventProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
         ev, dwEventFlags, tkEventType, mdAddOn, mdRemoveOn, mdFire, rmdOtherMethods));
    START_MD_PERF();
    LOCKWRITE();

    IfFailGo(_SetEventProps1(ev, dwEventFlags, tkEventType));
    IfFailGo(_SetEventProps2(ev, mdAddOn, mdRemoveOn, mdFire, rmdOtherMethods, true));
ErrExit:
    
    STOP_MD_PERF(SetEventProps);
    return hr;
} // STDAPI RegMeta::SetEventProps()

//*****************************************************************************
// Set the properties on the given Permission token.
//*****************************************************************************
STDAPI RegMeta::SetPermissionSetProps(  // S_OK or error.
    mdToken     tk,                     // [IN] The object to be decorated.
    DWORD       dwAction,               // [IN] CorDeclSecurity.
    void const  *pvPermission,          // [IN] Permission blob.
    ULONG       cbPermission,           // [IN] Count of bytes of pvPermission.
    mdPermission *ppm)                  // [OUT] Permission token.
{
    HRESULT     hr = S_OK;
    USHORT      sAction = static_cast<USHORT>(dwAction);    // Corresponding DeclSec field is a USHORT.
    mdPermission tkPerm;

    LOG((LOGMD, "MD RegMeta::SetPermissionSetProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        tk, dwAction, pvPermission, cbPermission, ppm));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(TypeFromToken(tk) == mdtTypeDef || TypeFromToken(tk) == mdtMethodDef ||
             TypeFromToken(tk) == mdtAssembly);

    // Check for valid Action.
    if (dwAction == ULONG_MAX || dwAction == 0 || dwAction > dclMaximumValue)
        IfFailGo(E_INVALIDARG);

    IfFailGo(ImportHelper::FindPermission(&(m_pStgdb->m_MiniMd), tk, sAction, &tkPerm));
    if (ppm)
        *ppm = tkPerm;
    IfFailGo(_SetPermissionSetProps(tkPerm, dwAction, pvPermission, cbPermission));
ErrExit:
    
    STOP_MD_PERF(SetPermissionSetProps);
    return hr;
} // RegMeta::SetPermissionSetProps

//*****************************************************************************
// This routine sets the p-invoke information for the specified Field or Method.
//*****************************************************************************
STDAPI RegMeta::DefinePinvokeMap(       // Return code.
    mdToken     tk,                     // [IN] FieldDef or MethodDef.
    DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
    LPCWSTR     szImportName,           // [IN] Import name.
    mdModuleRef mrImportDLL)            // [IN] ModuleRef token for the target DLL.
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::DefinePinvokeMap(0x%08x, 0x%08x, %S, 0x%08x)\n", 
        tk, dwMappingFlags, MDSTR(szImportName), mrImportDLL));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    hr = _DefinePinvokeMap(tk, dwMappingFlags, szImportName, mrImportDLL);

ErrExit:
    
    STOP_MD_PERF(DefinePinvokeMap);
    return hr;
} //RegMeta::DefinePinvokeMap

HRESULT RegMeta::_DefinePinvokeMap(     // Return hresult.
    mdToken     tk,                     // [IN] FieldDef or MethodDef.
    DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
    LPCWSTR     szImportName,           // [IN] Import name.
    mdModuleRef mrImportDLL)            // [IN] ModuleRef token for the target DLL.
{
    ImplMapRec  *pRecord;
    ULONG       iRecord;
    bool        bDupFound = false;
    HRESULT     hr = S_OK;

    _ASSERTE(TypeFromToken(tk) == mdtFieldDef || TypeFromToken(tk) == mdtMethodDef);
    _ASSERTE(TypeFromToken(mrImportDLL) == mdtModuleRef);
    _ASSERTE(RidFromToken(tk) && RidFromToken(mrImportDLL) && szImportName);

    // Turn on the quick lookup flag.
    if (TypeFromToken(tk) == mdtMethodDef)
    {
        if (CheckDups(MDDupMethodDef))
        {
            iRecord = m_pStgdb->m_MiniMd.FindImplMapHelper(tk);
            if (! InvalidRid(iRecord))
                bDupFound = true;
        }
        MethodRec   *pMethod = m_pStgdb->m_MiniMd.getMethod(RidFromToken(tk));
        pMethod->m_Flags |= mdPinvokeImpl;
    }
    else    // TypeFromToken(tk) == mdtFieldDef
    {
        if (CheckDups(MDDupFieldDef))
        {
            iRecord = m_pStgdb->m_MiniMd.FindImplMapHelper(tk);
            if (!InvalidRid(iRecord))
                bDupFound = true;
        }
        FieldRec    *pField = m_pStgdb->m_MiniMd.getField(RidFromToken(tk));
        pField->m_Flags |= fdPinvokeImpl;
    }

    // Create a new record.
    if (bDupFound)
    {
        if (IsENCOn())
            pRecord = m_pStgdb->m_MiniMd.getImplMap(RidFromToken(iRecord));
        else
        {
            hr = META_S_DUPLICATE;
            goto ErrExit;
        }
    }
    else
    {
        IfFailGo(UpdateENCLog(tk));
        IfNullGo(pRecord = m_pStgdb->m_MiniMd.AddImplMapRecord(&iRecord));
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_ImplMap,
                                             ImplMapRec::COL_MemberForwarded, pRecord, tk));
        IfFailGo( m_pStgdb->m_MiniMd.AddImplMapToHash(iRecord) );

    }

    // If no module, create a dummy, empty module.
    if (IsNilToken(mrImportDLL))
    {
        hr = ImportHelper::FindModuleRef(&m_pStgdb->m_MiniMd, "", &mrImportDLL);
        if (hr == CLDB_E_RECORD_NOTFOUND)
            IfFailGo(_DefineModuleRef(L"", &mrImportDLL));
    }
    
    // Set the data.
    if (dwMappingFlags != ULONG_MAX)
        pRecord->m_MappingFlags = static_cast<USHORT>(dwMappingFlags);
    IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_ImplMap, ImplMapRec::COL_ImportName,
                                           pRecord, szImportName));
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_ImplMap,
                                         ImplMapRec::COL_ImportScope, pRecord, mrImportDLL));

    IfFailGo(UpdateENCLog2(TBL_ImplMap, iRecord));
ErrExit:
    
    return hr;
}   // RegMeta::DefinePinvokeMap()

//*****************************************************************************
// This routine sets the p-invoke information for the specified Field or Method.
//*****************************************************************************
STDAPI RegMeta::SetPinvokeMap(          // Return code.
    mdToken     tk,                     // [IN] FieldDef or MethodDef.
    DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
    LPCWSTR     szImportName,           // [IN] Import name.
    mdModuleRef mrImportDLL)            // [IN] ModuleRef token for the target DLL.
{
    ImplMapRec  *pRecord;
    ULONG       iRecord;
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::SetPinvokeMap(0x%08x, 0x%08x, %S, 0x%08x)\n", 
        tk, dwMappingFlags, MDSTR(szImportName), mrImportDLL));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(TypeFromToken(tk) == mdtFieldDef || TypeFromToken(tk) == mdtMethodDef);
    _ASSERTE(RidFromToken(tk));
    
    iRecord = m_pStgdb->m_MiniMd.FindImplMapHelper(tk);

    if (InvalidRid(iRecord))
        IfFailGo(CLDB_E_RECORD_NOTFOUND);
    else
        pRecord = m_pStgdb->m_MiniMd.getImplMap(iRecord);

    // Set the data.
    if (dwMappingFlags != ULONG_MAX)
        pRecord->m_MappingFlags = static_cast<USHORT>(dwMappingFlags);
    if (szImportName)
        IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_ImplMap, ImplMapRec::COL_ImportName,
                                               pRecord, szImportName));
    if (! IsNilToken(mrImportDLL))
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_ImplMap, ImplMapRec::COL_ImportScope,
                                               pRecord, mrImportDLL));

    IfFailGo(UpdateENCLog2(TBL_ImplMap, iRecord));

ErrExit:
    
    STOP_MD_PERF(SetPinvokeMap);
    return hr;
}   // RegMeta::SetPinvokeMap()

//*****************************************************************************
// This routine deletes the p-invoke record for the specified Field or Method.
//*****************************************************************************
STDAPI RegMeta::DeletePinvokeMap(       // Return code.
    mdToken     tk)                     // [IN]FieldDef or MethodDef.
{
    HRESULT     hr = S_OK;
    ImplMapRec  *pRecord;
    RID         iRecord;

    LOG((LOGMD, "MD RegMeta::DeletePinvokeMap(0x%08x)\n", tk));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(TypeFromToken(tk) == mdtFieldDef || TypeFromToken(tk) == mdtMethodDef);
    _ASSERTE(!IsNilToken(tk));
    _ASSERTE(!m_bSaveOptimized && "Cannot delete records after PreSave() and before Save().");

    // Get the PinvokeMap record.
    iRecord = m_pStgdb->m_MiniMd.FindImplMapHelper(tk);
    if (InvalidRid(iRecord))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    pRecord = m_pStgdb->m_MiniMd.getImplMap(iRecord);

    // Clear the MemberForwarded token from the PinvokeMap record.
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_ImplMap,
                    ImplMapRec::COL_MemberForwarded, pRecord, mdFieldDefNil));

    // turn off the PinvokeImpl bit.
    if (TypeFromToken(tk) == mdtFieldDef)
    {
        FieldRec    *pFieldRec;

        pFieldRec = m_pStgdb->m_MiniMd.getField(RidFromToken(tk));
        pFieldRec->m_Flags &= ~fdPinvokeImpl;
    }
    else // TypeFromToken(tk) == mdtMethodDef
    {
        MethodRec   *pMethodRec;

        pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(tk));
        pMethodRec->m_Flags &= ~mdPinvokeImpl;
    }

    // Update the ENC log for the parent token.
    IfFailGo(UpdateENCLog(tk));
    // Create the log record for the non-token record.
    IfFailGo(UpdateENCLog2(TBL_ImplMap, iRecord));

ErrExit:
    STOP_MD_PERF(DeletePinvokeMap);
    return hr;
}   // RegMeta::DeletePinvokeMap()

//*****************************************************************************
// Create and define a new FieldDef record.
//*****************************************************************************
HRESULT RegMeta::DefineField(           // S_OK or error. 
    mdTypeDef   td,                     // Parent TypeDef   
    LPCWSTR     szName,                 // Name of member   
    DWORD       dwFieldFlags,           // Member attributes    
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
    DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
    void const  *pValue,                // [IN] constant value  
    ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
    mdFieldDef  *pmd)                   // [OUT] Put member token here    
{
    HRESULT hr = S_OK;                  // A result.
    FieldRec    *pRecord = NULL;        // The new record.
    RID         iRecord;                // RID of new record.
    LPUTF8      szNameUtf8 = UTF8STR(szName);   
    
    LOG((LOGMD, "MD: RegMeta::DefineField(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        td, MDSTR(szName), dwFieldFlags, pvSigBlob, cbSigBlob, dwCPlusTypeFlag, pValue, cchValue, pmd));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(pmd);

    m_pStgdb->m_MiniMd.PreUpdate();
    IsGlobalMethodParent(&td);
    
    // Validate flags.
    if (dwFieldFlags != ULONG_MAX)
    {
        // fdHasFieldRVA is settable, but not re-settable by applications.
        _ASSERTE((dwFieldFlags & (fdReservedMask&~(fdHasFieldRVA|fdRTSpecialName))) == 0);
        dwFieldFlags &= ~(fdReservedMask&~fdHasFieldRVA);
    }

    // See if this field has already been defined as a forward reference
    // from a MemberRef.  If so, then update the data to match what we know now.
    if (CheckDups(MDDupFieldDef))
    {

        hr = ImportHelper::FindField(&(m_pStgdb->m_MiniMd), 
            td, 
            szNameUtf8,
            pvSigBlob,
            cbSigBlob,
            pmd);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pRecord = m_pStgdb->m_MiniMd.getField(RidFromToken(*pmd));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create a new record.
    if (!pRecord)
    {
        // Create the field record.
        IfNullGo(pRecord=m_pStgdb->m_MiniMd.AddFieldRecord(&iRecord));

        // Set output parameter pmd.
        *pmd = TokenFromRid(iRecord, mdtFieldDef);

        // Add to parent's list of child records.
        IfFailGo(m_pStgdb->m_MiniMd.AddFieldToTypeDef(RidFromToken(td), iRecord));

        IfFailGo(UpdateENCLog(td, CMiniMdRW::eDeltaFieldCreate));

        // record the more defs are introduced.
        SetMemberDefDirty(true);
    }

    // Set the Field properties.
    IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_Field, FieldRec::COL_Name, pRecord, szNameUtf8));
    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_Field, FieldRec::COL_Signature, pRecord,
                                        pvSigBlob, cbSigBlob));

    // Check to see if it is value__ for enum type
	// @FUTURE: shouldn't we have checked the type containing the field to be a Enum type first of all?
    if (!wcscmp(szName, COR_ENUM_FIELD_NAME_W))
    {
        dwFieldFlags |= fdRTSpecialName | fdSpecialName;
    }
    SetCallerDefine();
    IfFailGo(_SetFieldProps(*pmd, dwFieldFlags, dwCPlusTypeFlag, pValue, cchValue));
    IfFailGo(m_pStgdb->m_MiniMd.AddMemberDefToHash(*pmd, td) ); 

ErrExit:
    SetCallerExternal();
    
    STOP_MD_PERF(DefineField);
    return hr;
} // HRESULT RegMeta::DefineField()

//*****************************************************************************
// Define and set a Property record.
//*****************************************************************************
HRESULT RegMeta::DefineProperty( 
    mdTypeDef   td,                     // [IN] the class/interface on which the property is being defined  
    LPCWSTR     szProperty,             // [IN] Name of the property    
    DWORD       dwPropFlags,            // [IN] CorPropertyAttr 
    PCCOR_SIGNATURE pvSig,              // [IN] the required type signature 
    ULONG       cbSig,                  // [IN] the size of the type signature blob 
    DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
    void const  *pValue,                // [IN] constant value  
    ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
    mdMethodDef mdSetter,               // [IN] optional setter of the property 
    mdMethodDef mdGetter,               // [IN] optional getter of the property 
    mdMethodDef rmdOtherMethods[],      // [IN] an optional array of other methods  
    mdProperty  *pmdProp)               // [OUT] output property token  
{
    HRESULT     hr = S_OK;
    PropertyRec *pPropRec = NULL;
    RID         iPropRec;
    PropertyMapRec *pPropMap;
    RID         iPropMap;
    LPCUTF8     szUTF8Property = UTF8STR(szProperty);
    ULONG       ulValue = 0;

    LOG((LOGMD, "MD RegMeta::DefineProperty(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        td, szProperty, dwPropFlags, pvSig, cbSig, dwCPlusTypeFlag, pValue, cchValue, mdSetter, mdGetter, 
        rmdOtherMethods, pmdProp));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(TypeFromToken(td) == mdtTypeDef && td != mdTypeDefNil &&
            szProperty && pvSig && cbSig && pmdProp);

    if (CheckDups(MDDupProperty))
    {
        hr = ImportHelper::FindProperty(&(m_pStgdb->m_MiniMd), td, szUTF8Property, pvSig, cbSig, pmdProp);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pPropRec = m_pStgdb->m_MiniMd.getProperty(RidFromToken(*pmdProp));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    if (! pPropRec)
    {
        // Create a new map if one doesn't exist already, else retrieve the existing one.
        // The property map must be created before the PropertyRecord, the new property
        // map will be pointing past the first property record.
        iPropMap = m_pStgdb->m_MiniMd.FindPropertyMapFor(RidFromToken(td));
        if (InvalidRid(iPropMap))
        {
            // Create new record.
            IfNullGo(pPropMap=m_pStgdb->m_MiniMd.AddPropertyMapRecord(&iPropMap));
            // Set parent.
            IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_PropertyMap,
                                                PropertyMapRec::COL_Parent, pPropMap, td));
            IfFailGo(UpdateENCLog2(TBL_PropertyMap, iPropMap));
        }
        else
        {
            pPropMap = m_pStgdb->m_MiniMd.getPropertyMap(iPropMap);
        }

        // Create a new record.
        IfNullGo(pPropRec = m_pStgdb->m_MiniMd.AddPropertyRecord(&iPropRec));

        // Set output parameter.
        *pmdProp = TokenFromRid(iPropRec, mdtProperty);

        // Add Property to the PropertyMap.
        IfFailGo(m_pStgdb->m_MiniMd.AddPropertyToPropertyMap(RidFromToken(iPropMap), iPropRec));

        IfFailGo(UpdateENCLog2(TBL_PropertyMap, iPropMap, CMiniMdRW::eDeltaPropertyCreate));
    }

    // Save the data.
    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_Property, PropertyRec::COL_Type, pPropRec,
                                        pvSig, cbSig));
    IfFailGo( m_pStgdb->m_MiniMd.PutString(TBL_Property, PropertyRec::COL_Name,
                                            pPropRec, szUTF8Property) );

    SetCallerDefine();
    IfFailGo(_SetPropertyProps(*pmdProp, dwPropFlags, dwCPlusTypeFlag, pValue, cchValue, mdSetter,
                              mdGetter, rmdOtherMethods));

    // Add the <property token, typedef token> to the lookup table
    if (m_pStgdb->m_MiniMd.HasIndirectTable(TBL_Property))
        IfFailGo( m_pStgdb->m_MiniMd.AddPropertyToLookUpTable(*pmdProp, td) );

ErrExit:
    SetCallerExternal();
    
    STOP_MD_PERF(DefineProperty);
    return hr;
} // HRESULT RegMeta::DefineProperty()

//*****************************************************************************
// Create a record in the Param table. Any set of name, flags, or default value
// may be set.
//*****************************************************************************
HRESULT RegMeta::DefineParam(
    mdMethodDef md,                     // [IN] Owning method   
    ULONG       ulParamSeq,             // [IN] Which param 
    LPCWSTR     szName,                 // [IN] Optional param name 
    DWORD       dwParamFlags,           // [IN] Optional param flags    
    DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
    void const  *pValue,                // [IN] constant value  
    ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
    mdParamDef  *ppd)                   // [OUT] Put param token here   
{
    HRESULT     hr = S_OK;
    RID         iRecord;
    ParamRec    *pRecord = 0;

    LOG((LOGMD, "MD RegMeta::DefineParam(0x%08x, 0x%08x, %S, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        md, ulParamSeq, MDSTR(szName), dwParamFlags, dwCPlusTypeFlag, pValue, cchValue, ppd));
    START_MD_PERF();
    LOCKWRITE();

    _ASSERTE(TypeFromToken(md) == mdtMethodDef && md != mdMethodDefNil &&
             ulParamSeq != ULONG_MAX && ppd);

    m_pStgdb->m_MiniMd.PreUpdate();

    // Retrieve or create the Param row.
    if (CheckDups(MDDupParamDef))
    {
        hr = _FindParamOfMethod(md, ulParamSeq, ppd);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pRecord = m_pStgdb->m_MiniMd.getParam(RidFromToken(*ppd));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    if (!pRecord)
    {
        // Create the Param record.
        IfNullGo(pRecord=m_pStgdb->m_MiniMd.AddParamRecord(&iRecord));

        // Set the output parameter.
        *ppd = TokenFromRid(iRecord, mdtParamDef);

        // Set sequence number.
        pRecord->m_Sequence = static_cast<USHORT>(ulParamSeq);

        // Add to the parent's list of child records.
        IfFailGo(m_pStgdb->m_MiniMd.AddParamToMethod(RidFromToken(md), iRecord));
        
        IfFailGo(UpdateENCLog(md, CMiniMdRW::eDeltaParamCreate));
    }

    SetCallerDefine();
    // Set the properties.
    IfFailGo(_SetParamProps(*ppd, szName, dwParamFlags, dwCPlusTypeFlag, pValue, cchValue));

ErrExit:
    SetCallerExternal();
    
    STOP_MD_PERF(DefineParam);
    return hr;
} // HRESULT RegMeta::DefineParam()

//*****************************************************************************
// Set the properties on the given Field token.
//*****************************************************************************
HRESULT RegMeta::SetFieldProps(           // S_OK or error.
    mdFieldDef  fd,                     // [IN] The FieldDef.
    DWORD       dwFieldFlags,           // [IN] Field attributes.
    DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
    void const  *pValue,                // [IN] Constant value.
    ULONG       cchValue)               // [IN] size of constant value (string, in wide chars).
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD: RegMeta::SetFieldProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        fd, dwFieldFlags, dwCPlusTypeFlag, pValue, cchValue));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    // Validate flags.
    if (dwFieldFlags != ULONG_MAX)
    {
        // fdHasFieldRVA is settable, but not re-settable by applications.
        _ASSERTE((dwFieldFlags & (fdReservedMask&~(fdHasFieldRVA|fdRTSpecialName))) == 0);
        dwFieldFlags &= ~(fdReservedMask&~fdHasFieldRVA);
    }

    hr = _SetFieldProps(fd, dwFieldFlags, dwCPlusTypeFlag, pValue, cchValue);

ErrExit:
    
    STOP_MD_PERF(SetFieldProps);
    return hr;
} // HRESULT RegMeta::SetFieldProps()

//*****************************************************************************
// Set the properties on the given Property token.
//*****************************************************************************
HRESULT RegMeta::SetPropertyProps(      // S_OK or error.
    mdProperty  pr,                     // [IN] Property token.
    DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
    DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
    void const  *pValue,                // [IN] Constant value.
    ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
    mdMethodDef mdSetter,               // [IN] Setter of the property.
    mdMethodDef mdGetter,               // [IN] Getter of the property.
    mdMethodDef rmdOtherMethods[])      // [IN] Array of other methods.
{
    BOOL        bClear = IsCallerExternal() || IsENCOn();
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::SetPropertyProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        pr, dwPropFlags, dwCPlusTypeFlag, pValue, cchValue, mdSetter, mdGetter,
        rmdOtherMethods));
    START_MD_PERF();
    LOCKWRITE();

    hr = _SetPropertyProps(pr, dwPropFlags, dwCPlusTypeFlag, pValue, cchValue, mdSetter, mdGetter, rmdOtherMethods);

ErrExit:
    
    STOP_MD_PERF(SetPropertyProps);
    return hr;
} // HRESULT RegMeta::SetPropertyProps()


//*****************************************************************************
// This routine sets properties on the given Param token.
//*****************************************************************************
HRESULT RegMeta::SetParamProps(         // Return code.
    mdParamDef  pd,                     // [IN] Param token.   
    LPCWSTR     szName,                 // [IN] Param name.
    DWORD       dwParamFlags,           // [IN] Param flags.
    DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
    void const  *pValue,                // [OUT] Constant value.
    ULONG       cchValue)               // [IN] size of constant value (string, in wide chars).
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::SetParamProps(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        pd, MDSTR(szName), dwParamFlags, dwCPlusTypeFlag, pValue, cchValue));
    START_MD_PERF();
    LOCKWRITE();

    hr = _SetParamProps(pd, szName, dwParamFlags, dwCPlusTypeFlag, pValue, cchValue);
ErrExit:
    
    STOP_MD_PERF(SetParamProps);
    return hr;
} // HRESULT RegMeta::SetParamProps()

//*****************************************************************************
// Apply edit and continue changes to this metadata.
//*****************************************************************************
STDAPI RegMeta::ApplyEditAndContinue(   // S_OK or error.
    IUnknown    *pUnk)                  // [IN] Metadata from the delta PE.
{
    HRESULT     hr;                     // A result.
    IMetaDataImport *pImport=0;         // Interface on the delta metadata.
    RegMeta     *pDeltaMD=0;            // The delta metadata.

    // Get the MiniMd on the delta.
    if (FAILED(hr=pUnk->QueryInterface(IID_IMetaDataImport, (void**)&pImport)))
        return hr;
    pDeltaMD = static_cast<RegMeta*>(pImport);

    CMiniMdRW   &mdDelta = pDeltaMD->m_pStgdb->m_MiniMd;
    CMiniMdRW   &mdBase = m_pStgdb->m_MiniMd;

    IfFailGo(mdBase.ConvertToRW());
    IfFailGo(mdBase.ApplyDelta(mdDelta));

ErrExit:
    if (pImport)
        pImport->Release();
    return hr;

} // STDAPI RegMeta::ApplyEditAndContinue()

BOOL RegMeta::HighCharTable[]= {
    FALSE,     /* 0x0, 0x0 */
        TRUE, /* 0x1, */
        TRUE, /* 0x2, */
        TRUE, /* 0x3, */
        TRUE, /* 0x4, */
        TRUE, /* 0x5, */
        TRUE, /* 0x6, */
        TRUE, /* 0x7, */
        TRUE, /* 0x8, */
        FALSE, /* 0x9,   */
        FALSE, /* 0xA,  */
        FALSE, /* 0xB, */
        FALSE, /* 0xC, */
        FALSE, /* 0xD,  */
        TRUE, /* 0xE, */
        TRUE, /* 0xF, */
        TRUE, /* 0x10, */
        TRUE, /* 0x11, */
        TRUE, /* 0x12, */
        TRUE, /* 0x13, */
        TRUE, /* 0x14, */
        TRUE, /* 0x15, */
        TRUE, /* 0x16, */
        TRUE, /* 0x17, */
        TRUE, /* 0x18, */
        TRUE, /* 0x19, */
        TRUE, /* 0x1A, */
        TRUE, /* 0x1B, */
        TRUE, /* 0x1C, */
        TRUE, /* 0x1D, */
        TRUE, /* 0x1E, */
        TRUE, /* 0x1F, */
        FALSE, /*0x20,  */
        FALSE, /*0x21, !*/
        FALSE, /*0x22, "*/
        FALSE, /*0x23,  #*/
        FALSE, /*0x24,  $*/
        FALSE, /*0x25,  %*/
        FALSE, /*0x26,  &*/
        TRUE,  /*0x27, '*/
        FALSE, /*0x28, (*/
        FALSE, /*0x29, )*/
        FALSE, /*0x2A **/
        FALSE, /*0x2B, +*/
        FALSE, /*0x2C, ,*/
        TRUE,  /*0x2D, -*/
        FALSE, /*0x2E, .*/
        FALSE, /*0x2F, /*/
        FALSE, /*0x30, 0*/
        FALSE, /*0x31, 1*/
        FALSE, /*0x32, 2*/
        FALSE, /*0x33, 3*/
        FALSE, /*0x34, 4*/
        FALSE, /*0x35, 5*/
        FALSE, /*0x36, 6*/
        FALSE, /*0x37, 7*/
        FALSE, /*0x38, 8*/
        FALSE, /*0x39, 9*/
        FALSE, /*0x3A, :*/
        FALSE, /*0x3B, ;*/
        FALSE, /*0x3C, <*/
        FALSE, /*0x3D, =*/
        FALSE, /*0x3E, >*/
        FALSE, /*0x3F, ?*/
        FALSE, /*0x40, @*/
        FALSE, /*0x41, A*/
        FALSE, /*0x42, B*/
        FALSE, /*0x43, C*/
        FALSE, /*0x44, D*/
        FALSE, /*0x45, E*/
        FALSE, /*0x46, F*/
        FALSE, /*0x47, G*/
        FALSE, /*0x48, H*/
        FALSE, /*0x49, I*/
        FALSE, /*0x4A, J*/
        FALSE, /*0x4B, K*/
        FALSE, /*0x4C, L*/
        FALSE, /*0x4D, M*/
        FALSE, /*0x4E, N*/
        FALSE, /*0x4F, O*/
        FALSE, /*0x50, P*/
        FALSE, /*0x51, Q*/
        FALSE, /*0x52, R*/
        FALSE, /*0x53, S*/
        FALSE, /*0x54, T*/
        FALSE, /*0x55, U*/
        FALSE, /*0x56, V*/
        FALSE, /*0x57, W*/
        FALSE, /*0x58, X*/
        FALSE, /*0x59, Y*/
        FALSE, /*0x5A, Z*/
        FALSE, /*0x5B, [*/
        FALSE, /*0x5C, \*/
        FALSE, /*0x5D, ]*/
        FALSE, /*0x5E, ^*/
        FALSE, /*0x5F, _*/
        FALSE, /*0x60, `*/
        FALSE, /*0x61, a*/
        FALSE, /*0x62, b*/
        FALSE, /*0x63, c*/
        FALSE, /*0x64, d*/
        FALSE, /*0x65, e*/
        FALSE, /*0x66, f*/
        FALSE, /*0x67, g*/
        FALSE, /*0x68, h*/
        FALSE, /*0x69, i*/
        FALSE, /*0x6A, j*/
        FALSE, /*0x6B, k*/
        FALSE, /*0x6C, l*/
        FALSE, /*0x6D, m*/
        FALSE, /*0x6E, n*/
        FALSE, /*0x6F, o*/
        FALSE, /*0x70, p*/
        FALSE, /*0x71, q*/
        FALSE, /*0x72, r*/
        FALSE, /*0x73, s*/
        FALSE, /*0x74, t*/
        FALSE, /*0x75, u*/
        FALSE, /*0x76, v*/
        FALSE, /*0x77, w*/
        FALSE, /*0x78, x*/
        FALSE, /*0x79, y*/
        FALSE, /*0x7A, z*/
        FALSE, /*0x7B, {*/
        FALSE, /*0x7C, |*/
        FALSE, /*0x7D, }*/
        FALSE, /*0x7E, ~*/
        TRUE, /*0x7F, */
        };

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\disp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Disp.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************
#ifndef __Disp__h__
#define __Disp__h__


class Disp :
    public IMetaDataDispenserEx
{
public:
    Disp();
    ~Disp();

    // *** IUnknown methods ***
    STDMETHODIMP    QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef(void); 
    STDMETHODIMP_(ULONG) Release(void);

    // *** IMetaDataDispenser methods ***
    STDMETHODIMP DefineScope(               // Return code.
        REFCLSID    rclsid,                 // [in] What version to create.
        DWORD       dwCreateFlags,          // [in] Flags on the create.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk);              // [out] Return interface on success.

    STDMETHODIMP OpenScope(                 // Return code.
        LPCWSTR     szScope,                // [in] The scope to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk);              // [out] Return interface on success.

    STDMETHODIMP OpenScopeOnMemory(         // Return code.
        LPCVOID     pData,                  // [in] Location of scope data.
        ULONG       cbData,                 // [in] Size of the data pointed to by pData.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk);              // [out] Return interface on success.

    // *** IMetaDataDispenserEx methods ***
    STDMETHODIMP SetOption(                 // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        const VARIANT *pvalue);             // [in] Value to which the option is to be set.

    STDMETHODIMP GetOption(                 // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        VARIANT *pvalue);                   // [out] Value to which the option is currently set.

    STDMETHODIMP OpenScopeOnITypeInfo(      // Return code.
        ITypeInfo   *pITI,                  // [in] ITypeInfo to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk);              // [out] Return interface on success.
                                
    STDMETHODIMP GetCORSystemDirectory(     // Return code.
         LPWSTR      szBuffer,              // [out] Buffer for the directory name
         DWORD       cchBuffer,             // [in] Size of the buffer
         DWORD*      pchBuffer);            // [OUT] Number of characters returned

    STDMETHODIMP FindAssembly(              // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN] the name buffer's size
        ULONG    *pcName);                  // [OUT] the number of characters returend in the buffer

    STDMETHODIMP FindAssemblyModule(        // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szModuleName,              // [IN] required - the name of the module
        LPWSTR   szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN]  the name buffer's size
        ULONG    *pcName);                  // [OUT] the number of characters returend in the buffer
    // Class factory hook-up.
    static HRESULT CreateObject(REFIID riid, void **ppUnk);

private:
    ULONG       m_cRef;                 // Ref count
    OptionValue m_OptionValue;          // values can be set by using SetOption
    WCHAR       *m_Namespace;
    CHAR        *m_RuntimeVersion;
};

#endif // __Disp__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\filtermanager.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
 	//*****************************************************************************
// FilterManager.cpp
//
// contains utility code to MD directory
//
//*****************************************************************************
#include "stdafx.h"
#include "FilterManager.h"
#include "TokenMapper.h"

#define IsGlobalTypeDef(td) (td == TokenFromRid(mdtTypeDef, 1))

//*****************************************************************************
// Walk up to the containing tree and 
// mark the transitive closure of the root token
//*****************************************************************************
HRESULT FilterManager::Mark(mdToken tk)
{
	HRESULT		hr = NOERROR;
	mdTypeDef	td;

	// We hard coded System.Object as mdTypeDefNil
	// The backing Field of property can be NULL as well.
	if (RidFromToken(tk) == mdTokenNil)
		goto ErrExit;

	switch ( TypeFromToken(tk) )
	{
	case mdtTypeDef: 
		IfFailGo( MarkTypeDef(tk) );
		break;

	case mdtMethodDef:
		// Get the typedef containing the MethodDef and mark the whole type
		IfFailGo( m_pMiniMd->FindParentOfMethodHelper(tk, &td) );

        // Global function so only mark the function itself and the typedef.
        // Don't call MarkTypeDef. That will trigger all of the global methods/fields
        // marked.
        //
        if (IsGlobalTypeDef(td))
        {
	        IfFailGo( m_pMiniMd->GetFilterTable()->MarkTypeDef(td) );
            IfFailGo( MarkMethod(tk) );
        }
        else
        {
		    IfFailGo( MarkTypeDef(td) );
        }
		break;

	case mdtFieldDef:
		// Get the typedef containing the FieldDef and mark the whole type
		IfFailGo( m_pMiniMd->FindParentOfFieldHelper(tk, &td) );
        if (IsGlobalTypeDef(td))
        {
	        IfFailGo( m_pMiniMd->GetFilterTable()->MarkTypeDef(td) );
            IfFailGo( MarkField(tk) );
        }
        else
        {
		    IfFailGo( MarkTypeDef(td) );
        }
		break;

	case mdtMemberRef:
		IfFailGo( MarkMemberRef(tk) );
		break;

	case mdtTypeRef:
		IfFailGo( MarkTypeRef(tk) );
		break;

	case mdtTypeSpec:
		IfFailGo( MarkTypeSpec(tk) );
		break;
	case mdtSignature:
		IfFailGo( MarkStandAloneSig(tk) );
		break;

	case mdtModuleRef:
		IfFailGo( MarkModuleRef(tk) );
		break;

    case mdtAssemblyRef:
        IfFailGo( MarkAssemblyRef(tk) );
        break;

    case mdtModule:
		IfFailGo( MarkModule(tk) );
		break;

	case mdtString:

		IfFailGo( MarkUserString(tk) );
		break;

    case mdtBaseType:
        // don't need to mark any base type.
        break;

    case mdtAssembly:
        IfFailGo( MarkAssembly(tk) );
        break;

	case mdtProperty:
	case mdtEvent:
	case mdtParamDef:
	case mdtInterfaceImpl:
	default:
		_ASSERTE(!" unknown type!");
		hr = E_INVALIDARG;
		break;
	}
ErrExit:
	return hr;
}	// Mark



//*****************************************************************************
// marking only module property
//*****************************************************************************
HRESULT FilterManager::MarkAssembly(mdAssembly as)
{
	HRESULT			hr = NOERROR;
	IHostFilter		*pFilter = m_pMiniMd->GetHostFilter();

    if (hasAssemblyBeenMarked == false)
    {
        hasAssemblyBeenMarked = true;
	    IfFailGo( MarkCustomAttributesWithParentToken(as) );
	    IfFailGo( MarkDeclSecuritiesWithParentToken(as) );
    }
ErrExit:
	return hr;
}	// MarkAssembly


//*****************************************************************************
// marking only module property
//*****************************************************************************
HRESULT FilterManager::MarkModule(mdModule mo)
{
	HRESULT			hr = NOERROR;
	IHostFilter		*pFilter = m_pMiniMd->GetHostFilter();

    if (hasModuleBeenMarked == false)
    {
        hasModuleBeenMarked = true;
	    IfFailGo( MarkCustomAttributesWithParentToken(mo) );
    }
ErrExit:
	return hr;
}	// MarkModule


//*****************************************************************************
// cascading Mark of a CustomAttribute
//*****************************************************************************
HRESULT FilterManager::MarkCustomAttribute(mdCustomAttribute cv)
{
	HRESULT		hr = NOERROR;
    CustomAttributeRec *pRec;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkCustomAttribute( cv ) );

    // Mark the type (and any family) of the CustomAttribue.
	pRec = m_pMiniMd->getCustomAttribute(RidFromToken(cv));
	IfFailGo( Mark(m_pMiniMd->getTypeOfCustomAttribute(pRec)) );

ErrExit:
	return hr;
}	// MarkCustomAttribute


//*****************************************************************************
// cascading Mark of a DeclSecurity
//*****************************************************************************
HRESULT FilterManager::MarkDeclSecurity(mdPermission pe)
{
	HRESULT		hr = NOERROR;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkDeclSecurity( pe ) );
ErrExit:
	return hr;
}	// eclSecurity



//*****************************************************************************
// cascading Mark of a signature
//*****************************************************************************
HRESULT FilterManager::MarkStandAloneSig(mdSignature sig)
{
	HRESULT			hr = NOERROR;
	StandAloneSigRec	*pRec;
	ULONG			cbSize;
	IHostFilter		*pFilter = m_pMiniMd->GetHostFilter();


	// if TypeRef is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsSignatureMarked(sig))
		goto ErrExit;

	// To mark the signature, we will need to mark
	// all of the embedded TypeRef or TypeDef
	//
	IfFailGo( m_pMiniMd->GetFilterTable()->MarkSignature( sig ) );
	
	if (pFilter)
		pFilter->MarkToken(sig);

	// Walk the signature and mark all of the embedded types
	pRec = m_pMiniMd->getStandAloneSig(RidFromToken(sig));
	IfFailGo( MarkSignature(m_pMiniMd->getSignatureOfStandAloneSig(pRec, &cbSize), NULL) );

	IfFailGo( MarkCustomAttributesWithParentToken(sig) );
ErrExit:
	return hr;
}	// MarkStandAloneSig



//*****************************************************************************
// cascading Mark of a TypeSpec
//*****************************************************************************
HRESULT FilterManager::MarkTypeSpec(mdTypeSpec ts)
{
	HRESULT			hr = NOERROR;
	TypeSpecRec		*pRec;
	ULONG			cbSize;
	IHostFilter		*pFilter = m_pMiniMd->GetHostFilter();

	// if TypeRef is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsTypeSpecMarked(ts))
		goto ErrExit;

	// To mark the TypeSpec, we will need to mark
	// all of the embedded TypeRef or TypeDef
	//
	IfFailGo( m_pMiniMd->GetFilterTable()->MarkTypeSpec( ts ) );

	if (pFilter)
		pFilter->MarkToken(ts);

	// Walk the signature and mark all of the embedded types
	pRec = m_pMiniMd->getTypeSpec(RidFromToken(ts));
	IfFailGo( MarkFieldSignature(m_pMiniMd->getSignatureOfTypeSpec(pRec, &cbSize), NULL) );
	IfFailGo( MarkCustomAttributesWithParentToken(ts) );


ErrExit:
	return hr;
}	// MarkTypeSpec




//*****************************************************************************
// cascading Mark of a TypeRef
//*****************************************************************************
HRESULT FilterManager::MarkTypeRef(mdTypeRef tr)
{
	HRESULT			hr = NOERROR;
	TOKENMAP		*tkMap;
	mdTypeDef		td;
	IHostFilter		*pFilter = m_pMiniMd->GetHostFilter();
    TypeRefRec      *pRec;
    mdToken         parentTk;

	// if TypeRef is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsTypeRefMarked(tr))
		goto ErrExit;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkTypeRef( tr ) );

    if (pFilter)
		pFilter->MarkToken(tr);

    pRec = m_pMiniMd->getTypeRef(RidFromToken(tr));
	parentTk = m_pMiniMd->getResolutionScopeOfTypeRef(pRec);
    if ( RidFromToken(parentTk) )
    {
  	    IfFailGo( Mark( parentTk ) );
    }

	tkMap = m_pMiniMd->GetTypeRefToTypeDefMap();
	td = *(tkMap->Get(RidFromToken(tr)));
	if ( td != mdTokenNil )
	{
		// TypeRef is referring to a TypeDef within the same module.
		// Mark the TypeDef as well.
		//	
		IfFailGo( Mark(td) );
	}

	IfFailGo( MarkCustomAttributesWithParentToken(tr) );

ErrExit:
	return hr;
}	// MarkTypeRef


//*****************************************************************************
// cascading Mark of a MemberRef
//*****************************************************************************
HRESULT FilterManager::MarkMemberRef(mdMemberRef mr)
{
	HRESULT			hr = NOERROR;
	MemberRefRec	*pRec;
	ULONG			cbSize;
	IHostFilter		*pFilter = m_pMiniMd->GetHostFilter();
	mdToken			md;					
	TOKENMAP		*tkMap;
    mdToken         tkParent;

	// if MemberRef is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsMemberRefMarked(mr))
		goto ErrExit;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkMemberRef( mr ) );

	if (pFilter)
		pFilter->MarkToken(mr);

	pRec = m_pMiniMd->getMemberRef(RidFromToken(mr));

	// we want to mark the parent of MemberRef as well
    tkParent = m_pMiniMd->getClassOfMemberRef(pRec);

    // If the parent is the global TypeDef, mark only the TypeDef itself (low-level function).
    // Other parents, do the transitive mark (ie, the high-level function).
    //
    if (IsGlobalTypeDef(tkParent))
	    IfFailGo( m_pMiniMd->GetFilterTable()->MarkTypeDef( tkParent ) );
    else
	    IfFailGo( Mark( tkParent ) );

	// Walk the signature and mark all of the embedded types
	IfFailGo( MarkSignature(m_pMiniMd->getSignatureOfMemberRef(pRec, &cbSize), NULL) );

	tkMap = m_pMiniMd->GetMemberRefToMemberDefMap();
	md = *(tkMap->Get(RidFromToken(mr)));			// can be fielddef or methoddef
	if ( RidFromToken(md) != mdTokenNil )
	{
		// MemberRef is referring to either a FieldDef or MethodDef.
		// If it is referring to MethodDef, we have fix the parent of MemberRef to be the MethodDef.
		// However, if it is mapped to a FieldDef, the parent column does not track this information.
		// Therefore we need to mark it explicitly.
		//	
		IfFailGo( Mark(md) );
	}

	IfFailGo( MarkCustomAttributesWithParentToken(mr) );

ErrExit:
	return hr;
}	// MarkMemberRef


//*****************************************************************************
// cascading Mark of a UserString
//*****************************************************************************
HRESULT FilterManager::MarkUserString(mdString str)
{
	HRESULT			hr = NOERROR;

    IHostFilter		*pFilter = m_pMiniMd->GetHostFilter();

	// if UserString is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsUserStringMarked(str))
		goto ErrExit;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkUserString( str ) );

ErrExit:
	return hr;
}	// MarkMemberRef


//*****************************************************************************
// cascading Mark of a ModuleRef
//*****************************************************************************
HRESULT FilterManager::MarkModuleRef(mdModuleRef mr)
{
	HRESULT		hr = NOERROR;

	// if ModuleREf is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsModuleRefMarked(mr))
		goto ErrExit;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkModuleRef( mr ) );
	IfFailGo( MarkCustomAttributesWithParentToken(mr) );

ErrExit:
	return hr;
}	// MarkModuleRef


//*****************************************************************************
// cascading Mark of a AssemblyRef
//*****************************************************************************
HRESULT FilterManager::MarkAssemblyRef(mdAssemblyRef ar)
{
	HRESULT		hr = NOERROR;

	// if ModuleREf is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsAssemblyRefMarked(ar))
		goto ErrExit;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkAssemblyRef( ar ) );
	IfFailGo( MarkCustomAttributesWithParentToken(ar) );

ErrExit:
	return hr;
}	// MarkModuleRef


//*****************************************************************************
// cascading Mark of all of the custom values associated with a token
//*****************************************************************************
HRESULT FilterManager::MarkCustomAttributesWithParentToken(mdToken tkParent)
{
	HRESULT		hr = NOERROR;
	RID			ridStart, ridEnd;
	RID			index;
	CustomAttributeRec *pRec;

	if ( m_pMiniMd->IsSorted( TBL_CustomAttribute ) )
	{
		// table is sorted. ridStart to ridEnd - 1 are all CustomAttribute
		// associated with tkParent
		//
		ridStart = m_pMiniMd->getCustomAttributeForToken(tkParent, &ridEnd);
		for (index = ridStart; index < ridEnd; index ++ )
		{
			IfFailGo( MarkCustomAttribute( TokenFromRid(index, mdtCustomAttribute) ) );
		}
	}
	else
	{
		// table scan is needed
		ridStart = 1;
		ridEnd = m_pMiniMd->getCountCustomAttributes() + 1;
		for (index = ridStart; index < ridEnd; index ++ )
		{
			pRec = m_pMiniMd->getCustomAttribute(index);
			if ( tkParent == m_pMiniMd->getParentOfCustomAttribute(pRec) )
			{
				// This CustomAttribute is associated with tkParent
				IfFailGo( MarkCustomAttribute( TokenFromRid(index, mdtCustomAttribute) ) );
			}
		}
	}

ErrExit:
	return hr;
}	// MarkCustomAttributeWithParentToken


//*****************************************************************************
// cascading Mark of all securities associated with a token
//*****************************************************************************
HRESULT FilterManager::MarkDeclSecuritiesWithParentToken(mdToken tkParent)
{
	HRESULT		hr = NOERROR;
	RID			ridStart, ridEnd;
	RID			index;
	DeclSecurityRec *pRec;

	if ( m_pMiniMd->IsSorted( TBL_DeclSecurity ) )
	{
		// table is sorted. ridStart to ridEnd - 1 are all DeclSecurity
		// associated with tkParent
		//
		ridStart = m_pMiniMd->getDeclSecurityForToken(tkParent, &ridEnd);
		for (index = ridStart; index < ridEnd; index ++ )
		{
			IfFailGo( m_pMiniMd->GetFilterTable()->MarkDeclSecurity( TokenFromRid(index, mdtPermission) ) );
		}
	}
	else
	{
		// table scan is needed
		ridStart = 1;
		ridEnd = m_pMiniMd->getCountDeclSecuritys() + 1;
		for (index = ridStart; index < ridEnd; index ++ )
		{
			pRec = m_pMiniMd->getDeclSecurity(index);
			if ( tkParent == m_pMiniMd->getParentOfDeclSecurity(pRec) )
			{
				// This DeclSecurity is associated with tkParent
				IfFailGo( m_pMiniMd->GetFilterTable()->MarkDeclSecurity( TokenFromRid(index, mdtPermission) ) );
			}
		}
	}

ErrExit:
	return hr;
}	// eclSecurityWithWithParentToken


//*****************************************************************************
// cascading Mark of all MemberRefs associated with a parent token
//*****************************************************************************
HRESULT FilterManager::MarkMemberRefsWithParentToken(mdToken tk)
{
	HRESULT		hr = NOERROR;
	RID			ulEnd;
	RID			index;
	mdToken		tkParent;
	MemberRefRec *pRec;

	ulEnd = m_pMiniMd->getCountMemberRefs();

	for (index = 1; index <= ulEnd; index ++ )
	{
		// memberRef table is not sorted. Table scan is needed.
		pRec = m_pMiniMd->getMemberRef(index);
		tkParent = m_pMiniMd->getClassOfMemberRef(pRec);
		if ( tk == tkParent )
		{
			IfFailGo( MarkMemberRef( TokenFromRid(index, mdtMemberRef) ) );
		}
	}
ErrExit:
	return hr;
}	// MarkMemberRefsWithParentToken


//*****************************************************************************
// cascading Mark of a ParamDef token
//*****************************************************************************
HRESULT FilterManager::MarkParam(mdParamDef pd)
{
	HRESULT		hr;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkParam( pd ) );

	IfFailGo( MarkCustomAttributesWithParentToken(pd) );
	// Parameter does not have declsecurity
	// IfFailGo( MarkDeclSecuritiesWithParentToken(pd) );

ErrExit:
	return hr;
}	// MarkParam


//*****************************************************************************
// cascading Mark of a method token
//*****************************************************************************
HRESULT FilterManager::MarkMethod(mdMethodDef md)
{
	HRESULT			hr = NOERROR;
	MethodRec		*pRec;
	ULONG			cbSize;
	ULONG			i, iCount;
	ImplMapRec		*pImplMapRec = NULL;
	mdMethodDef		mdImp;
	mdModuleRef		mrImp;
	IHostFilter		*pFilter = m_pMiniMd->GetHostFilter();

	// if MethodDef is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsMethodMarked(md))
		goto ErrExit;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkMethod( md ) );
	if (pFilter)
		pFilter->MarkToken(md);

	IfFailGo( MarkParamsWithParentToken(md) );

	// Walk the signature and mark all of the embedded types
	pRec = m_pMiniMd->getMethod(RidFromToken(md));
	IfFailGo( MarkSignature(m_pMiniMd->getSignatureOfMethod(pRec, &cbSize), NULL) );

    iCount = m_pMiniMd->getCountImplMaps();

	// loop through all ImplMaps and find the Impl map associated with this method def tokens
	// and mark the Module Ref tokens in the entries
	//
	for (i = 1; i <= iCount; i++)
	{
		pImplMapRec = m_pMiniMd->getImplMap(i);

		// Get the MethodDef that the impl map is associated with
		mdImp = m_pMiniMd->getMemberForwardedOfImplMap(pImplMapRec);

		if (mdImp != md)
		{
			// Impl Map entry does not associated with the method def that we are marking
			continue;
		}

		// Get the ModuleRef token 
		mrImp = m_pMiniMd->getImportScopeOfImplMap(pImplMapRec);
		IfFailGo( Mark(mrImp) );
	}

	// We should not mark all of the memberref with the parent of this methoddef token.
	// Because not all of the call sites are needed.
	//
	// IfFailGo( MarkMemberRefsWithParentToken(md) );
	IfFailGo( MarkCustomAttributesWithParentToken(md) );
	IfFailGo( MarkDeclSecuritiesWithParentToken(md) );
ErrExit:
	return hr;
}	// MarkMethod


//*****************************************************************************
// cascading Mark of a field token
//*****************************************************************************
HRESULT FilterManager::MarkField(mdFieldDef fd)
{
	HRESULT			hr = NOERROR;
	FieldRec		*pRec;
	ULONG			cbSize;
	IHostFilter		*pFilter = m_pMiniMd->GetHostFilter();

	// if FieldDef is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsFieldMarked(fd))
		goto ErrExit;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkField( fd ) );
	if (pFilter)
		pFilter->MarkToken(fd);

	// We should not mark all of the MemberRef with the parent of this FieldDef token.
	// Because not all of the call sites are needed.
	//

	// Walk the signature and mark all of the embedded types
	pRec = m_pMiniMd->getField(RidFromToken(fd));
	IfFailGo( MarkSignature(m_pMiniMd->getSignatureOfField(pRec, &cbSize), NULL) );

	IfFailGo( MarkCustomAttributesWithParentToken(fd) );
	// IfFailGo( MarkDeclSecuritiesWithParentToken(fd) );

ErrExit:
	return hr;
}	// MarkField


//*****************************************************************************
// cascading Mark of an event token
//*****************************************************************************
HRESULT FilterManager::MarkEvent(mdEvent ev)
{
	HRESULT		hr = NOERROR;
	EventRec	*pRec;

	// if Event is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsEventMarked(ev))
		goto ErrExit;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkEvent( ev ) );

	// mark the event type as well
	pRec = m_pMiniMd->getEvent( RidFromToken(ev) );
	IfFailGo( Mark(m_pMiniMd->getEventTypeOfEvent(pRec)) );

	// Note that we don't need to mark the MethodSemantics. Because the association of MethodSemantics
	// is marked. The Method column can only store MethodDef, ie the MethodDef has the same parent as 
	// this Event.

	IfFailGo( MarkCustomAttributesWithParentToken(ev) );
	// IfFailGo( MarkDeclSecuritiesWithParentToken(ev) );

ErrExit:
	return hr;
}	// MarkEvent



//*****************************************************************************
// cascading Mark of a Property token
//*****************************************************************************
HRESULT FilterManager::MarkProperty(mdProperty pr)
{
	HRESULT		hr = NOERROR;
	PropertyRec *pRec;
	ULONG		cbSize;

	// if Property is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsPropertyMarked(pr))
		goto ErrExit;

	IfFailGo( m_pMiniMd->GetFilterTable()->MarkProperty( pr ) );

	// marking the backing field, event changing and event changed
	pRec = m_pMiniMd->getProperty( RidFromToken(pr) );

	// Walk the signature and mark all of the embedded types
	IfFailGo( MarkSignature(m_pMiniMd->getTypeOfProperty(pRec, &cbSize), NULL) );

	// Note that we don't need to mark the MethodSemantics. Because the association of MethodSemantics
	// is marked. The Method column can only store MethodDef, ie the MethodDef has the same parent as 
	// this Property.

	IfFailGo( MarkCustomAttributesWithParentToken(pr) );
	// IfFailGo( MarkDeclSecuritiesWithParentToken(pr) );

ErrExit:
	return hr;
}	// MarkProperty

//*****************************************************************************
// cascading Mark of all ParamDef associated with a methoddef
//*****************************************************************************
HRESULT FilterManager::MarkParamsWithParentToken(mdMethodDef md)
{
	HRESULT		hr = NOERROR;
	RID			ulStart, ulEnd;
	RID			index;
	MethodRec	*pMethodRec;

	pMethodRec = m_pMiniMd->getMethod(RidFromToken(md));

	// figure out the start rid and end rid of the parameter list of this methoddef
	ulStart = m_pMiniMd->getParamListOfMethod(pMethodRec);
	ulEnd = m_pMiniMd->getEndParamListOfMethod(pMethodRec);
	for (index = ulStart; index < ulEnd; index ++ )
	{
		IfFailGo( MarkParam( TokenFromRid( m_pMiniMd->GetParamRid(index), mdtParamDef) ) );
	}
ErrExit:
	return hr;
}	// MarkParamsWithParentToken


//*****************************************************************************
// cascading Mark of all methods associated with a TypeDef token
//*****************************************************************************
HRESULT FilterManager::MarkMethodsWithParentToken(mdTypeDef td)
{
	HRESULT		hr = NOERROR;
	RID			ulStart, ulEnd;
	RID			index;
	TypeDefRec	*pTypeDefRec;

	pTypeDefRec = m_pMiniMd->getTypeDef(RidFromToken(td));
	ulStart = m_pMiniMd->getMethodListOfTypeDef( pTypeDefRec );
	ulEnd = m_pMiniMd->getEndMethodListOfTypeDef( pTypeDefRec );
	for ( index = ulStart; index < ulEnd; index ++ )
	{
		IfFailGo( MarkMethod( TokenFromRid( m_pMiniMd->GetMethodRid(index), mdtMethodDef) ) );
	}
ErrExit:
	return hr;
}	// MarkMethodsWithParentToken


//*****************************************************************************
// cascading Mark of all MethodImpls associated with a TypeDef token
//*****************************************************************************
HRESULT FilterManager::MarkMethodImplsWithParentToken(mdTypeDef td)
{
	HRESULT		hr = NOERROR;
	RID			index;
    mdToken     tkBody;
    mdToken     tkDecl;
    MethodImplRec *pMethodImplRec;
    HENUMInternal hEnum;
    
    memset(&hEnum, 0, sizeof(HENUMInternal));
    IfFailGo( m_pMiniMd->FindMethodImplHelper(td, &hEnum) );

    while (HENUMInternal::EnumNext(&hEnum, (mdToken *)&index))
	{
        pMethodImplRec = m_pMiniMd->getMethodImpl(index);
        IfFailGo(m_pMiniMd->GetFilterTable()->MarkMethodImpl(index));

        tkBody = m_pMiniMd->getMethodBodyOfMethodImpl(pMethodImplRec);
        IfFailGo( Mark(tkBody) );

        tkDecl = m_pMiniMd->getMethodDeclarationOfMethodImpl(pMethodImplRec);
        IfFailGo( Mark(tkDecl) );
	}
ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
	return hr;
}	// MarkMethodImplsWithParentToken


//*****************************************************************************
// cascading Mark of all fields associated with a TypeDef token
//*****************************************************************************
HRESULT FilterManager::MarkFieldsWithParentToken(mdTypeDef td)
{
	HRESULT		hr = NOERROR;
	RID			ulStart, ulEnd;
	RID			index;
	TypeDefRec	*pTypeDefRec;

	pTypeDefRec = m_pMiniMd->getTypeDef(RidFromToken(td));
	ulStart = m_pMiniMd->getFieldListOfTypeDef( pTypeDefRec );
	ulEnd = m_pMiniMd->getEndFieldListOfTypeDef( pTypeDefRec );
	for ( index = ulStart; index < ulEnd; index ++ )
	{
		IfFailGo( MarkField( TokenFromRid( m_pMiniMd->GetFieldRid(index), mdtFieldDef ) ) );
	}
ErrExit:
	return hr;
}	// MarkFieldWithParentToken


//*****************************************************************************
// cascading Mark of  all events associated with a TypeDef token
//*****************************************************************************
HRESULT FilterManager::MarkEventsWithParentToken(
	mdTypeDef	td)
{
	HRESULT		hr = NOERROR;
	RID			ridEventMap;
	RID			ulStart, ulEnd;
	RID			index;
	EventMapRec *pEventMapRec;

	// get the starting/ending rid of Events of this typedef
	ridEventMap = m_pMiniMd->FindEventMapFor( RidFromToken(td) );
	if ( !InvalidRid(ridEventMap) )
	{
		pEventMapRec = m_pMiniMd->getEventMap( ridEventMap );
		ulStart = m_pMiniMd->getEventListOfEventMap( pEventMapRec );
		ulEnd = m_pMiniMd->getEndEventListOfEventMap( pEventMapRec );
		for ( index = ulStart; index < ulEnd; index ++ )
		{
			IfFailGo( MarkEvent( TokenFromRid( m_pMiniMd->GetEventRid(index), mdtEvent ) ) );
		}
	}
ErrExit:
	return hr;
}	// MarkEventWithParentToken



//*****************************************************************************
// cascading Mark of all properties associated with a TypeDef token
//*****************************************************************************
HRESULT FilterManager::MarkPropertiesWithParentToken(
	mdTypeDef	td)
{
	HRESULT		hr = NOERROR;
	RID			ridPropertyMap;
	RID			ulStart, ulEnd;
	RID			index;
	PropertyMapRec *pPropertyMapRec;

	// get the starting/ending rid of properties of this typedef
	ridPropertyMap = m_pMiniMd->FindPropertyMapFor( RidFromToken(td) );
	if ( !InvalidRid(ridPropertyMap) )
	{
		pPropertyMapRec = m_pMiniMd->getPropertyMap( ridPropertyMap );
		ulStart = m_pMiniMd->getPropertyListOfPropertyMap( pPropertyMapRec );
		ulEnd = m_pMiniMd->getEndPropertyListOfPropertyMap( pPropertyMapRec );
		for ( index = ulStart; index < ulEnd; index ++ )
		{
			IfFailGo( MarkProperty( TokenFromRid( m_pMiniMd->GetPropertyRid(index), mdtProperty ) ) );
		}
	}
ErrExit:
	return hr;
}	// MarkPropertyWithParentToken


//*****************************************************************************
// cascading Mark of an TypeDef token
//*****************************************************************************
HRESULT FilterManager::MarkInterfaceImpls(
	mdTypeDef	td)
{
	HRESULT			hr = NOERROR;
	ULONG			ridStart, ridEnd;
	ULONG			i;
	InterfaceImplRec *pRec;
	if ( m_pMiniMd->IsSorted(TBL_InterfaceImpl) )
	{
		ridStart = m_pMiniMd->getInterfaceImplsForTypeDef(RidFromToken(td), &ridEnd);
	}
	else
	{
		ridStart = 1;
		ridEnd = m_pMiniMd->getCountInterfaceImpls() + 1;
	}

	// Search for the interfaceimpl with the parent of td
	for (i = ridStart; i < ridEnd; i++)
	{
		pRec = m_pMiniMd->getInterfaceImpl(i);
		if ( td != m_pMiniMd->getClassOfInterfaceImpl(pRec) )
			continue;

		// found an InterfaceImpl associate with td. Mark the interface row and the interfaceimpl type
		IfFailGo( m_pMiniMd->GetFilterTable()->MarkInterfaceImpl(TokenFromRid(i, mdtInterfaceImpl)) );
	    IfFailGo( MarkCustomAttributesWithParentToken(TokenFromRid(i, mdtInterfaceImpl)) );
		// IfFailGo( MarkDeclSecuritiesWithParentToken(TokenFromRid(i, mdtInterfaceImpl)) );
		IfFailGo( Mark(m_pMiniMd->getInterfaceOfInterfaceImpl(pRec)) );
	}
ErrExit:
	return hr;
}

//*****************************************************************************
// cascading Mark of an TypeDef token
//*****************************************************************************
HRESULT FilterManager::MarkTypeDef(
	mdTypeDef	td)
{
	HRESULT			hr = NOERROR;
	TypeDefRec		*pRec;
	IHostFilter		*pFilter = m_pMiniMd->GetHostFilter();
    DWORD           dwFlags;
    RID             iNester;

	// if TypeDef is already marked, just return
	if (m_pMiniMd->GetFilterTable()->IsTypeDefMarked(td))
		goto ErrExit;

	// Mark the TypeDef first to avoid duplicate marking
	IfFailGo( m_pMiniMd->GetFilterTable()->MarkTypeDef(td) );
	if (pFilter)
		pFilter->MarkToken(td);

	// We don't need to mark InterfaceImpl but we need to mark the
	// TypeDef/TypeRef associated with InterfaceImpl.
	IfFailGo( MarkInterfaceImpls(td) );

	// mark the base class
	pRec = m_pMiniMd->getTypeDef(RidFromToken(td));
	IfFailGo( Mark(m_pMiniMd->getExtendsOfTypeDef(pRec)) );

	// mark all of the children of this TypeDef
	IfFailGo( MarkMethodsWithParentToken(td) );
    IfFailGo( MarkMethodImplsWithParentToken(td) );
	IfFailGo( MarkFieldsWithParentToken(td) );
	IfFailGo( MarkEventsWithParentToken(td) );
	IfFailGo( MarkPropertiesWithParentToken(td) );

	// mark custom value and permission
	IfFailGo( MarkCustomAttributesWithParentToken(td) );
	IfFailGo( MarkDeclSecuritiesWithParentToken(td) );

    // If the class is a Nested class mark the parent, recursively.
    dwFlags = m_pMiniMd->getFlagsOfTypeDef(pRec);
    if (IsTdNested(dwFlags))
    {
        NestedClassRec      *pRec;
        iNester = m_pMiniMd->FindNestedClassHelper(td);
        if (InvalidRid(iNester))
            IfFailGo(CLDB_E_RECORD_NOTFOUND);
        pRec = m_pMiniMd->getNestedClass(iNester);
        IfFailGo(MarkTypeDef(m_pMiniMd->getEnclosingClassOfNestedClass(pRec)));
    }

ErrExit:
	return hr;
}	// MarkTypeDef


//*****************************************************************************
// walk signature and mark tokens embedded in the signature
//*****************************************************************************
HRESULT FilterManager::MarkSignature(
	PCCOR_SIGNATURE pbSigCur,			// [IN] point to the current byte to visit in the signature
	PCCOR_SIGNATURE *ppbSigPost)		// [OUT] point to the first byte of the signature has not been process
{
    HRESULT     hr = NOERROR;           // A result.
    ULONG       cArg = 0;               // count of arguments in the signature
    ULONG       callingconv;
	PCCOR_SIGNATURE pbSigPost;

    // calling convention
    callingconv = CorSigUncompressData(pbSigCur);
	_ASSERTE((callingconv & IMAGE_CEE_CS_CALLCONV_MASK) < IMAGE_CEE_CS_CALLCONV_MAX);

    if (isCallConv(callingconv, IMAGE_CEE_CS_CALLCONV_FIELD))
    {
        // It is a FieldDef
        IfFailGo(MarkFieldSignature(
			pbSigCur,
			&pbSigPost) );
		pbSigCur = pbSigPost;
    }
    else
    {

        // It is a MethodRef

        // count of argument
        cArg = CorSigUncompressData(pbSigCur);
		if ( !isCallConv(callingconv, IMAGE_CEE_CS_CALLCONV_LOCAL_SIG) )
		{
			// LocalVar sig does not have return type
			// process the return type
			IfFailGo(MarkFieldSignature(
				pbSigCur,
				&pbSigPost) );
			pbSigCur = pbSigPost;
		}


        while (cArg)
        {
            // process every argument
			IfFailGo(MarkFieldSignature(
				pbSigCur,
				&pbSigPost) );
			pbSigCur = pbSigPost;
            cArg--;
        }
    }
	if (ppbSigPost)
		*ppbSigPost = pbSigCur;

ErrExit:
	return hr;
}	// MarkSignature


//*****************************************************************************
// walk one type and mark tokens embedded in the signature
//*****************************************************************************
HRESULT FilterManager::MarkFieldSignature(
	PCCOR_SIGNATURE pbSigCur,			// [IN] point to the current byte to visit in the signature
	PCCOR_SIGNATURE *ppbSigPost)		// [OUT] point to the first byte of the signature has not been process
{
	HRESULT		hr = NOERROR;			// A result.
	ULONG		ulElementType;			// place holder for expanded data
	ULONG		ulData;
	ULONG		ulTemp;
	mdToken		tkRidFrom;				// Original rid
	int			iData;
	PCCOR_SIGNATURE pbSigPost;
	ULONG		cbSize;

    ulElementType = CorSigUncompressElementType(pbSigCur);

    // count numbers of modifiers
    while (CorIsModifierElementType((CorElementType) ulElementType))
    {
        ulElementType = CorSigUncompressElementType(pbSigCur);
    }

    switch (ulElementType)
    {
		case ELEMENT_TYPE_VALUEARRAY:
            // syntax for SDARRAY = BaseType <an integer for size>

            // visit the base type
            IfFailGo( MarkFieldSignature(   
				pbSigCur,
				&pbSigPost) );
			pbSigCur = pbSigPost;

            // after the base type, it is followed by an unsigned integer indicating the size 
            // of the array
            //
            ulData = CorSigUncompressData(pbSigCur);
            break;

        case ELEMENT_TYPE_SZARRAY:
            // syntax : SZARRAY <BaseType>

            // conver the base type for the SZARRAY or GENERICARRAY
            IfFailGo(MarkFieldSignature(   
				pbSigCur,
				&pbSigPost) );
			pbSigCur = pbSigPost;
            break;

        case ELEMENT_TYPE_CMOD_REQD:
        case ELEMENT_TYPE_CMOD_OPT:
            // syntax : CMOD_REQD <token> <BaseType>

            // now get the embedded token
            tkRidFrom = CorSigUncompressToken(pbSigCur);

			// Mark the token
			IfFailGo( Mark(tkRidFrom) );

            // mark the base type
            IfFailGo(MarkFieldSignature(   
				pbSigCur,
				&pbSigPost) );
			pbSigCur = pbSigPost;
            break;

        case ELEMENT_TYPE_ARRAY:
            // syntax : ARRAY BaseType <rank> [i size_1... size_i] [j lowerbound_1 ... lowerbound_j]

            // conver the base type for the MDARRAY
            // conver the base type for the SZARRAY or GENERICARRAY
            IfFailGo(MarkFieldSignature(   
				pbSigCur,
				&pbSigPost) );
			pbSigCur = pbSigPost;

            // Parse for the rank
            ulData = CorSigUncompressData(pbSigCur);

            // if rank == 0, we are done
            if (ulData == 0)
                break;

            // any size of dimension specified?
            ulData = CorSigUncompressData(pbSigCur);

            while (ulData--)
            {
                ulTemp = CorSigUncompressData(pbSigCur);
            }

            // any lower bound specified?
            ulData = CorSigUncompressData(pbSigCur);

            while (ulData--)
            {
                cbSize = CorSigUncompressSignedInt(pbSigCur, &iData);
				pbSigCur += cbSize;
            }

            break;
		case ELEMENT_TYPE_FNPTR:
			// function pointer is followed by another complete signature
            IfFailGo(MarkSignature(   
				pbSigCur,
				&pbSigPost) );
			pbSigCur = pbSigPost;
			break;
        case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_CLASS:

            // syntax for CLASS = ELEMENT_TYPE_CLASS <rid>
            // syntax for VALUE_CLASS = ELEMENT_TYPE_VALUECLASS <rid>

            // now get the embedded token
            tkRidFrom = CorSigUncompressToken(pbSigCur);

			// Mark the token
			IfFailGo( Mark(tkRidFrom) );
            break;
        default:
            _ASSERTE(ulElementType < ELEMENT_TYPE_MAX);
            _ASSERTE(ulElementType != ELEMENT_TYPE_PTR && ulElementType != ELEMENT_TYPE_BYREF);

            if (ulElementType >= ELEMENT_TYPE_MAX)
                IfFailGo(META_E_BAD_SIGNATURE);

            break;
    }

	if (ppbSigPost)
		*ppbSigPost = pbSigCur;
ErrExit:
    return hr;
}	// MarkFieldSignature



//*****************************************************************************
//
// Unmark the TypeDef
//
//*****************************************************************************
HRESULT FilterManager::UnmarkTypeDef(
    mdTypeDef       td)
{
	HRESULT			hr = NOERROR;
	TypeDefRec		*pTypeDefRec;
	RID			    ridStart, ridEnd;
	RID			    index;
	CustomAttributeRec  *pCARec;

	// if TypeDef is already unmarked, just return
	if (m_pMiniMd->GetFilterTable()->IsTypeDefMarked(td) == false)
		goto ErrExit;

	// Mark the TypeDef first to avoid duplicate marking
	IfFailGo( m_pMiniMd->GetFilterTable()->UnmarkTypeDef(td) );

    // Don't need to unmark InterfaceImpl because the TypeDef is unmarked that will make
    // the InterfaceImpl automatically unmarked.

	// unmark all of the children of this TypeDef
	pTypeDefRec = m_pMiniMd->getTypeDef(RidFromToken(td));

    // unmark the methods
	ridStart = m_pMiniMd->getMethodListOfTypeDef( pTypeDefRec );
	ridEnd = m_pMiniMd->getEndMethodListOfTypeDef( pTypeDefRec );
	for ( index = ridStart; index < ridEnd; index ++ )
	{
		IfFailGo( m_pMiniMd->GetFilterTable()->UnmarkMethod( TokenFromRid( m_pMiniMd->GetMethodRid(index), mdtMethodDef) ) );
	}

    // unmark the fields
	ridStart = m_pMiniMd->getFieldListOfTypeDef( pTypeDefRec );
	ridEnd = m_pMiniMd->getEndFieldListOfTypeDef( pTypeDefRec );
	for ( index = ridStart; index < ridEnd; index ++ )
	{
		IfFailGo( m_pMiniMd->GetFilterTable()->UnmarkField( TokenFromRid( m_pMiniMd->GetFieldRid(index), mdtFieldDef) ) );
	}

	// unmark custom value
	if ( m_pMiniMd->IsSorted( TBL_CustomAttribute ) )
	{
		// table is sorted. ridStart to ridEnd - 1 are all CustomAttribute
		// associated with tkParent
		//
		ridStart = m_pMiniMd->getCustomAttributeForToken(td, &ridEnd);
		for (index = ridStart; index < ridEnd; index ++ )
		{
			IfFailGo( m_pMiniMd->GetFilterTable()->UnmarkCustomAttribute( TokenFromRid(index, mdtCustomAttribute) ) );
		}
	}
	else
	{
		// table scan is needed
		ridStart = 1;
		ridEnd = m_pMiniMd->getCountCustomAttributes() + 1;
		for (index = ridStart; index < ridEnd; index ++ )
		{
			pCARec = m_pMiniMd->getCustomAttribute(index);
			if ( td == m_pMiniMd->getParentOfCustomAttribute(pCARec) )
			{
				// This CustomAttribute is associated with tkParent
				IfFailGo( m_pMiniMd->GetFilterTable()->UnmarkCustomAttribute( TokenFromRid(index, mdtCustomAttribute) ) );
			}
		}
	}

    // We don't support nested type!!

ErrExit:
	return hr;

}   // UnmarkTypeDef
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\helper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Helper.cpp
//
// Implementation for the meta data emit code.
//
//*****************************************************************************
#include "stdafx.h"
#include "RegMeta.h"
#include "ImportHelper.h"
#include <sighelper.h>
#include "MDLog.h"

//*****************************************************************************
// translating signature from one scope to another scope
//*****************************************************************************
STDAPI RegMeta::TranslateSigWithScope(	// S_OK or error.
    IMetaDataAssemblyImport *pAssemImport, // [IN] importing assembly interface
    const void  *pbHashValue,	        // [IN] Hash Blob for Assembly.
    ULONG 		cbHashValue,	        // [IN] Count of bytes.
	IMetaDataImport *pImport,			// [IN] importing interface
	PCCOR_SIGNATURE pbSigBlob,			// [IN] signature in the importing scope
	ULONG		cbSigBlob,				// [IN] count of bytes of signature
    IMetaDataAssemblyEmit   *pAssemEmit,// [IN] emit assembly interface
	IMetaDataEmit *pEmit,				// [IN] emit interface
	PCOR_SIGNATURE pvTranslatedSig,		// [OUT] buffer to hold translated signature
	ULONG		cbTranslatedSigMax,
	ULONG		*pcbTranslatedSig)		// [OUT] count of bytes in the translated signature
{
	HRESULT		hr = S_OK;
    RegMeta     *pRegMetaAssemEmit = static_cast<RegMeta*>(pAssemEmit);
	RegMeta     *pRegMetaEmit = static_cast<RegMeta*>(pEmit);
    RegMeta     *pRegMetaAssemImport = static_cast<RegMeta*>(pAssemImport);
    IMetaModelCommon *pCommonAssemImport;
	RegMeta     *pRegMetaImport = static_cast<RegMeta*>(pImport);
    IMetaModelCommon *pCommonImport = static_cast<IMetaModelCommon*>(&(pRegMetaImport->m_pStgdb->m_MiniMd));
	CQuickBytes qkSigEmit;
	ULONG       cbEmit;

    // This function can cause new TypeRef being introduced.
    LOCKWRITE();

	_ASSERTE(pvTranslatedSig && pcbTranslatedSig);

    pCommonAssemImport = pRegMetaAssemImport ?  
        static_cast<IMetaModelCommon*>(&(pRegMetaAssemImport->m_pStgdb->m_MiniMd)) : 0;

	IfFailGo( ImportHelper::MergeUpdateTokenInSig(  // S_OK or error.
            pRegMetaAssemEmit ? &(pRegMetaAssemEmit->m_pStgdb->m_MiniMd) : 0, // The assembly emit scope.
			&(pRegMetaEmit->m_pStgdb->m_MiniMd),	// The emit scope.
            pCommonAssemImport,                     // Assembly where the signature is from.
            pbHashValue,                            // Hash value for the import assembly.
            cbHashValue,                            // Size in bytes.
			pCommonImport,                          // The scope where signature is from.
			pbSigBlob,								// signature from the imported scope
			NULL,									// Internal OID mapping structure.
			&qkSigEmit,								// [OUT] translated signature
			0,										// start from first byte of the signature
			0,										// don't care how many bytes consumed
			&cbEmit));								// [OUT] total number of bytes write to pqkSigEmit
	memcpy(pvTranslatedSig, qkSigEmit.Ptr(), cbEmit > cbTranslatedSigMax ? cbTranslatedSigMax :cbEmit );
	*pcbTranslatedSig = cbEmit;
	if (cbEmit > cbTranslatedSigMax)
		hr = CLDB_S_TRUNCATION;
ErrExit:

	return hr;
} // STDAPI RegMeta::TranslateSigWithScope()

//*****************************************************************************
// convert a text signature to com format
//*****************************************************************************
STDAPI RegMeta::ConvertTextSigToComSig(	// Return hresult.
	IMetaDataEmit *emit,				// [IN] emit interface
	BOOL		fCreateTrIfNotFound,	// [IN] create typeref if not found
	LPCSTR		pSignature,				// [IN] class file format signature
	CQuickBytes *pqbNewSig,				// [OUT] place holder for COM+ signature
	ULONG		*pcbCount)				// [OUT] the result size of signature
{
	HRESULT		hr = S_OK;
	BYTE		*prgData = (BYTE *)pqbNewSig->Ptr();
	CQuickBytes qbNewSigForOneArg;		// temporary buffer to hold one arg or ret type in new signature format
	ULONG		cbTotal = 0;			// total number of bytes for the whole signature
	ULONG		cbOneArg;				// count of bytes for one arg/ret type
	ULONG		cb; 					// count of bytes
	DWORD		cArgs;
	LPCUTF8 	szRet;

    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

	_ASSERTE(pSignature && pqbNewSig && pcbCount);

	if (*pSignature == '(')
	{
		// get the argument count from the signature
		cArgs = CountArgsInTextSignature(pSignature);

		// put calling convention
		// @FUTURE: Obvious right now we only have text sig for default calling convention. We will need to extend
		// this function if this is changed in the future.
		//
		cbTotal = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_DEFAULT, &prgData[cbTotal]);

		// put the count of arguments
		cb = CorSigCompressData((ULONG)cArgs, &prgData[cbTotal]);
		cbTotal += cb;

		// get the return type
		szRet = strrchr(pSignature, ')');
		if (szRet == NULL)
		{
			_ASSERTE(!"Not a valid TEXT member signature!");
			IfFailGo( E_FAIL );
		}

		// skip over ')'
		szRet++;

		IfFailGo(_ConvertTextElementTypeToComSig(
			emit,
			fCreateTrIfNotFound,
			&szRet, 						// point to where return type starts	
			pqbNewSig,						// quick byte buffer for the return type
			cbTotal,
			&cbOneArg));					// count of bytes that write to quick bytes buffer

		cbTotal += cbOneArg;

		// skip over "("
		pSignature++;
		while (cArgs)
		{
			IfFailGo(_ConvertTextElementTypeToComSig(
				emit,
				fCreateTrIfNotFound,
				&pSignature,				// point to where an parameter starts	
				pqbNewSig,					// quick byte buffer for the return type
				cbTotal,
				&cbOneArg));				// count of bytes that write to quick bytes buffer

			cbTotal += cbOneArg;
			cArgs--;
		}
		*pcbCount = cbTotal;
	}
	else
	{
		// field
		IfFailGo(pqbNewSig->ReSize(CB_ELEMENT_TYPE_MAX));

		// put the calling convention first of all 
		cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_FIELD, pqbNewSig->Ptr());

		// now convert the Text signature
		IfFailGo(_ConvertTextElementTypeToComSig(
			emit,
			fCreateTrIfNotFound,
			&pSignature,
			pqbNewSig,
			cb,
			&cbOneArg));
		*pcbCount = cb + cbOneArg;
	}
ErrExit:
    
	return hr;
}

//*****************************************************************************
// Helper : convert a text field signature to a com format
//*****************************************************************************
HRESULT RegMeta::_ConvertTextElementTypeToComSig(// Return hresult.
	IMetaDataEmit *emit,				// [IN] emit interface.
	BOOL		fCreateTrIfNotFound,	// [IN] create typeref if not found or fail out?
	LPCSTR	 	*ppOneArgSig,			// [IN|OUT] class file format signature. On exit, it will be next arg starting point
	CQuickBytes *pqbNewSig, 			// [OUT] place holder for COM+ signature
	ULONG		cbStart,				// [IN] bytes that are already in pqbNewSig
	ULONG		*pcbCount)				// [OUT] count of bytes put into the QuickBytes buffer
{	
	_ASSERTE(ppOneArgSig && pqbNewSig && pcbCount);

	HRESULT     hr = NOERROR;
	BYTE		*prgData = (BYTE *)pqbNewSig->Ptr();
	ULONG		cDim, cDimTmp;			// number of '[' in signature
	CorSimpleETypeStruct eType; 
	LPCUTF8 	pOneArgSig = *ppOneArgSig;
	CQuickBytes qbFullName;
    CQuickBytes qbNameSpace;
    CQuickBytes qbName;
	ULONG		cb, cbTotal = 0, cbBaseElement;
	RegMeta		*pMeta = reinterpret_cast<RegMeta*>(emit);

	// given "[[LSystem.Object;I)V"
	if (ResolveTextSigToSimpleEType(&pOneArgSig, &eType, &cDim, true) == false)
	{
		_ASSERTE(!"not a valid signature!");
		return META_E_BAD_SIGNATURE;
	}

        // If we have a reference to an array (e.g. "&[B"), we need to process
        // the reference now, otherwise the code below will generate the array
        // sig bytes before dealing with the underlying element type and will
        // end up generating a signature equivalent to "[&B" (which is not
        // legal).
        if (cDim && (eType.dwFlags & CorSigElementTypeByRef))
        {
            cb = CorSigCompressElementType(ELEMENT_TYPE_BYREF, &prgData[cbStart + cbTotal]);
            cbTotal += cb;
            eType.dwFlags &= ~CorSigElementTypeByRef;
        }

	// pOneArgSig now points to "System.Object;I)V"
	// resolve the rid if exists
	if (eType.corEType == ELEMENT_TYPE_VALUETYPE || eType.corEType == ELEMENT_TYPE_CLASS)
	{
		if (ExtractClassNameFromTextSig(&pOneArgSig, &qbFullName, &cb) == FALSE)
		{	
			_ASSERTE(!"corrupted text signature!");
			return E_FAIL;
		}
        IfFailGo(qbNameSpace.ReSize(qbFullName.Size()));
        IfFailGo(qbName.ReSize(qbFullName.Size()));
        SIZE_T bSuccess = ns::SplitPath((LPCSTR)qbFullName.Ptr(),
                                     (LPSTR)qbNameSpace.Ptr(), (int)qbNameSpace.Size(),
                                     (LPSTR)qbName.Ptr(),      (int)qbName.Size());
        _ASSERTE(bSuccess);

		// now pOneArgSig will pointing to the starting of next parameter "I)V"
		// cb is the number of bytes for the class name excluding ";" but including NULL terminating char

		// @ todo:  This should be FindTypeRefOrDef.  The original code was actually just looking up
		// the TypeRef table currently, so doing the same right now.  This may need to be fixed later
		// to look up both TypeRef and TypeDef tables.
		hr = ImportHelper::FindTypeRefByName(&(pMeta->m_pStgdb->m_MiniMd),
                                             mdTokenNil,
                                             (LPCSTR)qbNameSpace.Ptr(),
                                             (LPCSTR)qbName.Ptr(),
                                             &eType.typeref);
		if (!fCreateTrIfNotFound)
		{
				// If caller asks not to create typeref when not found,
				// it is considered to be a failure to text sig to com sig translation.
				// The scenario that this is desired is when VM gets a text sig and doesn't
				// know the target scope to look for. When it searches among known scope,
				// the searched scope will not contain the method that it is looking for
				// if the scope doesn't even contain the typeref that is required to form
				// the binary signature.
				//
				IfFailGo(hr);
		}
		else if (hr == CLDB_E_RECORD_NOTFOUND)
		{
			// This is the first time we see this TypeRef.  Create a new record
			// in the TypeRef table.
			IfFailGo(pMeta->_DefineTypeRef(mdTokenNil, qbFullName.Ptr(),
                                           false, &eType.typeref));
		}
		else
			IfFailGo(hr);
	}

	// how many bytes the base type needs
	IfFailGo( CorSigGetSimpleETypeCbSize(&eType, &cbBaseElement) );

	// jagged array "[[I" will be represented as SDARRAY SDARRAY I 0 0 
	cb = (2 * CB_ELEMENT_TYPE_MAX) * cDim + cbBaseElement;

	// ensure buffer is big enough
	IfFailGo(pqbNewSig->ReSize(cbStart + cbTotal + cb));
	prgData = (BYTE *)pqbNewSig->Ptr();

	for (cDimTmp = 0; cDimTmp < cDim; cDimTmp++)
	{

		// jagged array, put cDim numbers of ELEMENT_TYPE_SZARRAY first 
		cb = CorSigCompressElementType(ELEMENT_TYPE_SZARRAY, &prgData[cbStart + cbTotal]);
		cbTotal += cb;
	}

	// now put the element type of jagged array or just put the type
	IfFailGo(CorSigPutSimpleEType(&eType, &prgData[cbStart + cbTotal], &cb));
	cbTotal += cb;

	*pcbCount = cbTotal;
	*ppOneArgSig = pOneArgSig;
	_ASSERTE(*pcbCount);
ErrExit:
	IfFailRet(hr);
	return hr;
}


extern HRESULT ExportTypeLibFromModule(LPCWSTR, LPCWSTR, int);

//*****************************************************************************
// Helper : export typelib from this module
//*****************************************************************************
STDAPI RegMeta::ExportTypeLibFromModule(	// Result.
	LPCWSTR		szModule,					// [IN] Module name.
	LPCWSTR		szTlb,						// [IN] Typelib name.
	BOOL		bRegister)					// [IN] Set to TRUE to have the typelib be registered.
{
	return ::ExportTypeLibFromModule(szModule, szTlb, bRegister);
} // HRESULT RegMeta::ExportTypeLibFromModule()


//*****************************************************************************
// Helper : Set ResolutionScope of a TypeRef
//*****************************************************************************
HRESULT RegMeta::SetResolutionScopeHelper(  // Return hresult.
	mdTypeRef   tr,						// [IN] TypeRef record to update
	mdToken     rs)  	    	    	// [IN] new ResolutionScope 
{
    HRESULT     hr = NOERROR;
    TypeRefRec  *pTypeRef;

    LOCKWRITE();
    
    pTypeRef = m_pStgdb->m_MiniMd.getTypeRef(RidFromToken(tr));
    IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_TypeRef, TypeRefRec::COL_ResolutionScope, pTypeRef, rs));    
ErrExit:
    return hr;
}   // SetResolutionScopeHelper


//*****************************************************************************
// Helper : Set offset of a ManifestResource
//*****************************************************************************
HRESULT RegMeta::SetManifestResourceOffsetHelper(  // Return hresult.
	mdManifestResource mr,				// [IN] The manifest token
	ULONG       ulOffset)  	            // [IN] new offset 
{
    HRESULT     hr = NOERROR;
    ManifestResourceRec  *pRec;

    LOCKWRITE();
    
    pRec = m_pStgdb->m_MiniMd.getManifestResource(RidFromToken(mr));
    pRec->m_Offset = ulOffset;
    return hr;
}   // SetManifestResourceOffsetHelper

//*****************************************************************************
// Helper : get metadata information
//*****************************************************************************
STDAPI RegMeta::GetMetadata(				// Result.
    ULONG		ulSelect,					// [IN] Selector.
	void		**ppData)					// [OUT] Put pointer to data here.
{
	switch (ulSelect)
	{
	case 0:
		*ppData = &m_pStgdb->m_MiniMd;
		break;
	case 1:
		*ppData = (void*)g_CodedTokens;
		break;
	case 2:
		*ppData = (void*)g_Tables;
		break;
	default:
		*ppData = 0;
		break;
	}

	return S_OK;
} // STDAPI RegMeta::GetMetadata()




//*******************************************************************************
// 
// IMetaDataEmitHelper.
// This following apis are used by reflection emit.
//
//
//*******************************************************************************

//*******************************************************************************
// helper to define method semantics
//*******************************************************************************
HRESULT RegMeta::DefineMethodSemanticsHelper(
	mdToken		tkAssociation,			// [IN] property or event token
	DWORD		dwFlags,				// [IN] semantics
	mdMethodDef md)						// [IN] method to associated with
{
    HRESULT     hr;
    LOCKWRITE();
	hr = _DefineMethodSemantics((USHORT) dwFlags, md, tkAssociation, false);
    
    return hr;
}	// DefineMethodSemantics



//*******************************************************************************
// helper to set field layout
//*******************************************************************************
HRESULT RegMeta::SetFieldLayoutHelper(	// Return hresult.
	mdFieldDef	fd,						// [IN] field to associate the layout info
	ULONG		ulOffset)				// [IN] the offset for the field
{
	HRESULT		hr;
	FieldLayoutRec *pFieldLayoutRec;
	RID		    iFieldLayoutRec;

    LOCKWRITE();

	if (ulOffset == ULONG_MAX)
	{
		// invalid argument
		IfFailGo( E_INVALIDARG );
	}

	// create a field layout record
	IfNullGo(pFieldLayoutRec = m_pStgdb->m_MiniMd.AddFieldLayoutRecord(&iFieldLayoutRec));

	// Set the Field entry.
	IfFailGo(m_pStgdb->m_MiniMd.PutToken(
		TBL_FieldLayout, 
		FieldLayoutRec::COL_Field,
		pFieldLayoutRec, 
		fd));
	pFieldLayoutRec->m_OffSet = ulOffset;
    IfFailGo( m_pStgdb->m_MiniMd.AddFieldLayoutToHash(iFieldLayoutRec) );

ErrExit:
    
	return hr;
}	// SetFieldLayout



//*******************************************************************************
// helper to define event
//*******************************************************************************
STDMETHODIMP RegMeta::DefineEventHelper(	// Return hresult.
    mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
    LPCWSTR     szEvent,                // [IN] Name of the event   
    DWORD       dwEventFlags,           // [IN] CorEventAttr    
    mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
    mdEvent     *pmdEvent)		        // [OUT] output event token 
{
	HRESULT		hr = S_OK;
	LOG((LOGMD, "MD RegMeta::DefineEventHelper(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x)\n", 
		td, szEvent, dwEventFlags, tkEventType, pmdEvent));

    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    hr = _DefineEvent(td, szEvent, dwEventFlags, tkEventType, pmdEvent);

    
	return hr;
}	// SetDefaultValue


//*******************************************************************************
// helper to add a declarative security blob to a class or method 
//*******************************************************************************
STDMETHODIMP RegMeta::AddDeclarativeSecurityHelper(
    mdToken     tk,                     // [IN] Parent token (typedef/methoddef)
    DWORD       dwAction,               // [IN] Security action (CorDeclSecurity)
    void const  *pValue,                // [IN] Permission set blob
    DWORD       cbValue,                // [IN] Byte count of permission set blob
    mdPermission*pmdPermission)         // [OUT] Output permission token
{
    HRESULT         hr = S_OK;
    DeclSecurityRec *pDeclSec = NULL;
    RID             iDeclSec;
    short           sAction = static_cast<short>(dwAction);
    mdPermission    tkPerm;

	LOG((LOGMD, "MD RegMeta::AddDeclarativeSecurityHelper(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
		tk, dwAction, pValue, cbValue, pmdPermission));

    LOCKWRITE();
    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(TypeFromToken(tk) == mdtTypeDef || TypeFromToken(tk) == mdtMethodDef || TypeFromToken(tk) == mdtAssembly);

    // Check for valid Action.
    if (sAction == 0 || sAction > dclMaximumValue)
        IfFailGo(E_INVALIDARG);

    if (CheckDups(MDDupPermission))
    {
        hr = ImportHelper::FindPermission(&(m_pStgdb->m_MiniMd), tk, sAction, &tkPerm);

        if (SUCCEEDED(hr))
        {
            // Set output parameter.
            if (pmdPermission)
                *pmdPermission = tkPerm;
            if (IsENCOn())
                pDeclSec = m_pStgdb->m_MiniMd.getDeclSecurity(RidFromToken(tkPerm));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create a new record.
    if (!pDeclSec)
    {
        IfNullGo(pDeclSec = m_pStgdb->m_MiniMd.AddDeclSecurityRecord(&iDeclSec));
        tkPerm = TokenFromRid(iDeclSec, mdtPermission);

        // Set output parameter.
        if (pmdPermission)
            *pmdPermission = tkPerm;

        // Save parent and action information.
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_DeclSecurity, DeclSecurityRec::COL_Parent, pDeclSec, tk));
        pDeclSec->m_Action =  sAction;

        // Turn on the internal security flag on the parent.
        if (TypeFromToken(tk) == mdtTypeDef)
            IfFailGo(_TurnInternalFlagsOn(tk, tdHasSecurity));
        else if (TypeFromToken(tk) == mdtMethodDef)
            IfFailGo(_TurnInternalFlagsOn(tk, mdHasSecurity));
        IfFailGo(UpdateENCLog(tk));
    }

    // Write the blob into the record.
    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_DeclSecurity, DeclSecurityRec::COL_PermissionSet,
                                        pDeclSec, pValue, cbValue));

    IfFailGo(UpdateENCLog(tkPerm));

ErrExit:
    
	return hr;
}


//*******************************************************************************
// helper to set type's extends column
//*******************************************************************************
HRESULT RegMeta::SetTypeParent(	        // Return hresult.
	mdTypeDef   td,						// [IN] Type definition
	mdToken     tkExtends)				// [IN] parent type
{
	HRESULT		hr;
	TypeDefRec  *pRec;

    LOCKWRITE();

	IfNullGo( pRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(td)) );
    IfFailGo( m_pStgdb->m_MiniMd.PutToken(TBL_TypeDef, TypeDefRec::COL_Extends, pRec, tkExtends) );
    
ErrExit:    
	return hr;
}	// SetTypeParent


//*******************************************************************************
// helper to set type's extends column
//*******************************************************************************
HRESULT RegMeta::AddInterfaceImpl(	    // Return hresult.
	mdTypeDef   td,						// [IN] Type definition
	mdToken     tkInterface)			// [IN] interface type
{
	HRESULT		        hr;
	InterfaceImplRec    *pRec;
    RID                 ii;

    LOCKWRITE();
    hr = ImportHelper::FindInterfaceImpl(&(m_pStgdb->m_MiniMd), td, tkInterface, (mdInterfaceImpl *)&ii);
    if (hr == S_OK)
        goto ErrExit;
    IfNullGo( pRec = m_pStgdb->m_MiniMd.AddInterfaceImplRecord((RID *)&ii) );
    IfFailGo( m_pStgdb->m_MiniMd.PutToken( TBL_InterfaceImpl, InterfaceImplRec::COL_Class, pRec, td) );
    IfFailGo( m_pStgdb->m_MiniMd.PutToken( TBL_InterfaceImpl, InterfaceImplRec::COL_Interface, pRec, tkInterface) );
    
ErrExit:    
	return hr;
}	// AddInterfaceImpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\import.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Import.cpp
//
// Implementation for the meta data import code.
//
//*****************************************************************************
#include "stdafx.h"
#include "RegMeta.h"
#include "MetaData.h"
#include "CorError.h"
#include "MDUtil.h"
#include "RWUtil.h"
#include "corpriv.h"
#include "ImportHelper.h"
#include "MDLog.h"
#include "MDPerf.h"


//*****************************************************************************
// Enumerate over all the Methods in a TypeDef.
//*****************************************************************************
STDAPI RegMeta::EnumMembers(            // S_OK, S_FALSE, or error.
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.
    mdToken     rMembers[],             // [OUT] Put MemberDefs here.
    ULONG       cMax,                   // [IN] Max MemberDefs to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal   **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT         hr = NOERROR;
    ULONG           ridStartMethod;
    ULONG           ridEndMethod;
    ULONG           ridStartField;
    ULONG           ridEndField;
    ULONG           index;
    ULONG           indexField;
    TypeDefRec      *pRec;
    HENUMInternal   *pEnum = *ppmdEnum;

    LOG((LOGMD, "MD RegMeta::EnumMembers(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, cl, rMembers, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        if ( IsGlobalMethodParentTk(cl) )
        {
            cl = m_tdModule;
        }

        pRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(cl));

        ridStartMethod = m_pStgdb->m_MiniMd.getMethodListOfTypeDef(pRec);
        ridEndMethod = m_pStgdb->m_MiniMd.getEndMethodListOfTypeDef(pRec);

        ridStartField = m_pStgdb->m_MiniMd.getFieldListOfTypeDef(pRec);
        ridEndField = m_pStgdb->m_MiniMd.getEndFieldListOfTypeDef(pRec);

        
        IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtMethodDef, &pEnum) );

        // add all methods to the dynamic array
        for (index = ridStartMethod; index < ridEndMethod; index++ )
        {
            IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetMethodRid(index), mdtMethodDef) ) );
        }

        // add all fields to the dynamic array
        for (indexField = ridStartField; indexField < ridEndField; indexField++ )
        {
            IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetFieldRid(indexField), mdtFieldDef) ) );
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rMembers, pcTokens);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumMembers);
    return hr;
} // STDAPI RegMeta::EnumMembers()


//*****************************************************************************
// Enumerate over all the Methods in a TypeDef that has szName
//*****************************************************************************
STDAPI RegMeta::EnumMembersWithName(    // S_OK, S_FALSE, or error.         
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.               
    mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.
    LPCWSTR     szName,                 // [IN] Limit results to those with this name.             
    mdToken     rMembers[],             // [OUT] Put MemberDefs here.                
    ULONG       cMax,                   // [IN] Max MemberDefs to put.             
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               ridStart;
    ULONG               ridEnd;
    ULONG               index;
    TypeDefRec          *pRec;
    MethodRec           *pMethod;
    FieldRec            *pField;
    HENUMInternal       *pEnum = *ppmdEnum;
    LPUTF8              szNameUtf8 = UTF8STR(szName);
    LPCUTF8             szNameUtf8Tmp;

    LOG((LOGMD, "MD RegMeta::EnumMembersWithName(0x%08x, 0x%08x, %S, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, cl, MDSTR(szName), rMembers, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        // create the enumerator
        IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtMethodDef, &pEnum) );

        if ( IsGlobalMethodParentTk(cl) )
        {
            cl = m_tdModule;
        }
        
        // get the range of method rids given a typedef
        pRec = pMiniMd->getTypeDef(RidFromToken(cl));
        ridStart = pMiniMd->getMethodListOfTypeDef(pRec);
        ridEnd = pMiniMd->getEndMethodListOfTypeDef(pRec);

        for (index = ridStart; index < ridEnd; index++ )
        {
            if (szNameUtf8 == NULL)
            {
                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetMethodRid(index), mdtMethodDef) ) );
            }
            else
            {
                pMethod = pMiniMd->getMethod( pMiniMd->GetMethodRid(index) );
                szNameUtf8Tmp = pMiniMd->getNameOfMethod(pMethod);
                if ( strcmp(szNameUtf8Tmp, szNameUtf8) == 0 )
                {
                    IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetMethodRid(index), mdtMethodDef) ) );
                }
            }
        }

        ridStart = m_pStgdb->m_MiniMd.getFieldListOfTypeDef(pRec);
        ridEnd = m_pStgdb->m_MiniMd.getEndFieldListOfTypeDef(pRec);

        for (index = ridStart; index < ridEnd; index++ )
        {
            if (szNameUtf8 == NULL)
            {
                HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetFieldRid(index), mdtFieldDef) );
            }
            else
            {
                pField = pMiniMd->getField( pMiniMd->GetFieldRid(index) );
                szNameUtf8Tmp = pMiniMd->getNameOfField( pField );
                if ( strcmp(szNameUtf8Tmp, szNameUtf8) == 0 )
                {
                    HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetFieldRid(index), mdtFieldDef) );
                }
            }
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rMembers, pcTokens);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumMembersWithName);
    return hr;
} // STDAPI RegMeta::EnumMembersWithName()


//*****************************************************************************
// enumerating through methods given a Typedef and the flag
//*****************************************************************************
STDAPI RegMeta::EnumMethods(
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
    mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.   
    ULONG       cMax,                   // [IN] Max MethodDefs to put.  
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               ridStart;
    ULONG               ridEnd;
    TypeDefRec          *pRec;
    HENUMInternal       *pEnum = *ppmdEnum;

	LOG((LOGMD, "MD RegMeta::EnumMethods(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
		phEnum, td, rMethods, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();
	
	if ( pEnum == 0 )
	{
		// instantiating a new ENUM
		CMiniMdRW		*pMiniMd = &(m_pStgdb->m_MiniMd);

		// Check for mdTypeDefNil (representing <Module>).
		// If so, this will map it to its token.
		//
		if ( IsGlobalMethodParentTk(td) )
		{
			td = m_tdModule;
		}

		pRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(td));
		ridStart = m_pStgdb->m_MiniMd.getMethodListOfTypeDef(pRec);
		ridEnd = m_pStgdb->m_MiniMd.getEndMethodListOfTypeDef(pRec);

		if (pMiniMd->HasIndirectTable(TBL_Method) || pMiniMd->HasDelete())
		{
			IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtMethodDef, &pEnum) );

			// add all methods to the dynamic array
			for (ULONG index = ridStart; index < ridEnd; index++ )
			{
                if (pMiniMd->HasDelete() && 
                    ((m_OptionValue.m_ImportOption & MDImportOptionAllMethodDefs) == 0))
                {
                    MethodRec       *pRec = pMiniMd->getMethod(pMiniMd->GetMethodRid(index));
                    if (IsMdRTSpecialName(pRec->m_Flags) && IsDeletedName(pMiniMd->getNameOfMethod(pRec)) )
                    {   
                        continue;
                    }
                }
                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetMethodRid(index), mdtMethodDef) ) );
			}
		}
		else
		{
			IfFailGo( HENUMInternal::CreateSimpleEnum( mdtMethodDef, ridStart, ridEnd, &pEnum) );
		}

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rMethods, pcTokens);

ErrExit:
	HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumMethods);
	return hr;
} // STDAPI RegMeta::EnumMethods()




//*****************************************************************************
// Enumerate over all the methods with szName in a TypeDef.
//*****************************************************************************
STDAPI RegMeta::EnumMethodsWithName(    // S_OK, S_FALSE, or error.         
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.               
    mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.
    LPCWSTR     szName,                 // [IN] Limit results to those with this name.             
    mdMethodDef rMethods[],             // [OU] Put MethodDefs here.                
    ULONG       cMax,                   // [IN] Max MethodDefs to put.             
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               ridStart;
    ULONG               ridEnd;
    ULONG               index;
    TypeDefRec          *pRec;
    MethodRec           *pMethod;
    HENUMInternal       *pEnum = *ppmdEnum;
    LPUTF8              szNameUtf8 = UTF8STR(szName);
    LPCUTF8             szNameUtf8Tmp;

    LOG((LOGMD, "MD RegMeta::EnumMethodsWithName(0x%08x, 0x%08x, %S, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, cl, MDSTR(szName), rMethods, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();
    

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        // Check for mdTypeDefNil (representing <Module>).
        // If so, this will map it to its token.
        //
        if ( IsGlobalMethodParentTk(cl) )
        {
            cl = m_tdModule;
        }
        

        // create the enumerator
        IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtMethodDef, &pEnum) );
        
        // get the range of method rids given a typedef
        pRec = pMiniMd->getTypeDef(RidFromToken(cl));
        ridStart = pMiniMd->getMethodListOfTypeDef(pRec);
        ridEnd = pMiniMd->getEndMethodListOfTypeDef(pRec);

        for (index = ridStart; index < ridEnd; index++ )
        {
            if ( szNameUtf8 == NULL )
            {
                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetMethodRid(index), mdtMethodDef) ) );
            }
            else
            {
                pMethod = pMiniMd->getMethod( pMiniMd->GetMethodRid(index) );
                szNameUtf8Tmp = pMiniMd->getNameOfMethod( pMethod );
                if ( strcmp(szNameUtf8Tmp, szNameUtf8) == 0 )
                {
                    IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetMethodRid(index), mdtMethodDef) ) );
                }
            }
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rMethods, pcTokens);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumMethodsWithName);
    return hr;
} // STDAPI RegMeta::EnumMethodsWithName()



//*****************************************************************************
// Enumerate over all the fields in a TypeDef and a flag.
//*****************************************************************************
STDAPI RegMeta::EnumFields(     		// S_OK, S_FALSE, or error.
	HCORENUM	*phEnum,				// [IN|OUT] Pointer to the enum.
	mdTypeDef	td, 					// [IN] TypeDef to scope the enumeration.
	mdFieldDef	rFields[],				// [OUT] Put FieldDefs here.
	ULONG		cMax,					// [IN] Max FieldDefs to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               ridStart;
    ULONG               ridEnd;
    TypeDefRec          *pRec;
    HENUMInternal       *pEnum = *ppmdEnum;

	LOG((LOGMD, "MD RegMeta::EnumFields(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
		phEnum, td, rFields, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();
	
	if ( pEnum == 0 )
	{
		// instantiating a new ENUM
		CMiniMdRW		*pMiniMd = &(m_pStgdb->m_MiniMd);

		// Check for mdTypeDefNil (representing <Module>).
		// If so, this will map it to its token.
		//
		if ( IsGlobalMethodParentTk(td) )
		{
			td = m_tdModule;
		}

		pRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(td));
		ridStart = m_pStgdb->m_MiniMd.getFieldListOfTypeDef(pRec);
		ridEnd = m_pStgdb->m_MiniMd.getEndFieldListOfTypeDef(pRec);

		if (pMiniMd->HasIndirectTable(TBL_Field) || pMiniMd->HasDelete())
		{
			IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtFieldDef, &pEnum) );

			// add all methods to the dynamic array
			for (ULONG index = ridStart; index < ridEnd; index++ )
			{
                if (pMiniMd->HasDelete() && 
                    ((m_OptionValue.m_ImportOption & MDImportOptionAllFieldDefs) == 0))
                {
                    FieldRec       *pRec = pMiniMd->getField(pMiniMd->GetFieldRid(index));
                    if (IsFdRTSpecialName(pRec->m_Flags) && IsDeletedName(pMiniMd->getNameOfField(pRec)) )
                    {   
                        continue;
                    }
                }
				IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetFieldRid(index), mdtFieldDef) ) );
			}
		}
		else
		{
			IfFailGo( HENUMInternal::CreateSimpleEnum( mdtFieldDef, ridStart, ridEnd, &pEnum) );
		}

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rFields, pcTokens);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumFields);
    return hr;
} // STDAPI RegMeta::EnumFields()



//*****************************************************************************
// Enumerate over all the fields with szName in a TypeDef.
//*****************************************************************************
STDAPI RegMeta::EnumFieldsWithName(     // S_OK, S_FALSE, or error.        
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.               
    mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.
    LPCWSTR     szName,                 // [IN] Limit results to those with this name.             
    mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                
    ULONG       cMax,                   // [IN] Max MemberDefs to put.             
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               ridStart;
    ULONG               ridEnd;
    ULONG               index;
    TypeDefRec          *pRec;
    FieldRec            *pField;
    HENUMInternal       *pEnum = *ppmdEnum;
    LPUTF8              szNameUtf8 = UTF8STR(szName);
    LPCUTF8             szNameUtf8Tmp;

    LOG((LOGMD, "MD RegMeta::EnumFields(0x%08x, 0x%08x, %S, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, cl, MDSTR(szName), rFields, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();
    
    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        // Check for mdTypeDefNil (representing <Module>).
        // If so, this will map it to its token.
        //
        if ( IsGlobalMethodParentTk(cl) )
        {
            cl = m_tdModule;
        }

        // create the enumerator
        IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtMethodDef, &pEnum) );
        
        // get the range of field rids given a typedef
        pRec = pMiniMd->getTypeDef(RidFromToken(cl));
        ridStart = m_pStgdb->m_MiniMd.getFieldListOfTypeDef(pRec);
        ridEnd = m_pStgdb->m_MiniMd.getEndFieldListOfTypeDef(pRec);

        for (index = ridStart; index < ridEnd; index++ )
        {
            if ( szNameUtf8 == NULL )
            {
                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetFieldRid(index), mdtFieldDef) ) );
            }
            else
            {
                pField = pMiniMd->getField( pMiniMd->GetFieldRid(index) );
                szNameUtf8Tmp = pMiniMd->getNameOfField(pField);
                if ( strcmp(szNameUtf8Tmp, szNameUtf8) == 0 )
                {
                    IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetFieldRid(index), mdtFieldDef) ) );
                }
            }
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rFields, pcTokens);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumFieldsWithName);
    return hr;
} // STDAPI RegMeta::EnumFieldsWithName()


//*****************************************************************************
// Enumerate over the ParamDefs in a Method.
//*****************************************************************************
STDAPI RegMeta::EnumParams(             // S_OK, S_FALSE, or error.
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration.
    mdParamDef  rParams[],              // [OUT] Put ParamDefs here.
    ULONG       cMax,                   // [IN] Max ParamDefs to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               ridStart;
    ULONG               ridEnd;
    MethodRec           *pRec;
    HENUMInternal       *pEnum = *ppmdEnum;

    LOG((LOGMD, "MD RegMeta::EnumParams(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, mb, rParams, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();
    

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
        pRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(mb));
        ridStart = m_pStgdb->m_MiniMd.getParamListOfMethod(pRec);
        ridEnd = m_pStgdb->m_MiniMd.getEndParamListOfMethod(pRec);

        if (pMiniMd->HasIndirectTable(TBL_Param))
        {
            IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtParamDef, &pEnum) );

            // add all methods to the dynamic array
            for (ULONG index = ridStart; index < ridEnd; index++ )
            {
                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetParamRid(index), mdtParamDef) ) );
            }
        }
        else
        {
            IfFailGo( HENUMInternal::CreateSimpleEnum( mdtParamDef, ridStart, ridEnd, &pEnum) );
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rParams, pcTokens);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumParams);
    return hr;
} // STDAPI RegMeta::EnumParams()



//*****************************************************************************
// Enumerate the MemberRefs given the parent token.
//*****************************************************************************
STDAPI RegMeta::EnumMemberRefs(         // S_OK, S_FALSE, or error.
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdToken     tkParent,               // [IN] Parent token to scope the enumeration.
    mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.
    ULONG       cMax,                   // [IN] Max MemberRefs to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               ridEnd;
    ULONG               index;
    MemberRefRec        *pRec;
    HENUMInternal       *pEnum = *ppmdEnum;

    LOG((LOGMD, "MD RegMeta::EnumMemberRefs(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, tkParent, rMemberRefs, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
        mdToken     tk;

        // Check for mdTypeDefNil (representing <Module>).
        // If so, this will map it to its token.
        //
        IsGlobalMethodParent(&tkParent);

        // create the enumerator
        IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtMemberRef, &pEnum) );
        
        // get the range of field rids given a typedef
        ridEnd = pMiniMd->getCountMemberRefs();

        for (index = 1; index <= ridEnd; index++ )
        {
            pRec = pMiniMd->getMemberRef(index);
            tk = pMiniMd->getClassOfMemberRef(pRec);
            if ( tk == tkParent )
            {
                // add the matched ones to the enumerator
                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(index, mdtMemberRef) ) );
            }
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rMemberRefs, pcTokens);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumMemberRefs);
    return hr;
} // STDAPI RegMeta::EnumMemberRefs()


//*****************************************************************************
// Enumerate methodimpls given a typedef
//*****************************************************************************
STDAPI RegMeta::EnumMethodImpls(        // S_OK, S_FALSE, or error
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.
    mdToken     rMethodBody[],          // [OUT] Put Method Body tokens here.   
    mdToken     rMethodDecl[],          // [OUT] Put Method Declaration tokens here.
    ULONG       cMax,                   // [IN] Max tokens to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    MethodImplRec       *pRec;
    HENUMInternal       *pEnum = *ppmdEnum;
    HENUMInternal hEnum;
    

    LOG((LOGMD, "MD RegMeta::EnumMethodImpls(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, td, rMethodBody, rMethodDecl, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();
    
    memset(&hEnum, 0, sizeof(HENUMInternal));

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
        mdToken         tkMethodBody;
        mdToken         tkMethodDecl;
        RID             ridCur;

        if ( !pMiniMd->IsSorted(TBL_MethodImpl))        
        {
            // MethodImpl table is not sorted. We need to
            // grab the write lock since we can MethodImpl table to be sorted.
            //
            CONVERT_READ_TO_WRITE_LOCK();
        }

        // Get the range of rids.
        IfFailGo( pMiniMd->FindMethodImplHelper(td, &hEnum) );

        // Create the enumerator, DynamicArrayEnum does not use the token type.
        IfFailGo( HENUMInternal::CreateDynamicArrayEnum( (TBL_MethodImpl << 24), &pEnum) );

        while (HENUMInternal::EnumNext(&hEnum, (mdToken *)&ridCur))
        {
            // Get the MethodBody and MethodDeclaration tokens for the current
            // MethodImpl record.
            pRec = pMiniMd->getMethodImpl(ridCur);
            tkMethodBody = pMiniMd->getMethodBodyOfMethodImpl(pRec);
            tkMethodDecl = pMiniMd->getMethodDeclarationOfMethodImpl(pRec);

            // Add the Method body/declaration pairs to the Enum
            IfFailGo( HENUMInternal::AddElementToEnum(pEnum, tkMethodBody ) );
            IfFailGo( HENUMInternal::AddElementToEnum(pEnum, tkMethodDecl ) );
        }

        // set the output parameter
        *ppmdEnum = pEnum;
    }

    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rMethodBody, rMethodDecl, pcTokens);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    HENUMInternal::ClearEnum(&hEnum);
    
    STOP_MD_PERF(EnumMethodImpls);
    return hr;
} // STDAPI RegMeta::EnumMethodImpls()


//*****************************************************************************
// Enumerate over PermissionSets.  Optionally limit to an object and/or an
//  action.
//*****************************************************************************
STDAPI RegMeta::EnumPermissionSets(     // S_OK, S_FALSE, or error.
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.
    DWORD       dwActions,              // [IN] if !0, return only these actions.
    mdPermission rPermission[],         // [OUT] Put Permissions here.
    ULONG       cMax,                   // [IN] Max Permissions to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               ridStart;
    ULONG               ridEnd;
    ULONG               index;
    DeclSecurityRec     *pRec;
    HENUMInternal       *pEnum = *ppmdEnum;
    bool                fCompareParent = false;
    mdToken             typ = TypeFromToken(tk);
    mdToken             tkParent;

    LOG((LOGMD, "MD RegMeta::EnumPermissionSets(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, tk, dwActions, rPermission, cMax, pcTokens));
    START_MD_PERF();
    LOCKREAD();
    
    if ( pEnum == 0 )
    {
        // Does this token type even have security?
        if (tk != 0 && 
            !(typ == mdtTypeDef || typ == mdtMethodDef || typ == mdtAssembly))
        {
            if (pcTokens)
                *pcTokens = 0;
            hr = S_FALSE;
            goto ErrExit;
        }
    
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        if (!IsNilToken(tk))
        {
            // parent is provided for lookup
            if ( pMiniMd->IsSorted( TBL_DeclSecurity ) )
            {
                ridStart = pMiniMd->getDeclSecurityForToken(tk, &ridEnd);
            }
            else
            {
                // table is not sorted. So we have to do a table scan
                ridStart = 1;
                ridEnd = pMiniMd->getCountDeclSecuritys() + 1;
                fCompareParent = true;
            }
        }
        else
        {
            ridStart = 1;
            ridEnd = pMiniMd->getCountDeclSecuritys() + 1;
        }

        if (IsDclActionNil(dwActions) && !fCompareParent && !m_pStgdb->m_MiniMd.HasDelete())
        {
            // create simple enumerator
            IfFailGo( HENUMInternal::CreateSimpleEnum( mdtPermission, ridStart, ridEnd, &pEnum) );
        }
        else
        {
            // create the dynamic enumerator
            IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtPermission, &pEnum) );                
            
            for (index = ridStart; index < ridEnd; index++ )
            {
                pRec = pMiniMd->getDeclSecurity(index);
                tkParent = pMiniMd->getParentOfDeclSecurity(pRec);
                if ( (fCompareParent && tk != tkParent) || 
                      IsNilToken(tkParent) )
                {
                    // We need to compare parent token and they are not equal so skip
                    // over this row.
                    //
                    continue;
                }
                if ( IsDclActionNil(dwActions) ||
                    ( (DWORD)(pMiniMd->getActionOfDeclSecurity(pRec))) ==  dwActions )
                {
                    // If we don't need to compare the action, just add to the enum.
                    // Or we need to compare the action and the action values are equal, add to enum as well.
                    //
                    IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(index, mdtPermission) ) );
                }
            }
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rPermission, pcTokens);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumPermissionSets);
    return hr;
} // STDAPI RegMeta::EnumPermissionSets()


//*****************************************************************************
// Find a given member in a TypeDef (typically a class).
//*****************************************************************************
STDAPI RegMeta::FindMember(
    mdTypeDef   td,                     // [IN] given typedef
    LPCWSTR     szName,                 // [IN] member name
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
    mdToken     *pmb)                   // [OUT] matching memberdef
{
    HRESULT             hr = NOERROR;

    LOG((LOGMD, "MD RegMeta::FindMember(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x)\n", 
        td, MDSTR(szName), pvSigBlob, cbSigBlob, pmb));
    START_MD_PERF();

    // Don't lock this function. All of the functions that it calls are public APIs. keep it that way.

    // try to match with method first of all
    hr = FindMethod(
        td,
        szName,
        pvSigBlob,
        cbSigBlob,
        pmb);

    if ( hr == CLDB_E_RECORD_NOTFOUND )
    {
        // now try field table
        IfFailGo( FindField(
            td,
            szName,
            pvSigBlob,
            cbSigBlob,
            pmb) );
    }
ErrExit:
    STOP_MD_PERF(FindMember);
    return hr;
} // STDAPI RegMeta::FindMember()



//*****************************************************************************
// Find a given member in a TypeDef (typically a class).
//*****************************************************************************
STDAPI RegMeta::FindMethod(
    mdTypeDef   td,                     // [IN] given typedef
    LPCWSTR     szName,                 // [IN] member name
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
    mdMethodDef *pmb)                   // [OUT] matching memberdef
{
    HRESULT             hr = NOERROR;
    CMiniMdRW           *pMiniMd = &(m_pStgdb->m_MiniMd);
    LPUTF8              szNameUtf8 = UTF8STR(szName);

    LOG((LOGMD, "MD RegMeta::FindMethod(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x)\n", 
        td, MDSTR(szName), pvSigBlob, cbSigBlob, pmb));
    START_MD_PERF();
    LOCKREAD();    

    // If this is a global method, then use the <Module> typedef as parent.
    IsGlobalMethodParent(&td);

    IfFailGo(ImportHelper::FindMethod(pMiniMd, 
        td, 
        szNameUtf8, 
        pvSigBlob, 
        cbSigBlob, 
        pmb));

ErrExit:
    
    STOP_MD_PERF(FindMethod);
    return hr;
} // STDAPI RegMeta::FindMethod()


//*****************************************************************************
// Find a given member in a TypeDef (typically a class).
//*****************************************************************************
STDAPI RegMeta::FindField(
    mdTypeDef   td,                     // [IN] given typedef
    LPCWSTR     szName,                 // [IN] member name
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
    mdFieldDef  *pmb)                   // [OUT] matching memberdef
{
    HRESULT             hr = NOERROR;
    CMiniMdRW           *pMiniMd = &(m_pStgdb->m_MiniMd);
    LPUTF8              szNameUtf8 = UTF8STR(szName);


    LOG((LOGMD, "MD RegMeta::FindField(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x)\n", 
        td, MDSTR(szName), pvSigBlob, cbSigBlob, pmb));
    START_MD_PERF();
    LOCKREAD();    
    
    // If this is a global method, then use the <Module> typedef as parent.
    IsGlobalMethodParent(&td);

    IfFailGo(ImportHelper::FindField(pMiniMd, 
        td, 
        szNameUtf8,
        pvSigBlob,
        cbSigBlob,
        pmb));
ErrExit:
        
    STOP_MD_PERF(FindField);
    return hr;
} // STDAPI RegMeta::FindField()


//*****************************************************************************
// Find a given MemberRef in a TypeRef (typically a class).  If no TypeRef
//  is specified, the query will be for a random member in the scope.
//*****************************************************************************
STDAPI RegMeta::FindMemberRef(
    mdToken     tkPar,                  // [IN] given parent token.
    LPCWSTR     szName,                 // [IN] member name
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
    mdMemberRef *pmr)                   // [OUT] matching memberref
{
    HRESULT             hr = NOERROR;
    CMiniMdRW           *pMiniMd = &(m_pStgdb->m_MiniMd);
    LPUTF8              szNameUtf8 = UTF8STR(szName);

    LOG((LOGMD, "MD RegMeta::FindMemberRef(0x%08x, %S, 0x%08x, 0x%08x, 0x%08x)\n", 
        tkPar, MDSTR(szName), pvSigBlob, cbSigBlob, pmr));
    START_MD_PERF();

    // @todo: Can this causing building hash table? If so, should this consider the write lock?
    LOCKREAD();
    
    // get the range of field rids given a typedef
    _ASSERTE(TypeFromToken(tkPar) == mdtTypeRef || TypeFromToken(tkPar) == mdtMethodDef ||
            TypeFromToken(tkPar) == mdtModuleRef || TypeFromToken(tkPar) == mdtTypeDef || 
            TypeFromToken(tkPar) == mdtTypeSpec);

    // Set parent to global class m_tdModule if mdTokenNil is passed.
    if (IsNilToken(tkPar))
        tkPar = m_tdModule;

    IfFailGo( ImportHelper::FindMemberRef(pMiniMd, tkPar, szNameUtf8, pvSigBlob, cbSigBlob, pmr) );

ErrExit:
    
    STOP_MD_PERF(FindMemberRef);
    return hr;
} // STDAPI RegMeta::FindMemberRef()


//*****************************************************************************
// Return the property of a MethodDef
//*****************************************************************************
STDAPI RegMeta::GetMethodProps(
    mdMethodDef mb,                     // The method for which to get props.
    mdTypeDef   *pClass,                // Put method's class here.
    LPWSTR      szMethod,               // Put method's name here.
    ULONG       cchMethod,              // Size of szMethod buffer in wide chars.
    ULONG       *pchMethod,             // Put actual size here
    DWORD       *pdwAttr,               // Put flags here.
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data
    ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob
    ULONG       *pulCodeRVA,            // [OUT] codeRVA
    DWORD       *pdwImplFlags)          // [OUT] Impl. Flags
{
    HRESULT             hr = NOERROR;
    MethodRec           *pMethodRec;
    CMiniMdRW           *pMiniMd = &(m_pStgdb->m_MiniMd);

    LOG((LOGMD, "MD RegMeta::GetMethodProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        mb, pClass, szMethod, cchMethod, pchMethod, pdwAttr, ppvSigBlob, pcbSigBlob, 
        pulCodeRVA, pdwImplFlags));
    START_MD_PERF();
    LOCKREAD();    

    if ( pClass && !pMiniMd->IsParentTableOfMethodValid() )
    {
        // we need to take a write lock since parent table for Method might be rebuilt!
        CONVERT_READ_TO_WRITE_LOCK();
    }

    _ASSERTE(TypeFromToken(mb) == mdtMethodDef);

    pMethodRec = pMiniMd->getMethod(RidFromToken(mb));

    if (szMethod || pchMethod)
    {
        IfFailGo( pMiniMd->getNameOfMethod(pMethodRec, szMethod, cchMethod, pchMethod) );
    }

    if (pClass)
    {
        // caller wants parent typedef
        IfFailGo( pMiniMd->FindParentOfMethodHelper(mb, pClass) );

        if ( IsGlobalMethodParentToken(*pClass) )
        {
            // If the parent of Method is the <Module>, return mdTypeDefNil instead.
            *pClass = mdTypeDefNil;
        }

    }
    if (ppvSigBlob || pcbSigBlob)
    {   
        // caller wants signature information
        PCCOR_SIGNATURE pvSigTmp;
        ULONG           cbSig;
        pvSigTmp = pMiniMd->getSignatureOfMethod(pMethodRec, &cbSig);
        if ( ppvSigBlob )
            *ppvSigBlob = pvSigTmp;
        if ( pcbSigBlob)
            *pcbSigBlob = cbSig;                
    }
    if ( pdwAttr )
    {
        *pdwAttr = pMiniMd->getFlagsOfMethod(pMethodRec);
    }
    if ( pulCodeRVA ) 
    {
        *pulCodeRVA = pMiniMd->getRVAOfMethod(pMethodRec);
    }
    if ( pdwImplFlags )
    {
        *pdwImplFlags = (DWORD )pMiniMd->getImplFlagsOfMethod(pMethodRec);
    }

ErrExit:
    STOP_MD_PERF(GetMethodProps);
    return hr;
} // STDAPI RegMeta::GetMethodProps()


//*****************************************************************************
// Return the property of a MemberRef
//*****************************************************************************
STDAPI RegMeta::GetMemberRefProps(      // S_OK or error.
    mdMemberRef mr,                     // [IN] given memberref
    mdToken     *ptk,                   // [OUT] Put classref or classdef here.
    LPWSTR      szMember,               // [OUT] buffer to fill for member's name
    ULONG       cchMember,              // [IN] the count of char of szMember
    ULONG       *pchMember,             // [OUT] actual count of char in member name
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value
    ULONG       *pbSig)                 // [OUT] actual size of signature blob
{
    HRESULT         hr = NOERROR;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
    MemberRefRec    *pMemberRefRec;

    LOG((LOGMD, "MD RegMeta::GetMemberRefProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        mr, ptk, szMember, cchMember, pchMember, ppvSigBlob, pbSig));
    START_MD_PERF();
    LOCKREAD();    

    _ASSERTE(TypeFromToken(mr) == mdtMemberRef);
    
	pMemberRefRec = pMiniMd->getMemberRef(RidFromToken(mr));

    if (ptk)
    {
        *ptk = pMiniMd->getClassOfMemberRef(pMemberRefRec);     
        if ( IsGlobalMethodParentToken(*ptk) )
        {
            // If the parent of MemberRef is the <Module>, return mdTypeDefNil instead.
            *ptk = mdTypeDefNil;
        }

    }
    if (szMember || pchMember)
    {
        IfFailGo( pMiniMd->getNameOfMemberRef(pMemberRefRec, szMember, cchMember, pchMember) );
    }
    if (ppvSigBlob || pbSig)
    {   
        // caller wants signature information
        PCCOR_SIGNATURE pvSigTmp;
        ULONG           cbSig;
        pvSigTmp = pMiniMd->getSignatureOfMemberRef(pMemberRefRec, &cbSig);
        if ( ppvSigBlob )
            *ppvSigBlob = pvSigTmp;
        if ( pbSig)
            *pbSig = cbSig;             
    }

ErrExit:
        
    STOP_MD_PERF(GetMemberRefProps);
    return hr;
} // STDAPI RegMeta::GetMemberRefProps()


//*****************************************************************************
// enumerate Property tokens for a typedef
//*****************************************************************************
STDAPI RegMeta::EnumProperties( 		// S_OK, S_FALSE, or error.
	HCORENUM	*phEnum,				// [IN|OUT] Pointer to the enum.
	mdTypeDef	td, 					// [IN] TypeDef to scope the enumeration.
	mdProperty	rProperties[],			// [OUT] Put Properties here.
	ULONG		cMax,					// [IN] Max properties to put.
	ULONG		*pcProperties) 			// [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               ridStart = 0;
    ULONG               ridEnd = 0;
    HENUMInternal       *pEnum = *ppmdEnum;

    LOG((LOGMD, "MD RegMeta::EnumProperties(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, td, rProperties, cMax, pcProperties));
    START_MD_PERF();
    LOCKREAD();
    
    if (IsNilToken(td))
    {
        if (pcProperties)
            *pcProperties = 0;
        hr = S_FALSE;
        goto ErrExit;
    }

    _ASSERTE(TypeFromToken(td) == mdtTypeDef);


    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
        RID         ridPropertyMap;
        PropertyMapRec *pPropertyMapRec;

        // get the starting/ending rid of properties of this typedef
        ridPropertyMap = pMiniMd->FindPropertyMapFor(RidFromToken(td));
        if (!InvalidRid(ridPropertyMap))
        {
            pPropertyMapRec = m_pStgdb->m_MiniMd.getPropertyMap(ridPropertyMap);
            ridStart = pMiniMd->getPropertyListOfPropertyMap(pPropertyMapRec);
            ridEnd = pMiniMd->getEndPropertyListOfPropertyMap(pPropertyMapRec);
        }

		if (pMiniMd->HasIndirectTable(TBL_Property) || pMiniMd->HasDelete())
		{
			IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtProperty, &pEnum) );

			// add all methods to the dynamic array
			for (ULONG index = ridStart; index < ridEnd; index++ )
			{
                if (pMiniMd->HasDelete() && 
                    ((m_OptionValue.m_ImportOption & MDImportOptionAllProperties) == 0))
                {
                    PropertyRec       *pRec = pMiniMd->getProperty(pMiniMd->GetPropertyRid(index));
                    if (IsPrRTSpecialName(pRec->m_PropFlags) && IsDeletedName(pMiniMd->getNameOfProperty(pRec)) )
                    {   
                        continue;
                    }
                }
				IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetPropertyRid(index), mdtProperty) ) );
			}
		}
		else
		{
			IfFailGo( HENUMInternal::CreateSimpleEnum( mdtProperty, ridStart, ridEnd, &pEnum) );
		}

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rProperties, pcProperties);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);

    
    STOP_MD_PERF(EnumProperties);
    return hr;
} // STDAPI RegMeta::EnumProperties()


//*****************************************************************************
// enumerate event tokens for a typedef
//*****************************************************************************
STDAPI RegMeta::EnumEvents(  			// S_OK, S_FALSE, or error.
	HCORENUM	*phEnum,				// [IN|OUT] Pointer to the enum.
	mdTypeDef	td, 					// [IN] TypeDef to scope the enumeration.
	mdEvent 	rEvents[],				// [OUT] Put events here.
	ULONG		cMax,					// [IN] Max events to put.
	ULONG		*pcEvents)  			// [OUT] Put # put here.
{
    HENUMInternal   **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT         hr = NOERROR;
    ULONG           ridStart = 0;
    ULONG           ridEnd = 0;
    HENUMInternal   *pEnum = *ppmdEnum;

    LOG((LOGMD, "MD RegMeta::EnumEvents(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, td, rEvents,  cMax, pcEvents));
    START_MD_PERF();
    LOCKREAD();
    
    _ASSERTE(TypeFromToken(td) == mdtTypeDef);


    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
        RID         ridEventMap;
        EventMapRec *pEventMapRec;

        // get the starting/ending rid of properties of this typedef
        ridEventMap = pMiniMd->FindEventMapFor(RidFromToken(td));
        if (!InvalidRid(ridEventMap))
        {
            pEventMapRec = pMiniMd->getEventMap(ridEventMap);
            ridStart = pMiniMd->getEventListOfEventMap(pEventMapRec);
            ridEnd = pMiniMd->getEndEventListOfEventMap(pEventMapRec);
        }

		if (pMiniMd->HasIndirectTable(TBL_Event) || pMiniMd->HasDelete())
		{
			IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtEvent, &pEnum) );

			// add all methods to the dynamic array
			for (ULONG index = ridStart; index < ridEnd; index++ )
			{
                if (pMiniMd->HasDelete() && 
                    ((m_OptionValue.m_ImportOption & MDImportOptionAllEvents) == 0))
                {
                    EventRec       *pRec = pMiniMd->getEvent(pMiniMd->GetEventRid(index));
                    if (IsEvRTSpecialName(pRec->m_EventFlags) && IsDeletedName(pMiniMd->getNameOfEvent(pRec)) )
                    {   
                        continue;
                    }
                }
				IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetEventRid(index), mdtEvent) ) );
			}
		}
		else
		{
			IfFailGo( HENUMInternal::CreateSimpleEnum( mdtEvent, ridStart, ridEnd, &pEnum) );
		}

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rEvents, pcEvents);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);

    
    STOP_MD_PERF(EnumEvents);
    return hr;
} // STDAPI RegMeta::EnumEvents()



//*****************************************************************************
// return the properties of an event token
//*****************************************************************************
STDAPI RegMeta::GetEventProps(          // S_OK, S_FALSE, or error.
    mdEvent     ev,                     // [IN] event token
    mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.
    LPCWSTR     szEvent,                // [OUT] Event name
    ULONG       cchEvent,               // [IN] the count of wchar of szEvent
    ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name
    DWORD       *pdwEventFlags,         // [OUT] Event flags.
    mdToken     *ptkEventType,          // [OUT] EventType class
    mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event
    mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event
    mdMethodDef *pmdFire,               // [OUT] Fire method of the event
    mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event
    ULONG       cMax,                   // [IN] size of rmdOtherMethod
    ULONG       *pcOtherMethod)         // [OUT] total number of other method of this event
{
    HRESULT         hr = NOERROR;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
    EventRec        *pRec;
    HENUMInternal   hEnum;

    LOG((LOGMD, "MD RegMeta::GetEventProps(0x%08x, 0x%08x, %S, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        ev, pClass, MDSTR(szEvent), cchEvent, pchEvent, pdwEventFlags, ptkEventType,
        pmdAddOn, pmdRemoveOn, pmdFire, rmdOtherMethod, cMax, pcOtherMethod));
    START_MD_PERF();
    LOCKREAD();
    
    _ASSERTE(TypeFromToken(ev) == mdtEvent);

    if ( !pMiniMd->IsSorted(TBL_MethodSemantics) || (pClass && !pMiniMd->IsParentTableOfEventValid() ) )        
    {
        // MethodSemantics table is not sorted. We need to
        // grab the write lock since we can cause constant table or MethodSemantics table to be sorted.
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }

    memset(&hEnum, 0, sizeof(HENUMInternal));
	pRec = pMiniMd->getEvent( RidFromToken(ev) );

    if ( pClass )
    {
        // find the event map entry corresponding to this event
        IfFailGo( pMiniMd->FindParentOfEventHelper( ev, pClass ) );
    }
    if (szEvent || pchEvent)
    {
        IfFailGo( pMiniMd->getNameOfEvent(pRec, (LPWSTR) szEvent, cchEvent, pchEvent) );
    }
    if ( pdwEventFlags )
    {
        *pdwEventFlags = pMiniMd->getEventFlagsOfEvent(pRec);
    }
    if ( ptkEventType )
    {
        *ptkEventType = pMiniMd->getEventTypeOfEvent(pRec);
    }
    {
        MethodSemanticsRec *pSemantics;
        RID         ridCur;
        ULONG       cCurOtherMethod = 0;
        ULONG       ulSemantics;
        mdMethodDef tkMethod;

        // initialize output parameters
        if (pmdAddOn) 
            *pmdAddOn = mdMethodDefNil;
        if (pmdRemoveOn) 
            *pmdRemoveOn = mdMethodDefNil;
        if (pmdFire) 
            *pmdFire = mdMethodDefNil;

        IfFailGo( pMiniMd->FindMethodSemanticsHelper(ev, &hEnum) );
        while (HENUMInternal::EnumNext(&hEnum, (mdToken *)&ridCur))
        {
            pSemantics = pMiniMd->getMethodSemantics(ridCur);
            ulSemantics = pMiniMd->getSemanticOfMethodSemantics(pSemantics);
            tkMethod = TokenFromRid( pMiniMd->getMethodOfMethodSemantics(pSemantics), mdtMethodDef );
            switch (ulSemantics)
            {
            case msAddOn:
                if (pmdAddOn) *pmdAddOn = tkMethod;
                break;
            case msRemoveOn:
                if (pmdRemoveOn) *pmdRemoveOn = tkMethod;
                break;
            case msFire:
                if (pmdFire) *pmdFire = tkMethod;
                break;
            case msOther:
                if (cCurOtherMethod < cMax)
                    rmdOtherMethod[cCurOtherMethod] = tkMethod;
                cCurOtherMethod++;
                break;
            default:
                _ASSERTE(!"BadKind!");
            }
        }

        // set the output parameter
        if (pcOtherMethod)
            *pcOtherMethod = cCurOtherMethod;
    }

ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
    STOP_MD_PERF(GetEventProps);
    return hr;
} // STDAPI RegMeta::GetEventProps()


//*****************************************************************************
// given a method, return an array of event/property tokens for each accessor role
// it is defined to have
//*****************************************************************************
STDAPI RegMeta::EnumMethodSemantics(    // S_OK, S_FALSE, or error.
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration.
    mdToken     rEventProp[],           // [OUT] Put Event/Property here.
    ULONG       cMax,                   // [IN] Max properties to put.
    ULONG       *pcEventProp)           // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               ridEnd;
    ULONG               index;
    HENUMInternal       *pEnum = *ppmdEnum;
    MethodSemanticsRec  *pRec;

    LOG((LOGMD, "MD RegMeta::EnumMethodSemantics(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, mb, rEventProp, cMax, pcEventProp));
    START_MD_PERF();
    LOCKREAD();
    

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        // create the enumerator
        IfFailGo( HENUMInternal::CreateDynamicArrayEnum( -1, &pEnum) );
        
        // get the range of method rids given a typedef
        ridEnd = pMiniMd->getCountMethodSemantics();

        for (index = 1; index <= ridEnd; index++ )
        {
            pRec = pMiniMd->getMethodSemantics(index);
            if ( pMiniMd->getMethodOfMethodSemantics(pRec) ==  mb )
            {
                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, pMiniMd->getAssociationOfMethodSemantics(pRec) ) );
            }
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rEventProp, pcEventProp);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);

    
    STOP_MD_PERF(EnumMethodSemantics);
    return hr;
} // STDAPI RegMeta::EnumMethodSemantics()



//*****************************************************************************
// return the role flags for the method/propevent pair
//*****************************************************************************
STDAPI RegMeta::GetMethodSemantics(     // S_OK, S_FALSE, or error.
    mdMethodDef mb,                     // [IN] method token
    mdToken     tkEventProp,            // [IN] event/property token.
    DWORD       *pdwSemanticsFlags)     // [OUT] the role flags for the method/propevent pair
{
    HRESULT             hr = NOERROR;
    CMiniMdRW           *pMiniMd = &(m_pStgdb->m_MiniMd);
    MethodSemanticsRec *pRec;
    ULONG               ridCur;
    HENUMInternal       hEnum;

    LOG((LOGMD, "MD RegMeta::GetMethodSemantics(0x%08x, 0x%08x, 0x%08x)\n", 
        mb, tkEventProp, pdwSemanticsFlags));
    START_MD_PERF();
    LOCKREAD();
    
    _ASSERTE(TypeFromToken(mb) == mdtMethodDef);
    _ASSERTE( pdwSemanticsFlags );

    if ( !pMiniMd->IsSorted(TBL_MethodSemantics) )        
    {
        // MethodSemantics table is not sorted. We need to
        // grab the write lock since we can cause constant table or MethodSemantics table to be sorted.
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }

    *pdwSemanticsFlags = 0;
    memset(&hEnum, 0, sizeof(HENUMInternal));

    // loop through all methods assoicated with this tkEventProp
    IfFailGo( pMiniMd->FindMethodSemanticsHelper(tkEventProp, &hEnum) );
    while (HENUMInternal::EnumNext(&hEnum, (mdToken *)&ridCur))
    {
        pRec = pMiniMd->getMethodSemantics(ridCur);
        if ( pMiniMd->getMethodOfMethodSemantics(pRec) ==  mb )
        {
            // we findd the match
            *pdwSemanticsFlags = pMiniMd->getSemanticOfMethodSemantics(pRec);
            goto ErrExit;
        }
    }

    IfFailGo( CLDB_E_RECORD_NOTFOUND );

ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
    STOP_MD_PERF(GetMethodSemantics);
    return hr;
} // STDAPI RegMeta::GetMethodSemantics()



//*****************************************************************************
// return the class layout information
//*****************************************************************************
STDAPI RegMeta::GetClassLayout(
    mdTypeDef   td,                     // [IN] give typedef
    DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16
    COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array
    ULONG       cMax,                   // [IN] size of the array
    ULONG       *pcFieldOffset,         // [OUT] needed array size
    ULONG       *pulClassSize)          // [OUT] the size of the class
{
    HRESULT         hr = NOERROR;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
    ClassLayoutRec  *pRec;
    RID             ridClassLayout;
    int             bLayout=0;          // Was any layout information found?
    
    _ASSERTE(TypeFromToken(td) == mdtTypeDef);
    
    LOG((LOGMD, "MD RegMeta::GetClassLayout(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        td, pdwPackSize, rFieldOffset, cMax, pcFieldOffset, pulClassSize));
    START_MD_PERF();
    LOCKREAD();
    
    if ( !pMiniMd->IsSorted(TBL_ClassLayout) || !pMiniMd->IsSorted(TBL_FieldLayout))        
    {
        // ClassLayout table is not sorted. We need to
        // grab the write lock since we can cause ClassLayout table to be sorted.
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }

    ridClassLayout = pMiniMd->FindClassLayoutHelper(td);

    if (InvalidRid(ridClassLayout))
    {   // Nothing specified - return default values of 0.
        if ( pdwPackSize )
            *pdwPackSize = 0;
        if ( pulClassSize )
            *pulClassSize = 0;
    }
    else
    {
        pRec = pMiniMd->getClassLayout(RidFromToken(ridClassLayout));
        if ( pdwPackSize )
            *pdwPackSize = pMiniMd->getPackingSizeOfClassLayout(pRec);
        if ( pulClassSize )
            *pulClassSize = pMiniMd->getClassSizeOfClassLayout(pRec);
        bLayout = 1;
    }

    // fill the layout array
    if (rFieldOffset || pcFieldOffset)
    {
        ULONG       iFieldOffset = 0;
        ULONG       ridFieldStart;
        ULONG       ridFieldEnd;
        ULONG       ridFieldLayout;
        ULONG       ulOffset;
        TypeDefRec  *pTypeDefRec;
        FieldLayoutRec *pLayout2Rec;
        mdFieldDef  fd;

        // record for this typedef in TypeDef Table
        pTypeDefRec = pMiniMd->getTypeDef(RidFromToken(td));

        // find the starting and end field for this typedef
        ridFieldStart = pMiniMd->getFieldListOfTypeDef(pTypeDefRec);
        ridFieldEnd = pMiniMd->getEndFieldListOfTypeDef(pTypeDefRec);

        // loop through the field table

        for(; ridFieldStart < ridFieldEnd; ridFieldStart++)
        {
            // Calculate the field token.
            fd = TokenFromRid(pMiniMd->GetFieldRid(ridFieldStart), mdtFieldDef);

            // Calculate the FieldLayout rid for the current field.
            ridFieldLayout = pMiniMd->FindFieldLayoutHelper(fd);

            // Calculate the offset.
            if (InvalidRid(ridFieldLayout))
                ulOffset = -1;
            else
            {
                // get the FieldLayout record.
                pLayout2Rec = pMiniMd->getFieldLayout(ridFieldLayout);
                ulOffset = pMiniMd->getOffSetOfFieldLayout(pLayout2Rec);
                bLayout = 1;
            }

            // fill in the field layout if output buffer still has space.
            if (cMax > iFieldOffset && rFieldOffset)
            {
                rFieldOffset[iFieldOffset].ridOfField = fd;
                rFieldOffset[iFieldOffset].ulOffset = ulOffset;
            }

            // advance the index to the buffer.
            iFieldOffset++;
        }

        if (bLayout && pcFieldOffset)
            *pcFieldOffset = iFieldOffset;
    }

    if (!bLayout)
        hr = CLDB_E_RECORD_NOTFOUND;
    
//ErrExit:
    STOP_MD_PERF(GetClassLayout);
    return hr;
} // STDAPI RegMeta::GetClassLayout()



//*****************************************************************************
// return the native type of a field
//*****************************************************************************
STDAPI RegMeta::GetFieldMarshal(
    mdToken     tk,                     // [IN] given a field's memberdef
    PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field
    ULONG       *pcbNativeType)         // [OUT] the count of bytes of *ppvNativeType
{
    HRESULT         hr = NOERROR;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
    RID             rid;
    FieldMarshalRec *pFieldMarshalRec;


	_ASSERTE(ppvNativeType != NULL && pcbNativeType != NULL);

    LOG((LOGMD, "MD RegMeta::GetFieldMarshal(0x%08x, 0x%08x, 0x%08x)\n", 
        tk, ppvNativeType, pcbNativeType));
    START_MD_PERF();
    LOCKREAD();
    
    _ASSERTE(TypeFromToken(tk) == mdtParamDef || TypeFromToken(tk) == mdtFieldDef);

    if ( !pMiniMd->IsSorted(TBL_FieldMarshal) )        
    {
        // constant table is not sorted and clients need contant value output. We need to
        // grab the write lock since we can cause constant table to be sorted.
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }


    // find the row containing the marshal definition for tk
    rid = pMiniMd->FindFieldMarshalHelper(tk);
    if (InvalidRid(rid))
    {
        IfFailGo( CLDB_E_RECORD_NOTFOUND );
    }
    pFieldMarshalRec = pMiniMd->getFieldMarshal(rid);

    // get the native type 
    *ppvNativeType = pMiniMd->getNativeTypeOfFieldMarshal(pFieldMarshalRec, pcbNativeType);

ErrExit:
    STOP_MD_PERF(GetFieldMarshal);
    return hr;
} // STDAPI RegMeta::GetFieldMarshal()



//*****************************************************************************
// return the RVA and implflag for MethodDef or FieldDef token
//*****************************************************************************
STDAPI RegMeta::GetRVA(                 // S_OK or error.
    mdToken     tk,                     // Member for which to set offset
    ULONG       *pulCodeRVA,            // The offset
    DWORD       *pdwImplFlags)          // the implementation flags
{
    HRESULT     hr = NOERROR;
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);

    LOG((LOGMD, "MD RegMeta::GetRVA(0x%08x, 0x%08x, 0x%08x)\n", 
        tk, pulCodeRVA, pdwImplFlags));
    START_MD_PERF();
    LOCKREAD();
    
    _ASSERTE(TypeFromToken(tk) == mdtMethodDef || TypeFromToken(tk) == mdtFieldDef);

    if (TypeFromToken(tk) == mdtMethodDef)
    {
        // MethodDef token
        MethodRec *pMethodRec = pMiniMd->getMethod(RidFromToken(tk));

        if (pulCodeRVA)
        {
            *pulCodeRVA = pMiniMd->getRVAOfMethod(pMethodRec);
        }

        if (pdwImplFlags)
        {
            *pdwImplFlags = pMiniMd->getImplFlagsOfMethod(pMethodRec);
        }
    }
    else    // TypeFromToken(tk) == mdtFieldDef
    {
        // FieldDef token
        ULONG   iRecord;

        if ( !pMiniMd->IsSorted(TBL_FieldRVA) )        
        {
            // FieldRVA table is not sorted. We need to
            // grab the write lock since we can cause FieldRVA table to be sorted.
            //
            CONVERT_READ_TO_WRITE_LOCK();
        }


        iRecord = pMiniMd->FindFieldRVAHelper(tk);

        if (InvalidRid(iRecord))
        {
            if (pulCodeRVA)
                *pulCodeRVA = 0;
            IfFailGo( CLDB_E_RECORD_NOTFOUND );
        }

        FieldRVARec *pFieldRVARec = pMiniMd->getFieldRVA(iRecord);

        if (pulCodeRVA)
        {
            *pulCodeRVA = pMiniMd->getRVAOfFieldRVA(pFieldRVARec);
        }
        _ASSERTE(!pdwImplFlags);
    }
ErrExit:
    STOP_MD_PERF(GetRVA);
    return hr;
} // STDAPI RegMeta::GetRVA()



//*****************************************************************************
// Get the Action and Permissions blob for a given PermissionSet.
//*****************************************************************************
STDAPI RegMeta::GetPermissionSetProps(
    mdPermission pm,                    // [IN] the permission token.
    DWORD       *pdwAction,             // [OUT] CorDeclSecurity.
    void const  **ppvPermission,        // [OUT] permission blob.
    ULONG       *pcbPermission)         // [OUT] count of bytes of pvPermission.
{
    HRESULT             hr = S_OK;
    CMiniMdRW           *pMiniMd = &(m_pStgdb->m_MiniMd);
    DeclSecurityRec     *pRecord = pMiniMd->getDeclSecurity(RidFromToken(pm));


    LOG((LOGMD, "MD RegMeta::GetPermissionSetProps(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        pm, pdwAction, ppvPermission, pcbPermission));
    START_MD_PERF();
    LOCKREAD();
    
    _ASSERTE(TypeFromToken(pm) == mdtPermission && RidFromToken(pm));
    
    // If you want the BLOB, better get the BLOB size as well.
    _ASSERTE(!ppvPermission || pcbPermission);

    if (pdwAction)
        *pdwAction = pMiniMd->getActionOfDeclSecurity(pRecord);

    if (ppvPermission)
        *ppvPermission = pMiniMd->getPermissionSetOfDeclSecurity(pRecord, pcbPermission);

    
    STOP_MD_PERF(GetPermissionSetProps);
    return hr;
} // STDAPI RegMeta::GetPermissionSetProps()



//*****************************************************************************
// Given a signature token, get return a pointer to the signature to the caller.
//
//@FUTURE: for short term we have a problem where there is no way to get a 
// fixed up address for a blob and do Merge at the same time.  So we've created
// this dummy table called StandAloneSig which you hand out a rid for.  This
// makes finding the sig an extra indirection that is not required.  The 
// Model Compression save code needs to map the token into a byte offset in
// the heap.  Perhaps we can have another mdt* type to switch on the difference.
// But ultimately it has to simply be "pBlobHeapBase + RidFromToken(mdSig)".
//*****************************************************************************
STDAPI RegMeta::GetSigFromToken(        // S_OK or error.
    mdSignature mdSig,                  // [IN] Signature token.
    PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.
    ULONG       *pcbSig)                // [OUT] return size of signature.
{
    HRESULT         hr = NOERROR;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
    StandAloneSigRec *pRec;

    LOG((LOGMD, "MD RegMeta::GetSigFromToken(0x%08x, 0x%08x, 0x%08x)\n", 
        mdSig, ppvSig, pcbSig));
    START_MD_PERF();
    LOCKREAD();
    
    _ASSERTE(TypeFromToken(mdSig) == mdtSignature);
    _ASSERTE(ppvSig && pcbSig);

	pRec = pMiniMd->getStandAloneSig( RidFromToken(mdSig) );
    *ppvSig = pMiniMd->getSignatureOfStandAloneSig( pRec, pcbSig );

    
    STOP_MD_PERF(GetSigFromToken);
    return hr;
} // STDAPI RegMeta::GetSigFromToken()


//*******************************************************************************
// return the ModuleRef properties
//*******************************************************************************
STDAPI RegMeta::GetModuleRefProps(      // S_OK or error.
    mdModuleRef mur,                    // [IN] moduleref token.
    LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.
    ULONG       cchName,                // [IN] size of szName in wide characters.
    ULONG       *pchName)               // [OUT] actual count of characters in the name.
{
    HRESULT         hr = NOERROR;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
    ModuleRefRec    *pModuleRefRec;

    LOG((LOGMD, "MD RegMeta::GetModuleRefProps(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        mur, szName, cchName, pchName));
    START_MD_PERF();
    LOCKREAD();
    
	pModuleRefRec = pMiniMd->getModuleRef(RidFromToken(mur));

    _ASSERTE(TypeFromToken(mur) == mdtModuleRef);

    if (szName || pchName)
    {
        IfFailGo( pMiniMd->getNameOfModuleRef(pModuleRefRec, szName, cchName, pchName) );
    }

ErrExit:
    
    STOP_MD_PERF(GetModuleRefProps);
    return hr;
} // STDAPI RegMeta::GetModuleRefProps()



//*******************************************************************************
// enumerating through all of the ModuleRefs
//*******************************************************************************
STDAPI RegMeta::EnumModuleRefs(         // S_OK or error.
    HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.
    mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.
    ULONG       cMax,                   // [IN] max memberrefs to put.
    ULONG       *pcModuleRefs)          // [OUT] put # put here.
{
    HENUMInternal   **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT         hr = NOERROR;
    HENUMInternal   *pEnum;
    
    LOG((LOGMD, "MD RegMeta::EnumModuleRefs(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, rModuleRefs, cMax, pcModuleRefs));
    START_MD_PERF();
    LOCKREAD();


    if ( *ppmdEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        // create the enumerator
        IfFailGo( HENUMInternal::CreateSimpleEnum(
            mdtModuleRef, 
            1, 
            pMiniMd->getCountModuleRefs() + 1, 
            &pEnum) );
        
        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    else
    {
        pEnum = *ppmdEnum;
    }

    // we can only fill the minimun of what caller asked for or what we have left
    HENUMInternal::EnumWithCount(pEnum, cMax, rModuleRefs, pcModuleRefs);

ErrExit:

    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);

    
    STOP_MD_PERF(EnumModuleRefs);
    return hr;

} // STDAPI RegMeta::EnumModuleRefs()


//*******************************************************************************
// return properties regarding a TypeSpec
//*******************************************************************************
STDAPI RegMeta::GetTypeSpecFromToken(   // S_OK or error.
    mdTypeSpec typespec,                // [IN] Signature token.
    PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.
    ULONG       *pcbSig)                // [OUT] return size of signature.
{
    CMiniMdRW           *pMiniMd = &(m_pStgdb->m_MiniMd);
    HRESULT             hr = NOERROR;

    LOG((LOGMD, "MD RegMeta::GetTypeSpecFromToken(0x%08x, 0x%08x, 0x%08x)\n", 
        typespec, ppvSig, pcbSig));
    START_MD_PERF();
    LOCKREAD();
    
    _ASSERTE(TypeFromToken(typespec) == mdtTypeSpec);
    _ASSERTE(ppvSig && pcbSig);

    TypeSpecRec *pRec = pMiniMd->getTypeSpec( RidFromToken(typespec) );
    *ppvSig = pMiniMd->getSignatureOfTypeSpec( pRec, pcbSig );

    
    STOP_MD_PERF(GetTypeSpecFromToken);
    return hr;
} // STDAPI RegMeta::GetTypeSpecFromToken()


//*****************************************************************************
// For those items that have a name, retrieve a direct pointer to the name
// off of the heap.  This reduces copies made for the caller.
//*****************************************************************************
#define NAME_FROM_TOKEN_TYPE(RecType, TokenType) \
        case mdt ## TokenType: \
        { \
            RecType ## Rec  *pRecord; \
            pRecord = pMiniMd->get ## RecType (RidFromToken(tk)); \
            *pszUtf8NamePtr = pMiniMd->getNameOf ## RecType (pRecord); \
        } \
        break;
#define NAME_FROM_TOKEN(RecType) NAME_FROM_TOKEN_TYPE(RecType, RecType)

STDAPI RegMeta::GetNameFromToken(       // S_OK or error.
    mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
    MDUTF8CSTR  *pszUtf8NamePtr)        // [OUT] Return pointer to UTF8 name in heap.
{
    HRESULT     hr = S_OK;

    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);

    LOG((LOGMD, "MD RegMeta::GetNameFromToken(0x%08x, 0x%08x)\n", 
        tk, pszUtf8NamePtr));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(pszUtf8NamePtr);

    switch (TypeFromToken(tk))
    {
        NAME_FROM_TOKEN(Module);
        NAME_FROM_TOKEN(TypeRef);
        NAME_FROM_TOKEN(TypeDef);
        NAME_FROM_TOKEN_TYPE(Field, FieldDef);
        NAME_FROM_TOKEN_TYPE(Method, MethodDef);
        NAME_FROM_TOKEN_TYPE(Param, ParamDef);
        NAME_FROM_TOKEN(MemberRef);
        NAME_FROM_TOKEN(Event);
        NAME_FROM_TOKEN(Property);
        NAME_FROM_TOKEN(ModuleRef);

        default:
        hr = E_INVALIDARG;
    }
    
    STOP_MD_PERF(GetNameFromToken);
    return (hr);
} // STDAPI RegMeta::GetNameFromToken()


//*****************************************************************************
// Get the symbol binding data back from the module if it is there.  It is
// stored as a custom value.
//*****************************************************************************
STDAPI RegMeta::GetSymbolBindingPath(   // S_OK or error.
    GUID        *pFormatID,             // [OUT] Symbol data format ID.
    LPWSTR      szSymbolDataPath,       // [OUT] Path of symbols.
    ULONG       cchSymbolDataPath,      // [IN] Max characters for output buffer.
    ULONG       *pcbSymbolDataPath)     // [OUT] Number of chars in actual name.
{
    CORDBG_SYMBOL_URL *pSymbol;         // Working pointer.
    mdToken     tokModule;              // Token for the module.
    ULONG       cbLen;                  // Raw byte size of data item.
    HRESULT     hr;

    LOG((LOGMD, "MD RegMeta::GetSymbolBindingPath(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        pFormatID, szSymbolDataPath, cchSymbolDataPath, pcbSymbolDataPath));
    START_MD_PERF();

    // Otherwise, what was the point?
    _ASSERTE(pFormatID || szSymbolDataPath);

    // No need to lock this function. Since it is calling public functions. Keep it that way!

    // Get the token for the module, then find the item if present.
    IfFailGo(GetModuleFromScope(&tokModule));
    IfFailGo(GetCustomAttributeByName(tokModule, SZ_CORDBG_SYMBOL_URL, (const void**)&pSymbol, &cbLen));
    if (hr == S_FALSE)
        IfFailGo(CLDB_E_RECORD_NOTFOUND);
    
    // Copy out the data asked for.
    if (pFormatID)
        *pFormatID = pSymbol->FormatID;
    if (szSymbolDataPath && cchSymbolDataPath)
    {
        wcsncpy(szSymbolDataPath, pSymbol->rcName, cchSymbolDataPath);
        szSymbolDataPath[cchSymbolDataPath - 1] = 0;
        if (pcbSymbolDataPath)
            *pcbSymbolDataPath = (ULONG)wcslen(pSymbol->rcName);
    }

ErrExit:
    STOP_MD_PERF(GetSymbolBindingPath);
    return (hr);
} // RegMeta::GetSymbolBindingPath



//*****************************************************************************
// Get the symbol binding data back from the module if it is there.  It is
// stored as a custom value.
//*****************************************************************************
STDAPI RegMeta::EnumUnresolvedMethods(  // S_OK or error.
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
    ULONG       cMax,                   // [IN] Max MemberDefs to put.  
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    ULONG               iCountTypeDef;
    ULONG               ulStart, ulEnd;
    ULONG               index;
    ULONG               indexTypeDef;
    HENUMInternal       *pEnum = *ppmdEnum;
    CMiniMdRW           *pMiniMd = &(m_pStgdb->m_MiniMd);

    LOG((LOGMD, "MD RegMeta::EnumUnresolvedMethods(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        phEnum, rMethods, cMax, pcTokens));
    START_MD_PERF();

    // take the write lock. Because we should have not have two EnumUnresolvedMethods being called at the
    // same time. Ref to Def map may be calculated incorrectly.
    LOCKWRITE();

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        MethodRec       *pMethodRec;
        TypeDefRec      *pTypeDefRec;

        // make sure our ref to def optimization is up to date
        IfFailGo( RefToDefOptimization() );
        IfFailGo( HENUMInternal::CreateDynamicArrayEnum( -1, &pEnum) );

        // Loop through all of the methoddef except global functions.
        // If methoddef has RVA 0 and not miRuntime, mdAbstract, mdVirtual, mdNative, 
        // we will fill it into the enumerator.
        //
        iCountTypeDef = pMiniMd->getCountTypeDefs();

        for (indexTypeDef = 2; indexTypeDef <= iCountTypeDef; indexTypeDef ++ )
        {
            pTypeDefRec = pMiniMd->getTypeDef(indexTypeDef);
            
            if (IsTdInterface(pTypeDefRec->m_Flags))
            {
                // don't bother to check if type is marked as interface or abstract
                continue;
            }

            ulStart = pMiniMd->getMethodListOfTypeDef(pTypeDefRec);
            ulEnd = pMiniMd->getEndMethodListOfTypeDef(pTypeDefRec);

            // always report errors even with any unimplemented methods
            for (index = ulStart; index < ulEnd; index++)
            {
                pMethodRec = pMiniMd->getMethod(pMiniMd->GetMethodRid(index));
                if ( IsMiForwardRef(pMethodRec->m_ImplFlags) )
                {
                    if ( IsMdPinvokeImpl(pMethodRec->m_Flags) ) 
                    {
                        continue;
                    }
                    if ( IsMiRuntime(pMethodRec->m_ImplFlags) || IsMiInternalCall(pMethodRec->m_ImplFlags))
                    {
                        continue;
                    }

                    if (IsMdAbstract(pMethodRec->m_Flags))
                        continue;

                    // If a methoddef has RVA 0 and it is not an abstract or virtual method.
                    // Nor it is a runtime generated method nore a native method, then we add it
                    // to the unresolved list.
                    //
                    IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(pMiniMd->GetMethodRid(index), mdtMethodDef) ) );

                    LOG((LOGMD, "MD   adding unresolved MethodDef:  token=%08x, flags=%08x, impl flags=%08x\n", 
                        TokenFromRid(pMiniMd->GetMethodRid(index), mdtMethodDef),
                        pMethodRec->m_Flags, pMethodRec->m_ImplFlags));
                }
            }
        }

        MemberRefRec    *pMemberRefRec;
        ULONG           iCount;

        // loop through MemberRef tables and find all of the unsats
        iCount = pMiniMd->getCountMemberRefs();
        for (index = 1; index <= iCount; index++ )
        {
            mdToken     defToken;
            mdMemberRef refToken = TokenFromRid(index, mdtMemberRef);
            pMemberRefRec = pMiniMd->getMemberRef(index);
            pMiniMd->GetTokenRemapManager()->ResolveRefToDef(refToken, &defToken);

            if ( pMiniMd->getClassOfMemberRef(pMemberRefRec) == m_tdModule && defToken == refToken )
            {
                // unresovled externals reference if parent token is not resolved and this ref token does not
                // map to any def token (can be MethodDef or FieldDef).
                //
                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, refToken) );

                LOG((LOGMD, "MD   adding unresolved MemberRef:  token=%08x, doesn't have a proper parent\n", 
                    refToken ));
            }
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rMethods, pcTokens);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumUnresolvedMethods);
    return hr;
} // HRESULT RegMeta::EnumUnresolvedMethods()

//*****************************************************************************
// Return the User string given the token.  The offset into the Blob pool where
// the string is stored in UNICODE is embedded inside the token.
//*****************************************************************************
STDAPI RegMeta::GetUserString(          // S_OK or error.
    mdString    stk,                    // [IN] String token.
    LPWSTR      szString,               // [OUT] Copy of string.
    ULONG       cchString,              // [IN] Max chars of room in szString.
    ULONG       *pchString)             // [OUT] How many chars in actual string.
{
    void        *pvString;              // Pointer to the string data.
    ULONG       cbString;               // Size of string data, bytes.
    ULONG       cbDummy;                // For null out pointer.
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::GetUserString(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        stk, szString, cchString, pchString));
    START_MD_PERF();
    LOCKREAD();

    // Get the string data.
    pvString = m_pStgdb->m_MiniMd.GetUserString(RidFromToken(stk), &cbString);
    // Want to get whole characters, followed by byte to indicate whether there
    // are extended characters (>= 0x80).
    _ASSERTE((cbString % sizeof(WCHAR)) == 1);
    // Strip off the last byte.
    cbString--;

    // Convert bytes to characters.
    if (!pchString)
        pchString = &cbDummy;
    *pchString = cbString / sizeof(WCHAR);

    // Copy the string back to the caller.
    if (szString && cchString)
    {
        cchString *= sizeof(WCHAR);
        memcpy(szString, pvString, min(cbString, cchString));
        if (cchString < cbString) 
            hr = CLDB_S_TRUNCATION;
    }

    
    STOP_MD_PERF(GetUserString);
    return (hr);
} // HRESULT RegMeta::GetUserString()

//*****************************************************************************
// Return contents of Pinvoke given the forwarded member token.
//***************************************************************************** 
STDAPI RegMeta::GetPinvokeMap(          // S_OK or error.
    mdToken     tk,                     // [IN] FieldDef or MethodDef.
    DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
    LPWSTR      szImportName,           // [OUT] Import name.
    ULONG       cchImportName,          // [IN] Size of the name buffer.
    ULONG       *pchImportName,         // [OUT] Actual number of characters stored.
    mdModuleRef *pmrImportDLL)          // [OUT] ModuleRef token for the target DLL.
{
    HRESULT     hr = S_OK;
    ImplMapRec  *pRecord;
    ULONG       iRecord;

    LOG((LOGMD, "MD RegMeta::GetPinvokeMap(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        tk, pdwMappingFlags, szImportName, cchImportName, pchImportName, pmrImportDLL));
    START_MD_PERF();
    LOCKREAD();

    if ( m_pStgdb->m_MiniMd.IsSorted(TBL_ImplMap) )        
    {
        // ImplMap table is not sorted. We need to
        // grab the write lock since we can cause ImplMap table to be sorted.
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }

    _ASSERTE(TypeFromToken(tk) == mdtFieldDef ||
             TypeFromToken(tk) == mdtMethodDef);

    iRecord = m_pStgdb->m_MiniMd.FindImplMapHelper(tk);
    if (InvalidRid(iRecord))
    {
        IfFailGo( CLDB_E_RECORD_NOTFOUND );
    }
    else
        pRecord = m_pStgdb->m_MiniMd.getImplMap(iRecord);

    if (pdwMappingFlags)
        *pdwMappingFlags = m_pStgdb->m_MiniMd.getMappingFlagsOfImplMap(pRecord);
    if (szImportName || pchImportName)
        IfFailGo(m_pStgdb->m_MiniMd.getImportNameOfImplMap(pRecord, szImportName, cchImportName, pchImportName));
    if (pmrImportDLL)
        *pmrImportDLL = m_pStgdb->m_MiniMd.getImportScopeOfImplMap(pRecord);
ErrExit:
    STOP_MD_PERF(GetPinvokeMap);
    return hr;
} // HRESULT RegMeta::GetPinvokeMap()

//*****************************************************************************
// Enumerate through all the local sigs.
//*****************************************************************************
STDAPI RegMeta::EnumSignatures(         // S_OK or error.
    HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
    mdModuleRef rSignatures[],          // [OUT] put signatures here.   
    ULONG       cmax,                   // [IN] max signatures to put.  
    ULONG       *pcSignatures)          // [OUT] put # put here.
{
    HENUMInternal   **ppsigEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT         hr = NOERROR;
    HENUMInternal   *pEnum;

    LOG((LOGMD, "MD RegMeta::EnumSignatures(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
        phEnum, rSignatures, cmax, pcSignatures));
    START_MD_PERF();
    LOCKREAD();

    if (*ppsigEnum == 0)
    {
        // instantiating a new ENUM
        CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);

        // create the enumerator.
        IfFailGo( HENUMInternal::CreateSimpleEnum(
            mdtSignature,
            1,
            pMiniMd->getCountStandAloneSigs() + 1,
            &pEnum) );

        // set the output parameter
        *ppsigEnum = pEnum;
    }
    else
        pEnum = *ppsigEnum;

    // we can only fill the minimum of what caller asked for or what we have left.
    HENUMInternal::EnumWithCount(pEnum, cmax, rSignatures, pcSignatures);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppsigEnum);
    
    STOP_MD_PERF(EnumSignatures);
    return hr;
}   // RegMeta::EnumSignatures



//*****************************************************************************
// Enumerate through all the TypeSpec
//*****************************************************************************
STDAPI RegMeta::EnumTypeSpecs(          // S_OK or error.
    HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
    mdTypeSpec  rTypeSpecs[],           // [OUT] put TypeSpecs here.   
    ULONG       cmax,                   // [IN] max TypeSpecs to put.  
    ULONG       *pcTypeSpecs)           // [OUT] put # put here.
{
    HENUMInternal   **ppEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT         hr = NOERROR;
    HENUMInternal   *pEnum;

    LOG((LOGMD, "MD RegMeta::EnumTypeSpecs(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
        phEnum, rTypeSpecs, cmax, pcTypeSpecs));
    START_MD_PERF();
    LOCKREAD();

    if (*ppEnum == 0)
    {
        // instantiating a new ENUM
        CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);

        // create the enumerator.
        IfFailGo( HENUMInternal::CreateSimpleEnum(
            mdtTypeSpec,
            1,
            pMiniMd->getCountTypeSpecs() + 1,
            &pEnum) );

        // set the output parameter
        *ppEnum = pEnum;
    }
    else
        pEnum = *ppEnum;

    // we can only fill the minimum of what caller asked for or what we have left.
    HENUMInternal::EnumWithCount(pEnum, cmax, rTypeSpecs, pcTypeSpecs);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppEnum);
    
    STOP_MD_PERF(EnumTypeSpecs);
    return hr;
}   // RegMeta::EnumTypeSpecs


//*****************************************************************************
// Enumerate through all the User Strings.
//*****************************************************************************
STDAPI RegMeta::EnumUserStrings(        // S_OK or error.
    HCORENUM    *phEnum,                // [IN/OUT] pointer to the enum.
    mdString    rStrings[],             // [OUT] put Strings here.
    ULONG       cmax,                   // [IN] max Strings to put.
    ULONG       *pcStrings)             // [OUT] put # put here.
{
    HENUMInternal   **ppEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT         hr = NOERROR;
    HENUMInternal   *pEnum = *ppEnum;
    ULONG           ulOffset = 0;
    ULONG           ulNext;
    ULONG           cbBlob;

    LOG((LOGMD, "MD RegMeta::EnumUserStrings(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
        phEnum, rStrings, cmax, pcStrings));
    START_MD_PERF();
    LOCKREAD();

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM.
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
        IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtString, &pEnum) );

        // Add all strings to the dynamic array.
         while (ulOffset != -1)
        {
            pMiniMd->GetUserStringNext(ulOffset, &cbBlob, &ulNext);
            // Skip over padding.
            if (!cbBlob)
            {
                ulOffset = ulNext;
                continue;
            }
            IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(ulOffset, mdtString) ) );
            ulOffset = ulNext;
        }

        // set the output parameter.
        *ppEnum = pEnum;
    }

    // fill the output token buffer.
    hr = HENUMInternal::EnumWithCount(pEnum, cmax, rStrings, pcStrings);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppEnum);

    
    STOP_MD_PERF(EnumUserStrings);
	return hr;
}	// RegMeta::EnumUserStrings


//*****************************************************************************
// This routine gets the param token given a method and index of the parameter.
//*****************************************************************************
STDAPI RegMeta::GetParamForMethodIndex( // S_OK or error.
    mdMethodDef md,                     // [IN] Method token.
    ULONG       ulParamSeq,             // [IN] Parameter sequence.
    mdParamDef  *ppd)                   // [IN] Put Param token here.
{
    HRESULT     hr = S_OK;

    LOG((LOGMD, "MD RegMeta::GetParamForMethodIndex(0x%08x, 0x%08x, 0x%08x)\n", 
        md, ulParamSeq, ppd));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(TypeFromToken(md) == mdtMethodDef && RidFromToken(md) &&
             ulParamSeq != ULONG_MAX && ppd);

    IfFailGo(_FindParamOfMethod(md, ulParamSeq, ppd));
ErrExit:
    
    STOP_MD_PERF(GetParamForMethodIndex);
    return hr;
}   // RegMeta::GetParamForMethodIndex()

//*****************************************************************************
// Return the property of a MethodDef or a FieldDef
//*****************************************************************************
HRESULT RegMeta::GetMemberProps(
    mdToken     mb,                     // The member for which to get props.   
    mdTypeDef   *pClass,                // Put member's class here. 
    LPWSTR      szMember,               // Put member's name here.  
    ULONG       cchMember,              // Size of szMember buffer in wide chars.   
    ULONG       *pchMember,             // Put actual size here 
    DWORD       *pdwAttr,               // Put flags here.  
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
    ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
    ULONG       *pulCodeRVA,            // [OUT] codeRVA    
    DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
    DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
    void const  **ppValue,              // [OUT] constant value 
    ULONG       *pchValue)              // [OUT] size of constant value, string only, wide chars
{
    HRESULT         hr = NOERROR;

    LOG((LOGMD, "MD RegMeta::GetMemberProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        mb, pClass, szMember, cchMember, pchMember, pdwAttr, ppvSigBlob, pcbSigBlob, 
        pulCodeRVA, pdwImplFlags, pdwCPlusTypeFlag, ppValue, pchValue));
    START_MD_PERF();

    _ASSERTE(TypeFromToken(mb) == mdtMethodDef || TypeFromToken(mb) == mdtFieldDef);

    // No need to lock this function. It is calling public APIs. Keep it that way.

    if (TypeFromToken(mb) == mdtMethodDef)
    {
        // It is a Method
        IfFailGo( GetMethodProps(
            mb, 
            pClass, 
            szMember, 
            cchMember, 
            pchMember, 
            pdwAttr,
            ppvSigBlob, 
            pcbSigBlob, 
            pulCodeRVA, 
            pdwImplFlags) );
    }
    else
    {
        // It is a Field
        IfFailGo( GetFieldProps(
            mb, 
            pClass, 
            szMember, 
            cchMember, 
            pchMember, 
            pdwAttr,
            ppvSigBlob, 
            pcbSigBlob, 
            pdwCPlusTypeFlag, 
            ppValue,
			pchValue) );
    }
ErrExit:
    STOP_MD_PERF(GetMemberProps);
    return hr;
} // HRESULT RegMeta::GetMemberProps()

//*****************************************************************************
// Return the property of a FieldDef
//*****************************************************************************
HRESULT RegMeta::GetFieldProps(  
    mdFieldDef  fd,                     // The field for which to get props.    
    mdTypeDef   *pClass,                // Put field's class here.  
    LPWSTR      szField,                // Put field's name here.   
    ULONG       cchField,               // Size of szField buffer in wide chars.    
    ULONG       *pchField,              // Put actual size here 
    DWORD       *pdwAttr,               // Put flags here.  
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
    ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
    DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
    void const  **ppValue,              // [OUT] constant value 
    ULONG       *pchValue)              // [OUT] size of constant value, string only, wide chars
{
    HRESULT         hr = NOERROR;
    FieldRec        *pFieldRec;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

    LOG((LOGMD, "MD RegMeta::GetFieldProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        fd, pClass, szField, cchField, pchField, pdwAttr, ppvSigBlob, pcbSigBlob, pdwCPlusTypeFlag, 
        ppValue, pchValue));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(TypeFromToken(fd) == mdtFieldDef);
    
    if ( (!pMiniMd->IsSorted(TBL_Constant) && ( pdwCPlusTypeFlag || ppValue) )  ||
         (pClass && !pMiniMd->IsParentTableOfFieldValid() ))
    {
        // constant table is not sorted and clients need contant value output. Or the parent table for 
        // field table is not built yet but our clients want the parent. We need to
        // grab the write lock since we can cause constant table to be sorted.
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }


    pFieldRec = pMiniMd->getField(RidFromToken(fd));
    
    if (szField || pchField)
    {
        IfFailGo( pMiniMd->getNameOfField(pFieldRec, szField, cchField, pchField) );
    }

    if (pClass)
    {
        // caller wants parent typedef
        IfFailGo( pMiniMd->FindParentOfFieldHelper(fd, pClass) );

        if ( IsGlobalMethodParentToken(*pClass) )
        {
            // If the parent of Field is the <Module>, return mdTypeDefNil instead.
            *pClass = mdTypeDefNil;
        }
    }
    if (ppvSigBlob || pcbSigBlob)
    {   
        // caller wants signature information
        PCCOR_SIGNATURE pvSigTmp;
        ULONG           cbSig;
        pvSigTmp = pMiniMd->getSignatureOfField(pFieldRec, &cbSig);
        if ( ppvSigBlob )
            *ppvSigBlob = pvSigTmp;
        if ( pcbSigBlob)
            *pcbSigBlob = cbSig;                
    }
    if ( pdwAttr )
    {
        *pdwAttr = pMiniMd->getFlagsOfField(pFieldRec);
    }
    if ( pdwCPlusTypeFlag || ppValue || pchValue)
    {
        // get the constant value
        ULONG   cbValue;
        RID     rid = pMiniMd->FindConstantHelper(fd);

        if (pchValue)
            *pchValue = 0;
        
        if (InvalidRid(rid))
        {
            // There is no constant value associate with it
            if (pdwCPlusTypeFlag)
                *pdwCPlusTypeFlag = ELEMENT_TYPE_VOID;
            
            if ( ppValue )
                *ppValue = NULL;
        }
        else
        {
            ConstantRec *pConstantRec = m_pStgdb->m_MiniMd.getConstant(rid);
			DWORD dwType;

            // get the type of constant value
			dwType = pMiniMd->getTypeOfConstant(pConstantRec);
            if ( pdwCPlusTypeFlag )
                *pdwCPlusTypeFlag = dwType;

            // get the value blob
            if (ppValue)
			{
                *ppValue = pMiniMd->getValueOfConstant(pConstantRec, &cbValue);
				if (pchValue && dwType == ELEMENT_TYPE_STRING)
					*pchValue = cbValue / sizeof(WCHAR);
			}
        }
    }

ErrExit:
    STOP_MD_PERF(GetFieldProps);
    return hr;
} // HRESULT RegMeta::GetFieldProps()

//*****************************************************************************
// return the properties of a property token
//*****************************************************************************
HRESULT RegMeta::GetPropertyProps(      // S_OK, S_FALSE, or error. 
    mdProperty  prop,                   // [IN] property token  
    mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
    LPCWSTR     szProperty,             // [OUT] Property name  
    ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
    ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
    DWORD       *pdwPropFlags,          // [OUT] property flags.    
    PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
    ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
    DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
    void const  **ppDefaultValue,       // [OUT] constant value 
    ULONG       *pchDefaultValue,       // [OUT] size of constant value, string only, wide chars
    mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
    mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
    mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
    ULONG       cMax,                   // [IN] size of rmdOtherMethod  
    ULONG       *pcOtherMethod)         // [OUT] total number of other method of this property  
{
    HRESULT         hr = NOERROR;
    CMiniMdRW       *pMiniMd;
    PropertyRec     *pRec;
    HENUMInternal   hEnum;

    LOG((LOGMD, "MD RegMeta::GetPropertyProps(0x%08x, 0x%08x, %S, 0x%08x, 0x%08x, "
                "0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, "
                "0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, "
                "0x%08x)\n", 
                prop, pClass, MDSTR(szProperty),  cchProperty, pchProperty,
                pdwPropFlags, ppvSig, pbSig, pdwCPlusTypeFlag, ppDefaultValue,
                pchDefaultValue, pmdSetter, pmdGetter, rmdOtherMethod, cMax,
                pcOtherMethod));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(TypeFromToken(prop) == mdtProperty);

    pMiniMd = &(m_pStgdb->m_MiniMd);

    if ( (!pMiniMd->IsSorted(TBL_Constant) || !pMiniMd->IsSorted(TBL_MethodSemantics) )  ||
         (pClass && !pMiniMd->IsParentTableOfPropertyValid() ))
    {
        // constant table or MethodSemantics table is not sorted. We need to
        // grab the write lock since we can cause constant table or MethodSemantics table to be sorted.
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }

    memset(&hEnum, 0, sizeof(HENUMInternal));
    pRec = pMiniMd->getProperty( RidFromToken(prop) );

    if ( pClass )
    {
        // find the property map entry corresponding to this property
        IfFailGo( pMiniMd->FindParentOfPropertyHelper( prop, pClass) );
    }
    if (szProperty || pchProperty)
    {
        IfFailGo( pMiniMd->getNameOfProperty(pRec, (LPWSTR) szProperty, cchProperty, pchProperty) );
    }
    if ( pdwPropFlags )
    {
        *pdwPropFlags = pMiniMd->getPropFlagsOfProperty(pRec);
    }
    if ( ppvSig || pbSig )
    {
        // caller wants the signature
        //
        ULONG               cbSig;
        PCCOR_SIGNATURE     pvSig;
        pvSig = pMiniMd->getTypeOfProperty(pRec, &cbSig);
        if ( ppvSig )
        {
            *ppvSig = pvSig;
        }
        if ( pbSig ) 
        {
            *pbSig = cbSig;
        }
    }
    if ( pdwCPlusTypeFlag || ppDefaultValue || pchDefaultValue)
    {
        // get the constant value
        ULONG   cbValue;
        RID     rid = pMiniMd->FindConstantHelper(prop);

        if (pchDefaultValue)
            *pchDefaultValue = 0;
        
        if (InvalidRid(rid))
        {
            // There is no constant value associate with it
            if (pdwCPlusTypeFlag)
                *pdwCPlusTypeFlag = ELEMENT_TYPE_VOID;
            
            if ( ppDefaultValue )
                *ppDefaultValue = NULL;
        }
        else
        {
            ConstantRec *pConstantRec = m_pStgdb->m_MiniMd.getConstant(rid);
			DWORD dwType;

            // get the type of constant value
			dwType = pMiniMd->getTypeOfConstant(pConstantRec);
            if ( pdwCPlusTypeFlag )
                *pdwCPlusTypeFlag = dwType;

            // get the value blob
            if (ppDefaultValue)
			{
                *ppDefaultValue = pMiniMd->getValueOfConstant(pConstantRec, &cbValue);
				if (pchDefaultValue && dwType == ELEMENT_TYPE_STRING)
					*pchDefaultValue = cbValue / sizeof(WCHAR);
			}
        }
    }
    {
        MethodSemanticsRec *pSemantics;
        RID         ridCur;
        ULONG       cCurOtherMethod = 0;
        ULONG       ulSemantics;
        mdMethodDef tkMethod;

        // initialize output parameters
        if (pmdSetter)
            *pmdSetter = mdMethodDefNil;
        if (pmdGetter)
            *pmdGetter = mdMethodDefNil;

        IfFailGo( pMiniMd->FindMethodSemanticsHelper(prop, &hEnum) );
        while (HENUMInternal::EnumNext(&hEnum, (mdToken *)&ridCur))
        {
            pSemantics = pMiniMd->getMethodSemantics(ridCur);
            ulSemantics = pMiniMd->getSemanticOfMethodSemantics(pSemantics);
            tkMethod = TokenFromRid( pMiniMd->getMethodOfMethodSemantics(pSemantics), mdtMethodDef );
            switch (ulSemantics)
            {
            case msSetter:
                if (pmdSetter) *pmdSetter = tkMethod;
                break;
            case msGetter:
                if (pmdGetter) *pmdGetter = tkMethod;
                break;
            case msOther:
                if (cCurOtherMethod < cMax)
                    rmdOtherMethod[cCurOtherMethod] = tkMethod;
                cCurOtherMethod ++;
                break;
            default:
                _ASSERTE(!"BadKind!");
            }
        }

        // set the output parameter
        if (pcOtherMethod)
            *pcOtherMethod = cCurOtherMethod;
    }

ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
    STOP_MD_PERF(GetPropertyProps);
    return hr;
} // HRESULT RegMeta::GetPropertyProps()

//*****************************************************************************
// This routine gets the properties for the given Param token.
//*****************************************************************************
HRESULT RegMeta::GetParamProps(         // S_OK or error.
    mdParamDef  pd,                     // [IN]The Parameter.
    mdMethodDef *pmd,                   // [OUT] Parent Method token.
    ULONG       *pulSequence,           // [OUT] Parameter sequence.
    LPWSTR      szName,                 // [OUT] Put name here.
    ULONG       cchName,                // [OUT] Size of name buffer.
    ULONG       *pchName,               // [OUT] Put actual size of name here.
    DWORD       *pdwAttr,               // [OUT] Put flags here.
    DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
    void const  **ppValue,              // [OUT] Constant value.
    ULONG       *pchValue)              // [OUT] size of constant value, string only, wide chars
{
    HRESULT         hr = NOERROR;
    ParamRec        *pParamRec;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

    LOG((LOGMD, "MD RegMeta::GetParamProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
        pd, pmd, pulSequence, szName, cchName, pchName, pdwAttr, pdwCPlusTypeFlag, ppValue, pchValue));
    START_MD_PERF();
    LOCKREAD();

    if ( (!pMiniMd->IsSorted(TBL_Constant) && ( pdwCPlusTypeFlag || ppValue) ) ||
         ( pmd && !pMiniMd->IsParentTableOfParamValid() ))
    {
        // constant table is not sorted and clients need contant value output. We need to
        // grab the write lock since we can cause constant table to be sorted.
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }


    _ASSERTE(TypeFromToken(pd) == mdtParamDef && RidFromToken(pd));
    

    pParamRec = pMiniMd->getParam(RidFromToken(pd));

    if (pmd)
    {
        IfFailGo(pMiniMd->FindParentOfParamHelper(pd, pmd));
        _ASSERTE(TypeFromToken(*pmd) == mdtMethodDef);
    }
    if (pulSequence)
        *pulSequence = pMiniMd->getSequenceOfParam(pParamRec);
    if (szName || pchName)
        IfFailGo( pMiniMd->getNameOfParam(pParamRec, szName, cchName, pchName) );
    if (pdwAttr)
    {
        *pdwAttr = pMiniMd->getFlagsOfParam(pParamRec);
    }
    if ( pdwCPlusTypeFlag || ppValue || pchValue)
    {
        // get the constant value
        ULONG   cbValue;
        RID     rid = pMiniMd->FindConstantHelper(pd);

        if (pchValue)
            *pchValue = 0;

        if (InvalidRid(rid))
        {
            // There is no constant value associate with it
            if (pdwCPlusTypeFlag)
                *pdwCPlusTypeFlag = ELEMENT_TYPE_VOID;
            
            if ( ppValue )
                *ppValue = NULL;
        }
        else
        {
            ConstantRec *pConstantRec = m_pStgdb->m_MiniMd.getConstant(rid);
			DWORD dwType;

            // get the type of constant value
			dwType = pMiniMd->getTypeOfConstant(pConstantRec);
            if ( pdwCPlusTypeFlag )
                *pdwCPlusTypeFlag = dwType;

            // get the value blob
            if (ppValue)
			{
                *ppValue = pMiniMd->getValueOfConstant(pConstantRec, &cbValue);
				if (pchValue && dwType == ELEMENT_TYPE_STRING)
					*pchValue = cbValue / sizeof(WCHAR);
			}
        }
    }

ErrExit:
    STOP_MD_PERF(GetParamProps);
    return hr;
} // HRESULT RegMeta::GetParamProps()

//*****************************************************************************
// This routine gets the parent class for the nested class.
//*****************************************************************************
HRESULT RegMeta::GetNestedClassProps(   // S_OK or error.
    mdTypeDef   tdNestedClass,          // [IN] NestedClass token.
    mdTypeDef   *ptdEnclosingClass)     // [OUT] EnclosingClass token.
{
    HRESULT         hr = NOERROR;
    NestedClassRec  *pRecord;
    ULONG           iRecord;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);


    LOG((LOGMD, "MD RegMeta::GetNestedClassProps(0x%08x, 0x%08x)\n", 
        tdNestedClass, ptdEnclosingClass));
    START_MD_PERF();
    LOCKREAD();

    if ( !pMiniMd->IsSorted(TBL_NestedClass) )        
    {
        // NestedClass table is not sorted. We need to
        // grab the write lock since we can cause NestedClass table to be sorted.
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }

    _ASSERTE(TypeFromToken(tdNestedClass) && !IsNilToken(tdNestedClass) && ptdEnclosingClass);

    iRecord = pMiniMd->FindNestedClassHelper(tdNestedClass);

    if (InvalidRid(iRecord))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }

    pRecord = pMiniMd->getNestedClass(iRecord);

    _ASSERTE(tdNestedClass == pMiniMd->getNestedClassOfNestedClass(pRecord));
    *ptdEnclosingClass = pMiniMd->getEnclosingClassOfNestedClass(pRecord);

ErrExit:
    STOP_MD_PERF(GetNestedClassProps);
    return hr;
} // HRESULT RegMeta::GetNestedClassProps()

//*****************************************************************************
// Given a signature, parse it for custom modifier with calling convention.
//*****************************************************************************
HRESULT RegMeta::GetNativeCallConvFromSig( // S_OK or error.
    void const  *pvSig,                 // [IN] Pointer to signature.
    ULONG       cbSig,                  // [IN] Count of signature bytes.
    ULONG       *pCallConv)             // [OUT] Put calling conv here (see CorPinvokemap).                                                                                        
{
    HRESULT     hr = NOERROR;
    PCCOR_SIGNATURE pvSigBlob = reinterpret_cast<PCCOR_SIGNATURE>(pvSig);
    ULONG       cbTotal = 0;            // total of number bytes for return type + all fixed arguments
    ULONG       cbCur = 0;              // index through the pvSigBlob
    ULONG       cb;
    ULONG       cArg;
    ULONG       callingconv;
    ULONG       cArgsIndex;
    ULONG       callConv = pmCallConvWinapi;  // The calling convention.

    *pCallConv = pmCallConvWinapi;

    // remember the number of bytes to represent the calling convention
    cb = CorSigUncompressData (pvSigBlob, &callingconv);
    cbCur += cb;

    // remember number of bytes to represent the arg counts
    cb= CorSigUncompressData (&pvSigBlob[cbCur], &cArg);
    cbCur += cb;

    // Look at the return type.
    hr = _SearchOneArgForCallConv( &pvSigBlob[cbCur], &cb, &callConv);
    if (hr == -1)
    {
        *pCallConv = callConv;
        hr = S_OK;
        goto ErrExit;
    }
    IfFailGo(hr);
    cbCur += cb;
    cbTotal += cb;
    
    // loop through argument until we found ELEMENT_TYPE_SENTINEL or run
    // out of arguments
    for (cArgsIndex = 0; cArgsIndex < cArg; cArgsIndex++)
    {
        _ASSERTE(cbCur < cbSig);
        hr = _SearchOneArgForCallConv( &pvSigBlob[cbCur], &cb, &callConv);
        if (hr == -1)
        {
            *pCallConv = callConv;
            hr = S_OK;
            goto ErrExit;
        }
        IfFailGo(hr);
        cbTotal += cb;
        cbCur += cb;
    }

ErrExit:
    return hr;
} // HRESULT RegMeta::GetNativeCallConvFromSig()

//*****************************************************************************
// Helper used by GetNativeCallingConvFromSig.
//*****************************************************************************
HRESULT RegMeta::_CheckCmodForCallConv( // S_OK, -1 if found, or error.                  
    PCCOR_SIGNATURE pbSig,              // [IN] Signature to check.                      
    ULONG       *pcbTotal,              // [OUT] Put bytes consumed here.                
    ULONG       *pCallConv)             // [OUT] If found, put calling convention here.  
{
    ULONG       cbTotal = 0;            // Bytes consumed.
    mdToken     tk;                     // Token for callconv.
    HRESULT     hr = NOERROR;           // A result.
    LPCUTF8     szName=0;               // Callconv name.
    LPCUTF8     szNamespace=0;          // Callconv namespace.
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);

    _ASSERTE(pcbTotal);
    
    // count the bytes for the token compression
    cbTotal += CorSigUncompressToken(&pbSig[cbTotal], &tk);

    // Hack to skip nil tokens.
    if (IsNilToken(tk))
    {
        *pcbTotal = cbTotal;
        goto ErrExit;
    }

    // See if this token is a calling convention.
    if (TypeFromToken(tk) == mdtTypeRef)
    {
        TypeRefRec *pTypeRefRec = pMiniMd->getTypeRef(RidFromToken(tk));
        szName = pMiniMd->getNameOfTypeRef(pTypeRefRec);
        szNamespace = pMiniMd->getNamespaceOfTypeRef(pTypeRefRec);
    }
    else
    if (TypeFromToken(tk) == mdtTypeDef)
    {
        TypeDefRec *pTypeDefRec = pMiniMd->getTypeDef(RidFromToken(tk));
        szName = pMiniMd->getNameOfTypeDef(pTypeDefRec);
        szNamespace = pMiniMd->getNamespaceOfTypeDef(pTypeDefRec);
    }
        
    if ((szNamespace && szName) &&
        (strcmp(szNamespace, CMOD_CALLCONV_NAMESPACE) == 0 ||
         strcmp(szNamespace, CMOD_CALLCONV_NAMESPACE_OLD) == 0) )
    {
        // Set the hr to -1, which is an unspecified 'error'.  This will percolate
        //  back up to the caller, where the 'error' should be recognized.
        hr=-1;
        if (strcmp(szName, CMOD_CALLCONV_NAME_CDECL) == 0)
            *pCallConv = pmCallConvCdecl;
        else
        if (strcmp(szName, CMOD_CALLCONV_NAME_STDCALL) == 0)
            *pCallConv = pmCallConvStdcall;
        else
        if (strcmp(szName, CMOD_CALLCONV_NAME_THISCALL) == 0)
            *pCallConv = pmCallConvThiscall;
        else
        if (strcmp(szName, CMOD_CALLCONV_NAME_FASTCALL) == 0)
            *pCallConv = pmCallConvFastcall;
        else
            hr = S_OK; // keep looking
        IfFailGo(hr);
    }
    *pcbTotal = cbTotal;
    
ErrExit:
    return hr;
} // HRESULT RegMeta::_CheckCmodForCallConv()

//*****************************************************************************
// Helper used by GetNativeCallingConvFromSig.
//*****************************************************************************
HRESULT RegMeta::_SearchOneArgForCallConv(// S_OK, -1 if found, or error.                  
    PCCOR_SIGNATURE pbSig,              // [IN] Signature to check.                      
    ULONG       *pcbTotal,              // [OUT] Put bytes consumed here.                
    ULONG       *pCallConv)             // [OUT] If found, put calling convention here.  
{
    ULONG       cb;
    ULONG       cbTotal = 0;
    CorElementType ulElementType;
    ULONG       ulData;
    ULONG       ulTemp;
    int         iData;
    mdToken     tk;
    ULONG       cArg;
    ULONG       callingconv;
    ULONG       cArgsIndex;
    HRESULT     hr = NOERROR;

    _ASSERTE(pcbTotal);
    
    cbTotal += CorSigUncompressElementType(&pbSig[cbTotal], &ulElementType);
    while (CorIsModifierElementType(ulElementType) || ulElementType == ELEMENT_TYPE_SENTINEL)
    {
        cbTotal += CorSigUncompressElementType(&pbSig[cbTotal], &ulElementType);
    }
    switch (ulElementType)
    {
		case ELEMENT_TYPE_VALUEARRAY:
            // syntax for SDARRAY = BaseType <an integer for size>
            // skip over base type
            IfFailGo( _SearchOneArgForCallConv(&pbSig[cbTotal], &cb, pCallConv) );
            cbTotal += cb;

            // Parse for the rank
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);

            break;

        case ELEMENT_TYPE_SZARRAY:
            // skip over base type
            IfFailGo( _SearchOneArgForCallConv(&pbSig[cbTotal], &cb, pCallConv) );
            cbTotal += cb;
            break;

        case ELEMENT_TYPE_FNPTR:
            cbTotal += CorSigUncompressData (&pbSig[cbTotal], &callingconv);

            // remember number of bytes to represent the arg counts
            cbTotal += CorSigUncompressData (&pbSig[cbTotal], &cArg);

            // how many bytes to represent the return type
            IfFailGo( _SearchOneArgForCallConv( &pbSig[cbTotal], &cb, pCallConv) );
            cbTotal += cb;
    
            // loop through argument
            for (cArgsIndex = 0; cArgsIndex < cArg; cArgsIndex++)
            {
                IfFailGo( _SearchOneArgForCallConv( &pbSig[cbTotal], &cb, pCallConv) );
                cbTotal += cb;
            }

            break;

        case ELEMENT_TYPE_ARRAY:
            // syntax : ARRAY BaseType <rank> [i size_1... size_i] [j lowerbound_1 ... lowerbound_j]

            // skip over base type
            IfFailGo( _SearchOneArgForCallConv(&pbSig[cbTotal], &cb, pCallConv) );
            cbTotal += cb;

            // Parse for the rank
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);

            // if rank == 0, we are done
            if (ulData == 0)
                break;

            // any size of dimension specified?
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);
            while (ulData--)
            {
                cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulTemp);
            }

            // any lower bound specified?
            cbTotal = CorSigUncompressData(&pbSig[cbTotal], &ulData);

            while (ulData--)
            {
                cbTotal += CorSigUncompressSignedInt(&pbSig[cbTotal], &iData);
            }

            break;
        case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_CLASS:
            // count the bytes for the token compression
            cbTotal += CorSigUncompressToken(&pbSig[cbTotal], &tk);
            break;
		case ELEMENT_TYPE_CMOD_REQD:
        case ELEMENT_TYPE_CMOD_OPT:
            // Check for the calling convention.
            IfFailGo(_CheckCmodForCallConv(&pbSig[cbTotal], &cb, pCallConv));
            cbTotal += cb;
            // skip over base type
            IfFailGo( _SearchOneArgForCallConv(&pbSig[cbTotal], &cb, pCallConv) );
            cbTotal += cb;
            break;
        default:
            break;
    }
    *pcbTotal = cbTotal;
    
ErrExit:
    return hr;
} // HRESULT RegMeta::_SearchOneArgForCallConv()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\filtermanager.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// FilterManager.h
//
// Contains utility code for MD directory
//
//*****************************************************************************
#ifndef __FilterManager__h__
#define __FilterManager__h__




//*********************************************************************
// FilterManager Class 
//*********************************************************************
class FilterManager
{
public:
	FilterManager(CMiniMdRW	*pMiniMd) {m_pMiniMd = pMiniMd; hasModuleBeenMarked = false; hasAssemblyBeenMarked = false;}
	~FilterManager() {};

	HRESULT Mark(mdToken tk);

    // Unmark helper! Currently we only support unmarking certain TypeDefs. Don't expose this to 
    // external caller!! 
    HRESULT UnmarkTypeDef(mdTypeDef td);

private:
	HRESULT MarkCustomAttribute(mdCustomAttribute cv);
	HRESULT MarkDeclSecurity(mdPermission pe);
	HRESULT MarkStandAloneSig(mdSignature sig);
	HRESULT MarkTypeSpec(mdTypeSpec ts);
	HRESULT MarkTypeRef(mdTypeRef tr);
	HRESULT MarkMemberRef(mdMemberRef mr);
	HRESULT MarkModuleRef(mdModuleRef mr);
	HRESULT MarkAssemblyRef(mdAssemblyRef ar);
	HRESULT MarkModule(mdModule mo);
    HRESULT MarkAssembly(mdAssembly as);
	HRESULT MarkInterfaceImpls(mdTypeDef	td);
    HRESULT MarkUserString(mdString str);

	HRESULT MarkCustomAttributesWithParentToken(mdToken tkParent);
	HRESULT MarkDeclSecuritiesWithParentToken(mdToken tkParent);
	HRESULT MarkMemberRefsWithParentToken(mdToken tk);

	HRESULT MarkParam(mdParamDef pd);
	HRESULT MarkMethod(mdMethodDef md);
	HRESULT MarkField(mdFieldDef fd);
	HRESULT MarkEvent(mdEvent ev);
	HRESULT MarkProperty(mdProperty pr);

	HRESULT MarkParamsWithParentToken(mdMethodDef md);
	HRESULT MarkMethodsWithParentToken(mdTypeDef td);
    HRESULT MarkMethodImplsWithParentToken(mdTypeDef td);
	HRESULT MarkFieldsWithParentToken(mdTypeDef td);
	HRESULT MarkEventsWithParentToken(mdTypeDef td);
	HRESULT MarkPropertiesWithParentToken(mdTypeDef td);


	HRESULT MarkTypeDef(mdTypeDef td);


	// We don't want to keep track the debug info with bits because these are going away...
	HRESULT MarkMethodDebugInfo(mdMethodDef md);

	// walk the signature and mark all of the embedded TypeDef or TypeRef
	HRESULT MarkSignature(PCCOR_SIGNATURE pbSigCur, PCCOR_SIGNATURE *ppbSigPost);
	HRESULT MarkFieldSignature(PCCOR_SIGNATURE pbSigCur, PCCOR_SIGNATURE *ppbSigPost);


private:
	CMiniMdRW	*m_pMiniMd;
    bool        hasModuleBeenMarked;
    bool        hasAssemblyBeenMarked;
};

#endif // __FilterManager__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\importhelper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDUtil.cpp
//
// contains utility code to MD directory
//
//*****************************************************************************
#include "stdafx.h"
#include "ImportHelper.h"
#include <MdUtil.h>
#include "RWUtil.h"
#include "MDLog.h"
#include "StrongName.h"

#define COM_RUNTIME_LIBRARY "ComRuntimeLibrary"

//*******************************************************************************
// Find a Method given a parent, name and signature.
//*******************************************************************************
HRESULT ImportHelper::FindMethod(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
    mdTypeDef   td,                     // [IN] parent.
    LPCUTF8     szName,                 // [IN] MethodDef name.
    const COR_SIGNATURE *pSig,          // [IN] Signature.
    ULONG       cbSig,                  // [IN] Size of signature.
    mdMethodDef *pmb,                   // [OUT] Put the MethodDef token here.
    RID         rid /* = 0 */)          // [IN] Optional rid to be ignored.
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       ridStart;               // Start of td's methods.
    ULONG       ridEnd;                 // End of td's methods.
    ULONG       index;                  // Loop control.
    TypeDefRec  *pRec;                  // A TypeDef Record.
    MethodRec   *pMethod;               // A MethodDef Record.
    LPCUTF8     szNameUtf8Tmp;          // A found MethodDef's name.
    PCCOR_SIGNATURE pSigTmp;            // A found MethodDef's signature.
    ULONG       cbSigTmp;               // Size of a found MethodDef's signature.
    PCCOR_SIGNATURE pvSigTemp = pSig;   // For use in parsing a signature.
    CQuickBytes qbSig;                  // Struct to build a non-varargs signature.
    int         rtn;

    if (cbSig)
    {   // check to see if this is a vararg signature
        if ( isCallConv(CorSigUncompressCallingConv(pvSigTemp), IMAGE_CEE_CS_CALLCONV_VARARG) )
        {   // Get the fix part of VARARG signature
            IfFailGo( _GetFixedSigOfVarArg(pSig, cbSig, &qbSig, &cbSig) );
            pSig = (PCCOR_SIGNATURE) qbSig.Ptr();
        }
    }

    *pmb = TokenFromRid(rid, mdtMethodDef); // to know what to ignore
    rtn = pMiniMd->FindMemberDefFromHash(td, szName, pSig, cbSig, pmb);
    if (rtn == CMiniMdRW::Found)
        goto ErrExit;
    else if (rtn == CMiniMdRW::NotFound)
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    _ASSERTE(rtn == CMiniMdRW::NoTable);

    *pmb = mdMethodDefNil;

    // get the range of method rids given a typedef
    pRec = pMiniMd->getTypeDef(RidFromToken(td));
    ridStart = pMiniMd->getMethodListOfTypeDef(pRec);
    ridEnd = pMiniMd->getEndMethodListOfTypeDef(pRec);
    // Iterate over the methods.
    for (index = ridStart; index < ridEnd; index ++ )
    {
		RID	methodRID = pMiniMd->GetMethodRid(index);
        // For the call from Validator ignore the rid passed in.
        if (methodRID != rid)
		{
			// Get the method and its name.
			pMethod = pMiniMd->getMethod( methodRID );
			szNameUtf8Tmp = pMiniMd->getNameOfMethod(pMethod);

			// If name matches what was requested...
			if ( strcmp(szNameUtf8Tmp, szName) == 0 )
			{
                if (cbSig && pSig)
				{
					pSigTmp = pMiniMd->getSignatureOfMethod(pMethod, &cbSigTmp);
					if (cbSigTmp != cbSig || memcmp(pSig, pSigTmp, cbSig))
                        continue;
                }
                // Ignore PrivateScope methods.
                if (IsMdPrivateScope(pMiniMd->getFlagsOfMethod(pMethod)))
                    continue;
                // Found method.
						*pmb = TokenFromRid(methodRID, mdtMethodDef);
						goto ErrExit;
					}
				}
			}

    // record not found
    *pmb = mdMethodDefNil;
    hr = CLDB_E_RECORD_NOTFOUND;

ErrExit:
    return hr;
} // HRESULT ImportHelper::FindMethod()

//*******************************************************************************
// Find a Field given a parent, name and signature.
//*******************************************************************************
HRESULT ImportHelper::FindField(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
    mdTypeDef   td,                     // [IN] parent.
    LPCUTF8     szName,                 // [IN] FieldDef name.
    const COR_SIGNATURE *pSig,          // [IN] Signature.
    ULONG       cbSig,                  // [IN] Size of signature.
    mdFieldDef  *pfd,                   // [OUT] Put the FieldDef token here.
    RID         rid /* = 0 */)          // [IN] Optional rid to be ignored.
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       ridStart;               // Start of td's methods.
    ULONG       ridEnd;                 // End of td's methods.
    ULONG       index;                  // Loop control.
    TypeDefRec  *pRec;                  // A TypeDef Record.
    FieldRec    *pField;                // A FieldDef Record.
    LPCUTF8     szNameUtf8Tmp;          // A found FieldDef's name.
    PCCOR_SIGNATURE pSigTmp;            // A found FieldDef's signature.
    ULONG       cbSigTmp;               // Size of a found FieldDef's signature.
    int         rtn;

    *pfd = TokenFromRid(rid,mdtFieldDef); // to know what to ignore
    rtn = pMiniMd->FindMemberDefFromHash(td, szName, pSig, cbSig, pfd);
    if (rtn == CMiniMdRW::Found)
        goto ErrExit;
    else if (rtn == CMiniMdRW::NotFound)
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    _ASSERTE(rtn == CMiniMdRW::NoTable);

    *pfd = mdFieldDefNil;

    // get the range of method rids given a typedef
    pRec = pMiniMd->getTypeDef(RidFromToken(td));
    ridStart = pMiniMd->getFieldListOfTypeDef(pRec);
    ridEnd = pMiniMd->getEndFieldListOfTypeDef(pRec);

    // Iterate over the methods.
    for (index = ridStart; index < ridEnd; index ++ )
    {
		RID fieldRID = pMiniMd->GetFieldRid(index);
        // For the call from Validator ignore the rid passed in.
        if (fieldRID != rid)
		{
			// Get the field and its name.
			pField = pMiniMd->getField( fieldRID );
			szNameUtf8Tmp = pMiniMd->getNameOfField(pField);

			// If name matches what was requested...
			if ( strcmp(szNameUtf8Tmp, szName) == 0 )
			{
                // Check signature if specified.
                if (cbSig && pSig)
				{
					pSigTmp = pMiniMd->getSignatureOfField(pField, &cbSigTmp);
					if (cbSigTmp != cbSig || memcmp(pSig, pSigTmp, cbSig))
                        continue;
                }
                // Ignore PrivateScope fields.
                if (IsFdPrivateScope(pMiniMd->getFlagsOfField(pField)))
                    continue;
                // Field found.
						*pfd = TokenFromRid(fieldRID, mdtFieldDef);
						goto ErrExit;
					}
				}
			}

    // record not found
    *pfd = mdFieldDefNil;
    hr = CLDB_E_RECORD_NOTFOUND;

ErrExit:
    return hr;
} // HRESULT ImportHelper::FindField()

//*******************************************************************************
// Find a Member given a parent, name and signature.
//*******************************************************************************
HRESULT ImportHelper::FindMember(
    CMiniMdRW   *pMiniMd,                   // [IN] the minimd to lookup
    mdTypeDef   td,                         // [IN] parent.
    LPCUTF8     szName,                     // [IN] Member name.
    const COR_SIGNATURE *pSig,              // [IN] Signature.
    ULONG       cbSig,                      // [IN] Size of signature.
    mdToken     *ptk)                       // [OUT] Put the token here.
{
    HRESULT     hr;                         // A result.

    // determine if it is ref to MethodDef or FieldDef
    if ((pSig[0] & IMAGE_CEE_CS_CALLCONV_MASK) != IMAGE_CEE_CS_CALLCONV_FIELD)
        hr = FindMethod(pMiniMd, td, szName, pSig, cbSig, ptk);
    else 
        hr = FindField(pMiniMd, td, szName, pSig, cbSig, ptk);

    if (hr == CLDB_E_RECORD_NOTFOUND)
        *ptk = mdTokenNil;

    return hr;
} // HRESULT ImportHelper::FindMember()


//*******************************************************************************
// Find the memberref given name, sig, and parent
//*******************************************************************************
HRESULT ImportHelper::FindMemberRef(
    CMiniMdRW   *pMiniMd,                   // [IN] the minimd to lookup
    mdToken     tkParent,                   // [IN] the parent token
    LPCUTF8     szName,                     // [IN] memberref name
    const COR_SIGNATURE *pbSig,             // [IN] Signature.
    ULONG       cbSig,                      // [IN] Size of signature.
    mdMemberRef *pmr,                       // [OUT] Put the MemberRef token found
    RID         rid /* = 0*/)               // [IN] Optional rid to be ignored.
{
    ULONG       cMemberRefRecs;
    MemberRefRec    *pMemberRefRec;
    LPCUTF8     szNameTmp = 0;
    const COR_SIGNATURE *pbSigTmp;          // Signature.
    ULONG       cbSigTmp;                   // Size of signature.
    mdToken     tkParentTmp;                // the parent token
    HRESULT     hr = NOERROR;
    int         rtn;
    ULONG       i;

    _ASSERTE(szName &&  pmr);

    *pmr = TokenFromRid(rid,mdtMemberRef); // to know what to ignore
    rtn = pMiniMd->FindMemberRefFromHash(tkParent, szName, pbSig, cbSig, pmr);
    if (rtn == CMiniMdRW::Found)
        goto ErrExit;
    else if (rtn == CMiniMdRW::NotFound)
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    _ASSERTE(rtn == CMiniMdRW::NoTable);

    *pmr = mdMemberRefNil;

    cMemberRefRecs = pMiniMd->getCountMemberRefs();

    // Search for the MemberRef
    for (i = 1; i <= cMemberRefRecs; i++)
    {
        // For the call from Validator ignore the rid passed in.
        if (i == rid)
            continue;

        pMemberRefRec = pMiniMd->getMemberRef(i);
        if ( !IsNilToken(tkParent) )
        {
            // given a valid parent
            tkParentTmp = pMiniMd->getClassOfMemberRef(pMemberRefRec);
            if (tkParentTmp != tkParent)
            {
                // if parent is specified and not equal to the current row,
                // try the next row.
                //
                continue;
            }
        }
        if ( szName && *szName )
        {
            // name is specified
            szNameTmp = pMiniMd->getNameOfMemberRef(pMemberRefRec);
            if ( strcmp(szName, szNameTmp) != 0 )
            {
                // Name is not equal. Try next row.
                continue;
            }
        }
        if ( cbSig && pbSig )
        {
            // signature is specifed
            pbSigTmp = pMiniMd->getSignatureOfMemberRef(pMemberRefRec, &cbSigTmp);
            if (cbSigTmp != cbSig)
                continue;
            if (memcmp( pbSig, pbSigTmp, cbSig ) != 0)
                continue;
        }

        // we found a match
        *pmr = TokenFromRid(i, mdtMemberRef);
        return S_OK;
    }
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    return hr;
} // HRESULT ImportHelper::FindMemberRef()



//*******************************************************************************
// Find duplicate StandAloneSig
//*******************************************************************************
HRESULT ImportHelper::FindStandAloneSig(
    CMiniMdRW   *pMiniMd,                   // [IN] the minimd to lookup
    const COR_SIGNATURE *pbSig,             // [IN] Signature.
    ULONG       cbSig,                      // [IN] Size of signature.
    mdSignature *psa)                       // [OUT] Put the StandAloneSig token found
{
    ULONG       cRecs;
    StandAloneSigRec    *pRec;
    const COR_SIGNATURE *pbSigTmp;          // Signature.
    ULONG       cbSigTmp;                   // Size of signature.


    _ASSERTE(cbSig &&  psa);
    *psa = mdSignatureNil;

    cRecs = pMiniMd->getCountStandAloneSigs();

    // Search for the StandAloneSignature
    for (ULONG i = 1; i <= cRecs; i++)
    {
        pRec = pMiniMd->getStandAloneSig(i);
        pbSigTmp = pMiniMd->getSignatureOfStandAloneSig(pRec, &cbSigTmp);
        if (cbSigTmp != cbSig)
            continue;
        if (memcmp( pbSig, pbSigTmp, cbSig ) != 0)
            continue;

        // we found a match
        *psa = TokenFromRid(i, mdtSignature);
        return S_OK;
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindStandAloneSig()

//*******************************************************************************
// Find duplicate TypeSpec
//*******************************************************************************
HRESULT ImportHelper::FindTypeSpec(
    CMiniMdRW   *pMiniMd,                   // [IN] the minimd to lookup
    const COR_SIGNATURE *pbSig,             // [IN] Signature.
    ULONG       cbSig,                      // [IN] Size of signature.
    mdTypeSpec  *ptypespec)                 // [OUT] Put the TypeSpec token found
{
    ULONG       cRecs;
    TypeSpecRec *pRec;
    const COR_SIGNATURE *pbSigTmp;          // Signature.
    ULONG       cbSigTmp;                   // Size of signature.


    _ASSERTE(cbSig &&  ptypespec);
    *ptypespec = mdSignatureNil;

    cRecs = pMiniMd->getCountTypeSpecs();

    // Search for the TypeSpec
    for (ULONG i = 1; i <= cRecs; i++)
    {
        pRec = pMiniMd->getTypeSpec(i);
        pbSigTmp = pMiniMd->getSignatureOfTypeSpec(pRec, &cbSigTmp);
        if (cbSigTmp != cbSig)
            continue;
        if (memcmp( pbSig, pbSigTmp, cbSig ) != 0)
            continue;

        // we found a match
        *ptypespec = TokenFromRid(i, mdtTypeSpec);
        return S_OK;
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindTypeSpec()


//*******************************************************************************
// Find the MethodImpl
//*******************************************************************************
HRESULT ImportHelper::FindMethodImpl(
    CMiniMdRW   *pMiniMd,                   // [IN] The MiniMd to lookup.
    mdTypeDef   tkClass,                    // [IN] The parent TypeDef token.
    mdMethodDef tkBody,                     // [IN] Method body token.
    mdMethodDef tkDecl,                     // [IN] Method declaration token.
    RID         *pRid)                      // [OUT] Put the MethodImpl rid here
{
    MethodImplRec *pMethodImplRec;          // MethodImpl record.
    ULONG       cMethodImplRecs;            // Count of MethodImpl records.
    mdTypeDef   tkClassTmp;                 // Parent TypeDef token.
    mdToken     tkBodyTmp;                  // Method body token.
    mdToken     tkDeclTmp;                  // Method declaration token.

    _ASSERTE(TypeFromToken(tkClass) == mdtTypeDef);
    _ASSERTE(TypeFromToken(tkBody) == mdtMemberRef || TypeFromToken(tkBody) == mdtMethodDef);
    _ASSERTE(TypeFromToken(tkDecl) == mdtMemberRef || TypeFromToken(tkDecl) == mdtMethodDef);
    _ASSERTE(!IsNilToken(tkClass) && !IsNilToken(tkBody) && !IsNilToken(tkDecl));
    
    if (pRid)
        *pRid = 0;

    cMethodImplRecs = pMiniMd->getCountMethodImpls();

    // Search for the MethodImpl.
    for (ULONG i = 1; i <= cMethodImplRecs; i++)
    {
        pMethodImplRec = pMiniMd->getMethodImpl(i);

        // match the parent column
        tkClassTmp = pMiniMd->getClassOfMethodImpl(pMethodImplRec);
        if (tkClassTmp != tkClass)
            continue;

        // match the method body column
        tkBodyTmp = pMiniMd->getMethodBodyOfMethodImpl(pMethodImplRec);
        if (tkBodyTmp != tkBody)
            continue;

        // match the method declaration column
        tkDeclTmp = pMiniMd->getMethodDeclarationOfMethodImpl(pMethodImplRec);
        if (tkDeclTmp != tkDecl)
            continue;

        // we found a match
        if (pRid)
            *pRid = i;
        return S_OK;
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindMethodImpl()


//*******************************************************************************
// Find the TypeRef given the full qualified name.
//*******************************************************************************
HRESULT ImportHelper::FindTypeRefByName(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
    mdToken     tkResolutionScope,      // [IN] Resolution scope for the TypeRef.
    LPCUTF8     szNamespace,            // [IN] TypeRef Namespace.
    LPCUTF8     szName,                 // [IN] TypeRef Name.
    mdTypeRef   *ptk,                   // [OUT] Put the TypeRef token here.
    RID         rid /* = 0*/)           // [IN] Optional rid to be ignored.
{
    HRESULT     hr=S_OK;                // A result.
    ULONG       cTypeRefRecs;           // Count of TypeRefs to scan.
    TypeRefRec  *pTypeRefRec;           // A TypeRef record.
    LPCUTF8     szNameTmp;              // A TypeRef's Name.
    LPCUTF8     szNamespaceTmp;         // A TypeRef's Namespace.
    mdToken     tkResTmp;               // TypeRef's resolution scope.
    ULONG       i;                      // Loop control.

    _ASSERTE(szName &&  ptk);
    *ptk = mdTypeRefNil;

    // Treat no namespace as empty string.
    if (!szNamespace)
        szNamespace = "";

    if (pMiniMd->m_pNamedItemHash)
    {
        // If hash is build, go through the hash table
        TOKENHASHENTRY *p;              // Hash entry from chain.
        ULONG       iHash;              // Item's hash value.
        int         pos;                // Position in hash chain.

        // Hash the data.
        iHash = pMiniMd->HashNamedItem(0, szName);

        // Go through every entry in the hash chain looking for ours.
        for (p = pMiniMd->m_pNamedItemHash->FindFirst(iHash, pos);
             p;
             p = pMiniMd->m_pNamedItemHash->FindNext(pos))
        {   

            // name hash can hold more than one kind of token
            if (TypeFromToken(p->tok) != (ULONG)mdtTypeRef)
            {
                continue;
            }

            // skip this one if asked
            if (RidFromToken(p->tok) == rid)
                continue;

            pTypeRefRec = pMiniMd->getTypeRef(RidFromToken(p->tok));
            szNamespaceTmp = pMiniMd->getNamespaceOfTypeRef(pTypeRefRec);
            szNameTmp = pMiniMd->getNameOfTypeRef(pTypeRefRec);
            if (strcmp(szName, szNameTmp) || strcmp(szNamespace, szNamespaceTmp))
            {
                // if the name space is not equal, then check the next one.
                continue;
            }
            tkResTmp = pMiniMd->getResolutionScopeOfTypeRef(pTypeRefRec);

            if (tkResTmp == tkResolutionScope ||
                (IsNilToken(tkResTmp) && IsNilToken(tkResolutionScope)))
            {
                // we found a match
                *ptk = p->tok;
                return S_OK;
            }
        }
        hr = CLDB_E_RECORD_NOTFOUND;
    } 
    else
    {
        cTypeRefRecs = pMiniMd->getCountTypeRefs();

        // Search for the TypeRef.
        for (i = 1; i <= cTypeRefRecs; i++)
        {
            // For the call from Validator ignore the rid passed in.
            if (i == rid)
                continue;

            pTypeRefRec = pMiniMd->getTypeRef(i);

            // See if the Resolution scopes match.
            tkResTmp = pMiniMd->getResolutionScopeOfTypeRef(pTypeRefRec);
            if (IsNilToken(tkResTmp))
            {
                if (!IsNilToken(tkResolutionScope))
                    continue;
            }
            else if (tkResTmp != tkResolutionScope)
                continue;

            szNamespaceTmp = pMiniMd->getNamespaceOfTypeRef(pTypeRefRec);
            if (strcmp(szNamespace, szNamespaceTmp))
                continue;

            szNameTmp = pMiniMd->getNameOfTypeRef(pTypeRefRec);
            if (! strcmp(szName, szNameTmp))
            {
                *ptk = TokenFromRid(i, mdtTypeRef);
                return S_OK;
            }
        }
        hr = CLDB_E_RECORD_NOTFOUND;
    }
    return hr;
} // HRESULT ImportHelper::FindTypeRefByName()


//*******************************************************************************
// Find the ModuleRef given the name, guid and mvid.
//*******************************************************************************
HRESULT ImportHelper::FindModuleRef(
    CMiniMdRW   *pMiniMd,                   // [IN] the minimd to lookup
    LPCUTF8     szUTF8Name,                 // [IN] ModuleRef name.
    mdModuleRef *pmur,                      // [OUT] Put the ModuleRef token here.
    RID         rid /* = 0*/)               // [IN] Optional rid to be ignored.
{
    ModuleRefRec *pModuleRef;
    ULONG       cModuleRefs;
    LPCUTF8     szCurName;
    ULONG       i;

    _ASSERTE(pmur);
    _ASSERTE(szUTF8Name);

    cModuleRefs = pMiniMd->getCountModuleRefs();

    // linear scan through the ModuleRef table
    for (i=1; i <= cModuleRefs; ++i)
    {
        // For the call from Validator ignore the rid passed in.
        if (i == rid)
            continue;

        pModuleRef = pMiniMd->getModuleRef(i);

        if (szUTF8Name)
        {
            szCurName = pMiniMd->getNameOfModuleRef(pModuleRef);
            if (strcmp(szCurName, szUTF8Name))
                continue;
        }
        //  Matching record found.
        *pmur = TokenFromRid(i, mdtModuleRef);
        return S_OK;
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindModuleRef()



//*******************************************************************************
// Find the TypeDef given the type and namespace name
//*******************************************************************************
HRESULT ImportHelper::FindTypeDefByName(
    CMiniMdRW   *pMiniMd,                   // [IN] the minimd to lookup
    LPCUTF8     szNamespace,                // [IN] Full qualified TypeRef name.
    LPCUTF8     szName,                     // [IN] Full qualified TypeRef name.
    mdToken     tkEnclosingClass,           // [IN] TypeDef/TypeRef for Enclosing class.
    mdTypeDef   *ptk,                       // [OUT] Put the TypeRef token here.
    RID         rid /* = 0 */)              // [IN] Optional rid to be ignored.
{
    ULONG       cTypeDefRecs;
    TypeDefRec  *pTypeDefRec;
    LPCUTF8     szNameTmp;
    LPCUTF8     szNamespaceTmp;
    DWORD       dwFlags;
    HRESULT     hr = S_OK;

    _ASSERTE(szName &&  ptk);
    _ASSERTE(TypeFromToken(tkEnclosingClass) == mdtTypeDef ||
             TypeFromToken(tkEnclosingClass) == mdtTypeRef ||
             IsNilToken(tkEnclosingClass));
    _ASSERTE(! ns::FindSep(szName));

    *ptk = mdTypeDefNil;

    cTypeDefRecs = pMiniMd->getCountTypeDefs();

    // Treat no namespace as empty string.
    if (!szNamespace)
        szNamespace = "";

    // Search for the TypeDef
    for (ULONG i = 1; i <= cTypeDefRecs; i++)
    {
        // For the call from Validator ignore the rid passed in.
        if (i == rid)
            continue;

        pTypeDefRec = pMiniMd->getTypeDef(i);

        dwFlags = pMiniMd->getFlagsOfTypeDef(pTypeDefRec);

        if (!IsTdNested(dwFlags) && !IsNilToken(tkEnclosingClass))
        {
            // If the class is not Nested and EnclosingClass passed in is not nil
            continue;
        }
        else if (IsTdNested(dwFlags) && IsNilToken(tkEnclosingClass))
        {
            // If the class is nested and EnclosingClass passed is nil
            continue;
        }
        else if (!IsNilToken(tkEnclosingClass))
        {
            RID         iNestedClassRec;
            NestedClassRec *pNestedClassRec;
            mdTypeDef   tkEnclosingClassTmp;

            // If the EnclosingClass passed in is not nil
            if (TypeFromToken(tkEnclosingClass) == mdtTypeRef)
            {
                // Resolve the TypeRef to a TypeDef.

                TypeRefRec  *pTypeRefRec;
                mdToken     tkResolutionScope;
                LPCUTF8     szTypeRefName;
                LPCUTF8     szTypeRefNamespace;

                pTypeRefRec = pMiniMd->getTypeRef(RidFromToken(tkEnclosingClass));
                tkResolutionScope = pMiniMd->getResolutionScopeOfTypeRef(pTypeRefRec);
                szTypeRefName = pMiniMd->getNameOfTypeRef(pTypeRefRec);
                szTypeRefNamespace = pMiniMd->getNamespaceOfTypeRef(pTypeRefRec);

                hr = FindTypeDefByName(pMiniMd, szTypeRefNamespace, szTypeRefName,
                    (TypeFromToken(tkResolutionScope) == mdtTypeRef) ? tkResolutionScope : mdTokenNil,
                    &tkEnclosingClass);
                if (hr == CLDB_E_RECORD_NOTFOUND)
                {
                    continue;
                }
                else if (hr != S_OK)
                    return hr;
            }

            iNestedClassRec = pMiniMd->FindNestedClassHelper(TokenFromRid(i, mdtTypeDef));
            if (InvalidRid(iNestedClassRec))
                continue;
            pNestedClassRec = pMiniMd->getNestedClass(iNestedClassRec);
            tkEnclosingClassTmp = pMiniMd->getEnclosingClassOfNestedClass(pNestedClassRec);
            if (tkEnclosingClass != tkEnclosingClassTmp)
                continue;
        }

        szNameTmp = pMiniMd->getNameOfTypeDef(pTypeDefRec);
        if ( strcmp(szName, szNameTmp) == 0)
        {
            szNamespaceTmp = pMiniMd->getNamespaceOfTypeDef(pTypeDefRec);
            if (strcmp(szNamespace, szNamespaceTmp) == 0)
            {
                *ptk = TokenFromRid(i, mdtTypeDef);
                return S_OK;
            }
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindTypeDefByName()

//*******************************************************************************
// Find the InterfaceImpl given the typedef and implemented interface
//*******************************************************************************
HRESULT ImportHelper::FindInterfaceImpl(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
    mdToken     tkClass,                // [IN] TypeDef of the type
    mdToken     tkInterface,            // [IN] could be typedef/typeref
    mdInterfaceImpl *ptk,               // [OUT] Put the interface token here.
    RID         rid /* = 0*/)           // [IN] Optional rid to be ignored.
{
    ULONG       ridStart, ridEnd;
    ULONG       i;
    InterfaceImplRec    *pInterfaceImplRec;

    _ASSERTE(ptk);
    *ptk = mdInterfaceImplNil;
    if ( pMiniMd->IsSorted(TBL_InterfaceImpl) )
    {
        ridStart = pMiniMd->getInterfaceImplsForTypeDef(RidFromToken(tkClass), &ridEnd);
    }
    else
    {
        ridStart = 1;
        ridEnd = pMiniMd->getCountInterfaceImpls() + 1;
    }

    // Search for the interfaceimpl
    for (i = ridStart; i < ridEnd; i++)
    {
        // For the call from Validator ignore the rid passed in.
        if (i == rid)
            continue;

        pInterfaceImplRec = pMiniMd->getInterfaceImpl(i);
        if ( tkClass != pMiniMd->getClassOfInterfaceImpl(pInterfaceImplRec) )
            continue;
        if ( tkInterface == pMiniMd->getInterfaceOfInterfaceImpl(pInterfaceImplRec) )
        {
            *ptk = TokenFromRid(i, mdtInterfaceImpl);
            return S_OK;
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindInterfaceImpl()



//*******************************************************************************
// Find the Permission by parent and action
//*******************************************************************************
HRESULT ImportHelper::FindPermission(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
    mdToken     tkParent,               // [IN] Token with the Permission
    USHORT      usAction,               // [IN] The action of the permission
    mdPermission *ppm)                  // [OUT] Put permission token here
{
    HRESULT     hr = NOERROR;
    DeclSecurityRec *pRec;
    ULONG       ridStart, ridEnd;
    ULONG       i;
    mdToken     tkParentTmp;

    _ASSERTE(ppm);

    if ( pMiniMd->IsSorted(TBL_DeclSecurity) )
    {

        ridStart = pMiniMd->getDeclSecurityForToken(tkParent, &ridEnd);
    }
    else
    {
        ridStart = 1;
        ridEnd = pMiniMd->getCountDeclSecuritys() + 1;
    }
    // loop through all permission
    for (i = ridStart; i < ridEnd; i++)
    {
        pRec = pMiniMd->getDeclSecurity(i);
        tkParentTmp = pMiniMd->getParentOfDeclSecurity(pRec);
        if ( tkParentTmp != tkParent )
            continue;
        if (pRec->m_Action == usAction)
        {
            *ppm = TokenFromRid(i, mdtPermission);
            return S_OK;
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindPermission()


//*****************************************************************************
// find a property record
//*****************************************************************************
HRESULT ImportHelper::FindProperty(
    CMiniMdRW   *pMiniMd,                   // [IN] the minimd to lookup
    mdToken     tkTypeDef,                  // [IN] typedef token
    LPCUTF8     szName,                     // [IN] name of the property
    const COR_SIGNATURE *pbSig,             // [IN] Signature.
    ULONG       cbSig,                      // [IN] Size of signature.
    mdProperty  *ppr)                       // [OUT] Property token
{
    HRESULT     hr = NOERROR;
    RID         ridPropertyMap;
    PropertyMapRec *pPropertyMapRec;
    PropertyRec *pRec;
    ULONG       ridStart;
    ULONG       ridEnd;
    ULONG       i;
    LPCUTF8     szNameTmp;
    PCCOR_SIGNATURE pbSigTmp;
    ULONG       cbSigTmp;
    ULONG       pr;

    ridPropertyMap = pMiniMd->FindPropertyMapFor( RidFromToken(tkTypeDef) );
    if ( !InvalidRid(ridPropertyMap) )
    {
        pPropertyMapRec = pMiniMd->getPropertyMap( ridPropertyMap );
        ridStart = pMiniMd->getPropertyListOfPropertyMap( pPropertyMapRec );
        ridEnd = pMiniMd->getEndPropertyListOfPropertyMap( pPropertyMapRec );

        for (i = ridStart; i < ridEnd; i++)
        {
            // get the property rid
            pr = pMiniMd->GetPropertyRid(i);
            pRec = pMiniMd->getProperty(pr);
            szNameTmp = pMiniMd->getNameOfProperty(pRec);
            pbSigTmp = pMiniMd->getTypeOfProperty( pRec, &cbSigTmp );
            if ( strcmp (szName, szNameTmp) != 0 )                   
                continue;
            if ( cbSig != 0 && (cbSigTmp != cbSig || memcmp(pbSig, pbSigTmp, cbSig) != 0 ) )
                continue;
            *ppr = TokenFromRid( i, mdtProperty );
            return S_OK;
        }
        return CLDB_E_RECORD_NOTFOUND;
    }
    else
    {
        return CLDB_E_RECORD_NOTFOUND;
    }
} // HRESULT ImportHelper::FindProperty()




//*****************************************************************************
// find an Event record
//*****************************************************************************
HRESULT ImportHelper::FindEvent(
    CMiniMdRW   *pMiniMd,                   // [IN] the minimd to lookup
    mdToken     tkTypeDef,                  // [IN] typedef token
    LPCUTF8     szName,                     // [IN] name of the event
    mdProperty  *pev)                       // [OUT] Event token
{
    HRESULT     hr = NOERROR;
    RID         ridEventMap;
    EventMapRec *pEventMapRec;
    EventRec    *pRec;
    ULONG       ridStart;
    ULONG       ridEnd;
    ULONG       i;
    LPCUTF8     szNameTmp;
    ULONG       ev;

    ridEventMap = pMiniMd->FindEventMapFor( RidFromToken(tkTypeDef) );
    if ( !InvalidRid(ridEventMap) )
    {
        pEventMapRec = pMiniMd->getEventMap( ridEventMap );
        ridStart = pMiniMd->getEventListOfEventMap( pEventMapRec );
        ridEnd = pMiniMd->getEndEventListOfEventMap( pEventMapRec );

        for (i = ridStart; i < ridEnd; i++)
        {
            // get the Event rid
            ev = pMiniMd->GetEventRid(i);

            // get the event row
            pRec = pMiniMd->getEvent(ev);
            szNameTmp = pMiniMd->getNameOfEvent( pRec );
            if ( strcmp (szName, szNameTmp) == 0)
            {
                *pev = TokenFromRid( ev, mdtEvent );
                return S_OK;
            }
        }
        return CLDB_E_RECORD_NOTFOUND;
    }
    else
    {
        return CLDB_E_RECORD_NOTFOUND;
    }
} // HRESULT ImportHelper::FindEvent()



//*****************************************************************************
// find an custom value record given by parent and type token. This will always return
// the first one that is found regardless duplicated.
//*****************************************************************************
HRESULT ImportHelper::FindCustomAttributeByToken(
    CMiniMdRW   *pMiniMd,                   // [IN] the minimd to lookup
    mdToken     tkParent,                   // [IN] the parent that custom value is associated with
    mdToken     tkType,                     // [IN] type of the CustomAttribute
	const void	*pCustBlob,					// [IN] custom attribute blob
	ULONG		cbCustBlob,					// [IN] size of the blob.
    mdCustomAttribute *pcv)                 // [OUT] CustomAttribute token
{
    HRESULT     hr = NOERROR;
    CustomAttributeRec  *pRec;
    ULONG       ridStart, ridEnd;
    ULONG       i;
    mdToken     tkParentTmp;
    mdToken     tkTypeTmp;
	const void	*pCustBlobTmp;
	ULONG		cbCustBlobTmp;

    _ASSERTE(pcv);
    *pcv = mdCustomAttributeNil;
    if ( pMiniMd->IsSorted(TBL_CustomAttribute) )
    {
        *pcv = pMiniMd->FindCustomAttributeFor(
            RidFromToken( tkParent ),
            TypeFromToken( tkParent ),
            tkType);
        if (InvalidRid(*pcv))
            return S_FALSE;
        else if (pCustBlob)
		{
			pRec = pMiniMd->getCustomAttribute(RidFromToken(*pcv));
			pCustBlobTmp = pMiniMd->getValueOfCustomAttribute(pRec, &cbCustBlobTmp);
			if (cbCustBlob == cbCustBlobTmp &&
				!memcmp(pCustBlob, pCustBlobTmp, cbCustBlob))
			{
				return S_OK;
			}
			else
				return S_FALSE;
		}
        else
            return S_OK;
    }
    else
    {
        CLookUpHash *pHashTable = pMiniMd->m_pLookUpHashs[TBL_CustomAttribute];

        if (pHashTable)
        {
            // table is not sorted but hash is built
            // We want to create dynmaic array to hold the dynamic enumerator.
            TOKENHASHENTRY *p;
            ULONG       iHash;
            int         pos;
            mdToken     tkParentTmp;
            mdToken     tkTypeTmp;

            // Hash the data.
            iHash = pMiniMd->HashCustomAttribute(tkParent);

            // Go through every entry in the hash chain looking for ours.
            for (p = pHashTable->FindFirst(iHash, pos);
                 p;
                 p = pHashTable->FindNext(pos))
            {
                pRec = pMiniMd->getCustomAttribute(RidFromToken(p->tok));

                tkParentTmp = pMiniMd->getParentOfCustomAttribute(pRec);
                if (tkParentTmp != tkParent)
					continue;

                tkTypeTmp = pMiniMd->getTypeOfCustomAttribute(pRec);
				if (tkType != tkTypeTmp)
					continue;

				pCustBlobTmp = pMiniMd->getValueOfCustomAttribute(pRec, &cbCustBlobTmp);
				if (cbCustBlob == cbCustBlobTmp &&
					!memcmp(pCustBlob, pCustBlobTmp, cbCustBlob))
                {
                    *pcv = TokenFromRid(p->tok, mdtCustomAttribute);
                    return S_OK;
                }
            }
        }
        else
        {
            // linear scan
            ridStart = 1;
            ridEnd = pMiniMd->getCountCustomAttributes() + 1;

            // loop through all custom values
            for (i = ridStart; i < ridEnd; i++)
            {
                pRec = pMiniMd->getCustomAttribute(i);

                tkParentTmp = pMiniMd->getParentOfCustomAttribute(pRec);
                if ( tkParentTmp != tkParent )
                    continue;

                tkTypeTmp = pMiniMd->getTypeOfCustomAttribute(pRec);
                if (tkType != tkTypeTmp)
					continue;

				pCustBlobTmp = pMiniMd->getValueOfCustomAttribute(pRec, &cbCustBlobTmp);
				if (cbCustBlob == cbCustBlobTmp &&
					!memcmp(pCustBlob, pCustBlobTmp, cbCustBlob))
                {
                    *pcv = TokenFromRid(i, mdtCustomAttribute);
                    return S_OK;
                }
            }
        }
        // fall through
    }
    return S_FALSE;
} // HRESULT ImportHelper::FindCustomAttributeByToken()



//*****************************************************************************
// Helper function to lookup and retrieve a CustomAttribute.
//*****************************************************************************
HRESULT ImportHelper::GetCustomAttributeByName( // S_OK or error.
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
    mdToken     tkObj,                  // [IN] Object with Custom Attribute.
    LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
	const void	**ppData,				// [OUT] Put pointer to data here.
	ULONG		*pcbData)				// [OUT] Put size of data here.
{
    return pMiniMd->CommonGetCustomAttributeByName(tkObj, szName, ppData, pcbData);
}   // ImportHelper::GetCustomAttributeByName



//*******************************************************************************
// Find an ImplMap record, which is used for p-invoke data.
//*******************************************************************************
HRESULT ImportHelper::FindImplMap(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup.
    mdToken     tkModuleRef,            // [IN] Parent module ref to look under.
    mdToken     tkMethodDef,            // [IN] Parent methoddef to look under.
    USHORT      usMappingFlags,         // [IN] Flags on how to map the item.
    LPCUTF8     szImportName,           // [IN] Name of import member.
    ULONG       *piRecord)              // [OUT] Record for item if found.
{
    ULONG       cRecs;                  // Count of records.
    ImplMapRec  *pRec;                  // Current record being looked at.

    mdToken     tkTmp;
    LPCUTF8     szImportNameTmp;

    _ASSERTE(piRecord);
    *piRecord = 0;

    cRecs = pMiniMd->getCountImplMaps();

    // Search for the ImplMap record.
    for (ULONG i = 1; i <= cRecs; i++)
    {
        pRec = pMiniMd->getImplMap(i);

        tkTmp = pMiniMd->getMemberForwardedOfImplMap(pRec);
        if (tkTmp != tkMethodDef)
            continue;

        tkTmp = pMiniMd->getImportScopeOfImplMap(pRec);
        if (tkTmp != tkModuleRef)
            continue;

        szImportNameTmp = pMiniMd->getImportNameOfImplMap(pRec);
        if (strcmp(szImportNameTmp, szImportName))
            continue;

        if (pRec->m_MappingFlags != usMappingFlags)
            continue;

        *piRecord = i;
        return S_OK;
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindImplMap()

//*******************************************************************************
// Find an AssemblyRef record given the name.
//*******************************************************************************
HRESULT ImportHelper::FindAssemblyRef(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup.
    LPCUTF8     szName,                 // [IN] Name.
    LPCUTF8     szLocale,               // [IN] Locale.
    const void  *pbPublicKeyOrToken,    // [IN] Public key or token (based on flags).
    ULONG       cbPublicKeyOrToken,     // [IN] Byte count of public key or token.
    USHORT      usMajorVersion,         // [IN] Major version.
    USHORT      usMinorVersion,         // [IN] Minor version.
    USHORT      usBuildNumber,          // [IN] Build number.
    USHORT      usRevisionNumber,       // [IN] Revision number.
    DWORD       dwFlags,                // [IN] Flags.
    mdAssemblyRef *pmar)                // [OUT] returned AssemblyRef token.
{
    ULONG       cRecs;                  // Count of records.
    AssemblyRefRec *pRec;               // Current record being looked at.
    LPCUTF8     szTmp;                  // Temp string.
    const void  *pbTmp;                 // Temp blob.
    ULONG       cbTmp;                  // Temp byte count.
    DWORD       dwTmp;                  // Temp flags.
    const void  *pbToken = NULL;        // Token version of public key.
    ULONG       cbToken = 0;            // Count of bytes in token.
    const void  *pbTmpToken;            // Token version of public key.
    ULONG       cbTmpToken;             // Count of bytes in token.
    bool        fMatch;                 // Did public key or tokens match?

    // Handle special cases upfront.
    if (!szLocale)
        szLocale = "";
    if (!pbPublicKeyOrToken)
        cbPublicKeyOrToken = 0;

    if (!IsAfPublicKey(dwFlags))
    {
        pbToken = pbPublicKeyOrToken;
        cbToken = cbPublicKeyOrToken;
    }

    _ASSERTE(pMiniMd && szName && pmar);
    *pmar = 0;

    cRecs = pMiniMd->getCountAssemblyRefs();

    // Search for the AssemblyRef record.
    for (ULONG i = 1; i <= cRecs; i++)
    {
        pRec = pMiniMd->getAssemblyRef(i);

        szTmp = pMiniMd->getNameOfAssemblyRef(pRec);
        if (strcmp(szTmp, szName))
            continue;

        szTmp = pMiniMd->getLocaleOfAssemblyRef(pRec);
        if (strcmp(szTmp, szLocale))
            continue;

        if (pRec->m_MajorVersion != usMajorVersion)
            continue;
        if (pRec->m_MinorVersion != usMinorVersion)
            continue;
        if (pRec->m_BuildNumber != usBuildNumber)
            continue;
        if (pRec->m_RevisionNumber != usRevisionNumber)
            continue;

        pbTmp = pMiniMd->getPublicKeyOrTokenOfAssemblyRef(pRec, &cbTmp);

        if ((cbPublicKeyOrToken && !cbTmp) ||
            (!cbPublicKeyOrToken && cbTmp))
            continue;

        if (cbTmp)
        {
            // Either ref may be using either a full public key or a token
            // (determined by the ref flags). Must cope with all variations.
            dwTmp = pMiniMd->getFlagsOfAssemblyRef(pRec);
            if (IsAfPublicKey(dwTmp) == IsAfPublicKey(dwFlags))
            {
                // Easy case, they're both in the same form.
                if (cbTmp != cbPublicKeyOrToken || memcmp(pbTmp, pbPublicKeyOrToken, cbTmp))
                    continue;
            }
            else if (IsAfPublicKey(dwTmp))
            {
                // Need to compress target public key to see if it matches.
                if (!StrongNameTokenFromPublicKey((BYTE*)pbTmp,
                                                  cbTmp,
                                                  (BYTE**)&pbTmpToken,
                                                  &cbTmpToken))
                    return StrongNameErrorInfo();
                fMatch = cbTmpToken == cbPublicKeyOrToken && !memcmp(pbTmpToken, pbPublicKeyOrToken, cbTmpToken);
                StrongNameFreeBuffer((BYTE*)pbTmpToken);
                if (!fMatch)
                    continue;
            }
            else
            {
                // Need to compress out public key to see if it matches. We
                // cache the result of this for further iterations.
                if (!pbToken)
                    if (!StrongNameTokenFromPublicKey((BYTE*)pbPublicKeyOrToken,
                                                      cbPublicKeyOrToken,
                                                      (BYTE**)&pbToken,
                                                      &cbToken))
                        return StrongNameErrorInfo();
                if (cbTmp != cbToken || memcmp(pbTmp, pbToken, cbToken))
                    continue;
            }
        }

        if (pbToken && IsAfPublicKey(dwFlags))
            StrongNameFreeBuffer((BYTE*)pbToken);
        *pmar = TokenFromRid(i, mdtAssemblyRef);
        return S_OK;
    }
    if (pbToken && IsAfPublicKey(dwFlags))
        StrongNameFreeBuffer((BYTE*)pbToken);
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindAssemblyRef()

//*******************************************************************************
// Find a File record given the name.
//*******************************************************************************
HRESULT ImportHelper::FindFile(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup.
    LPCUTF8     szName,                 // [IN] name for the File.
    mdFile      *pmf,                   // [OUT] returned File token.
    RID         rid /* = 0 */)          // [IN] Optional rid to be ignored.
{
    ULONG       cRecs;                  // Count of records.
    FileRec     *pRec;                  // Current record being looked at.

    LPCUTF8     szNameTmp;

    _ASSERTE(pMiniMd && szName && pmf);
    *pmf = 0;

    cRecs = pMiniMd->getCountFiles();

    // Search for the File record.
    for (ULONG i = 1; i <= cRecs; i++)
    {
        // For the call from Validator ignore the rid passed in.
        if (i == rid)
            continue;

        pRec = pMiniMd->getFile(i);

        szNameTmp = pMiniMd->getNameOfFile(pRec);
        if (!strcmp(szNameTmp, szName))
        {
            *pmf = TokenFromRid(i, mdtFile);
            return S_OK;
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindFile()

//*******************************************************************************
// Find a ExportedType record given the name.
//*******************************************************************************
HRESULT ImportHelper::FindExportedType(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup.
    LPCUTF8     szNamespace,            // [IN] namespace for the ExportedType.
    LPCUTF8     szName,                 // [IN] name for the ExportedType.
    mdExportedType   tkEnclosingType,        // [IN] token for the enclosing type.
    mdExportedType   *pmct,                  // [OUT] returned ExportedType token.
    RID         rid /* = 0 */)          // [IN] Optional rid to be ignored.
{
    ULONG       cRecs;                  // Count of records.
    ExportedTypeRec  *pRec;                  // Current record being looked at.
    mdToken     tkImpl;
    LPCUTF8     szNamespaceTmp;
    LPCUTF8     szNameTmp;

    _ASSERTE(pMiniMd && szName && pmct);
    *pmct = 0;

    // Treat no namespace as empty string.
    if (!szNamespace)
        szNamespace = "";

    cRecs = pMiniMd->getCountExportedTypes();

    // Search for the ExportedType record.
    for (ULONG i = 1; i <= cRecs; i++)
    {
        // For the call from Validator ignore the rid passed in.
        if (i == rid)
            continue;

        pRec = pMiniMd->getExportedType(i);

        // Handle the case of nested vs. non-nested classes.
        tkImpl = pMiniMd->getImplementationOfExportedType(pRec);
        if (TypeFromToken(tkImpl) == mdtExportedType && !IsNilToken(tkImpl))
        {
            // Current ExportedType being looked at is a nested type, so
            // comparing the implementation token.
            if (tkImpl != tkEnclosingType)
                continue;
        }
        else if (TypeFromToken(tkEnclosingType) == mdtExportedType &&
                 !IsNilToken(tkEnclosingType))
        {
            // ExportedType passed in is nested but the current ExportedType is not.
            continue;
        }

        szNamespaceTmp = pMiniMd->getTypeNamespaceOfExportedType(pRec);
        if (strcmp(szNamespaceTmp, szNamespace))
            continue;

        szNameTmp = pMiniMd->getTypeNameOfExportedType(pRec);
        if (!strcmp(szNameTmp, szName))
        {
            *pmct = TokenFromRid(i, mdtExportedType);
            return S_OK;
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindExportedType()

//*******************************************************************************
// Find a ManifestResource record given the name.
//*******************************************************************************
HRESULT ImportHelper::FindManifestResource(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup.
    LPCUTF8     szName,                 // [IN] name for the ManifestResource.
    mdManifestResource *pmmr,           // [OUT] returned ManifestResource token.
    RID         rid /* = 0 */)          // [IN] Optional rid to be ignored.
{
    ULONG       cRecs;                  // Count of records.
    ManifestResourceRec *pRec;          // Current record being looked at.

    LPCUTF8     szNameTmp;

    _ASSERTE(pMiniMd && szName && pmmr);
    *pmmr = 0;

    cRecs = pMiniMd->getCountManifestResources();

    // Search for the ManifestResource record.
    for (ULONG i = 1; i <= cRecs; i++)
    {
        // For the call from Validator ignore the rid passed in.
        if (i == rid)
            continue;

        pRec = pMiniMd->getManifestResource(i);

        szNameTmp = pMiniMd->getNameOfManifestResource(pRec);
        if (!strcmp(szNameTmp, szName))
        {
            *pmmr = TokenFromRid(i, mdtManifestResource);
            return S_OK;
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT ImportHelper::FindManifestResource()

//****************************************************************************
// Convert tokens contained in an element type
//****************************************************************************
HRESULT ImportHelper::MergeUpdateTokenInFieldSig(       // S_OK or error.
    CMiniMdRW   *pMiniMdAssemEmit,      // [IN] The assembly emit scope.
    CMiniMdRW   *pMiniMdEmit,           // [IN] The emit scope.
    IMetaModelCommon *pCommonAssemImport,// [IN] Assembly scope where the signature is from.
    const void  *pbHashValue,           // [IN] Hash value for the import assembly.
    ULONG       cbHashValue,            // [IN] Size in bytes for the hash value.
    IMetaModelCommon *pCommonImport,    // [IN] The scope to merge into the emit scope.
    PCCOR_SIGNATURE pbSigImp,           // signature from the imported scope
    MDTOKENMAP      *ptkMap,            // Internal OID mapping structure.
    CQuickBytes     *pqkSigEmit,        // [OUT] buffer for translated signature
    ULONG           cbStartEmit,        // [IN] start point of buffer to write to
    ULONG           *pcbImp,            // [OUT] total number of bytes consumed from pbSigImp
    ULONG           *pcbEmit)           // [OUT] total number of bytes write to pqkSigEmit
{

    HRESULT     hr;                     // A result.
    ULONG       cb;                     // count of bytes
    ULONG       cb1;                    // count of bytes
    ULONG       cb2;                    // count of bytes
    ULONG       cbSubTotal;
    ULONG       cbImp;
    ULONG       cbEmit;
    ULONG       cbSrcTotal = 0;         // count of bytes consumed in the imported signature
    ULONG       cbDestTotal = 0;        // count of bytes for the new signature
    ULONG       ulElementType;          // place holder for expanded data
    ULONG       ulData;
    ULONG       ulTemp;
    mdToken     tkRidFrom;              // Original rid
    mdToken     tkRidTo;                // new rid
    int         iData;
    CQuickArray<mdToken> cqaNesters;    // Array of Nester tokens.
    CQuickArray<LPCUTF8> cqaNesterNamespaces;   // Array of Nester Namespaces.
    CQuickArray<LPCUTF8> cqaNesterNames;    // Array of Nester names.

    _ASSERTE(pcbEmit);

    cb = CorSigUncompressData(&pbSigImp[cbSrcTotal], &ulElementType);
    cbSrcTotal += cb;

    // count numbers of modifiers
    while (CorIsModifierElementType((CorElementType) ulElementType))
    {
        cb = CorSigUncompressData(&pbSigImp[cbSrcTotal], &ulElementType);
        cbSrcTotal += cb;
    }

    // copy ELEMENT_TYPE_* over
    cbDestTotal = cbSrcTotal;
    IfFailGo(pqkSigEmit->ReSize(cbStartEmit + cbDestTotal));
    memcpy(((BYTE *)pqkSigEmit->Ptr()) + cbStartEmit, pbSigImp, cbDestTotal);
    switch (ulElementType)
    {
        case ELEMENT_TYPE_VALUEARRAY:
            // syntax for SDARRAY = BaseType <an integer for size>

            // conver the base type for the SDARRAY
            IfFailGo(MergeUpdateTokenInFieldSig(
                pMiniMdAssemEmit,           // The assembly emit scope.
                pMiniMdEmit,                // The emit scope.
                pCommonAssemImport,         // The assembly scope where the signature is from.
                pbHashValue,                // Hash value for the import assembly.
                cbHashValue,                // Size in bytes for the hash value.
                pCommonImport,              // The scope to merge into the emit scope.
                &pbSigImp[cbSrcTotal],      // signature from the imported scope
                ptkMap,                     // Internal OID mapping structure.
                pqkSigEmit,                 // [OUT] buffer for translated signature
                cbStartEmit + cbSrcTotal,   // [IN] start point of buffer to write to
                &cbImp,                     // [OUT] total number of bytes consumed from pbSigImp
                &cbEmit));                  // [OUT] total number of bytes write to pqkSigEmit
            cbSrcTotal += cbImp;
            cbDestTotal += cbEmit;

            // after the base type, it is followed by an integer indicating the size
            // of the array
            //
            cb = CorSigUncompressData(&pbSigImp[cbSrcTotal], &ulData);

            IfFailGo(pqkSigEmit->ReSize(cbStartEmit + cbDestTotal + cb));
            cb1 = CorSigCompressData(ulData, ((BYTE *)pqkSigEmit->Ptr()) + cbStartEmit + cbDestTotal);
            _ASSERTE(cb == cb1);

            cbSrcTotal = cbSrcTotal + cb;
            cbDestTotal = cbDestTotal + cb1;
            break;

        case ELEMENT_TYPE_SZARRAY:
            // syntax : SZARRAY <BaseType>

            // conver the base type for the SZARRAY or GENERICARRAY
            IfFailGo(MergeUpdateTokenInFieldSig(
                pMiniMdAssemEmit,           // The assembly emit scope.
                pMiniMdEmit,                // The emit scope.
                pCommonAssemImport,         // The assembly scope where the signature is from.
                pbHashValue,                // Hash value for the import assembly.
                cbHashValue,                // Size in bytes for the hash value.
                pCommonImport,              // scope to merge into the emit scope.
                &pbSigImp[cbSrcTotal],      // from the imported scope
                ptkMap,                     // OID mapping structure.
                pqkSigEmit,                 // [OUT] buffer for translated signature
                cbStartEmit + cbDestTotal,  // [IN] start point of buffer to write to
                &cbImp,                     // [OUT] total number of bytes consumed from pbSigImp
                &cbEmit));                  // [OUT] total number of bytes write to pqkSigEmit
            cbSrcTotal += cbImp;
            cbDestTotal += cbEmit;
            break;

        case ELEMENT_TYPE_ARRAY:
            // syntax : ARRAY BaseType <rank> [i size_1... size_i] [j lowerbound_1 ... lowerbound_j]

            // conver the base type for the MDARRAY
            IfFailGo(MergeUpdateTokenInFieldSig(
                pMiniMdAssemEmit,           // The assembly emit scope.
                pMiniMdEmit,                // The emit scope.
                pCommonAssemImport,         // The assembly scope where the signature is from.
                pbHashValue,                // Hash value for the import assembly.
                cbHashValue,                // Size in bytes for the hash value.
                pCommonImport,              // The scope to merge into the emit scope.
                &pbSigImp[cbSrcTotal],      // signature from the imported scope
                ptkMap,                     // Internal OID mapping structure.
                pqkSigEmit,                 // [OUT] buffer for translated signature
                cbStartEmit + cbSrcTotal,   // [IN] start point of buffer to write to
                &cbImp,                     // [OUT] total number of bytes consumed from pbSigImp
                &cbEmit));                  // [OUT] total number of bytes write to pqkSigEmit
            cbSrcTotal += cbImp;
            cbDestTotal += cbEmit;

            // Parse for the rank
            cbSubTotal = CorSigUncompressData(&pbSigImp[cbSrcTotal], &ulData);

            // if rank == 0, we are done
            if (ulData != 0)
            {
                // any size of dimension specified?
                cb = CorSigUncompressData(&pbSigImp[cbSrcTotal + cbSubTotal], &ulData);
                cbSubTotal += cb;

                while (ulData--)
                {
                    cb = CorSigUncompressData(&pbSigImp[cbSrcTotal + cbSubTotal], &ulTemp);
                    cbSubTotal += cb;
                }

                // any lower bound specified?
                cb = CorSigUncompressData(&pbSigImp[cbSrcTotal + cbSubTotal], &ulData);
                cbSubTotal += cb;

                while (ulData--)
                {
                    cb = CorSigUncompressSignedInt(&pbSigImp[cbSrcTotal + cbSubTotal], &iData);
                    cbSubTotal += cb;
                }
            }

            // cbSubTotal is now the number of bytes still left to move over
            // cbSrcTotal is where bytes start on the pbSigImp to be copied over
            // cbStartEmit + cbDestTotal is where the destination of copy

            IfFailGo(pqkSigEmit->ReSize(cbStartEmit + cbDestTotal + cbSubTotal));
            memcpy(((BYTE *)pqkSigEmit->Ptr())+cbStartEmit + cbDestTotal, &pbSigImp[cbSrcTotal], cbSubTotal);

            cbSrcTotal = cbSrcTotal + cbSubTotal;
            cbDestTotal = cbDestTotal + cbSubTotal;

            break;
        case ELEMENT_TYPE_FNPTR:
            // function pointer is followed by another complete signature
            IfFailGo(MergeUpdateTokenInSig(
                pMiniMdAssemEmit,           // The assembly emit scope.
                pMiniMdEmit,                // The emit scope.
                pCommonAssemImport,         // The assembly scope where the signature is from.
                pbHashValue,                // Hash value for the import assembly.
                cbHashValue,                // Size in bytes for the hash value.
                pCommonImport,              // The scope to merge into the emit scope.
                &pbSigImp[cbSrcTotal],      // signature from the imported scope
                ptkMap,                     // Internal OID mapping structure.
                pqkSigEmit,                 // [OUT] buffer for translated signature
                cbStartEmit + cbDestTotal,  // [IN] start point of buffer to write to
                &cbImp,                     // [OUT] total number of bytes consumed from pbSigImp
                &cbEmit));                  // [OUT] total number of bytes write to pqkSigEmit
            cbSrcTotal += cbImp;
            cbDestTotal += cbEmit;
            break;
        case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_CMOD_REQD:
        case ELEMENT_TYPE_CMOD_OPT:

            // syntax for CLASS = ELEMENT_TYPE_CLASS <rid>
            // syntax for VALUE_CLASS = ELEMENT_TYPE_VALUECLASS <rid>

            // now get the embedded typeref token
            cb = CorSigUncompressToken(&pbSigImp[cbSrcTotal], &tkRidFrom);

            // Map the ulRidFrom to ulRidTo
            if (ptkMap)
            {
                // mdtBaseType does not record in the map. It is unique across modules
                if ( TypeFromToken(tkRidFrom) == mdtBaseType )
                {
                    tkRidTo = tkRidFrom;
                }
                else
                {
                    IfFailGo( ptkMap->Remap(tkRidFrom, &tkRidTo) );
                }
            }
            else
            {
                // If the token is a TypeDef or a TypeRef, get/create the
                // ResolutionScope for the outermost TypeRef.
                if (TypeFromToken(tkRidFrom) == mdtTypeDef)
                {
                    IfFailGo(ImportTypeDef(pMiniMdAssemEmit,
                                           pMiniMdEmit,
                                           pCommonAssemImport,
                                           pbHashValue,
                                           cbHashValue,
                                           pCommonImport,
                                           tkRidFrom,
                                           true,    // Optimize to TypeDef if emit and import scopes are identical.
                                           &tkRidTo));
                }
                else if (TypeFromToken(tkRidFrom) == mdtTypeRef)
                {
                    IfFailGo(ImportTypeRef(pMiniMdAssemEmit,
                                           pMiniMdEmit,
                                           pCommonAssemImport,
                                           pbHashValue,
                                           cbHashValue,
                                           pCommonImport,
                                           tkRidFrom,
                                           &tkRidTo));
                }
                else if ( TypeFromToken(tkRidFrom) == mdtTypeSpec )
                {
                    // copy over the TypeSpec
                    PCCOR_SIGNATURE pvTypeSpecSig;
                    ULONG           cbTypeSpecSig;
                    CQuickBytes qkTypeSpecSigEmit;
                    ULONG           cbTypeSpecEmit;

                    pCommonImport->CommonGetTypeSpecProps(tkRidFrom, &pvTypeSpecSig, &cbTypeSpecSig);

                                        // Translate the typespec signature before look up
                    IfFailGo(MergeUpdateTokenInFieldSig(
                        pMiniMdAssemEmit,           // The assembly emit scope.
                        pMiniMdEmit,                // The emit scope.
                        pCommonAssemImport,         // The assembly scope where the signature is from.
                        pbHashValue,                // Hash value for the import assembly.
                        cbHashValue,                // Size in bytes for the hash value.
                        pCommonImport,              // The scope to merge into the emit scope.
                        pvTypeSpecSig,              // signature from the imported scope
                        ptkMap,                     // Internal OID mapping structure.
                        &qkTypeSpecSigEmit,         // [OUT] buffer for translated signature
                        0,                          // start from first byte of TypeSpec signature
                        0,                          // don't care how many bytes are consumed
                        &cbTypeSpecEmit) );         // [OUT] total number of bytes write to pqkSigEmit

                    hr = FindTypeSpec(pMiniMdEmit,
                                      (PCCOR_SIGNATURE) (qkTypeSpecSigEmit.Ptr()),
                                      cbTypeSpecEmit,
                                      &tkRidTo);

                    if ( hr == CLDB_E_RECORD_NOTFOUND )
                    {
                        // Create TypeSpec record.
                        TypeSpecRec     *pRecEmit;

                        IfNullGo(pRecEmit = pMiniMdEmit->AddTypeSpecRecord((ULONG *)&tkRidTo));

                        IfFailGo(pMiniMdEmit->PutBlob(
                            TBL_TypeSpec,
                            TypeSpecRec::COL_Signature,
                            pRecEmit,
                            (PCCOR_SIGNATURE) (qkTypeSpecSigEmit.Ptr()),
                            cbTypeSpecEmit));
                        tkRidTo = TokenFromRid( tkRidTo, mdtTypeSpec );
                        IfFailGo(pMiniMdEmit->UpdateENCLog(tkRidTo));
                    }
                    IfFailGo( hr );
                }
                else
                {
                    _ASSERTE( TypeFromToken(tkRidFrom) == mdtBaseType );

                    // base type is unique across module
                    tkRidTo = tkRidFrom;
                }
            }

            // How many bytes the new rid will consume?
            cb1 = CorSigCompressToken(tkRidTo, &ulData);

            // ensure buffer is big enough
            IfFailGo(pqkSigEmit->ReSize(cbStartEmit + cbDestTotal + cb1));

            // store the new token
            cb2 = CorSigCompressToken(
                    tkRidTo,
                    (ULONG *)( ((BYTE *)pqkSigEmit->Ptr()) + cbStartEmit + cbDestTotal) );

            // inconsistency on CorSigCompressToken and CorSigUncompressToken
            _ASSERTE(cb1 == cb2);

            cbSrcTotal = cbSrcTotal + cb;
            cbDestTotal = cbDestTotal + cb1;

            if ( ulElementType == ELEMENT_TYPE_CMOD_REQD ||
                 ulElementType == ELEMENT_TYPE_CMOD_OPT)
            {
                // need to skip over the base type
                IfFailGo(MergeUpdateTokenInFieldSig(
                    pMiniMdAssemEmit,           // The assembly emit scope.
                    pMiniMdEmit,                // The emit scope.
                    pCommonAssemImport,         // The assembly scope where the signature is from.
                    pbHashValue,                // Hash value for the import assembly.
                    cbHashValue,                // Size in bytes for the hash value.
                    pCommonImport,              // The scope to merge into the emit scope.
                    &pbSigImp[cbSrcTotal],      // signature from the imported scope
                    ptkMap,                     // Internal OID mapping structure.
                    pqkSigEmit,                 // [OUT] buffer for translated signature
                    cbStartEmit + cbDestTotal,  // [IN] start point of buffer to write to
                    &cbImp,                     // [OUT] total number of bytes consumed from pbSigImp
                    &cbEmit));                  // [OUT] total number of bytes write to pqkSigEmit
                cbSrcTotal += cbImp;
                cbDestTotal += cbEmit;
            }

            break;
        default:
            _ASSERTE(ulElementType < ELEMENT_TYPE_MAX);
            _ASSERTE(ulElementType != ELEMENT_TYPE_PTR && ulElementType != ELEMENT_TYPE_BYREF);
            _ASSERTE(cbSrcTotal == cbDestTotal);

            if (ulElementType >= ELEMENT_TYPE_MAX)
                IfFailGo(META_E_BAD_SIGNATURE);

            break;
    }
    if (pcbImp)
        *pcbImp = cbSrcTotal;
    *pcbEmit = cbDestTotal;

ErrExit:
    return hr;
} // HRESULT ImportHelper::MergeUpdateTokenInFieldSig()


//****************************************************************************
// convert tokens contained in a COM+ signature
//****************************************************************************
HRESULT ImportHelper::MergeUpdateTokenInSig(// S_OK or error.
    CMiniMdRW   *pMiniMdAssemEmit,      // [IN] The assembly emit scope.
    CMiniMdRW   *pMiniMdEmit,           // [IN] The emit scope.
    IMetaModelCommon *pCommonAssemImport,// [IN] Assembly scope where the signature is from.
    const void  *pbHashValue,           // [IN] Hash value for the import assembly.
    ULONG       cbHashValue,            // [IN] Size in bytes for the hash value.
    IMetaModelCommon *pCommonImport,    // [IN] The scope to merge into the emit scope.
    PCCOR_SIGNATURE pbSigImp,           // signature from the imported scope
    MDTOKENMAP      *ptkMap,            // Internal OID mapping structure.
    CQuickBytes     *pqkSigEmit,        // [OUT] translated signature
    ULONG           cbStartEmit,        // [IN] start point of buffer to write to
    ULONG           *pcbImp,            // [OUT] total number of bytes consumed from pbSigImp
    ULONG           *pcbEmit)           // [OUT] total number of bytes write to pqkSigEmit
{
    HRESULT     hr = NOERROR;           // A result.
    ULONG       cb;                     // count of bytes
    ULONG       cb1;
    ULONG       cbSrcTotal = 0;         // count of bytes consumed in the imported signature
    ULONG       cbDestTotal = 0;        // count of bytes for the new signature
    ULONG       cbEmit;                 // count of bytes consumed in the imported signature
    ULONG       cbImp;                  // count of bytes for the new signature
    ULONG       cbField = 0;            // count of bytes
    ULONG       cArg = 0;               // count of arguments in the signature
    ULONG       callingconv;

    _ASSERTE(pcbEmit && pqkSigEmit && pbSigImp);

    // calling convention
    cb = CorSigUncompressData(&pbSigImp[cbSrcTotal], &callingconv);
    _ASSERTE((callingconv & IMAGE_CEE_CS_CALLCONV_MASK) < IMAGE_CEE_CS_CALLCONV_MAX);

    // skip over calling convention
    cbSrcTotal += cb;

    if (isCallConv(callingconv, IMAGE_CEE_CS_CALLCONV_FIELD))
    {
        // It is a FieldRef
        cb1 = CorSigCompressData(callingconv, ((BYTE *)pqkSigEmit->Ptr()) + cbStartEmit);

        // compression and uncompression better match
        _ASSERTE(cb == cb1);

        cbDestTotal = cbSrcTotal = cb;
        IfFailGo(MergeUpdateTokenInFieldSig(
            pMiniMdAssemEmit,
            pMiniMdEmit,
            pCommonAssemImport,
            pbHashValue,
            cbHashValue,
            pCommonImport,
            &pbSigImp[cbSrcTotal],
            ptkMap,
            pqkSigEmit,                     // output buffer to hold the new sig for the field
            cbStartEmit + cbDestTotal,      // number of bytes already in pqkSigDest
            &cbImp,                         // number of bytes consumed from imported signature
            &cbEmit));                      // number of bytes write to the new signature
        *pcbEmit = cbDestTotal + cbEmit;
    }
    else
    {

        // It is a MethodRef

        // count of argument
        cb = CorSigUncompressData(&pbSigImp[cbSrcTotal], &cArg);
        cbSrcTotal += cb;

        // move over the calling convention and the count of arguments
        IfFailGo(pqkSigEmit->ReSize(cbStartEmit + cbSrcTotal));
        memcpy(((BYTE *)pqkSigEmit->Ptr()) + cbStartEmit, pbSigImp, cbSrcTotal);
        cbDestTotal = cbSrcTotal;

        if ( !isCallConv(callingconv, IMAGE_CEE_CS_CALLCONV_LOCAL_SIG) )
        {
                // LocalVar sig does not have return type
                // process the return type
                IfFailGo(MergeUpdateTokenInFieldSig(
                pMiniMdAssemEmit,
                pMiniMdEmit,
                pCommonAssemImport,
                pbHashValue,
                cbHashValue,
                pCommonImport,
                &pbSigImp[cbSrcTotal],
                ptkMap,
                pqkSigEmit,                     // output buffer to hold the new sig for the field
                cbStartEmit + cbDestTotal,      // number of bytes already in pqkSigDest
                &cbImp,                         // number of bytes consumed from imported signature
                &cbEmit));                      // number of bytes write to the new signature

            // advance the count
            cbSrcTotal += cbImp;
            cbDestTotal += cbEmit;
        }


        while (cArg)
        {
            // process every argument
            IfFailGo(MergeUpdateTokenInFieldSig(
                pMiniMdAssemEmit,
                pMiniMdEmit,
                pCommonAssemImport,
                pbHashValue,
                cbHashValue,
                pCommonImport,
                &pbSigImp[cbSrcTotal],
                ptkMap,
                pqkSigEmit,                 // output buffer to hold the new sig for the field
                cbStartEmit + cbDestTotal,
                &cbImp,                     // number of bytes consumed from imported signature
                &cbEmit));                  // number of bytes write to the new signature
            cbSrcTotal += cbImp;
            cbDestTotal += cbEmit;
            cArg--;
        }

        // total of number of bytes consumed from imported signature
        if (pcbImp)
            *pcbImp = cbSrcTotal;

        // total number of bytes emitted by this function call to the emitting signature
        *pcbEmit = cbDestTotal;
    }

ErrExit:
    return hr;
} // HRESULT ImportHelper::MergeUpdateTokenInSig()

//****************************************************************************
// Given a TypeDef or a TypeRef, return the Nesting hierarchy.  The first
// element in the returned array always refers to the class token passed and
// the nesting hierarchy expands outwards from there.
//****************************************************************************
HRESULT ImportHelper::GetNesterHierarchy(
    IMetaModelCommon *pCommon,          // Scope in which to find the hierarchy.
    mdToken     tk,                     // TypeDef/TypeRef whose hierarchy is needed.
    CQuickArray<mdToken> &cqaNesters,   // Array of Nesters.
    CQuickArray<LPCUTF8> &cqaNamespaces,    // Names of the nesters.
    CQuickArray<LPCUTF8> &cqaNames)     // Namespaces of the nesters.
{
    _ASSERTE(pCommon &&
             (TypeFromToken(tk) == mdtTypeDef ||
              TypeFromToken(tk) == mdtTypeRef) &&
             !IsNilToken(tk));

    if (TypeFromToken(tk) == mdtTypeDef)
    {
        return GetTDNesterHierarchy(pCommon,
                                    tk,
                                    cqaNesters,
                                    cqaNamespaces,
                                    cqaNames);
    }
    else
    {
        return GetTRNesterHierarchy(pCommon,
                                    tk,
                                    cqaNesters,
                                    cqaNamespaces,
                                    cqaNames);
    }
}   // HRESULT ImportHelper::GetNesterHierarchy()

//****************************************************************************
// Get Nesting hierarchy given a TypeDef.
//****************************************************************************
HRESULT ImportHelper::GetTDNesterHierarchy(
    IMetaModelCommon *pCommon,          // Scope in which to find the hierarchy.
    mdTypeDef       td,                 // TypeDef whose hierarchy is needed.
    CQuickArray<mdTypeDef> &cqaTdNesters,// Array of Nesters.
    CQuickArray<LPCUTF8> &cqaNamespaces,    // Namespaces of the nesters.
    CQuickArray<LPCUTF8> &cqaNames)     // Names of the nesters.
{
    LPCUTF8     szName, szNamespace;
    DWORD       dwFlags;
    mdTypeDef   tdNester;
    ULONG       ulNesters;
    HRESULT     hr = NOERROR;

    _ASSERTE(pCommon &&
             TypeFromToken(td) == mdtTypeDef &&
             !IsNilToken(td));

    // Set current Nester index to 0.
    ulNesters = 0;
    // The first element in the hierarchy is the TypeDef itself.
    tdNester = td;
    // Bogus initialization to kick off the while loop.
    dwFlags = tdNestedPublic;
    // Loop as long as the TypeDef is a Nested TypeDef.
    while (IsTdNested(dwFlags))
    {
        if (InvalidRid(tdNester))
            IfFailGo(CLDB_E_RECORD_NOTFOUND);
        // Get the name and namespace for the TypeDef.
        pCommon->CommonGetTypeDefProps(tdNester,
                                &szNamespace, &szName, &dwFlags);

        // Update the dynamic arrays.
        ulNesters++;

        IfFailGo(cqaTdNesters.ReSize(ulNesters));
        cqaTdNesters[ulNesters-1] = tdNester;

        IfFailGo(cqaNamespaces.ReSize(ulNesters));
        cqaNamespaces[ulNesters-1] = szNamespace;

        IfFailGo(cqaNames.ReSize(ulNesters));
        cqaNames[ulNesters-1] = szName;

        tdNester = pCommon->CommonGetEnclosingClassOfTypeDef(tdNester);
    }
    // Outermost class must have enclosing of Nil.
    _ASSERTE(IsNilToken(tdNester));
ErrExit:
    return hr;
}   // HRESULT ImportHelper::GetTDNesterHierarchy()


//****************************************************************************
// Get Nesting hierarchy given a TypeRef.
//****************************************************************************
HRESULT ImportHelper::GetTRNesterHierarchy(
    IMetaModelCommon *pCommon,          // [IN] Scope in which to find the hierarchy.
    mdTypeRef   tr,                     // [IN] TypeRef whose hierarchy is needed.
    CQuickArray<mdTypeRef> &cqaTrNesters,// [OUT] Array of Nesters.
    CQuickArray<LPCUTF8> &cqaNamespaces,    // [OUT] Namespaces of the nesters.
    CQuickArray<LPCUTF8> &cqaNames)    // [OUT] Names of the nesters.
{
    LPCUTF8     szNamespace;
    LPCUTF8     szName;
    mdTypeRef   trNester;
    mdToken     tkResolutionScope;
    ULONG       ulNesters;
    HRESULT     hr = S_OK;

    _ASSERTE(pCommon &&
             TypeFromToken(tr) == mdtTypeRef &&
             !IsNilToken(tr));

    // Set current Nester index to 0.
    ulNesters = 0;
    // The first element in the hierarchy is the TypeRef itself.
    trNester = tr;
    // Loop as long as the TypeRef is a Nested TypeRef.
    while (TypeFromToken(trNester) == mdtTypeRef && !IsNilToken(trNester))
    {
        // Get the name and namespace for the TypeDef.
        pCommon->CommonGetTypeRefProps(trNester,
                                       &szNamespace,
                                       &szName,
                                       &tkResolutionScope);

        // Update the dynamic arrays.
        ulNesters++;

        IfFailGo(cqaTrNesters.ReSize(ulNesters));
        cqaTrNesters[ulNesters-1] = trNester;

        IfFailGo(cqaNamespaces.ReSize(ulNesters));
        cqaNamespaces[ulNesters-1] = szNamespace;

        IfFailGo(cqaNames.ReSize(ulNesters));
        cqaNames[ulNesters-1] = szName;

        trNester = tkResolutionScope;
    }
ErrExit:
    return hr;
}   // HRESULT ImportHelper::GetTRNesterHierarchy()

//****************************************************************************
// Create the Nesting hierarchy given the array of TypeRef names.  The first
// TypeRef in the array is the innermost TypeRef.
//****************************************************************************
HRESULT ImportHelper::CreateNesterHierarchy(
    CMiniMdRW   *pMiniMdEmit,           // [IN] Emit scope to create the Nesters in.
    CQuickArray<LPCUTF8> &cqaNesterNamespaces,   // [IN] Array of Nester namespaces.
    CQuickArray<LPCUTF8> &cqaNesterNames,  // [IN] Array of Nester names.
    mdToken     tkResolutionScope,      // [IN] ResolutionScope for the innermost TypeRef.
    mdTypeRef   *ptr)                   // [OUT] Token for the innermost TypeRef.
{
    TypeRefRec  *pRecEmit;
    ULONG       iRecord;
    LPCUTF8     szName;
    LPCUTF8     szNamespace;
    mdTypeRef   trNester;
    mdTypeRef   trCur;
    ULONG       ulNesters;
    HRESULT     hr = S_OK;

    _ASSERTE(cqaNesterNames.Size() == cqaNesterNamespaces.Size() &&
             cqaNesterNames.Size());

    // Initialize the output parameter.
    *ptr = mdTypeRefNil;

    // Get count of Nesters in the hierarchy.
    ulNesters = (ULONG)cqaNesterNames.Size();

    // For each nester try to find the corresponding TypeRef in the emit scope.
    // For the outermost TypeRef, ResolutionScope is what's passed in.
    if (tkResolutionScope == mdTokenNil)
        trNester = mdTypeRefNil;
    else
        trNester = tkResolutionScope;
    for (ULONG ulCurNester = ulNesters-1; ulCurNester != -1; ulCurNester--)
    {
        hr = FindTypeRefByName(pMiniMdEmit,
                               trNester,
                               cqaNesterNamespaces[ulCurNester],
                               cqaNesterNames[ulCurNester],
                               &trCur);
        if (hr == CLDB_E_RECORD_NOTFOUND)
            break;
        else
            IfFailGo(hr);
        trNester = trCur;
    }
    if (SUCCEEDED(hr))
        *ptr = trNester;
    else if ( hr == CLDB_E_RECORD_NOTFOUND )
    {
        // Create TypeRef records for the part of the hierarchy for which
        // TypeRefs are not already present.
        for (;ulCurNester != -1; ulCurNester--)
        {
            szName = cqaNesterNames[ulCurNester];
            szNamespace = cqaNesterNamespaces[ulCurNester];

            IfNullGo(pRecEmit = pMiniMdEmit->AddTypeRefRecord(&iRecord));
            if (szNamespace && szNamespace[0] != '\0')
            {
                // only put the namespace if it is not an empty string and not NULL
                IfFailGo(pMiniMdEmit->PutString(TBL_TypeRef, TypeRefRec::COL_Namespace,
                                                pRecEmit, szNamespace));
            }
            IfFailGo(pMiniMdEmit->PutString(TBL_TypeRef, TypeRefRec::COL_Name,
                                            pRecEmit, szName));
            IfFailGo(pMiniMdEmit->PutToken(TBL_TypeRef,
                        TypeRefRec::COL_ResolutionScope, pRecEmit, trNester));
            
            trNester = TokenFromRid(iRecord, mdtTypeRef);
            IfFailGo(pMiniMdEmit->UpdateENCLog(trNester));
            
            // Hash the name.
            IfFailGo(pMiniMdEmit->AddNamedItemToHash(TBL_TypeRef, trNester, szName, 0));
        }
        *ptr = trNester;
    }
    else
        IfFailGo(hr);
ErrExit:
    return hr;
}   // HRESULT ImportHelper::CreateNesterHierarchy()

//****************************************************************************
// Given the arrays of names and namespaces for the Nested Type hierarchy,
// find the innermost TypeRef token.  The arrays start with the innermost
// TypeRefs and go outwards.
//****************************************************************************
HRESULT ImportHelper::FindNestedTypeRef(
    CMiniMdRW   *pMiniMd,               // [IN] Scope in which to find the TypeRef.
    CQuickArray<LPCUTF8> &cqaNesterNamespaces,  // [IN] Array of Names.
    CQuickArray<LPCUTF8> &cqaNesterNames,   // [IN] Array of Namespaces.
    mdToken     tkResolutionScope,      // [IN] Resolution scope for the outermost TypeRef.
    mdTypeRef   *ptr)                   // [OUT] Inner most TypeRef token.
{
    ULONG       ulNesters;
    ULONG       ulCurNester;
    HRESULT     hr = S_OK;

    _ASSERTE(cqaNesterNames.Size() == cqaNesterNamespaces.Size() &&
             cqaNesterNames.Size());

    // Set the output parameter to Nil token.
    *ptr = mdTokenNil;

    // Get count in the hierarchy, the give TypeDef included.
    ulNesters = (ULONG)cqaNesterNames.Size();

    // For each nester try to find the corresponding TypeRef in
    // the emit scope.  For the outermost TypeDef enclosing class is Nil.
    for (ulCurNester = ulNesters-1; ulCurNester != -1; ulCurNester--)
    {
        IfFailGo(FindTypeRefByName(pMiniMd,
                                   tkResolutionScope,
                                   cqaNesterNamespaces[ulCurNester],
                                   cqaNesterNames[ulCurNester],
                                   &tkResolutionScope));
    }
    *ptr = tkResolutionScope;
ErrExit:
    return hr;
}   // HRESULT ImportHelper::FindNestedTypeRef()


//****************************************************************************
// Given the arrays of names and namespaces for the Nested Type hierarchy,
// find the innermost TypeDef token.  The arrays start with the innermost
// TypeDef and go outwards.
//****************************************************************************
HRESULT ImportHelper::FindNestedTypeDef(
    CMiniMdRW   *pMiniMd,               // [IN] Scope in which to find the TypeRef.
    CQuickArray<LPCUTF8> &cqaNesterNamespaces,   // [IN] Array of Namespaces.
    CQuickArray<LPCUTF8> &cqaNesterNames,    // [IN] Array of Names.
    mdTypeDef   tdNester,               // [IN] Enclosing class for the Outermost TypeDef.
    mdTypeDef   *ptd)                   // [OUT] Inner most TypeRef token.
{
    ULONG       ulNesters;
    ULONG       ulCurNester;
    HRESULT     hr = S_OK;

    _ASSERTE(cqaNesterNames.Size() == cqaNesterNamespaces.Size() &&
             cqaNesterNames.Size());

    // Set the output parameter to Nil token.
    *ptd = mdTokenNil;

    // Get count in the hierarchy, the give TypeDef included.
    ulNesters = (ULONG)cqaNesterNames.Size();

    // For each nester try to find the corresponding TypeRef in
    // the emit scope.  For the outermost TypeDef enclosing class is Nil.
    for (ulCurNester = ulNesters-1; ulCurNester != -1; ulCurNester--)
    {
        IfFailGo(FindTypeDefByName(pMiniMd,
                                   cqaNesterNamespaces[ulCurNester],
                                   cqaNesterNames[ulCurNester],
                                   tdNester,
                                   &tdNester));
    }
    *ptd = tdNester;
ErrExit:
    return hr;
}   // HRESULT ImportHelper::FindNestedTypeDef()



//****************************************************************************
// Given the TypeDef and the corresponding assembly and module import scopes,
// create a corresponding TypeRef in the given emit scope.
//****************************************************************************
HRESULT ImportHelper::ImportTypeDef(
    CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Assembly emit scope.
    CMiniMdRW   *pMiniMdEmit,           // [IN] Module emit scope.
    IMetaModelCommon *pCommonAssemImport, // [IN] Assembly import scope.
    const void  *pbHashValue,           // [IN] Hash value for import assembly.
    ULONG       cbHashValue,            // [IN] Size in bytes of hash value.
    IMetaModelCommon *pCommonImport,    // [IN] Module import scope.
    mdTypeDef   tdImport,               // [IN] Imported TypeDef.
    bool        bReturnTd,              // [IN] If the import and emit scopes are identical, return the TypeDef.
    mdToken     *ptkType)               // [OUT] Output token for the imported type in the emit scope.
{
    CQuickArray<mdTypeDef>  cqaNesters;
    CQuickArray<LPCUTF8> cqaNesterNames;
    CQuickArray<LPCUTF8> cqaNesterNamespaces;
    GUID        nullguid = GUID_NULL;
    GUID        *pMvidAssemImport = &nullguid;
    GUID        *pMvidAssemEmit = &nullguid;
    GUID        *pMvidImport = &nullguid;
    GUID        *pMvidEmit = &nullguid;
    GUID        GuidImport = GUID_NULL;
    LPCUTF8     szModuleImport;
    mdToken     tkOuterRes = mdTokenNil;
    HRESULT     hr = S_OK;
    BOOL        bBCL = false;

    _ASSERTE(pMiniMdEmit && pCommonImport && ptkType);
    _ASSERTE(TypeFromToken(tdImport) == mdtTypeDef && tdImport != mdTypeDefNil);

    // Get MVIDs for import and emit, assembly and module scopes.
    if (pCommonAssemImport)
        pCommonAssemImport->CommonGetScopeProps(0, &pMvidAssemImport);
    pCommonImport->CommonGetScopeProps(&szModuleImport, &pMvidImport);
    if (pMiniMdAssemEmit)
        static_cast<IMetaModelCommon*>(pMiniMdAssemEmit)->CommonGetScopeProps(0, &pMvidAssemEmit);
    static_cast<IMetaModelCommon*>(pMiniMdEmit)->CommonGetScopeProps(0, &pMvidEmit);

    if (pCommonAssemImport == NULL && strcmp(szModuleImport, COM_RUNTIME_LIBRARY) == 0) 
    {
        HRESULT         hr;                     // A result.
        const BYTE      *pBlob;                 // Blob with dispid.
        ULONG           cbBlob;                 // Length of blob.
        WCHAR           wzBlob[40];             // Wide char format of guid.
        int             ix;                     // Loop control.

        hr = pCommonImport->CommonGetCustomAttributeByName(1, INTEROP_GUID_TYPE, (const void **)&pBlob, &cbBlob);
        if (hr != S_FALSE)
        {
            // Should be in format.  Total length == 41
            // <0x0001><0x24>01234567-0123-0123-0123-001122334455<0x0000>
            if ((cbBlob == 41) || (*(USHORT*)pBlob == 1))
            {
                for (ix=1; ix<=36; ++ix)
                    wzBlob[ix] = pBlob[ix+2];
                wzBlob[0] = '{';
                wzBlob[37] = '}';
                wzBlob[38] = 0;
                hr = IIDFromString(wzBlob, &GuidImport);
            }
        }
        bBCL = (GuidImport == LIBID_ComPlusRuntime);
    }

    // Compute the ResolutionScope for the imported type.
    if (bBCL)
    {
        // This is the case that we are referring to mscorlib.dll but client does not provide the manifest for
        // mscorlib.dll!! Do not generate ModuleRef to the mscorlib.dll. But instead we should just leave the
        // ResolutionScope empty
        tkOuterRes = mdTokenNil;
    }
    else if (*pMvidAssemImport == *pMvidAssemEmit && *pMvidImport == *pMvidEmit)
    {
        // The TypeDef is in the same Assembly and the Same scope.
        if (bReturnTd)
        {
            *ptkType = tdImport;
            goto ErrExit;
        }
        else
            tkOuterRes = TokenFromRid(1, mdtModule);
    }
    else if (*pMvidAssemImport == *pMvidAssemEmit && *pMvidImport != *pMvidEmit)
    {
        // The TypeDef is in the same Assembly but a different module.
        
        // Create a ModuleRef corresponding to the import scope.
        IfFailGo(CreateModuleRefFromScope(pMiniMdEmit, pCommonImport, &tkOuterRes));
    }
    else if (*pMvidAssemImport != *pMvidAssemEmit)
    {
        if (pCommonAssemImport)
        {
            // The TypeDef is from a different Assembly.

            // Import and Emit scopes can't be identical and be from different
            // Assemblies at the same time.
            _ASSERTE(*pMvidImport != *pMvidEmit &&
                     "Import scope can't be identical to the Emit scope and be from a different Assembly at the same time.");

            _ASSERTE(pCommonAssemImport);

            // Create an AssemblyRef corresponding to the import scope.
            IfFailGo(CreateAssemblyRefFromAssembly(pMiniMdAssemEmit,
                                                   pMiniMdEmit,
                                                   pCommonAssemImport,
                                                   pbHashValue,
                                                   cbHashValue,
                                                   &tkOuterRes));
        }
        else
        {
            // @FUTURE: review this fix! We may want to return error in the future.
            // This is to enable smc to reference mscorlib.dll while it does not have the manifest for mscorlib.dll opened.
            // Create a Nil ResolutionScope to the TypeRef.
            tkOuterRes = mdTokenNil;
        }
    }

    // Get the nesting hierarchy for the Type from the import scope and create
    // the corresponding Type hierarchy in the emit scope.  Note that the non-
    // nested class case simply folds into this scheme.

    IfFailGo(GetNesterHierarchy(pCommonImport,
                                tdImport,
                                cqaNesters,
                                cqaNesterNamespaces,
                                cqaNesterNames));

    IfFailGo(CreateNesterHierarchy(pMiniMdEmit,
                                   cqaNesterNamespaces,
                                   cqaNesterNames,
                                   tkOuterRes,
                                   ptkType));
ErrExit:
    return hr;
}   // HRESULT ImportHelper::ImportTypeDef()

//****************************************************************************
// Given the TypeRef and the corresponding assembly and module import scopes,
// return the corresponding token in the given emit scope.
// @FUTURE:  Should we look at visibility flags on ExportedTypes and TypeDefs when
// handling references across Assemblies?
//****************************************************************************
HRESULT ImportHelper::ImportTypeRef(
    CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Assembly emit scope.
    CMiniMdRW   *pMiniMdEmit,           // [IN] Module emit scope.
    IMetaModelCommon *pCommonAssemImport, // [IN] Assembly import scope.
    const void  *pbHashValue,           // [IN] Hash value for import assembly.
    ULONG       cbHashValue,            // [IN] Size in bytes of hash value.
    IMetaModelCommon *pCommonImport,    // [IN] Module import scope.
    mdTypeRef   trImport,               // [IN] Imported TypeRef.
    mdToken     *ptkType)               // [OUT] Output token for the imported type in the emit scope.
{
    CQuickArray<mdTypeDef>  cqaNesters;
    CQuickArray<LPCUTF8> cqaNesterNames;
    CQuickArray<LPCUTF8> cqaNesterNamespaces;
    LPCUTF8     szScopeNameEmit;
    GUID        nullguid = GUID_NULL;
    GUID        *pMvidAssemImport = &nullguid;
    GUID        *pMvidAssemEmit = &nullguid;
    GUID        *pMvidImport = &nullguid;
    GUID        *pMvidEmit = &nullguid;
    mdToken     tkOuterImportRes;               // ResolutionScope for the outermost TypeRef in import scope.
    mdToken     tkOuterEmitRes = mdTokenNil;    // ResolutionScope for outermost TypeRef in emit scope.
    HRESULT     hr = S_OK;
    bool        bAssemblyRefFromAssemScope = false;

    _ASSERTE(pMiniMdEmit && pCommonImport && ptkType);
    _ASSERTE(TypeFromToken(trImport) == mdtTypeRef);

    // Get MVIDs for import and emit, assembly and module scopes.
    if (pCommonAssemImport)
        pCommonAssemImport->CommonGetScopeProps(0, &pMvidAssemImport);
    pCommonImport->CommonGetScopeProps(0, &pMvidImport);
    if (pMiniMdAssemEmit)
    {
        static_cast<IMetaModelCommon*>(pMiniMdAssemEmit)->CommonGetScopeProps(
                                            0, &pMvidAssemEmit);
    }
    static_cast<IMetaModelCommon*>(pMiniMdEmit)->CommonGetScopeProps(
                                            &szScopeNameEmit, &pMvidEmit);

    // Get the outermost resolution scope for the TypeRef being imported.
    IfFailGo(GetNesterHierarchy(pCommonImport,
                                trImport,
                                cqaNesters,
                                cqaNesterNamespaces,
                                cqaNesterNames));
    pCommonImport->CommonGetTypeRefProps(cqaNesters[cqaNesters.Size() - 1],
                                         0, 0, &tkOuterImportRes);

    // Compute the ResolutionScope for the imported type.
    if (*pMvidAssemImport == *pMvidAssemEmit && *pMvidImport == *pMvidEmit)
    {
        *ptkType = trImport;
        goto ErrExit;
    }
    else if (*pMvidAssemImport == *pMvidAssemEmit && *pMvidImport != *pMvidEmit)
    {
        // The TypeRef is in the same Assembly but a different module.

        if (IsNilToken(tkOuterImportRes))
        {
            tkOuterEmitRes = tkOuterImportRes;
        }
        else if (TypeFromToken(tkOuterImportRes) == mdtModule)
        {
            // TypeRef resolved to the import module in which its defined.

            // This is a work around for 1421 integration to enable IJW linker scenario.
            // We are encountering a problem while compiling ISymWrapper where _GUID is locally
            // defined in the ISymWrapper.obj file and CoCreateInstance MemberRef has a reference to it.
            // When IJW comes in and try to do translateSigWithScope, we create a new TypeRef with ModuleRef
            // record which module ref name is to an empty string!! Upon merger, these two TypeRefs do not
            // seem to be identical to Merger!! This breaks our build!
            //
            if (pMiniMdAssemEmit == NULL && pCommonAssemImport == NULL)
            {
                tkOuterEmitRes = TokenFromRid(1, mdtModule);
            }
            else
            {
                // Create a ModuleRef corresponding to the import scope.
                IfFailGo(CreateModuleRefFromScope(pMiniMdEmit,
                                                  pCommonImport,
                                                  &tkOuterEmitRes));
            }
        }
        else if (TypeFromToken(tkOuterImportRes) == mdtAssemblyRef)
        {
            // TypeRef is from a different Assembly.

            // Create a corresponding AssemblyRef in the emit scope.
            IfFailGo(CreateAssemblyRefFromAssemblyRef(pMiniMdAssemEmit,
                                                      pMiniMdEmit,
                                                      pCommonImport,
                                                      tkOuterImportRes,
                                                      &tkOuterEmitRes));
        }
        else if (TypeFromToken(tkOuterImportRes) == mdtModuleRef)
        {
            // Get Name of the ModuleRef.
            LPCUTF8     szMRName;
            pCommonImport->CommonGetModuleRefProps(tkOuterImportRes, &szMRName);

            if (!strcmp(szMRName, szScopeNameEmit))
            {
                // ModuleRef from import scope resolves to the emit scope.
                tkOuterEmitRes = TokenFromRid(1, mdtModule);
            }
            else
            {
                // ModuleRef does not correspond to the emit scope.
                // Create a corresponding ModuleRef.
                IfFailGo(CreateModuleRefFromModuleRef(pMiniMdEmit,
                                                      pCommonImport,
                                                      tkOuterImportRes,
                                                      &tkOuterEmitRes));
            }
        }
    }
    else if (*pMvidAssemImport != *pMvidAssemEmit)
    {
        // The TypeDef is from a different Assembly.

        // Import and Emit scopes can't be identical and be from different
        // Assemblies at the same time.
        _ASSERTE(*pMvidImport != *pMvidEmit &&
                 "Import scope can't be identical to the Emit scope and be from a different Assembly at the same time.");

        mdToken     tkImplementation;       // Implementation token for ExportedType.
        if (IsNilToken(tkOuterImportRes))
        {
            // BUG FIX:: URT 13626
            // Well, before all of the clients generate AR for mscorlib.dll reference, it is not true
            // that tkOuterImportRes == nil will imply that we have to find such an entry in the import manifest!!

            // Look for a ExportedType entry in the import Assembly.  Its an error
            // if we don't find a ExportedType entry.
            mdExportedType   tkExportedType;
            hr = pCommonAssemImport->CommonFindExportedType(
                                    cqaNesterNamespaces[cqaNesters.Size() - 1],
                                    cqaNesterNames[cqaNesters.Size() - 1],
                                    mdTokenNil,
                                    &tkExportedType);
            if (SUCCEEDED(hr))
            {
                pCommonAssemImport->CommonGetExportedTypeProps(tkExportedType, 0, 0, &tkImplementation);
                if (TypeFromToken(tkImplementation) == mdtFile)
                {
                    // Type is from a different Assembly.
                    IfFailGo(CreateAssemblyRefFromAssembly(pMiniMdAssemEmit,
                                                           pMiniMdEmit,
                                                           pCommonAssemImport,
                                                           pbHashValue,
                                                           cbHashValue,
                                                           &tkOuterEmitRes));
                }
                else if (TypeFromToken(tkImplementation) == mdtAssemblyRef)
                {
                    // This folds into the case where the Type is AssemblyRef.  So
                    // let it fall through to that case.         

                    // Remember that this AssemblyRef token is actually from the Manifest scope not
                    // the module scope!!!
                    bAssemblyRefFromAssemScope = true;
                    tkOuterImportRes = tkImplementation;
                }
                else
                    _ASSERTE(!"Unexpected ExportedType implementation token.");
            }
            else
            {
                // In this case, we will just move over the TypeRef with Nil ResolutionScope.
                hr = NOERROR;
                tkOuterEmitRes = mdTokenNil;
            }
        }
        else if (TypeFromToken(tkOuterImportRes) == mdtModule)
        {
            // Type is from a different Assembly.
            IfFailGo(CreateAssemblyRefFromAssembly(pMiniMdAssemEmit,
                                                   pMiniMdEmit,
                                                   pCommonAssemImport,
                                                   pbHashValue,
                                                   cbHashValue,
                                                   &tkOuterEmitRes));
        }
        // Not else if, because mdtModule case above could change
        // tkOuterImportRes to an AssemblyRef.
        if (TypeFromToken(tkOuterImportRes) == mdtAssemblyRef)
        {
            // If there is an emit assembly, see if the import assembly ref points to 
            //  it.  If there is no emit assembly, the import assembly, by definition,
            //  does not point to this one.
            if (pMiniMdAssemEmit == NULL  || !pMiniMdAssemEmit->getCountAssemblys())
                hr = S_FALSE;
            else
            {
                if (bAssemblyRefFromAssemScope)
                {
                    // Check to see if the AssemblyRef resolves to the emit assembly.
                    IfFailGo(CompareAssemblyRefToAssembly(pCommonAssemImport,
                                                          tkOuterImportRes,
                                    static_cast<IMetaModelCommon*>(pMiniMdAssemEmit)));

                }
                else
                {
                    // Check to see if the AssemblyRef resolves to the emit assembly.
                    IfFailGo(CompareAssemblyRefToAssembly(pCommonImport,
                                                          tkOuterImportRes,
                                    static_cast<IMetaModelCommon*>(pMiniMdAssemEmit)));
                }
            }
            if (hr == S_OK)
            {
                // The TypeRef being imported is defined in the current Assembly.

                // Find the ExportedType for the outermost TypeRef in the Emit assembly.
                mdExportedType   tkExportedType;

                hr = FindExportedType(pMiniMdAssemEmit,
                                 cqaNesterNamespaces[cqaNesters.Size() - 1],
                                 cqaNesterNames[cqaNesters.Size() - 1],
                                 mdTokenNil,    // Enclosing ExportedType.
                                 &tkExportedType);
                if (hr == S_OK)
                {
                    // Create a ModuleRef based on the File name for the ExportedType.
                    // If the ModuleRef corresponds to pMiniMdEmit, the function
                    // will return S_FALSE, in which case set tkOuterEmitRes to
                    // the Module token.
                    hr = CreateModuleRefFromExportedType(pMiniMdEmit,
                                                    pMiniMdAssemEmit,
                                                    tkExportedType,
                                                    &tkOuterEmitRes);
                    if (hr == S_FALSE)
                        tkOuterEmitRes = TokenFromRid(1, mdtModule);
                    else
                        IfFailGo(hr);
                }
                else if (hr == CLDB_E_RECORD_NOTFOUND)
                {
                    // Find the Type in the Assembly emit scope to cover the
                    // case where ExportedTypes may be implicitly defined.  Its an
                    // error if we can't find the Type at this point.
                    IfFailGo(FindTypeDefByName(pMiniMdAssemEmit,
                                               cqaNesterNamespaces[cqaNesters.Size() - 1],
                                               cqaNesterNames[cqaNesters.Size() - 1],
                                               mdTokenNil,  // Enclosing Type.
                                               &tkOuterEmitRes));
                    tkOuterEmitRes = TokenFromRid(1, mdtModule);
                }
                else
                {
                    _ASSERTE(FAILED(hr));
                    IfFailGo(hr);
                }
            }
            else if (hr == S_FALSE)
            {
                // The TypeRef being imported is from a different Assembly.

                if (bAssemblyRefFromAssemScope)
                {
                    // Create a corresponding AssemblyRef.
                    IfFailGo(CreateAssemblyRefFromAssemblyRef(pMiniMdAssemEmit,
                                                              pMiniMdEmit,
                                                              pCommonAssemImport,
                                                              tkOuterImportRes,
                                                              &tkOuterEmitRes));
                }
                else
                {
                    // Create a corresponding AssemblyRef.
                    IfFailGo(CreateAssemblyRefFromAssemblyRef(pMiniMdAssemEmit,
                                                              pMiniMdEmit,
                                                              pCommonImport,
                                                              tkOuterImportRes,
                                                              &tkOuterEmitRes));
                }
            }
            else
            {
                _ASSERTE(FAILED(hr));
                IfFailGo(hr);
            }
        }
        else if (TypeFromToken(tkOuterImportRes) == mdtModuleRef)
        {
            // Type is from a different Assembly.
            IfFailGo(CreateAssemblyRefFromAssembly(pMiniMdAssemEmit,
                                                   pMiniMdEmit,
                                                   pCommonAssemImport,
                                                   pbHashValue,
                                                   cbHashValue,
                                                   &tkOuterEmitRes));
        }
    }

    // Try to find the TypeDef in the emit scope. If we cannot find the
    // typedef, we need to introduce a typeref.

    // See if the Nested TypeDef is present in the Emit scope.
    hr = CLDB_E_RECORD_NOTFOUND;
    if (TypeFromToken(tkOuterEmitRes) == mdtModule && !IsNilToken(tkOuterEmitRes))
    {
        hr = FindNestedTypeDef(pMiniMdEmit,
                               cqaNesterNamespaces,
                               cqaNesterNames,
                               mdTokenNil,
                               ptkType);

        // cannot assert now!! Due to the IJW hack!
        // _ASSERTE(SUCCEEDED(hr));
    }

    if (hr == CLDB_E_RECORD_NOTFOUND)
    {
        IfFailGo(CreateNesterHierarchy(pMiniMdEmit,
                                       cqaNesterNamespaces,
                                       cqaNesterNames,
                                       tkOuterEmitRes,
                                       ptkType));
    }
    else
        IfFailGo(hr);
ErrExit:
    return hr;
}   // HRESULT ImportHelper::ImportTypeRef()

//******************************************************************************
// Given import scope, create a corresponding ModuleRef.
//******************************************************************************
HRESULT ImportHelper::CreateModuleRefFromScope( // S_OK or error.
    CMiniMdRW   *pMiniMdEmit,           // [IN] Emit scope in which the ModuleRef is to be created.
    IMetaModelCommon *pCommonImport,    // [IN] Import scope.
    mdModuleRef *ptkModuleRef)          // [OUT] Output token for ModuleRef.
{
    HRESULT     hr = S_OK;
    LPCSTR      szName;
    ModuleRefRec *pRecordEmit;
    RID         iRecordEmit;

    // Set output to nil.
    *ptkModuleRef = mdTokenNil;

    // Get name of import scope.
    pCommonImport->CommonGetScopeProps(&szName, 0);

    // See if the ModuleRef exists in the Emit scope.
    hr = FindModuleRef(pMiniMdEmit, szName, ptkModuleRef);

    if (hr == CLDB_E_RECORD_NOTFOUND)
    {
        if (szName[0] == '\0')
        {
            // It the referenced Module does not have a proper name, use the nil token instead.
            LOG((LOGMD, "WARNING!!! MD ImportHelper::CreatemoduleRefFromScope but scope does not have a proper name!!!!"));

            // clear the error
            hr = NOERROR;

            // It is a bug to create an ModuleRef to an empty name!!!
            *ptkModuleRef = mdTokenNil;
        }
        else
        {
            // Create ModuleRef record and set the output parameter.
            IfNullGo(pRecordEmit = pMiniMdEmit->AddModuleRefRecord(&iRecordEmit));
            *ptkModuleRef = TokenFromRid(iRecordEmit, mdtModuleRef);
            IfFailGo(pMiniMdEmit->UpdateENCLog(*ptkModuleRef));

            // It is a bug to create an ModuleRef to mscorlib.dll
            _ASSERTE(strcmp(szName, COM_RUNTIME_LIBRARY) != 0);

            // Set the name of ModuleRef.
            IfFailGo(pMiniMdEmit->PutString(TBL_ModuleRef, ModuleRefRec::COL_Name,
                                                  pRecordEmit, szName));
        }
    }
    else
        IfFailGo(hr);
ErrExit:
    return hr;
}   // HRESULT ImportHelper::CreateModuleRefFromScope()


//******************************************************************************
// Given an import scope and a ModuleRef, create a corresponding ModuleRef in
// the given emit scope.
//******************************************************************************
HRESULT ImportHelper::CreateModuleRefFromModuleRef(    // S_OK or error.
    CMiniMdRW   *pMiniMdEmit,           // [IN] Emit scope.
    IMetaModelCommon *pCommon,              // [IN] Import scope.
    mdModuleRef tkModuleRef,            // [IN] ModuleRef token.
    mdModuleRef *ptkModuleRef)          // [OUT] ModuleRef token in the emit scope.
{
    HRESULT     hr = S_OK;
    LPCSTR      szName;
    ModuleRefRec *pRecord;
    RID         iRecord;

    // Set output to Nil.
    *ptkModuleRef = mdTokenNil;

    // Get name of the ModuleRef being imported.
    pCommon->CommonGetModuleRefProps(tkModuleRef, &szName);

    // See if the ModuleRef exist in the Emit scope.
    hr = FindModuleRef(pMiniMdEmit, szName, ptkModuleRef);

    if (hr == CLDB_E_RECORD_NOTFOUND)
    {
        // Create ModuleRef record and set the output parameter.
        IfNullGo(pRecord = pMiniMdEmit->AddModuleRefRecord(&iRecord));
        *ptkModuleRef = TokenFromRid(iRecord, mdtModuleRef);
        IfFailGo(pMiniMdEmit->UpdateENCLog(*ptkModuleRef));

        // Set the name of ModuleRef.
        IfFailGo(pMiniMdEmit->PutString(TBL_ModuleRef, ModuleRefRec::COL_Name,
                                              pRecord, szName));
    }
    else
        IfFailGo(hr);
ErrExit:
    return hr;
}   // HRESULT ImportHelper::CreateModuleRefFromModuleRef()


//******************************************************************************
// Given a ExportedType and the Assembly emit scope, create a corresponding ModuleRef
// in the give emit scope.  The ExportedType being passed in must belong to the
// Assembly passed in.  Function returns S_FALSE if the ExportedType is implemented
// by the emit scope passed in.
//******************************************************************************
HRESULT ImportHelper::CreateModuleRefFromExportedType(  // S_OK or error.
    CMiniMdRW   *pAssemEmit,            // [IN] Import assembly scope.
    CMiniMdRW   *pMiniMdEmit,           // [IN] Emit scope.
    mdExportedType   tkExportedType,              // [IN] ExportedType token in Assembly emit scope.
    mdModuleRef *ptkModuleRef)          // [OUT] ModuleRef token in the emit scope.
{
    mdFile      tkFile;
    LPCUTF8     szFile;
    LPCUTF8     szScope;
    FileRec     *pFileRec;
    HRESULT     hr = S_OK;

    // Set output to nil.
    *ptkModuleRef = mdTokenNil;

    // Get the implementation token for the ExportedType.  It must be a File token
    // since the caller should call this function only on ExportedTypes that resolve
    // to the same Assembly.
    static_cast<IMetaModelCommon*>(pAssemEmit)->
                            CommonGetExportedTypeProps(tkExportedType, 0, 0, &tkFile);
    _ASSERTE(TypeFromToken(tkFile) == mdtFile);

    // Get the name of the file.
    pFileRec = pAssemEmit->getFile(RidFromToken(tkFile));
    szFile = pAssemEmit->getNameOfFile(pFileRec);

    // Get the name of the emit scope.
    static_cast<IMetaModelCommon*>(pMiniMdEmit)->
                            CommonGetScopeProps(&szScope, 0);

    // If the file corresponds to the emit scope, return S_FALSE;
    if (!strcmp(szFile, szScope))
        return S_FALSE;

    // See if a ModuleRef exists with this name.
    hr = FindModuleRef(pMiniMdEmit, szFile, ptkModuleRef);

    if (hr == CLDB_E_RECORD_NOTFOUND)
    {
        // Create ModuleRef record and set the output parameter.

        ModuleRefRec    *pRecord;
        RID             iRecord;

        IfNullGo(pRecord = pMiniMdEmit->AddModuleRefRecord(&iRecord));
        *ptkModuleRef = TokenFromRid(iRecord, mdtModuleRef);
        IfFailGo(pMiniMdEmit->UpdateENCLog(*ptkModuleRef));

        // Set the name of ModuleRef.
        IfFailGo(pMiniMdEmit->PutString(TBL_ModuleRef, ModuleRefRec::COL_Name,
                                              pRecord, szFile));
    }
    else
        IfFailGo(hr);
ErrExit:
    return hr;
}   // HRESULT ImportHelper::CreateModuleRefFromExportedType()


//******************************************************************************
// Given the Assembly Import scope, hash value and execution location, create
// a corresponding AssemblyRef in the given assembly and module emit scope.
// Set the output parameter to the AssemblyRef token emitted in the module emit
// scope.
//******************************************************************************
HRESULT ImportHelper::CreateAssemblyRefFromAssembly( // S_OK or error.
    CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Emit assembly scope.
    CMiniMdRW   *pMiniMdModuleEmit,     // [IN] Emit module scope.
    IMetaModelCommon *pCommonAssemImport, // [IN] Assembly import scope.
    const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
    ULONG           cbHashValue,                // [IN] Count of bytes.
    mdAssemblyRef *ptkAssemblyRef)      // [OUT] AssemblyRef token.
{
    AssemblyRefRec *pRecordEmit;
    CMiniMdRW   *rMiniMdRW[2];
    CMiniMdRW   *pMiniMdEmit;
    RID         iRecordEmit;
    USHORT      usMajorVersion;
    USHORT      usMinorVersion;
    USHORT      usBuildNumber;
    USHORT      usRevisionNumber;
    DWORD       dwFlags;
    const void  *pbPublicKey;
    ULONG       cbPublicKey;
    LPCUTF8     szName;
    LPCUTF8     szLocale;
    mdAssemblyRef tkAssemRef;
    HRESULT     hr = S_OK;
    const void  *pbToken = NULL;
    ULONG       cbToken = 0;
    ULONG       i;

    // Set output to Nil.
    *ptkAssemblyRef = mdTokenNil;

    // Get the Assembly props.
    pCommonAssemImport->CommonGetAssemblyProps(&usMajorVersion, &usMinorVersion,
                                               &usBuildNumber, &usRevisionNumber,
                                               &dwFlags, &pbPublicKey, &cbPublicKey,
                                               &szName, &szLocale);

    // Compress the public key into a token.
    if ((pbPublicKey != NULL) && (cbPublicKey != 0))
    {
        _ASSERTE(IsAfPublicKey(dwFlags));
        dwFlags &= ~afPublicKey;
        if (!StrongNameTokenFromPublicKey((BYTE*)pbPublicKey,
                                          cbPublicKey,
                                          (BYTE**)&pbToken,
                                          &cbToken))
            IfFailGo(StrongNameErrorInfo());
    }
    else
        _ASSERTE(!IsAfPublicKey(dwFlags));

    // Create the AssemblyRef in both the Assembly and Module emit scopes.
    rMiniMdRW[0] = pMiniMdAssemEmit;
    rMiniMdRW[1] = pMiniMdModuleEmit;

    for (i = 0; i < 2; i++)
    {
        pMiniMdEmit = rMiniMdRW[i];

        if (!pMiniMdEmit)
            continue;

        // See if the AssemblyRef already exists in the emit scope.
        hr = FindAssemblyRef(pMiniMdEmit, szName, szLocale, pbToken,
                             cbToken, usMajorVersion, usMinorVersion,
                             usBuildNumber, usRevisionNumber, dwFlags,
                             &tkAssemRef);
        if (hr == CLDB_E_RECORD_NOTFOUND)
        {
            // Create the AssemblyRef record and set the output parameter.
            IfNullGo(pRecordEmit = pMiniMdEmit->AddAssemblyRefRecord(&iRecordEmit));
            tkAssemRef = TokenFromRid(iRecordEmit, mdtAssemblyRef);
            IfFailGo(pMiniMdEmit->UpdateENCLog(tkAssemRef));

            // Set parameters derived from the import Assembly.
            pRecordEmit->m_MajorVersion     = usMajorVersion;
            pRecordEmit->m_MinorVersion     = usMinorVersion;
            pRecordEmit->m_BuildNumber      = usBuildNumber;
            pRecordEmit->m_RevisionNumber   = usRevisionNumber;
            pRecordEmit->m_Flags            = dwFlags;

            IfFailGo(pMiniMdEmit->PutBlob(TBL_AssemblyRef, AssemblyRefRec::COL_PublicKeyOrToken,
                                          pRecordEmit, pbToken, cbToken));
            IfFailGo(pMiniMdEmit->PutString(TBL_AssemblyRef, AssemblyRefRec::COL_Name,
                                          pRecordEmit, szName));
            IfFailGo(pMiniMdEmit->PutString(TBL_AssemblyRef, AssemblyRefRec::COL_Locale,
                                          pRecordEmit, szLocale));

            // Set the parameters passed in for the AssemblyRef.
            IfFailGo(pMiniMdEmit->PutBlob(TBL_AssemblyRef, AssemblyRefRec::COL_HashValue,
                                          pRecordEmit, pbHashValue, cbHashValue));
        }
        else
            IfFailGo(hr);

        // Set the output parameter for the AssemblyRef emitted in Module emit scope.
        if (i)
            *ptkAssemblyRef = tkAssemRef;
    }
ErrExit:
    if (pbToken)
        StrongNameFreeBuffer((BYTE*)pbToken);
    return hr;
}   // HRESULT ImportHelper::CreateAssemblyRefFromAssembly()


//******************************************************************************
// Given an AssemblyRef and the corresponding scope, compare it to see if it
// refers to the given Assembly.
//******************************************************************************
HRESULT ImportHelper::CompareAssemblyRefToAssembly(    // S_OK, S_FALSE or error.
    IMetaModelCommon *pCommonAssem1,    // [IN] Scope that defines the AssemblyRef.
    mdAssemblyRef tkAssemRef,           // [IN] AssemblyRef.
    IMetaModelCommon *pCommonAssem2)    // [IN] Assembly against which the Ref is compared.
{
    USHORT      usMajorVersion1;
    USHORT      usMinorVersion1;
    USHORT      usBuildNumber1;
    USHORT      usRevisionNumber1;
    const void  *pbPublicKeyOrToken1;
    ULONG       cbPublicKeyOrToken1;
    LPCUTF8     szName1;
    LPCUTF8     szLocale1;
    DWORD       dwFlags1;

    USHORT      usMajorVersion2;
    USHORT      usMinorVersion2;
    USHORT      usBuildNumber2;
    USHORT      usRevisionNumber2;
    const void  *pbPublicKey2;
    ULONG       cbPublicKey2;
    LPCUTF8     szName2;
    LPCUTF8     szLocale2;
    const void  *pbToken = NULL;
    ULONG       cbToken = 0;
    bool        fMatch;

    // Get the AssemblyRef props.
    pCommonAssem1->CommonGetAssemblyRefProps(tkAssemRef, &usMajorVersion1,
                                             &usMinorVersion1, &usBuildNumber1, 
                                             &usRevisionNumber1, &dwFlags1, &pbPublicKeyOrToken1,
                                             &cbPublicKeyOrToken1, &szName1, &szLocale1,
                                             0, 0);
    // Get the Assembly props.
    pCommonAssem2->CommonGetAssemblyProps(&usMajorVersion2, &usMinorVersion2,
                                          &usBuildNumber2, &usRevisionNumber2, 
                                          0, &pbPublicKey2, &cbPublicKey2,
                                          &szName2, &szLocale2);

    // Compare.
    if (usMajorVersion1 != usMajorVersion2 ||
        usMinorVersion1 != usMinorVersion2 ||
        usBuildNumber1 != usBuildNumber2 ||
        usRevisionNumber1 != usRevisionNumber2 ||
        strcmp(szName1, szName2) ||
        strcmp(szLocale1, szLocale2))
    {
        return S_FALSE;
    }

    // Defs always contain a full public key (or no key at all). Refs may have
    // no key, a full public key or a tokenized key.
    if ((cbPublicKeyOrToken1 && !cbPublicKey2) ||
        (!cbPublicKeyOrToken1 && cbPublicKey2))
        return S_FALSE;

    if (cbPublicKeyOrToken1)
    {
        // If ref contains a full public key we can just directly compare.
        if (IsAfPublicKey(dwFlags1) &&
            (cbPublicKeyOrToken1 != cbPublicKey2 ||
             memcmp(pbPublicKeyOrToken1, pbPublicKey2, cbPublicKeyOrToken1)))
            return FALSE;

        // Otherwise we need to compress the def public key into a token.
        if (!StrongNameTokenFromPublicKey((BYTE*)pbPublicKey2,
                                          cbPublicKey2,
                                          (BYTE**)&pbToken,
                                          &cbToken))
            return StrongNameErrorInfo();

        fMatch = cbPublicKeyOrToken1 == cbToken &&
            !memcmp(pbPublicKeyOrToken1, pbToken, cbPublicKeyOrToken1);

        StrongNameFreeBuffer((BYTE*)pbToken);

        if (!fMatch)
            return S_FALSE;
    }

    return S_OK;
}   // HRESULT ImportHelper::CompareAssemblyRefToAssembly()


//******************************************************************************
// Given an AssemblyRef and the corresponding scope, create an AssemblyRef in
// the given Module scope and Assembly scope.
//******************************************************************************
HRESULT ImportHelper::CreateAssemblyRefFromAssemblyRef(
    CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Assembly emit scope.
    CMiniMdRW   *pMiniMdModuleEmit,     // [IN] Module emit scope
    IMetaModelCommon *pCommonImport,    // [IN] Scope to import the assembly ref from.
    mdAssemblyRef tkAssemRef,           // [IN] Assembly ref to be imported.
    mdAssemblyRef *ptkAssemblyRef)      // [OUT] AssemblyRef in the emit scope.
{
    AssemblyRefRec *pRecordEmit;
    CMiniMdRW   *rMiniMdRW[2];
    CMiniMdRW   *pMiniMdEmit;
    RID         iRecordEmit;
    USHORT      usMajorVersion;
    USHORT      usMinorVersion;
    USHORT      usBuildNumber;
    USHORT      usRevisionNumber;
    DWORD       dwFlags;
    const void  *pbPublicKeyOrToken;
    ULONG       cbPublicKeyOrToken;
    LPCUTF8     szName;
    LPCUTF8     szLocale;
    const void  *pbHashValue;
    ULONG       cbHashValue;
    HRESULT     hr = S_OK;

    // Set output to Nil.
    *ptkAssemblyRef = mdTokenNil;

    // Get import AssemblyRef props.
    pCommonImport->CommonGetAssemblyRefProps(tkAssemRef, &usMajorVersion,
                                             &usMinorVersion, &usBuildNumber,
                                             &usRevisionNumber, &dwFlags,
                                       &pbPublicKeyOrToken, &cbPublicKeyOrToken,
                                       &szName, &szLocale,
                                       &pbHashValue,
                                       &cbHashValue);

    // Create the AssemblyRef in both the Assembly and Module emit scopes.
    rMiniMdRW[0] = pMiniMdAssemEmit;
    rMiniMdRW[1] = pMiniMdModuleEmit;

    for (ULONG i = 0; i < 2; i++)
    {
        pMiniMdEmit = rMiniMdRW[i];

        if (!pMiniMdEmit)
            continue;

        // See if the AssemblyRef already exists in the emit scope.
        hr = FindAssemblyRef(pMiniMdEmit, szName, szLocale, pbPublicKeyOrToken,
                             cbPublicKeyOrToken, usMajorVersion, usMinorVersion,
                             usBuildNumber, usRevisionNumber, dwFlags, &tkAssemRef);
        if (hr == CLDB_E_RECORD_NOTFOUND)
        {
            // Create the AssemblyRef record and set the output parameter.
            IfNullGo(pRecordEmit = pMiniMdEmit->AddAssemblyRefRecord(&iRecordEmit));
            tkAssemRef = TokenFromRid(iRecordEmit, mdtAssemblyRef);
            IfFailGo(pMiniMdEmit->UpdateENCLog(tkAssemRef));

            // Set parameters derived from the import Assembly.
            pRecordEmit->m_MajorVersion     = usMajorVersion;
            pRecordEmit->m_MinorVersion     = usMinorVersion;
            pRecordEmit->m_BuildNumber      = usBuildNumber;
            pRecordEmit->m_RevisionNumber   = usRevisionNumber;
            pRecordEmit->m_Flags            = dwFlags;

            IfFailGo(pMiniMdEmit->PutBlob(TBL_AssemblyRef, AssemblyRefRec::COL_PublicKeyOrToken,
                                          pRecordEmit, pbPublicKeyOrToken, cbPublicKeyOrToken));
            IfFailGo(pMiniMdEmit->PutString(TBL_AssemblyRef, AssemblyRefRec::COL_Name,
                                          pRecordEmit, szName));
            IfFailGo(pMiniMdEmit->PutString(TBL_AssemblyRef, AssemblyRefRec::COL_Locale,
                                          pRecordEmit, szLocale));

            // Set the parameters passed in for the AssemblyRef.
            IfFailGo(pMiniMdEmit->PutBlob(TBL_AssemblyRef, AssemblyRefRec::COL_HashValue,
                                          pRecordEmit, pbHashValue, cbHashValue));
        }
        else
            IfFailGo(hr);

        // Set the output parameter for the AssemblyRef emitted in Module emit scope.
        if (i)
            *ptkAssemblyRef = tkAssemRef;
    }
ErrExit:
    return hr;
}   // HRESULT ImportHelper::CreateAssemblyRefFromAssemblyRef()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\importhelper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ImportHelper.cpp
//
// contains utility code to MD directory
//
//*****************************************************************************
#ifndef __IMPORTHELPER__h__
#define __IMPORTHELPER__h__

class CMiniMdRW;
class MDTOKENMAP;

//*********************************************************************
// Class to handle merge
//*********************************************************************
class ImportHelper
{
public:

    static HRESULT FindMethod(      
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdTypeDef   td,                     // [IN] parent.
        LPCUTF8     szName,                 // [IN] MethodDef name.
        const COR_SIGNATURE *pSig,          // [IN] Signature.
        ULONG       cbSig,                  // [IN] Size of signature.
        mdMethodDef *pmb,                   // [OUT] Put the MethodDef token here.
        RID         rid = 0);               // [IN] Optional rid to be ignored.

    static HRESULT FindField(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdTypeDef   td,                     // [IN] parent.
        LPCUTF8     szName,                 // [IN] FieldDef name.
        const COR_SIGNATURE *pSig,          // [IN] Signature.
        ULONG       cbSig,                  // [IN] Size of signature.
        mdFieldDef  *pfd,                   // [OUT] Put the FieldDef token here.
        RID         rid = 0);               // [IN] Optional rid to be ignored.

    static HRESULT FindMember(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdTypeDef   td,                     // [IN] parent.
        LPCUTF8     szName,                 // [IN] Member name.
        const COR_SIGNATURE *pSig,          // [IN] Signature.
        ULONG       cbSig,                  // [IN] Size of signature.
        mdToken     *ptk);                  // [OUT] Put the token here.

    static HRESULT FindMemberRef(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdToken     tkParent,               // [IN] the parent token
        LPCUTF8     szName,                 // [IN] memberref name
        const COR_SIGNATURE *pSig,          // [IN] Signature.
        ULONG       cbSig,                  // [IN] Size of signature.
        mdMemberRef *pmr,                   // [OUT] Put the MemberRef token found
        RID         rid = 0);               // [IN] Optional rid to be ignored.

    static HRESULT FindStandAloneSig(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        const COR_SIGNATURE *pbSig,         // [IN] Signature.
        ULONG       cbSig,                  // [IN] Size of signature.
        mdSignature *psa);                  // [OUT] Put the StandAloneSig token found

    static HRESULT FindTypeSpec(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        const COR_SIGNATURE *pbSig,         // [IN] Signature.
        ULONG       cbSig,                  // [IN] Size of signature.
        mdTypeSpec  *ptypespec);            // [OUT] Put the TypeSpec token found

    static HRESULT FindMethodImpl(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdTypeDef   tkClass,                // [IN] The parent TypeDef token.
        mdToken     tkBody,                 // [IN] Method body token.
        mdToken     tkDecl,                 // [IN] Method declaration token.
        RID         *pRid);                 // [OUT] Put the MethodImpl rid here

    static HRESULT FindTypeRefByName(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdToken     tkResolutionScope,      // [IN] ResolutionScope, mdAssemblyRef or mdModuleRef.
        LPCUTF8     szNamespace,            // [IN] TypeRef Namespace.
        LPCUTF8     szName,                 // [IN] TypeRef Name.
        mdTypeDef   *ptk,                   // [OUT] Put the TypeRef token here.
        RID         rid = 0);               // [IN] Optional rid to be ignored.

    static HRESULT FindModuleRef(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        LPCUTF8     szUTF8Name,             // [IN] ModuleRef name.
        mdModuleRef *pmur,                  // [OUT] Put the ModuleRef token here.
        RID         rid = 0);               // [IN] Optional rid to be ignored.

    static HRESULT FindTypeDefByName(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        LPCUTF8     szNamespace,            // [IN] Namespace of the TypeDef.
        LPCUTF8     szName,                 // [IN] Name of the TypeDef.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef enclosing class.
        mdTypeDef   *ptk,                   // [OUT] Put the TypeDef token here.
        RID         rid = 0);               // [IN] Optional rid to be ignored.

    static HRESULT FindInterfaceImpl(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdToken     tkClass,                // [IN] TypeDef of the type
        mdToken     tkInterface,            // [IN] could be typedef/typeref
        mdInterfaceImpl *ptk,               // [OUT] Put the interface token here.
        RID         rid = 0);               // [IN] Optional rid to be ignored.

    static HRESULT FindPermission(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdToken     tkParent,               // [IN] Token with the Permission
        USHORT      usAction,               // [IN] The action of the permission
        mdPermission *ppm);                 // [OUT] Put permission token here

    static HRESULT FindProperty(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdToken     tkTypeDef,              // [IN] typedef token
        LPCUTF8     szName,                 // [IN] name of the property
        const COR_SIGNATURE *pbSig,         // [IN] Signature.
        ULONG       cbSig,                  // [IN] Size of signature.
        mdProperty  *ppr);                  // [OUT] Property token 

    static HRESULT FindEvent(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdToken     tkTypeDef,              // [IN] typedef token
        LPCUTF8     szName,                 // [IN] name of the event
        mdProperty  *pev);                  // [OUT] Event token 

    static HRESULT FindCustomAttributeByToken(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdToken     tkParent,               // [IN] the parent that custom value is associated with
        mdToken     tkType,                 // [IN] type of the CustomAttribute
		const void	*pCustBlob,				// [IN] custom value blob
		ULONG		cbCustBlob,				// [IN] size of the blob.
        mdCustomAttribute *pcv);            // [OUT] CustomAttribute token 

	static HRESULT GetCustomAttributeByName(// S_OK or error.
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
		mdToken		tkObj,					// [IN] Object with Custom Attribute.
		LPCUTF8		szName,					// [IN] Name of desired Custom Attribute.
		const void	**ppData,				// [OUT] Put pointer to data here.
		ULONG		*pcbData);				// [OUT] Put size of data here.

    static HRESULT GetCustomAttributeByName(// S_OK or error.
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
		mdToken		tkObj,					// [IN] Object with Custom Attribute.
		LPCUTF8		szName,					// [IN] Name of desired Custom Attribute.
        mdCustomAttribute pca);             // [OUT] found CA token

    static HRESULT MergeUpdateTokenInFieldSig(      
        CMiniMdRW   *pMiniMdAssemEmit,      // [IN] The assembly emit scope.
        CMiniMdRW   *pMiniMdEmit,           // [IN] The emit scope.
        IMetaModelCommon *pCommonAssemImport,   // [IN] Assembly scope where the signature is from.
        const void  *pbHashValue,           // [IN] Hash value for the import assembly.
        ULONG       cbHashValue,            // [IN] Size in bytes for the hash value.
        IMetaModelCommon *pCommonImport,    // [IN] The scope to merge into the emit scope.
        PCCOR_SIGNATURE pbSigImp,           // [IN] signature from the imported scope
        MDTOKENMAP  *ptkMap,                // [IN] Internal OID mapping structure.
        CQuickBytes *pqkSigEmit,            // [OUT] buffer for translated signature
        ULONG       cbStartEmit,            // [IN] start point of buffer to write to
        ULONG       *pcbImp,                // [OUT] total number of bytes consumed from pbSigImp
        ULONG       *pcbEmit);              // [OUT] total number of bytes write to pqkSigEmit

    static HRESULT MergeUpdateTokenInSig(   // S_OK or error.
        CMiniMdRW   *pMiniMdAssemEmit,      // [IN] The assembly emit scope.
        CMiniMdRW   *pMiniMdEmit,           // [IN] The emit scope.
        IMetaModelCommon *pCommonAssemImport,   // [IN] Assembly scope where the signature is from.
        const void  *pbHashValue,           // [IN] Hash value for the import assembly.
        ULONG       cbHashValue,            // [IN] Size in bytes for the hash value.
        IMetaModelCommon *pCommonImport,    // [IN] The scope to merge into the emit scope.
        PCCOR_SIGNATURE pbSigImp,           // [IN] signature from the imported scope
        MDTOKENMAP  *ptkMap,                // [IN] Internal OID mapping structure.
        CQuickBytes *pqkSigEmit,            // [OUT] translated signature
        ULONG       cbStartEmit,            // [IN] start point of buffer to write to
        ULONG       *pcbImp,                // [OUT] total number of bytes consumed from pbSigImp
        ULONG       *pcbEmit);              // [OUT] total number of bytes write to pqkSigEmit

    static HRESULT FindImplMap(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup.
        mdToken     tkModuleRef,            // [IN] Parent module ref to look under.
        mdToken     tkMethodDef,            // [IN] Parent methoddef to look under.
        USHORT      usMappingFlags,         // [IN] Flags on how to map the item.
        LPCUTF8     szImportName,           // [IN] Name of import member.
        ULONG       *piRecord);             // [OUT] Record for item if found.

    static HRESULT FindAssemblyRef(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup.
        LPCUTF8     szName,                 // [IN] Name.
        LPCUTF8     szLocale,               // [IN] Locale.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token (based on flags).
        ULONG       cbPublicKeyOrToken,     // [IN] Byte count of public key or token.
        USHORT      usMajorVersion,         // [IN] Major version.
        USHORT      usMinorVersion,         // [IN] Minor version.
        USHORT      usBuildNumber,          // [IN] Build number.
        USHORT      usRevisionNumber,       // [IN] Revision number.
        DWORD       dwFlags,                // [IN] Flags.
        mdAssemblyRef *pmar);               // [OUT] returned AssemblyRef token.

    static HRESULT FindFile(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup.
        LPCUTF8     szName,                 // [IN] name for the File.
        mdFile      *pmf,                   // [OUT] returned File token.
        RID         rid = 0);               // [IN] Optional rid to be ignored.

    static HRESULT FindExportedType(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup.
        LPCUTF8     szNamespace,            // [IN] namespace for the ExportedType.
        LPCUTF8     szName,                 // [IN] name for the ExportedType.
        mdExportedType   tkEnclosingType,   // [IN] enclosing ExportedType token.
        mdExportedType   *pmct,             // [OUT] returned ExportedType token.
        RID         rid = 0);               // [IN] Optional rid to be ignored.

    static HRESULT FindManifestResource(
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup.
        LPCUTF8     szName,                 // [IN] name for the ManifestResource.
        mdManifestResource *pmmr,           // [OUT] returned ManifestResource token.
        RID         rid = 0);               // [IN] Optional rid to be ignored.

    static HRESULT ImportHelper::GetNesterHierarchy(
        IMetaModelCommon *pCommon,          // Scope in which to find the hierarchy.
        mdTypeDef   td,                     // TypeDef whose hierarchy is needed.
        CQuickArray<mdTypeDef> &cqaTdNesters,  // Array of Nesters.
        CQuickArray<LPCUTF8> &cqaNamespaces,    // Namespaces of the nesters.
        CQuickArray<LPCUTF8> &cqaNames);    // Names of the nesters.

    static HRESULT ImportHelper::FindNestedTypeRef(
        CMiniMdRW   *pMiniMd,               // [IN] Scope in which to find the TypeRef.
        CQuickArray<LPCUTF8> &cqaNesterNamespaces,   // [IN] Array of Namespaces.
        CQuickArray<LPCUTF8> &cqaNesterNames,    // [IN] Array of Names.
        mdToken     tkResolutionScope,      // [IN] Resolution scope for the outermost TypeRef.
        mdTypeRef   *ptr);                  // [OUT] Inner most TypeRef token.

    static HRESULT ImportHelper::FindNestedTypeDef(
        CMiniMdRW   *pMiniMd,               // [IN] Scope in which to find the TypeRef.
        CQuickArray<LPCUTF8> &cqaNesterNamespaces,   // [IN] Array of Namespaces.
        CQuickArray<LPCUTF8> &cqaNesterNames,    // [IN] Array of Names.
        mdTypeDef   tdNester,               // [IN] Enclosing class for the Outermost TypeDef.
        mdTypeDef   *ptd);                  // [OUT] Inner most TypeRef token.

    static HRESULT CreateNesterHierarchy(
        CMiniMdRW   *pMiniMdEmit,           // [IN] Emit scope to create the Nesters in.
        CQuickArray<LPCUTF8> &cqaNesterNamespaces,    // [IN] Array of Nester namespaces.
        CQuickArray<LPCUTF8> &cqaNesterNames,   // [IN] Array of Nester names.
        mdToken     tkResolutionScope,      // [IN] ResolutionScope for the innermost TypeRef.
        mdTypeRef   *ptr);                  // [OUT] Token for the innermost TypeRef.

    static HRESULT ImportTypeDef(
        CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Assembly emit scope.
        CMiniMdRW   *pMiniMdEmit,           // [IN] Module emit scope.
        IMetaModelCommon *pCommonAssemImport, // [IN] Assembly import scope.
        const void  *pbHashValue,           // [IN] Hash value for import assembly.
        ULONG       cbHashValue,            // [IN] Size in bytes of hash value.
        IMetaModelCommon *pCommonImport,    // [IN] Module import scope.
        mdTypeDef   tdImport,               // [IN] Imported TypeDef.
        bool        bReturnTd,              // [IN] If the import and emit scopes are identical, return the TypeDef.
        mdToken     *ptkType);              // [OUT] Output token for the imported type in the emit scope.

    static HRESULT ImportTypeRef(
        CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Assembly emit scope.
        CMiniMdRW   *pMiniMdEmit,           // [IN] Module emit scope.
        IMetaModelCommon *pCommonAssemImport, // [IN] Assembly import scope.
        const void  *pbHashValue,           // [IN] Hash value for import assembly.
        ULONG       cbHashValue,            // [IN] Size in bytes of hash value.
        IMetaModelCommon *pCommonImport,    // [IN] Module import scope.
        mdTypeRef   trImport,               // [IN] Imported TypeRef.
        mdToken     *ptkType);              // [OUT] Output token for the imported type in the emit scope.

private:
    /*
    static bool ImportHelper::CompareCustomAttribute( // 
        CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
        ULONG       rid);                    // [IN] the rid of the custom attribute to compare to
    */

    static HRESULT GetTDNesterHierarchy(
        IMetaModelCommon *pCommon,          // Scope in which to find the hierarchy.
        mdTypeDef     td,                   // TypeDef whose hierarchy is needed.
        CQuickArray<mdTypeDef> &cqaTdNesters,// Array of Nesters.
        CQuickArray<LPCUTF8> &cqaNamespaces,    // Namespaces of the nesters.
        CQuickArray<LPCUTF8> &cqaNames);    // Names of the nesters.

    static HRESULT GetTRNesterHierarchy(
        IMetaModelCommon *pCommon,          // Scope in which to find the hierarchy.
        mdTypeRef     tr,                   // TypeRef whose hierarchy is needed.
        CQuickArray<mdTypeRef> &cqaTrNesters,// Array of Nesters.
        CQuickArray<LPCUTF8> &cqaNamespaces,    // Namespaces of the nesters.
        CQuickArray<LPCUTF8> &cqaNames);    // Names of the nesters.

    static HRESULT CreateModuleRefFromScope(
        CMiniMdRW   *pMiniMdEmit,           // [IN] Emit scope in which the ModuleRef is to be created.
        IMetaModelCommon *pCommonImport,    // [IN] Import scope.
        mdModuleRef *ptkModuleRef);         // [OUT] Output token for ModuleRef.

    static HRESULT CreateModuleRefFromModuleRef(    // S_OK or error.
        CMiniMdRW   *pMiniMdEmit,           // [IN] Emit scope.
        IMetaModelCommon *pCommon,          // [IN] Import scope.
        mdModuleRef tkModuleRef,            // [IN] ModuleRef token.
        mdModuleRef *ptkModuleRef);         // [OUT] ModuleRef token in the emit scope.

    static HRESULT CreateModuleRefFromExportedType(  // S_OK, S_FALSE or error.
        CMiniMdRW   *pAssemEmit,            // [IN] Import assembly scope.
        CMiniMdRW   *pMiniMdEmit,           // [IN] Emit scope.
        mdExportedType   tkExportedType,              // [IN] ExportedType token in Assembly emit scope.
        mdModuleRef *ptkModuleRef);         // [OUT] ModuleRef token in the emit scope.

    static HRESULT CreateAssemblyRefFromAssembly( // S_OK or error.
        CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Emit assembly scope.
        CMiniMdRW   *pMiniMdModuleEmit,     // [IN] Emit module scope.
        IMetaModelCommon *pCommonAssemImport, // [IN] Assembly import scope.
    	const void 	*pbHashValue,	        // [IN] Hash Blob for Assembly.
    	ULONG 	    cbHashValue,	        // [IN] Count of bytes.
        mdAssemblyRef *ptkAssemblyRef);     // [OUT] AssemblyRef token.

    static HRESULT CompareAssemblyRefToAssembly(    // S_OK, S_FALSE or error.
        IMetaModelCommon *pCommonAssem1,    // [IN] Assembly that defines the AssemblyRef.
        mdAssemblyRef tkAssemRef,           // [IN] AssemblyRef.
        IMetaModelCommon *pCommonAssem2);   // [IN] Assembly against which the Ref is compared.

    static HRESULT CreateAssemblyRefFromAssemblyRef(
        CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Assembly emit scope.
        CMiniMdRW   *pMiniMdModuleEmit,     // [IN] Module emit scope
        IMetaModelCommon *pCommonImport,    // [IN] Scope to import the assembly ref from.
        mdAssemblyRef tkAssemRef,           // [IN] Assembly ref to be imported.
        mdAssemblyRef *ptkAssemblyRef);     // [OUT] AssemblyRef in the emit scope.
};

#endif // __IMPORTHELPER__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\mdperf.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDperf.cpp
//*****************************************************************************

#include "stdafx.h"
#include "MDPerf.h"

#ifdef MD_PERF_STATS_ENABLED

//-----------------------------------------------------------------------------
// Global array containing the name of the APIs. This is shared across 
// all instances of MDCompilerPerf.
//-----------------------------------------------------------------------------
char g_szNameOfAPI[LAST_MD_API][API_NAME_STR_SIZE];  

//-----------------------------------------------------------------------------
// Constructor. Initialize counters to 0. Initialize names of MD APIs.
//-----------------------------------------------------------------------------
MDCompilerPerf::MDCompilerPerf()
{
    // Initialize counters
    for (int idx=0; idx < LAST_MD_API; idx++)
    {
        MDPerfStats[idx].dwCalledNumTimes = 0;
        MDPerfStats[idx].dwQueryPerfCycles = 0;
    }

#undef MD_FUNC
#define MD_FUNC(MDTag)\
    strncpy(g_szNameOfAPI[MDTag ## _ENUM], #MDTag, API_NAME_STR_SIZE-1);

    MD_COMPILER_PERF_TABLE;  // Relies on the MD_FUNC defined above.
}

MDCompilerPerf::~MDCompilerPerf()
    {
        // Output the stats and cleanup.
        MetaDataPerfReport ();
    }
    
//-----------------------------------------------------------------------------
// Output stats. TODO: grow this into stats for per fautomation
//-----------------------------------------------------------------------------
void MDCompilerPerf::MetaDataPerfReport ()
{
    LARGE_INTEGER freqVal;
    DWORD totalCalls=0, totalCycles=0;
    
    if (!QueryPerformanceFrequency(&freqVal))
    {
        printf("Perf counters not supported\n");
        return;
    }
    
    for (int idx=0; idx < LAST_MD_API; idx++)
    {
        totalCalls += MDPerfStats[idx].dwCalledNumTimes;
        totalCycles += MDPerfStats[idx].dwQueryPerfCycles;
    }   
    
    if (!(totalCalls && totalCycles && freqVal.QuadPart))
    {
        // if any of above is 0 then things don't look good.
        printf("No data gathered ...\n");
        return;
    }

    printf("\n%-32.32s %-16.16s %-16.16s %-16.16s\n", "API Name", "# Calls", "Cycles", "Time (msec)");
    for (idx=0; idx < LAST_MD_API; idx++)
    {
        if(MDPerfStats[idx].dwCalledNumTimes != 0)
            printf( "%-32.32s %-9d [%3.2d%%] %-16d %-8.2f [%3.2d%%]\n", 
                    g_szNameOfAPI[idx],
                    MDPerfStats[idx].dwCalledNumTimes,
                    (MDPerfStats[idx].dwCalledNumTimes*100)/totalCalls,
                    MDPerfStats[idx].dwQueryPerfCycles,
                    ((float)MDPerfStats[idx].dwQueryPerfCycles*1000)/(float)freqVal.QuadPart,
                    (MDPerfStats[idx].dwQueryPerfCycles*100)/totalCycles);
    }   
    printf( "%-32.32s %-9d [100%%] %-16d %-8.2f [100%%]\n\n",
            "Total Stats",
            totalCalls,
            totalCycles,
            ((float)totalCycles*1000)/(float)freqVal.QuadPart);

}

#endif // #ifdef MD_PERF_STATS_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\mdperf.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Mdperf.h 
// 
//*****************************************************************************

#ifndef __MDCOMPILERPERF_H__
#define __MDCOMPILERPERF_H__

//#define MD_PERF_STATS_ENABLED

#ifdef MD_PERF_STATS_ENABLED

// Avoid dynamic allocs to display the API names.
#define API_NAME_STR_SIZE 80

//-----------------------------------------------------------------------------
// In order to add instrumentation for an API, two changes have to be made. 
// One, add the API name in the table below (MD_TABLE). 
// Second, add two lines of code (shown below) in the implementation 
// of the API itself. e.g.
//      RegMeta::MyNewMetataDataAPI(...)
//      {
//           LOG(...);
//           START_MD_PERF();        // <------ add this line as is.
//           .... 
//           // API implementation
//       ErrExit:
//           STOP_MD_PERF(RegMeta_MyNewMetaDataAPI); // <---------- add this line with the appropriate name
//           return (hr);
//      ]
//  
//-----------------------------------------------------------------------------
#define MD_COMPILER_PERF_TABLE\
    MD_FUNC(SaveToMemory)\
    MD_FUNC(DefineMethod)\
    MD_FUNC(DefineMethodImpl)\
    MD_FUNC(SetRVA)\
    MD_FUNC(DefineTypeRefByName)\
    MD_FUNC(DefineImportType)\
    MD_FUNC(DefineMemberRef)\
    MD_FUNC(DefineImportMember)\
    MD_FUNC(DefineEvent)\
    MD_FUNC(SetClassLayout)\
    MD_FUNC(DeleteClassLayout)\
    MD_FUNC(SetFieldMarshal)\
    MD_FUNC(DeleteFieldMarshal)\
    MD_FUNC(DefinePermissionSet)\
    MD_FUNC(SetMemberIndex)\
    MD_FUNC(GetTokenFromSig)\
    MD_FUNC(DefineModuleRef)\
    MD_FUNC(SetParent)\
    MD_FUNC(GetTokenFromTypeSpec)\
    MD_FUNC(SetSymbolBindingPath)\
    MD_FUNC(DefineUserString)\
    MD_FUNC(DeleteToken)\
    MD_FUNC(SetTypeDefProps)\
    MD_FUNC(DefineNestedType)\
    MD_FUNC(SetMethodProps)\
    MD_FUNC(SetEventProps)\
    MD_FUNC(SetPermissionSetProps)\
    MD_FUNC(DefinePinvokeMap)\
    MD_FUNC(SetPinvokeMap)\
    MD_FUNC(DeletePinvokeMap)\
    MD_FUNC(DefineField)\
    MD_FUNC(DefineProperty)\
    MD_FUNC(DefineParam)\
    MD_FUNC(SetFieldProps)\
    MD_FUNC(SetPropertyProps)\
    MD_FUNC(SetParamProps)\
    MD_FUNC(EnumMembers)\
    MD_FUNC(EnumMembersWithName)\
    MD_FUNC(EnumMethods)\
    MD_FUNC(EnumMethodsWithName)\
    MD_FUNC(EnumFields)\
    MD_FUNC(EnumFieldsWithName)\
    MD_FUNC(EnumParams)\
    MD_FUNC(EnumMemberRefs)\
    MD_FUNC(EnumMethodImpls)\
    MD_FUNC(EnumPermissionSets)\
    MD_FUNC(FindMember)\
    MD_FUNC(FindMethod)\
    MD_FUNC(FindField)\
    MD_FUNC(FindMemberRef)\
    MD_FUNC(GetMethodProps)\
    MD_FUNC(GetMemberRefProps)\
    MD_FUNC(EnumProperties)\
    MD_FUNC(EnumEvents)\
    MD_FUNC(GetEventProps)\
    MD_FUNC(EnumMethodSemantics)\
    MD_FUNC(GetMethodSemantics)\
    MD_FUNC(GetClassLayout)\
    MD_FUNC(GetFieldMarshal)\
    MD_FUNC(GetRVA)\
    MD_FUNC(GetPermissionSetProps)\
    MD_FUNC(GetSigFromToken)\
    MD_FUNC(GetModuleRefProps)\
    MD_FUNC(EnumModuleRefs)\
    MD_FUNC(GetTypeSpecFromToken)\
    MD_FUNC(GetNameFromToken)\
    MD_FUNC(GetSymbolBindingPath)\
    MD_FUNC(EnumUnresolvedMethods)\
    MD_FUNC(GetUserString)\
    MD_FUNC(GetPinvokeMap)\
    MD_FUNC(EnumSignatures)\
    MD_FUNC(EnumTypeSpecs)\
    MD_FUNC(EnumUserStrings)\
    MD_FUNC(GetParamForMethodIndex)\
    MD_FUNC(GetMemberProps)\
    MD_FUNC(GetFieldProps)\
    MD_FUNC(GetPropertyProps)\
    MD_FUNC(GetParamProps)\
    MD_FUNC(SetModuleProps)\
    MD_FUNC(Save)\
    MD_FUNC(SaveToStream)\
    MD_FUNC(GetSaveSize)\
    MD_FUNC(Merge)\
    MD_FUNC(DefineCustomAttribute)\
    MD_FUNC(SetCustomAttributeValue)\
    MD_FUNC(DefineSecurityAttributeSet)\
    MD_FUNC(UnmarkAll)\
    MD_FUNC(MarkToken)\
    MD_FUNC(IsTokenMarked)\
    MD_FUNC(DefineTypeDef)\
    MD_FUNC(SetHandler)\
    MD_FUNC(CountEnum)\
    MD_FUNC(ResetEnum)\
    MD_FUNC(EnumTypeDefs)\
    MD_FUNC(EnumInterfaceImpls)\
    MD_FUNC(EnumTypeRefs)\
    MD_FUNC(FindTypeDefByName)\
    MD_FUNC(FindTypeDefByGUID)\
    MD_FUNC(GetScopeProps)\
    MD_FUNC(GetModuleFromScope)\
    MD_FUNC(GetTypeDefProps)\
    MD_FUNC(GetInterfaceImplProps)\
    MD_FUNC(GetCustomAttributeByName)\
    MD_FUNC(GetTypeRefProps)\
    MD_FUNC(ResolveTypeRef)\
    MD_FUNC(EnumCustomAttributes)\
    MD_FUNC(GetCustomAttributeProps)\
    MD_FUNC(FindTypeRef)\
    MD_FUNC(RefToDefOptimization)\
    MD_FUNC(ProcessFilter)\
    MD_FUNC(DefineAssembly)\
    MD_FUNC(DefineAssemblyRef)\
    MD_FUNC(DefineFile)\
    MD_FUNC(DefineExportedType)\
    MD_FUNC(DefineManifestResource)\
    MD_FUNC(DefineExecutionLocation)\
    MD_FUNC(SetAssemblyProps)\
    MD_FUNC(SetAssemblyRefProps)\
    MD_FUNC(SetFileProps)\
    MD_FUNC(SetExportedTypeProps)\
    MD_FUNC(GetAssemblyProps)\
    MD_FUNC(GetAssemblyRefProps)\
    MD_FUNC(GetFileProps)\
    MD_FUNC(GetExportedTypeProps)\
    MD_FUNC(GetManifestResourceProps)\
    MD_FUNC(GetExecutionLocationProps)\
    MD_FUNC(EnumAssemblyRefs)\
    MD_FUNC(EnumFiles)\
    MD_FUNC(EnumExportedTypes)\
    MD_FUNC(EnumManifestResources)\
    MD_FUNC(EnumExecutionLocations)\
    MD_FUNC(GetAssemblyFromScope)\
    MD_FUNC(FindExportedTypeByName)\
    MD_FUNC(FindManifestResourceByName)\
    MD_FUNC(FindAssembliesByName)

//-----------------------------------------------------------------------------
// Create an enum of all the API names. This is the index to access the APIs.
//-----------------------------------------------------------------------------
#undef MD_FUNC
#define MD_FUNC(MDTag)\
    MDTag ## _ENUM,

typedef enum _MDAPIs
{
    MD_COMPILER_PERF_TABLE
    LAST_MD_API
} MDApis;

//-----------------------------------------------------------------------------
// Declare the struct which contais all the interesting stats for a particular 
// API call.
//-----------------------------------------------------------------------------
typedef struct _MDAPIPerfData
{
    DWORD dwQueryPerfCycles;             // # of cycles spent in this call
    DWORD dwCalledNumTimes;              // # of times this API was called
} MDAPIPerfData;

    
//-----------------------------------------------------------------------------
// MDCompilerPerf
//-----------------------------------------------------------------------------
class MDCompilerPerf 
{
public:
    MDCompilerPerf();
    ~MDCompilerPerf();
    
private:
    MDAPIPerfData MDPerfStats[LAST_MD_API];
    
    void MetaDataPerfReport ();
};

// Note that this macro declares a local var. 
#define START_MD_PERF()\
    LARGE_INTEGER __startVal;\
    QueryPerformanceCounter(&__startVal); 

#undef MD_FUNC
#define MD_FUNC(MDTag)\
    MDTag ## _ENUM

// Note that this macro uses the local var startVal declared in START_MD_PERF()
#define STOP_MD_PERF(MDTag)\
    LARGE_INTEGER __stopVal;\
    QueryPerformanceCounter(&__stopVal);\
    m_MDCompilerPerf.MDPerfStats[MD_FUNC(MDTag)].dwCalledNumTimes++;\
    m_MDCompilerPerf.MDPerfStats[MD_FUNC(MDTag)].dwQueryPerfCycles += (DWORD)(__stopVal.QuadPart - __startVal.QuadPart);
    
#else // #ifdef MD_PERF_STATS_ENABLED

#define START_MD_PERF()
#define STOP_MD_PERF(MDTag)

#endif // #ifdef MD_PERF_STATS_ENABLED

#endif // __MDCOMPILERPERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\mdvalidator.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDValidator.cpp
//
// Implementation for the MetaData validator.
//
//*****************************************************************************
#include "stdafx.h"
#include "RegMeta.h"
#include "ImportHelper.h"
#include <ivehandler_i.c>

//-----------------------------------------------------------------------------
// Application specific debug macro.
#define IfBreakGo(EXPR) \
do {if ((EXPR) != S_OK) IfFailGo(VLDTR_E_INTERRUPTED); } while (0)

//-----------------------------------------------------------------------------
// To avoid multiple validation of the same thing:
struct ValidationResult
{
    mdToken     tok;
    HRESULT     hr;
};
ValidationResult*               g_rValidated=NULL; // allocated in ValidateMetaData
unsigned                        g_nValidated=0;
//-----------------------------------------------------------------------------

#define BASE_OBJECT_CLASSNAME   "Object"
#define BASE_NAMESPACE          "System"
#define BASE_VTYPE_CLASSNAME    "ValueType"
#define BASE_ENUM_CLASSNAME     "Enum"
#define BASE_VALUE_FIELDNAME    "value__"
#define BASE_CTOR_NAME          ".ctor"
#define BASE_CCTOR_NAME         ".cctor"
// as defined in SRC\Tools\CorOpt\common.h and SRC\Tools\ilcover\instr\common.h
#define MAX_CLASSNAME_LENGTH 1024
//-----------------------------------------------------------------------------
// Class names used in long form signatures (namespace is always "System")
unsigned g_NumSigLongForms = 19;
LPCSTR   g_SigLongFormName[] = {
    "String",
    "______", // "Object", // uncomment when EE handles ELEMENT_TYPE_OBJECT
    "Boolean",
    "Char",
    "Byte",
    "SByte",
    "UInt16",
    "Int16",
    "UInt32",
    "Int32",
    "UInt64",
    "Int64",
    "Single",
    "Double",
    "SysInt",
    "SysUInt",
    "SingleResult",
    "Void",
    "IntPtr"
};
mdToken g_tkEntryPoint;
bool    g_fValidatingMscorlib;
bool    g_fIsDLL;
//-----------------------------------------------------------------------------

// Forward declarations for helper functions.

static HRESULT _AllocSafeVariantArrayVector( // Return status.
    VARIANT     *rVar,                  // [IN] Variant array.
    long        cElem,                  // [IN] Size of the array.
    SAFEARRAY   **ppArray);             // [OUT] Double pointer to SAFEARRAY.

static HRESULT _ValidateErrorHelper(
    ULONG       ulVal,                  // [IN] UI4 value.
    VARIANT     *rVar,                  // [IN] VARIANT pointer.
    SAFEARRAY   **ppsa);                // [OUT] Double pointer to SAFEARRAY.

static HRESULT _ValidateErrorHelper(
    ULONG       ulVal1,                 // [IN] UI4 value1.
    ULONG       ulVal2,                 // [IN] UI4 value2.
    VARIANT     *rVar,                  // [IN] VARIANT pointer.
    SAFEARRAY   **ppsa);                // [OUT] Double pointer to SAFEARRAY.
    
static HRESULT _ValidateErrorHelper(
    ULONG       ulVal1,                 // [IN] UI4 value1.
    ULONG       ulVal2,                 // [IN] UI4 value2.
    ULONG       ulVal3,                 // [IN] UI4 value3.
    VARIANT     *rVar,                  // [IN] VARIANT pointer.
    SAFEARRAY   **ppsa);                // [OUT] Double pointer to SAFEARRAY.

static HRESULT _FindClassLayout(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
    mdTypeDef   tkParent,               // [IN] the parent that ClassLayout is associated with
    RID         *clRid,                 // [OUT] rid for the ClassLayout.
    RID         rid);                   // [IN] rid to be ignored.

static HRESULT _FindFieldLayout(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
    mdFieldDef  tkParent,               // [IN] the parent that FieldLayout is associated with
    RID         *flRid,                 // [OUT] rid for the FieldLayout record.
    RID         rid);                   // [IN] rid to be ignored.

static BOOL _IsValidLocale(LPCUTF8 szLocale);

// NULL VEContext.
static VEContext g_VECtxtNil = { 0, 0 };

// Macro for destroying safe array.  Failure to destroy SAFEARRAY overrides
// the existing failures since the former is more drastic.
#define DESTROY_SAFEARRAY_AND_RETURN()                  \
    if (psa)                                            \
    {                                                   \
        hrSave = SafeArrayDestroy(psa);                 \
        if (FAILED(hrSave))                             \
            hr = hrSave;                                \
    }                                                   \
    return hr;                                          \

// Macro to see if a given OS platform id is invalid.
#define INVALIDOSPLATFORMID(id)                         \
        ((id) != VER_PLATFORM_WIN32s &&                 \
        (id) != VER_PLATFORM_WIN32_WINDOWS &